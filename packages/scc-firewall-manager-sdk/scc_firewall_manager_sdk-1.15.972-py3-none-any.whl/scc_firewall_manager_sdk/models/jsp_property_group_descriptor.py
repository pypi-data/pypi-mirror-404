# coding: utf-8

"""
    Cisco Security Cloud Control Firewall Manager API

    Use the documentation to explore the endpoints Security Cloud Control Firewall Manager has to offer

    The version of the OpenAPI document: 1.9.0
    Contact: cdo.tac@cisco.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class JspPropertyGroupDescriptor(BaseModel):
    """
    JspPropertyGroupDescriptor
    """ # noqa: E501
    buffer: Optional[StrictStr] = None
    default_content_type: Optional[StrictStr] = Field(default=None, alias="defaultContentType")
    deferred_syntax_allowed_as_literal: Optional[StrictStr] = Field(default=None, alias="deferredSyntaxAllowedAsLiteral")
    el_ignored: Optional[StrictStr] = Field(default=None, alias="elIgnored")
    error_on_el_not_found: Optional[StrictStr] = Field(default=None, alias="errorOnELNotFound")
    error_on_undeclared_namespace: Optional[StrictStr] = Field(default=None, alias="errorOnUndeclaredNamespace")
    include_codas: Optional[List[StrictStr]] = Field(default=None, alias="includeCodas")
    include_preludes: Optional[List[StrictStr]] = Field(default=None, alias="includePreludes")
    is_xml: Optional[StrictStr] = Field(default=None, alias="isXml")
    page_encoding: Optional[StrictStr] = Field(default=None, alias="pageEncoding")
    scripting_invalid: Optional[StrictStr] = Field(default=None, alias="scriptingInvalid")
    trim_directive_whitespaces: Optional[StrictStr] = Field(default=None, alias="trimDirectiveWhitespaces")
    url_patterns: Optional[List[StrictStr]] = Field(default=None, alias="urlPatterns")
    __properties: ClassVar[List[str]] = ["buffer", "defaultContentType", "deferredSyntaxAllowedAsLiteral", "elIgnored", "errorOnELNotFound", "errorOnUndeclaredNamespace", "includeCodas", "includePreludes", "isXml", "pageEncoding", "scriptingInvalid", "trimDirectiveWhitespaces", "urlPatterns"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of JspPropertyGroupDescriptor from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of JspPropertyGroupDescriptor from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "buffer": obj.get("buffer"),
            "defaultContentType": obj.get("defaultContentType"),
            "deferredSyntaxAllowedAsLiteral": obj.get("deferredSyntaxAllowedAsLiteral"),
            "elIgnored": obj.get("elIgnored"),
            "errorOnELNotFound": obj.get("errorOnELNotFound"),
            "errorOnUndeclaredNamespace": obj.get("errorOnUndeclaredNamespace"),
            "includeCodas": obj.get("includeCodas"),
            "includePreludes": obj.get("includePreludes"),
            "isXml": obj.get("isXml"),
            "pageEncoding": obj.get("pageEncoding"),
            "scriptingInvalid": obj.get("scriptingInvalid"),
            "trimDirectiveWhitespaces": obj.get("trimDirectiveWhitespaces"),
            "urlPatterns": obj.get("urlPatterns")
        })
        return _obj


