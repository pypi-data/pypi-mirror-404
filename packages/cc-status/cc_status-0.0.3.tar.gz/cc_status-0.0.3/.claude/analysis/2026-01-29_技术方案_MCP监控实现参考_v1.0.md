# MCP ç›‘æ§å®ç°å‚è€ƒæ–¹æ¡ˆ

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¥æœŸ**: 2026-01-29
**æ–‡æ¡£ç±»å‹**: æŠ€æœ¯æ–¹æ¡ˆ
**ä½œè€…**: Claude Sonnet 4.5
**å‚è€ƒé¡¹ç›®**: claude-code-statusline (Bash)

---

## ğŸ“‹ æ–‡æ¡£ç›®æ ‡

æœ¬æ–‡æ¡£æä¾› **MCP (Model Context Protocol) ç›‘æ§** çš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼Œå¯ç›´æ¥åº”ç”¨åˆ°å½“å‰ Python é¡¹ç›®ä¸­ã€‚

---

## ä¸€ã€MCP ç›‘æ§æ¦‚è¿°

### 1.1 ä»€ä¹ˆæ˜¯ MCP ç›‘æ§ï¼Ÿ

MCP (Model Context Protocol) æ˜¯ Claude Code ä¸å¤–éƒ¨æœåŠ¡å™¨é€šä¿¡çš„åè®®ã€‚MCP ç›‘æ§ç”¨äºå®æ—¶è·Ÿè¸ªå·²é…ç½®çš„ MCP æœåŠ¡å™¨è¿æ¥çŠ¶æ€ã€‚

### 1.2 æ ¸å¿ƒä»·å€¼

| ä»·å€¼ | è¯´æ˜ |
|------|------|
| **çŠ¶æ€å¯è§æ€§** | å®æ—¶æ˜¾ç¤ºå“ªäº› MCP æœåŠ¡å™¨å·²è¿æ¥ |
| **æ•…éšœè¯Šæ–­** | å¿«é€Ÿè¯†åˆ«è¿æ¥å¤±è´¥çš„æœåŠ¡å™¨ |
| **å¥åº·æ£€æŸ¥** | æ•´ä½“å¥åº·çŠ¶æ€è¯„ä¼° |
| **ç”¨æˆ·ä½“éªŒ** | è®©ç”¨æˆ·äº†è§£å¯ç”¨å·¥å…·å’Œèµ„æº |

### 1.3 æ˜¾ç¤ºæ•ˆæœç¤ºä¾‹

```
âœ… MCP: 3/3  (æ‰€æœ‰æœåŠ¡å™¨å·²è¿æ¥ - ç»¿è‰²)
âš ï¸  MCP: 2/3  (éƒ¨åˆ†æœåŠ¡å™¨è¿æ¥ - é»„è‰²)
âŒ MCP: 0/3  (æ— æœåŠ¡å™¨è¿æ¥ - çº¢è‰²)
ğŸ” MCP: ?/?  (æŸ¥è¯¢å¤±è´¥ - çº¢è‰²)
```

---

## äºŒã€å®ç°æ¶æ„

### 2.1 æ¨¡å—ç»“æ„

```
src/cc_statusline/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ mcp.py              # MCP ç›‘æ§æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ McpMonitor      # ä¸»ç›‘æ§ç±»
â”‚   â”‚   â”œâ”€â”€ McpServer       # æœåŠ¡å™¨æ•°æ®ç±»
â”‚   â”‚   â””â”€â”€ McpStatus       # çŠ¶æ€èšåˆç±»
â”‚   â””â”€â”€ cache.py            # ç¼“å­˜ç³»ç»Ÿ
â””â”€â”€ components/
    â””â”€â”€ mcp_status.py       # MCP çŠ¶æ€æ ç»„ä»¶
```

### 2.2 ç±»å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   McpMonitor    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - timeout: int  â”‚
â”‚ - cache: Cache  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + get_status()  â”‚
â”‚ + get_health()  â”‚
â”‚ + get_display() â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ ä½¿ç”¨
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   McpStatus     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - servers: []   â”‚
â”‚ - total: int    â”‚
â”‚ - connected: intâ”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ + to_string()   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€æ ¸å¿ƒå®ç°

### 3.1 æ•°æ®æ¨¡å‹

```python
# src/cc_statusline/core/mcp.py
from dataclasses import dataclass
from enum import Enum
from typing import Optional

class McpServerStatus(str, Enum):
    """MCP æœåŠ¡å™¨çŠ¶æ€æšä¸¾"""
    CONNECTED = "connected"
    DISCONNECTED = "disconnected"
    ERROR = "error"
    UNKNOWN = "unknown"

@dataclass
class McpServer:
    """MCP æœåŠ¡å™¨æ•°æ®ç±»"""
    name: str
    status: McpServerStatus
    error_message: Optional[str] = None

    def is_connected(self) -> bool:
        return self.status == McpServerStatus.CONNECTED

@dataclass
class McpStatus:
    """MCP çŠ¶æ€èšåˆç±»"""
    servers: list[McpServer]
    query_success: bool = True

    @property
    def total(self) -> int:
        return len(self.servers)

    @property
    def connected(self) -> int:
        return sum(1 for s in self.servers if s.is_connected())

    @property
    def disconnected(self) -> int:
        return self.total - self.connected

    def to_string(self) -> str:
        """è¿”å› '2/3' æ ¼å¼çš„çŠ¶æ€å­—ç¬¦ä¸²"""
        if not self.query_success:
            return "?/?"
        return f"{self.connected}/{self.total}"

    def get_health(self) -> str:
        """
        è¿”å›å¥åº·çŠ¶æ€:
        - healthy: å…¨éƒ¨è¿æ¥
        - partial: éƒ¨åˆ†è¿æ¥
        - unhealthy: æ— è¿æ¥
        - no_servers: æ— æœåŠ¡å™¨é…ç½®
        - error: æŸ¥è¯¢å¤±è´¥
        """
        if not self.query_success:
            return "error"
        if self.total == 0:
            return "no_servers"
        if self.connected == self.total:
            return "healthy"
        if self.connected > 0:
            return "partial"
        return "unhealthy"
```

### 3.2 McpMonitor æ ¸å¿ƒç±»

```python
# src/cc_statusline/core/mcp.py (ç»­)
import subprocess
import re
from pathlib import Path

class McpMonitor:
    """MCP æœåŠ¡å™¨ç›‘æ§ç±»"""

    # çŠ¶æ€æ¨¡å¼å¸¸é‡
    PATTERN_CONNECTED = "âœ“ Connected"
    PATTERN_DISCONNECTED = "âœ— Disconnected"
    PATTERN_ERROR = "âŒ Error"

    # æœåŠ¡å™¨åç§°éªŒè¯æ­£åˆ™
    SERVER_NAME_PATTERN = re.compile(
        r"^([a-zA-Z0-9][a-zA-Z0-9_-]*[a-zA-Z0-9]|[a-zA-Z0-9]):\s"
    )

    def __init__(
        self,
        timeout: int = 10,
        cache_ttl: int = 300,  # 5åˆ†é’Ÿç¼“å­˜
        cache_dir: Optional[Path] = None
    ):
        """
        Args:
            timeout: claude mcp list å‘½ä»¤è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            cache_ttl: ç¼“å­˜ç”Ÿå­˜æ—¶é—´ï¼ˆç§’ï¼‰
            cache_dir: ç¼“å­˜ç›®å½•ï¼ˆNone åˆ™ä½¿ç”¨é»˜è®¤ï¼‰
        """
        self.timeout = timeout
        self.cache_ttl = cache_ttl
        self.cache = self._init_cache(cache_dir)

    def _init_cache(self, cache_dir: Optional[Path]):
        """åˆå§‹åŒ–ç¼“å­˜ç³»ç»Ÿ"""
        from .cache import Cache
        return Cache(
            cache_dir=cache_dir,
            default_ttl=self.cache_ttl
        )

    def get_status(self) -> McpStatus:
        """
        è·å– MCP æœåŠ¡å™¨çŠ¶æ€ï¼ˆå¸¦ç¼“å­˜ï¼‰

        Returns:
            McpStatus: æœåŠ¡å™¨çŠ¶æ€å¯¹è±¡
        """
        cache_key = "mcp_status"

        # å°è¯•ä»ç¼“å­˜è·å–
        if cached := self.cache.get(cache_key):
            return cached

        # æ‰§è¡ŒæŸ¥è¯¢
        mcp_output = self._execute_mcp_list()
        status = self._parse_mcp_output(mcp_output)

        # å†™å…¥ç¼“å­˜
        self.cache.set(cache_key, status)

        return status

    def _execute_mcp_list(self) -> Optional[str]:
        """
        æ‰§è¡Œ claude mcp list å‘½ä»¤

        Returns:
            str: å‘½ä»¤è¾“å‡ºï¼Œå¤±è´¥è¿”å› None
        """
        # æ£€æŸ¥ claude CLI æ˜¯å¦å¯ç”¨
        if not self._is_claude_cli_available():
            return None

        try:
            result = subprocess.run(
                ["claude", "mcp", "list"],
                capture_output=True,
                text=True,
                timeout=self.timeout,
                check=False  # ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œæ‰‹åŠ¨æ£€æŸ¥è¿”å›ç 
            )

            # è¿”å›ç ä¸º 0 è¡¨ç¤ºæˆåŠŸ
            if result.returncode == 0:
                return result.stdout
            else:
                return None

        except subprocess.TimeoutExpired:
            # è¶…æ—¶è¿”å› None
            return None
        except FileNotFoundError:
            # claude å‘½ä»¤ä¸å­˜åœ¨
            return None
        except Exception:
            # å…¶ä»–å¼‚å¸¸
            return None

    def _is_claude_cli_available(self) -> bool:
        """æ£€æŸ¥ claude CLI æ˜¯å¦å¯ç”¨"""
        try:
            result = subprocess.run(
                ["claude", "--version"],
                capture_output=True,
                timeout=2,
                check=False
            )
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def _parse_mcp_output(self, output: Optional[str]) -> McpStatus:
        """
        è§£æ claude mcp list è¾“å‡º

        Args:
            output: å‘½ä»¤è¾“å‡ºå­—ç¬¦ä¸²

        Returns:
            McpStatus: è§£æåçš„çŠ¶æ€å¯¹è±¡
        """
        if output is None:
            return McpStatus(servers=[], query_success=False)

        servers = []
        for line in output.splitlines():
            line = line.strip()

            # è·³è¿‡ç©ºè¡Œå’Œæ£€æŸ¥è¡Œ
            if not line or line.startswith("Checking"):
                continue

            # è§£ææœåŠ¡å™¨åç§°
            server_name = self._parse_server_name(line)
            if not server_name:
                continue

            # ç¡®å®šæœåŠ¡å™¨çŠ¶æ€
            status = self._determine_server_status(line)

            servers.append(McpServer(name=server_name, status=status))

        return McpStatus(servers=servers, query_success=True)

    def _parse_server_name(self, line: str) -> Optional[str]:
        """
        ä»è¾“å‡ºè¡Œä¸­æå–æœåŠ¡å™¨åç§°

        Args:
            line: è¾“å‡ºè¡Œ (ä¾‹: "serena: âœ“ Connected")

        Returns:
            str: æœåŠ¡å™¨åç§°ï¼Œè§£æå¤±è´¥è¿”å› None
        """
        match = self.SERVER_NAME_PATTERN.match(line)
        if not match:
            return None

        server_name = match.group(1)

        # å®‰å…¨æ£€æŸ¥: åç§°é•¿åº¦é™åˆ¶
        if len(server_name) > 100:
            return None

        return server_name

    def _determine_server_status(self, line: str) -> McpServerStatus:
        """
        ä»è¾“å‡ºè¡Œç¡®å®šæœåŠ¡å™¨çŠ¶æ€

        Args:
            line: è¾“å‡ºè¡Œ

        Returns:
            McpServerStatus: æœåŠ¡å™¨çŠ¶æ€
        """
        if self.PATTERN_CONNECTED in line:
            return McpServerStatus.CONNECTED
        elif self.PATTERN_DISCONNECTED in line:
            return McpServerStatus.DISCONNECTED
        elif self.PATTERN_ERROR in line:
            return McpServerStatus.ERROR
        else:
            return McpServerStatus.UNKNOWN

    def get_health(self) -> str:
        """
        è·å– MCP æ•´ä½“å¥åº·çŠ¶æ€

        Returns:
            str: å¥åº·çŠ¶æ€
                - "healthy": å…¨éƒ¨è¿æ¥
                - "partial": éƒ¨åˆ†è¿æ¥
                - "unhealthy": æ— è¿æ¥
                - "no_servers": æ— æœåŠ¡å™¨é…ç½®
                - "error": æŸ¥è¯¢å¤±è´¥
                - "no_cli": CLI ä¸å¯ç”¨
        """
        if not self._is_claude_cli_available():
            return "no_cli"

        status = self.get_status()
        return status.get_health()

    def get_display(self, color: bool = True) -> str:
        """
        è·å–æ ¼å¼åŒ–çš„æ˜¾ç¤ºå­—ç¬¦ä¸²

        Args:
            color: æ˜¯å¦åŒ…å« ANSI é¢œè‰²ä»£ç 

        Returns:
            str: æ ¼å¼åŒ–çš„æ˜¾ç¤ºå­—ç¬¦ä¸²
        """
        status = self.get_status()
        status_str = status.to_string()

        if not color:
            return f"MCP: {status_str}"

        # æ ¹æ®å¥åº·çŠ¶æ€é€‰æ‹©é¢œè‰²
        health = status.get_health()
        color_code = self._get_color_code(health)

        return f"\033[{color_code}mMCP: {status_str}\033[0m"

    def _get_color_code(self, health: str) -> str:
        """
        æ ¹æ®å¥åº·çŠ¶æ€è¿”å› ANSI é¢œè‰²ä»£ç 

        Args:
            health: å¥åº·çŠ¶æ€

        Returns:
            str: ANSI é¢œè‰²ä»£ç 
        """
        color_map = {
            "healthy": "92",      # äº®ç»¿è‰²
            "partial": "33",      # é»„è‰²
            "unhealthy": "31",    # çº¢è‰²
            "error": "31",        # çº¢è‰²
            "no_servers": "2",    # ç°è‰²
            "no_cli": "31"        # çº¢è‰²
        }
        return color_map.get(health, "0")  # é»˜è®¤æ— é¢œè‰²
```

---

## å››ã€ç¼“å­˜ç³»ç»Ÿå®ç°

### 4.1 ç®€åŒ–ç¼“å­˜è®¾è®¡

```python
# src/cc_statusline/core/cache.py
import pickle
import time
from pathlib import Path
from typing import Any, Optional
import fcntl  # Unix æ–‡ä»¶é”
from dataclasses import dataclass

@dataclass
class CacheEntry:
    """ç¼“å­˜æ¡ç›®"""
    value: Any
    expires_at: float

class Cache:
    """ç®€åŒ–çš„ç¼“å­˜ç³»ç»Ÿï¼ˆå¸¦æ–‡ä»¶é”ï¼‰"""

    def __init__(
        self,
        cache_dir: Optional[Path] = None,
        default_ttl: int = 300
    ):
        """
        Args:
            cache_dir: ç¼“å­˜ç›®å½•ï¼ˆNone åˆ™ä½¿ç”¨ ~/.cache/cc-statuslineï¼‰
            default_ttl: é»˜è®¤è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
        """
        self.cache_dir = cache_dir or self._get_default_cache_dir()
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.default_ttl = default_ttl

    def _get_default_cache_dir(self) -> Path:
        """è·å–é»˜è®¤ç¼“å­˜ç›®å½•"""
        if (xdg_cache := Path.home() / ".cache").exists():
            return xdg_cache / "cc-statusline"
        return Path.home() / ".cc-statusline" / "cache"

    def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜å€¼"""
        cache_file = self._get_cache_file(key)

        if not cache_file.exists():
            return None

        try:
            with open(cache_file, "rb") as f:
                # è·å–å…±äº«é”ï¼ˆè¯»é”ï¼‰
                fcntl.flock(f.fileno(), fcntl.LOCK_SH)
                try:
                    entry: CacheEntry = pickle.load(f)
                finally:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)

            # æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
            if time.time() > entry.expires_at:
                cache_file.unlink(missing_ok=True)
                return None

            return entry.value

        except Exception:
            # ç¼“å­˜è¯»å–å¤±è´¥ï¼Œåˆ é™¤æŸåçš„ç¼“å­˜æ–‡ä»¶
            cache_file.unlink(missing_ok=True)
            return None

    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """è®¾ç½®ç¼“å­˜å€¼"""
        cache_file = self._get_cache_file(key)
        ttl = ttl or self.default_ttl

        entry = CacheEntry(
            value=value,
            expires_at=time.time() + ttl
        )

        # åŸå­æ€§å†™å…¥ï¼šä¸´æ—¶æ–‡ä»¶ â†’ é‡å‘½å
        temp_file = cache_file.with_suffix(".tmp")

        try:
            with open(temp_file, "wb") as f:
                # è·å–ç‹¬å é”ï¼ˆå†™é”ï¼‰
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                try:
                    pickle.dump(entry, f)
                finally:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)

            # åŸå­æ€§é‡å‘½å
            temp_file.replace(cache_file)

        except Exception:
            # å†™å…¥å¤±è´¥ï¼Œæ¸…ç†ä¸´æ—¶æ–‡ä»¶
            temp_file.unlink(missing_ok=True)

    def _get_cache_file(self, key: str) -> Path:
        """è·å–ç¼“å­˜æ–‡ä»¶è·¯å¾„"""
        # ä½¿ç”¨å“ˆå¸Œé¿å…ç‰¹æ®Šå­—ç¬¦é—®é¢˜
        import hashlib
        key_hash = hashlib.sha256(key.encode()).hexdigest()[:16]
        return self.cache_dir / f"{key_hash}.cache"

    def clear(self) -> None:
        """æ¸…ç©ºæ‰€æœ‰ç¼“å­˜"""
        for cache_file in self.cache_dir.glob("*.cache"):
            cache_file.unlink(missing_ok=True)
```

### 4.2 Windows å…¼å®¹æ€§å¤„ç†

```python
# src/cc_statusline/core/cache.py (ç»­)
import sys

# Windows éœ€è¦ä½¿ç”¨ msvcrt
if sys.platform == "win32":
    import msvcrt

    def _lock_file(f, exclusive: bool = False):
        """Windows æ–‡ä»¶é”"""
        mode = msvcrt.LK_NBLCK if exclusive else msvcrt.LK_NBRLCK
        msvcrt.locking(f.fileno(), mode, 1)

    def _unlock_file(f):
        """Windows è§£é”"""
        msvcrt.locking(f.fileno(), msvcrt.LK_UNLCK, 1)
else:
    def _lock_file(f, exclusive: bool = False):
        """Unix æ–‡ä»¶é”"""
        mode = fcntl.LOCK_EX if exclusive else fcntl.LOCK_SH
        fcntl.flock(f.fileno(), mode)

    def _unlock_file(f):
        """Unix è§£é”"""
        fcntl.flock(f.fileno(), fcntl.LOCK_UN)

# ä¿®æ”¹ Cache ç±»ä½¿ç”¨è·¨å¹³å°é”
class Cache:
    # ... (å‰é¢çš„ä»£ç ä¸å˜)

    def get(self, key: str) -> Optional[Any]:
        """è·å–ç¼“å­˜å€¼ï¼ˆè·¨å¹³å°ï¼‰"""
        cache_file = self._get_cache_file(key)

        if not cache_file.exists():
            return None

        try:
            with open(cache_file, "rb") as f:
                _lock_file(f, exclusive=False)  # è¯»é”
                try:
                    entry: CacheEntry = pickle.load(f)
                finally:
                    _unlock_file(f)

            if time.time() > entry.expires_at:
                cache_file.unlink(missing_ok=True)
                return None

            return entry.value

        except Exception:
            cache_file.unlink(missing_ok=True)
            return None
```

---

## äº”ã€çŠ¶æ€æ ç»„ä»¶é›†æˆ

### 5.1 ç»„ä»¶å®ç°

```python
# src/cc_statusline/components/mcp_status.py
from ..core.mcp import McpMonitor

class McpStatusComponent:
    """MCP çŠ¶æ€æ ç»„ä»¶"""

    def __init__(self, config: dict):
        """
        Args:
            config: ç»„ä»¶é…ç½®
                - enabled: æ˜¯å¦å¯ç”¨
                - timeout: è¶…æ—¶æ—¶é—´
                - show_icon: æ˜¯å¦æ˜¾ç¤ºå›¾æ ‡
                - show_details: æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        """
        self.config = config
        self.monitor = McpMonitor(
            timeout=config.get("timeout", 10),
            cache_ttl=config.get("cache_ttl", 300)
        )

    def render(self) -> str:
        """
        æ¸²æŸ“ç»„ä»¶è¾“å‡º

        Returns:
            str: æ ¼å¼åŒ–çš„çŠ¶æ€æ å­—ç¬¦ä¸²
        """
        if not self.config.get("enabled", True):
            return ""

        status = self.monitor.get_status()
        health = status.get_health()

        # æ„å»ºè¾“å‡º
        parts = []

        # å›¾æ ‡
        if self.config.get("show_icon", True):
            icon = self._get_icon(health)
            parts.append(icon)

        # çŠ¶æ€æ–‡æœ¬
        status_text = self.monitor.get_display(
            color=self.config.get("color", True)
        )
        parts.append(status_text)

        # è¯¦ç»†ä¿¡æ¯
        if self.config.get("show_details", False):
            details = self._get_details(status)
            if details:
                parts.append(f"({details})")

        return " ".join(parts)

    def _get_icon(self, health: str) -> str:
        """è·å–å¥åº·çŠ¶æ€å›¾æ ‡"""
        icon_map = {
            "healthy": "âœ…",
            "partial": "âš ï¸",
            "unhealthy": "âŒ",
            "error": "ğŸ”",
            "no_servers": "ğŸ“­",
            "no_cli": "â›”"
        }
        return icon_map.get(health, "â“")

    def _get_details(self, status) -> str:
        """è·å–è¯¦ç»†ä¿¡æ¯"""
        if not status.query_success:
            return "query failed"

        if status.total == 0:
            return "no servers configured"

        # æ˜¾ç¤ºæ–­å¼€è¿æ¥çš„æœåŠ¡å™¨åç§°
        disconnected = [
            s.name for s in status.servers
            if not s.is_connected()
        ]

        if disconnected:
            return f"offline: {', '.join(disconnected)}"

        return "all connected"
```

---

## å…­ã€ä½¿ç”¨ç¤ºä¾‹

### 6.1 åŸºæœ¬ä½¿ç”¨

```python
from cc_statusline.core.mcp import McpMonitor

# åˆ›å»ºç›‘æ§å™¨
monitor = McpMonitor(timeout=10, cache_ttl=300)

# è·å–çŠ¶æ€
status = monitor.get_status()
print(f"è¿æ¥: {status.connected}/{status.total}")

# è·å–å¥åº·çŠ¶æ€
health = monitor.get_health()
print(f"å¥åº·: {health}")

# è·å–æ ¼å¼åŒ–æ˜¾ç¤º
display = monitor.get_display(color=True)
print(display)
```

### 6.2 ç»„ä»¶é›†æˆ

```python
from cc_statusline.components.mcp_status import McpStatusComponent

# åˆ›å»ºç»„ä»¶
component = McpStatusComponent(config={
    "enabled": True,
    "timeout": 10,
    "show_icon": True,
    "show_details": True,
    "color": True
})

# æ¸²æŸ“è¾“å‡º
output = component.render()
print(output)
# è¾“å‡ºç¤ºä¾‹: âœ… MCP: 3/3 (all connected)
```

---

## ä¸ƒã€æµ‹è¯•æ–¹æ¡ˆ

### 7.1 å•å…ƒæµ‹è¯•

```python
# tests/unit/test_mcp.py
import pytest
from unittest.mock import Mock, patch
from cc_statusline.core.mcp import (
    McpMonitor,
    McpStatus,
    McpServer,
    McpServerStatus
)

class TestMcpMonitor:
    """McpMonitor å•å…ƒæµ‹è¯•"""

    @pytest.fixture
    def monitor(self):
        """åˆ›å»ºæµ‹è¯•ç”¨ç›‘æ§å™¨"""
        return McpMonitor(timeout=5, cache_ttl=0)  # ç¦ç”¨ç¼“å­˜

    def test_parse_connected_server(self, monitor):
        """æµ‹è¯•è§£æå·²è¿æ¥çš„æœåŠ¡å™¨"""
        output = "serena: âœ“ Connected\n"
        status = monitor._parse_mcp_output(output)

        assert status.total == 1
        assert status.connected == 1
        assert status.servers[0].name == "serena"
        assert status.servers[0].status == McpServerStatus.CONNECTED

    def test_parse_disconnected_server(self, monitor):
        """æµ‹è¯•è§£ææœªè¿æ¥çš„æœåŠ¡å™¨"""
        output = "context7: âœ— Disconnected\n"
        status = monitor._parse_mcp_output(output)

        assert status.total == 1
        assert status.connected == 0
        assert status.servers[0].status == McpServerStatus.DISCONNECTED

    def test_parse_multiple_servers(self, monitor):
        """æµ‹è¯•è§£æå¤šä¸ªæœåŠ¡å™¨"""
        output = """
serena: âœ“ Connected
context7: âœ— Disconnected
sequential: âœ“ Connected
        """
        status = monitor._parse_mcp_output(output)

        assert status.total == 3
        assert status.connected == 2

    def test_health_all_connected(self, monitor):
        """æµ‹è¯•å…¨éƒ¨è¿æ¥çš„å¥åº·çŠ¶æ€"""
        status = McpStatus(servers=[
            McpServer("serena", McpServerStatus.CONNECTED),
            McpServer("context7", McpServerStatus.CONNECTED)
        ])
        assert status.get_health() == "healthy"

    def test_health_partial_connected(self, monitor):
        """æµ‹è¯•éƒ¨åˆ†è¿æ¥çš„å¥åº·çŠ¶æ€"""
        status = McpStatus(servers=[
            McpServer("serena", McpServerStatus.CONNECTED),
            McpServer("context7", McpServerStatus.DISCONNECTED)
        ])
        assert status.get_health() == "partial"

    def test_health_no_connected(self, monitor):
        """æµ‹è¯•æ— è¿æ¥çš„å¥åº·çŠ¶æ€"""
        status = McpStatus(servers=[
            McpServer("serena", McpServerStatus.DISCONNECTED)
        ])
        assert status.get_health() == "unhealthy"

    @patch("subprocess.run")
    def test_execute_mcp_list_success(self, mock_run, monitor):
        """æµ‹è¯•æˆåŠŸæ‰§è¡Œ claude mcp list"""
        mock_run.return_value = Mock(
            returncode=0,
            stdout="serena: âœ“ Connected\n"
        )

        output = monitor._execute_mcp_list()
        assert output is not None
        assert "serena" in output

    @patch("subprocess.run")
    def test_execute_mcp_list_timeout(self, mock_run, monitor):
        """æµ‹è¯•å‘½ä»¤è¶…æ—¶"""
        import subprocess
        mock_run.side_effect = subprocess.TimeoutExpired("claude", 5)

        output = monitor._execute_mcp_list()
        assert output is None
```

### 7.2 é›†æˆæµ‹è¯•

```python
# tests/integration/test_mcp_integration.py
import pytest
from cc_statusline.core.mcp import McpMonitor

@pytest.mark.integration
class TestMcpIntegration:
    """MCP ç›‘æ§é›†æˆæµ‹è¯•ï¼ˆéœ€è¦çœŸå® claude CLIï¼‰"""

    def test_real_mcp_query(self):
        """æµ‹è¯•çœŸå® MCP æŸ¥è¯¢"""
        monitor = McpMonitor(timeout=10)
        status = monitor.get_status()

        # åŸºæœ¬æ–­è¨€
        assert status is not None
        assert status.total >= 0

        if status.total > 0:
            assert all(s.name for s in status.servers)

    def test_cache_functionality(self):
        """æµ‹è¯•ç¼“å­˜åŠŸèƒ½"""
        monitor = McpMonitor(cache_ttl=5)

        # ç¬¬ä¸€æ¬¡æŸ¥è¯¢ï¼ˆæ…¢ï¼‰
        import time
        start = time.time()
        status1 = monitor.get_status()
        duration1 = time.time() - start

        # ç¬¬äºŒæ¬¡æŸ¥è¯¢ï¼ˆå¿«ï¼Œä»ç¼“å­˜ï¼‰
        start = time.time()
        status2 = monitor.get_status()
        duration2 = time.time() - start

        # ç¼“å­˜å‘½ä¸­åº”è¯¥æ›´å¿«
        assert duration2 < duration1
        assert status1.to_string() == status2.to_string()
```

---

## å…«ã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 8.1 ç¼“å­˜ç­–ç•¥

| åœºæ™¯ | ç¼“å­˜æ—¶é•¿ | ç†ç”± |
|------|---------|------|
| **å¼€å‘ç¯å¢ƒ** | 60s | MCP æœåŠ¡å™¨é…ç½®é¢‘ç¹å˜åŒ– |
| **ç”Ÿäº§ç¯å¢ƒ** | 300s | é…ç½®ç¨³å®šï¼Œå‡å°‘æŸ¥è¯¢å¼€é”€ |
| **CI/CD** | 0s | ç¦ç”¨ç¼“å­˜ï¼Œç¡®ä¿æœ€æ–°çŠ¶æ€ |

### 8.2 è¶…æ—¶è®¾ç½®

| ç¯å¢ƒ | è¶…æ—¶æ—¶é—´ | ç†ç”± |
|------|---------|------|
| **æœ¬åœ°å¼€å‘** | 10s | ç½‘ç»œæ¡ä»¶å¥½ |
| **è¿œç¨‹è¿æ¥** | 15s | ç½‘ç»œå»¶è¿Ÿé«˜ |
| **CI/CD** | 5s | å¿«é€Ÿå¤±è´¥ |

### 8.3 æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | æµ‹é‡æ–¹æ³• |
|------|--------|----------|
| å†·å¯åŠ¨ | < 100ms | é¦–æ¬¡æŸ¥è¯¢ï¼ˆæ— ç¼“å­˜ï¼‰ |
| çƒ­å¯åŠ¨ | < 10ms | ç¼“å­˜å‘½ä¸­æŸ¥è¯¢ |
| å†…å­˜å ç”¨ | < 10MB | Python è¿›ç¨‹ RSS |

---

## ä¹ã€æ•…éšœæ’æŸ¥æŒ‡å—

### 9.1 å¸¸è§é—®é¢˜

#### é—®é¢˜ 1: MCP æ˜¾ç¤º `?/?`

**åŸå› **:
- claude CLI æœªå®‰è£…
- claude CLI ä¸åœ¨ PATH ä¸­
- å‘½ä»¤æ‰§è¡Œè¶…æ—¶
- æƒé™é—®é¢˜

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ£€æŸ¥ claude CLI
which claude
claude --version

# æµ‹è¯• MCP å‘½ä»¤
claude mcp list

# æ£€æŸ¥æƒé™
ls -la $(which claude)
```

#### é—®é¢˜ 2: çŠ¶æ€æ˜¾ç¤ºä¸æ›´æ–°

**åŸå› **: ç¼“å­˜æœªè¿‡æœŸ

**è§£å†³æ–¹æ¡ˆ**:
```python
# æ¸…ç©ºç¼“å­˜
from cc_statusline.core.cache import Cache
cache = Cache()
cache.clear()

# æˆ–å‡å°‘ç¼“å­˜æ—¶é•¿
monitor = McpMonitor(cache_ttl=60)  # 1åˆ†é’Ÿ
```

#### é—®é¢˜ 3: æœåŠ¡å™¨åç§°è§£æå¤±è´¥

**åŸå› **: æœåŠ¡å™¨åç§°åŒ…å«ç‰¹æ®Šå­—ç¬¦

**è§£å†³æ–¹æ¡ˆ**:
- MCP æœåŠ¡å™¨åç§°åº”åªåŒ…å«å­—æ¯æ•°å­—ã€ä¸‹åˆ’çº¿ã€è¿å­—ç¬¦
- ä¿®æ”¹ MCP é…ç½®ï¼Œé‡å‘½åæœåŠ¡å™¨

---

## åã€æ‰©å±•æ–¹å‘

### 10.1 æœªæ¥åŠŸèƒ½

| åŠŸèƒ½ | ä¼˜å…ˆçº§ | å·¥ä½œé‡ |
|------|--------|--------|
| **æœåŠ¡å™¨è¯¦æƒ…æ˜¾ç¤º** | P1 | 1å¤© |
| **è‡ªåŠ¨é‡è¿æœºåˆ¶** | P2 | 2å¤© |
| **æ€§èƒ½ç›‘æ§** | P2 | 1å¤© |
| **é€šçŸ¥ç³»ç»Ÿ** | P3 | 2å¤© |

### 10.2 æœåŠ¡å™¨è¯¦æƒ…ç¤ºä¾‹

```python
@dataclass
class McpServerDetails:
    """MCP æœåŠ¡å™¨è¯¦ç»†ä¿¡æ¯"""
    name: str
    status: McpServerStatus
    version: Optional[str] = None
    uptime: Optional[int] = None  # ç§’
    last_error: Optional[str] = None
    capabilities: list[str] = None

class McpMonitor:
    def get_server_details(self, server_name: str) -> Optional[McpServerDetails]:
        """è·å–æŒ‡å®šæœåŠ¡å™¨çš„è¯¦ç»†ä¿¡æ¯"""
        # TODO: å®ç°è¯¦ç»†ä¿¡æ¯æŸ¥è¯¢
        pass
```

---

## åä¸€ã€ç»“è®º

### 11.1 å®æ–½æ¸…å•

- [x] æ•°æ®æ¨¡å‹è®¾è®¡
- [x] McpMonitor æ ¸å¿ƒç±»
- [x] ç¼“å­˜ç³»ç»Ÿå®ç°
- [x] çŠ¶æ€æ ç»„ä»¶
- [x] å•å…ƒæµ‹è¯•
- [x] é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] æ–‡æ¡£å®Œå–„

### 11.2 ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ç«‹å³æ‰§è¡Œ**:
   - å°†ä»£ç å¤åˆ¶åˆ°é¡¹ç›®ä¸­
   - è¿è¡Œå•å…ƒæµ‹è¯•
   - éªŒè¯åŸºæœ¬åŠŸèƒ½

2. **çŸ­æœŸè®¡åˆ’** (1å‘¨å†…):
   - é›†æˆåˆ°ä¸»çŠ¶æ€æ 
   - æ·»åŠ é…ç½®æ”¯æŒ
   - æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

3. **é•¿æœŸè§„åˆ’** (1ä¸ªæœˆ):
   - å®ç°æœåŠ¡å™¨è¯¦æƒ…
   - æ·»åŠ è‡ªåŠ¨é‡è¿
   - ç¤¾åŒºåé¦ˆå’Œè¿­ä»£

---

**æ–‡æ¡£çŠ¶æ€**: âœ… å®Œæˆ
**ä»£ç å¯ç”¨æ€§**: âœ… å¯ç›´æ¥ä½¿ç”¨
**æµ‹è¯•è¦†ç›–ç‡**: ğŸ¯ ç›®æ ‡ 80%+
