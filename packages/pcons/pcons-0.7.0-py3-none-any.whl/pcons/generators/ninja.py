# SPDX-License-Identifier: MIT
"""Ninja build file generator.

Generates build.ninja files from a configured pcons Project.
"""

from __future__ import annotations

import os
import re
from pathlib import Path
from typing import TYPE_CHECKING, Any, TextIO, cast

from pcons.core.debug import trace, trace_value
from pcons.core.node import FileNode, Node
from pcons.core.paths import PathResolver
from pcons.generators.generator import BaseGenerator

if TYPE_CHECKING:
    from pcons.core.environment import Environment
    from pcons.core.project import Project
    from pcons.core.subst import CommandToken
    from pcons.core.target import Target


class NinjaGenerator(BaseGenerator):
    """Generator that produces Ninja build files.

    Generates a complete build.ninja file including:
    - Variable definitions
    - Rule definitions (one per unique command pattern)
    - Build statements with dependencies
    - Phony rules for aliases
    - Default targets

    Example:
        project = Project("myapp", build_dir="build")
        # ... configure project ...

        generator = NinjaGenerator()
        generator.generate(project)
        # Creates build/build.ninja
    """

    # Characters that need escaping in Ninja
    ESCAPE_CHARS = re.compile(r"([$:\s])")

    def __init__(self) -> None:
        super().__init__("ninja")
        self._rules: dict[str, str] = {}  # rule_name -> command
        self._rule_counter = 0
        self._output_dir: Path | None = None  # Set during generate()
        self._project_root: Path | None = None  # Set during generate()
        self._topdir: str = ".."  # Relative path from output_dir to project root
        self._path_resolver: PathResolver | None = None  # Set during generate()

    def _generate_impl(self, project: Project, output_dir: Path) -> None:
        """Generate build.ninja file.

        Args:
            project: Configured project to generate for.
            output_dir: Directory to write build.ninja to.
        """
        trace("generate", "Generating ninja files to: %s", output_dir)
        trace_value("generate", "targets", len(project.targets))

        output_dir.mkdir(parents=True, exist_ok=True)
        ninja_file = output_dir / "build.ninja"

        # Reset state for this generation
        self._rules = {}
        self._rule_counter = 0
        self._output_dir = output_dir.resolve()
        self._project_root = project.root_dir.resolve()
        # Store path_resolver from project if available
        self._path_resolver = getattr(project, "_path_resolver", None)
        # Compute relative path from output_dir to project root
        try:
            self._topdir = str(
                Path(os.path.relpath(self._project_root, self._output_dir))
            )
        except ValueError:
            # On Windows, relpath fails for paths on different drives
            self._topdir = str(self._project_root)

        with open(ninja_file, "w") as f:
            self._write_header(f, project)
            self._write_variables(f, project)
            self._write_rules(f, project)
            self._write_builds(f, project)
            self._write_aliases(f, project)
            self._write_defaults(f, project)

    def _write_header(self, f: TextIO, project: Project) -> None:
        """Write file header comment."""
        f.write(f"# Generated by pcons for project: {project.name}\n")
        f.write("# Do not edit - regenerate with 'pcons generate'\n")
        f.write("ninja_required_version = 1.5\n")
        f.write("\n")

    def _write_variables(self, f: TextIO, project: Project) -> None:
        """Write global variables."""
        f.write("# Global variables\n")
        # builddir is "." since the ninja file is in the build directory
        f.write("builddir = .\n")
        # topdir is the relative path from build dir to project root
        # Used for source files, include paths, etc.
        f.write(f"topdir = {self._escape_path(self._topdir)}\n")
        f.write("\n")

    def _write_rules(self, f: TextIO, project: Project) -> None:
        """Write rule definitions.

        Rules are deduplicated - identical commands share a rule.
        """
        f.write("# Rules\n")
        # Note: Ninja automatically creates output directories before running
        # commands, so we don't need explicit mkdir rules.

        # Collect all unique rules from targets
        for target in project.targets:
            env = target._env
            for node in self._get_target_build_nodes(target):
                self._ensure_rule(f, node, target, env)

        # Also check nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    self._ensure_rule(f, node, None, env)

        f.write("\n")

    def _find_env_for_node(
        self, node: FileNode, project: Project
    ) -> Environment | None:
        """Find the environment that created a node."""
        for env in project.environments:
            if node in getattr(env, "_created_nodes", []):
                return env
        return None

    def _ensure_rule(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        env: Environment | None = None,
    ) -> str:
        """Ensure a rule exists for this node's builder, return rule name.

        Commands are now fully expanded by the resolver. The generator uses
        the pre-expanded command from _build_info["command"] and deduplicates
        rules based on command hash.

        For nodes without a pre-expanded command (e.g., tests that manually
        create build_info), falls back to the old expansion logic.
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return "phony"

        # Get basic info from build_info
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")

        # Check if this is a generic command (has custom rule_name)
        custom_rule_name = build_info.get("rule_name")

        # Get the pre-expanded command from build_info (set by resolver)
        # Command can be a list of tokens or a string
        command_raw = build_info.get("command")

        # If no pre-expanded command, fall back to old expansion logic
        # (for backward compatibility with tests and direct node creation)
        if command_raw is None:
            command = self._expand_command_fallback(node, build_info, env)
        elif isinstance(command_raw, list):
            # Relativize path flags in tokens for ninja execution
            # (ninja runs from build dir, paths are project-root-relative)
            relativized_tokens = self._relativize_command_tokens(command_raw)
            # Convert token list to shell command string with ninja quoting
            from pcons.core.subst import to_shell_command

            command = to_shell_command(relativized_tokens, shell="ninja")
        else:
            command = command_raw

        # Append post-build commands directly to the command if needed
        # This ensures targets with different post-build commands get different rules
        sources = cast(list[Node], build_info.get("sources", []))
        post_build_suffix = self._get_post_build_suffix(node, target, sources)
        if post_build_suffix:
            command = command.rstrip() + post_build_suffix

        # Create a unique rule key based on the command
        # This ensures identical commands share rules (deduplication)
        if custom_rule_name:
            rule_key = custom_rule_name
        else:
            # Hash the command to create a stable rule key
            # Include tool and command_var for readability
            import hashlib

            cmd_hash = hashlib.md5(command.encode()).hexdigest()[:8]
            rule_key = f"{tool_name}_{command_var}_{cmd_hash}"

        if rule_key not in self._rules:
            rule_name = rule_key
            description = f"{tool_name.upper()} $out"

            # Use description from build_info if provided
            custom_description = build_info.get("description")
            if custom_description:
                description = str(custom_description)
            elif custom_rule_name:
                description = "COMMAND $out"

            # Write the rule
            f.write(f"rule {rule_name}\n")
            f.write(f"  command = {command}\n")
            f.write(f"  description = {description}\n")

            # Add depfile support based on builder configuration
            depfile = build_info.get("depfile")
            deps_style = build_info.get("deps_style")

            if deps_style == "msvc":
                f.write("  deps = msvc\n")
            elif deps_style == "gcc":
                if depfile:
                    # depfile is a PathToken - use suffix to create $out.d pattern
                    # Ninja uses $out (the output variable) + suffix
                    from pcons.core.subst import PathToken

                    if isinstance(depfile, PathToken):
                        depfile_ninja = f"$out{depfile.suffix}"
                        f.write(f"  depfile = {depfile_ninja}\n")
                f.write("  deps = gcc\n")

            f.write("\n")
            self._rules[rule_key] = rule_name

        return self._rules[rule_key]

    def _get_post_build_suffix(
        self,
        node: FileNode,
        target: Target | None,
        sources: list[Node],
    ) -> str:
        """Get post-build command suffix if this node needs it.

        Returns ' && cmd1 && cmd2' if the node is an output node with post-build
        commands, otherwise returns empty string.

        Post-build commands are baked directly into the rule command, so targets
        with different post-build commands get different rules (via command hash).
        """
        if target is None:
            return ""

        # Check if this is an output node (not an intermediate like .o files)
        is_output_node = (
            hasattr(target, "output_nodes") and node in target.output_nodes
        ) or node in target.nodes

        if not is_output_node:
            return ""

        builder_data = getattr(target, "_builder_data", {}) or {}
        post_build_cmds = builder_data.get("post_build_commands", [])
        if not post_build_cmds:
            return ""

        # Substitute $out and $in in each command
        out_path = str(node.path)
        in_paths = " ".join(str(s.path) for s in sources if isinstance(s, FileNode))
        substituted_cmds = []
        for cmd in post_build_cmds:
            cmd = cmd.replace("$out", out_path)
            cmd = cmd.replace("$in", in_paths)
            substituted_cmds.append(cmd)

        return " && " + " && ".join(substituted_cmds)

    def _expand_command_fallback(
        self,
        _node: FileNode,
        build_info: dict[str, Any],
        env: Environment | None,
    ) -> str:
        """Fallback command expansion when build_info["command"] is not set.

        This fallback exists for two cases:
        1. Unit tests that manually create _build_info without using the resolver
        2. Direct node creation without going through project.resolve()

        In normal use, the resolver sets build_info["command"] with the
        pre-expanded command, so this fallback is not triggered.

        Args:
            _node: The file node being built (unused, kept for API consistency).
            build_info: The node's build info.
            env: The environment (may be None for standalone tools).

        Returns:
            Expanded command string, or a placeholder if no env/tool available.
        """
        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        context = build_info.get("context")

        # Check for context overrides (archive/install tools)
        context_overrides: dict[str, Any] = {}
        if context is not None and hasattr(context, "get_env_overrides"):
            context_overrides = context.get_env_overrides()

        # Default command
        command = f"echo 'No command for {tool_name}_{command_var}'"

        if env is not None:
            tool_config = getattr(env, tool_name, None)
            if tool_config is not None:
                cmd_template = getattr(tool_config, command_var, None)
                if cmd_template:
                    # Set context overrides on tool config
                    if context_overrides:
                        for key, val in context_overrides.items():
                            setattr(tool_config, key, val)

                    # Expand using subst
                    command = env.subst(cmd_template, shell="ninja")
        else:
            # Try standalone tools
            cmd_template = self._get_standalone_tool_command(tool_name, command_var)
            if cmd_template:
                command = cmd_template.replace("$$", "$")
                # Apply context overrides for standalone tools
                # Replace $tool.var patterns with actual values
                if context_overrides:
                    for key, val in context_overrides.items():
                        pattern = f"${tool_name}.{key}"
                        if isinstance(val, list):
                            # List values become space-separated tokens
                            val_str = " ".join(str(v) for v in val)
                        else:
                            val_str = str(val)
                        command = command.replace(pattern, val_str)

        return command

    def _write_builds(self, f: TextIO, project: Project) -> None:
        """Write build statements for all targets."""
        f.write("# Build statements\n")

        written_nodes: set[Path] = set()

        # Note: No explicit mkdir statements needed - Ninja automatically
        # creates output directories before running commands.

        for target in project.targets:
            self._write_target_builds(f, target, project, written_nodes)

        # Also write builds for nodes tracked in environments
        for env in project.environments:
            for node in getattr(env, "_created_nodes", []):
                if isinstance(node, FileNode) and node.builder is not None:
                    if node.path not in written_nodes:
                        self._write_build_statement(f, node, None, project)
                        written_nodes.add(node.path)

        f.write("\n")

    def _write_target_builds(
        self, f: TextIO, target: Target, project: Project, written_nodes: set[Path]
    ) -> None:
        """Write build statements for a single target."""
        for node in self._get_target_build_nodes(target):
            if node.path not in written_nodes:
                self._write_build_statement(f, node, target, project)
                written_nodes.add(node.path)

    def _write_build_statement(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        project: Project | None = None,
    ) -> None:
        """Write a single build statement.

        Handles both single-output and multi-output builds. Multi-output builds
        use Ninja's implicit output syntax: build out1 out2 | implicit_out: rule deps
        """
        build_info = getattr(node, "_build_info", None)
        if build_info is None:
            return

        # Skip secondary nodes from multi-output builds (they reference primary_node)
        if "primary_node" in build_info:
            return

        tool_name = build_info.get("tool", "unknown")
        command_var = build_info.get("command_var", "cmdline")
        sources = cast(list[Node], build_info.get("sources", []))

        # Get the environment for this build (needed for per-env rule naming)
        # For target-centric builds, use target._env
        # For direct builder calls, find the env that created the node
        env: Environment | None = None
        if target:
            env = target._env
        elif project:
            env = self._find_env_for_node(node, project)

        # Check for custom rule name (from generic command builder)
        custom_rule_name = build_info.get("rule_name")
        if custom_rule_name:
            rule_name = custom_rule_name
        else:
            # Rule name must match _ensure_rule() logic
            # Use the pre-expanded command to create a hash-based rule key
            command_raw = build_info.get("command")
            if command_raw is None:
                # Fallback expansion - use same logic as _ensure_rule
                command = self._expand_command_fallback(node, build_info, env)
            elif isinstance(command_raw, list):
                # Relativize path flags in tokens for ninja execution
                relativized_tokens = self._relativize_command_tokens(command_raw)
                # Convert token list to shell command string with ninja quoting
                from pcons.core.subst import to_shell_command

                command = to_shell_command(relativized_tokens, shell="ninja")
            else:
                command = command_raw

            # Append post-build commands directly to the command if needed
            # Must match _ensure_rule() logic for consistent rule naming
            post_build_suffix = self._get_post_build_suffix(node, target, sources)
            if post_build_suffix:
                command = command.rstrip() + post_build_suffix

            # Hash the command to create a stable rule key
            import hashlib

            cmd_hash = hashlib.md5(command.encode()).hexdigest()[:8]
            rule_name = f"{tool_name}_{command_var}_{cmd_hash}"

        # Handle multi-output builds from generic commands
        all_targets = build_info.get("all_targets")
        outputs_info = build_info.get("outputs")

        if all_targets and len(cast(list[Node], all_targets)) > 1:
            # Generic command with multiple outputs
            target_nodes = cast(list[FileNode], all_targets)
            output = " ".join(self._escape_output_path(t.path) for t in target_nodes)
        elif outputs_info:
            # Multi-output build (from MultiOutputBuilder)
            explicit_outputs: list[str] = []
            implicit_outputs: list[str] = []

            for _name, info in outputs_info.items():
                path = self._escape_output_path(info["path"])
                if info.get("implicit", False):
                    implicit_outputs.append(path)
                else:
                    explicit_outputs.append(path)

            output = " ".join(explicit_outputs)
            if implicit_outputs:
                output += " | " + " ".join(implicit_outputs)
        else:
            # Single-output build
            output = self._escape_output_path(node.path)

        # Explicit dependencies (sources + library dependencies)
        # For source files, we need to reference them from the build directory
        def get_dep_path(s: FileNode) -> str:
            # Check if this is a build output (has _build_info from resolver)
            if getattr(s, "_build_info", None) is not None or s.is_target:
                # Build output - make relative to build dir
                return self._escape_output_path(s.path)

            # Source file - try to make relative with $topdir
            rel = self._make_source_relative(s.path)
            if rel is not None:
                # $topdir is a ninja variable - escape the path part
                return "$topdir/" + self._escape_path(rel)

            # Fall back: escape the path as-is (external files)
            return self._escape_path(s.path)

        # Start with sources from build_info
        explicit_deps_list = [
            get_dep_path(s) for s in sources if isinstance(s, FileNode)
        ]

        # Add any additional explicit deps (e.g., libraries for linking)
        # that aren't already in sources
        source_paths_set = {s.path for s in sources if isinstance(s, FileNode)}
        for dep in node.explicit_deps:
            if isinstance(dep, FileNode) and dep.path not in source_paths_set:
                # Use _escape_output_path for build outputs (objects, libraries)
                explicit_deps_list.append(self._escape_output_path(dep.path))

        explicit_deps = " ".join(explicit_deps_list)

        # Implicit dependencies (from node.implicit_deps)
        implicit_deps = ""
        if node.implicit_deps:
            implicit = " ".join(
                self._escape_output_path(d.path)
                for d in node.implicit_deps
                if isinstance(d, FileNode)
            )
            if implicit:
                implicit_deps = f" | {implicit}"

        # Note: No order-only dependencies for directories needed.
        # Ninja automatically creates output directories before running commands.
        order_only = ""

        f.write(
            f"build {output}: {rule_name} {explicit_deps}{implicit_deps}{order_only}\n"
        )

        # Write per-build variables
        # These override the rule's command with actual values
        self._write_build_variables(f, node, target, build_info, project)

    def _write_build_variables(
        self,
        f: TextIO,
        node: FileNode,
        target: Target | None,
        build_info: dict[str, object],
        project: Project | None = None,
    ) -> None:
        """Write variables for a build statement.

        Note: We don't write $in or $out - ninja sets these automatically
        from the build statement's inputs and outputs.

        For multi-output builds, writes out_<name> variables for each output.
        For generic commands, writes source_N and target_N for indexed access.
        """
        sources = cast(list[Node], build_info.get("sources", []))

        # Helper to format source paths
        def get_source_path(s: FileNode) -> str:
            # Check if this is a build output (has _build_info from resolver)
            if getattr(s, "_build_info", None) is not None or s.is_target:
                # Build output - make relative to build dir
                return self._make_output_relative(s.path)

            # Source file - try to make relative with $topdir
            rel = self._make_source_relative(s.path)
            if rel is not None:
                # $topdir is a ninja variable, expanded when used in command
                return f"$topdir/{rel}"

            # Fall back to original path (external files)
            return str(s.path)

        source_file_nodes = [s for s in sources if isinstance(s, FileNode)]

        # For generic commands with indexed access, write source_N and target_N
        # variables for each source and target
        all_targets = build_info.get("all_targets")
        if all_targets:
            # Write indexed source variables
            for i, src in enumerate(source_file_nodes):
                f.write(f"  source_{i} = {get_source_path(src)}\n")
            # Write indexed target variables
            target_nodes = cast(list[FileNode], all_targets)
            for i, tgt in enumerate(target_nodes):
                f.write(f"  target_{i} = {self._make_output_relative(tgt.path)}\n")

        # For multi-output builds, write out_<name> for each output
        # Also write target_N for indexed access (used by TargetPath(index=N) in commands)
        outputs_info = build_info.get("outputs")
        if outputs_info and isinstance(outputs_info, dict):
            for i, (name, info) in enumerate(outputs_info.items()):
                # Write out_<name> variable for each output
                if isinstance(info, dict):
                    info_dict = cast(dict[str, Any], info)
                    out_path = self._make_output_relative(info_dict["path"])
                    f.write(f"  out_{name} = {out_path}\n")
                    # Also write target_N for indexed access
                    f.write(f"  target_{i} = {out_path}\n")

        # Write custom per-build variables from build_info (legacy support)
        # Note: New code should use context objects instead
        custom_vars = build_info.get("variables")
        if custom_vars and isinstance(custom_vars, dict):
            for var_name, var_value in custom_vars.items():
                if var_value:  # Only write non-empty values
                    # Escape for Ninja variable substitution
                    escaped_value = self._escape_for_ninja_variable(str(var_value))
                    f.write(f"  {var_name} = {escaped_value}\n")

    def _write_aliases(self, f: TextIO, project: Project) -> None:
        """Write phony rules for aliases."""
        if not project.aliases:
            return

        f.write("# Aliases\n")
        for name, alias in project.aliases.items():
            targets = " ".join(
                self._escape_output_path(t.path)
                for t in alias.targets
                if isinstance(t, FileNode)
            )
            if targets:
                f.write(f"build {name}: phony {targets}\n")
        f.write("\n")

    def _write_defaults(self, f: TextIO, project: Project) -> None:
        """Write default targets and 'all' phony target."""
        f.write("# Default targets\n")
        user_defaults: list[str] = []
        all_outputs: list[str] = []

        # Collect user-specified default targets
        for target in project.default_targets:
            for out_node in target.output_nodes:
                if isinstance(out_node, FileNode):
                    user_defaults.append(self._escape_output_path(out_node.path))

        # Collect all target outputs for 'all' target
        for target in project.targets:
            for node in target.output_nodes:
                if isinstance(node, FileNode):
                    all_outputs.append(self._escape_output_path(node.path))

        if all_outputs:
            # Create 'all' phony target â€” builds every target in the project
            f.write(f"build all: phony {' '.join(all_outputs)}\n")

        # Collect programs and libraries for implicit default
        prog_lib_outputs: list[str] = []
        for target in project.targets:
            if target.target_type in (
                "program",
                "shared_library",
                "static_library",
            ):
                for node in target.output_nodes:
                    if isinstance(node, FileNode):
                        prog_lib_outputs.append(self._escape_output_path(node.path))

        # Set default: user-specified targets, or programs & libraries
        if user_defaults:
            f.write(f"default {' '.join(user_defaults)}\n")
        elif prog_lib_outputs:
            f.write(f"default {' '.join(prog_lib_outputs)}\n")
        elif all_outputs:
            f.write("default all\n")

    def _escape_path(self, path: Path | str) -> str:
        """Escape a path for use in Ninja files.

        Ninja requires escaping of $, :, and whitespace.
        Always uses forward slashes for cross-platform compatibility.
        """
        path_str = str(path)
        # Normalize to forward slashes (Ninja handles them on all platforms)
        path_str = path_str.replace("\\", "/")
        # Escape special characters
        return self.ESCAPE_CHARS.sub(r"$\1", path_str)

    def _make_output_relative(self, path: Path | str) -> str:
        """Make an output path relative to the ninja file location.

        Since the ninja file is written to the build directory, output paths
        should be relative to that directory. For example, if the build dir
        is '/abs/path/build/' and a path is '/abs/path/build/my_program',
        this returns 'my_program'.

        Always uses forward slashes for cross-platform compatibility.
        """
        path_obj = Path(path)

        # Handle absolute paths
        if path_obj.is_absolute():
            if self._output_dir is not None:
                try:
                    return str(path_obj.relative_to(self._output_dir)).replace(
                        "\\", "/"
                    )
                except ValueError:
                    # Path is not under output_dir - return as-is
                    return str(path).replace("\\", "/")
            return str(path).replace("\\", "/")

        # Handle relative paths - strip the build dir prefix if present
        # e.g., "build/my_program" when output_dir is "build"
        if self._output_dir is not None:
            build_dir_name = self._output_dir.name
            parts = path_obj.parts
            if parts and parts[0] == build_dir_name:
                # Strip the build dir prefix
                if len(parts) > 1:
                    return str(Path(*parts[1:])).replace("\\", "/")
                return "."

        return str(path).replace("\\", "/")

    def _escape_output_path(self, path: Path | str) -> str:
        """Make an output path relative to build dir and escape for Ninja."""
        return self._escape_path(self._make_output_relative(path))

    def _make_source_relative(self, path: Path | str) -> str | None:
        """Try to make a source path relative to project root.

        Returns a path like "src/file.c" (relative to project root) if the path
        is within the project root, or None if it cannot be made relative
        (e.g., path is outside project or on different drive on Windows).

        The caller is responsible for prepending $topdir if needed.

        Uses PathResolver if available for consistent path handling.
        """
        # Use PathResolver if available
        if self._path_resolver is not None:
            path_obj = Path(path)
            # Make absolute if relative, so we can check if it's under project root
            if not path_obj.is_absolute() and self._project_root is not None:
                path_obj = self._project_root / path_obj
            result = self._path_resolver.make_project_relative(path_obj.resolve())
            # Check if result is absolute (meaning it couldn't be made relative)
            if Path(result).is_absolute():
                return None
            return result

        # Fallback for tests without full project context
        if self._project_root is None or self._output_dir is None:
            return None

        path_obj = Path(path)

        # Make absolute if relative
        if not path_obj.is_absolute():
            path_obj = self._project_root / path_obj

        path_obj = path_obj.resolve()

        # Try to make path relative to project root
        try:
            rel_to_root = path_obj.relative_to(self._project_root)
            # Use forward slashes for cross-platform compatibility
            return str(rel_to_root).replace("\\", "/")
        except ValueError:
            # Path is not under project root
            return None

    def _relativize_path_for_variable(self, path: str) -> str:
        """Make a path relative for use in ninja variables (like includes).

        For paths within the project, returns $topdir/relative/path.
        For paths outside the project, returns the original path.
        The result is shell-quoted if needed.
        """
        rel = self._make_source_relative(path)
        if rel is not None:
            return rel
        return path

    def _is_build_dir_path(self, path: str) -> bool:
        """Check if a path refers to the build directory.

        Args:
            path: Path string (can be relative or absolute).

        Returns:
            True if the path resolves to the build directory.
        """
        if self._output_dir is None:
            return False
        path_obj = Path(path)
        if not path_obj.is_absolute():
            # Make relative path absolute from project root
            if self._project_root:
                path_obj = self._project_root / path_obj
        try:
            return path_obj.resolve() == self._output_dir
        except (OSError, ValueError):
            return False

    def _relativize_flag_with_path(self, token: str) -> str:
        """Relativize a compiler flag that contains a path.

        Handles flags like:
        - -I/path/to/include -> -I$topdir/relative/path
        - /I/path/to/include -> /I$topdir/relative/path (MSVC)
        - -L/path/to/lib -> -L$topdir/relative/path
        - /LIBPATH:/path -> /LIBPATH:$topdir/relative/path (MSVC)

        Special case: if path equals the build directory, returns prefix + "."
        since ninja runs from the build directory.

        Returns the token unchanged if it's not a path flag or can't be relativized.
        """
        # Common Unix-style flags with path
        for prefix in ("-I", "-L", "-isystem"):
            if token.startswith(prefix):
                path = token[len(prefix) :]
                if path:  # Has a path after the prefix
                    # Special case: path equals build directory -> use "."
                    if self._is_build_dir_path(path):
                        return f"{prefix}."
                    rel = self._make_source_relative(path)
                    if rel is not None:
                        return f"{prefix}$topdir/{rel}"
                return token

        # MSVC-style flags
        if token.startswith("/I"):
            path = token[2:]
            if path:
                # Special case: path equals build directory -> use "."
                if self._is_build_dir_path(path):
                    return "/I."
                rel = self._make_source_relative(path)
                if rel is not None:
                    return f"/I$topdir/{rel}"
            return token

        if token.upper().startswith("/LIBPATH:"):
            prefix = token[:9]  # Preserve original case
            path = token[9:]
            if path:
                # Special case: path equals build directory -> use "."
                if self._is_build_dir_path(path):
                    return f"{prefix}."
                rel = self._make_source_relative(path)
                if rel is not None:
                    return f"{prefix}$topdir/{rel}"
            return token

        return token

    def _relativize_command_tokens(
        self, tokens: list[str] | list[CommandToken]
    ) -> list[str]:
        """Relativize path tokens in command for ninja execution.

        Processes PathToken objects using their relativize() method with
        ninja-appropriate path transformation. Converts SourcePath/TargetPath
        markers to Ninja's $in/$out variables. For regular strings, falls
        back to pattern-based detection of path flags.

        Args:
            tokens: List of command tokens (str, PathToken, SourcePath, TargetPath).

        Returns:
            List of string tokens with paths relativized for ninja.
        """
        from pcons.core.subst import PathToken, SourcePath, TargetPath

        result: list[str] = []
        for token in tokens:
            if isinstance(token, SourcePath):
                # Convert SourcePath marker to Ninja's $in or $source_N variable
                # index=0 with no other indexed sources uses $in for simplicity
                prefix = token.prefix if token.prefix else ""
                suffix = token.suffix if token.suffix else ""
                if token.index > 0:
                    result.append(f"{prefix}$source_{token.index}{suffix}")
                else:
                    # Check if there are any indexed sources in the token list
                    has_indexed = any(
                        isinstance(t, SourcePath) and t.index > 0 for t in tokens
                    )
                    if has_indexed:
                        result.append(f"{prefix}$source_0{suffix}")
                    else:
                        result.append(f"{prefix}$in{suffix}")
            elif isinstance(token, TargetPath):
                # Convert TargetPath marker to Ninja's $out or $target_N variable
                # Handle prefix (e.g., "/Fo" for MSVC) and suffix (e.g., ".d" for depfiles)
                prefix = token.prefix if token.prefix else ""
                suffix = token.suffix if token.suffix else ""
                if token.index > 0:
                    result.append(f"{prefix}$target_{token.index}{suffix}")
                else:
                    # Check if there are any indexed targets in the token list
                    has_indexed = any(
                        isinstance(t, TargetPath) and t.index > 0 for t in tokens
                    )
                    if has_indexed:
                        result.append(f"{prefix}$target_0{suffix}")
                    else:
                        result.append(f"{prefix}$out{suffix}")
            elif isinstance(token, PathToken):
                # Use PathToken's relativize() with ninja path transformer
                result.append(token.relativize(self._relativize_path_for_ninja))
            else:
                # Fall back to pattern-based detection for plain strings
                result.append(self._relativize_flag_with_path(str(token)))
        return result

    def _relativize_path_for_ninja(self, path: str) -> str:
        """Transform a path for ninja execution context.

        Since ninja runs from the build directory, paths relative to project
        root need to be prefixed with $topdir. Paths that equal the build
        directory become ".".

        Args:
            path: Path string (project-root-relative or absolute).

        Returns:
            Transformed path suitable for ninja command.
        """
        # Special case: path equals build directory -> use "."
        if self._is_build_dir_path(path):
            return "."

        # Try to make relative to project root with $topdir
        rel = self._make_source_relative(path)
        if rel is not None:
            return f"$topdir/{rel}"

        # Fall back to original path (external/absolute paths)
        return path

    def _escape_for_ninja_variable(self, token: str) -> str:
        """Escape a token for use in a Ninja variable value.

        Used for variable values that get substituted into commands.
        Uses Ninja escaping ($ prefix) rather than shell quoting,
        which works consistently across all platforms.

        Ninja escaping: space -> $  (dollar-space), colon -> $:, dollar -> $$
        Also normalizes backslashes to forward slashes for cross-platform paths.

        Preserves Ninja variable references like $topdir, $in, $out.
        """
        # Normalize backslashes to forward slashes
        token = token.replace("\\", "/")

        # Escape special characters for Ninja, but preserve $topdir and other
        # Ninja variables. We do this by temporarily replacing known patterns.
        # $topdir is the main one we use for relative paths.
        token = token.replace("$topdir", "\x00TOPDIR\x00")

        # Escape remaining $ to $$
        token = token.replace("$", "$$")
        token = token.replace(" ", "$ ")
        token = token.replace(":", "$:")

        # Restore $topdir
        token = token.replace("\x00TOPDIR\x00", "$topdir")
        return token

    def _get_standalone_tool_command(
        self, tool_name: str, command_var: str
    ) -> str | None:
        """Get command template from a standalone tool.

        Used when no environment is available (e.g., Install targets without
        an associated env). Instantiates the standalone tool to get its
        default command template.

        Args:
            tool_name: Tool name (e.g., "install", "archive").
            command_var: Command variable name (e.g., "copycmd", "tarcmd").

        Returns:
            Command template string, or None if not available.
        """
        from pcons.core.subst import to_shell_command

        # Import standalone tools here to avoid circular imports
        if tool_name == "install":
            from pcons.tools.install import InstallTool

            tool = InstallTool()
        elif tool_name == "archive":
            from pcons.tools.archive import ArchiveTool

            tool = ArchiveTool()
        else:
            return None

        defaults = tool.default_vars()
        cmd_template = defaults.get(command_var)
        if cmd_template is None:
            return None

        # Convert list templates to shell command string
        # List templates may contain SourcePath/TargetPath markers that need
        # to be converted to Ninja's $in/$out variables
        if isinstance(cmd_template, list):
            # Relativize path tokens and convert markers to Ninja variables
            # Cast to list[CommandToken] - type checker doesn't narrow from isinstance
            from pcons.core.subst import CommandToken

            relativized = self._relativize_command_tokens(
                cast(list[CommandToken], cmd_template)
            )
            return to_shell_command(relativized, shell="ninja")

        return str(cmd_template) or None
