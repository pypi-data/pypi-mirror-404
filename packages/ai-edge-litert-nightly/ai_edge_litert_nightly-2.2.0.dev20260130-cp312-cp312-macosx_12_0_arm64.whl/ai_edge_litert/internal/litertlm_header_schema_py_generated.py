import flatbuffers

# automatically generated by the FlatBuffers compiler, do not modify

# namespace: schema

from flatbuffers.compat import import_numpy
np = import_numpy()

class VData(object):
    NONE = 0
    UInt8 = 1
    Int8 = 2
    UInt16 = 3
    Int16 = 4
    UInt32 = 5
    Int32 = 6
    Float32 = 7
    Bool = 8
    StringValue = 9
    UInt64 = 10
    Int64 = 11
    Double = 12

def VdataCreator(unionType, table):
    from flatbuffers.table import Table
    if not isinstance(table, Table):
        return None
    if unionType == VData.UInt8:
        return UInt8T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Int8:
        return Int8T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.UInt16:
        return UInt16T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Int16:
        return Int16T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.UInt32:
        return UInt32T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Int32:
        return Int32T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Float32:
        return Float32T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Bool:
        return BoolT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.StringValue:
        return StringValueT.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.UInt64:
        return UInt64T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Int64:
        return Int64T.InitFromBuf(table.Bytes, table.Pos)
    if unionType == VData.Double:
        return DoubleT.InitFromBuf(table.Bytes, table.Pos)
    return None


class AnySectionDataType(object):
    NONE = 0
    GenericBinaryData = 1
    Deprecated = 2
    TFLiteModel = 3
    SP_Tokenizer = 4
    LlmMetadataProto = 5
    HF_Tokenizer_Zlib = 6
    TFLiteWeights = 7


class UInt8(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UInt8()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUInt8(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # UInt8
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UInt8
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

def UInt8Start(builder):
    builder.StartObject(1)

def UInt8AddValue(builder, value):
    builder.PrependUint8Slot(0, value, 0)

def UInt8End(builder):
    return builder.EndObject()



class UInt8T(object):

    # UInt8T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        uint8 = UInt8()
        uint8.Init(buf, pos)
        return cls.InitFromObj(uint8)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, uint8):
        x = UInt8T()
        x._UnPack(uint8)
        return x

    # UInt8T
    def _UnPack(self, uint8):
        if uint8 is None:
            return
        self.value = uint8.Value()

    # UInt8T
    def Pack(self, builder):
        UInt8Start(builder)
        UInt8AddValue(builder, self.value)
        uint8 = UInt8End(builder)
        return uint8


class Int8(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int8()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt8(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Int8
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int8
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

def Int8Start(builder):
    builder.StartObject(1)

def Int8AddValue(builder, value):
    builder.PrependInt8Slot(0, value, 0)

def Int8End(builder):
    return builder.EndObject()



class Int8T(object):

    # Int8T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int8 = Int8()
        int8.Init(buf, pos)
        return cls.InitFromObj(int8)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, int8):
        x = Int8T()
        x._UnPack(int8)
        return x

    # Int8T
    def _UnPack(self, int8):
        if int8 is None:
            return
        self.value = int8.Value()

    # Int8T
    def Pack(self, builder):
        Int8Start(builder)
        Int8AddValue(builder, self.value)
        int8 = Int8End(builder)
        return int8


class UInt16(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UInt16()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUInt16(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # UInt16
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UInt16
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

def UInt16Start(builder):
    builder.StartObject(1)

def UInt16AddValue(builder, value):
    builder.PrependUint16Slot(0, value, 0)

def UInt16End(builder):
    return builder.EndObject()



class UInt16T(object):

    # UInt16T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        uint16 = UInt16()
        uint16.Init(buf, pos)
        return cls.InitFromObj(uint16)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, uint16):
        x = UInt16T()
        x._UnPack(uint16)
        return x

    # UInt16T
    def _UnPack(self, uint16):
        if uint16 is None:
            return
        self.value = uint16.Value()

    # UInt16T
    def Pack(self, builder):
        UInt16Start(builder)
        UInt16AddValue(builder, self.value)
        uint16 = UInt16End(builder)
        return uint16


class Int16(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int16()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt16(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Int16
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int16
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int16Flags, o + self._tab.Pos)
        return 0

def Int16Start(builder):
    builder.StartObject(1)

def Int16AddValue(builder, value):
    builder.PrependInt16Slot(0, value, 0)

def Int16End(builder):
    return builder.EndObject()



class Int16T(object):

    # Int16T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int16 = Int16()
        int16.Init(buf, pos)
        return cls.InitFromObj(int16)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, int16):
        x = Int16T()
        x._UnPack(int16)
        return x

    # Int16T
    def _UnPack(self, int16):
        if int16 is None:
            return
        self.value = int16.Value()

    # Int16T
    def Pack(self, builder):
        Int16Start(builder)
        Int16AddValue(builder, self.value)
        int16 = Int16End(builder)
        return int16


class UInt32(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UInt32()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUInt32(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # UInt32
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UInt32
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
        return 0

def UInt32Start(builder):
    builder.StartObject(1)

def UInt32AddValue(builder, value):
    builder.PrependUint32Slot(0, value, 0)

def UInt32End(builder):
    return builder.EndObject()



class UInt32T(object):

    # UInt32T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        uint32 = UInt32()
        uint32.Init(buf, pos)
        return cls.InitFromObj(uint32)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, uint32):
        x = UInt32T()
        x._UnPack(uint32)
        return x

    # UInt32T
    def _UnPack(self, uint32):
        if uint32 is None:
            return
        self.value = uint32.Value()

    # UInt32T
    def Pack(self, builder):
        UInt32Start(builder)
        UInt32AddValue(builder, self.value)
        uint32 = UInt32End(builder)
        return uint32


class Int32(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int32()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt32(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Int32
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int32
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

def Int32Start(builder):
    builder.StartObject(1)

def Int32AddValue(builder, value):
    builder.PrependInt32Slot(0, value, 0)

def Int32End(builder):
    return builder.EndObject()



class Int32T(object):

    # Int32T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int32 = Int32()
        int32.Init(buf, pos)
        return cls.InitFromObj(int32)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, int32):
        x = Int32T()
        x._UnPack(int32)
        return x

    # Int32T
    def _UnPack(self, int32):
        if int32 is None:
            return
        self.value = int32.Value()

    # Int32T
    def Pack(self, builder):
        Int32Start(builder)
        Int32AddValue(builder, self.value)
        int32 = Int32End(builder)
        return int32


class Float32(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Float32()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsFloat32(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Float32
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Float32
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float32Flags, o + self._tab.Pos)
        return 0.0

def Float32Start(builder):
    builder.StartObject(1)

def Float32AddValue(builder, value):
    builder.PrependFloat32Slot(0, value, 0.0)

def Float32End(builder):
    return builder.EndObject()



class Float32T(object):

    # Float32T
    def __init__(
        self,
        value = 0.0,
    ):
        self.value = value  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        float32 = Float32()
        float32.Init(buf, pos)
        return cls.InitFromObj(float32)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, float32):
        x = Float32T()
        x._UnPack(float32)
        return x

    # Float32T
    def _UnPack(self, float32):
        if float32 is None:
            return
        self.value = float32.Value()

    # Float32T
    def Pack(self, builder):
        Float32Start(builder)
        Float32AddValue(builder, self.value)
        float32 = Float32End(builder)
        return float32


class Bool(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Bool()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsBool(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Bool
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Bool
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

def BoolStart(builder):
    builder.StartObject(1)

def BoolAddValue(builder, value):
    builder.PrependBoolSlot(0, value, 0)

def BoolEnd(builder):
    return builder.EndObject()



class BoolT(object):

    # BoolT
    def __init__(
        self,
        value = False,
    ):
        self.value = value  # type: bool

    @classmethod
    def InitFromBuf(cls, buf, pos):
        bool = Bool()
        bool.Init(buf, pos)
        return cls.InitFromObj(bool)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, bool):
        x = BoolT()
        x._UnPack(bool)
        return x

    # BoolT
    def _UnPack(self, bool):
        if bool is None:
            return
        self.value = bool.Value()

    # BoolT
    def Pack(self, builder):
        BoolStart(builder)
        BoolAddValue(builder, self.value)
        bool = BoolEnd(builder)
        return bool


class UInt64(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = UInt64()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsUInt64(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # UInt64
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # UInt64
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

def UInt64Start(builder):
    builder.StartObject(1)

def UInt64AddValue(builder, value):
    builder.PrependUint64Slot(0, value, 0)

def UInt64End(builder):
    return builder.EndObject()



class UInt64T(object):

    # UInt64T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        uint64 = UInt64()
        uint64.Init(buf, pos)
        return cls.InitFromObj(uint64)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, uint64):
        x = UInt64T()
        x._UnPack(uint64)
        return x

    # UInt64T
    def _UnPack(self, uint64):
        if uint64 is None:
            return
        self.value = uint64.Value()

    # UInt64T
    def Pack(self, builder):
        UInt64Start(builder)
        UInt64AddValue(builder, self.value)
        uint64 = UInt64End(builder)
        return uint64


class Int64(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Int64()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInt64(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Int64
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Int64
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

def Int64Start(builder):
    builder.StartObject(1)

def Int64AddValue(builder, value):
    builder.PrependInt64Slot(0, value, 0)

def Int64End(builder):
    return builder.EndObject()



class Int64T(object):

    # Int64T
    def __init__(
        self,
        value = 0,
    ):
        self.value = value  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        int64 = Int64()
        int64.Init(buf, pos)
        return cls.InitFromObj(int64)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, int64):
        x = Int64T()
        x._UnPack(int64)
        return x

    # Int64T
    def _UnPack(self, int64):
        if int64 is None:
            return
        self.value = int64.Value()

    # Int64T
    def Pack(self, builder):
        Int64Start(builder)
        Int64AddValue(builder, self.value)
        int64 = Int64End(builder)
        return int64


class Double(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Double()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsDouble(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Double
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Double
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

def DoubleStart(builder):
    builder.StartObject(1)

def DoubleAddValue(builder, value):
    builder.PrependFloat64Slot(0, value, 0.0)

def DoubleEnd(builder):
    return builder.EndObject()



class DoubleT(object):

    # DoubleT
    def __init__(
        self,
        value = 0.0,
    ):
        self.value = value  # type: float

    @classmethod
    def InitFromBuf(cls, buf, pos):
        double = Double()
        double.Init(buf, pos)
        return cls.InitFromObj(double)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, double):
        x = DoubleT()
        x._UnPack(double)
        return x

    # DoubleT
    def _UnPack(self, double):
        if double is None:
            return
        self.value = double.Value()

    # DoubleT
    def Pack(self, builder):
        DoubleStart(builder)
        DoubleAddValue(builder, self.value)
        double = DoubleEnd(builder)
        return double


class StringValue(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = StringValue()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsStringValue(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # StringValue
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # StringValue
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def StringValueStart(builder):
    builder.StartObject(1)

def StringValueAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def StringValueEnd(builder):
    return builder.EndObject()



class StringValueT(object):

    # StringValueT
    def __init__(
        self,
        value = None,
    ):
        self.value = value  # type: Optional[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        stringValue = StringValue()
        stringValue.Init(buf, pos)
        return cls.InitFromObj(stringValue)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, stringValue):
        x = StringValueT()
        x._UnPack(stringValue)
        return x

    # StringValueT
    def _UnPack(self, stringValue):
        if stringValue is None:
            return
        self.value = stringValue.Value()

    # StringValueT
    def Pack(self, builder):
        if self.value is not None:
            value = builder.CreateString(self.value)
        StringValueStart(builder)
        if self.value is not None:
            StringValueAddValue(builder, value)
        stringValue = StringValueEnd(builder)
        return stringValue


class KeyValuePair(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = KeyValuePair()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsKeyValuePair(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # KeyValuePair
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # KeyValuePair
    def Key(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # KeyValuePair
    def ValueType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

    # KeyValuePair
    def Value(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            from flatbuffers.table import Table
            obj = Table(bytearray(), 0)
            self._tab.Union(obj, o)
            return obj
        return None

def KeyValuePairStart(builder):
    builder.StartObject(3)

def KeyValuePairAddKey(builder, key):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)

def KeyValuePairAddValueType(builder, valueType):
    builder.PrependUint8Slot(1, valueType, 0)

def KeyValuePairAddValue(builder, value):
    builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)

def KeyValuePairEnd(builder):
    return builder.EndObject()


try:
    from typing import Union
except:
    pass

class KeyValuePairT(object):

    # KeyValuePairT
    def __init__(
        self,
        key = None,
        valueType = 0,
        value = None,
    ):
        self.key = key  # type: Optional[str]
        self.valueType = valueType  # type: int
        self.value = value  # type: Union[None, 'UInt8T', 'Int8T', 'UInt16T', 'Int16T', 'UInt32T', 'Int32T', 'Float32T', 'BoolT', 'StringValueT', 'UInt64T', 'Int64T', 'DoubleT']

    @classmethod
    def InitFromBuf(cls, buf, pos):
        keyValuePair = KeyValuePair()
        keyValuePair.Init(buf, pos)
        return cls.InitFromObj(keyValuePair)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, keyValuePair):
        x = KeyValuePairT()
        x._UnPack(keyValuePair)
        return x

    # KeyValuePairT
    def _UnPack(self, keyValuePair):
        if keyValuePair is None:
            return
        self.key = keyValuePair.Key()
        self.valueType = keyValuePair.ValueType()
        self.value = VDataCreator(self.valueType, keyValuePair.Value())

    # KeyValuePairT
    def Pack(self, builder):
        if self.key is not None:
            key = builder.CreateString(self.key)
        if self.value is not None:
            value = self.value.Pack(builder)
        KeyValuePairStart(builder)
        if self.key is not None:
            KeyValuePairAddKey(builder, key)
        KeyValuePairAddValueType(builder, self.valueType)
        if self.value is not None:
            KeyValuePairAddValue(builder, value)
        keyValuePair = KeyValuePairEnd(builder)
        return keyValuePair


class SystemMetadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SystemMetadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSystemMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SystemMetadata
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SystemMetadata
    def Entries(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = KeyValuePair()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SystemMetadata
    def EntriesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SystemMetadata
    def EntriesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def SystemMetadataStart(builder):
    builder.StartObject(1)

def SystemMetadataAddEntries(builder, entries):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(entries), 0)

def SystemMetadataStartEntriesVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SystemMetadataEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class SystemMetadataT(object):

    # SystemMetadataT
    def __init__(
        self,
        entries = None,
    ):
        self.entries = entries  # type: Optional[List[KeyValuePairT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        systemMetadata = SystemMetadata()
        systemMetadata.Init(buf, pos)
        return cls.InitFromObj(systemMetadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, systemMetadata):
        x = SystemMetadataT()
        x._UnPack(systemMetadata)
        return x

    # SystemMetadataT
    def _UnPack(self, systemMetadata):
        if systemMetadata is None:
            return
        if not systemMetadata.EntriesIsNone():
            self.entries = []
            for i in range(systemMetadata.EntriesLength()):
                if systemMetadata.Entries(i) is None:
                    self.entries.append(None)
                else:
                    keyValuePair_ = KeyValuePairT.InitFromObj(systemMetadata.Entries(i))
                    self.entries.append(keyValuePair_)

    # SystemMetadataT
    def Pack(self, builder):
        if self.entries is not None:
            entrieslist = []
            for i in range(len(self.entries)):
                entrieslist.append(self.entries[i].Pack(builder))
            SystemMetadataStartEntriesVector(builder, len(self.entries))
            for i in reversed(range(len(self.entries))):
                builder.PrependUOffsetTRelative(entrieslist[i])
            entries = builder.EndVector()
        SystemMetadataStart(builder)
        if self.entries is not None:
            SystemMetadataAddEntries(builder, entries)
        systemMetadata = SystemMetadataEnd(builder)
        return systemMetadata


class SectionObject(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SectionObject()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSectionObject(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SectionObject
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SectionObject
    def Items(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = KeyValuePair()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SectionObject
    def ItemsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SectionObject
    def ItemsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # SectionObject
    def BeginOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # SectionObject
    def EndOffset(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # SectionObject
    def DataType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, o + self._tab.Pos)
        return 0

def SectionObjectStart(builder):
    builder.StartObject(4)

def SectionObjectAddItems(builder, items):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(items), 0)

def SectionObjectStartItemsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SectionObjectAddBeginOffset(builder, beginOffset):
    builder.PrependUint64Slot(1, beginOffset, 0)

def SectionObjectAddEndOffset(builder, endOffset):
    builder.PrependUint64Slot(2, endOffset, 0)

def SectionObjectAddDataType(builder, dataType):
    builder.PrependUint8Slot(3, dataType, 0)

def SectionObjectEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class SectionObjectT(object):

    # SectionObjectT
    def __init__(
        self,
        items = None,
        beginOffset = 0,
        endOffset = 0,
        dataType = 0,
    ):
        self.items = items  # type: Optional[List[KeyValuePairT]]
        self.beginOffset = beginOffset  # type: int
        self.endOffset = endOffset  # type: int
        self.dataType = dataType  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        sectionObject = SectionObject()
        sectionObject.Init(buf, pos)
        return cls.InitFromObj(sectionObject)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, sectionObject):
        x = SectionObjectT()
        x._UnPack(sectionObject)
        return x

    # SectionObjectT
    def _UnPack(self, sectionObject):
        if sectionObject is None:
            return
        if not sectionObject.ItemsIsNone():
            self.items = []
            for i in range(sectionObject.ItemsLength()):
                if sectionObject.Items(i) is None:
                    self.items.append(None)
                else:
                    keyValuePair_ = KeyValuePairT.InitFromObj(sectionObject.Items(i))
                    self.items.append(keyValuePair_)
        self.beginOffset = sectionObject.BeginOffset()
        self.endOffset = sectionObject.EndOffset()
        self.dataType = sectionObject.DataType()

    # SectionObjectT
    def Pack(self, builder):
        if self.items is not None:
            itemslist = []
            for i in range(len(self.items)):
                itemslist.append(self.items[i].Pack(builder))
            SectionObjectStartItemsVector(builder, len(self.items))
            for i in reversed(range(len(self.items))):
                builder.PrependUOffsetTRelative(itemslist[i])
            items = builder.EndVector()
        SectionObjectStart(builder)
        if self.items is not None:
            SectionObjectAddItems(builder, items)
        SectionObjectAddBeginOffset(builder, self.beginOffset)
        SectionObjectAddEndOffset(builder, self.endOffset)
        SectionObjectAddDataType(builder, self.dataType)
        sectionObject = SectionObjectEnd(builder)
        return sectionObject


class SectionMetadata(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SectionMetadata()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsSectionMetadata(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # SectionMetadata
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # SectionMetadata
    def Objects(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            obj = SectionObject()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # SectionMetadata
    def ObjectsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SectionMetadata
    def ObjectsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

def SectionMetadataStart(builder):
    builder.StartObject(1)

def SectionMetadataAddObjects(builder, objects):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(objects), 0)

def SectionMetadataStartObjectsVector(builder, numElems):
    return builder.StartVector(4, numElems, 4)

def SectionMetadataEnd(builder):
    return builder.EndObject()


try:
    from typing import List
except:
    pass

class SectionMetadataT(object):

    # SectionMetadataT
    def __init__(
        self,
        objects = None,
    ):
        self.objects = objects  # type: Optional[List[SectionObjectT]]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        sectionMetadata = SectionMetadata()
        sectionMetadata.Init(buf, pos)
        return cls.InitFromObj(sectionMetadata)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, sectionMetadata):
        x = SectionMetadataT()
        x._UnPack(sectionMetadata)
        return x

    # SectionMetadataT
    def _UnPack(self, sectionMetadata):
        if sectionMetadata is None:
            return
        if not sectionMetadata.ObjectsIsNone():
            self.objects = []
            for i in range(sectionMetadata.ObjectsLength()):
                if sectionMetadata.Objects(i) is None:
                    self.objects.append(None)
                else:
                    sectionObject_ = SectionObjectT.InitFromObj(sectionMetadata.Objects(i))
                    self.objects.append(sectionObject_)

    # SectionMetadataT
    def Pack(self, builder):
        if self.objects is not None:
            objectslist = []
            for i in range(len(self.objects)):
                objectslist.append(self.objects[i].Pack(builder))
            SectionMetadataStartObjectsVector(builder, len(self.objects))
            for i in reversed(range(len(self.objects))):
                builder.PrependUOffsetTRelative(objectslist[i])
            objects = builder.EndVector()
        SectionMetadataStart(builder)
        if self.objects is not None:
            SectionMetadataAddObjects(builder, objects)
        sectionMetadata = SectionMetadataEnd(builder)
        return sectionMetadata


class LiteRTLMMetaData(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LiteRTLMMetaData()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsLiteRTLMMetaData(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # LiteRTLMMetaData
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LiteRTLMMetaData
    def SystemMetadata(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = SystemMetadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LiteRTLMMetaData
    def SectionMetadata(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            obj = SectionMetadata()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def LiteRTLMMetaDataStart(builder):
    builder.StartObject(2)

def LiteRTLMMetaDataAddSystemMetadata(builder, systemMetadata):
    builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(systemMetadata), 0)

def LiteRTLMMetaDataAddSectionMetadata(builder, sectionMetadata):
    builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(sectionMetadata), 0)

def LiteRTLMMetaDataEnd(builder):
    return builder.EndObject()


try:
    from typing import Optional
except:
    pass

class LiteRTLMMetaDataT(object):

    # LiteRTLMMetaDataT
    def __init__(
        self,
        systemMetadata = None,
        sectionMetadata = None,
    ):
        self.systemMetadata = systemMetadata  # type: Optional[SystemMetadataT]
        self.sectionMetadata = sectionMetadata  # type: Optional[SectionMetadataT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        liteRtlmmetaData = LiteRTLMMetaData()
        liteRtlmmetaData.Init(buf, pos)
        return cls.InitFromObj(liteRtlmmetaData)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, liteRtlmmetaData):
        x = LiteRTLMMetaDataT()
        x._UnPack(liteRtlmmetaData)
        return x

    # LiteRTLMMetaDataT
    def _UnPack(self, liteRtlmmetaData):
        if liteRtlmmetaData is None:
            return
        if liteRtlmmetaData.SystemMetadata() is not None:
            self.systemMetadata = SystemMetadataT.InitFromObj(liteRtlmmetaData.SystemMetadata())
        if liteRtlmmetaData.SectionMetadata() is not None:
            self.sectionMetadata = SectionMetadataT.InitFromObj(liteRtlmmetaData.SectionMetadata())

    # LiteRTLMMetaDataT
    def Pack(self, builder):
        if self.systemMetadata is not None:
            systemMetadata = self.systemMetadata.Pack(builder)
        if self.sectionMetadata is not None:
            sectionMetadata = self.sectionMetadata.Pack(builder)
        LiteRTLMMetaDataStart(builder)
        if self.systemMetadata is not None:
            LiteRTLMMetaDataAddSystemMetadata(builder, systemMetadata)
        if self.sectionMetadata is not None:
            LiteRTLMMetaDataAddSectionMetadata(builder, sectionMetadata)
        liteRtlmmetaData = LiteRTLMMetaDataEnd(builder)
        return liteRtlmmetaData


