"""   
Supervertaler
=============
The Ultimate Translation Workbench.
Modern PyQt6 interface with specialised modules to handle any problem.
Framework: PyQt6

This is the modern edition of Supervertaler using PyQt6 framework.
For the classic tkinter edition, see Supervertaler_tkinter.py

Key Features:
- Complete Translation Matching: Termbase + TM + MT + Multi-LLM
- Project Termbases: Dedicated terminology per project with automatic extraction
- Supervoice: AI-enhanced voice dictation (100+ languages via OpenAI Whisper)
- Superimage: Extract images from DOCX files with preview
- Google Cloud Translation API integration
- Multi-LLM Support: OpenAI GPT, Claude, Google Gemini
- 2-Layer Prompt Architecture (System + Custom Prompts) with AI Assistant
- AI Assistant with conversational interface for document analysis
- Superlookup with global hotkey (Ctrl+Alt+L)
- Detachable Log window for multi-monitor setups
- Modern theme system (6 themes + custom editor)
- AutoFingers automation for memoQ with TagCleaner module
- memoQ bilingual DOCX import/export
- Bilingual Table export/import for review workflow
- SQLite-based translation memory with FTS5 search
- Professional TMX editor
- Spellcheck integration with Hunspell and custom dictionary support

Author: Michael Beijer
License: MIT
"""

# Version Information.
__version__ = "1.9.187"
__phase__ = "0.9"
__release_date__ = "2026-02-01"
__edition__ = "Qt"

import sys
import json
import os
import subprocess
import atexit
from pathlib import Path
from typing import List, Optional, Dict, Any, Tuple, Callable
from dataclasses import dataclass, asdict
from datetime import datetime


def get_resource_path(relative_path: str) -> Path:
    """Get absolute path to resource, works for dev and for PyInstaller bundled app."""
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # Running as compiled executable (PyInstaller)
        base_path = Path(sys._MEIPASS)
    else:
        # Running in development
        base_path = Path(__file__).parent
    return base_path / relative_path


def get_config_pointer_path() -> Path:
    """
    Get path to the config pointer file that stores the user's chosen data location.
    
    This is stored in a standard config location:
    - Windows: %APPDATA%/Supervertaler/config.json
    - macOS:   ~/Library/Application Support/Supervertaler/config.json
    - Linux:   ~/.config/Supervertaler/config.json
    
    This small file just contains a pointer to where the real data lives.
    """
    if sys.platform == 'win32':
        # Windows: %APPDATA% (Roaming, syncs across machines on domain)
        appdata = os.environ.get('APPDATA', os.path.expanduser('~'))
        return Path(appdata) / "Supervertaler" / "config.json"
    elif sys.platform == 'darwin':
        # macOS: ~/Library/Application Support/
        return Path.home() / "Library" / "Application Support" / "Supervertaler" / "config.json"
    else:
        # Linux/BSD: ~/.config/ (XDG_CONFIG_HOME)
        xdg_config = os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
        return Path(xdg_config) / "Supervertaler" / "config.json"


def get_default_user_data_path() -> Path:
    """
    Get the DEFAULT user data path (visible in home folder).
    
    - Windows: C:/Users/Username/Supervertaler/
    - macOS:   ~/Supervertaler/
    - Linux:   ~/Supervertaler/
    
    This is intentionally a visible, easily-accessible location.
    """
    return Path.home() / "Supervertaler"


def save_user_data_path(path: Path) -> None:
    """Save the user's chosen data path to the config pointer file."""
    pointer_path = get_config_pointer_path()
    pointer_path.parent.mkdir(parents=True, exist_ok=True)
    
    config = {"user_data_path": str(path)}
    with open(pointer_path, 'w', encoding='utf-8') as f:
        json.dump(config, f, indent=2)


def load_user_data_path_from_config() -> Optional[Path]:
    """
    Load the user's chosen data path from config pointer file.
    Returns None if no config exists or path is invalid.
    """
    pointer_path = get_config_pointer_path()
    
    if not pointer_path.exists():
        return None
    
    try:
        with open(pointer_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        path_str = config.get('user_data_path')
        if path_str:
            return Path(path_str)
    except (json.JSONDecodeError, OSError):
        pass
    
    return None


def get_user_data_path() -> Path:
    """
    Get the path to user data directory.
    
    Resolution order:
    1. Check config pointer file for user's saved preference
    2. If pointer missing, check if default location has data (auto-recover)
    3. If nothing found, return default (first-run dialog will be shown later)
    
    All users (EXE, pip, dev) use the same unified system:
    - Default: ~/Supervertaler/ (visible in home folder)
    - User can choose custom location on first run
    - Config pointer remembers their choice
    
    This ensures data survives pip upgrades, EXE updates, and is easy to find/backup.
    """
    # 1. Check if user has a saved preference
    saved_path = load_user_data_path_from_config()
    if saved_path and saved_path.exists():
        return saved_path
    
    # 2. Check if default location has data (auto-recovery if pointer deleted)
    default_path = get_default_user_data_path()
    if default_path.exists():
        # Check if it has actual content
        has_content = False
        try:
            for item in default_path.iterdir():
                if item.is_file() or (item.is_dir() and any(item.iterdir())):
                    has_content = True
                    break
        except OSError:
            pass
        
        if has_content:
            # Auto-recover: recreate the pointer file
            save_user_data_path(default_path)
            print(f"[Data Paths] Auto-recovered config pointer to: {default_path}")
            return default_path
    
    # 3. Return default path (first-run dialog will be shown by MainWindow)
    # Don't create folder yet - let the dialog handle that
    return default_path


def needs_first_run_data_dialog() -> bool:
    """
    Check if we need to show the first-run data location dialog.
    
    Returns True if:
    - No config pointer file exists, AND
    - Default data location doesn't have existing content
    
    This means it's truly a fresh install.
    """
    # If config pointer exists, user has already chosen a location
    pointer_path = get_config_pointer_path()
    if pointer_path.exists():
        return False
    
    # If default location has content, we auto-recovered (no dialog needed)
    default_path = get_default_user_data_path()
    if default_path.exists():
        try:
            for item in default_path.iterdir():
                if item.is_file() or (item.is_dir() and any(item.iterdir())):
                    return False  # Has content, no dialog needed
        except OSError:
            pass
    
    # Truly a fresh install - need to show dialog
    return True

import threading
import time  # For delays in Superlookup
import re

# Fix encoding for Windows console (UTF-8 support)
# Only set if stdout/stderr exist (they're None in PyInstaller --windowed mode)
if sys.platform == 'win32':
    import io
    if sys.stdout is not None and hasattr(sys.stdout, 'buffer'):
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    if sys.stderr is not None and hasattr(sys.stderr, 'buffer'):
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

# External dependencies
import pyperclip  # For clipboard operations in Superlookup
from modules.superlookup import SuperlookupEngine  # Superlookup engine
from modules.voice_dictation_lite import QuickDictationThread  # Voice dictation
from modules.voice_commands import VoiceCommandManager, VoiceCommand, ContinuousVoiceListener  # Voice commands (Talon-style)
from modules.statuses import (
    STATUSES,
    DEFAULT_STATUS,
    StatusDefinition,
    get_status,
    match_memoq_status,
    compose_memoq_status,
)
from modules import file_dialog_helper as fdh  # File dialog helper with last directory memory
from modules.spellcheck_manager import SpellcheckManager, get_spellcheck_manager  # Spellcheck with Hunspell
from modules.find_replace_qt import (
    FindReplaceHistory,
    FindReplaceOperation,
    FindReplaceSet,
    FindReplaceSetsManager,
    HistoryComboBox,
)  # F&R History and Sets
from modules.shortcut_manager import ShortcutManager  # Keyboard shortcut management
from modules.termview_widget import TermviewWidget  # Termview widget for glossary display


STATUS_ORDER = [
    "not_started",
    "pretranslated",
    "translated",
    "confirmed",
    "tr_confirmed",
    "proofread",
    "approved",
    "rejected",
]

STATUS_CYCLE = STATUS_ORDER

TRANSLATABLE_STATUSES = {"not_started", "pretranslated", "translated"}

# Check for PyQt6 and offer to install if missing
try:
    from PyQt6.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
        QTableWidget, QTableWidgetItem, QTableWidgetSelectionRange, QHeaderView, QMenuBar, QMenu,
        QFileDialog, QMessageBox, QToolBar, QLabel, QComboBox,
        QPushButton, QSpinBox, QSplitter, QTextEdit, QStatusBar,
        QStyledItemDelegate, QInputDialog, QDialog, QLineEdit, QRadioButton,
        QButtonGroup, QDialogButtonBox, QTabWidget, QGroupBox, QGridLayout, QCheckBox,
        QProgressBar, QProgressDialog, QFormLayout, QTabBar, QPlainTextEdit, QAbstractItemDelegate,
        QFrame, QListWidget, QListWidgetItem, QStackedWidget, QTreeWidget, QTreeWidgetItem,
        QScrollArea, QSizePolicy, QSlider, QToolButton, QAbstractItemView
    )
    from PyQt6.QtCore import Qt, QSize, QTimer, pyqtSignal, QObject, QUrl, QThread
    from PyQt6.QtGui import QFont, QAction, QKeySequence, QIcon, QTextOption, QColor, QDesktopServices, QTextCharFormat, QTextCursor, QBrush, QSyntaxHighlighter, QPalette, QTextBlockFormat, QCursor, QFontMetrics
    from PyQt6.QtWidgets import QStyleOptionViewItem, QStyle
    from PyQt6.QtCore import QRectF
    from PyQt6.QtNetwork import QNetworkAccessManager, QNetworkRequest, QNetworkReply
    from PyQt6 import sip
except ImportError:
    print("PyQt6 not found. Installing...")
    import subprocess
    subprocess.check_call([sys.executable, "-m", "pip", "install", "PyQt6"])
    print("‚úì PyQt6 installed. Please restart the application.")
    sys.exit(0)


# ============================================================================
# PRIVATE DATA PROTECTION SYSTEM
# ============================================================================

# Check for .supervertaler.local file to enable private features (for developers only)
# This ensures that private data (API keys, personal projects, etc.) stays in user_data_private/
# which is .gitignored, preventing accidental upload to GitHub
ENABLE_PRIVATE_FEATURES = os.path.exists(
    os.path.join(os.path.dirname(os.path.abspath(__file__)), ".supervertaler.local")
)
if ENABLE_PRIVATE_FEATURES:
    print("[DEV MODE] Private features enabled (.supervertaler.local found)")
    print("[DEV MODE] Using 'user_data_private/' folder (git-ignored)")
else:
    print("[USER MODE] Using 'user_data/' folder")


# ============================================================================
# GLOBAL AHK PROCESS CLEANUP
# ============================================================================

# Global variable to track AHK process
_ahk_process = None

def cleanup_ahk_process():
    """Cleanup function to kill AHK process on exit"""
    global _ahk_process
    if _ahk_process:
        try:
            _ahk_process.terminate()
            _ahk_process.wait(timeout=1)
            print("[Hotkeys] AHK process terminated on exit")
        except:
            try:
                _ahk_process.kill()
                print("[Hotkeys] AHK process killed on exit")
            except:
                pass

# Register cleanup function to run on Python exit
atexit.register(cleanup_ahk_process)


# ============================================================================
# ============================================================================
# DATA MODELS
# ============================================================================

# ============================================================================
# INLINE FORMATTING TAG UTILITIES
# ============================================================================

def runs_to_tagged_text(paragraphs) -> str:
    """
    Convert Word document paragraphs with run formatting to HTML-tagged text.
    
    Args:
        paragraphs: List of python-docx Paragraph objects
        
    Returns:
        String with HTML tags for formatting (e.g., "<b>bold</b> normal <i>italic</i>")
    """
    result_parts = []
    
    for paragraph in paragraphs:
        for run in paragraph.runs:
            text = run.text
            if not text:
                continue
            
            # Determine which tags to apply
            is_bold = run.bold == True
            is_italic = run.italic == True
            is_underline = run.underline == True
            
            # Build tagged text
            if is_bold or is_italic or is_underline:
                # Open tags (order: bold, italic, underline)
                if is_bold:
                    text = f"<b>{text}"
                if is_italic:
                    text = f"<i>{text}" if not is_bold else text.replace("<b>", "<b><i>", 1)
                if is_underline:
                    if is_bold and is_italic:
                        text = text.replace("<b><i>", "<b><i><u>", 1)
                    elif is_bold:
                        text = text.replace("<b>", "<b><u>", 1)
                    elif is_italic:
                        text = text.replace("<i>", "<i><u>", 1)
                    else:
                        text = f"<u>{text}"
                
                # Close tags (reverse order: underline, italic, bold)
                if is_underline:
                    text = f"{text}</u>"
                if is_italic:
                    text = f"{text}</i>"
                if is_bold:
                    text = f"{text}</b>"
            
            result_parts.append(text)
    
    return ''.join(result_parts)


def strip_formatting_tags(text: str) -> str:
    """
    Remove HTML formatting tags from text, leaving plain text.
    
    Args:
        text: Text with HTML tags like <b>, </b>, <i>, </i>, <u>, </u>
        
    Returns:
        Plain text without tags
    """
    import re
    # Remove <b>, </b>, <i>, </i>, <u>, </u> tags
    return re.sub(r'</?[biu]>', '', text)


def has_formatting_tags(text: str) -> bool:
    """
    Check if text contains any formatting tags.
    
    Args:
        text: Text to check
        
    Returns:
        True if text contains <b>, <i>, or <u> tags
    """
    import re
    return bool(re.search(r'</?[biu]>', text))


def apply_formatting_tags(text: str, tag: str) -> str:
    """
    Wrap text with the specified formatting tag.
    
    Args:
        text: Text to wrap
        tag: Tag name ('b', 'i', or 'u')
        
    Returns:
        Tagged text like "<b>text</b>"
    """
    if tag in ('b', 'i', 'u'):
        return f"<{tag}>{text}</{tag}>"
    return text


def get_formatted_html_display(text: str) -> str:
    """
    Convert our simple tags to HTML for rich text display.
    
    Args:
        text: Text with <b>, <i>, <u> tags
        
    Returns:
        HTML string suitable for QTextEdit.setHtml()
    """
    # Escape HTML entities first (except our tags)
    import html
    
    # Temporarily replace our tags with placeholders
    text = text.replace('<b>', '\x00B_OPEN\x00')
    text = text.replace('</b>', '\x00B_CLOSE\x00')
    text = text.replace('<i>', '\x00I_OPEN\x00')
    text = text.replace('</i>', '\x00I_CLOSE\x00')
    text = text.replace('<u>', '\x00U_OPEN\x00')
    text = text.replace('</u>', '\x00U_CLOSE\x00')
    
    # Escape other HTML
    text = html.escape(text)
    
    # Restore our tags as real HTML
    text = text.replace('\x00B_OPEN\x00', '<b>')
    text = text.replace('\x00B_CLOSE\x00', '</b>')
    text = text.replace('\x00I_OPEN\x00', '<i>')
    text = text.replace('\x00I_CLOSE\x00', '</i>')
    text = text.replace('\x00U_OPEN\x00', '<u>')
    text = text.replace('\x00U_CLOSE\x00', '</u>')
    
    return text


def tagged_text_to_runs(text: str) -> list:
    """
    Parse text with HTML formatting tags and return a list of runs with formatting info.
    
    Args:
        text: Text with <b>, <i>, <u> tags (can be nested)
        
    Returns:
        List of dicts: [{'text': str, 'bold': bool, 'italic': bool, 'underline': bool}, ...]
    
    Example:
        "Hello <b>bold</b> and <i>italic</i> world"
        -> [{'text': 'Hello ', 'bold': False, 'italic': False, 'underline': False},
            {'text': 'bold', 'bold': True, 'italic': False, 'underline': False},
            {'text': ' and ', 'bold': False, 'italic': False, 'underline': False},
            {'text': 'italic', 'bold': False, 'italic': True, 'underline': False},
            {'text': ' world', 'bold': False, 'italic': False, 'underline': False}]
    """
    import re
    
    runs = []
    
    # Track current formatting state
    is_bold = False
    is_italic = False
    is_underline = False
    
    # Pattern to match opening/closing tags
    tag_pattern = re.compile(r'(</?[biu]>)')
    
    # Split text by tags, keeping the tags as delimiters
    parts = tag_pattern.split(text)
    
    current_text = ""
    
    for part in parts:
        if part == '<b>':
            # Save any accumulated text before changing state
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_bold = True
        elif part == '</b>':
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_bold = False
        elif part == '<i>':
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_italic = True
        elif part == '</i>':
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_italic = False
        elif part == '<u>':
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_underline = True
        elif part == '</u>':
            if current_text:
                runs.append({
                    'text': current_text,
                    'bold': is_bold,
                    'italic': is_italic,
                    'underline': is_underline
                })
                current_text = ""
            is_underline = False
        else:
            # Regular text - accumulate it
            current_text += part
    
    # Don't forget any remaining text
    if current_text:
        runs.append({
            'text': current_text,
            'bold': is_bold,
            'italic': is_italic,
            'underline': is_underline
        })
    
    return runs


# ============================================================================
# MEMOQ TAG UTILITIES (for tag insertion shortcuts)
# ============================================================================

def extract_memoq_tags(text: str) -> list:
    """
    Extract all memoQ-style tags from text in order of appearance.
    
    memoQ uses several tag types:
    - Paired opening tags: [1}, [2}, [3} etc.
    - Paired closing tags: {1], {2], {3] etc.
    - Standalone tags: [1], [2], [3] etc. (e.g., for tabs, special characters)
    
    Args:
        text: Source text containing tags
        
    Returns:
        List of tag strings in order of appearance: ['[1}', '{1]', '[2]', ...]
    """
    import re
    # Match:
    # - Opening paired tags: [N}
    # - Closing paired tags: {N]
    # - Standalone tags: [N]
    pattern = r'(\[\d+\}|\{\d+\]|\[\d+\])'
    return re.findall(pattern, text)


def extract_html_tags(text: str) -> list:
    """
    Extract all HTML/XML tags from text in order of appearance.
    
    Supports common formatting tags used in translation:
    - Opening tags: <b>, <i>, <u>, <li>, <p>, <span>, etc.
    - Closing tags: </b>, </i>, </u>, </li>, </p>, </span>, etc.
    - Self-closing tags: <br/>, <hr/>, etc.
    
    Args:
        text: Source text containing HTML tags
        
    Returns:
        List of tag strings in order of appearance: ['<li>', '</li>', '<b>', '</b>', ...]
    """
    import re
    # Match HTML/XML tags: <tagname>, </tagname>, <tagname/>, <tagname attr="value">
    pattern = r'(</?[a-zA-Z][a-zA-Z0-9]*(?:\s+[^>]*)?>)'
    return re.findall(pattern, text)


def extract_all_tags(text: str) -> list:
    """
    Extract all tags (memoQ and HTML) from text in order of appearance.
    
    Args:
        text: Source text containing tags
        
    Returns:
        List of all tag strings in order of appearance
    """
    import re
    # Combined pattern for both memoQ tags and HTML tags
    # memoQ: [N}, {N], [N]
    # HTML: <tag>, </tag>, <tag/>, <tag attr="value"> - includes hyphenated tags like li-o, li-b
    pattern = r'(\[\d+\}|\{\d+\]|\[\d+\]|</?[a-zA-Z][a-zA-Z0-9-]*(?:\s+[^>]*)?>)'
    return re.findall(pattern, text)


def count_pipe_symbols(text: str) -> int:
    """Count the number of CafeTran pipe symbols in text."""
    return text.count('|')


def get_next_pipe_count_needed(source_text: str, target_text: str) -> int:
    """
    Get how many more pipe symbols are needed in target to match source.
    
    Args:
        source_text: Source segment text with pipe symbols
        target_text: Current target text
        
    Returns:
        Number of additional pipe symbols needed (0 if target has enough or more)
    """
    source_pipes = count_pipe_symbols(source_text)
    target_pipes = count_pipe_symbols(target_text)
    return max(0, source_pipes - target_pipes)


def get_tag_pair(tag_number: int) -> tuple:
    """
    Get opening and closing tag pair for a given number.
    
    Args:
        tag_number: The tag number (1, 2, 3, etc.)
        
    Returns:
        Tuple of (opening_tag, closing_tag) e.g. ('[1}', '{1]')
    """
    return (f'[{tag_number}}}', f'{{{tag_number}]')


def find_next_unused_tag(source_text: str, target_text: str) -> str:
    """
    Find the next tag from source that hasn't been used in target yet.
    
    Supports both memoQ tags ([1}, {1], [1]) and HTML tags (<li>, </li>, <b>, etc.)
    
    Args:
        source_text: Source segment text with tags
        target_text: Current target text (may have some tags already)
        
    Returns:
        The next tag to insert, or empty string if all tags are used
    """
    # Use combined extraction for both memoQ and HTML 	
    source_tags = extract_all_tags(source_text)
    target_tags = extract_all_tags(target_text)
    
    # Count occurrences in target
    from collections import Counter
    target_tag_counts = Counter(target_tags)
    source_tag_counts = Counter(source_tags)
    
    # Find first tag that needs more occurrences in target
    for tag in source_tags:
        source_count = source_tag_counts[tag]
        target_count = target_tag_counts.get(tag, 0)
        if target_count < source_count:
            return tag
    
    return ""  # All tags already in target


def get_wrapping_tag_pair(source_text: str, target_text: str) -> tuple:
    """
    Get the next available tag pair for wrapping selected text.
    
    Finds the first tag number from source where either opening or closing
    tag is not yet in target.
    
    Args:
        source_text: Source segment text with tags
        target_text: Current target text
        
    Returns:
        Tuple of (opening_tag, closing_tag) or (None, None) if no pairs available
    """
    import re
    
    # Extract all tag numbers from source
    source_tags = extract_memoq_tags(source_text)
    if not source_tags:
        return (None, None)
    
    # Get unique tag numbers in order
    tag_numbers = []
    for tag in source_tags:
        match = re.search(r'\d+', tag)
        if match:
            num = int(match.group())
            if num not in tag_numbers:
                tag_numbers.append(num)
    
    target_tags = extract_memoq_tags(target_text)
    
    # Find first tag number where pair is not complete in target
    for num in tag_numbers:
        opening, closing = get_tag_pair(num)
        if opening not in target_tags or closing not in target_tags:
            return (opening, closing)

    return (None, None)


def get_html_wrapping_tag_pair(source_text: str, target_text: str) -> tuple:
    """
    Get the next available HTML tag pair for wrapping selected text.

    Finds paired HTML tags (opening + closing) from source that are not yet
    complete in target. Supports common formatting tags: b, i, u, em, strong,
    span, li, p, a, sub, sup, etc.

    Args:
        source_text: Source segment text with HTML tags
        target_text: Current target text

    Returns:
        Tuple of (opening_tag, closing_tag) or (None, None) if no pairs available
    """
    import re

    # Find all HTML tags in source
    # Match: <tag>, <tag attr="...">, </tag>
    tag_pattern = r'<(/?)([a-zA-Z][a-zA-Z0-9-]*)(?:\s+[^>]*)?>'
    source_matches = re.findall(tag_pattern, source_text)
    target_matches = re.findall(tag_pattern, target_text)

    if not source_matches:
        return (None, None)

    # Build lists of opening and closing tags in source
    source_opening = []  # [(full_tag, tag_name), ...]
    source_closing = []

    for match in re.finditer(tag_pattern, source_text):
        is_closing = match.group(1) == '/'
        tag_name = match.group(2).lower()
        full_tag = match.group(0)

        if is_closing:
            source_closing.append((full_tag, tag_name))
        else:
            source_opening.append((full_tag, tag_name))

    # Build sets of tag names already in target
    target_opening_names = set()
    target_closing_names = set()

    for is_closing, tag_name in target_matches:
        if is_closing == '/':
            target_closing_names.add(tag_name.lower())
        else:
            target_opening_names.add(tag_name.lower())

    # Find first tag pair where both opening and closing exist in source
    # but at least one is missing from target
    seen_tags = set()
    for full_tag, tag_name in source_opening:
        if tag_name in seen_tags:
            continue
        seen_tags.add(tag_name)

        # Check if there's a matching closing tag in source
        has_closing = any(name == tag_name for _, name in source_closing)
        if not has_closing:
            continue

        # Check if pair is incomplete in target
        opening_in_target = tag_name in target_opening_names
        closing_in_target = tag_name in target_closing_names

        if not opening_in_target or not closing_in_target:
            # Find the actual opening and closing tags from source
            opening_tag = full_tag
            closing_tag = f"</{tag_name}>"
            return (opening_tag, closing_tag)

    return (None, None)


@dataclass
class Segment:
    """Translation segment (matches tkinter version format)"""
    id: int
    source: str
    target: str = ""
    status: str = DEFAULT_STATUS.key
    type: str = "para"  # para, heading, list_item, table_cell
    notes: str = ""  # Stored as ‚ÄúComments‚Äù in UI
    match_percent: Optional[int] = None  # memoQ match score if provided
    memoQ_status: str = ""  # Raw memoQ status text
    locked: bool = False  # For compatibility with tkinter version
    paragraph_id: int = 0  # Group segments by paragraph for document flow
    style: str = "Normal"  # Heading 1, Heading 2, Title, Subtitle, Normal, etc.
    document_position: int = 0  # Position in original document
    is_table_cell: bool = False  # Whether this segment is in a table
    table_info: Optional[tuple] = None  # (table_idx, row_idx, cell_idx) if is_table_cell
    modified: bool = False  # Track if segment has been edited
    created_at: str = ""  # Creation timestamp
    modified_at: str = ""  # Last modification timestamp
    list_number: Optional[int] = None  # For numbered lists: 1, 2, 3, etc. None for bullets or non-lists
    list_type: str = ""  # "numbered", "bullet", or "" for non-list items
    file_id: Optional[int] = None  # ID of the file this segment belongs to (for multi-file projects)
    file_name: str = ""  # Name of the file this segment belongs to (for multi-file projects)
    dejavu_segment_id: str = ""  # D√©j√† Vu segment ID for round-trip export
    dejavu_row_index: Optional[int] = None  # D√©j√† Vu row index for export mapping
    
    def __post_init__(self):
        """Initialize timestamps if not provided"""
        if not self.created_at:
            self.created_at = datetime.now().isoformat()
        if not self.modified_at:
            self.modified_at = datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Segment':
        """Create Segment from dictionary, ignoring unknown fields"""
        # Only use fields that the dataclass knows about
        valid_fields = {f.name for f in cls.__dataclass_fields__.values()}
        filtered_data = {k: v for k, v in data.items() if k in valid_fields}
        return cls(**filtered_data)


@dataclass
class Project:
    """Translation project"""
    name: str
    source_lang: str = "en"
    target_lang: str = "nl"
    segments: List[Segment] = None
    created: str = ""
    modified: str = ""
    prompt_settings: Dict[str, Any] = None  # Store active prompt settings
    tm_settings: Dict[str, Any] = None  # Store activated TM settings
    termbase_settings: Dict[str, Any] = None  # Store activated termbase settings
    nt_settings: Dict[str, Any] = None  # Store activated non-translatables settings
    spellcheck_settings: Dict[str, Any] = None  # Store spellcheck settings {enabled, language}
    ui_settings: Dict[str, Any] = None  # Store UI settings (results pane zoom, etc.)
    general_settings_overrides: Dict[str, Any] = None  # Per-project overrides for general settings
    id: int = None  # Unique project ID for TM activation tracking
    original_docx_path: str = None  # Path to original DOCX for structure-preserving export
    trados_source_path: str = None  # Path to original Trados bilingual DOCX for round-trip export
    memoq_source_path: str = None  # Path to original memoQ bilingual DOCX for round-trip export
    mqxliff_source_path: str = None  # Path to original memoQ XLIFF for round-trip export
    cafetran_source_path: str = None  # Path to original CafeTran bilingual DOCX for round-trip export
    sdlppx_source_path: str = None  # Path to original Trados SDLPPX package for SDLRPX export
    original_txt_path: str = None  # Path to original simple text file for round-trip export
    dejavu_source_path: str = None  # Path to original D√©j√† Vu bilingual RTF for round-trip export
    concordance_geometry: Dict[str, int] = None  # Window geometry for Concordance Search {x, y, width, height}
    # Multi-file project support
    files: List[Dict[str, Any]] = None  # List of files in project: [{id, name, path, type, segment_count, ...}]
    is_multifile: bool = False  # True if this is a multi-file project
    # Scratchpad for private translator notes (stored only in .svproj, never exported to CAT tools)
    scratchpad_notes: str = ""
    
    def __post_init__(self):
        if self.segments is None:
            self.segments = []
        if self.files is None:
            self.files = []
        if not self.created:
            self.created = datetime.now().isoformat()
        if not self.modified:
            self.modified = datetime.now().isoformat()
        if self.prompt_settings is None:
            self.prompt_settings = {}
        if self.tm_settings is None:
            self.tm_settings = {}
        if self.termbase_settings is None:
            self.termbase_settings = {}
        if self.nt_settings is None:
            self.nt_settings = {}
        if self.spellcheck_settings is None:
            self.spellcheck_settings = {}
        if self.ui_settings is None:
            self.ui_settings = {}
        if self.general_settings_overrides is None:
            self.general_settings_overrides = {}
        # Generate ID if not set (for backward compatibility with old projects)
        if self.id is None:
            import hashlib
            # Create stable ID from project name + created timestamp
            id_source = f"{self.name}_{self.created}"
            self.id = int(hashlib.md5(id_source.encode()).hexdigest()[:8], 16)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization.
        
        Structure is organized for human readability when opened in a text editor:
        1. Project identification (name, languages, dates, id)
        2. Settings (prompts, TM, termbases, spellcheck, etc.)
        3. Source file paths
        4. UI state (concordance geometry)
        5. Segments (at the end - the actual translation content)
        """
        # Start with core project metadata
        result = {
            'name': self.name,
            'source_lang': self.source_lang,
            'target_lang': self.target_lang,
            'created': self.created,
            'modified': self.modified,
            'id': self.id  # Save project ID
        }
        
        # Add settings (prompts, TM, termbases, etc.)
        if hasattr(self, 'prompt_settings'):
            result['prompt_settings'] = self.prompt_settings
        if self.tm_settings:
            result['tm_settings'] = self.tm_settings
        if self.termbase_settings:
            result['termbase_settings'] = self.termbase_settings
        if self.nt_settings:
            result['nt_settings'] = self.nt_settings
        if self.spellcheck_settings:
            result['spellcheck_settings'] = self.spellcheck_settings
        if self.ui_settings:
            result['ui_settings'] = self.ui_settings
        
        # Add source file paths
        if self.original_docx_path:
            result['original_docx_path'] = self.original_docx_path
        if self.trados_source_path:
            result['trados_source_path'] = self.trados_source_path
        if self.memoq_source_path:
            result['memoq_source_path'] = self.memoq_source_path
        if self.mqxliff_source_path:
            result['mqxliff_source_path'] = self.mqxliff_source_path
        if self.cafetran_source_path:
            result['cafetran_source_path'] = self.cafetran_source_path
        if self.sdlppx_source_path:
            result['sdlppx_source_path'] = self.sdlppx_source_path
        if self.original_txt_path:
            result['original_txt_path'] = self.original_txt_path
        if self.dejavu_source_path:
            result['dejavu_source_path'] = self.dejavu_source_path
        
        # Add UI state
        if self.concordance_geometry:
            result['concordance_geometry'] = self.concordance_geometry
        
        # Add multi-file project data
        if self.is_multifile:
            result['is_multifile'] = self.is_multifile
        if self.files:
            result['files'] = self.files
        
        # Add scratchpad notes (private translator notes, never exported to CAT tools)
        if self.scratchpad_notes:
            result['scratchpad_notes'] = self.scratchpad_notes
        
        # Add segments LAST (so they appear at the end of the file)
        result['segments'] = [seg.to_dict() for seg in self.segments]
        
        return result
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Project':
        """Create Project from dictionary"""
        segments = [Segment.from_dict(seg) for seg in data.get('segments', [])]
        
        # Handle missing name field (use filename or default)
        name = data.get('name', 'Untitled Project')
        
        project = cls(
            name=name,
            source_lang=data.get('source_lang', 'en'),
            target_lang=data.get('target_lang', 'nl'),
            segments=segments,
            created=data.get('created', ''),
            modified=data.get('modified', ''),
            id=data.get('id', None)  # Load project ID (will auto-generate if missing)
        )
        # Store prompt settings if they exist
        if 'prompt_settings' in data:
            project.prompt_settings = data['prompt_settings']
        # Store TM settings if they exist
        if 'tm_settings' in data:
            project.tm_settings = data['tm_settings']
        # Store termbase settings if they exist
        if 'termbase_settings' in data:
            project.termbase_settings = data['termbase_settings']
        # Store non-translatables settings if they exist
        if 'nt_settings' in data:
            project.nt_settings = data['nt_settings']
        # Store spellcheck settings if they exist
        if 'spellcheck_settings' in data:
            project.spellcheck_settings = data['spellcheck_settings']
        # Store UI settings if they exist
        if 'ui_settings' in data:
            project.ui_settings = data['ui_settings']
        # Store original DOCX path if it exists
        if 'original_docx_path' in data:
            project.original_docx_path = data['original_docx_path']
        # Store Trados source path if it exists
        if 'trados_source_path' in data:
            project.trados_source_path = data['trados_source_path']
        # Store memoQ source path if it exists
        if 'memoq_source_path' in data:
            project.memoq_source_path = data['memoq_source_path']
        # Store memoQ XLIFF source path if it exists
        if 'mqxliff_source_path' in data:
            project.mqxliff_source_path = data['mqxliff_source_path']
        # Store CafeTran source path if it exists
        if 'cafetran_source_path' in data:
            project.cafetran_source_path = data['cafetran_source_path']
        # Store SDLPPX source path if it exists
        if 'sdlppx_source_path' in data:
            project.sdlppx_source_path = data['sdlppx_source_path']
        # Store original TXT path if it exists
        if 'original_txt_path' in data:
            project.original_txt_path = data['original_txt_path']
        # Store D√©j√† Vu source path if it exists
        if 'dejavu_source_path' in data:
            project.dejavu_source_path = data['dejavu_source_path']
        # Store concordance window geometry if it exists
        if 'concordance_geometry' in data:
            project.concordance_geometry = data['concordance_geometry']
        # Store multi-file project data if it exists
        if 'is_multifile' in data:
            project.is_multifile = data['is_multifile']
        if 'files' in data:
            project.files = data['files']
        # Store scratchpad notes if they exist
        if 'scratchpad_notes' in data:
            project.scratchpad_notes = data['scratchpad_notes']
        return project


# ============================================================================
# CUSTOM DELEGATES AND EDITORS
# ============================================================================


class _CtrlReturnEventFilter(QObject):
    """App-level event filter to catch Ctrl+Return/Ctrl+Enter for grid confirm.

    This is a workaround for cases where the main keyboard Return key (Key_Return)
    is swallowed before it reaches the source cell editor or QShortcut.
    """

    def __init__(self, main_window):
        super().__init__(main_window)
        self._main_window = main_window

    def eventFilter(self, obj, event):
        from PyQt6.QtCore import QEvent
        from PyQt6.QtWidgets import QApplication

        if event.type() != QEvent.Type.KeyPress:
            return False

        # Only handle Ctrl+Return/Ctrl+Enter (ignore Shift/Alt variants)
        mods = event.modifiers()
        if not (mods & Qt.KeyboardModifier.ControlModifier):
            return False
        if mods & (Qt.KeyboardModifier.ShiftModifier | Qt.KeyboardModifier.AltModifier):
            return False
        if event.key() not in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            return False

        mw = self._main_window
        if not mw or not mw.isActiveWindow():
            return False

        table = getattr(mw, 'table', None)
        if table is None:
            return False

        focus = QApplication.focusWidget()
        if focus is None:
            return False

        # Allow triggering when focus is in the grid itself OR in the grid's filter boxes.
        # This keeps the shortcut useful while typing filters (e.g. "Filter Source" box).
        source_filter = getattr(mw, 'source_filter', None)
        target_filter = getattr(mw, 'target_filter', None)
        if focus in (source_filter, target_filter) or focus is table or focus is table.viewport() or table.isAncestorOf(focus) or isinstance(focus, (ReadOnlyGridTextEditor, EditableGridTextEditor)):
            if hasattr(mw, 'confirm_selected_or_next'):
                mw.confirm_selected_or_next()
                return True

        return False


class GridTableEventFilter:
    """Mixin to pass keyboard shortcuts from editor to table"""
    pass


class GridTextEditor(QTextEdit):
    """Custom QTextEdit for grid cells that passes special shortcuts to parent"""
    
    table_widget = None  # Will be set by delegate
    assistance_panel = None  # Will be set by delegate
    current_row = None  # Track which row this editor is in
    
    def __init__(self, parent=None):
        super().__init__(parent)
        # Prevent Tab from changing focus - we handle it manually
        self.setTabChangesFocus(False)
    
    def keyPressEvent(self, event):
        """Override keyPressEvent to handle Tab - this is called AFTER event()"""
        # Ctrl+Tab: Insert actual tab character
        if event.key() == Qt.Key.Key_Tab and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self.insertPlainText('\t')
            event.accept()
            return
        
        # Tab (without Ctrl): Cycle to source cell
        if event.key() == Qt.Key.Key_Tab:
            if self.table_widget and self.current_row is not None:
                # Close current editor
                self.table_widget.closeEditor(self, QAbstractItemDelegate.EndEditHint.NoHint)
                # Open editor for source cell in same row (column 2)
                source_index = self.table_widget.model().index(self.current_row, 2)
                self.table_widget.setCurrentIndex(source_index)
                self.table_widget.edit(source_index)
                event.accept()
                return
        
        # Handle other Ctrl+ shortcuts
        if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
            # Ctrl+1 through Ctrl+9: Insert match by number
            # TODO: Update to work with new results_panels system
            if event.key() >= Qt.Key.Key_1 and event.key() <= Qt.Key.Key_9:
                # Disabled for now - needs update to work with results_panels
                pass
            # Ctrl+Up/Down: Send to grid for grid navigation
            elif event.key() in (Qt.Key.Key_Up, Qt.Key.Key_Down):
                if self.table_widget:
                    self.table_widget.keyPressEvent(event)
                    event.accept()
                    return
            # Ctrl+Enter: Confirm & Next (call main window method directly)
            elif event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
                if self.main_window and hasattr(self.main_window, 'confirm_selected_or_next'):
                    self.main_window.confirm_selected_or_next()
                event.accept()
                return
            # Ctrl+, (comma): Insert next memoQ tag or wrap selection with tag pair
            elif event.key() == Qt.Key.Key_Comma:
                self._insert_next_tag_or_wrap_selection()
                event.accept()
                return
        
        # Shift+Enter: Insert line break (for multi-line content)
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            if event.modifiers() & Qt.KeyboardModifier.ShiftModifier:
                super().keyPressEvent(event)
                event.accept()
                return
        
        # Enter/Return: Don't insert, let delegate handle it (will close editor)
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Just ignore it - the table's default behavior will close the editor
            event.ignore()
            return
        
        # All other keys: Handle normally (including ESC for closing editor)
        print(f"üîë GridTextEditor: Passing to super().keyPressEvent")
        super().keyPressEvent(event)
    
    def _insert_next_tag_or_wrap_selection(self):
        """
        Insert the next memoQ tag, HTML tag, or CafeTran pipe symbol from source, or wrap selection.

        Behavior:
        - If text is selected: Wrap it with the next available tag pair [N}selection{N] or <tag>selection</tag> or |selection|
        - If no selection: Insert the next unused tag/pipe from source at cursor position

        Supports:
        - memoQ tags: [1}, {1], [2}, {2], etc.
        - HTML/XML tags: <li>, </li>, <b>, </b>, <i>, </i>, etc.
        - CafeTran pipe symbols: |

        Shortcut: Ctrl+, (comma)
        """
        # Get the main window and current segment
        if not self.table_widget or self.current_row is None:
            return

        # Navigate up to find main window
        main_window = self.table_widget.parent()
        while main_window and not hasattr(main_window, 'current_project'):
            main_window = main_window.parent()

        if not main_window or not hasattr(main_window, 'current_project'):
            return

        if not main_window.current_project or self.current_row >= len(main_window.current_project.segments):
            return

        segment = main_window.current_project.segments[self.current_row]
        source_text = segment.source
        current_target = self.toPlainText()

        # Check what type of tags are in the source
        has_memoq_tags = bool(extract_memoq_tags(source_text))
        has_html_tags = bool(extract_html_tags(source_text))
        has_any_tags = has_memoq_tags or has_html_tags
        has_pipe_symbols = '|' in source_text

        # Check if there's a selection
        cursor = self.textCursor()
        if cursor.hasSelection():
            selected_text = cursor.selectedText()

            # Try memoQ tag pair first
            if has_memoq_tags:
                opening_tag, closing_tag = get_wrapping_tag_pair(source_text, current_target)
                if opening_tag and closing_tag:
                    wrapped_text = f"{opening_tag}{selected_text}{closing_tag}"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with {opening_tag}...{closing_tag}")
                    return

            # Try HTML tag pairs (e.g., <b>...</b>, <i>...</i>)
            if has_html_tags:
                opening_tag, closing_tag = get_html_wrapping_tag_pair(source_text, current_target)
                if opening_tag and closing_tag:
                    wrapped_text = f"{opening_tag}{selected_text}{closing_tag}"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with {opening_tag}...{closing_tag}")
                    return

            # Try CafeTran pipe symbols
            if has_pipe_symbols:
                pipes_needed = get_next_pipe_count_needed(source_text, current_target)
                if pipes_needed >= 2:
                    # Wrap with pipes
                    wrapped_text = f"|{selected_text}|"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with |...|")
                    return

            if hasattr(main_window, 'log'):
                main_window.log("‚ö†Ô∏è No tag pairs available from source")
        else:
            # No selection - insert next unused tag or pipe at cursor

            # Try memoQ tags and HTML tags (find_next_unused_tag handles both)
            if has_any_tags:
                next_tag = find_next_unused_tag(source_text, current_target)
                if next_tag:
                    cursor.insertText(next_tag)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Inserted tag: {next_tag}")
                    return

            # Try CafeTran pipe symbols
            if has_pipe_symbols:
                pipes_needed = get_next_pipe_count_needed(source_text, current_target)
                if pipes_needed > 0:
                    cursor.insertText('|')
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Inserted pipe symbol (|)")
                    return

            if hasattr(main_window, 'log'):
                main_window.log("‚úì All tags from source already in target")


class ReadOnlyGridTextEditor(QTextEdit):
    """Read-only QTextEdit for source cells - allows easy text selection"""
    
    # Class variable for tag highlight color (shared across all instances)
    tag_highlight_color = '#7f0001'  # Default memoQ dark red
    
    table_widget = None  # Will be set by delegate
    current_row = None  # Track which row this editor is in
    allow_source_edit = False  # Will be set by delegate based on settings
    
    def __init__(self, text: str = "", parent=None, row: int = -1):
        super().__init__(parent)
        self.row = row  # Store row number for Tab cycling
        self.table_ref = parent  # Store table reference (parent is the table)
        self.setReadOnly(True)  # Prevent typing but allow selection
        self.setPlainText(text)

        # CRITICAL: Enable keyboard focus and text selection
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
        # Enable text interaction: selection with keyboard and mouse
        self.setTextInteractionFlags(
            Qt.TextInteractionFlag.TextSelectableByKeyboard |
            Qt.TextInteractionFlag.TextSelectableByMouse
        )

        # Make inactive selections stay visible with same color
        from PyQt6.QtGui import QPalette
        palette = self.palette()
        palette.setColor(QPalette.ColorGroup.Active, QPalette.ColorRole.Highlight, QColor("#D0E7FF"))
        palette.setColor(QPalette.ColorGroup.Active, QPalette.ColorRole.HighlightedText, QColor("black"))
        palette.setColor(QPalette.ColorGroup.Inactive, QPalette.ColorRole.Highlight, QColor("#D0E7FF"))
        palette.setColor(QPalette.ColorGroup.Inactive, QPalette.ColorRole.HighlightedText, QColor("black"))
        self.setPalette(palette)

        # Style to look like a normal cell with subtle selection
        # Background and text colors now managed by theme system
        self.setStyleSheet("""
            QTextEdit {
                border: none;
                padding: 0px 4px 0px 0px;
            }
            QTextEdit:focus {
                border: 1px solid #2196F3;
            }
            QTextEdit::selection {
                background-color: #D0E7FF;
                color: black;
            }
        """)

        # Set document margins to 0 for compact display
        doc = self.document()
        doc.setDocumentMargin(0)

        # Configure text option for minimal line spacing
        # With zero-width spaces inserted after invisible character markers,
        # normal WordWrap will work correctly
        wrap_mode = QTextOption.WrapMode.WordWrap

        self.setWordWrapMode(wrap_mode)
        self.setAcceptRichText(False)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        text_option = QTextOption()
        text_option.setWrapMode(wrap_mode)
        doc.setDefaultTextOption(text_option)
        
        # Set minimum height to 0 - let content determine size
        self.setMinimumHeight(0)
        self.setMaximumHeight(16777215)  # Qt's max int
        
        # Store termbase matches for this cell (for tooltip and double-click)
        self.termbase_matches = {}
        
        # Enable mouse tracking for hover tooltips
        self.setMouseTracking(True)

        # Add syntax highlighter for tags (no spellcheck for source cells)
        # Get invisible char color and tag color from main window (theme-aware)
        main_window = self._get_main_window()
        invisible_char_color = main_window.invisible_char_color if main_window and hasattr(main_window, 'invisible_char_color') else '#999999'

        # Use theme-aware tag color (light pink in dark mode, dark red in light mode)
        is_dark = main_window and hasattr(main_window, 'theme_manager') and main_window.theme_manager and main_window.theme_manager.current_theme.name == "Dark"
        tag_color = '#FFB6C1' if is_dark else self.tag_highlight_color  # Light pink in dark mode

        self.highlighter = TagHighlighter(self.document(), tag_color, invisible_char_color, enable_spellcheck=False)

        # Store raw text (with tags) for mode switching
        self._raw_text = text
    
    def keyPressEvent(self, event):
        """Override to fix clipboard and word navigation when invisible characters shown"""
        from PyQt6.QtCore import Qt
        from PyQt6.QtWidgets import QApplication
        from PyQt6.QtGui import QTextCursor
        
        # Check for Ctrl+C (copy)
        if event.modifiers() == Qt.KeyboardModifier.ControlModifier and event.key() == Qt.Key.Key_C:
            # Get selected text
            cursor = self.textCursor()
            if cursor.hasSelection():
                selected_text = cursor.selectedText()
                # Reverse invisible character replacements before copying
                main_window = self._get_main_window()
                if main_window and hasattr(main_window, 'reverse_invisible_replacements'):
                    clean_text = main_window.reverse_invisible_replacements(selected_text)
                    # Also replace paragraph separator with newline (Qt uses U+2029)
                    clean_text = clean_text.replace('\u2029', '\n')
                    # Set clipboard with clean text
                    clipboard = QApplication.clipboard()
                    clipboard.setText(clean_text)
                    return  # Don't call parent - we handled it
        
        # Handle Ctrl+Arrow word navigation when invisibles are shown
        main_window = self._get_main_window()
        if main_window and hasattr(main_window, 'invisible_display_settings'):
            if main_window.invisible_display_settings.get('spaces', False):
                ctrl_only = event.modifiers() == Qt.KeyboardModifier.ControlModifier
                ctrl_shift = event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier)
                
                if (ctrl_only or ctrl_shift) and event.key() in (Qt.Key.Key_Left, Qt.Key.Key_Right):
                    cursor = self.textCursor()
                    text = self.toPlainText()
                    pos = cursor.position()
                    word_chars = ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂', ' ')
                    
                    if event.key() == Qt.Key.Key_Right:
                        # Move to end of current word, then skip delimiters to start of next word
                        # First skip any delimiters we're on
                        while pos < len(text) and text[pos] in word_chars:
                            pos += 1
                        # Then skip to end of word (next delimiter)
                        while pos < len(text) and text[pos] not in word_chars:
                            pos += 1
                    else:  # Key_Left
                        # Move backwards: skip delimiters, then find start of word
                        if pos > 0:
                            pos -= 1
                        # Skip any delimiters
                        while pos > 0 and text[pos] in word_chars:
                            pos -= 1
                        # Find start of word
                        while pos > 0 and text[pos - 1] not in word_chars:
                            pos -= 1
                    
                    # Apply cursor movement
                    if ctrl_shift:
                        cursor.setPosition(pos, QTextCursor.MoveMode.KeepAnchor)
                    else:
                        cursor.setPosition(pos)
                    self.setTextCursor(cursor)
                    return
        
        # Arrow Up/Down: memoQ-style segment navigation at cell boundaries
        # When cursor is at top line and Up is pressed, go to previous segment
        # When cursor is at bottom line and Down is pressed, go to next segment
        if event.key() in (Qt.Key.Key_Up, Qt.Key.Key_Down) and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            cursor = self.textCursor()
            
            # Get current cursor position info
            current_block = cursor.block()
            doc = self.document()
            first_block = doc.firstBlock()
            last_block = doc.lastBlock()
            
            # Get table reference
            table = self.table_ref if hasattr(self, 'table_ref') else self.parent()
            
            if event.key() == Qt.Key.Key_Up:
                # Check if we're on the first line
                if current_block == first_block:
                    # Navigate to previous segment
                    main_window = self._get_main_window()
                    if main_window and hasattr(main_window, 'go_to_previous_segment'):
                        # Get cursor column position for smart positioning
                        col_in_line = cursor.positionInBlock()
                        # Navigate and let go_to_previous_segment position cursor in target cell
                        main_window.go_to_previous_segment(target_column=col_in_line, to_last_line=True)
                        
                        # Now move focus from target to source cell, preserving column position
                        if table:
                            current_row = table.currentRow()
                            source_widget = table.cellWidget(current_row, 2)  # Column 2 is Source
                            if source_widget and hasattr(source_widget, 'textCursor'):
                                new_cursor = source_widget.textCursor()
                                src_doc = source_widget.document()
                                src_last_block = src_doc.lastBlock()
                                new_cursor.setPosition(src_last_block.position())
                                line_length = src_last_block.length() - 1
                                target_pos = min(col_in_line, max(0, line_length))
                                new_cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.MoveAnchor, target_pos)
                                source_widget.setTextCursor(new_cursor)
                                source_widget.setFocus()
                        return
            
            elif event.key() == Qt.Key.Key_Down:
                # Check if we're on the last line
                if current_block == last_block:
                    # Navigate to next segment
                    main_window = self._get_main_window()
                    if main_window and hasattr(main_window, 'go_to_next_segment'):
                        # Get cursor column position for smart positioning
                        col_in_line = cursor.positionInBlock()
                        # Navigate and let go_to_next_segment position cursor in target cell
                        main_window.go_to_next_segment(target_column=col_in_line, to_first_line=True)
                        
                        # Now move focus from target to source cell, preserving column position
                        if table:
                            current_row = table.currentRow()
                            source_widget = table.cellWidget(current_row, 2)  # Column 2 is Source
                            if source_widget and hasattr(source_widget, 'textCursor'):
                                new_cursor = source_widget.textCursor()
                                src_doc = source_widget.document()
                                src_first_block = src_doc.firstBlock()
                                new_cursor.setPosition(src_first_block.position())
                                line_length = src_first_block.length() - 1
                                target_pos = min(col_in_line, max(0, line_length))
                                new_cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.MoveAnchor, target_pos)
                                source_widget.setTextCursor(new_cursor)
                                source_widget.setFocus()
                        return
        
        # Ctrl+Enter: Confirm & Next (same behavior as in target cell)
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            mods = event.modifiers()
            if (mods & Qt.KeyboardModifier.ControlModifier) and not (mods & (Qt.KeyboardModifier.ShiftModifier | Qt.KeyboardModifier.AltModifier)):
                main_window = self._get_main_window()
                if main_window and hasattr(main_window, 'confirm_selected_or_next'):
                    main_window.confirm_selected_or_next()
                    event.accept()
                    return
        
        # Tab key: Cycle to target cell (column 3) in same row
        if event.key() == Qt.Key.Key_Tab and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            table = self.table_ref if hasattr(self, 'table_ref') else self.parent()
            if table and self.row >= 0:
                target_widget = table.cellWidget(self.row, 3)  # Column 3 is Target
                if target_widget:
                    target_widget.setFocus()
                    table.setCurrentCell(self.row, 3)
                    return
        
        super().keyPressEvent(event)
    
    def mouseDoubleClickEvent(self, event):
        """Handle double-click to select words properly when invisibles are shown"""
        from PyQt6.QtCore import Qt
        from PyQt6.QtGui import QTextCursor
        
        main_window = self._get_main_window()
        # Check if invisible spaces are being shown
        if main_window and hasattr(main_window, 'invisible_display_settings'):
            if main_window.invisible_display_settings.get('spaces', False):
                # Get cursor position at click
                cursor = self.cursorForPosition(event.pos())
                pos = cursor.position()
                text = self.toPlainText()
                
                # Find word boundaries using middle dot (¬∑) or zero-width space as delimiters
                # Find start of word (search backwards for ¬∑ or start of text)
                start = pos
                while start > 0 and text[start - 1] not in ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂'):
                    start -= 1
                
                # Find end of word (search forwards for ¬∑ or end of text)
                end = pos
                while end < len(text) and text[end] not in ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂'):
                    end += 1
                
                # Select the word
                cursor.setPosition(start)
                cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)
                self.setTextCursor(cursor)
                return
        
        # Default behavior
        super().mouseDoubleClickEvent(event)
    
    def _get_main_window(self):
        """Get the main application window by traversing the parent hierarchy"""
        from PyQt6.QtWidgets import QTableWidget
        
        # Try multiple ways to get table reference (different creation paths set different attributes)
        # Check table_widget FIRST - delegate explicitly sets this to the correct table
        # table_ref may be set to viewport (wrong) when delegate creates the editor
        table = None
        if hasattr(self, 'table_widget') and self.table_widget and isinstance(self.table_widget, QTableWidget):
            table = self.table_widget
        elif hasattr(self, 'table_ref') and self.table_ref and isinstance(self.table_ref, QTableWidget):
            table = self.table_ref
        else:
            # Walk up parent hierarchy to find QTableWidget
            widget = self.parent()
            while widget and not isinstance(widget, QTableWidget):
                widget = widget.parent() if hasattr(widget, 'parent') else None
            table = widget
        
        if not table:
            return None
        main_window = table.parent()
        while main_window and not hasattr(main_window, 'go_to_first_segment'):
            main_window = main_window.parent()
        return main_window
    
    def update_display_mode(self, text: str, show_tags: bool):
        """
        Update the display based on tag view mode.
        
        Args:
            text: The raw text (with HTML tags like <b>bold</b>)
            show_tags: If True, show raw tags. If False, show formatted WYSIWYG.
        """
        self._raw_text = text
        
        if show_tags:
            # Show raw tags as plain text
            self.setPlainText(text)
        else:
            # Show WYSIWYG - convert tags to actual formatting
            html = get_formatted_html_display(text)
            self.setHtml(html)
    
    def get_raw_text(self) -> str:
        """Get the raw text with tags, regardless of display mode."""
        return getattr(self, '_raw_text', self.toPlainText())

    def highlight_termbase_matches(self, matches_dict: Dict):
        """
        Highlight termbase matches in the text using the configured style.
        Does NOT change the widget - just adds formatting to existing text.
        
        Supported styles (configured in Settings > View Settings):
        - 'background': Pastel green background colors based on priority (default)
        - 'dotted': Subtle dotted underline (IDE/code editor style)
        - 'semibold': Slightly bolder text with tinted color (typographic)
        
        Args:
            matches_dict: Dictionary of {term: {'translation': str, 'priority': int}} or {term: str}
        """
        from PyQt6.QtGui import QTextCursor, QTextCharFormat, QColor, QFont

        # Get the document and create a cursor
        doc = self.document()
        text = self.toPlainText()
        text_lower = text.lower()
        
        # IMPORTANT: Always clear all previous formatting first to prevent inconsistent highlighting
        cursor = QTextCursor(doc)
        cursor.select(QTextCursor.SelectionType.Document)
        default_fmt = QTextCharFormat()
        cursor.setCharFormat(default_fmt)
        
        # If no matches, we're done (highlighting has been cleared)
        if not matches_dict:
            return
        
        # Get highlight style from main window settings
        highlight_style = 'background'  # default
        dotted_color = '#808080'  # default medium gray (more visible)
        parent = self.parent()
        while parent:
            if hasattr(parent, 'termbase_highlight_style'):
                highlight_style = getattr(parent, 'termbase_highlight_style', 'background')
                dotted_color = getattr(parent, 'termbase_dotted_color', '#808080')
                break
            elif hasattr(parent, 'load_general_settings'):
                settings = parent.load_general_settings()
                highlight_style = settings.get('termbase_highlight_style', 'semibold')
                dotted_color = settings.get('termbase_dotted_color', '#808080')
                break
            parent = parent.parent() if hasattr(parent, 'parent') else None

        # Sort matches by source term length (longest first) to avoid partial matches
        # Since dict keys are now term_ids, we need to extract source terms first
        term_entries = []
        for term_id, match_info in matches_dict.items():
            if isinstance(match_info, dict):
                source_term = match_info.get('source', '')
                if source_term:
                    term_entries.append((source_term, term_id, match_info))

        # Sort by source term length (longest first)
        term_entries.sort(key=lambda x: len(x[0]), reverse=True)
        
        # Track positions we've already highlighted to avoid overlaps
        highlighted_ranges = []
        found_count = 0
        
        for term, term_id, match_info in term_entries:
            # Get ranking, forbidden status, and termbase type
            ranking = match_info.get('ranking', None)
            forbidden = match_info.get('forbidden', False)
            is_project_termbase = match_info.get('is_project_termbase', False)
            translation = match_info.get('target', match_info.get('translation', ''))
            notes = match_info.get('notes', '')
            termbase_name = match_info.get('termbase_name', '')
            
            # IMPORTANT: Treat ranking #1 as project termbase (even if flag not set)
            is_effective_project = is_project_termbase or (ranking == 1)
            
            # Build tooltip text
            tooltip_text = ""
            if translation:
                tooltip_text = f"Glossary: {translation}"
                if termbase_name:
                    tooltip_text += f"\nFrom: {termbase_name}"
                if notes:
                    tooltip_text += f"\nNote: {notes}"
            
            # Find all occurrences of this term (case-insensitive)
            term_lower = term.lower()
            start = 0
            while True:
                idx = text_lower.find(term_lower, start)
                if idx == -1:
                    break
                
                end_idx = idx + len(term)
                
                # Check if this range overlaps with already highlighted text
                overlaps = any(
                    (idx < h_end and end_idx > h_start)
                    for h_start, h_end in highlighted_ranges
                )
                
                if not overlaps:
                    # Create cursor for this position
                    cursor = QTextCursor(doc)
                    cursor.setPosition(idx)
                    cursor.setPosition(end_idx, QTextCursor.MoveMode.KeepAnchor)
                    
                    # Create format based on style
                    fmt = QTextCharFormat()
                    
                    if highlight_style == 'dotted':
                        # DOTTED UNDERLINE STYLE (IDE/code editor approach)
                        # Simple dotted line like the Gemini example - clean and unobtrusive
                        fmt.setUnderlineStyle(QTextCharFormat.UnderlineStyle.DotLine)
                        if forbidden:
                            fmt.setUnderlineColor(QColor(0, 0, 0))  # Black for forbidden
                        else:
                            # Higher priority = red (more attention), lower = gray (subtle)
                            if ranking == 1:
                                fmt.setUnderlineColor(QColor('#CC0000'))  # Red for priority 1 (project termbase)
                            elif ranking == 2:
                                fmt.setUnderlineColor(QColor('#505050'))  # Dark gray for priority 2
                            elif ranking == 3:
                                fmt.setUnderlineColor(QColor('#707070'))  # Medium gray
                            else:
                                fmt.setUnderlineColor(QColor(dotted_color))  # User-configured color
                        # Add tooltip with translation and notes
                        if tooltip_text:
                            fmt.setToolTip(tooltip_text)
                    
                    elif highlight_style == 'semibold':
                        # SEMIBOLD TEXT STYLE (typographic approach)
                        fmt.setFontWeight(QFont.Weight.DemiBold)
                        if forbidden:
                            fmt.setForeground(QColor(180, 0, 0))  # Dark red for forbidden
                        else:
                            # Tinted dark color based on ranking
                            if ranking == 1:
                                fmt.setForeground(QColor('#1B5E20'))  # Dark green for priority 1
                            elif ranking == 2:
                                fmt.setForeground(QColor('#2E7D32'))  # Medium dark green
                            elif ranking == 3:
                                fmt.setForeground(QColor('#388E3C'))  # Medium green
                            else:
                                fmt.setForeground(QColor('#43A047'))  # Lighter green
                        # Add tooltip with translation and notes
                        if tooltip_text:
                            fmt.setToolTip(tooltip_text)
                    
                    else:
                        # BACKGROUND COLOR STYLE (default - current behavior)
                        if forbidden:
                            color = QColor(0, 0, 0)  # Black for forbidden terms
                            fmt.setForeground(QColor("white"))
                        else:
                            # Use ranking to determine soft green shade
                            if ranking is not None:
                                if ranking == 1:
                                    color = QColor(165, 214, 167)  # Soft medium green (Green 200)
                                elif ranking == 2:
                                    color = QColor(200, 230, 201)  # Soft light green (Green 100)
                                elif ranking == 3:
                                    color = QColor(220, 237, 200)  # Very soft light green
                                else:
                                    color = QColor(232, 245, 233)  # Extremely soft pastel green
                            else:
                                color = QColor(200, 230, 201)  # Green 100 (fallback)
                            fmt.setForeground(QColor("black"))
                        fmt.setBackground(color)
                        # Add tooltip with translation and notes
                        if tooltip_text:
                            fmt.setToolTip(tooltip_text)
                    
                    # Apply format
                    cursor.setCharFormat(fmt)
                    found_count += 1
                    
                    # Track this range as highlighted
                    highlighted_ranges.append((idx, end_idx))
                
                start = end_idx
    
    def highlight_non_translatables(self, nt_matches: list, highlighted_ranges: list = None):
        """
        Highlight non-translatable matches in the text using pastel yellow background.
        
        Args:
            nt_matches: List of dicts with 'text', 'start', 'end' keys from NT manager
            highlighted_ranges: Optional list of already-highlighted ranges to avoid overlap
        """
        from PyQt6.QtGui import QTextCursor, QTextCharFormat, QColor
        
        if not nt_matches:
            return
        
        doc = self.document()
        
        # Track ranges we've highlighted (to avoid overlap with termbase matches)
        if highlighted_ranges is None:
            highlighted_ranges = []
        
        # Pastel yellow for non-translatables
        nt_color = QColor(255, 253, 208)  # Pastel yellow (#FFFDD0)
        
        for match in nt_matches:
            start_pos = match.get('start', 0)
            end_pos = match.get('end', 0)
            
            if start_pos >= end_pos:
                continue
            
            # Check for overlap with existing highlights
            overlaps = any(
                (start_pos < h_end and end_pos > h_start)
                for h_start, h_end in highlighted_ranges
            )
            
            if overlaps:
                continue
            
            # Create cursor for this position
            cursor = QTextCursor(doc)
            cursor.setPosition(start_pos)
            cursor.setPosition(end_pos, QTextCursor.MoveMode.KeepAnchor)
            
            # Create format with pastel yellow background
            fmt = QTextCharFormat()
            fmt.setBackground(nt_color)
            fmt.setForeground(QColor("#5D4E37"))  # Dark brown text for contrast
            
            cursor.setCharFormat(fmt)
            highlighted_ranges.append((start_pos, end_pos))
    
    def event(self, event):
        """Override event() to catch Tab and Ctrl+T keys before Qt's default handling"""
        # Catch Tab key at event level (before keyPressEvent)
        if event.type() == event.Type.KeyPress:
            key_event = event
            
            # Ctrl+E: Add selected terms to termbase (with dialog)
            if key_event.key() == Qt.Key.Key_E and key_event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                self._handle_add_to_termbase()
                return True  # Event handled
            
            # Alt+Left: Quick add selected terms to last-used termbase (no dialog)
            if key_event.key() == Qt.Key.Key_Left and key_event.modifiers() == Qt.KeyboardModifier.AltModifier:
                self._handle_quick_add_to_termbase()
                return True  # Event handled
            
            # Ctrl+Alt+N: Add selected text to non-translatables
            if key_event.key() == Qt.Key.Key_N and key_event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier):
                self._handle_add_to_nt()
                return True  # Event handled
            
            # Ctrl+Home: Navigate to first segment (pass to main window)
            if key_event.key() == Qt.Key.Key_Home and key_event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                main_window = self._get_main_window()
                if main_window and hasattr(main_window, 'go_to_first_segment'):
                    main_window.go_to_first_segment()
                return True  # Event handled
            
            # Ctrl+End: Navigate to last segment (pass to main window)
            if key_event.key() == Qt.Key.Key_End and key_event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                main_window = self._get_main_window()
                if main_window and hasattr(main_window, 'go_to_last_segment'):
                    main_window.go_to_last_segment()
                return True  # Event handled
            
            if key_event.key() == Qt.Key.Key_Tab:
                # Ctrl+Tab: Insert actual tab character (if editing is allowed)
                if key_event.modifiers() == Qt.KeyboardModifier.ControlModifier:
                    if self.allow_source_edit:
                        self.insertPlainText('\t')
                        return True  # Event handled
                
                # Tab alone: Cycle to target cell (column 3) in same row
                if key_event.modifiers() == Qt.KeyboardModifier.NoModifier:
                    if self.table_ref and self.row >= 0:
                        # Get target cell widget (column 3)
                        target_widget = self.table_ref.cellWidget(self.row, 3)
                        if target_widget:
                            target_widget.setFocus()
                            self.table_ref.setCurrentCell(self.row, 3)
                            return True  # Event handled, don't propagate
        
        # Let base class handle all other events
        return super().event(event)
    
    def keyPressEvent(self, event):
        """Override to handle other keys (Tab is handled in event())"""
        # All keys: Handle normally (Tab already handled in event())
        super().keyPressEvent(event)
    
    def sizeHint(self):
        """Return compact size based on content"""
        doc = self.document()
        ideal_width = self.width() if self.width() > 0 else 200
        doc.setTextWidth(ideal_width)
        height = int(doc.size().height())
        # Add minimal padding (2px total)
        height = max(height + 2, 1)
        current_width = self.width() if self.width() > 0 else 200
        return QSize(current_width, height)
    
    def _handle_add_to_termbase(self):
        """Handle Ctrl+T: Add selected source and target terms to termbase"""
        if not self.table_ref or self.row < 0:
            return
        
        # Get source selection (from this widget)
        source_text = self.textCursor().selectedText().strip()
        
        # Get target cell widget and its selection
        target_widget = self.table_ref.cellWidget(self.row, 3)
        target_text = ""
        if target_widget and hasattr(target_widget, 'textCursor'):
            target_text = target_widget.textCursor().selectedText().strip()
        
        # Validate we have both selections
        if not source_text or not target_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text in both Source and Target cells before adding to glossary.\\n\\n"
                "Workflow:\\n"
                "1. Select term in source cell\\n"
                "2. Press Tab to cycle to target cell\\n"
                "3. Select corresponding translation\\n"
                "4. Press Ctrl+E (or right-click) to add to glossary"
            )
            return
        
        # Find main window and call add_to_termbase method
        main_window = self.table_ref.parent()
        while main_window and not hasattr(main_window, 'add_term_pair_to_termbase'):
            main_window = main_window.parent()
        
        if main_window and hasattr(main_window, 'add_term_pair_to_termbase'):
            main_window.add_term_pair_to_termbase(source_text, target_text)
    
    def _handle_quick_add_to_termbase(self):
        """Handle Ctrl+R: Quick add selected source and target terms to termbase (no dialog)"""
        if not self.table_ref or self.row < 0:
            return
        
        # Get source selection (from this widget)
        source_text = self.textCursor().selectedText().strip()
        
        # Get target cell widget and its selection
        target_widget = self.table_ref.cellWidget(self.row, 3)
        target_text = ""
        if target_widget and hasattr(target_widget, 'textCursor'):
            target_text = target_widget.textCursor().selectedText().strip()
        
        # Validate we have both selections
        if not source_text or not target_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text in both Source and Target cells before quick-adding to termbase.\n\n"
                "Tip: Use Ctrl+E to add with a dialog where you can choose termbase and add metadata."
            )
            return
        
        # Find main window and call quick_add_to_termbase method
        main_window = self.table_ref.parent()
        while main_window and not hasattr(main_window, 'quick_add_term_pair_to_termbase'):
            main_window = main_window.parent()
        
        if main_window and hasattr(main_window, 'quick_add_term_pair_to_termbase'):
            main_window.quick_add_term_pair_to_termbase(source_text, target_text)
    
    def _handle_superlookup_search(self):
        """Handle right-click: Search selected text in Superlookup"""
        # Get selected text
        selected_text = self.textCursor().selectedText().strip()
        
        if not selected_text:
            return
        
        # Find main window
        main_window = self._get_main_window()
        if not main_window:
            return
        
        # Get project languages
        source_lang = None
        target_lang = None
        if hasattr(main_window, 'current_project') and main_window.current_project:
            source_lang = main_window.current_project.source_lang
            target_lang = main_window.current_project.target_lang
        
        # Navigate to Superlookup
        main_window._go_to_superlookup()
        
        # Trigger search
        if hasattr(main_window, 'lookup_tab') and main_window.lookup_tab:
            main_window.lookup_tab.search_with_query(
                selected_text,
                switch_to_vertical=True,
                source_lang=source_lang,
                target_lang=target_lang
            )
    
    def mouseMoveEvent(self, event):
        """Show tooltip when hovering over highlighted termbase matches"""
        super().mouseMoveEvent(event)
        
        # Get cursor position
        cursor = self.cursorForPosition(event.pos())
        cursor_pos = cursor.position()
        
        # Check if cursor is over a termbase match
        for term_id, match_info in self.termbase_matches.items():
            # Extract source term from match_info
            term = match_info.get('source', '') if isinstance(match_info, dict) else str(term_id)
            # Find term position in text
            text = self.toPlainText()
            text_lower = text.lower()
            term_lower = term.lower()
            
            start = 0
            while True:
                idx = text_lower.find(term_lower, start)
                if idx == -1:
                    break
                
                end_idx = idx + len(term)
                
                # Check if cursor is within this term's range
                if idx <= cursor_pos <= end_idx:
                    # Get translation and other info
                    if isinstance(match_info, dict):
                        translation = match_info.get('translation', '')
                        priority = match_info.get('priority', 50)
                        forbidden = match_info.get('forbidden', False)
                        
                        # Build tooltip (show only target translation)
                        tooltip = f"<b>{translation}</b>"
                        if forbidden:
                            tooltip += "<br><span style='color: red;'>‚ö†Ô∏è FORBIDDEN TERM</span>"
                        tooltip += f"<br><span style='color: #666;'>Priority: {priority}</span>"
                        tooltip += "<br><span style='color: #666;'><i>Double-click to insert</i></span>"
                    else:
                        tooltip = f"<b>{match_info}</b><br><span style='color: #666;'><i>Double-click to insert</i></span>"
                    
                    self.setToolTip(tooltip)
                    return
                
                start = end_idx
        
        # No match found at cursor position
        self.setToolTip("")
    
    def mouseDoubleClickEvent(self, event):
        """Insert termbase translation on double-click"""
        # Get cursor position
        cursor = self.cursorForPosition(event.pos())
        cursor_pos = cursor.position()
        
        # Check if double-clicked on a termbase match
        for term_id, match_info in self.termbase_matches.items():
            # Extract source term from match_info
            term = match_info.get('source', '') if isinstance(match_info, dict) else str(term_id)
            text = self.toPlainText()
            text_lower = text.lower()
            term_lower = term.lower()
            
            start = 0
            while True:
                idx = text_lower.find(term_lower, start)
                if idx == -1:
                    break
                
                end_idx = idx + len(term)
                
                # Check if cursor is within this term's range
                if idx <= cursor_pos <= end_idx:
                    # Get translation
                    if isinstance(match_info, dict):
                        translation = match_info.get('translation', '')
                    else:
                        translation = match_info
                    
                    # Insert translation into target cell at cursor position
                    if self.table_ref and self.row >= 0:
                        target_widget = self.table_ref.cellWidget(self.row, 3)
                        if target_widget and hasattr(target_widget, 'textCursor'):
                            # Insert at current cursor position in target
                            target_cursor = target_widget.textCursor()
                            target_cursor.insertText(translation)
                            target_widget.setFocus()
                    return
                
                start = end_idx
        
        # If not on a termbase match, allow normal double-click selection
        super().mouseDoubleClickEvent(event)
    
    def mousePressEvent(self, event):
        """Allow text selection on click and trigger row selection"""
        super().mousePressEvent(event)

        # Use stored table reference and row number
        if self.table_ref and self.row >= 0:
            try:
                # Check for Shift or Ctrl modifier - let Qt handle native multi-selection
                modifiers = event.modifiers()
                is_shift = modifiers & Qt.KeyboardModifier.ShiftModifier
                is_ctrl = modifiers & Qt.KeyboardModifier.ControlModifier

                if is_shift or is_ctrl:
                    # For Shift+click (range) or Ctrl+click (toggle), just set current cell
                    # but don't call selectRow() which would clear the selection
                    self.table_ref.setCurrentCell(self.row, 2)
                else:
                    # Normal click - select just this row
                    self.table_ref.selectRow(self.row)
                    self.table_ref.setCurrentCell(self.row, 2)

                    # CRITICAL: Manually trigger on_cell_selected since signals aren't firing
                    # Find the main window and call the method directly
                    main_window = self.table_ref.parent()
                    while main_window and not hasattr(main_window, 'on_cell_selected'):
                        main_window = main_window.parent()
                    if main_window and hasattr(main_window, 'on_cell_selected'):
                        main_window.on_cell_selected(self.row, 2, -1, -1)
            except Exception as e:
                print(f"Error triggering manual cell selection: {e}")

    def mouseReleaseEvent(self, event):
        """Smart word selection - expand partial selections to full words
        
        Works across multiple lines - if you select text spanning several lines,
        partial words at the START and END of your selection will be expanded.
        """
        super().mouseReleaseEvent(event)

        # Check if smart selection is enabled
        main_window = self._get_main_window()
        if main_window and hasattr(main_window, 'enable_smart_word_selection'):
            if not main_window.enable_smart_word_selection:
                return  # Feature disabled

        # Get the current cursor
        cursor = self.textCursor()

        # Only expand if there's a selection
        if cursor.hasSelection():
            # Get selection boundaries
            start = cursor.selectionStart()
            end = cursor.selectionEnd()

            # Get the full text
            text = self.toPlainText()

            # Helper function to check if character is part of a word
            # Includes alphanumeric, underscore, hyphen, and apostrophe
            def is_word_char(char):
                return char.isalnum() or char in "_-'"

            # Track if we need to update the selection
            selection_changed = False

            # Expand START boundary if we're in the middle of a word
            # (i.e., the character before the selection is a word character)
            if start > 0 and is_word_char(text[start - 1]):
                # Also check that the first selected character is a word char
                # (to avoid expanding when selecting from whitespace)
                if start < len(text) and is_word_char(text[start]):
                    while start > 0 and is_word_char(text[start - 1]):
                        start -= 1
                    selection_changed = True

            # Expand END boundary if we're in the middle of a word
            # (i.e., the character after the selection is a word character)
            if end < len(text) and is_word_char(text[end]):
                # Also check that the last selected character is a word char
                # (to avoid expanding when selecting to whitespace)
                if end > 0 and is_word_char(text[end - 1]):
                    while end < len(text) and is_word_char(text[end]):
                        end += 1
                    selection_changed = True

            # Set the new selection if boundaries changed
            if selection_changed:
                cursor.setPosition(start)
                cursor.setPosition(end, cursor.MoveMode.KeepAnchor)
                self.setTextCursor(cursor)

    def _get_main_window(self):
        """Get the main application window by traversing the parent hierarchy"""
        if not self.parent():
            return None
        main_window = self.parent()
        while main_window and not hasattr(main_window, 'go_to_first_segment'):
            main_window = main_window.parent()
        return main_window
    
    def focusInEvent(self, event):
        """Select text when focused for easy copying and trigger row selection"""
        super().focusInEvent(event)
        # Don't auto-select - let user select manually

        # Use stored table reference and row number
        if self.table_ref and self.row >= 0:
            try:
                # Check for Shift or Ctrl modifier - let Qt handle native multi-selection
                from PyQt6.QtWidgets import QApplication
                modifiers = QApplication.keyboardModifiers()
                is_shift = modifiers & Qt.KeyboardModifier.ShiftModifier
                is_ctrl = modifiers & Qt.KeyboardModifier.ControlModifier

                if is_shift or is_ctrl:
                    # For Shift+click (range) or Ctrl+click (toggle), just set current cell
                    # but don't call selectRow() which would clear the selection
                    self.table_ref.setCurrentCell(self.row, 2)
                else:
                    # Normal focus - select just this row
                    self.table_ref.selectRow(self.row)
                    self.table_ref.setCurrentCell(self.row, 2)

                    # CRITICAL: Manually trigger on_cell_selected since signals aren't firing
                    # Find the main window and call the method directly
                    main_window = self.table_ref.parent()
                    while main_window and not hasattr(main_window, 'on_cell_selected'):
                        main_window = main_window.parent()
                    if main_window and hasattr(main_window, 'on_cell_selected'):
                        main_window.on_cell_selected(self.row, 2, -1, -1)
            except Exception as e:
                print(f"Error triggering manual cell selection: {e}")

    def contextMenuEvent(self, event):
        """Show context menu with Add to Glossary and Add to Non-Translatables options"""
        from PyQt6.QtWidgets import QMenu
        from PyQt6.QtGui import QAction
        
        menu = QMenu(self)
        
        # Add standard actions
        if self.textCursor().hasSelection():
            copy_action = QAction("Copy", self)
            copy_action.triggered.connect(self.copy)
            menu.addAction(copy_action)
            menu.addSeparator()
        
        # Superlookup search action
        if self.textCursor().hasSelection():
            superlookup_action = QAction("üîç Search in Superlookup (Ctrl+K)", self)
            superlookup_action.triggered.connect(self._handle_superlookup_search)
            menu.addAction(superlookup_action)
            menu.addSeparator()

        # QuickMenu (prompt-based actions)
        try:
            main_window = self._get_main_window()
            quickmenu_items = []
            if main_window and hasattr(main_window, 'prompt_manager_qt') and main_window.prompt_manager_qt:
                lib = getattr(main_window.prompt_manager_qt, 'library', None)
                if lib and hasattr(lib, 'get_quickmenu_grid_prompts'):
                    quickmenu_items = lib.get_quickmenu_grid_prompts() or []

            if quickmenu_items:
                qm_menu = menu.addMenu("‚ö° QuickMenu")
                for rel_path, label in sorted(quickmenu_items, key=lambda x: (x[1] or x[0]).lower()):
                    prompt_menu = qm_menu.addMenu(label or rel_path)

                    run_show = QAction("‚ñ∂ Run (show response)‚Ä¶", self)
                    run_show.triggered.connect(
                        lambda checked=False, p=rel_path: main_window.run_grid_quickmenu_prompt(p, origin_widget=self, behavior="show")
                    )
                    prompt_menu.addAction(run_show)

                    run_replace = QAction("‚Ü∫ Run and replace target selection", self)
                    run_replace.triggered.connect(
                        lambda checked=False, p=rel_path: main_window.run_grid_quickmenu_prompt(p, origin_widget=self, behavior="replace")
                    )
                    prompt_menu.addAction(run_replace)

                menu.addSeparator()
        except Exception:
            # Never break the normal context menu due to QuickMenu errors
            pass
        
        # Add to glossary action (with dialog)
        add_to_tb_action = QAction("üìñ Add to Glossary (Ctrl+E)", self)
        add_to_tb_action.triggered.connect(self._handle_add_to_termbase)
        menu.addAction(add_to_tb_action)
        
        # Quick add to glossary action (no dialog) - uses last-selected glossary from Ctrl+E
        quick_add_action = QAction("‚ö° Quick Add to Glossary (Alt+Left)", self)
        quick_add_action.triggered.connect(self._handle_quick_add_to_termbase)
        menu.addAction(quick_add_action)
        
        # Add to non-translatables action
        add_to_nt_action = QAction("üö´ Add to Non-Translatables (Ctrl+Alt+N)", self)
        add_to_nt_action.triggered.connect(self._handle_add_to_nt)
        menu.addAction(add_to_nt_action)
        
        menu.exec(event.globalPos())
    
    def _handle_add_to_nt(self):
        """Handle Ctrl+Alt+N: Add selected text to active non-translatable list(s)"""
        # Get selected text
        selected_text = self.textCursor().selectedText().strip()
        
        if not selected_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text in the Source cell before adding to non-translatables."
            )
            return
        
        # Find main window and call add_to_nt method
        table = self.table_ref if hasattr(self, 'table_ref') else self.parent()
        if table:
            main_window = table.parent()
            while main_window and not hasattr(main_window, 'add_text_to_non_translatables'):
                main_window = main_window.parent()
            
            if main_window and hasattr(main_window, 'add_text_to_non_translatables'):
                main_window.add_text_to_non_translatables(selected_text)
            else:
                from PyQt6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Feature Not Available",
                    "Non-translatables functionality not available."
                )

    def set_background_color(self, color: str):
        """Set the background color for this text editor (for alternating row colors)"""
        self.setStyleSheet(f"""
            QTextEdit {{
                border: none;
                background-color: {color};
                padding: 0px;
            }}
        """)


class TagHighlighter(QSyntaxHighlighter):
    """Syntax highlighter for HTML/XML tags, CAT tool tags, CafeTran pipe symbols, Markdown syntax, and spell checking in text editors"""

    # Class-level reference to spellcheck manager (shared across all instances)
    _spellcheck_manager = None
    _spellcheck_enabled = False
    _is_cafetran_project = False  # Only highlight pipe symbols for CafeTran projects
    _is_markdown_project = False  # Highlight Markdown syntax for Markdown imports

    def __init__(self, document, tag_color='#7f0001', invisible_char_color='#999999', enable_spellcheck=False):
        super().__init__(document)
        self.tag_color = tag_color
        self.invisible_char_color = invisible_char_color
        self._local_spellcheck_enabled = enable_spellcheck
        self.update_tag_format()

    @classmethod
    def set_spellcheck_manager(cls, manager):
        """Set the shared spellcheck manager instance"""
        cls._spellcheck_manager = manager

    @classmethod
    def set_spellcheck_enabled(cls, enabled: bool):
        """Enable or disable spellchecking globally"""
        cls._spellcheck_enabled = enabled

    def update_tag_format(self):
        """Update the tag format with current color"""
        from PyQt6.QtGui import QTextCharFormat, QColor
        self.tag_format = QTextCharFormat()
        self.tag_format.setForeground(QColor(self.tag_color))

        # CafeTran pipe symbols - red and bold like in CafeTran
        self.pipe_format = QTextCharFormat()
        self.pipe_format.setForeground(QColor('#FF0000'))  # Red
        self.pipe_format.setFontWeight(700)  # Bold

        # Invisible character symbols - use configured color
        self.invisible_format = QTextCharFormat()
        self.invisible_format.setForeground(QColor(self.invisible_char_color))

        # Spellcheck format - red wavy underline
        self.spellcheck_format = QTextCharFormat()
        self.spellcheck_format.setUnderlineColor(QColor('#FF0000'))
        self.spellcheck_format.setUnderlineStyle(QTextCharFormat.UnderlineStyle.WaveUnderline)

        # Markdown syntax formats
        # Bold/Italic markers: ** __ * _
        self.md_bold_format = QTextCharFormat()
        self.md_bold_format.setForeground(QColor('#C71585'))  # Medium violet red
        self.md_bold_format.setFontWeight(700)  # Bold to make it stand out
        
        # Heading markers: # ## ### etc.
        self.md_heading_format = QTextCharFormat()
        self.md_heading_format.setForeground(QColor('#0066CC'))  # Blue
        self.md_heading_format.setFontWeight(700)
        
        # Code markers: ` ``` 
        self.md_code_format = QTextCharFormat()
        self.md_code_format.setForeground(QColor('#D2691E'))  # Chocolate/Orange
        self.md_code_format.setFontWeight(700)
        
        # Link/Image syntax: []() ![]()
        self.md_link_format = QTextCharFormat()
        self.md_link_format.setForeground(QColor('#6A5ACD'))  # Slate blue/Purple
        
        # Blockquote markers: >
        self.md_quote_format = QTextCharFormat()
        self.md_quote_format.setForeground(QColor('#228B22'))  # Forest green
        self.md_quote_format.setFontWeight(700)
        
        # List markers: - * + 1. 2.
        self.md_list_format = QTextCharFormat()
        self.md_list_format.setForeground(QColor('#FF6600'))  # Orange
        self.md_list_format.setFontWeight(700)

    def set_tag_color(self, color: str):
        """Update tag highlight color"""
        self.tag_color = color
        self.update_tag_format()
        self.rehighlight()

    def set_invisible_char_color(self, color: str):
        """Update invisible character color"""
        self.invisible_char_color = color
        self.update_tag_format()
        self.rehighlight()

    def set_local_spellcheck(self, enabled: bool):
        """Enable or disable spellcheck for this specific highlighter"""
        self._local_spellcheck_enabled = enabled
        self.rehighlight()
    
    def highlightBlock(self, text):
        """Highlight all tags, pipe symbols, invisible chars, and misspelled words in the text block"""
        import re
        # Combined pattern for ALL CAT tool tag types:
        # 1. HTML/XML: <tag>, </tag>, <tag/>, <tag attr="val">
        # 2. Trados numeric: <1>, </1>
        # 3. memoQ numeric bracket tags:
        #    - Opening: [1}, [2} etc.
        #    - Closing: {1], {2] etc.
        #    - Standalone: [1], [2] etc.
        # 4. memoQ content tags with text/attributes (from bilingual DOCX):
        #    - [uicontrol id="GUID-..."], [image cid="..." href="..."], etc.
        #    - {uicontrol}, {image}, etc. (closing tags)
        #    NOTE: Opening [tag] MUST have attributes (space+content) to avoid matching
        #          placeholders like [Company] or [Bedrijf]. Closing {tag} doesn't need attrs.
        tag_patterns = [
            r'</?[a-zA-Z][a-zA-Z0-9-]*/?(?:\s[^>]*)?>',  # HTML/XML tags
            r'</?\d+>',                                   # Trados numeric: <1>, </1>
            r'\[\d+[}\]]',                                # memoQ numeric: [1}, [1]
            r'\{\d+[}\]]',                                # memoQ numeric: {1}, {1]
            r'\[[^}\]]+\}',                               # memoQ mixed: [anything} (exclude } and ])
            r'\{[^\[\]]+\]',                              # memoQ mixed: {anything] (exclude [ and ])
            r'\[[a-zA-Z][^}\]]*\s[^}\]]*\]',              # memoQ content: [tag attr...] (exclude } and ])
            r'\{[a-zA-Z][a-zA-Z0-9_-]*\}',                # memoQ closing: {uicontrol}, {MQ}
            r'\{\d{5}\}',                                 # D√©j√† Vu tags: {00108}, {00109}, etc.
        ]
        combined_pattern = re.compile('|'.join(tag_patterns))

        matches_found = list(combined_pattern.finditer(text))

        for match in matches_found:
            start = match.start()
            length = match.end() - start
            self.setFormat(start, length, self.tag_format)

        # Match invisible character symbols (light blue)
        for i, char in enumerate(text):
            if char in '¬∑‚Üí¬∞¬∂':  # Invisible character replacement symbols
                self.setFormat(i, 1, self.invisible_format)
        
        # CafeTran pipe symbols (red and bold) - ONLY for CafeTran projects
        if TagHighlighter._is_cafetran_project:
            for i, char in enumerate(text):
                if char == '|':
                    self.setFormat(i, 1, self.pipe_format)

        # Markdown syntax highlighting - ONLY for Markdown projects
        if TagHighlighter._is_markdown_project:
            self._highlight_markdown_syntax(text)

        # Spell checking - only for target editors when enabled
        if self._local_spellcheck_enabled and TagHighlighter._spellcheck_enabled and TagHighlighter._spellcheck_manager:
            self._highlight_misspelled_words(text)

    def _highlight_misspelled_words(self, text):
        """Highlight misspelled words with red wavy underline"""
        # Safety check - if spellcheck manager is not available or disabled, skip
        if not TagHighlighter._spellcheck_manager:
            return
        
        # Check if spellcheck manager detected a crash - if so, skip entirely
        if hasattr(TagHighlighter._spellcheck_manager, '_crash_detected') and TagHighlighter._spellcheck_manager._crash_detected:
            return
        
        import re
        # Find all words (letters only, including accented characters)
        # Skip words inside tags or that look like technical content
        word_pattern = re.compile(r'\b([a-zA-Z√Ä-√ø\']+)\b', re.UNICODE)
        
        try:
            for match in word_pattern.finditer(text):
                word = match.group(1)
                start = match.start(1)
                length = len(word)
                
                # Skip very short words and words with apostrophes at start/end
                if len(word) < 2:
                    continue
                
                # Check if this word is inside ANY type of tag:
                # - HTML/XML: < ... >
                # - memoQ/DITA: [ ... } or [ ... ] or { ... ]
                before_text = text[:start]
                
                # Check for HTML tags
                last_html_open = before_text.rfind('<')
                last_html_close = before_text.rfind('>')
                if last_html_open > last_html_close:
                    continue  # Inside HTML tag
                
                # Check for bracket tags: [ ... } or [ ... ]
                last_square_open = before_text.rfind('[')
                last_square_close = max(before_text.rfind('}'), before_text.rfind(']'))
                if last_square_open > last_square_close:
                    continue  # Inside [tag...} or [tag...]
                
                # Check for curly tags: { ... ] or { ... }
                last_curly_open = before_text.rfind('{')
                last_curly_close = max(before_text.rfind(']'), before_text.rfind('}'))
                if last_curly_open > last_curly_close:
                    continue  # Inside {tag...] or {tag...}
                
                # Check spelling
                if not TagHighlighter._spellcheck_manager.check_word(word):
                    self.setFormat(start, length, self.spellcheck_format)
        except Exception as e:
            # If anything goes wrong during spellcheck highlighting, disable it
            print(f"Spellcheck highlighting error: {e}")
            if TagHighlighter._spellcheck_manager:
                TagHighlighter._spellcheck_manager._crash_detected = True
                TagHighlighter._spellcheck_manager.enabled = False

    def _highlight_markdown_syntax(self, text):
        """Highlight Markdown syntax elements to make them visually distinct"""
        import re
        
        # 1. Heading markers at start of line: # ## ### #### ##### ######
        #    Only match at start of line (or after only whitespace)
        heading_pattern = re.compile(r'^(#{1,6})\s', re.MULTILINE)
        for match in heading_pattern.finditer(text):
            self.setFormat(match.start(1), len(match.group(1)), self.md_heading_format)
        
        # 2. Bold markers: **text** or __text__
        #    Highlight just the markers, not the content
        bold_pattern = re.compile(r'(\*\*|__)(?=\S)(.+?)(?<=\S)\1')
        for match in bold_pattern.finditer(text):
            # Opening marker
            self.setFormat(match.start(), 2, self.md_bold_format)
            # Closing marker
            self.setFormat(match.end() - 2, 2, self.md_bold_format)
        
        # 3. Italic markers: *text* or _text_ (but not ** or __)
        #    Must not be preceded/followed by same character
        italic_pattern = re.compile(r'(?<!\*)\*(?!\*)(?=\S)(.+?)(?<=\S)\*(?!\*)|(?<!_)_(?!_)(?=\S)(.+?)(?<=\S)_(?!_)')
        for match in italic_pattern.finditer(text):
            # Opening marker (1 char)
            self.setFormat(match.start(), 1, self.md_bold_format)
            # Closing marker (1 char)
            self.setFormat(match.end() - 1, 1, self.md_bold_format)
        
        # 4. Inline code: `code`
        code_inline_pattern = re.compile(r'(`+)([^`]+)\1')
        for match in code_inline_pattern.finditer(text):
            # Highlight entire code span including backticks
            self.setFormat(match.start(), len(match.group(0)), self.md_code_format)
        
        # 5. Code fence markers: ``` or ~~~
        code_fence_pattern = re.compile(r'^(`{3,}|~{3,}).*$', re.MULTILINE)
        for match in code_fence_pattern.finditer(text):
            self.setFormat(match.start(), len(match.group(0)), self.md_code_format)
        
        # 6. Links: [text](url) - highlight brackets and parens, not the text
        link_pattern = re.compile(r'\[([^\]]+)\]\(([^\)]+)\)')
        for match in link_pattern.finditer(text):
            full_start = match.start()
            text_part = match.group(1)
            url_part = match.group(2)
            # [ bracket
            self.setFormat(full_start, 1, self.md_link_format)
            # ] bracket
            self.setFormat(full_start + 1 + len(text_part), 1, self.md_link_format)
            # ( and url and )
            url_start = full_start + 1 + len(text_part) + 1
            self.setFormat(url_start, len(url_part) + 2, self.md_link_format)
        
        # 7. Images: ![alt](url) - same as links but with !
        image_pattern = re.compile(r'!\[([^\]]*)\]\(([^\)]+)\)')
        for match in image_pattern.finditer(text):
            full_start = match.start()
            alt_part = match.group(1)
            url_part = match.group(2)
            # ! and [ 
            self.setFormat(full_start, 2, self.md_link_format)
            # ]
            self.setFormat(full_start + 2 + len(alt_part), 1, self.md_link_format)
            # ( and url and )
            url_start = full_start + 2 + len(alt_part) + 1
            self.setFormat(url_start, len(url_part) + 2, self.md_link_format)
        
        # 8. Blockquote markers: > at start of line
        quote_pattern = re.compile(r'^(>+)\s?', re.MULTILINE)
        for match in quote_pattern.finditer(text):
            self.setFormat(match.start(1), len(match.group(1)), self.md_quote_format)
        
        # 9. Unordered list markers: - * + at start of line (with space after)
        ul_pattern = re.compile(r'^(\s*)([-*+])\s', re.MULTILINE)
        for match in ul_pattern.finditer(text):
            marker_start = match.start(2)
            self.setFormat(marker_start, 1, self.md_list_format)
        
        # 10. Ordered list markers: 1. 2. 3. etc. at start of line
        ol_pattern = re.compile(r'^(\s*)(\d+\.)\s', re.MULTILINE)
        for match in ol_pattern.finditer(text):
            marker_start = match.start(2)
            marker_len = len(match.group(2))
            self.setFormat(marker_start, marker_len, self.md_list_format)
        
        # 11. Horizontal rules: --- or *** or ___ (3+ chars)
        hr_pattern = re.compile(r'^([-*_]{3,})\s*$', re.MULTILINE)
        for match in hr_pattern.finditer(text):
            self.setFormat(match.start(1), len(match.group(1)), self.md_heading_format)


class EditableGridTextEditor(QTextEdit):
    """Editable QTextEdit for target cells - allows text selection and editing"""
    
    # Class variable for tag highlight color (shared across all instances)
    tag_highlight_color = '#7f0001'  # Default memoQ dark red
    
    # Class variables for focus border customization
    focus_border_color = '#f1b79a'  # Default peach/salmon
    focus_border_thickness = 2  # Default 2px (slightly thicker than before)
    
    def __init__(self, text: str = "", parent=None, row: int = -1, table=None):
        super().__init__(parent)
        self.row = row  # Store row number for auto-selection
        self.table = table  # Store table reference
        self.setReadOnly(False)

        # CRITICAL: Track initial load state to ignore spurious textChanged events
        # Qt queues document change events during setPlainText() even with blockSignals(True).
        # When signals are unblocked later, Qt delivers these queued events, causing false
        # textChanged signals. This flag allows us to ignore the first event after unblocking.
        self._initial_load_complete = False

        # CRITICAL: Block ALL signals during initialization to prevent textChanged from firing
        # when setText is called. Signals will be unblocked AFTER signal handler is connected
        # in load_segments_to_grid. This prevents ANY textChanged events during grid loading.
        self.blockSignals(True)
        self.setPlainText(text)
        # DO NOT unblock signals here - they will be unblocked after handler connection

        # CRITICAL: Enable strong focus to receive Tab key events
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

        # Make inactive selections stay visible with same color
        from PyQt6.QtGui import QPalette
        palette = self.palette()
        palette.setColor(QPalette.ColorGroup.Active, QPalette.ColorRole.Highlight, QColor("#D0E7FF"))
        palette.setColor(QPalette.ColorGroup.Active, QPalette.ColorRole.HighlightedText, QColor("black"))
        palette.setColor(QPalette.ColorGroup.Inactive, QPalette.ColorRole.Highlight, QColor("#D0E7FF"))
        palette.setColor(QPalette.ColorGroup.Inactive, QPalette.ColorRole.HighlightedText, QColor("black"))
        self.setPalette(palette)

        # Add syntax highlighter for tags (with spellcheck enabled for target cells)
        # Get invisible char color and tag color from main window (theme-aware)
        main_window = self._get_main_window()
        invisible_char_color = main_window.invisible_char_color if main_window and hasattr(main_window, 'invisible_char_color') else '#999999'

        # Use theme-aware tag color (light pink in dark mode, dark red in light mode)
        is_dark = main_window and hasattr(main_window, 'theme_manager') and main_window.theme_manager and main_window.theme_manager.current_theme.name == "Dark"
        tag_color = '#FFB6C1' if is_dark else self.tag_highlight_color  # Light pink in dark mode

        self.highlighter = TagHighlighter(self.document(), tag_color, invisible_char_color, enable_spellcheck=True)

        # Style to look like a normal cell with subtle selection
        # Background and text colors now managed by theme system
        # Border color and thickness use class variables for user customization
        border_color = EditableGridTextEditor.focus_border_color
        border_thickness = EditableGridTextEditor.focus_border_thickness
        self.setStyleSheet(f"""
            QTextEdit {{
                border: none;
                padding: 0px 4px 0px 0px;
            }}
            QTextEdit:focus {{
                border: {border_thickness}px solid {border_color};
            }}
            QTextEdit::selection {{
                background-color: #D0E7FF;
                color: black;
            }}
        """)

        # Set document margins to 0 for compact display
        doc = self.document()
        doc.setDocumentMargin(0)

        # Configure text option for minimal line spacing
        # With zero-width spaces inserted after invisible character markers,
        # normal WordWrap will work correctly
        wrap_mode = QTextOption.WrapMode.WordWrap

        self.setWordWrapMode(wrap_mode)
        self.setAcceptRichText(False)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)

        text_option = QTextOption()
        text_option.setWrapMode(wrap_mode)
        doc.setDefaultTextOption(text_option)
        
        # Set minimum height to 0 - let content determine size
        self.setMinimumHeight(0)
        self.setMaximumHeight(16777215)  # Qt's max int
    
    def mouseDoubleClickEvent(self, event):
        """Handle double-click to select words properly when invisibles are shown"""
        from PyQt6.QtGui import QTextCursor
        
        main_window = self._get_main_window()
        # Check if invisible spaces are being shown
        if main_window and hasattr(main_window, 'invisible_display_settings'):
            if main_window.invisible_display_settings.get('spaces', False):
                # Get cursor position at click
                cursor = self.cursorForPosition(event.pos())
                pos = cursor.position()
                text = self.toPlainText()
                
                # Find word boundaries using middle dot (¬∑) or zero-width space as delimiters
                # Find start of word (search backwards for ¬∑ or start of text)
                start = pos
                while start > 0 and text[start - 1] not in ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂'):
                    start -= 1
                
                # Find end of word (search forwards for ¬∑ or end of text)
                end = pos
                while end < len(text) and text[end] not in ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂'):
                    end += 1
                
                # Select the word
                cursor.setPosition(start)
                cursor.setPosition(end, QTextCursor.MoveMode.KeepAnchor)
                self.setTextCursor(cursor)
                return
        
        # Default behavior
        super().mouseDoubleClickEvent(event)
    
    def _get_main_window(self):
        """Get the main application window by traversing the parent hierarchy"""
        if not self.table:
            return None
        main_window = self.table.parent()
        while main_window and not hasattr(main_window, 'go_to_first_segment'):
            main_window = main_window.parent()
        return main_window
    
    def _handle_add_to_termbase(self):
        """Handle Ctrl+T: Add selected source and target terms to termbase"""
        if not self.table or self.row < 0:
            return
        
        # Get target selection (from this widget)
        target_text = self.textCursor().selectedText().strip()
        
        # Get source cell widget and its selection
        source_widget = self.table.cellWidget(self.row, 2)
        source_text = ""
        if source_widget and hasattr(source_widget, 'textCursor'):
            source_text = source_widget.textCursor().selectedText().strip()
        
        # Validate we have both selections
        if not source_text or not target_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text in both Source and Target cells before adding to glossary.\\n\\n"
                "Workflow:\\n"
                "1. Select term in source/target cell\\n"
                "2. Press Tab to cycle to other cell\\n"
                "3. Select corresponding term\\n"
                "4. Press Ctrl+E (or right-click) to add to glossary"
            )
            return
        
        # Find main window and call add_to_termbase method
        main_window = self.table.parent()
        while main_window and not hasattr(main_window, 'add_term_pair_to_termbase'):
            main_window = main_window.parent()
        
        if main_window and hasattr(main_window, 'add_term_pair_to_termbase'):
            main_window.add_term_pair_to_termbase(source_text, target_text)
    
    def _handle_quick_add_to_termbase(self):
        """Handle Ctrl+R: Quick add selected source and target terms to glossary (no dialog)"""
        if not self.table or self.row < 0:
            return
        
        # Get target selection (from this widget)
        target_text = self.textCursor().selectedText().strip()
        
        # Get source cell widget and its selection
        source_widget = self.table.cellWidget(self.row, 2)
        source_text = ""
        if source_widget and hasattr(source_widget, 'textCursor'):
            source_text = source_widget.textCursor().selectedText().strip()
        
        # Validate we have both selections
        if not source_text or not target_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text in both Source and Target cells before quick-adding to glossary.\n\n"
                "Tip: Use Ctrl+E to add with a dialog where you can choose glossary and add metadata."
            )
            return
        
        # Find main window and call quick_add_to_termbase method
        main_window = self.table.parent()
        while main_window and not hasattr(main_window, 'quick_add_term_pair_to_termbase'):
            main_window = main_window.parent()
        
        if main_window and hasattr(main_window, 'quick_add_term_pair_to_termbase'):
            main_window.quick_add_term_pair_to_termbase(source_text, target_text)
    
    def _handle_superlookup_search(self):
        """Handle right-click: Search selected text in Superlookup"""
        # Get selected text
        selected_text = self.textCursor().selectedText().strip()
        
        if not selected_text:
            return
        
        # Find main window
        main_window = self.table.parent() if self.table else None
        while main_window and not hasattr(main_window, '_go_to_superlookup'):
            main_window = main_window.parent()
        
        if not main_window:
            return
        
        # Get project languages
        source_lang = None
        target_lang = None
        if hasattr(main_window, 'current_project') and main_window.current_project:
            source_lang = main_window.current_project.source_lang
            target_lang = main_window.current_project.target_lang
        
        # Navigate to Superlookup
        main_window._go_to_superlookup()
        
        # Trigger search
        if hasattr(main_window, 'lookup_tab') and main_window.lookup_tab:
            main_window.lookup_tab.search_with_query(
                selected_text,
                switch_to_vertical=True,
                source_lang=source_lang,
                target_lang=target_lang
            )
    
    def contextMenuEvent(self, event):
        """Show context menu with Add to Glossary, Non-Translatables, and Spellcheck options"""
        from PyQt6.QtWidgets import QMenu
        from PyQt6.QtGui import QAction
        
        menu = QMenu(self)
        
        # Check if cursor is on a misspelled word for spellcheck suggestions
        cursor_pos = self.cursorForPosition(event.pos())
        misspelled_word, word_start, word_end = self._get_misspelled_word_at_cursor(cursor_pos)
        
        if misspelled_word:
            # Get spellcheck suggestions
            if TagHighlighter._spellcheck_manager:
                suggestions = TagHighlighter._spellcheck_manager.get_suggestions(misspelled_word)
                
                if suggestions:
                    # Add suggestions at the top
                    for suggestion in suggestions[:5]:  # Limit to 5 suggestions
                        suggestion_action = QAction(f"‚úì {suggestion}", self)
                        # Use default argument to capture current value
                        suggestion_action.triggered.connect(
                            lambda checked, s=suggestion, start=word_start, end=word_end: 
                            self._replace_word(start, end, s)
                        )
                        suggestion_action.setFont(menu.font())
                        menu.addAction(suggestion_action)
                    menu.addSeparator()
                
                # Add to dictionary action
                add_to_dict_action = QAction(f"üìñ Add '{misspelled_word}' to Dictionary (Alt+D)", self)
                add_to_dict_action.triggered.connect(
                    lambda checked, w=misspelled_word: self._add_to_dictionary(w)
                )
                menu.addAction(add_to_dict_action)
                
                # Ignore this session action
                ignore_action = QAction(f"üîá Ignore '{misspelled_word}' (this session)", self)
                ignore_action.triggered.connect(
                    lambda checked, w=misspelled_word: self._ignore_word(w)
                )
                menu.addAction(ignore_action)
                menu.addSeparator()
        
        # Add standard edit actions
        if self.textCursor().hasSelection():
            copy_action = QAction("Copy", self)
            copy_action.triggered.connect(self.copy)
            menu.addAction(copy_action)
            
            cut_action = QAction("Cut", self)
            cut_action.triggered.connect(self.cut)
            menu.addAction(cut_action)
            menu.addSeparator()
        
        paste_action = QAction("Paste", self)
        paste_action.triggered.connect(self.paste)
        menu.addAction(paste_action)
        menu.addSeparator()
        
        # Superlookup search action
        if self.textCursor().hasSelection():
            superlookup_action = QAction("üîç Search in Superlookup (Ctrl+K)", self)
            superlookup_action.triggered.connect(self._handle_superlookup_search)
            menu.addAction(superlookup_action)
            menu.addSeparator()

        # QuickMenu (prompt-based actions)
        try:
            main_window = self.table.parent() if self.table else None
            while main_window and not hasattr(main_window, 'run_grid_quickmenu_prompt'):
                main_window = main_window.parent()

            quickmenu_items = []
            if main_window and hasattr(main_window, 'prompt_manager_qt') and main_window.prompt_manager_qt:
                lib = getattr(main_window.prompt_manager_qt, 'library', None)
                if lib and hasattr(lib, 'get_quickmenu_grid_prompts'):
                    quickmenu_items = lib.get_quickmenu_grid_prompts() or []

            if quickmenu_items:
                qm_menu = menu.addMenu("‚ö° QuickMenu")
                for rel_path, label in sorted(quickmenu_items, key=lambda x: (x[1] or x[0]).lower()):
                    prompt_menu = qm_menu.addMenu(label or rel_path)

                    run_show = QAction("‚ñ∂ Run (show response)‚Ä¶", self)
                    run_show.triggered.connect(
                        lambda checked=False, p=rel_path: main_window.run_grid_quickmenu_prompt(p, origin_widget=self, behavior="show")
                    )
                    prompt_menu.addAction(run_show)

                    run_replace = QAction("‚Ü∫ Run and replace selection", self)
                    run_replace.triggered.connect(
                        lambda checked=False, p=rel_path: main_window.run_grid_quickmenu_prompt(p, origin_widget=self, behavior="replace")
                    )
                    prompt_menu.addAction(run_replace)

                menu.addSeparator()
        except Exception:
            # Never break the normal context menu due to QuickMenu errors
            pass
        
        # Add to termbase action (with dialog)
        add_to_tb_action = QAction("üìñ Add to Glossary (Ctrl+E)", self)
        add_to_tb_action.triggered.connect(self._handle_add_to_termbase)
        menu.addAction(add_to_tb_action)
        
        # Quick add to termbase action (no dialog) - uses last-selected termbase from Ctrl+E
        quick_add_action = QAction("‚ö° Quick Add to Glossary (Alt+Left)", self)
        quick_add_action.triggered.connect(self._handle_quick_add_to_termbase)
        menu.addAction(quick_add_action)
        
        # Add to non-translatables action
        add_to_nt_action = QAction("üö´ Add to Non-Translatables (Ctrl+Alt+N)", self)
        add_to_nt_action.triggered.connect(self._handle_add_to_nt)
        menu.addAction(add_to_nt_action)
        
        menu.exec(event.globalPos())

    def _get_misspelled_word_at_cursor(self, cursor):
        """Get the misspelled word at the cursor position, if any"""
        import re
        
        if not TagHighlighter._spellcheck_enabled or not TagHighlighter._spellcheck_manager:
            return None, 0, 0
        
        text = self.toPlainText()
        pos = cursor.position()
        
        # Find word boundaries around cursor position
        word_pattern = re.compile(r'\b([a-zA-Z√Ä-√ø\']+)\b', re.UNICODE)
        
        for match in word_pattern.finditer(text):
            start = match.start(1)
            end = match.end(1)
            
            if start <= pos <= end:
                word = match.group(1)
                # Check if this word is misspelled
                if not TagHighlighter._spellcheck_manager.check_word(word):
                    return word, start, end
                break
        
        return None, 0, 0

    def _replace_word(self, start: int, end: int, replacement: str):
        """Replace a word at the given position with the replacement"""
        cursor = self.textCursor()
        cursor.setPosition(start)
        cursor.setPosition(end, cursor.MoveMode.KeepAnchor)
        cursor.insertText(replacement)

    def _add_to_dictionary(self, word: str):
        """Add word to the custom dictionary"""
        if TagHighlighter._spellcheck_manager:
            TagHighlighter._spellcheck_manager.add_to_dictionary(word)
            
            # Show confirmation in main window log
            main_window = self._get_main_window()
            if main_window and hasattr(main_window, 'log'):
                main_window.log(f"‚úì Added '{word}' to custom dictionary")

            # Refresh all highlighters to update other occurrences
            if main_window and hasattr(main_window, '_refresh_all_highlighters'):
                main_window._refresh_all_highlighters()
            else:
                # Fallback to local rehighlight
                self.highlighter.rehighlight()

    def _ignore_word(self, word: str):
        """Ignore word for this session"""
        if TagHighlighter._spellcheck_manager:
            TagHighlighter._spellcheck_manager.ignore_word(word)
            
            # Show confirmation in main window log
            main_window = self._get_main_window()
            if main_window and hasattr(main_window, 'log'):
                main_window.log(f"üîá Ignoring '{word}' for this session")

            # Refresh all highlighters to update other occurrences
            if main_window and hasattr(main_window, '_refresh_all_highlighters'):
                main_window._refresh_all_highlighters()
            else:
                # Fallback to local rehighlight
                self.highlighter.rehighlight()
    
    def sizeHint(self):
        """Return compact size based on content"""
        doc = self.document()
        ideal_width = self.width() if self.width() > 0 else 200
        doc.setTextWidth(ideal_width)
        height = int(doc.size().height())
        # Add minimal padding (2px total)
        height = max(height + 2, 1)
        current_width = self.width() if self.width() > 0 else 200
        return QSize(current_width, height)
    
    def mousePressEvent(self, event):
        """Allow text selection on click and auto-select row"""
        super().mousePressEvent(event)
        # Auto-select the row when clicking in the target cell
        if self.table and self.row >= 0:
            # Check for Shift or Ctrl modifier - let Qt handle native multi-selection
            modifiers = event.modifiers()
            is_shift = modifiers & Qt.KeyboardModifier.ShiftModifier
            is_ctrl = modifiers & Qt.KeyboardModifier.ControlModifier

            if is_shift or is_ctrl:
                # For Shift+click (range) or Ctrl+click (toggle), just set current cell
                # but don't call selectRow() which would clear the selection
                self.table.setCurrentCell(self.row, 3)  # Column 3 is Target
            else:
                # Normal click - select just this row
                self.table.selectRow(self.row)
                self.table.setCurrentCell(self.row, 3)  # Column 3 is Target

                # CRITICAL: Manually trigger on_cell_selected since signals aren't firing
                # Find the main window and call the method directly
                try:
                    main_window = self.table.parent()
                    while main_window and not hasattr(main_window, 'on_cell_selected'):
                        main_window = main_window.parent()
                    if main_window and hasattr(main_window, 'on_cell_selected'):
                        main_window.on_cell_selected(self.row, 3, -1, -1)
                except Exception as e:
                    print(f"Error triggering manual cell selection: {e}")

    def mouseReleaseEvent(self, event):
        """Smart word selection - expand partial selections to full words
        
        Works across multiple lines - if you select text spanning several lines,
        partial words at the START and END of your selection will be expanded.
        """
        super().mouseReleaseEvent(event)

        # Check if smart selection is enabled
        main_window = self._get_main_window()
        if main_window and hasattr(main_window, 'enable_smart_word_selection'):
            if not main_window.enable_smart_word_selection:
                return  # Feature disabled

        # Get the current cursor
        cursor = self.textCursor()

        # Only expand if there's a selection
        if cursor.hasSelection():
            # Get selection boundaries
            start = cursor.selectionStart()
            end = cursor.selectionEnd()

            # Get the full text
            text = self.toPlainText()

            # Helper function to check if character is part of a word
            # Includes alphanumeric, underscore, hyphen, and apostrophe
            def is_word_char(char):
                return char.isalnum() or char in "_-'"

            # Track if we need to update the selection
            selection_changed = False

            # Expand START boundary if we're in the middle of a word
            # (i.e., the character before the selection is a word character)
            if start > 0 and is_word_char(text[start - 1]):
                # Also check that the first selected character is a word char
                # (to avoid expanding when selecting from whitespace)
                if start < len(text) and is_word_char(text[start]):
                    while start > 0 and is_word_char(text[start - 1]):
                        start -= 1
                    selection_changed = True

            # Expand END boundary if we're in the middle of a word
            # (i.e., the character after the selection is a word character)
            if end < len(text) and is_word_char(text[end]):
                # Also check that the last selected character is a word char
                # (to avoid expanding when selecting to whitespace)
                if end > 0 and is_word_char(text[end - 1]):
                    while end < len(text) and is_word_char(text[end]):
                        end += 1
                    selection_changed = True

            # Set the new selection if boundaries changed
            if selection_changed:
                cursor.setPosition(start)
                cursor.setPosition(end, cursor.MoveMode.KeepAnchor)
                self.setTextCursor(cursor)

    def focusInEvent(self, event):
        """Ensure text remains visible when focused and auto-select row"""
        super().focusInEvent(event)
        # Ensure the widget is properly visible
        self.setVisible(True)
        self.show()
        # Auto-select the row when focusing the target cell
        if self.table and self.row >= 0:
            # Check for Shift or Ctrl modifier - let Qt handle native multi-selection
            from PyQt6.QtWidgets import QApplication
            modifiers = QApplication.keyboardModifiers()
            is_shift = modifiers & Qt.KeyboardModifier.ShiftModifier
            is_ctrl = modifiers & Qt.KeyboardModifier.ControlModifier

            if is_shift or is_ctrl:
                # For Shift+click (range) or Ctrl+click (toggle), just set current cell
                # but don't call selectRow() which would clear the selection
                self.table.setCurrentCell(self.row, 3)  # Column 3 is Target
            else:
                # Normal focus - select just this row
                self.table.selectRow(self.row)
                self.table.setCurrentCell(self.row, 3)  # Column 3 is Target

                # CRITICAL: Manually trigger on_cell_selected since signals aren't firing
                # Find the main window and call the method directly
                try:
                    main_window = self.table.parent()
                    while main_window and not hasattr(main_window, 'on_cell_selected'):
                        main_window = main_window.parent()
                    if main_window and hasattr(main_window, 'on_cell_selected'):
                        main_window.on_cell_selected(self.row, 3, -1, -1)
                except Exception as e:
                    print(f"Error triggering manual cell selection: {e}")
    
    def keyPressEvent(self, event):
        """Handle Tab and Ctrl+E keys to cycle between source and target cells"""
        from PyQt6.QtWidgets import QApplication
        from PyQt6.QtGui import QTextCursor
        
        # Ctrl+C: Fix clipboard when copying with invisible characters shown
        if event.key() == Qt.Key.Key_C and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            cursor = self.textCursor()
            if cursor.hasSelection():
                selected_text = cursor.selectedText()
                # Reverse invisible character replacements before copying
                main_window = self._get_main_window()
                if main_window and hasattr(main_window, 'reverse_invisible_replacements'):
                    clean_text = main_window.reverse_invisible_replacements(selected_text)
                    # Also replace paragraph separator with newline (Qt uses U+2029)
                    clean_text = clean_text.replace('\u2029', '\n')
                    # Set clipboard with clean text
                    clipboard = QApplication.clipboard()
                    clipboard.setText(clean_text)
                    event.accept()
                    return
        
        # Handle Ctrl+Arrow word navigation when invisibles are shown
        main_window = self._get_main_window()
        if main_window and hasattr(main_window, 'invisible_display_settings'):
            if main_window.invisible_display_settings.get('spaces', False):
                ctrl_only = event.modifiers() == Qt.KeyboardModifier.ControlModifier
                ctrl_shift = event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier)
                
                if (ctrl_only or ctrl_shift) and event.key() in (Qt.Key.Key_Left, Qt.Key.Key_Right):
                    cursor = self.textCursor()
                    text = self.toPlainText()
                    pos = cursor.position()
                    word_chars = ('¬∑', '\u200B', '\n', '\t', '‚Üí', '¬∞', '¬∂', ' ')
                    
                    if event.key() == Qt.Key.Key_Right:
                        # Move to end of current word, then skip delimiters to start of next word
                        # First skip any delimiters we're on
                        while pos < len(text) and text[pos] in word_chars:
                            pos += 1
                        # Then skip to end of word (next delimiter)
                        while pos < len(text) and text[pos] not in word_chars:
                            pos += 1
                    else:  # Key_Left
                        # Move backwards: skip delimiters, then find start of word
                        if pos > 0:
                            pos -= 1
                        # Skip any delimiters
                        while pos > 0 and text[pos] in word_chars:
                            pos -= 1
                        # Find start of word
                        while pos > 0 and text[pos - 1] not in word_chars:
                            pos -= 1
                    
                    # Apply cursor movement
                    if ctrl_shift:
                        cursor.setPosition(pos, QTextCursor.MoveMode.KeepAnchor)
                    else:
                        cursor.setPosition(pos)
                    self.setTextCursor(cursor)
                    event.accept()
                    return
        
        # Ctrl+E: Add selected terms to termbase (with dialog)
        if event.key() == Qt.Key.Key_E and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self._handle_add_to_termbase()
            event.accept()
            return
        
        # Alt+Left: Quick add selected terms to last-used termbase (no dialog)
        if event.key() == Qt.Key.Key_Left and event.modifiers() == Qt.KeyboardModifier.AltModifier:
            self._handle_quick_add_to_termbase()
            event.accept()
            return
        
        # Ctrl+Alt+N: Add selected text to non-translatables
        if event.key() == Qt.Key.Key_N and event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier):
            self._handle_add_to_nt()
            event.accept()
            return
        
        # Ctrl+Home: Navigate to first segment (pass to main window)
        if event.key() == Qt.Key.Key_Home and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            main_window = self._get_main_window()
            if main_window and hasattr(main_window, 'go_to_first_segment'):
                main_window.go_to_first_segment()
            event.accept()
            return
        
        # Ctrl+End: Navigate to last segment (pass to main window)
        if event.key() == Qt.Key.Key_End and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            main_window = self._get_main_window()
            if main_window and hasattr(main_window, 'go_to_last_segment'):
                main_window.go_to_last_segment()
            event.accept()
            return
        
        # Ctrl+, (comma): Insert next memoQ tag or wrap selection with tag pair
        if event.key() == Qt.Key.Key_Comma and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self._insert_next_tag_or_wrap_selection()
            event.accept()
            return
        
        # Ctrl+Shift+S: Copy source text to target
        if event.key() == Qt.Key.Key_S and event.modifiers() == (Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.ShiftModifier):
            self._copy_source_to_target()
            event.accept()
            return
        
        # Ctrl+B: Apply bold formatting to selection
        if event.key() == Qt.Key.Key_B and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self._apply_formatting_tag('b')
            event.accept()
            return
        
        # Ctrl+I: Apply italic formatting to selection
        if event.key() == Qt.Key.Key_I and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self._apply_formatting_tag('i')
            event.accept()
            return
        
        # Ctrl+U: Apply underline formatting to selection
        if event.key() == Qt.Key.Key_U and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self._apply_formatting_tag('u')
            event.accept()
            return
        
        # Ctrl+Enter: Confirm & Next (call main window method directly)
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter) and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            main_window = self._get_main_window()
            if main_window and hasattr(main_window, 'confirm_selected_or_next'):
                main_window.confirm_selected_or_next()
            event.accept()
            return
        
        # Shift+Enter: Insert line break (for multi-line content)
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter) and event.modifiers() == Qt.KeyboardModifier.ShiftModifier:
            super().keyPressEvent(event)
            event.accept()
            return
        
        # Plain Enter: Don't insert newline, just accept
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter) and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            event.accept()
            return
        
        # Ctrl+Tab: Insert actual tab character
        if event.key() == Qt.Key.Key_Tab and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self.insertPlainText('\t')
            event.accept()
            return
        
        # Tab alone: Cycle to source cell (column 2) in same row
        if event.key() == Qt.Key.Key_Tab and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            if self.table and self.row >= 0:
                # Get source cell widget (column 2)
                source_widget = self.table.cellWidget(self.row, 2)
                if source_widget:
                    source_widget.setFocus()
                    self.table.setCurrentCell(self.row, 2)
                    event.accept()
                    return
        
        # Arrow Up/Down: memoQ-style segment navigation at cell boundaries
        # When cursor is at top VISUAL line and Up is pressed, go to previous segment
        # When cursor is at bottom VISUAL line and Down is pressed, go to next segment
        if event.key() in (Qt.Key.Key_Up, Qt.Key.Key_Down) and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            cursor = self.textCursor()
            current_block = cursor.block()
            doc = self.document()
            first_block = doc.firstBlock()
            last_block = doc.lastBlock()
            
            # Get the visual line number within the current block
            layout = current_block.layout()
            if layout:
                pos_in_block = cursor.positionInBlock()
                current_visual_line = layout.lineForTextPosition(pos_in_block)
                current_line_num = current_visual_line.lineNumber() if current_visual_line.isValid() else 0
                total_lines_in_block = layout.lineCount()
            else:
                current_line_num = 0
                total_lines_in_block = 1
            
            if event.key() == Qt.Key.Key_Up:
                # Only navigate to previous segment if we're on the FIRST visual line of the FIRST block
                is_first_visual_line = (current_block == first_block and current_line_num == 0)
                if is_first_visual_line:
                    main_window = self._get_main_window()
                    if main_window and hasattr(main_window, 'go_to_previous_segment'):
                        # Get cursor column within current visual line
                        if layout and current_visual_line.isValid():
                            col_in_line = pos_in_block - int(current_visual_line.textStart())
                        else:
                            col_in_line = cursor.positionInBlock()
                        # Signal rapid navigation for performance optimization
                        main_window._arrow_key_navigation = True
                        main_window.go_to_previous_segment(target_column=col_in_line, to_last_line=True)
                        event.accept()
                        return
            
            elif event.key() == Qt.Key.Key_Down:
                # Only navigate to next segment if we're on the LAST visual line of the LAST block
                is_last_visual_line = (current_block == last_block and current_line_num >= total_lines_in_block - 1)
                if is_last_visual_line:
                    main_window = self._get_main_window()
                    if main_window and hasattr(main_window, 'go_to_next_segment'):
                        # Get cursor column within current visual line
                        if layout and current_visual_line.isValid():
                            col_in_line = pos_in_block - int(current_visual_line.textStart())
                        else:
                            col_in_line = cursor.positionInBlock()
                        # Signal rapid navigation for performance optimization
                        main_window._arrow_key_navigation = True
                        main_window.go_to_next_segment(target_column=col_in_line, to_first_line=True)
                        event.accept()
                        return
        
        # All other keys: Handle normally
        super().keyPressEvent(event)
    
    def _handle_add_to_nt(self):
        """Handle Ctrl+Alt+N: Add selected text to active non-translatable list(s)"""
        # Get selected text from source cell (for NT, we typically add from source)
        # But if this is target and source is available, use source
        selected_text = self.textCursor().selectedText().strip()
        
        # If no selection in target, try getting from source
        if not selected_text and self.table and self.row >= 0:
            source_widget = self.table.cellWidget(self.row, 2)
            if source_widget and hasattr(source_widget, 'textCursor'):
                selected_text = source_widget.textCursor().selectedText().strip()
        
        if not selected_text:
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.warning(
                self,
                "Selection Required",
                "Please select text before adding to non-translatables."
            )
            return
        
        # Find main window and call add_to_nt method
        if self.table:
            main_window = self.table.parent()
            while main_window and not hasattr(main_window, 'add_text_to_non_translatables'):
                main_window = main_window.parent()
            
            if main_window and hasattr(main_window, 'add_text_to_non_translatables'):
                main_window.add_text_to_non_translatables(selected_text)
            else:
                from PyQt6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Feature Not Available",
                    "Non-translatables functionality not available."
                )

    def _insert_next_tag_or_wrap_selection(self):
        """
        Insert the next memoQ tag, HTML tag, or CafeTran pipe symbol from source, or wrap selection.
        
        Behavior:
        - If text is selected: Wrap it with the next available tag pair [N}selection{N] or |selection|
        - If no selection: Insert the next unused tag/pipe from source at cursor position
        
        Supports:
        - memoQ tags: [1}, {1], [2}, {2], etc.
        - HTML/XML tags: <li>, </li>, <b>, </b>, <i>, </i>, etc.
        - CafeTran pipe symbols: |
        
        Shortcut: Ctrl+, (comma)
        """
        if not self.table or self.row < 0:
            return
        
        # Navigate up to find main window
        main_window = self.table.parent()
        while main_window and not hasattr(main_window, 'current_project'):
            main_window = main_window.parent()
        
        if not main_window or not hasattr(main_window, 'current_project'):
            return
        
        if not main_window.current_project or self.row >= len(main_window.current_project.segments):
            return
        
        segment = main_window.current_project.segments[self.row]
        source_text = segment.source
        current_target = self.toPlainText()
        
        # Check what type of tags are in the source
        has_memoq_tags = bool(extract_memoq_tags(source_text))
        has_html_tags = bool(extract_html_tags(source_text))
        has_any_tags = has_memoq_tags or has_html_tags
        has_pipe_symbols = '|' in source_text
        
        # Check if there's a selection
        cursor = self.textCursor()
        if cursor.hasSelection():
            selected_text = cursor.selectedText()

            # Try memoQ tag pair first
            if has_memoq_tags:
                opening_tag, closing_tag = get_wrapping_tag_pair(source_text, current_target)
                if opening_tag and closing_tag:
                    wrapped_text = f"{opening_tag}{selected_text}{closing_tag}"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with {opening_tag}...{closing_tag}")
                    return

            # Try HTML tag pairs (e.g., <b>...</b>, <i>...</i>)
            if has_html_tags:
                opening_tag, closing_tag = get_html_wrapping_tag_pair(source_text, current_target)
                if opening_tag and closing_tag:
                    wrapped_text = f"{opening_tag}{selected_text}{closing_tag}"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with {opening_tag}...{closing_tag}")
                    return

            # Try CafeTran pipe symbols
            if has_pipe_symbols:
                pipes_needed = get_next_pipe_count_needed(source_text, current_target)
                if pipes_needed >= 2:
                    # Wrap with pipes
                    wrapped_text = f"|{selected_text}|"
                    cursor.insertText(wrapped_text)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Wrapped selection with |...|")
                    return

            if hasattr(main_window, 'log'):
                main_window.log("‚ö†Ô∏è No tag pairs available from source")
        else:
            # No selection - insert next unused tag or pipe at cursor

            # Try memoQ tags and HTML tags (find_next_unused_tag handles both)
            if has_any_tags:
                next_tag = find_next_unused_tag(source_text, current_target)
                if next_tag:
                    cursor.insertText(next_tag)
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Inserted tag: {next_tag}")
                    return

            # Try CafeTran pipe symbols
            if has_pipe_symbols:
                pipes_needed = get_next_pipe_count_needed(source_text, current_target)
                if pipes_needed > 0:
                    cursor.insertText('|')
                    if hasattr(main_window, 'log'):
                        main_window.log(f"üè∑Ô∏è Inserted pipe symbol (|)")
                    return

            if hasattr(main_window, 'log'):
                main_window.log("‚úì All tags from source already in target")

    def _copy_source_to_target(self):
        """
        Copy source text to target cell.
        
        Shortcut: Ctrl+Shift+S
        """
        if not self.table or self.row < 0:
            return
        
        # Navigate up to find main window
        main_window = self.table.parent()
        while main_window and not hasattr(main_window, 'current_project'):
            main_window = main_window.parent()
        
        if not main_window or not hasattr(main_window, 'current_project'):
            return
        
        if not main_window.current_project or self.row >= len(main_window.current_project.segments):
            return
        
        segment = main_window.current_project.segments[self.row]
        source_text = segment.source
        
        # Set the target text
        self.setPlainText(source_text)
        
        if hasattr(main_window, 'log'):
            main_window.log(f"üìã Copied source to target (segment {self.row + 1})")

    def _apply_formatting_tag(self, tag: str):
        """
        Apply or toggle a formatting tag on the selected text.
        
        Args:
            tag: The tag to apply ('b', 'i', or 'u')
        """
        cursor = self.textCursor()
        if not cursor.hasSelection():
            return
        
        selected_text = cursor.selectedText()
        
        # Check if the text is already wrapped with this tag
        open_tag = f"<{tag}>"
        close_tag = f"</{tag}>"
        
        # Get the full text and selection position
        full_text = self.toPlainText()
        start = cursor.selectionStart()
        end = cursor.selectionEnd()
        
        # Check for existing tags just before/after selection
        prefix_has_tag = start >= len(open_tag) and full_text[start - len(open_tag):start] == open_tag
        suffix_has_tag = end + len(close_tag) <= len(full_text) and full_text[end:end + len(close_tag)] == close_tag
        
        if prefix_has_tag and suffix_has_tag:
            # Remove the tags (toggle off)
            new_text = full_text[:start - len(open_tag)] + selected_text + full_text[end + len(close_tag):]
            cursor.setPosition(start - len(open_tag))
            cursor.setPosition(end + len(close_tag), cursor.MoveMode.KeepAnchor)
            cursor.insertText(selected_text)
        else:
            # Add the tags (toggle on)
            wrapped_text = f"{open_tag}{selected_text}{close_tag}"
            cursor.insertText(wrapped_text)
            
            # Re-select the wrapped text (including tags)
            cursor.setPosition(start)
            cursor.setPosition(start + len(wrapped_text), cursor.MoveMode.KeepAnchor)
            self.setTextCursor(cursor)

    def update_display_mode(self, text: str, show_tags: bool):
        """
        Update the display based on tag view mode.
        
        Args:
            text: The raw text (with HTML tags like <b>bold</b>)
            show_tags: If True, show raw tags. If False, show formatted WYSIWYG.
        """
        # Store raw text as property for later retrieval
        self._raw_text = text
        
        self.blockSignals(True)
        if show_tags:
            # Tag view: Show plain text with visible tags
            # The TagHighlighter will colorize the tags
            self.setPlainText(text)
        else:
            # WYSIWYG view: Apply formatting
            if has_formatting_tags(text):
                html = get_formatted_html_display(text)
                self.setHtml(html)
            else:
                # No tags, just plain text
                self.setPlainText(text)
        self.blockSignals(False)
    
    def get_raw_text(self) -> str:
        """Get the raw text with tags, regardless of display mode."""
        return getattr(self, '_raw_text', self.toPlainText())

    def set_background_color(self, color: str):
        """Set the background color for this text editor (for alternating row colors)"""
        # Use class variables for border settings to respect user customization
        border_color = EditableGridTextEditor.focus_border_color
        border_thickness = EditableGridTextEditor.focus_border_thickness
        self.setStyleSheet(f"""
            QTextEdit {{
                border: none;
                background-color: {color};
                padding: 0px 4px 0px 0px;
            }}
            QTextEdit:focus {{
                border: {border_thickness}px solid {border_color};
            }}
            QTextEdit::selection {{
                background-color: #D0E7FF;
                color: black;
            }}
        """)


class SearchHighlightDelegate(QStyledItemDelegate):
    """
    Custom delegate that highlights search terms in cells while preserving full editability.
    Uses custom painting to draw highlights underneath the text.
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.search_terms = {}  # Dict of {(row, col): search_term}
        self.highlight_color = QColor(255, 255, 0, 180)  # Yellow with some transparency

    def set_highlight(self, row: int, col: int, search_term: str):
        """Set a search term to highlight for a specific cell"""
        self.search_terms[(row, col)] = search_term

    def clear_highlight(self, row: int, col: int):
        """Clear highlight for a specific cell"""
        if (row, col) in self.search_terms:
            del self.search_terms[(row, col)]

    def clear_all_highlights(self):
        """Clear all highlights"""
        self.search_terms.clear()

    def paint(self, painter, option, index):
        """Custom paint method that highlights search terms"""
        row = index.row()
        col = index.column()

        # Check if this cell has a search term to highlight
        if (row, col) in self.search_terms:
            search_term = self.search_terms[(row, col)]
            text = index.data(Qt.ItemDataRole.DisplayRole) or ""

            if text and search_term:
                # Save painter state
                painter.save()

                # Draw the background first (handles selection, etc.)
                option_copy = QStyleOptionViewItem(option)
                self.initStyleOption(option_copy, index)

                # Get the style
                style = option.widget.style() if option.widget else QApplication.style()

                # Draw background
                style.drawPrimitive(QStyle.PrimitiveElement.PE_PanelItemViewItem, option_copy, painter, option.widget)

                # Calculate text rect
                text_rect = style.subElementRect(QStyle.SubElement.SE_ItemViewItemText, option_copy, option.widget)

                # Get font metrics
                fm = painter.fontMetrics()

                # Find and highlight all occurrences of the search term
                text_lower = text.lower()
                search_lower = search_term.lower()
                pos = 0

                while True:
                    found = text_lower.find(search_lower, pos)
                    if found == -1:
                        break

                    # Calculate the position of this occurrence
                    prefix = text[:found]
                    prefix_width = fm.horizontalAdvance(prefix)
                    term_width = fm.horizontalAdvance(text[found:found + len(search_term)])

                    # Draw highlight rectangle
                    highlight_rect = QRectF(
                        text_rect.left() + prefix_width,
                        text_rect.top(),
                        term_width,
                        text_rect.height()
                    )
                    painter.fillRect(highlight_rect, self.highlight_color)

                    pos = found + len(search_term)

                # Draw the text on top
                painter.setPen(option_copy.palette.color(QPalette.ColorRole.Text))
                painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, text)

                painter.restore()
                return

        # Default painting for non-highlighted cells
        super().paint(painter, option, index)


class ClickableHighlightLabel(QLabel):
    """
    Custom QLabel for highlighted search results that allows double-click to edit.
    When double-clicked, it removes itself from the table cell and triggers editing.

    Mouse events are transparent by default - the table's viewport handles them.
    We use installEventFilter on the table's viewport to catch double-clicks.
    """

    def __init__(self, table, row: int, col: int, plain_text: str, parent=None):
        super().__init__(parent)
        self.table = table
        self.row = row
        self.col = col
        self.plain_text = plain_text  # Store the original plain text for restoration
        # Make mouse events pass through to the table underneath
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)


class TermbaseHighlightWidget(QLabel):
    """Custom label widget that displays source text with termbase highlights and tooltips"""
    
    # Signal for term double-click
    term_double_clicked = None
    
    def __init__(self, source_text: str, termbase_matches: Optional[Dict[str, str]] = None, parent=None):
        """
        Args:
            source_text: The full source text to display
            termbase_matches: Dict of {term: translation} for highlighted terms
            parent: Parent widget
        """
        super().__init__(parent)
        self.source_text = source_text
        self.termbase_matches = termbase_matches if termbase_matches is not None else {}
        self.term_ranges = {}  # Store {term: (start_pos, end_pos)}
        self.setWordWrap(True)
        self.setup_display()
        self.setMouseTracking(True)
    
    def setup_display(self):
        """Create rich text display with highlighted terms"""
        html = self._create_highlighted_html()
        self.setText(html)
        self.setTextFormat(Qt.TextFormat.RichText)
    
    def _create_highlighted_html(self) -> str:
        """Create HTML with highlighted termbase matches using priority colors"""
        text = self.source_text
        
        # Sort matches by source term length (longest first) to avoid overlaps
        # Since dict keys are now term_ids, extract source terms first
        term_entries = []
        for term_id, match_info in self.termbase_matches.items():
            if isinstance(match_info, dict):
                source_term = match_info.get('source', '')
                if source_term:
                    term_entries.append((source_term, match_info))
        
        term_entries.sort(key=lambda x: len(x[0]), reverse=True)
        
        # Build HTML with highlights
        html = text
        offset = 0
        
        for term, match_info in term_entries:
            # Case-insensitive search
            search_term = term.lower()
            search_html = html.lower()
            
            # Get priority-based color (if termbase_matches contains priority info)
            if isinstance(match_info, dict) and 'priority' in match_info:
                priority = match_info.get('priority', 50)
                translation = match_info.get('translation', '')
            else:
                # Backward compatibility: if just string, use default priority
                priority = 50
                translation = match_info if isinstance(match_info, str) else ''
            
            # Calculate color based on priority (1-99, higher = darker blue)
            # Priority 99 = darkest (#0066CC), Priority 1 = lightest (#99CCFF)
            darkness = int(255 - (priority * 1.5))  # Higher priority = lower RGB value = darker
            darkness = max(0, min(darkness, 200))  # Clamp between 0-200
            color = f"rgb(0, {darkness}, 255)"
            
            # Find all occurrences
            start = 0
            while True:
                idx = search_html.find(search_term, start)
                if idx == -1:
                    break
                
                # Extract original casing
                original_term = html[idx:idx + len(term)]
                
                # Replace with highlighted version using priority color
                highlighted = f'<span style="background-color: {color}; color: white; padding: 1px 3px; border-radius: 2px; font-weight: bold; cursor: pointer;" class="termbase-match" data-term="{term}" title="{translation} (Priority: {priority})">{original_term}</span>'
                
                html = html[:idx] + highlighted + html[idx + len(term):]
                search_html = html.lower()
                
                start = idx + len(highlighted)
        
        return html
    
    def mouseMoveEvent(self, ev):
        """Show tooltip when hovering over highlighted terms"""
        # Find if cursor is over a highlighted term using text format
        # This is a simplified approach - shows generic tooltip
        super().mouseMoveEvent(ev)
    
    def mouseDoubleClickEvent(self, ev):
        """Handle double-click on highlighted terms"""
        # Find which term was clicked by getting the word at the position
        # Since QLabel doesn't provide cursor position easily, we look at the click
        # and try to extract the clicked word from the text
        
        # Get position in text (approximate)
        pos = ev.pos()
        
        # Try to find which term is near the click point
        # This is a simplified approach - in production would need better handling
        for term_id, match_info in self.termbase_matches.items():
            term = match_info.get('source', '') if isinstance(match_info, dict) else str(term_id)
            translation = match_info.get('translation', match_info) if isinstance(match_info, dict) else match_info
            # Check if this term contains the click area (very approximate)
            if self.term_double_clicked is not None and callable(self.term_double_clicked):
                # For now, if we get a double-click and there are matches,
                # this is a signal to insert the first/only match
                # Better implementation would need proper hit detection
                pass
        
        super().mouseDoubleClickEvent(ev)


class WordWrapDelegate(QStyledItemDelegate):
    """Custom delegate to enable word wrap when editing cells, with search term highlighting"""

    def __init__(self, assistance_panel=None, table_widget=None, allow_source_edit=False):
        super().__init__()
        self.assistance_panel = assistance_panel
        self.table_widget = table_widget
        self.allow_source_edit = allow_source_edit  # Controls whether source can be edited
        self.search_terms = {}  # Dict of {(row, col): search_term} for highlighting
        self.highlight_color = QColor(255, 255, 0, 180)  # Yellow with some transparency

    def set_highlight(self, row: int, col: int, search_term: str):
        """Set a search term to highlight for a specific cell"""
        self.search_terms[(row, col)] = search_term

    def clear_highlight(self, row: int, col: int):
        """Clear highlight for a specific cell"""
        if (row, col) in self.search_terms:
            del self.search_terms[(row, col)]

    def clear_all_highlights(self):
        """Clear all highlights"""
        self.search_terms.clear()

    def paint(self, painter, option, index):
        """Custom paint method that highlights search terms while keeping cells editable.

        Uses QTextDocument with HTML for reliable cross-line highlighting.
        Instead of storing per-cell terms, we store a global search term and check
        if the cell's text contains it.
        """
        row = index.row()
        col = index.column()

        # Check if this cell has a search term to highlight
        # Use global search term if set, otherwise check per-cell dict
        search_term = None
        if col == 3 and hasattr(self, 'global_search_term') and self.global_search_term:
            # For target column, use global search term
            search_term = self.global_search_term
        elif col == 2 and hasattr(self, 'global_source_search_term') and self.global_source_search_term:
            # For source column, use global source search term
            search_term = self.global_source_search_term
        elif (row, col) in self.search_terms:
            search_term = self.search_terms[(row, col)]

        # Debug: Log once per column 3 cell when global_search_term is set
        if col == 3 and hasattr(self, 'global_search_term') and self.global_search_term and row == 0:
            print(f"[PAINT DEBUG] Row 0, Col 3: global_search_term='{self.global_search_term}', search_term='{search_term}'")

        if search_term:
            text = index.data(Qt.ItemDataRole.DisplayRole) or ""

            # Only highlight if the search term is actually in the text
            if text and search_term.lower() in text.lower():
                from PyQt6.QtGui import QColor, QTextDocument, QAbstractTextDocumentLayout, QPalette
                from PyQt6.QtCore import QRectF, QSizeF
                import html as html_module

                # Get style and text rect
                option_copy = QStyleOptionViewItem(option)
                self.initStyleOption(option_copy, index)
                style = option.widget.style() if option.widget else QApplication.style()

                # Draw background first (handles selection state etc.)
                style.drawPrimitive(QStyle.PrimitiveElement.PE_PanelItemViewItem, option_copy, painter, option.widget)

                # Get the text rectangle
                text_rect = style.subElementRect(QStyle.SubElement.SE_ItemViewItemText, option_copy, option.widget)

                # Add small padding like default delegate
                text_rect = text_rect.adjusted(3, 0, -3, 0)

                # Create HTML with highlighted search terms
                # Escape HTML special characters first
                escaped_text = html_module.escape(text)
                escaped_term = html_module.escape(search_term)

                # Case-insensitive replacement with highlighting
                import re
                pattern = re.compile(re.escape(escaped_term), re.IGNORECASE)

                def replace_with_highlight(match):
                    return f'<span style="background-color: #FFFF00;">{match.group(0)}</span>'

                html_text = pattern.sub(replace_with_highlight, escaped_text)

                # Create QTextDocument with the highlighted HTML
                doc = QTextDocument()
                doc.setDefaultFont(option.font)
                doc.setTextWidth(text_rect.width())
                doc.setHtml(html_text)

                painter.save()
                painter.translate(text_rect.topLeft())

                # Clip to text rect
                painter.setClipRect(QRectF(0, 0, text_rect.width(), text_rect.height()))

                # Draw the document
                doc.drawContents(painter)

                painter.restore()
                return

        # Default painting for non-highlighted cells
        super().paint(painter, option, index)
    
    def createEditor(self, parent, option, index):
        """Create a QTextEdit for multi-line editing with word wrap"""
        # Target column (column 3) - always editable
        if index.column() == 3:
            editor = GridTextEditor(parent)
            editor.assistance_panel = self.assistance_panel
            editor.table_widget = self.table_widget
            editor.current_row = index.row()
            editor.setWordWrapMode(QTextOption.WrapMode.WordWrap)
            editor.setAcceptRichText(False)  # Plain text only
            editor.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
            editor.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
            
            # Ensure the row is tall enough for editing
            table = parent.parent()
            if hasattr(table, 'resizeRowToContents'):
                # Schedule row resize after editor is shown
                from PyQt6.QtCore import QTimer
                QTimer.singleShot(0, lambda: table.resizeRowToContents(index.row()))
            
            return editor
        
        # Source column (column 2) - editable for selection/dual selection, optionally editable for content
        elif index.column() == 2:
            editor = ReadOnlyGridTextEditor("", parent)
            editor.table_widget = self.table_widget
            editor.current_row = index.row()
            editor.allow_source_edit = self.allow_source_edit
            
            # If allow_source_edit is True, make it actually editable (with warning color)
            if self.allow_source_edit:
                editor.setReadOnly(False)
                editor.setStyleSheet("""
                    QTextEdit {
                        border: none;
                        background-color: #FFF9E6;
                        padding: 0px;
                        color: black;
                    }
                    QTextEdit:focus {
                        border: 1px solid #FF9800;
                        background-color: #FFFACD;
                        color: black;
                    }
                    QTextEdit::selection {
                        background-color: #D0E7FF;
                        color: black;
                    }
                """)
            
            # Ensure the row is tall enough for editing
            table = parent.parent()
            if hasattr(table, 'resizeRowToContents'):
                from PyQt6.QtCore import QTimer
                QTimer.singleShot(0, lambda: table.resizeRowToContents(index.row()))
            
            return editor
        else:
            return super().createEditor(parent, option, index)
    
    def setEditorData(self, editor, index):
        """Load data into the editor"""
        if isinstance(editor, (QTextEdit, ReadOnlyGridTextEditor)):
            text = index.model().data(index, Qt.ItemDataRole.EditRole)
            editor.setPlainText(text or "")
            # Ensure cursor is at start
            cursor = editor.textCursor()
            cursor.movePosition(cursor.MoveOperation.Start)
            editor.setTextCursor(cursor)
        else:
            super().setEditorData(editor, index)
    
    def setModelData(self, editor, model, index):
        """Save data from editor back to model"""
        if isinstance(editor, ReadOnlyGridTextEditor):
            # Only save if editing is allowed
            if editor.allow_source_edit:
                text = editor.toPlainText()
                model.setData(index, text, Qt.ItemDataRole.EditRole)
            # Otherwise, just close without saving (was for selection only)
        elif isinstance(editor, QTextEdit):
            text = editor.toPlainText()
            model.setData(index, text, Qt.ItemDataRole.EditRole)
        else:
            super().setModelData(editor, model, index)
    
    def updateEditorGeometry(self, editor, option, index):
        """Set the editor geometry to match the cell size"""
        if isinstance(editor, (QTextEdit, ReadOnlyGridTextEditor)):
            # Make the editor fill the cell properly with some padding
            rect = option.rect
            editor.setGeometry(rect)
        else:
            super().updateEditorGeometry(editor, option, index)


# ============================================================================
# THEME EDITOR DIALOG
# ============================================================================

class ThemeEditorDialog(QDialog):
    """Dialog for editing and managing themes"""
    
    def __init__(self, parent, theme_manager):
        super().__init__(parent)
        self.theme_manager = theme_manager
        self.setWindowTitle("Theme Editor")
        self.setModal(True)
        self.resize(700, 600)
        
        self.setup_ui()
        self.load_themes()
    
    def setup_ui(self):
        """Create the UI"""
        layout = QVBoxLayout(self)
        
        # Theme selection
        theme_group = QGroupBox("Select Theme")
        theme_layout = QHBoxLayout()
        
        self.theme_combo = QComboBox()
        self.theme_combo.currentTextChanged.connect(self.on_theme_selected)
        theme_layout.addWidget(QLabel("Theme:"))
        theme_layout.addWidget(self.theme_combo, 1)
        
        self.apply_btn = QPushButton("‚úì Apply")
        self.apply_btn.clicked.connect(self.apply_theme)
        theme_layout.addWidget(self.apply_btn)
        
        theme_group.setLayout(theme_layout)
        layout.addWidget(theme_group)
        
        # Color customization
        colors_group = QGroupBox("Customize Colors")
        colors_layout = QGridLayout()
        
        # Create color pickers for main colors
        self.color_buttons = {}
        color_configs = [
            ("window_bg", "Window Background", 0, 0),
            ("base", "Input Fields", 0, 1),
            ("button", "Buttons", 0, 2),
            ("text", "Text", 1, 0),
            ("highlight", "Highlight", 1, 1),
            ("border", "Borders", 1, 2),
            ("grid_header", "Table Headers", 2, 0),
            ("alternate_bg", "Alternate Rows", 2, 1),
            ("tm_exact", "100% TM Match", 3, 0),
            ("tm_high", "95-99% TM Match", 3, 1),
        ]
        
        for attr, label, row, col in color_configs:
            lbl = QLabel(label + ":")
            btn = QPushButton()
            btn.setMinimumHeight(30)
            btn.setProperty("color_attr", attr)
            btn.clicked.connect(lambda checked, a=attr: self.pick_color(a))
            self.color_buttons[attr] = btn
            
            colors_layout.addWidget(lbl, row * 2, col)
            colors_layout.addWidget(btn, row * 2 + 1, col)
        
        colors_group.setLayout(colors_layout)
        layout.addWidget(colors_group)
        
        # Custom theme actions
        custom_group = QGroupBox("Custom Themes")
        custom_layout = QHBoxLayout()
        
        save_btn = QPushButton("üíæ Save as Custom Theme")
        save_btn.clicked.connect(self.save_custom_theme)
        custom_layout.addWidget(save_btn)
        
        delete_btn = QPushButton("üóëÔ∏è Delete Custom Theme")
        delete_btn.clicked.connect(self.delete_custom_theme)
        custom_layout.addWidget(delete_btn)
        
        custom_group.setLayout(custom_layout)
        layout.addWidget(custom_group)
        
        # Dialog buttons
        button_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok | 
            QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def load_themes(self):
        """Load available themes into combo box"""
        self.theme_combo.clear()
        themes = self.theme_manager.get_all_themes()
        for theme_name in themes.keys():
            self.theme_combo.addItem(theme_name)
        
        # Select current theme
        current_idx = self.theme_combo.findText(self.theme_manager.current_theme.name)
        if current_idx >= 0:
            self.theme_combo.setCurrentIndex(current_idx)
    
    def on_theme_selected(self, theme_name):
        """When theme is selected from combo box"""
        if not theme_name:
            return
        
        theme = self.theme_manager.get_theme(theme_name)
        if theme:
            self.update_color_buttons(theme)
    
    def update_color_buttons(self, theme):
        """Update color button backgrounds"""
        for attr, btn in self.color_buttons.items():
            color = getattr(theme, attr, "#FFFFFF")
            btn.setStyleSheet(f"background-color: {color}; border: 1px solid #999;")
            btn.setText(color)
    
    def pick_color(self, attr):
        """Open color picker for an attribute"""
        from PyQt6.QtWidgets import QColorDialog
        
        theme_name = self.theme_combo.currentText()
        theme = self.theme_manager.get_theme(theme_name)
        
        if not theme:
            return
        
        current_color = QColor(getattr(theme, attr))
        color = QColorDialog.getColor(current_color, self, f"Pick {attr}")
        
        if color.isValid():
            # Update button
            hex_color = color.name()
            self.color_buttons[attr].setStyleSheet(
                f"background-color: {hex_color}; border: 1px solid #999;"
            )
            self.color_buttons[attr].setText(hex_color)
            
            # Update theme
            setattr(theme, attr, hex_color)
    
    def apply_theme(self):
        """Apply the selected theme"""
        theme_name = self.theme_combo.currentText()
        if self.theme_manager.set_theme(theme_name):
            self.theme_manager.apply_theme(QApplication.instance())

            # Call the main app's refresh method to update all UI elements
            if hasattr(self.parent(), 'refresh_theme_colors'):
                self.parent().refresh_theme_colors()

            QMessageBox.information(self, "Theme Applied",
                                   f"Theme '{theme_name}' has been applied.")
    
    def save_custom_theme(self):
        """Save current settings as a custom theme"""
        from PyQt6.QtWidgets import QInputDialog
        
        name, ok = QInputDialog.getText(self, "Save Theme", "Enter theme name:")
        if ok and name:
            # Create new theme from current settings
            theme_name = self.theme_combo.currentText()
            base_theme = self.theme_manager.get_theme(theme_name)
            
            if base_theme:
                # Create copy with new name
                from modules.theme_manager import Theme
                new_theme = Theme(
                    name=name,
                    **{k: v for k, v in base_theme.to_dict().items() if k != 'name'}
                )
                
                # Update with any modified colors
                for attr, btn in self.color_buttons.items():
                    color = btn.text()
                    if color.startswith('#'):
                        setattr(new_theme, attr, color)
                
                self.theme_manager.save_custom_theme(new_theme)
                self.load_themes()
                
                # Select the new theme
                idx = self.theme_combo.findText(name)
                if idx >= 0:
                    self.theme_combo.setCurrentIndex(idx)
                
                QMessageBox.information(self, "Theme Saved", 
                                       f"Custom theme '{name}' has been saved.")
    
    def delete_custom_theme(self):
        """Delete the selected custom theme"""
        theme_name = self.theme_combo.currentText()
        
        # Can't delete predefined themes
        from modules.theme_manager import ThemeManager
        if theme_name in ThemeManager.PREDEFINED_THEMES:
            QMessageBox.warning(self, "Cannot Delete", 
                               "Cannot delete predefined themes.")
            return
        
        reply = QMessageBox.question(self, "Delete Theme",
                                    f"Delete custom theme '{theme_name}'?",
                                    QMessageBox.StandardButton.Yes | 
                                    QMessageBox.StandardButton.No)
        
        if reply == QMessageBox.StandardButton.Yes:
            if self.theme_manager.delete_custom_theme(theme_name):
                self.load_themes()
                QMessageBox.information(self, "Theme Deleted", 
                                       f"Theme '{theme_name}' has been deleted.")


# ============================================================================
# DETACHED LOG WINDOW
# ============================================================================

class DetachedLogWindow(QWidget):
    """Detached log window that can be moved to another screen"""

    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.setWindowTitle("Supervertaler - Session Log")
        self.setWindowIcon(self.parent.windowIcon())
        self.resize(800, 600)

        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)

        # Top toolbar
        toolbar = QWidget()
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 0)

        # Info label
        info_label = QLabel("üìã This is a detached log window. It will update in real-time.")
        info_label.setStyleSheet("color: #666; font-style: italic;")
        toolbar_layout.addWidget(info_label)

        toolbar_layout.addStretch()

        # Re-attach button
        reattach_btn = QPushButton("‚Ü©Ô∏è Close")
        reattach_btn.setToolTip("Close this detached window")
        reattach_btn.clicked.connect(self.close)
        toolbar_layout.addWidget(reattach_btn)

        layout.addWidget(toolbar)

        # Log display
        self.log_display = QPlainTextEdit()
        self.log_display.setReadOnly(True)
        self.log_display.setStyleSheet("""
            QPlainTextEdit {
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 10px;
                border: 1px solid #ccc;
            }
        """)
        layout.addWidget(self.log_display)

        # Copy existing log content
        if hasattr(parent, 'session_log') and parent.session_log:
            self.log_display.setPlainText(parent.session_log.toPlainText())
            # Scroll to bottom
            scrollbar = self.log_display.verticalScrollBar()
            if scrollbar:
                scrollbar.setValue(scrollbar.maximum())

    def closeEvent(self, event):
        """Handle window close"""
        # Remove from parent's list
        try:
            if self in self.parent.detached_log_windows:
                self.parent.detached_log_windows.remove(self)
        except:
            pass
        event.accept()


# ============================================================================
# TERM METADATA DIALOG
# ============================================================================

class TermMetadataDialog(QDialog):
    """Dialog for adding/editing term metadata before saving to termbase"""
    
    def __init__(self, source_term: str, target_term: str, active_termbases: list, parent=None, user_data_path=None):
        super().__init__(parent)
        self.source_term = source_term
        self.target_term = target_term
        self.active_termbases = active_termbases
        self.termbase_checkboxes = {}  # Store checkbox references
        self.user_data_path = user_data_path
        self.saved_selections = self._load_termbase_selections()
        self.setup_ui()
    
    def _load_termbase_selections(self):
        """Load saved termbase selections from preferences"""
        if not self.user_data_path:
            return None
        
        prefs_file = self.user_data_path / "ui_preferences.json"
        if not prefs_file.exists():
            return None
        
        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                return prefs.get('add_term_termbase_selections', None)
        except:
            return None
    
    def _save_termbase_selections(self):
        """Save current termbase selections to preferences"""
        if not self.user_data_path:
            return
        
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        # Load existing preferences
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        # Save the selected termbase IDs
        selected_ids = [tb_id for tb_id, cb in self.termbase_checkboxes.items() if cb.isChecked()]
        prefs['add_term_termbase_selections'] = selected_ids
        
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except:
            pass
        
    def setup_ui(self):
        self.setWindowTitle("Add Term to Glossary")
        self.setMinimumWidth(550)

        # Auto-resize to fit screen (max 85% of screen height)
        screen = QApplication.primaryScreen().availableGeometry()
        max_height = int(screen.height() * 0.85)
        self.setMaximumHeight(max_height)

        # Start with very compact size for laptops
        self.resize(600, min(550, max_height))

        # Create main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)

        # Create scroll area for all content
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.Shape.NoFrame)

        content_widget = QWidget()
        layout = QVBoxLayout(content_widget)
        layout.setSpacing(4)
        layout.setContentsMargins(6, 6, 6, 6)
        
        # Header
        header = QLabel("Add term pair to glossary")
        header.setStyleSheet("font-size: 12px; font-weight: bold; margin-bottom: 5px; padding: 4px;")
        layout.addWidget(header)
        
        # Term pair display (read-only)
        term_group = QGroupBox("Term Pair")
        term_layout = QFormLayout()
        
        source_label = QLabel(self.source_term)
        source_label.setStyleSheet("padding: 5px; border-radius: 3px;")
        source_label.setWordWrap(True)
        term_layout.addRow("Source:", source_label)
        
        target_label = QLabel(self.target_term)
        target_label.setStyleSheet("padding: 5px; border-radius: 3px;")
        target_label.setWordWrap(True)
        term_layout.addRow("Target:", target_label)
        
        term_group.setLayout(term_layout)
        layout.addWidget(term_group)
        
        # Termbase selection
        tb_group = QGroupBox("Save to Glossary(s)")
        tb_layout = QVBoxLayout()
        
        if not self.active_termbases:
            no_tb_label = QLabel("‚ö†Ô∏è No active glossaries found. Please activate at least one glossary first.")
            no_tb_label.setStyleSheet("color: #d32f2f; padding: 10px;")
            no_tb_label.setWordWrap(True)
            tb_layout.addWidget(no_tb_label)
        else:
            # Header with select all/none buttons
            header_layout = QHBoxLayout()
            select_all_btn = QPushButton("Select All")
            select_all_btn.setMaximumWidth(100)
            select_none_btn = QPushButton("Select None")
            select_none_btn.setMaximumWidth(100)
            
            def select_all():
                for cb in self.termbase_checkboxes.values():
                    cb.setChecked(True)
            
            def select_none():
                for cb in self.termbase_checkboxes.values():
                    cb.setChecked(False)
            
            select_all_btn.clicked.connect(select_all)
            select_none_btn.clicked.connect(select_none)
            
            header_layout.addWidget(select_all_btn)
            header_layout.addWidget(select_none_btn)
            header_layout.addStretch()
            tb_layout.addLayout(header_layout)
            
            # Checkboxes for each active termbase
            for tb in self.active_termbases:
                is_project_tb = tb.get('is_project_termbase', False)
                
                # Use pink checkbox for project termbase, green for others
                if is_project_tb:
                    cb = PinkCheckmarkCheckBox(f"üìå {tb['name']} (Project)")
                else:
                    cb = CheckmarkCheckBox(tb['name'])
                
                # Use saved selection if available, otherwise default to all selected
                if self.saved_selections is not None:
                    cb.setChecked(tb['id'] in self.saved_selections)
                else:
                    cb.setChecked(True)  # Default: all selected
                cb.setToolTip(f"Languages: {tb.get('source_lang', '?')} ‚Üí {tb.get('target_lang', '?')}")
                
                self.termbase_checkboxes[tb['id']] = cb
                tb_layout.addWidget(cb)
        
        tb_group.setLayout(tb_layout)
        layout.addWidget(tb_group)
        
        # Metadata fields
        meta_group = QGroupBox("Metadata (Optional)")
        meta_layout = QFormLayout()
        
        # Domain
        self.domain_edit = QLineEdit()
        self.domain_edit.setPlaceholderText("e.g., Patents, Legal, Medical, IT...")
        meta_layout.addRow("Domain:", self.domain_edit)
        
        # Notes
        self.notes_edit = QTextEdit()
        self.notes_edit.setMaximumHeight(45)
        self.notes_edit.setPlaceholderText("Usage notes, context, definition, URLs...")
        self.notes_edit.setStyleSheet("padding: 3px; font-size: 10px;")
        meta_layout.addRow("Notes:", self.notes_edit)
        
        # Project
        self.project_edit = QLineEdit()
        self.project_edit.setPlaceholderText("Optional project name...")
        meta_layout.addRow("Project:", self.project_edit)
        
        # Client
        self.client_edit = QLineEdit()
        self.client_edit.setPlaceholderText("Optional client name...")
        meta_layout.addRow("Client:", self.client_edit)
        
        # Forbidden term checkbox
        self.forbidden_check = CheckmarkCheckBox("Mark as forbidden term")
        self.forbidden_check.setToolTip("Forbidden terms trigger warnings when used")
        meta_layout.addRow("", self.forbidden_check)
        
        meta_group.setLayout(meta_layout)
        layout.addWidget(meta_group)
        
        # Source Synonyms section (collapsible)
        source_syn_group = QGroupBox()
        source_syn_main_layout = QVBoxLayout()

        # Header with collapse button
        source_syn_header = QHBoxLayout()
        self.source_syn_toggle = QToolButton()
        self.source_syn_toggle.setText("‚ñº")
        self.source_syn_toggle.setStyleSheet("QToolButton { border: none; font-weight: bold; }")
        self.source_syn_toggle.setFixedSize(20, 20)
        self.source_syn_toggle.setCheckable(True)
        self.source_syn_toggle.setChecked(False)
        source_syn_header.addWidget(self.source_syn_toggle)

        source_syn_label = QLabel("Source Synonyms (Optional)")
        source_syn_label.setStyleSheet("font-weight: bold;")
        source_syn_header.addWidget(source_syn_label)
        source_syn_header.addStretch()
        source_syn_main_layout.addLayout(source_syn_header)

        # Collapsible content
        self.source_syn_content = QWidget()
        source_syn_layout = QVBoxLayout(self.source_syn_content)
        source_syn_layout.setContentsMargins(0, 0, 0, 0)
        self.source_syn_content.setVisible(False)

        # Instructions
        source_syn_info = QLabel("Add alternative source terms. First item = preferred term:")
        source_syn_info.setStyleSheet("color: #666; font-size: 10px;")
        source_syn_layout.addWidget(source_syn_info)
        
        # Input field + Add button + Forbidden checkbox
        source_add_layout = QHBoxLayout()
        self.source_synonym_edit = QLineEdit()
        self.source_synonym_edit.setPlaceholderText("Enter source synonym and press Add or Enter...")
        source_add_layout.addWidget(self.source_synonym_edit)
        
        self.source_synonym_forbidden_check = CheckmarkCheckBox("Forbidden")
        self.source_synonym_forbidden_check.setToolTip("Mark this source synonym as forbidden")
        source_add_layout.addWidget(self.source_synonym_forbidden_check)
        
        source_add_syn_btn = QPushButton("Add")
        source_add_syn_btn.setMaximumWidth(60)
        source_add_syn_btn.clicked.connect(self.add_source_synonym)
        source_add_layout.addWidget(source_add_syn_btn)
        source_syn_layout.addLayout(source_add_layout)
        
        # Connect Enter key to add synonym
        self.source_synonym_edit.returnPressed.connect(self.add_source_synonym)
        
        # List of source synonyms with control buttons
        source_list_layout = QHBoxLayout()
        
        self.source_synonym_list = QListWidget()
        self.source_synonym_list.setMaximumHeight(100)
        self.source_synonym_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.source_synonym_list.customContextMenuRequested.connect(self.show_source_synonym_context_menu)
        source_list_layout.addWidget(self.source_synonym_list)
        
        # Up/Down buttons for source synonyms
        source_button_col = QVBoxLayout()
        source_move_up_btn = QPushButton("‚ñ≤")
        source_move_up_btn.setToolTip("Move synonym up (higher priority)")
        source_move_up_btn.setMaximumWidth(30)
        source_move_up_btn.clicked.connect(self.move_source_synonym_up)
        source_button_col.addWidget(source_move_up_btn)
        
        source_move_down_btn = QPushButton("‚ñº")
        source_move_down_btn.setToolTip("Move synonym down (lower priority)")
        source_move_down_btn.setMaximumWidth(30)
        source_move_down_btn.clicked.connect(self.move_source_synonym_down)
        source_button_col.addWidget(source_move_down_btn)
        
        source_button_col.addStretch()
        
        source_delete_btn = QPushButton("‚úó")
        source_delete_btn.setToolTip("Delete synonym")
        source_delete_btn.setMaximumWidth(30)
        source_delete_btn.clicked.connect(self.delete_selected_source_synonym)
        source_button_col.addWidget(source_delete_btn)
        
        source_list_layout.addLayout(source_button_col)
        source_syn_layout.addLayout(source_list_layout)

        # Add collapsible content to main layout
        source_syn_main_layout.addWidget(self.source_syn_content)
        source_syn_group.setLayout(source_syn_main_layout)

        # Connect toggle button
        self.source_syn_toggle.clicked.connect(lambda: self.toggle_section(self.source_syn_toggle, self.source_syn_content))

        layout.addWidget(source_syn_group)
        
        # Target Synonyms section (collapsible)
        target_syn_group = QGroupBox()
        target_syn_main_layout = QVBoxLayout()

        # Header with collapse button
        target_syn_header = QHBoxLayout()
        self.target_syn_toggle = QToolButton()
        self.target_syn_toggle.setText("‚ñº")
        self.target_syn_toggle.setStyleSheet("QToolButton { border: none; font-weight: bold; }")
        self.target_syn_toggle.setFixedSize(20, 20)
        self.target_syn_toggle.setCheckable(True)
        self.target_syn_toggle.setChecked(False)
        target_syn_header.addWidget(self.target_syn_toggle)

        target_syn_label = QLabel("Target Synonyms (Optional)")
        target_syn_label.setStyleSheet("font-weight: bold;")
        target_syn_header.addWidget(target_syn_label)
        target_syn_header.addStretch()
        target_syn_main_layout.addLayout(target_syn_header)

        # Collapsible content
        self.target_syn_content = QWidget()
        target_syn_layout = QVBoxLayout(self.target_syn_content)
        target_syn_layout.setContentsMargins(0, 0, 0, 0)
        self.target_syn_content.setVisible(False)

        # Instructions
        target_syn_info = QLabel("Add alternative translations (synonyms). First item = preferred term:")
        target_syn_info.setStyleSheet("color: #666; font-size: 10px;")
        target_syn_layout.addWidget(target_syn_info)
        
        # Input field + Add button + Forbidden checkbox
        target_add_layout = QHBoxLayout()
        self.target_synonym_edit = QLineEdit()
        self.target_synonym_edit.setPlaceholderText("Enter synonym and press Add or Enter...")
        target_add_layout.addWidget(self.target_synonym_edit)
        
        self.target_synonym_forbidden_check = CheckmarkCheckBox("Forbidden")
        self.target_synonym_forbidden_check.setToolTip("Mark this synonym as forbidden (warning when used)")
        target_add_layout.addWidget(self.target_synonym_forbidden_check)
        
        target_add_syn_btn = QPushButton("Add")
        target_add_syn_btn.setMaximumWidth(60)
        target_add_syn_btn.clicked.connect(self.add_target_synonym)
        target_add_layout.addWidget(target_add_syn_btn)
        target_syn_layout.addLayout(target_add_layout)
        
        # Connect Enter key to add synonym
        self.target_synonym_edit.returnPressed.connect(self.add_target_synonym)
        
        # List of target synonyms with control buttons
        target_list_layout = QHBoxLayout()
        
        self.target_synonym_list = QListWidget()
        self.target_synonym_list.setMaximumHeight(100)
        self.target_synonym_list.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.target_synonym_list.customContextMenuRequested.connect(self.show_target_synonym_context_menu)
        target_list_layout.addWidget(self.target_synonym_list)
        
        # Up/Down buttons for target synonyms
        target_button_col = QVBoxLayout()
        target_move_up_btn = QPushButton("‚ñ≤")
        target_move_up_btn.setToolTip("Move synonym up (higher priority)")
        target_move_up_btn.setMaximumWidth(30)
        target_move_up_btn.clicked.connect(self.move_target_synonym_up)
        target_button_col.addWidget(target_move_up_btn)
        
        target_move_down_btn = QPushButton("‚ñº")
        target_move_down_btn.setToolTip("Move synonym down (lower priority)")
        target_move_down_btn.setMaximumWidth(30)
        target_move_down_btn.clicked.connect(self.move_target_synonym_down)
        target_button_col.addWidget(target_move_down_btn)
        
        target_button_col.addStretch()
        
        target_delete_btn = QPushButton("‚úó")
        target_delete_btn.setToolTip("Delete synonym")
        target_delete_btn.setMaximumWidth(30)
        target_delete_btn.clicked.connect(self.delete_selected_target_synonym)
        target_button_col.addWidget(target_delete_btn)
        
        target_list_layout.addLayout(target_button_col)
        target_syn_layout.addLayout(target_list_layout)

        # Add collapsible content to main layout
        target_syn_main_layout.addWidget(self.target_syn_content)
        target_syn_group.setLayout(target_syn_main_layout)

        # Connect toggle button
        self.target_syn_toggle.clicked.connect(lambda: self.toggle_section(self.target_syn_toggle, self.target_syn_content))

        layout.addWidget(target_syn_group)

        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("Add to Glossary")
        save_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 5px 15px; border: none; outline: none;")
        save_btn.clicked.connect(self._accept_and_save)
        save_btn.setDefault(True)
        button_layout.addWidget(save_btn)

        layout.addLayout(button_layout)

        # Set the scroll area content
        scroll.setWidget(content_widget)
        main_layout.addWidget(scroll)

    def toggle_section(self, toggle_btn, content_widget):
        """Toggle visibility of a collapsible section"""
        is_visible = content_widget.isVisible()
        content_widget.setVisible(not is_visible)
        toggle_btn.setText("‚ñº" if is_visible else "‚ñ≤")

    # ========================================================================
    # SOURCE SYNONYM METHODS
    # ========================================================================
    
    def add_source_synonym(self):
        """Add a source synonym to the list"""
        synonym = self.source_synonym_edit.text().strip()
        if synonym:
            # Check for duplicates
            for i in range(self.source_synonym_list.count()):
                item = self.source_synonym_list.item(i)
                item_text = item.data(Qt.ItemDataRole.UserRole).get('text', '')
                if item_text == synonym:
                    QMessageBox.warning(self, "Duplicate", f"Source synonym '{synonym}' already added.")
                    return
            
            # Don't allow the main source term as a synonym
            if synonym.lower() == self.source_term.lower():
                QMessageBox.warning(self, "Invalid Synonym", "Cannot add the main source term as a synonym.")
                return
            
            # Create list item with stored data
            is_forbidden = self.source_synonym_forbidden_check.isChecked()
            display_text = f"{'üö´ ' if is_forbidden else ''}{synonym}"
            
            item = QListWidgetItem(display_text)
            item.setData(Qt.ItemDataRole.UserRole, {
                'text': synonym,
                'forbidden': is_forbidden
            })
            
            if is_forbidden:
                item.setForeground(QColor('#d32f2f'))
            
            self.source_synonym_list.addItem(item)
            self.source_synonym_edit.clear()
            self.source_synonym_forbidden_check.setChecked(False)
            self.source_synonym_edit.setFocus()
    
    def move_source_synonym_up(self):
        """Move selected source synonym up in the list"""
        current_row = self.source_synonym_list.currentRow()
        if current_row > 0:
            item = self.source_synonym_list.takeItem(current_row)
            self.source_synonym_list.insertItem(current_row - 1, item)
            self.source_synonym_list.setCurrentRow(current_row - 1)
    
    def move_source_synonym_down(self):
        """Move selected source synonym down in the list"""
        current_row = self.source_synonym_list.currentRow()
        if current_row < self.source_synonym_list.count() - 1 and current_row >= 0:
            item = self.source_synonym_list.takeItem(current_row)
            self.source_synonym_list.insertItem(current_row + 1, item)
            self.source_synonym_list.setCurrentRow(current_row + 1)
    
    def delete_selected_source_synonym(self):
        """Delete selected source synonym"""
        current_row = self.source_synonym_list.currentRow()
        if current_row >= 0:
            self.source_synonym_list.takeItem(current_row)
    
    def show_source_synonym_context_menu(self, position):
        """Show context menu for source synonym list"""
        if self.source_synonym_list.count() == 0:
            return
        
        current_item = self.source_synonym_list.currentItem()
        if not current_item:
            return
        
        menu = QMenu()
        
        # Toggle forbidden status
        data = current_item.data(Qt.ItemDataRole.UserRole)
        is_forbidden = data.get('forbidden', False)
        
        if is_forbidden:
            toggle_action = menu.addAction("Mark as Allowed")
        else:
            toggle_action = menu.addAction("Mark as Forbidden")
        
        menu.addSeparator()
        delete_action = menu.addAction("Delete")
        
        action = menu.exec(self.source_synonym_list.mapToGlobal(position))
        
        if action == toggle_action:
            # Toggle forbidden status
            data['forbidden'] = not is_forbidden
            text = data['text']
            display_text = f"{'üö´ ' if data['forbidden'] else ''}{text}"
            current_item.setText(display_text)
            current_item.setData(Qt.ItemDataRole.UserRole, data)
            
            if data['forbidden']:
                current_item.setForeground(QColor('#d32f2f'))
            else:
                current_item.setForeground(QColor('#000000'))
                
        elif action == delete_action:
            self.source_synonym_list.takeItem(self.source_synonym_list.row(current_item))
    
    def get_source_synonyms(self):
        """Return list of source synonym dictionaries with text, forbidden flag, and order"""
        synonyms = []
        for i in range(self.source_synonym_list.count()):
            item = self.source_synonym_list.item(i)
            data = item.data(Qt.ItemDataRole.UserRole)
            synonyms.append({
                'text': data['text'],
                'forbidden': data['forbidden'],
                'order': i
            })
        return synonyms
    
    # ========================================================================
    # TARGET SYNONYM METHODS
    # ========================================================================
    
    def add_target_synonym(self):
        """Add a target synonym to the list"""
        synonym = self.target_synonym_edit.text().strip()
        if synonym:
            # Check for duplicates
            for i in range(self.target_synonym_list.count()):
                item = self.target_synonym_list.item(i)
                item_text = item.data(Qt.ItemDataRole.UserRole).get('text', '')
                if item_text == synonym:
                    QMessageBox.warning(self, "Duplicate", f"Synonym '{synonym}' already added.")
                    return
            
            # Don't allow the main target term as a synonym
            if synonym.lower() == self.target_term.lower():
                QMessageBox.warning(self, "Invalid Synonym", "Cannot add the main target term as a synonym.")
                return
            
            # Create list item with stored data
            is_forbidden = self.target_synonym_forbidden_check.isChecked()
            display_text = f"{'üö´ ' if is_forbidden else ''}{synonym}"
            
            item = QListWidgetItem(display_text)
            item.setData(Qt.ItemDataRole.UserRole, {
                'text': synonym,
                'forbidden': is_forbidden
            })
            
            if is_forbidden:
                item.setForeground(QColor('#d32f2f'))
            
            self.target_synonym_list.addItem(item)
            self.target_synonym_edit.clear()
            self.target_synonym_forbidden_check.setChecked(False)
            self.target_synonym_edit.setFocus()
    
    def move_target_synonym_up(self):
        """Move selected target synonym up in the list"""
        current_row = self.target_synonym_list.currentRow()
        if current_row > 0:
            item = self.target_synonym_list.takeItem(current_row)
            self.target_synonym_list.insertItem(current_row - 1, item)
            self.target_synonym_list.setCurrentRow(current_row - 1)
    
    def move_target_synonym_down(self):
        """Move selected target synonym down in the list"""
        current_row = self.target_synonym_list.currentRow()
        if current_row < self.target_synonym_list.count() - 1 and current_row >= 0:
            item = self.target_synonym_list.takeItem(current_row)
            self.target_synonym_list.insertItem(current_row + 1, item)
            self.target_synonym_list.setCurrentRow(current_row + 1)
    
    def delete_selected_target_synonym(self):
        """Delete selected target synonym"""
        current_row = self.target_synonym_list.currentRow()
        if current_row >= 0:
            self.target_synonym_list.takeItem(current_row)
    
    def show_target_synonym_context_menu(self, position):
        """Show context menu for target synonym list"""
        if self.target_synonym_list.count() == 0:
            return
        
        current_item = self.target_synonym_list.currentItem()
        if not current_item:
            return
        
        menu = QMenu()
        
        # Toggle forbidden status
        data = current_item.data(Qt.ItemDataRole.UserRole)
        is_forbidden = data.get('forbidden', False)
        
        if is_forbidden:
            toggle_action = menu.addAction("Mark as Allowed")
        else:
            toggle_action = menu.addAction("Mark as Forbidden")
        
        menu.addSeparator()
        delete_action = menu.addAction("Delete")
        
        action = menu.exec(self.target_synonym_list.mapToGlobal(position))
        
        if action == toggle_action:
            # Toggle forbidden status
            data['forbidden'] = not is_forbidden
            text = data['text']
            display_text = f"{'üö´ ' if data['forbidden'] else ''}{text}"
            current_item.setText(display_text)
            current_item.setData(Qt.ItemDataRole.UserRole, data)
            
            if data['forbidden']:
                current_item.setForeground(QColor('#d32f2f'))
            else:
                current_item.setForeground(QColor('#000000'))
                
        elif action == delete_action:
            self.target_synonym_list.takeItem(self.target_synonym_list.row(current_item))
    
    def get_target_synonyms(self):
        """Return list of target synonym dictionaries with text, forbidden flag, and order"""
        synonyms = []
        for i in range(self.target_synonym_list.count()):
            item = self.target_synonym_list.item(i)
            data = item.data(Qt.ItemDataRole.UserRole)
            synonyms.append({
                'text': data['text'],
                'forbidden': data['forbidden'],
                'order': i
            })
        return synonyms
    
    def get_metadata(self):
        """Return dictionary of metadata fields"""
        return {
            'domain': self.domain_edit.text().strip(),
            'notes': self.notes_edit.toPlainText().strip(),
            'project': self.project_edit.text().strip(),
            'client': self.client_edit.text().strip(),
            'forbidden': self.forbidden_check.isChecked()
        }
    
    def get_selected_termbases(self):
        """Return list of selected termbase IDs"""
        return [tb_id for tb_id, cb in self.termbase_checkboxes.items() if cb.isChecked()]
    
    def _accept_and_save(self):
        """Save termbase selections and accept the dialog"""
        self._save_termbase_selections()
        self.accept()


class VoiceCommandEditDialog(QDialog):
    """Dialog for adding/editing voice commands"""
    
    CATEGORIES = ["navigation", "editing", "translation", "lookup", "file", "view", "dictation", "memoq", "trados", "custom"]
    ACTION_TYPES = [
        ("internal", "Internal Action (Supervertaler)"),
        ("keystroke", "Keystroke (e.g., ctrl+s)"),
        ("ahk_inline", "AutoHotkey Code"),
        ("ahk_script", "AutoHotkey Script File"),
    ]
    
    def __init__(self, parent=None, command: VoiceCommand = None):
        super().__init__(parent)
        self.command = command
        self.setup_ui()
        
        if command:
            self.populate_from_command(command)
    
    def setup_ui(self):
        self.setWindowTitle("Edit Voice Command" if self.command else "Add Voice Command")
        self.setMinimumWidth(500)
        
        layout = QVBoxLayout(self)
        
        # Phrase
        phrase_layout = QHBoxLayout()
        phrase_layout.addWidget(QLabel("Phrase:"))
        self.phrase_edit = QLineEdit()
        self.phrase_edit.setPlaceholderText("e.g., confirm segment")
        phrase_layout.addWidget(self.phrase_edit)
        layout.addLayout(phrase_layout)
        
        # Aliases
        aliases_layout = QHBoxLayout()
        aliases_layout.addWidget(QLabel("Aliases:"))
        self.aliases_edit = QLineEdit()
        self.aliases_edit.setPlaceholderText("e.g., confirm, done, okay (comma-separated)")
        aliases_layout.addWidget(self.aliases_edit)
        layout.addLayout(aliases_layout)
        
        # Action Type
        type_layout = QHBoxLayout()
        type_layout.addWidget(QLabel("Type:"))
        self.type_combo = QComboBox()
        for value, label in self.ACTION_TYPES:
            self.type_combo.addItem(label, value)
        self.type_combo.currentIndexChanged.connect(self._on_type_changed)
        type_layout.addWidget(self.type_combo)
        layout.addLayout(type_layout)
        
        # Action
        action_layout = QVBoxLayout()
        action_label = QLabel("Action:")
        action_layout.addWidget(action_label)
        self.action_edit = QTextEdit()
        self.action_edit.setMaximumHeight(100)
        self.action_edit.setPlaceholderText("For internal: action_name\nFor keystroke: ctrl+s\nFor AHK: Send, ^s")
        action_layout.addWidget(self.action_edit)
        layout.addLayout(action_layout)
        
        # Internal actions dropdown (for internal type)
        self.internal_actions_layout = QHBoxLayout()
        self.internal_actions_layout.addWidget(QLabel("Preset:"))
        self.internal_combo = QComboBox()
        self.internal_combo.addItems([
            "navigate_next", "navigate_previous", "navigate_first", "navigate_last",
            "confirm_segment", "copy_source_to_target", "clear_target",
            "translate_segment", "batch_translate",
            "open_superlookup", "concordance_search",
            "show_log", "show_editor",
            "start_dictation", "stop_listening"
        ])
        self.internal_combo.currentTextChanged.connect(lambda t: self.action_edit.setPlainText(t))
        self.internal_actions_layout.addWidget(self.internal_combo)
        self.internal_actions_layout.addStretch()
        layout.addLayout(self.internal_actions_layout)
        
        # Description
        desc_layout = QHBoxLayout()
        desc_layout.addWidget(QLabel("Description:"))
        self.desc_edit = QLineEdit()
        self.desc_edit.setPlaceholderText("e.g., Confirm current segment")
        desc_layout.addWidget(self.desc_edit)
        layout.addLayout(desc_layout)
        
        # Category
        cat_layout = QHBoxLayout()
        cat_layout.addWidget(QLabel("Category:"))
        self.cat_combo = QComboBox()
        self.cat_combo.addItems(self.CATEGORIES)
        self.cat_combo.setEditable(True)
        cat_layout.addWidget(self.cat_combo)
        layout.addLayout(cat_layout)
        
        # Buttons
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        
        # Initial type setup
        self._on_type_changed()
    
    def _on_type_changed(self):
        """Show/hide internal actions dropdown based on type"""
        is_internal = self.type_combo.currentData() == "internal"
        for i in range(self.internal_actions_layout.count()):
            widget = self.internal_actions_layout.itemAt(i).widget()
            if widget:
                widget.setVisible(is_internal)
    
    def populate_from_command(self, cmd: VoiceCommand):
        """Populate dialog from existing command"""
        self.phrase_edit.setText(cmd.phrase)
        self.aliases_edit.setText(", ".join(cmd.aliases))
        
        # Find and set action type
        for i in range(self.type_combo.count()):
            if self.type_combo.itemData(i) == cmd.action_type:
                self.type_combo.setCurrentIndex(i)
                break
        
        self.action_edit.setPlainText(cmd.action)
        self.desc_edit.setText(cmd.description)
        
        # Set category
        idx = self.cat_combo.findText(cmd.category)
        if idx >= 0:
            self.cat_combo.setCurrentIndex(idx)
        else:
            self.cat_combo.setCurrentText(cmd.category)
    
    def get_command(self) -> VoiceCommand:
        """Get the command from dialog inputs"""
        aliases_text = self.aliases_edit.text().strip()
        aliases = [a.strip() for a in aliases_text.split(",") if a.strip()] if aliases_text else []
        
        return VoiceCommand(
            phrase=self.phrase_edit.text().strip(),
            aliases=aliases,
            action_type=self.type_combo.currentData(),
            action=self.action_edit.toPlainText().strip(),
            description=self.desc_edit.text().strip(),
            category=self.cat_combo.currentText().strip(),
            enabled=True
        )


class AdvancedFiltersDialog(QDialog):
    """Dialog for advanced filtering options"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
    
    def setup_ui(self):
        self.setWindowTitle("Advanced Filters")
        self.setMinimumWidth(600)
        self.setMinimumHeight(500)
        layout = QVBoxLayout(self)
        
        # Create scroll area for filters
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.NoFrame)
        
        content = QWidget()
        content_layout = QVBoxLayout(content)
        content_layout.setSpacing(15)
        
        # Match Rate Filter
        match_group = QGroupBox("Match Rate (%)")
        match_layout = QHBoxLayout()
        
        self.match_rate_check = CheckmarkCheckBox("Enable")
        match_layout.addWidget(self.match_rate_check)
        
        match_layout.addWidget(QLabel("From:"))
        self.match_min_spin = QSpinBox()
        self.match_min_spin.setRange(0, 100)
        self.match_min_spin.setValue(0)
        self.match_min_spin.setSuffix("%")
        match_layout.addWidget(self.match_min_spin)
        
        match_layout.addWidget(QLabel("To:"))
        self.match_max_spin = QSpinBox()
        self.match_max_spin.setRange(0, 100)
        self.match_max_spin.setValue(100)
        self.match_max_spin.setSuffix("%")
        match_layout.addWidget(self.match_max_spin)
        match_layout.addStretch()
        
        match_group.setLayout(match_layout)
        content_layout.addWidget(match_group)
        
        # Row Status Filter
        status_group = QGroupBox("Row Status")
        status_layout = QVBoxLayout()
        
        self.status_not_started = CheckmarkCheckBox("Not started")
        self.status_edited = CheckmarkCheckBox("Edited")
        self.status_pretranslated = CheckmarkCheckBox("Pre-translated")
        self.status_translated = CheckmarkCheckBox("Translated")
        self.status_confirmed = CheckmarkCheckBox("Confirmed")
        self.status_draft = CheckmarkCheckBox("Draft")

        status_layout.addWidget(self.status_not_started)
        status_layout.addWidget(self.status_edited)
        status_layout.addWidget(self.status_pretranslated)
        status_layout.addWidget(self.status_translated)
        status_layout.addWidget(self.status_confirmed)
        status_layout.addWidget(self.status_draft)
        
        status_group.setLayout(status_layout)
        content_layout.addWidget(status_group)
        
        # Locked/Unlocked Filter
        locked_group = QGroupBox("Locked Status")
        locked_layout = QVBoxLayout()
        
        self.locked_both = CheckmarkRadioButton("Both locked and unlocked rows")
        self.locked_only = CheckmarkRadioButton("Only locked rows")
        self.locked_unlocked_only = CheckmarkRadioButton("Only unlocked rows")
        self.locked_both.setChecked(True)
        
        locked_layout.addWidget(self.locked_both)
        locked_layout.addWidget(self.locked_only)
        locked_layout.addWidget(self.locked_unlocked_only)
        
        locked_group.setLayout(locked_layout)
        content_layout.addWidget(locked_group)
        
        # Other Properties
        other_group = QGroupBox("Other Properties")
        other_layout = QVBoxLayout()
        
        self.has_comments_check = CheckmarkCheckBox("Has comments/notes")
        self.has_proofreading_check = CheckmarkCheckBox("Has proofreading issues")
        self.repetitions_check = CheckmarkCheckBox("Repetitions only")
        self.auto_propagated_check = CheckmarkCheckBox("Auto-propagated")
        
        other_layout.addWidget(self.has_comments_check)
        other_layout.addWidget(self.has_proofreading_check)
        other_layout.addWidget(self.repetitions_check)
        other_layout.addWidget(self.auto_propagated_check)
        
        other_group.setLayout(other_layout)
        content_layout.addWidget(other_group)
        
        content_layout.addStretch()
        scroll.setWidget(content)
        layout.addWidget(scroll)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        reset_btn = QPushButton("Reset All")
        reset_btn.clicked.connect(self.reset_filters)
        button_layout.addWidget(reset_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        apply_btn = QPushButton("Apply Filters")
        apply_btn.setStyleSheet("background-color: #2196F3; color: white; font-weight: bold; padding: 5px 15px; border: none; outline: none;")
        apply_btn.clicked.connect(self.accept)
        apply_btn.setDefault(True)
        button_layout.addWidget(apply_btn)
        
        layout.addLayout(button_layout)
    
    def reset_filters(self):
        """Reset all filters to default"""
        self.match_rate_check.setChecked(False)
        self.match_min_spin.setValue(0)
        self.match_max_spin.setValue(100)
        
        self.status_not_started.setChecked(False)
        self.status_edited.setChecked(False)
        self.status_pretranslated.setChecked(False)
        self.status_translated.setChecked(False)
        self.status_confirmed.setChecked(False)
        self.status_draft.setChecked(False)
        
        self.locked_both.setChecked(True)
        
        self.has_comments_check.setChecked(False)
        self.has_proofreading_check.setChecked(False)
        self.repetitions_check.setChecked(False)
        self.auto_propagated_check.setChecked(False)
    
    def get_filters(self):
        """Return dictionary of filter settings"""
        filters = {}
        
        # Match rate
        filters['match_rate_enabled'] = self.match_rate_check.isChecked()
        filters['match_rate_min'] = self.match_min_spin.value()
        filters['match_rate_max'] = self.match_max_spin.value()
        
        # Row status
        row_status = []
        if self.status_not_started.isChecked():
            row_status.append('not_started')
        if self.status_edited.isChecked():
            row_status.append('edited')
        if self.status_pretranslated.isChecked():
            row_status.append('pretranslated')
        if self.status_translated.isChecked():
            row_status.append('translated')
        if self.status_confirmed.isChecked():
            row_status.append('confirmed')
        if self.status_draft.isChecked():
            row_status.append('draft')
        filters['row_status'] = row_status
        
        # Locked filter
        if self.locked_only.isChecked():
            filters['locked_filter'] = 'locked'
        elif self.locked_unlocked_only.isChecked():
            filters['locked_filter'] = 'unlocked'
        else:
            filters['locked_filter'] = None
        
        # Other properties
        filters['has_comments'] = self.has_comments_check.isChecked()
        filters['has_proofreading'] = self.has_proofreading_check.isChecked()
        filters['repetitions_only'] = self.repetitions_check.isChecked()
        filters['auto_propagated'] = self.auto_propagated_check.isChecked()
        
        return filters


class ScratchpadDialog(QDialog):
    """Dialog for private translator notes (scratchpad).
    
    Notes are stored only in the .svproj file and never exported to CAT tools.
    """
    
    def __init__(self, parent=None, notes_text: str = ""):
        super().__init__(parent)
        self.notes_text = notes_text
        self.setup_ui()
    
    def setup_ui(self):
        self.setWindowTitle("üìù Scratchpad - Private Notes")
        self.setMinimumWidth(500)
        self.setMinimumHeight(400)
        self.resize(600, 450)
        
        layout = QVBoxLayout(self)
        layout.setSpacing(10)
        
        # Info label
        info_label = QLabel(
            "üìù <b>Private notes for this project</b><br>"
            "<small>These notes are saved with your project (.svproj) file and are <b>never</b> "
            "exported to CAT tools or shared with clients.</small>"
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; padding: 5px; background: #f9f9f9; border-radius: 4px;")
        layout.addWidget(info_label)
        
        # Notes text area
        self.notes_edit = QPlainTextEdit()
        self.notes_edit.setPlainText(self.notes_text)
        self.notes_edit.setPlaceholderText(
            "Use this scratchpad for your private notes during translation:\n\n"
            "‚Ä¢ Terminology decisions\n"
            "‚Ä¢ Client preferences\n"
            "‚Ä¢ Research findings\n"
            "‚Ä¢ Questions to ask\n"
            "‚Ä¢ Reminders for yourself"
        )
        # Nice monospace-ish font for notes
        font = self.notes_edit.font()
        font.setFamily("Consolas, Courier New, monospace")
        font.setPointSize(10)
        self.notes_edit.setFont(font)
        layout.addWidget(self.notes_edit, 1)  # Stretch to fill
        
        # Button row
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("üíæ Save Notes")
        save_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 6px 16px; border: none;")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        button_layout.addWidget(save_btn)
        
        layout.addLayout(button_layout)
    
    def get_notes(self) -> str:
        """Return the current notes text."""
        return self.notes_edit.toPlainText()


# ============================================================================
# BATCH TRANSLATION WORKER & PROGRESS DIALOG
# ============================================================================

class PreTranslationWorker(QThread):
    """Background worker thread for batch translation."""
    
    # Signals
    progress_update = pyqtSignal(int, int, str, bool, float)  # current, total, message, success, elapsed_time
    translation_complete = pyqtSignal(int, int)  # success_count, error_count
    translation_error = pyqtSignal(str)  # error_message
    retry_needed = pyqtSignal(list)  # empty_segments list of (row_index, segment)
    
    def __init__(self, parent_app, segments, provider_type, provider_name, model, tm_exact_only=False, prompt_manager=None, retry_enabled=False, retry_pass=0, tm_ids=None):
        super().__init__()
        self.parent_app = parent_app
        self.segments = segments
        self.provider_type = provider_type
        self.provider_name = provider_name
        self.model = model
        self.tm_exact_only = tm_exact_only
        self.prompt_manager = prompt_manager
        self.retry_enabled = retry_enabled
        self.retry_pass = retry_pass
        self.max_retries = 5
        self._cancelled = False
        self.tm_ids = tm_ids  # Activated TM IDs for TM pre-translation
        self.success_count = 0
        self.error_count = 0
    
    def run(self):
        """Main translation loop - runs in background thread."""
        import time
        import re
        
        # For TM provider, create thread-local database connection
        # SQLite connections can't be shared across threads
        self._thread_local_db = None
        if self.provider_type == 'TM' and hasattr(self.parent_app, 'tm_database') and self.parent_app.tm_database:
            try:
                import sqlite3
                db_path = self.parent_app.tm_database.db_path
                self._thread_local_db = sqlite3.connect(db_path)
                self._thread_local_db.row_factory = sqlite3.Row
                print(f"‚úì Created thread-local database connection for TM pre-translation")
            except Exception as e:
                print(f"‚ùå Failed to create thread-local DB connection: {e}")
                self._thread_local_db = None
        
        try:
            # For TM and MT, process segments individually
            if self.provider_type in ['TM', 'MT']:
                for idx, (row_index, segment) in enumerate(self.segments):
                    if self._cancelled:
                        break
                    
                    try:
                        start_time = time.time()
                        
                        # Get translation
                        if self.provider_type == 'TM':
                            translation = self._translate_from_tm(segment)
                        else:  # MT
                            translation = self._translate_with_mt(segment)
                        
                        elapsed = time.time() - start_time
                        
                        if translation:
                            segment.target = translation
                            segment.status = "Translated"
                            
                            preview = segment.source[:50] + ("..." if len(segment.source) > 50 else "")
                            message = f"[{idx+1}/{len(self.segments)}] ‚úì {preview} ({elapsed:.1f}s)"
                            self.progress_update.emit(idx + 1, len(self.segments), message, True, elapsed)
                            self.success_count += 1
                        else:
                            preview = segment.source[:50] + ("..." if len(self.segments) > 50 else "")
                            message = f"[{idx+1}/{len(self.segments)}] ‚äò No match found: {preview}"
                            self.progress_update.emit(idx + 1, len(self.segments), message, False, elapsed)
                            self.error_count += 1
                    
                    except Exception as e:
                        preview = segment.source[:50] + ("..." if len(segment.source) > 50 else "")
                        message = f"[{idx+1}/{len(self.segments)}] ‚úó ERROR: {preview} - {str(e)}"
                        self.progress_update.emit(idx + 1, len(self.segments), message, False, 0)
                        self.error_count += 1
        
            # For LLM, process in batches
            else:
                # Get batch size from settings
                general_prefs = self.parent_app.load_general_settings()
                batch_size = general_prefs.get('batch_size', 20)
                
                # Split segments into batches
                total_batches = (len(self.segments) + batch_size - 1) // batch_size
                
                for batch_num in range(total_batches):
                    if self._cancelled:
                        break
                    
                    start_idx = batch_num * batch_size
                    end_idx = min((batch_num + 1) * batch_size, len(self.segments))
                    batch_segments = self.segments[start_idx:end_idx]
                    
                    try:
                        start_time = time.time()
                    
                        # Translate entire batch
                        batch_translations = self._translate_batch_with_llm(batch_segments)
                    
                        elapsed = time.time() - start_time
                    
                        # Process results
                        for (row_index, segment), translation in zip(batch_segments, batch_translations):
                            absolute_idx = start_idx + batch_segments.index((row_index, segment))
                            
                            if translation:
                                segment.target = translation
                                segment.status = "Translated"
                                
                                preview = segment.source[:50] + ("..." if len(segment.source) > 50 else "")
                                message = f"[{absolute_idx+1}/{len(self.segments)}] ‚úì {preview}"
                                self.progress_update.emit(absolute_idx + 1, len(self.segments), message, True, elapsed / len(batch_segments))
                                self.success_count += 1
                            else:
                                preview = segment.source[:50] + ("..." if len(segment.source) > 50 else "")
                                message = f"[{absolute_idx+1}/{len(self.segments)}] ‚äò No translation: {preview}"
                                self.progress_update.emit(absolute_idx + 1, len(self.segments), message, False, elapsed / len(batch_segments))
                                self.error_count += 1
                
                    except Exception as e:
                        import traceback
                        error_details = traceback.format_exc()
                        print(f"‚ùå Batch processing error: {e}")
                        print(f"‚ùå Full traceback:\n{error_details}")
                        # Mark entire batch as failed
                        for row_index, segment in batch_segments:
                            absolute_idx = start_idx + batch_segments.index((row_index, segment))
                            preview = segment.source[:50] + ("..." if len(segment.source) > 50 else "")
                            message = f"[{absolute_idx+1}/{len(self.segments)}] ‚úó BATCH ERROR: {str(e)}"
                            self.progress_update.emit(absolute_idx + 1, len(self.segments), message, False, 0)
                            self.error_count += 1
        
            # Check if retry is needed (for LLM mode with retry option enabled)
            if self.retry_enabled and self.provider_type == 'LLM' and self.retry_pass < self.max_retries:
                # Count segments that are still empty after this pass
                empty_segments_after = []
                for row_index, seg in self.segments:
                    if not seg.target or not seg.target.strip():
                        empty_segments_after.append((row_index, seg))
                
                if empty_segments_after:
                    # Emit retry_needed signal with list of empty segments
                    self.retry_needed.emit(empty_segments_after)
                    # Still emit completion for UI updates
                    self.translation_complete.emit(self.success_count, self.error_count)
                    return
        
            # Emit completion
            self.translation_complete.emit(self.success_count, self.error_count)
        
        finally:
            # Clean up thread-local database connection
            if self._thread_local_db:
                try:
                    self._thread_local_db.close()
                    print(f"‚úì Closed thread-local database connection")
                except:
                    pass
    
    def cancel(self):
        """Request cancellation of translation job."""
        self._cancelled = True
    
    def _translate_from_tm(self, segment):
        """Translate a single segment using TM.
        
        Uses thread-local database connection to avoid SQLite threading errors.
        """
        try:
            print(f"üîç TM PRE-TRANSLATE: Searching for: '{segment.source[:50]}...'")
            print(f"üîç TM PRE-TRANSLATE: Using tm_ids: {self.tm_ids}")
            print(f"üîç TM PRE-TRANSLATE: Exact only: {self.tm_exact_only}")
            
            # Use thread-local database connection
            if not self._thread_local_db:
                print(f"‚ùå TM PRE-TRANSLATE: No thread-local database connection!")
                return None
            
            # Create a thread-local DatabaseManager for TM operations
            # This avoids SQLite threading errors
            from modules.database_manager import DatabaseManager
            
            # Get db_path from parent_app's tm_database
            db_path = self.parent_app.tm_database.db_path
            
            # Create a thread-local DatabaseManager
            thread_local_tm = DatabaseManager(db_path=db_path, log_callback=print)
            thread_local_tm.connection = self._thread_local_db
            thread_local_tm.cursor = self._thread_local_db.cursor()
            
            if self.tm_exact_only:
                # Exact matches only - use hash lookup
                match = thread_local_tm.get_exact_match(segment.source, tm_ids=self.tm_ids)
                print(f"üîç TM PRE-TRANSLATE: Exact match result: {match}")
                if match:
                    return match.get('target_text', '')
                return None
            else:
                # Fuzzy matching enabled - use activated TM IDs
                matches = thread_local_tm.search_all(
                    segment.source, 
                    tm_ids=self.tm_ids, 
                    enabled_only=False, 
                    max_matches=1
                )
                print(f"üîç TM PRE-TRANSLATE: Fuzzy matches: {matches}")
                if matches and len(matches) > 0:
                    match = matches[0]
                    match_pct = match.get('match_pct', 0)
                    print(f"üîç TM PRE-TRANSLATE: Best match pct: {match_pct}")
                    if match_pct >= 75:  # Accept matches 75% and above
                        return match.get('target', '')
                return None
        except Exception as e:
            print(f"TM translation error: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def _translate_with_mt(self, segment):
        """Translate a single segment using MT."""
        # This would call parent_app's MT methods
        # Implementation depends on which MT provider is selected
        try:
            # Get source/target languages
            source_lang = getattr(self.parent_app.current_project, 'source_lang', 'en')
            target_lang = getattr(self.parent_app.current_project, 'target_lang', 'nl')
            
            # Load API keys
            api_keys = self.parent_app.load_api_keys()
            
            # Call appropriate MT service
            if self.provider_name == 'Google Translate':
                return self.parent_app.call_google_translate(segment.source, source_lang, target_lang, api_keys.get('google_translate'))
            elif self.provider_name == 'DeepL':
                return self.parent_app.call_deepl(segment.source, source_lang, target_lang, api_keys.get('deepl'))
            # Add other MT providers as needed
            return None
        except Exception as e:
            print(f"MT translation error: {e}")
            return None
    
    def _translate_with_llm(self, segment):
        """Translate a single segment using LLM."""
        try:
            from modules.llm_clients import LLMClient
            
            # Get source/target languages
            source_lang = getattr(self.parent_app.current_project, 'source_lang', 'en')
            target_lang = getattr(self.parent_app.current_project, 'target_lang', 'nl')
            
            # Load API keys
            api_keys = self.parent_app.load_api_keys()
            api_key = api_keys.get(self.provider_name) or (api_keys.get('google') if self.provider_name == 'gemini' else None)
            
            # Build custom prompt from prompt library
            custom_prompt = None
            if self.prompt_manager:
                try:
                    # Get glossary terms for AI injection
                    glossary_terms = self.parent_app.get_ai_inject_glossary_terms() if hasattr(self.parent_app, 'get_ai_inject_glossary_terms') else []
                    full_prompt = self.prompt_manager.build_final_prompt(
                        source_text=segment.source,
                        source_lang=source_lang,
                        target_lang=target_lang,
                        mode="single",
                        glossary_terms=glossary_terms
                    )
                    # Extract just the instruction part (without the source text section)
                    if "**SOURCE TEXT:**" in full_prompt:
                        custom_prompt = full_prompt.split("**SOURCE TEXT:**")[0].strip()
                    elif "Translate the following" in full_prompt:
                        custom_prompt = full_prompt.split("Translate the following")[0].strip()
                    else:
                        custom_prompt = full_prompt
                except Exception as e:
                    print(f"Warning: Could not build custom prompt: {e}")
                    custom_prompt = None
            
            # Create client
            client = LLMClient(
                api_key=api_key,
                provider=self.provider_name,
                model=self.model
            )
            
            # Translate with custom prompt
            result = client.translate(
                text=segment.source,
                source_lang=source_lang,
                target_lang=target_lang,
                custom_prompt=custom_prompt
            )
            
            return result
        except Exception as e:
            print(f"LLM translation error: {e}")
            return None
    
    def _translate_batch_with_llm(self, batch_segments):
        """Translate multiple segments in one LLM call (batch mode)."""
        try:
            from modules.llm_clients import LLMClient
            import re
            import traceback
            
            print(f"üöÄ _translate_batch_with_llm: Starting batch of {len(batch_segments)} segments")
            
            # Get source/target languages
            source_lang = getattr(self.parent_app.current_project, 'source_lang', 'en')
            target_lang = getattr(self.parent_app.current_project, 'target_lang', 'nl')
            print(f"üöÄ Languages: {source_lang} ‚Üí {target_lang}")
            
            # Load API keys
            api_keys = self.parent_app.load_api_keys()
            api_key = api_keys.get(self.provider_name) or (api_keys.get('google') if self.provider_name == 'gemini' else None)
            
            # Build batch prompt
            batch_prompt_parts = []
            
            # Get base prompt from prompt library
            base_prompt = None
            if self.prompt_manager and batch_segments:
                try:
                    first_segment = batch_segments[0][1]
                    # Get glossary terms for AI injection
                    glossary_terms = self.parent_app.get_ai_inject_glossary_terms() if hasattr(self.parent_app, 'get_ai_inject_glossary_terms') else []
                    full_prompt = self.prompt_manager.build_final_prompt(
                        source_text=first_segment.source,
                        source_lang=source_lang,
                        target_lang=target_lang,
                        mode="single",
                        glossary_terms=glossary_terms
                    )
                    # Extract just the instruction part
                    if "**SOURCE TEXT:**" in full_prompt:
                        base_prompt = full_prompt.split("**SOURCE TEXT:**")[0].strip()
                    elif "Translate the following" in full_prompt:
                        base_prompt = full_prompt.split("Translate the following")[0].strip()
                    else:
                        base_prompt = full_prompt
                except Exception:
                    base_prompt = None
            
            if base_prompt:
                batch_prompt_parts.append(base_prompt)
            else:
                batch_prompt_parts.append(f"Translate the following text segments from {source_lang} to {target_lang}.")
            
            # Add batch instructions
            batch_prompt_parts.append(f"\n**SEGMENTS TO TRANSLATE ({len(batch_segments)} segments):**")
            batch_prompt_parts.append("\n‚ö†Ô∏è CRITICAL INSTRUCTIONS:")
            batch_prompt_parts.append(f"1. You must provide EXACTLY one translation per segment")
            batch_prompt_parts.append(f"2. You MUST translate ALL {len(batch_segments)} segments")
            batch_prompt_parts.append("3. Format: Each translation MUST start with its segment number, a period, then the translation")
            batch_prompt_parts.append("4. NO explanations, NO commentary, ONLY the numbered translations\n")
            
            batch_prompt_parts.append("**SEGMENTS TO TRANSLATE:**\n")
            
            # Add all segments
            for row_index, seg in batch_segments:
                batch_prompt_parts.append(f"{seg.id}. {seg.source}")
            
            batch_prompt_parts.append("\n**YOUR TRANSLATIONS (numbered list):**")
            batch_prompt_parts.append("Begin your translations now:")
            
            batch_prompt = "\n".join(batch_prompt_parts)
            
            # Create client
            client = LLMClient(
                api_key=api_key,
                provider=self.provider_name,
                model=self.model
            )
            
            # Call LLM with batch prompt (no custom_prompt parameter - it's all in the text)
            result = client.translate(
                text=batch_prompt,
                source_lang=source_lang,
                target_lang=target_lang,
                custom_prompt=None  # We built the full prompt already
            )
            
            # Parse the numbered response
            translations = []
            if result:
                lines = result.split('\n')
                translation_map = {}
                
                for line in lines:
                    # Match "123. Translation text"
                    match = re.match(r'^(\d+)\.\s*(.+)$', line.strip())
                    if match:
                        seg_id = int(match.group(1))
                        translation = match.group(2).strip()
                        translation_map[seg_id] = translation
                
                # Extract translations in order
                for row_index, seg in batch_segments:
                    translation = translation_map.get(seg.id, None)
                    translations.append(translation)
            else:
                # No result - all segments failed
                translations = [None] * len(batch_segments)
            
            return translations
            
        except Exception as e:
            import traceback
            error_details = traceback.format_exc()
            print(f"‚ùå Batch LLM translation error: {e}")
            print(f"‚ùå Full traceback:\n{error_details}")
            # Return list of None for all segments
            return [None] * len(batch_segments)


class LiveProgressDialog(QDialog):
    """Progress dialog with live console output."""
    
    def __init__(self, parent, total_segments, provider_info):
        super().__init__(parent)
        self.total_segments = total_segments
        self.provider_info = provider_info
        self.start_time = time.time()
        self.segment_times = []  # Track processing times for estimation
        
        self.setWindowTitle("Batch Translation Progress")
        self.setMinimumSize(800, 600)
        
        # Main layout
        layout = QVBoxLayout(self)
        
        # Header
        header_label = QLabel(f"<h3>üöÄ Translating {total_segments} segment{'s' if total_segments != 1 else ''}</h3>")
        layout.addWidget(header_label)
        
        # Provider info
        provider_label = QLabel(provider_info)
        provider_label.setStyleSheet("color: #666; padding: 5px 0;")
        layout.addWidget(provider_label)
        
        # Progress info section
        info_layout = QHBoxLayout()
        self.progress_label = QLabel("0/0 (0%)")
        self.time_label = QLabel("Elapsed: 0:00 | Remaining: --:--")
        self.speed_label = QLabel("Speed: -- seg/min")
        info_layout.addWidget(self.progress_label)
        info_layout.addStretch()
        info_layout.addWidget(self.time_label)
        info_layout.addWidget(self.speed_label)
        layout.addLayout(info_layout)
        
        # Progress bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximum(total_segments)
        layout.addWidget(self.progress_bar)
        
        # Console output
        console_label = QLabel("<b>Console Output:</b>")
        layout.addWidget(console_label)
        
        self.console = QTextEdit()
        self.console.setReadOnly(True)
        self.console.setFont(QFont("Consolas", 9))
        self.console.setStyleSheet("""
            QTextEdit {
                background-color: #1e1e1e;
                color: #d4d4d4;
                border: 1px solid #3c3c3c;
            }
        """)
        layout.addWidget(self.console)
        
        # Statistics
        self.stats_label = QLabel("‚úì Success: 0  |  ‚úó Errors: 0")
        self.stats_label.setStyleSheet("padding: 5px 0; font-weight: bold;")
        layout.addWidget(self.stats_label)
        
        # Button section
        button_layout = QHBoxLayout()
        self.cancel_btn = QPushButton("Cancel")
        self.cancel_btn.clicked.connect(self.reject)
        button_layout.addStretch()
        button_layout.addWidget(self.cancel_btn)
        layout.addLayout(button_layout)
        
        # Timer for elapsed time updates
        self.timer = QTimer()
        self.timer.timeout.connect(self._update_time_display)
        self.timer.start(1000)  # Update every second
        
        # Initial console message
        self.add_console_line(f"Starting batch translation: {total_segments} segments", True)
        self.add_console_line(provider_info, True)
        self.add_console_line("-" * 80, True)
    
    def add_console_line(self, message, is_success=True):
        """Add a line to the console with color coding."""
        cursor = self.console.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        
        # Set text color
        fmt = cursor.charFormat()
        if is_success:
            fmt.setForeground(QColor("#4ec9b0"))  # Greenish (VS Code style)
        else:
            fmt.setForeground(QColor("#f48771"))  # Reddish (VS Code style)
        
        cursor.setCharFormat(fmt)
        cursor.insertText(message + "\n")
        
        # Auto-scroll to bottom
        self.console.setTextCursor(cursor)
        self.console.ensureCursorVisible()
    
    def update_progress(self, current, total, elapsed_seconds, success_count, error_count):
        """Update progress bar and labels."""
        self.progress_bar.setValue(current)
        
        # Update progress label
        percent = int((current / total) * 100) if total > 0 else 0
        self.progress_label.setText(f"{current}/{total} ({percent}%)")
        
        # Update statistics
        self.stats_label.setText(f"‚úì Success: {success_count}  |  ‚úó Errors: {error_count}")
        
        # Track timing
        if elapsed_seconds > 0:
            self.segment_times.append(elapsed_seconds)
        
        # Calculate speed and estimate remaining time
        if len(self.segment_times) > 0:
            avg_time = sum(self.segment_times) / len(self.segment_times)
            speed = 60 / avg_time if avg_time > 0 else 0
            remaining_segments = total - current
            remaining_seconds = remaining_segments * avg_time
            
            # Update labels
            self.speed_label.setText(f"Speed: {speed:.1f} seg/min")
            
            remaining_str = self._format_time(remaining_seconds)
            elapsed_str = self._format_time(time.time() - self.start_time)
            self.time_label.setText(f"Elapsed: {elapsed_str} | Remaining: {remaining_str}")
    
    def _update_time_display(self):
        """Update elapsed time display (called every second)."""
        if self.progress_bar.value() < self.total_segments:
            elapsed = time.time() - self.start_time
            current_text = self.time_label.text()
            # Update only elapsed portion
            if " | " in current_text:
                remaining_part = current_text.split(" | ")[1]
                self.time_label.setText(f"Elapsed: {self._format_time(elapsed)} | {remaining_part}")
    
    @staticmethod
    def _format_time(seconds):
        """Format seconds as MM:SS."""
        minutes = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{minutes}:{secs:02d}"
    
    def show_completion_message(self, success_count, error_count):
        """Show completion summary in console."""
        self.add_console_line("", True)  # Blank line
        self.add_console_line("=" * 80, True)
        self.add_console_line(f"Translation Complete!", True)
        self.add_console_line(f"‚úì Success: {success_count}", True)
        if error_count > 0:
            self.add_console_line(f"‚úó Errors: {error_count}", False)
        total_time = time.time() - self.start_time
        self.add_console_line(f"Total time: {self._format_time(total_time)}", True)
        self.add_console_line("=" * 80, True)
        
        # Change button to "Close"
        self.cancel_btn.setText("Close")


# ============================================================================
# MAIN WINDOW
# ============================================================================

class SupervertalerQt(QMainWindow):
    """Main application window"""
    
    MAX_RECENT_PROJECTS = 10  # Maximum number of recent projects to track
    
    # Signal for thread-safe logging (background threads emit, main thread handles)
    _log_signal = pyqtSignal(str)
    
    # Signal for proactive highlighting - prefetch worker emits, main thread applies highlighting
    # Args: segment_id (int), termbase_matches (dict as JSON string for thread safety)
    _proactive_highlight_signal = pyqtSignal(int, str)
    
    def __init__(self):
        super().__init__()
        
        # Connect thread-safe log signal (must be done first for logging to work from threads)
        self._log_signal.connect(self._log_to_ui)
        
        # Connect proactive highlighting signal (prefetch worker emits, main thread highlights)
        self._proactive_highlight_signal.connect(self._apply_proactive_highlighting)
        
        # Application state
        self.current_project: Optional[Project] = None
        self.project_file_path: Optional[str] = None
        self.project_modified = False
        
        # memoQ bilingual DOCX import tracking
        self.memoq_source_file = None
        
        # UI Configuration
        self.default_font_family = "Calibri"
        self.default_font_size = 11
        
        # Application settings
        self.allow_replace_in_source = False  # Safety: don't allow replace in source by default
        self.auto_propagate_exact_matches = True  # Auto-fill 100% TM matches for empty segments
        self.auto_insert_100_percent_matches = True  # Auto-insert 100% TM matches when segment selected
        self.auto_confirm_100_percent_matches = False  # Auto-confirm 100% matches when navigating with Ctrl+Enter
        self.auto_confirm_overwrite_existing = False  # Allow auto-confirm to overwrite existing target content
        self.tm_save_mode = 'latest'  # 'all' = keep all translations with timestamps, 'latest' = only keep most recent (DEFAULT)
        
        # Tab position setting
        self.tabs_above_grid = False  # Whether to show Termview/Session Log tabs above grid
        
        # Right panel visibility settings
        self.show_translation_results_pane = False  # Show Translation Results tab (hidden by default for new users)
        # Note: Match Panel is always visible (no toggle needed)
        
        # TM and Termbase matching toggle (default: enabled)
        self.enable_tm_matching = True
        self.enable_termbase_matching = True
        self.enable_mt_matching = True  # Machine Translation enabled
        self.enable_llm_matching = False  # LLM Translation enabled (DISABLED by default - too slow for navigation!)
        self.enable_termbase_grid_highlighting = True  # Highlight termbase matches in source cells

        # Termbase display settings
        self.termbase_display_order = 'appearance'  # Options: 'alphabetical', 'appearance', 'length'
        self.termbase_hide_shorter_matches = False  # Hide shorter terms included in longer ones

        # Invisible character display settings
        self.showing_invisible_spaces = False  # Track whether spaces are shown as middle dots
        self.invisible_char_color = '#999999'  # Light gray color for invisible characters
        self.invisible_display_settings = {
            'spaces': False,
            'tabs': False,
            'nbsp': False,
            'linebreaks': False
        }

        # Grid row color settings (memoQ-style alternating row colors)
        self.enable_alternating_row_colors = True  # Enable alternating row colors by default
        self.even_row_color = '#FFFFFF'  # White for even rows
        self.odd_row_color = '#F0F0F0'  # Light gray for odd rows
        
        # Termbase highlight style settings
        self.termbase_highlight_style = 'semibold'  # 'background', 'dotted', or 'semibold'
        self.termbase_dotted_color = '#808080'  # Medium gray for dotted underline (more visible)
        
        # Focus border settings for target cells
        self.focus_border_color = '#f1b79a'  # Peach/salmon
        self.focus_border_thickness = 2  # 2px
        
        # Sound effects settings
        self.enable_sound_effects = False  # Sound effects disabled by default

        # Debug mode settings (for troubleshooting performance issues)
        self.debug_mode_enabled = False  # Enables verbose debug logging
        self.debug_auto_export = False  # Auto-export debug logs to file
        self.debug_log_buffer = []  # Buffer for debug logs (for export)
        
        # Precision scroll settings (for fine-tuned grid navigation)
        self.precision_scroll_divisor = 3  # Divide row height by this (higher = finer increments)
        self.auto_center_active_segment = True  # Auto-scroll to keep active segment centered (default ON)
        
        # Translation service availability flags (would be set from config/API keys)
        self.google_translate_enabled = True  # For demo purposes
        self.deepl_enabled = False  # Not implemented yet
        self.openai_enabled = True  # For demo purposes
        self.claude_enabled = True  # For demo purposes
        
        # Timer for delayed lookup (cancel if user moves to another segment)
        self.lookup_timer = None
        self.current_lookup_segment_id = None
        
        # Termbase cache for performance optimization
        # Maps segment ID ‚Üí {term: translation} dictionary
        self.termbase_cache = {}
        self.termbase_cache_lock = threading.Lock()  # Thread-safe cache access
        self.termbase_batch_worker_thread = None  # Background worker thread
        self.termbase_batch_stop_event = threading.Event()  # Signal to stop background worker

        # In-memory termbase index for instant lookups (v1.9.182)
        # Loaded once on project load, contains ALL terms from activated termbases
        # Structure: list of term dicts with pre-compiled regex patterns
        self.termbase_index = []
        self.termbase_index_lock = threading.Lock()
        
        # TM/MT/LLM prefetch cache for instant segment switching (like memoQ)
        # Maps segment ID ‚Üí {"TM": [...], "MT": [...], "LLM": [...]}
        self.translation_matches_cache = {}
        self.translation_matches_cache_lock = threading.Lock()
        self.prefetch_worker_thread = None
        self.prefetch_stop_event = threading.Event()
        self.prefetch_queue = []  # List of segment IDs to prefetch
        
        # Idle prefetch: prefetch next segments while user is thinking/typing
        self.idle_prefetch_timer = None  # QTimer for triggering prefetch after typing pause
        self.idle_prefetch_delay_ms = 1500  # Start prefetch 1.5s after user stops typing
        
        # Cache kill switch for performance testing
        # When True, all caches are bypassed - direct lookups every time
        self.disable_all_caches = False  # v1.9.183: Default to False (caches ENABLED)
        
        # Undo/Redo stack for grid edits
        self.undo_stack = []  # List of (segment_id, old_target, new_target, old_status, new_status)
        self.redo_stack = []  # List of undone actions that can be redone
        self.max_undo_levels = 100  # Maximum number of undo levels to keep
        
        # Global language settings (defaults)
        self.source_language = "English"
        self.target_language = "Dutch"

        # Supervoice model download tracking
        self.is_loading_model = False
        self.loading_model_name = None
        
        # Target editor signal suppression (prevents load-time churn)
        self._suppress_target_change_handlers = False
        self.warning_banners: Dict[str, QWidget] = {}
        
        # Superlookup detached window
        self.lookup_detached_window = None
        
        # ============================================================================
        # USER DATA PATH INITIALIZATION
        # ============================================================================
        # ALL users (EXE, pip, dev) now use a unified system:
        # - Default location: ~/Supervertaler/ (visible in home folder)
        # - User can choose custom location on first run
        # - Config pointer stores their choice at standard config location
        # - Auto-recovery if pointer is deleted but data exists at default location
        from modules.database_manager import DatabaseManager
        
        # Check if this is first run BEFORE getting the path
        # (so we know whether to show the data location dialog later)
        self._needs_data_location_dialog = needs_first_run_data_dialog()
        
        if ENABLE_PRIVATE_FEATURES:
            # Developer mode: use private folder (git-ignored)
            self.user_data_path = Path(__file__).parent / "user_data_private"
            self._needs_data_location_dialog = False  # Dev mode doesn't need dialog
        else:
            # Normal mode: use unified system (same for pip, EXE, etc.)
            self.user_data_path = get_user_data_path()
        
        # Ensure user_data directory exists (creates empty folder if missing)
        # BUT only if we're not going to show the dialog (which will create the chosen folder)
        if not self._needs_data_location_dialog:
            self.user_data_path.mkdir(parents=True, exist_ok=True)
        
        print(f"[Data Paths] User data: {self.user_data_path}")
        
        # Database Manager for Termbases
        self.db_manager = DatabaseManager(
            db_path=str(self.user_data_path / "resources" / "supervertaler.db"),
            log_callback=self.log
        )
        # Only connect if we're not showing the dialog (which will create the folder)
        # If dialog is needed, we'll connect after user chooses location
        if not self._needs_data_location_dialog:
            self.db_manager.connect()
        
        # TM Database - Initialize early so Superlookup works without a project loaded
        from modules.translation_memory import TMDatabase
        self.tm_database = TMDatabase(
            source_lang=None,  # Will be set when project is loaded
            target_lang=None,  # Will be set when project is loaded
            db_path=str(self.user_data_path / "resources" / "supervertaler.db"),
            log_callback=self.log
        )
        
        # TM Metadata Manager - needed for TM list in Superlookup
        from modules.tm_metadata_manager import TMMetadataManager
        self.tm_metadata_mgr = TMMetadataManager(self.db_manager, self.log)

        # Termbase Manager - needed for glossary AI injection
        from modules.termbase_manager import TermbaseManager
        self.termbase_mgr = TermbaseManager(self.db_manager, self.log)
        
        # Spellcheck Manager for target language spell checking
        self.spellcheck_manager = get_spellcheck_manager(str(self.user_data_path))
        # Note: spellcheck_enabled will be loaded from preferences later in _load_spellcheck_settings()
        # For now set to False, it gets updated when UI is created
        self.spellcheck_enabled = False
        # Set up the shared spellcheck manager for TagHighlighter instances
        TagHighlighter.set_spellcheck_manager(self.spellcheck_manager)
        TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
        
        # Find & Replace History Manager
        self.fr_history = FindReplaceHistory(str(self.user_data_path))
        
        # Shortcut Manager for keyboard shortcuts (including enable/disable)
        self.shortcut_manager = ShortcutManager(Path(self.user_data_path) / "shortcuts.json")
        
        # Voice Command Manager for Talon-style voice commands
        self.voice_command_manager = VoiceCommandManager(self.user_data_path, main_window=self)
        
        # Continuous Voice Listener (always-on mode) - initialized on demand
        self.voice_listener = None  # Will be ContinuousVoiceListener when enabled
        
        # Figure Context Manager for multimodal AI translation
        from modules.figure_context_manager import FigureContextManager
        self.figure_context = FigureContextManager(self)
        
        # Theme Manager
        from modules.theme_manager import ThemeManager
        self.theme_manager = None  # Will be initialized after UI setup
        
        # User data path - uses safety system to prevent private data leaks
        # If .supervertaler.local exists: uses "user_data_private" (git-ignored)
        # Otherwise: uses "user_data" (safe to commit)
        base_folder = "user_data_private" if ENABLE_PRIVATE_FEATURES else "user_data"
        self.recent_projects_file = self.user_data_path / "recent_projects.json"
        
        # Initialize UI
        self.init_ui()
        
        # Initialize theme manager and apply theme
        self.theme_manager = ThemeManager(self.user_data_path)
        # Apply saved global UI font scale
        saved_font_scale = self._get_global_ui_font_scale()
        self.theme_manager.font_scale = saved_font_scale
        self.theme_manager.apply_theme(QApplication.instance())
        
        # Update widgets that were created before theme_manager existed
        if hasattr(self, 'termview_widget') and self.termview_widget:
            self.termview_widget.theme_manager = self.theme_manager
            if hasattr(self.termview_widget, 'apply_theme'):
                self.termview_widget.apply_theme()

        # Also update the Match Panel TermView (right panel)
        if hasattr(self, 'termview_widget_match') and self.termview_widget_match:
            self.termview_widget_match.theme_manager = self.theme_manager
            if hasattr(self.termview_widget_match, 'apply_theme'):
                self.termview_widget_match.apply_theme()

        if hasattr(self, 'translation_results_panel') and self.translation_results_panel:
            self.translation_results_panel.theme_manager = self.theme_manager
            # Also update class-level theme_manager for CompactMatchItem
            from modules.translation_results_panel import CompactMatchItem
            CompactMatchItem.theme_manager = self.theme_manager
            print(f"üé® DEBUG: Calling apply_theme on translation_results_panel", flush=True)
            # Write to file for debugging
            with open("theme_debug.txt", "w") as f:
                f.write(f"apply_theme called, theme={self.theme_manager.current_theme.name}\n")
                f.write(f"compare_text_edits count: {len(self.translation_results_panel.compare_text_edits)}\n")
                f.flush()
            if hasattr(self.translation_results_panel, 'apply_theme'):
                self.translation_results_panel.apply_theme()
                print(f"üé® DEBUG: apply_theme() called successfully", flush=True)
        else:
            print(f"üé® DEBUG: translation_results_panel NOT FOUND!", flush=True)
            with open("theme_debug.txt", "w") as f:
                f.write("translation_results_panel NOT FOUND!\n")
                f.flush()
        
        # Schedule theme refresh after UI is fully initialized
        # This ensures all widgets are properly themed at startup
        from PyQt6.QtCore import QTimer
        QTimer.singleShot(100, self.refresh_theme_colors)
        
        # Create example API keys file on first launch (after UI is ready)
        self.ensure_example_api_keys()
        
        self.log(f"Welcome to Supervertaler v{__version__}")
        self.log("Supervertaler: The Ultimate Translation Workbench.")
        
        # Load general settings (including auto-propagation)
        self.load_general_settings()
        
        # Load language settings
        self.load_language_settings()
        
        # Restore last project if enabled in settings
        self.restore_last_project_if_enabled()
        
        # Auto-open log window if enabled in settings
        general_settings = self.load_general_settings()
        if general_settings.get('auto_open_log', False):
            # Use QTimer to open log window after UI fully initializes
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(500, self.detach_log_window)  # 500ms delay to ensure UI is ready

        # Initialize auto backup timer
        self.auto_backup_timer = None
        self.last_backup_time = None
        self.restart_auto_backup_timer()

        # Load font sizes from preferences (after UI is fully initialized)
        QApplication.instance().processEvents()  # Allow UI to finish initializing
        self.load_font_sizes_from_preferences()
        
        # Restore Termview under grid visibility state
        if hasattr(self, 'bottom_tabs'):
            termview_visible = general_settings.get('termview_under_grid_visible', True)
            self.bottom_tabs.setVisible(termview_visible)
            if hasattr(self, 'termview_visible_action'):
                self.termview_visible_action.setChecked(termview_visible)
        
        # Auto-check for new models if enabled in settings
        if general_settings.get('auto_check_models', True):
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(2000, lambda: self._check_for_new_models(force=False))  # 2 second delay
        
        # First-run check - show unified setup wizard
        if self._needs_data_location_dialog or not general_settings.get('first_run_completed', False):
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(300, lambda: self._show_setup_wizard(is_first_run=True))
    
    def _show_data_location_dialog(self):
        """Show dialog to let user choose their data folder location on first run."""
        try:
            from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                                         QPushButton, QLineEdit, QFileDialog, QDialogButtonBox)
            
            dialog = QDialog(self)
            dialog.setWindowTitle("Choose Data Folder Location")
            dialog.setMinimumWidth(550)
            dialog.setModal(True)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            
            # Title
            title_label = QLabel("<h2>üìÅ Choose Your Data Folder</h2>")
            layout.addWidget(title_label)
            
            # Explanation
            msg_label = QLabel(
                "Supervertaler stores your data in a folder of your choice, which contains things like:<br><br>"
                "‚Ä¢ API keys<br>"
                "‚Ä¢ Translation memories<br>"
                "‚Ä¢ Glossaries<br>"
                "‚Ä¢ Prompts<br>"
                "‚Ä¢ Settings<br><br>"
                "Choose a location that's easy to find and backup.<br>"
                "You can change this later in Settings ‚Üí General."
            )
            msg_label.setWordWrap(True)
            layout.addWidget(msg_label)
            
            # Path input with browse button
            path_layout = QHBoxLayout()
            
            path_edit = QLineEdit()
            default_path = get_default_user_data_path()
            path_edit.setText(str(default_path))
            path_edit.setMinimumWidth(350)
            path_layout.addWidget(path_edit)
            
            browse_btn = QPushButton("Browse...")
            def browse_folder():
                folder = QFileDialog.getExistingDirectory(
                    dialog, 
                    "Choose Data Folder",
                    str(Path.home())
                )
                if folder:
                    # Append "Supervertaler" if user didn't include it
                    folder_path = Path(folder)
                    if folder_path.name != "Supervertaler":
                        folder_path = folder_path / "Supervertaler"
                    path_edit.setText(str(folder_path))
            
            browse_btn.clicked.connect(browse_folder)
            path_layout.addWidget(browse_btn)
            
            layout.addLayout(path_layout)
            
            # Tip
            tip_label = QLabel(
                "üí° <b>Tip:</b> The default location is in your home folder, "
                "making it easy to find and backup."
            )
            tip_label.setWordWrap(True)
            tip_label.setStyleSheet("color: #666;")
            layout.addWidget(tip_label)
            
            # Buttons
            button_layout = QHBoxLayout()
            
            default_btn = QPushButton("Use Default")
            default_btn.clicked.connect(lambda: path_edit.setText(str(default_path)))
            button_layout.addWidget(default_btn)
            
            button_layout.addStretch()
            
            ok_btn = QPushButton("OK")
            ok_btn.setDefault(True)
            ok_btn.clicked.connect(dialog.accept)
            button_layout.addWidget(ok_btn)
            
            layout.addLayout(button_layout)
            
            # Show dialog
            if dialog.exec() == QDialog.DialogCode.Accepted:
                chosen_path = Path(path_edit.text())
                
                # Create the folder
                chosen_path.mkdir(parents=True, exist_ok=True)
                
                # Save the choice to config pointer
                save_user_data_path(chosen_path)
                
                # Update our path if different from what we initialized with
                if chosen_path != self.user_data_path:
                    self.user_data_path = chosen_path
                    # Re-initialize managers with new path
                    self._reinitialize_with_new_data_path()
                else:
                    # Same path, but we still need to connect database (it was deferred)
                    if hasattr(self, 'db_manager') and self.db_manager and not self.db_manager.connection:
                        self.db_manager.connect()
                
                self.log(f"üìÅ Data folder set to: {chosen_path}")
                
                # Now show the features welcome dialog
                from PyQt6.QtCore import QTimer
                QTimer.singleShot(300, self._show_first_run_welcome)
            else:
                # User cancelled - use default anyway
                default_path.mkdir(parents=True, exist_ok=True)
                save_user_data_path(default_path)
                self.log(f"üìÅ Using default data folder: {default_path}")
                
        except Exception as e:
            self.log(f"‚ö†Ô∏è Data location dialog error: {e}")
            import traceback
            traceback.print_exc()
    
    def _reinitialize_with_new_data_path(self):
        """Re-initialize managers after user changes data path."""
        try:
            # Close existing database connection
            if hasattr(self, 'db_manager') and self.db_manager:
                self.db_manager.close()
            
            # Re-initialize database manager
            from modules.database_manager import DatabaseManager
            self.db_manager = DatabaseManager(
                db_path=str(self.user_data_path / "resources" / "supervertaler.db"),
                log_callback=self.log
            )
            self.db_manager.connect()
            
            # Re-initialize TM database
            from modules.translation_memory import TMDatabase
            self.tm_database = TMDatabase(
                source_lang=None,
                target_lang=None,
                db_path=str(self.user_data_path / "resources" / "supervertaler.db"),
                log_callback=self.log
            )
            
            # Re-initialize TM metadata manager
            from modules.tm_metadata_manager import TMMetadataManager
            self.tm_metadata_mgr = TMMetadataManager(self.db_manager, self.log)
            
            # Update other managers
            self.spellcheck_manager = get_spellcheck_manager(str(self.user_data_path))
            self.fr_history = FindReplaceHistory(str(self.user_data_path))
            self.shortcut_manager = ShortcutManager(Path(self.user_data_path) / "shortcuts.json")
            self.voice_command_manager = VoiceCommandManager(self.user_data_path, main_window=self)
            
            # Update theme manager
            from modules.theme_manager import ThemeManager
            self.theme_manager = ThemeManager(self.user_data_path)
            # Apply saved global UI font scale
            saved_font_scale = self._get_global_ui_font_scale()
            self.theme_manager.font_scale = saved_font_scale
            self.theme_manager.apply_theme(QApplication.instance())
            
            # Update recent projects file path
            self.recent_projects_file = self.user_data_path / "recent_projects.json"
            
            self.log(f"‚úÖ Re-initialized all managers with new data path")
            
        except Exception as e:
            self.log(f"‚ö†Ô∏è Error re-initializing managers: {e}")
            import traceback
            traceback.print_exc()
    
    def _show_first_run_welcome(self):
        """Show welcome message and Features tab on first run."""
        try:
            # Create a custom dialog with checkbox
            from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QCheckBox, QDialogButtonBox
            
            dialog = QDialog(self)
            dialog.setWindowTitle("Welcome to Supervertaler!")
            dialog.setMinimumWidth(450)
            
            layout = QVBoxLayout(dialog)
            layout.setSpacing(15)
            
            # Icon and title
            title_label = QLabel("<h2>Welcome to Supervertaler! üéâ</h2>")
            layout.addWidget(title_label)
            
            # Message
            msg_label = QLabel(
                "Supervertaler uses a <b>modular architecture</b> - you can install "
                "only the features you need to save disk space.<br><br>"
                "We'll now show you the <b>Features</b> tab where you can see which "
                "optional components are installed and how to add more.<br><br>"
                "üí° <b>Tip:</b> You can always access this from Settings ‚Üí Features."
            )
            msg_label.setWordWrap(True)
            layout.addWidget(msg_label)
            
            # Checkbox - use our standard green checkmark style
            dont_show_checkbox = CheckmarkCheckBox("Don't show this again")
            dont_show_checkbox.setChecked(True)  # Default to not showing again
            layout.addWidget(dont_show_checkbox)
            
            # OK button
            button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
            button_box.accepted.connect(dialog.accept)
            layout.addWidget(button_box)
            
            dialog.exec()
            
            # Navigate to Settings ‚Üí Features tab
            self.main_tabs.setCurrentIndex(4)  # Settings tab
            if hasattr(self, 'settings_tabs'):
                # Find the Features tab index
                for i in range(self.settings_tabs.count()):
                    if "Features" in self.settings_tabs.tabText(i):
                        self.settings_tabs.setCurrentIndex(i)
                        break
            
            # Save the preference to general_settings.json (where load_general_settings reads from)
            if dont_show_checkbox.isChecked():
                settings = self.load_general_settings()
                settings['first_run_completed'] = True
                self.save_general_settings(settings)
                self.log("‚úÖ First-run welcome completed (won't show again)")
            else:
                self.log("‚úÖ First-run welcome shown (will show again next time)")
        except Exception as e:
            self.log(f"‚ö†Ô∏è First-run welcome error: {e}")

    def _show_setup_wizard(self, is_first_run: bool = False):
        """
        Show unified setup wizard that combines data folder selection and features intro.

        Args:
            is_first_run: If True, this is an automatic first-run trigger. If False, user
                          manually invoked from menu (skip data folder if already configured).
        """
        try:
            from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                                         QPushButton, QLineEdit, QFileDialog, QStackedWidget,
                                         QWidget, QFrame, QCheckBox)
            from PyQt6.QtCore import Qt

            dialog = QDialog(self)
            dialog.setWindowTitle("Supervertaler Setup Wizard")
            dialog.setMinimumWidth(600)
            dialog.setMinimumHeight(450)
            dialog.setModal(True)

            main_layout = QVBoxLayout(dialog)
            main_layout.setSpacing(15)
            main_layout.setContentsMargins(20, 20, 20, 20)

            # Stacked widget for wizard pages
            stacked = QStackedWidget()

            # Determine if we need to show data folder page
            show_data_folder_page = is_first_run and self._needs_data_location_dialog

            # ==================== PAGE 1: Data Folder Selection ====================
            page1 = QWidget()
            page1_layout = QVBoxLayout(page1)
            page1_layout.setSpacing(15)

            # Step indicator
            step1_indicator = QLabel("<span style='color: #888;'>Step 1 of 2</span>")
            page1_layout.addWidget(step1_indicator)

            # Title
            page1_title = QLabel("<h2>üìÅ Choose Your Data Folder</h2>")
            page1_layout.addWidget(page1_title)

            # Explanation
            page1_msg = QLabel(
                "Supervertaler stores your data in a folder of your choice:<br><br>"
                "‚Ä¢ <b>API keys</b> ‚Äì Your LLM provider credentials<br>"
                "‚Ä¢ <b>Translation memories</b> ‚Äì Reusable translation pairs<br>"
                "‚Ä¢ <b>Glossaries</b> ‚Äì Terminology databases<br>"
                "‚Ä¢ <b>Prompts</b> ‚Äì Custom AI prompts<br>"
                "‚Ä¢ <b>Settings</b> ‚Äì Application configuration<br><br>"
                "Choose a location that's easy to find and backup."
            )
            page1_msg.setWordWrap(True)
            page1_layout.addWidget(page1_msg)

            # Path input with browse button
            path_layout = QHBoxLayout()
            path_edit = QLineEdit()
            default_path = get_default_user_data_path()
            path_edit.setText(str(default_path))
            path_edit.setMinimumWidth(350)
            path_layout.addWidget(path_edit)

            browse_btn = QPushButton("Browse...")
            def browse_folder():
                folder = QFileDialog.getExistingDirectory(
                    dialog,
                    "Choose Data Folder",
                    str(Path.home())
                )
                if folder:
                    folder_path = Path(folder)
                    if folder_path.name != "Supervertaler":
                        folder_path = folder_path / "Supervertaler"
                    path_edit.setText(str(folder_path))

            browse_btn.clicked.connect(browse_folder)
            path_layout.addWidget(browse_btn)
            page1_layout.addLayout(path_layout)

            # Tip
            page1_tip = QLabel(
                "üí° <b>Tip:</b> The default location is in your home folder, "
                "making it easy to find and backup."
            )
            page1_tip.setWordWrap(True)
            page1_tip.setStyleSheet("color: #666;")
            page1_layout.addWidget(page1_tip)

            page1_layout.addStretch()
            stacked.addWidget(page1)

            # ==================== PAGE 2: Features Introduction ====================
            page2 = QWidget()
            page2_layout = QVBoxLayout(page2)
            page2_layout.setSpacing(15)

            # Step indicator
            step2_label = "Step 2 of 2" if show_data_folder_page else "Setup"
            step2_indicator = QLabel(f"<span style='color: #888;'>{step2_label}</span>")
            page2_layout.addWidget(step2_indicator)

            # Data folder info (shown when skipping page 1)
            if not show_data_folder_page:
                from PyQt6.QtGui import QDesktopServices
                from PyQt6.QtCore import QUrl

                data_folder_path = str(self.user_data_path)
                data_folder_info = QLabel(
                    f"<b>üìÅ Data Folder:</b> <a href='file:///{data_folder_path}' "
                    f"style='color: #3b82f6;'>{data_folder_path}</a><br>"
                    "<span style='color: #666; font-size: 0.9em;'>"
                    "Your settings, TMs, glossaries and prompts are stored here. "
                    "Change in Settings ‚Üí General.</span>"
                )
                data_folder_info.setWordWrap(True)
                data_folder_info.setTextFormat(Qt.TextFormat.RichText)
                data_folder_info.setOpenExternalLinks(False)  # Handle clicks ourselves
                data_folder_info.linkActivated.connect(
                    lambda url: QDesktopServices.openUrl(QUrl.fromLocalFile(data_folder_path))
                )
                data_folder_info.setStyleSheet(
                    "background: #f0f4ff; padding: 12px; border-radius: 6px; "
                    "border-left: 4px solid #3b82f6; margin-bottom: 10px;"
                )
                page2_layout.addWidget(data_folder_info)

            # Title
            page2_title = QLabel("<h2>‚ú® Modular Features</h2>")
            page2_layout.addWidget(page2_title)

            # Message
            page2_msg = QLabel(
                "Supervertaler uses a <b>modular architecture</b> ‚Äì you can install "
                "only the features you need.<br><br>"
                "<b>Core features</b> (always available):<br>"
                "‚Ä¢ AI translation with OpenAI, Claude, Gemini, Ollama<br>"
                "‚Ä¢ Translation Memory and Glossaries<br>"
                "‚Ä¢ XLIFF, SDLXLIFF, memoQ support<br>"
                "‚Ä¢ Basic spellchecking<br><br>"
                "<b>Optional features</b> (install via pip):<br>"
                "‚Ä¢ <code>openai-whisper</code> ‚Äì Local voice dictation (no API needed)<br><br>"
                "You can view and manage features in <b>Settings ‚Üí Features</b>."
            )
            page2_msg.setWordWrap(True)
            page2_msg.setTextFormat(Qt.TextFormat.RichText)
            page2_layout.addWidget(page2_msg)

            # Checkbox
            dont_show_checkbox = CheckmarkCheckBox("Don't show this wizard on startup")
            dont_show_checkbox.setChecked(True)
            page2_layout.addWidget(dont_show_checkbox)

            # Open Features tab checkbox
            open_features_checkbox = CheckmarkCheckBox("Open Features tab after closing")
            open_features_checkbox.setChecked(True)
            page2_layout.addWidget(open_features_checkbox)

            page2_layout.addStretch()
            stacked.addWidget(page2)

            main_layout.addWidget(stacked)

            # ==================== Navigation Buttons ====================
            nav_layout = QHBoxLayout()

            back_btn = QPushButton("‚Üê Back")
            back_btn.setVisible(False)  # Hidden on first page

            next_btn = QPushButton("Next ‚Üí")
            finish_btn = QPushButton("Finish")
            finish_btn.setVisible(False)
            finish_btn.setDefault(True)

            # Use Default button (only on page 1)
            default_btn = QPushButton("Use Default")
            default_btn.clicked.connect(lambda: path_edit.setText(str(default_path)))

            nav_layout.addWidget(default_btn)
            nav_layout.addStretch()
            nav_layout.addWidget(back_btn)
            nav_layout.addWidget(next_btn)
            nav_layout.addWidget(finish_btn)

            main_layout.addLayout(nav_layout)

            # Track chosen path for later
            chosen_path_holder = [None]

            def go_to_page(page_index):
                stacked.setCurrentIndex(page_index)
                if page_index == 0:
                    back_btn.setVisible(False)
                    next_btn.setVisible(True)
                    finish_btn.setVisible(False)
                    default_btn.setVisible(True)
                else:
                    back_btn.setVisible(show_data_folder_page)
                    next_btn.setVisible(False)
                    finish_btn.setVisible(True)
                    default_btn.setVisible(False)

            def on_next():
                # Save the data folder choice
                chosen_path = Path(path_edit.text())
                chosen_path_holder[0] = chosen_path

                # Create the folder and save config
                chosen_path.mkdir(parents=True, exist_ok=True)
                save_user_data_path(chosen_path)

                # Update our path if different
                if chosen_path != self.user_data_path:
                    self.user_data_path = chosen_path
                    self._reinitialize_with_new_data_path()
                else:
                    if hasattr(self, 'db_manager') and self.db_manager and not self.db_manager.connection:
                        self.db_manager.connect()

                self.log(f"üìÅ Data folder set to: {chosen_path}")
                go_to_page(1)

            def on_back():
                go_to_page(0)

            def on_finish():
                # Save first_run preference
                if dont_show_checkbox.isChecked():
                    settings = self.load_general_settings()
                    settings['first_run_completed'] = True
                    self.save_general_settings(settings)
                    self.log("‚úÖ Setup wizard completed (won't show again on startup)")
                else:
                    self.log("‚úÖ Setup wizard shown (will show again next time)")

                dialog.accept()

                # Navigate to Features tab if checkbox is checked
                if open_features_checkbox.isChecked():
                    self.main_tabs.setCurrentIndex(4)  # Settings tab
                    if hasattr(self, 'settings_tabs'):
                        for i in range(self.settings_tabs.count()):
                            if "Features" in self.settings_tabs.tabText(i):
                                self.settings_tabs.setCurrentIndex(i)
                                break

            back_btn.clicked.connect(on_back)
            next_btn.clicked.connect(on_next)
            finish_btn.clicked.connect(on_finish)

            # Start on appropriate page
            if show_data_folder_page:
                go_to_page(0)
            else:
                # Skip to features page if data folder already configured
                go_to_page(1)
                step2_indicator.setText("<span style='color: #888;'>Supervertaler Setup</span>")

            dialog.exec()

        except Exception as e:
            self.log(f"‚ö†Ô∏è Setup wizard error: {e}")
            import traceback
            traceback.print_exc()

    def _check_for_new_models(self, force: bool = False):
        """
        Check for new LLM models from providers

        Args:
            force: Force check even if checked recently
        """
        try:
            from modules.model_version_checker import ModelVersionChecker
            from modules.model_update_dialog import ModelUpdateDialog, NoNewModelsDialog
            from modules.llm_clients import load_api_keys

            # Load API keys
            api_keys = load_api_keys()

            # Initialize checker with cache in user_data
            cache_path = self.user_data_path / "model_version_cache.json"
            checker = ModelVersionChecker(cache_path=str(cache_path))

            # Check if we should run (unless forced)
            if not force and not checker.should_check():
                # Already checked recently
                return

            self.log("üîç Checking for new LLM models...")

            # Run the check
            results = checker.check_all_providers(
                openai_key=api_keys.get("OPENAI_API_KEY"),
                anthropic_key=api_keys.get("ANTHROPIC_API_KEY"),
                google_key=api_keys.get("GOOGLE_API_KEY"),
                force=force
            )

            # If this was a forced manual check, log the results
            if force:
                self.log(f"  OpenAI: {len(results.get('openai', {}).get('new_models', []))} new models")
                self.log(f"  Claude: {len(results.get('claude', {}).get('new_models', []))} new models")
                self.log(f"  Gemini: {len(results.get('gemini', {}).get('new_models', []))} new models")

            # Check if any new models found
            if checker.has_new_models(results):
                self.log(f"‚ú® New models detected! Opening dialog...")

                # Show dialog with new models
                dialog = ModelUpdateDialog(results, parent=self)
                dialog.models_selected.connect(self._on_new_models_selected)
                dialog.exec()

            else:
                # No new models
                if force:
                    # Only show "no new models" dialog for manual checks
                    cache_info = checker.get_cache_info()
                    dialog = NoNewModelsDialog(
                        last_check=cache_info.get('last_check'),
                        parent=self
                    )
                    dialog.exec()
                else:
                    # Silent for automatic checks
                    self.log("‚úì No new models detected")

        except ImportError as e:
            self.log(f"‚ö† Could not check for new models: Missing dependencies ({e})")
        except Exception as e:
            self.log(f"‚ö† Error checking for new models: {e}")
            if force:
                # Show error dialog for manual checks
                from PyQt6.QtWidgets import QMessageBox
                QMessageBox.warning(
                    self,
                    "Model Check Error",
                    f"Failed to check for new models:\n\n{str(e)}"
                )

    def _on_new_models_selected(self, selected_models: dict):
        """
        Handle user selection of new models to add

        Args:
            selected_models: Dict of {provider: [model_ids]}
        """
        try:
            # Update the known models in llm_clients.py
            # For now, just log what would be added
            self.log("üì¶ Adding selected models to Supervertaler:")

            for provider, models in selected_models.items():
                if models:
                    self.log(f"  {provider.capitalize()}: {len(models)} model(s)")
                    for model in models:
                        self.log(f"    ‚Ä¢ {model}")

            # TODO: Actually add the models to the configuration
            # This would require modifying llm_clients.py or a separate config file
            # For now, just show a message
            from PyQt6.QtWidgets import QMessageBox
            QMessageBox.information(
                self,
                "Models Added",
                f"Selected models have been noted:\n\n"
                f"{sum(len(m) for m in selected_models.values())} model(s) from "
                f"{len(selected_models)} provider(s)\n\n"
                f"These models will be available after restarting Supervertaler.\n\n"
                f"Note: You may need to manually add them to Settings ‚Üí AI Settings for now."
            )

        except Exception as e:
            self.log(f"‚ùå Error adding models: {e}")

    def init_ui(self):
        """Initialize the user interface"""
        # Build window title with dev mode indicator
        title = f"Supervertaler v{__version__}"
        if ENABLE_PRIVATE_FEATURES:
            title += " [üõ†Ô∏è DEV MODE]"
        self.setWindowTitle(title)
        self.setGeometry(100, 100, 1400, 800)

        # Set application icon
        from PyQt6.QtGui import QIcon
        icon_path = get_resource_path("assets/icon.ico")
        if icon_path.exists():
            self.setWindowIcon(QIcon(str(icon_path)))

        # Ensure window can be resized (no minimum size constraint)
        self.setMinimumSize(400, 300)  # Very small minimum to allow resizing
        
        # Create menu bar (ribbon removed - using traditional menus)
        self.create_menus()
        
        # Ribbon removed - all functionality moved to menu bar
        # self.create_ribbon()
        
        # Create main layout
        self.create_main_layout()
        
        # Create status bar with progress indicators
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")
        
        # Add permanent progress widgets to status bar (right side)
        self._setup_progress_indicators()

        # Setup global shortcuts
        self.setup_global_shortcuts()

    def setup_global_shortcuts(self):
        """Setup application-wide keyboard shortcuts"""
        from PyQt6.QtGui import QShortcut
        
        # Store all shortcuts with their IDs and default key sequences for enable/disable management
        self.global_shortcuts = {}  # shortcut_id -> QShortcut
        self.global_shortcut_keys = {}  # shortcut_id -> current key sequence string (from manager)
        
        def create_shortcut(shortcut_id: str, default_key: str, handler):
            """Create a shortcut, using custom key from manager if set, respecting enabled state"""
            # Get the actual key sequence (custom or default) from the manager
            key_sequence = self.shortcut_manager.get_shortcut(shortcut_id)
            # Important: an empty string is a valid "unassigned" default.
            # Only fall back to the passed default_key if the shortcut ID is unknown to the manager.
            if key_sequence == "":
                default_ids = getattr(self.shortcut_manager, 'DEFAULT_SHORTCUTS', {})
                custom_ids = getattr(self.shortcut_manager, 'custom_shortcuts', {})
                if shortcut_id not in default_ids and shortcut_id not in custom_ids:
                    key_sequence = default_key
            
            shortcut = QShortcut(QKeySequence(key_sequence), self)
            shortcut.activated.connect(handler)
            # Store the current key sequence for re-enabling later
            self.global_shortcut_keys[shortcut_id] = key_sequence
            # If disabled, clear the key sequence to fully release the key combination
            if not self.shortcut_manager.is_enabled(shortcut_id):
                shortcut.setKey(QKeySequence())  # Clear key to release combination
            self.global_shortcuts[shortcut_id] = shortcut
            return shortcut

        # F9 - Voice dictation
        create_shortcut("voice_dictate", "F9", self.start_voice_dictation)
        
        # Ctrl+Up/Down - Cycle through translation matches
        create_shortcut("match_cycle_previous", "Ctrl+Up", self.select_previous_match)
        create_shortcut("match_cycle_next", "Ctrl+Down", self.select_next_match)
        
        # Ctrl+1 through Ctrl+9 - Insert match by number
        self.match_shortcuts = []
        for i in range(1, 10):
            shortcut_id = f"match_insert_{i}"
            default_key = f"Ctrl+{i}"
            key_sequence = self.shortcut_manager.get_shortcut(shortcut_id)
            # Respect intentionally blank defaults (unassigned shortcuts)
            if key_sequence == "":
                default_ids = getattr(self.shortcut_manager, 'DEFAULT_SHORTCUTS', {})
                custom_ids = getattr(self.shortcut_manager, 'custom_shortcuts', {})
                if shortcut_id not in default_ids and shortcut_id not in custom_ids:
                    key_sequence = default_key
            shortcut = QShortcut(QKeySequence(key_sequence), self)
            shortcut.activated.connect(lambda num=i: self.insert_match_by_number(num))
            self.global_shortcut_keys[shortcut_id] = key_sequence
            if not self.shortcut_manager.is_enabled(shortcut_id):
                shortcut.setKey(QKeySequence())  # Clear key to release combination
            self.global_shortcuts[shortcut_id] = shortcut
            self.match_shortcuts.append(shortcut)

        # Compare Panel insertion shortcut
        # Alt+0 inserts MT; double-tap Alt+0,0 inserts TM Target.
        self._compare_panel_last_key = None
        self._compare_panel_last_time = 0
        create_shortcut("compare_insert_alt0", "Alt+0", self._handle_compare_panel_alt0_shortcut)

        # Compare Panel navigation shortcuts
        # MT prev/next: Ctrl+Alt+Left / Ctrl+Alt+Right
        # TM prev/next: Ctrl+Alt+Up / Ctrl+Alt+Down
        create_shortcut(
            "compare_nav_mt_prev",
            "Ctrl+Alt+Left",
            lambda: self._compare_panel_nav_mt(-1) if self._get_active_match_shortcut_mode() == 'compare' else None,
        )
        create_shortcut(
            "compare_nav_mt_next",
            "Ctrl+Alt+Right",
            lambda: self._compare_panel_nav_mt(1) if self._get_active_match_shortcut_mode() == 'compare' else None,
        )
        create_shortcut(
            "compare_nav_tm_prev",
            "Ctrl+Alt+Up",
            lambda: self._compare_panel_nav_tm(-1) if self._get_active_match_shortcut_mode() == 'compare' else None,
        )
        create_shortcut(
            "compare_nav_tm_next",
            "Ctrl+Alt+Down",
            lambda: self._compare_panel_nav_tm(1) if self._get_active_match_shortcut_mode() == 'compare' else None,
        )
        
        # Alt+0 through Alt+9 - Insert term from TermView by number
        # Supports double-tap for terms 11-20 (00, 11, 22, ..., 99)
        self.termview_shortcuts = []
        self._termview_last_key = None  # Track last key for double-tap detection
        self._termview_last_time = 0    # Track timing for double-tap
        
        # Double-tap Shift detection for context menu
        self._shift_last_press_time = 0
        self._shift_double_tap_threshold = 0.35  # 350ms window
        
        for i in range(0, 10):  # 0-9
            shortcut_id = f"termview_insert_{i}"
            default_key = f"Alt+{i}"
            key_sequence = self.shortcut_manager.get_shortcut(shortcut_id)
            # Respect intentionally blank defaults (unassigned shortcuts)
            if key_sequence == "":
                default_ids = getattr(self.shortcut_manager, 'DEFAULT_SHORTCUTS', {})
                custom_ids = getattr(self.shortcut_manager, 'custom_shortcuts', {})
                if shortcut_id not in default_ids and shortcut_id not in custom_ids:
                    key_sequence = default_key
            shortcut = QShortcut(QKeySequence(key_sequence), self)
            shortcut.activated.connect(lambda num=i: self._handle_termview_shortcut(num))
            self.global_shortcut_keys[shortcut_id] = key_sequence
            if not self.shortcut_manager.is_enabled(shortcut_id):
                shortcut.setKey(QKeySequence())  # Clear key to release combination
            self.global_shortcuts[shortcut_id] = shortcut
            self.termview_shortcuts.append(shortcut)
        
        # Ctrl+Space - Insert currently selected match
        create_shortcut("match_insert_selected_ctrl", "Ctrl+Space", self.insert_selected_match)
        
        # Alt+Up/Down - Navigate to previous/next segment
        create_shortcut("segment_previous", "Alt+Up", self.go_to_previous_segment)
        create_shortcut("segment_next", "Alt+Down", self.go_to_next_segment)
        
        # Ctrl+Home/End - Navigate to first/last segment
        create_shortcut("segment_go_to_top", "Ctrl+Home", self.go_to_first_segment)
        create_shortcut("segment_go_to_bottom", "Ctrl+End", self.go_to_last_segment)
        
        # Ctrl+Enter - Confirm segment(s) and go to next unconfirmed
        # If multiple segments selected: confirm all selected
        # If single segment: confirm and go to next unconfirmed
        ctrl_enter_shortcut = create_shortcut("editor_save_and_next", "Ctrl+Return", self.confirm_selected_or_next)
        # CRITICAL: Use ApplicationShortcut context so it works even when focus is in QTextEdit widgets
        ctrl_enter_shortcut.setContext(Qt.ShortcutContext.ApplicationShortcut)

        # Workaround: ensure Ctrl+Return (main keyboard) is caught even if swallowed before QShortcut
        # (Observed: Ctrl+Enter on numpad works, Ctrl+Return does not when focus is in source cell.)
        if not hasattr(self, '_ctrl_return_event_filter'):
            from PyQt6.QtWidgets import QApplication
            self._ctrl_return_event_filter = _CtrlReturnEventFilter(self)
            QApplication.instance().installEventFilter(self._ctrl_return_event_filter)
        
        # Note: Double-tap Shift for context menu is handled by AutoHotkey (double_shift_menu.ahk)
        # Qt's event system makes reliable double-tap detection difficult in Python
        
        # Ctrl+Shift+Enter - Always confirm all selected segments
        create_shortcut("editor_confirm_selected", "Ctrl+Shift+Return", self.confirm_selected_segments)
        
        # Note: Ctrl+Shift+S (Copy source to target) is handled in EditableGridTextEditor.keyPressEvent
        
        # Ctrl+K - Concordance Search
        create_shortcut("tools_concordance_search", "Ctrl+K", self.show_concordance_search)
        
        # Ctrl+Shift+F - Filter on selected text / Clear filter (toggle)
        create_shortcut("filter_selected_text", "Ctrl+Shift+F", self.filter_on_selected_text)
        
        # Ctrl+Alt+T - Toggle Tag View
        create_shortcut("view_toggle_tags", "Ctrl+Alt+T", self._toggle_tag_view_via_shortcut)
        
        # Page Up/Down - Navigate pagination pages
        create_shortcut("page_prev", "PgUp", self.go_to_prev_page)
        create_shortcut("page_next", "PgDown", self.go_to_next_page)
        
        # Shift+Page Up/Down - Select range of segments
        create_shortcut("select_range_up", "Shift+PgUp", self.select_range_page_up)
        create_shortcut("select_range_down", "Shift+PgDown", self.select_range_page_down)
        
        # Ctrl+G - Go to segment
        create_shortcut("edit_goto", "Ctrl+G", self.show_goto_dialog)
        
        # F5 - Force refresh matches (clear all caches and re-search)
        create_shortcut("tools_force_refresh", "F5", self.force_refresh_matches)
        
        # Ctrl+Shift+1 - Quick add term with Priority 1
        create_shortcut("editor_quick_add_priority_1", "Ctrl+Shift+1", lambda: self._quick_add_term_with_priority(1))
        
        # Ctrl+Shift+2 - Quick add term with Priority 2
        create_shortcut("editor_quick_add_priority_2", "Ctrl+Shift+2", lambda: self._quick_add_term_with_priority(2))
        
        # Alt+D - Add word at cursor to dictionary
        create_shortcut("editor_add_to_dictionary", "Alt+D", self.add_word_to_dictionary_shortcut)
        
        # Ctrl+N - Focus Segment Note tab
        create_shortcut("editor_focus_notes", "Ctrl+N", self.focus_segment_notes)
        
        # Alt+K - Open QuickMenu directly
        create_shortcut("editor_open_quickmenu", "Alt+K", self.open_quickmenu)
    
    def focus_segment_notes(self):
        """Switch to Segment Note tab and focus the notes editor so user can start typing immediately"""
        if not hasattr(self, 'right_tabs'):
            return
        
        # Find the Segment Note tab in right_tabs by looking for the tab with "Segment note" in its text
        for i in range(self.right_tabs.count()):
            if "Segment note" in self.right_tabs.tabText(i):
                self.right_tabs.setCurrentIndex(i)
                break
        
        # Focus the notes editor so user can start typing
        if hasattr(self, 'bottom_notes_edit'):
            self.bottom_notes_edit.setFocus()
    
    def open_quickmenu(self):
        """Open QuickMenu popup at current cursor position for quick AI prompt selection.
        
        User can navigate with arrow keys and press Enter to select a prompt.
        """
        try:
            # Get QuickMenu items from prompt library
            quickmenu_items = []
            if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                lib = getattr(self.prompt_manager_qt, 'library', None)
                if lib and hasattr(lib, 'get_quickmenu_grid_prompts'):
                    quickmenu_items = lib.get_quickmenu_grid_prompts() or []
            
            if not quickmenu_items:
                self.log("‚ö†Ô∏è No QuickMenu prompts available. Add prompts with 'Show in QuickMenu' enabled.")
                return
            
            # Find the currently focused widget (source or target cell)
            focus_widget = QApplication.focusWidget()
            
            # Build the menu
            menu = QMenu(self)
            menu.setTitle("‚ö° QuickMenu")
            
            for rel_path, label in sorted(quickmenu_items, key=lambda x: (x[1] or x[0]).lower()):
                prompt_menu = menu.addMenu(label or rel_path)
                
                run_show = QAction("‚ñ∂ Run (show response)‚Ä¶", self)
                run_show.triggered.connect(
                    lambda checked=False, p=rel_path, w=focus_widget: self.run_grid_quickmenu_prompt(p, origin_widget=w, behavior="show")
                )
                prompt_menu.addAction(run_show)
                
                run_replace = QAction("‚Ü∫ Run and replace target selection", self)
                run_replace.triggered.connect(
                    lambda checked=False, p=rel_path, w=focus_widget: self.run_grid_quickmenu_prompt(p, origin_widget=w, behavior="replace")
                )
                prompt_menu.addAction(run_replace)
            
            # Show menu at cursor position (or center of focused widget)
            if focus_widget:
                # Get cursor rectangle if it's a text editor
                if hasattr(focus_widget, 'cursorRect'):
                    cursor_rect = focus_widget.cursorRect()
                    pos = focus_widget.mapToGlobal(cursor_rect.bottomLeft())
                else:
                    # Fallback to center of widget
                    pos = focus_widget.mapToGlobal(focus_widget.rect().center())
            else:
                # Fallback to mouse cursor position
                pos = QCursor.pos()
            
            menu.exec(pos)
            
        except Exception as e:
            self.log(f"‚ùå Error opening QuickMenu: {e}")
    
    def refresh_shortcut_enabled_states(self):
        """Refresh enabled/disabled states and key bindings of all global shortcuts from shortcut manager.
        
        When disabled: clears the key sequence to fully release the key combination.
        When enabled: restores the key sequence from the manager (custom or default).
        """
        if not hasattr(self, 'global_shortcuts'):
            return
        for shortcut_id, shortcut in self.global_shortcuts.items():
            is_enabled = self.shortcut_manager.is_enabled(shortcut_id)
            if is_enabled:
                # Get the current key sequence from manager (may have been customized)
                key_sequence = self.shortcut_manager.get_shortcut(shortcut_id)
                if key_sequence:
                    self.global_shortcut_keys[shortcut_id] = key_sequence
                    shortcut.setKey(QKeySequence(key_sequence))
            else:
                # Clear the key to release the combination for other uses
                shortcut.setKey(QKeySequence())

    def _setup_progress_indicators(self):
        """Setup permanent progress indicator widgets in the status bar"""
        from PyQt6.QtWidgets import QLabel, QFrame

        # Create a container frame for all progress info
        progress_frame = QFrame()
        progress_layout = QHBoxLayout(progress_frame)
        progress_layout.setContentsMargins(0, 0, 10, 0)
        progress_layout.setSpacing(20)

        # LLM Provider/Model indicator (leftmost in the permanent area)
        self.llm_indicator_label = QLabel("")
        self.llm_indicator_label.setStyleSheet("color: #888; font-size: 11px;")
        self.llm_indicator_label.setToolTip("Current LLM provider and model")
        progress_layout.addWidget(self.llm_indicator_label)
        
        # Update LLM indicator on startup
        self._update_llm_indicator()

        # Words translated label
        self.progress_words_label = QLabel("Words: --")
        self.progress_words_label.setStyleSheet("color: #555; font-size: 11px;")
        self.progress_words_label.setToolTip("Words with translation / Total words (percentage)")
        progress_layout.addWidget(self.progress_words_label)

        # Segments confirmed label
        self.progress_confirmed_label = QLabel("Confirmed: --")
        self.progress_confirmed_label.setStyleSheet("color: #555; font-size: 11px;")
        self.progress_confirmed_label.setToolTip("Confirmed segments / Total segments (percentage)")
        progress_layout.addWidget(self.progress_confirmed_label)

        # Remaining segments label
        self.progress_remaining_label = QLabel("Remaining: --")
        self.progress_remaining_label.setStyleSheet("color: #555; font-size: 11px;")
        self.progress_remaining_label.setToolTip("Segments still requiring work")
        progress_layout.addWidget(self.progress_remaining_label)
        
        # Files indicator (for multi-file projects)
        self.progress_files_label = QLabel("")
        self.progress_files_label.setStyleSheet("color: #2196F3; font-size: 11px;")
        self.progress_files_label.setToolTip("Files in multi-file project (click for details)")
        self.progress_files_label.setCursor(Qt.CursorShape.PointingHandCursor)
        self.progress_files_label.mousePressEvent = lambda e: self.show_file_progress_dialog()
        self.progress_files_label.hide()  # Hidden by default, shown for multi-file projects
        progress_layout.addWidget(self.progress_files_label)
        
        # Always-on voice indicator
        self.alwayson_indicator_label = QLabel("")
        self.alwayson_indicator_label.setStyleSheet("font-size: 11px; font-weight: bold;")
        self.alwayson_indicator_label.setToolTip("Always-on voice listening status\nClick to toggle")
        self.alwayson_indicator_label.setCursor(Qt.CursorShape.PointingHandCursor)
        self.alwayson_indicator_label.mousePressEvent = lambda e: self._toggle_alwayson_from_statusbar()
        self.alwayson_indicator_label.hide()  # Hidden until enabled
        progress_layout.addWidget(self.alwayson_indicator_label)

        # Add as permanent widget (stays on right side)
        self.status_bar.addPermanentWidget(progress_frame)
        
        # Initialize Ollama keep-warm timer
        self.ollama_keepwarm_timer = None
        self._setup_ollama_keepwarm()
    
    def _update_llm_indicator(self):
        """Update the LLM provider/model indicator in the status bar"""
        try:
            settings = self.load_llm_settings()
            provider = settings.get('provider', 'openai')
            model_key = f'{provider}_model'
            model = settings.get(model_key, 'gpt-4o')
            
            # Format nicely
            if provider == 'ollama':
                icon = "üñ•Ô∏è"
                display = f"{icon} Local: {model}"
            elif provider == 'openai':
                icon = "ü§ñ"
                display = f"{icon} {model}"
            elif provider == 'claude':
                icon = "üü£"
                display = f"{icon} {model}"
            elif provider == 'gemini':
                icon = "üíé"
                display = f"{icon} {model}"
            else:
                display = f"{provider}: {model}"
            
            if hasattr(self, 'llm_indicator_label'):
                self.llm_indicator_label.setText(display)
                self.llm_indicator_label.setToolTip(f"LLM Provider: {provider.title()}\nModel: {model}")
        except Exception as e:
            if hasattr(self, 'llm_indicator_label'):
                self.llm_indicator_label.setText("")
    
    def _setup_ollama_keepwarm(self):
        """Setup timer to keep Ollama model warm (loaded in memory)"""
        from PyQt6.QtCore import QTimer
        
        # Check settings to see if keep-warm is enabled
        general_settings = self.load_general_settings()
        keepwarm_enabled = general_settings.get('ollama_keepwarm', False)
        
        if keepwarm_enabled:
            self._start_ollama_keepwarm_timer()
    
    def _start_ollama_keepwarm_timer(self):
        """Start the Ollama keep-warm timer (pings every 4 minutes)"""
        from PyQt6.QtCore import QTimer
        
        if self.ollama_keepwarm_timer is None:
            self.ollama_keepwarm_timer = QTimer(self)
            self.ollama_keepwarm_timer.timeout.connect(self._ping_ollama_keepwarm)
        
        # Ping every 4 minutes (Ollama unloads after 5 min of inactivity)
        self.ollama_keepwarm_timer.start(4 * 60 * 1000)  # 4 minutes in ms
        self.log("üî• Ollama keep-warm enabled (pinging every 4 minutes)")
    
    def _stop_ollama_keepwarm_timer(self):
        """Stop the Ollama keep-warm timer"""
        if self.ollama_keepwarm_timer:
            self.ollama_keepwarm_timer.stop()
            self.log("‚ùÑÔ∏è Ollama keep-warm disabled")
    
    def _ping_ollama_keepwarm(self):
        """Send a minimal request to Ollama to keep the model loaded"""
        import threading
        
        def ping():
            try:
                import requests
                settings = self.load_llm_settings()
                if settings.get('provider') != 'ollama':
                    return
                
                model = settings.get('ollama_model', 'qwen2.5:7b')
                endpoint = "http://localhost:11434"
                
                # Send minimal request to keep model warm
                response = requests.post(
                    f"{endpoint}/api/generate",
                    json={
                        "model": model,
                        "prompt": "hi",
                        "options": {"num_predict": 1}  # Generate just 1 token
                    },
                    timeout=30
                )
                if response.status_code == 200:
                    print(f"üî• Ollama keep-warm ping successful ({model})")
            except Exception as e:
                print(f"‚ö†Ô∏è Ollama keep-warm ping failed: {e}")
        
        # Run in background thread to not block UI
        threading.Thread(target=ping, daemon=True).start()

    def update_progress_stats(self):
        """Update the progress indicator labels in the status bar"""
        try:
            if not self.current_project or not self.current_project.segments:
                self.progress_words_label.setText("Words: --")
                self.progress_confirmed_label.setText("Confirmed: --")
                self.progress_remaining_label.setText("Remaining: --")
                if hasattr(self, 'progress_files_label'):
                    self.progress_files_label.hide()
                return

            segments = self.current_project.segments
            total_segments = len(segments)

            # Count words in source text for each segment
            total_words = 0
            translated_words = 0
            confirmed_count = 0
            remaining_count = 0

            # Statuses that indicate "done" (confirmed or higher)
            confirmed_statuses = {'confirmed', 'tr_confirmed', 'proofread', 'approved'}
            # Statuses that need work
            unfinished_statuses = {'not_started', 'pretranslated', 'rejected'}

            for segment in segments:
                # Count words in source (simple split on whitespace)
                source_words = len(segment.source.split()) if segment.source else 0
                total_words += source_words

                # If segment has a non-empty translation, count those words as translated
                if segment.target and segment.target.strip():
                    translated_words += source_words

                # Count confirmed (or higher status)
                if segment.status in confirmed_statuses:
                    confirmed_count += 1

                # Count remaining (not_started, pretranslated, or rejected)
                if segment.status in unfinished_statuses:
                    remaining_count += 1

            # Calculate percentages
            word_percent = (translated_words / total_words * 100) if total_words > 0 else 0
            confirmed_percent = (confirmed_count / total_segments * 100) if total_segments > 0 else 0

            # Update labels with color-coding based on progress
            word_color = self._get_progress_color(word_percent)
            confirmed_color = self._get_progress_color(confirmed_percent)
            remaining_color = "#c00" if remaining_count > 0 else "#080"

            self.progress_words_label.setText(f"Words: {translated_words}/{total_words} ({word_percent:.0f}%)")
            self.progress_words_label.setStyleSheet(f"color: {word_color}; font-size: 11px;")

            self.progress_confirmed_label.setText(f"Confirmed: {confirmed_count}/{total_segments} ({confirmed_percent:.0f}%)")
            self.progress_confirmed_label.setStyleSheet(f"color: {confirmed_color}; font-size: 11px;")

            self.progress_remaining_label.setText(f"Remaining: {remaining_count}")
            self.progress_remaining_label.setStyleSheet(f"color: {remaining_color}; font-size: 11px;")
            
            # Multi-file project indicator
            if hasattr(self, 'progress_files_label'):
                is_multifile = getattr(self.current_project, 'is_multifile', False)
                files = getattr(self.current_project, 'files', [])
                
                if is_multifile and files:
                    # Count completed files
                    completed_files = 0
                    for file_info in files:
                        file_id = file_info['id']
                        file_segs = [s for s in segments if getattr(s, 'file_id', None) == file_id]
                        if file_segs:
                            conf_count = sum(1 for s in file_segs if s.status in confirmed_statuses)
                            if conf_count == len(file_segs):
                                completed_files += 1
                    
                    self.progress_files_label.setText(f"üìÅ Files: {completed_files}/{len(files)}")
                    self.progress_files_label.setToolTip(
                        f"Multi-file project: {len(files)} files\n"
                        f"Completed: {completed_files} files\n\n"
                        "Click for detailed file progress"
                    )
                    self.progress_files_label.show()
                else:
                    self.progress_files_label.hide()

        except Exception as e:
            self.log(f"‚ö†Ô∏è Error updating progress stats: {e}")

    def _get_progress_color(self, percent: float) -> str:
        """Get color for progress percentage: red < 50%, orange < 80%, green >= 80%"""
        if percent < 50:
            return "#c00"  # Red
        elif percent < 80:
            return "#c60"  # Orange
        else:
            return "#080"  # Green

    def create_menus(self):
        """Create application menus"""
        menubar = self.menuBar()
        
        # File Menu
        file_menu = menubar.addMenu("&File")
        
        new_action = QAction("&New Project", self)
        new_action.setShortcut(QKeySequence.StandardKey.New)
        new_action.triggered.connect(self.new_project)
        file_menu.addAction(new_action)
        
        open_action = QAction("&Open Project...", self)
        open_action.setShortcut(QKeySequence.StandardKey.Open)
        open_action.triggered.connect(self.open_project)
        file_menu.addAction(open_action)
        
        # Recent projects submenu
        self.recent_menu = file_menu.addMenu("Open &Recent")
        self.update_recent_menu()
        
        file_menu.addSeparator()
        
        save_action = QAction("&Save", self)
        save_action.setShortcut(QKeySequence.StandardKey.Save)
        save_action.triggered.connect(self.save_project)
        file_menu.addAction(save_action)
        
        save_as_action = QAction("Save &As...", self)
        # No keyboard shortcut - Ctrl+Shift+S is used for Copy Source to Target in editor
        save_as_action.triggered.connect(self.save_project_as)
        file_menu.addAction(save_as_action)
        
        file_menu.addSeparator()
        
        close_action = QAction("&Close Project", self)
        close_action.triggered.connect(self.close_project)
        file_menu.addAction(close_action)
        
        file_menu.addSeparator()
        
        # Import/Export submenu
        import_menu = file_menu.addMenu("&Import")
        
        import_docx_action = QAction("&Monolingual Document (DOCX)...", self)
        import_docx_action.triggered.connect(self.import_docx)
        import_docx_action.setShortcut("Ctrl+O")
        import_menu.addAction(import_docx_action)
        
        import_txt_action = QAction("&Text / Markdown File (TXT, MD)...", self)
        import_txt_action.triggered.connect(self.import_simple_txt)
        import_menu.addAction(import_txt_action)
        
        import_menu.addSeparator()
        
        # Multi-file folder import
        import_folder_action = QAction("üìÅ &Folder (Multiple Files)...", self)
        import_folder_action.triggered.connect(self.import_folder_multifile)
        import_menu.addAction(import_folder_action)
        
        import_menu.addSeparator()  # Separate monolingual from bilingual tools
        
        import_memoq_action = QAction("memoQ &Bilingual Table (DOCX)...", self)
        import_memoq_action.triggered.connect(self.import_memoq_bilingual)
        import_menu.addAction(import_memoq_action)
        
        import_memoq_xliff_action = QAction("memoQ &XLIFF (.mqxliff)...", self)
        import_memoq_xliff_action.triggered.connect(self.import_memoq_xliff)
        import_menu.addAction(import_memoq_xliff_action)
        
        import_cafetran_action = QAction("&CafeTran Bilingual Table (DOCX)...", self)
        import_cafetran_action.triggered.connect(self.import_cafetran_bilingual)
        import_menu.addAction(import_cafetran_action)
        
        # Trados submenu - group all Trados imports together
        trados_submenu = import_menu.addMenu("&Trados Studio")

        import_trados_bilingual_action = QAction("Bilingual &Review (DOCX)...", self)
        import_trados_bilingual_action.triggered.connect(self.import_trados_bilingual)
        trados_submenu.addAction(import_trados_bilingual_action)

        import_sdlppx_action = QAction("&Package (SDLPPX)...", self)
        import_sdlppx_action.triggered.connect(self.import_sdlppx_package)
        trados_submenu.addAction(import_sdlppx_action)

        # Phrase (Memsource) import
        import_phrase_bilingual_action = QAction("&Phrase (Memsource) Bilingual (DOCX)...", self)
        import_phrase_bilingual_action.triggered.connect(self.import_phrase_bilingual)
        import_menu.addAction(import_phrase_bilingual_action)

        # D√©j√† Vu X3 import
        import_dejavu_action = QAction("&D√©j√† Vu X3 Bilingual (RTF)...", self)
        import_dejavu_action.triggered.connect(self.import_dejavu_bilingual)
        import_menu.addAction(import_dejavu_action)

        import_menu.addSeparator()
        
        import_review_table_action = QAction("&Bilingual Table (DOCX) - Update Project...", self)
        import_review_table_action.triggered.connect(self.import_review_table)
        import_menu.addAction(import_review_table_action)
        
        export_menu = file_menu.addMenu("&Export")
        
        export_memoq_action = QAction("memoQ &Bilingual Table - Translated (DOCX)...", self)
        export_memoq_action.triggered.connect(self.export_memoq_bilingual)
        export_menu.addAction(export_memoq_action)
        
        export_memoq_xliff_action = QAction("memoQ &XLIFF - Translated (.mqxliff)...", self)
        export_memoq_xliff_action.triggered.connect(self.export_memoq_xliff)
        export_menu.addAction(export_memoq_xliff_action)
        
        export_cafetran_action = QAction("&CafeTran Bilingual Table - Translated (DOCX)...", self)
        export_cafetran_action.triggered.connect(self.export_cafetran_bilingual)
        export_menu.addAction(export_cafetran_action)
        
        # Trados submenu - group all Trados exports together
        trados_export_submenu = export_menu.addMenu("&Trados Studio")

        export_trados_bilingual_action = QAction("Bilingual &Review - Translated (DOCX)...", self)
        export_trados_bilingual_action.triggered.connect(self.export_trados_bilingual)
        trados_export_submenu.addAction(export_trados_bilingual_action)

        export_sdlrpx_action = QAction("Return &Package (SDLRPX)...", self)
        export_sdlrpx_action.triggered.connect(self.export_sdlrpx_package)
        trados_export_submenu.addAction(export_sdlrpx_action)

        # Phrase (Memsource) export
        export_phrase_bilingual_action = QAction("&Phrase (Memsource) Bilingual - Translated (DOCX)...", self)
        export_phrase_bilingual_action.triggered.connect(self.export_phrase_bilingual)
        export_menu.addAction(export_phrase_bilingual_action)

        # D√©j√† Vu X3 export
        export_dejavu_action = QAction("&D√©j√† Vu X3 Bilingual - Translated (RTF)...", self)
        export_dejavu_action.triggered.connect(self.export_dejavu_bilingual)
        export_menu.addAction(export_dejavu_action)
        
        export_target_docx_action = QAction("&Target Only (DOCX)...", self)
        export_target_docx_action.triggered.connect(self.export_target_only_docx)
        export_menu.addAction(export_target_docx_action)
        
        export_txt_action = QAction("Simple &Text File - Translated (TXT)...", self)
        export_txt_action.triggered.connect(self.export_simple_txt)
        export_menu.addAction(export_txt_action)
        
        export_ai_action = QAction("üìÑ &AI-Readable Markdown (.md)...", self)
        export_ai_action.triggered.connect(self.export_bilingual_table_markdown)
        export_ai_action.setToolTip("Export segments in [SEGMENT] format for AI translation/review")
        export_menu.addAction(export_ai_action)
        
        export_menu.addSeparator()
        
        # Multi-file folder export
        export_folder_action = QAction("üìÅ &Folder (Multiple Files)...", self)
        export_folder_action.triggered.connect(self.export_folder_multifile)
        export_folder_action.setToolTip("Export multi-file project to folder with separate files")
        export_menu.addAction(export_folder_action)
        
        export_menu.addSeparator()
        
        # Relocate source folder for multi-file projects
        relocate_source_action = QAction("üîó &Relocate Source Folder...", self)
        relocate_source_action.triggered.connect(self.relocate_source_folder)
        relocate_source_action.setToolTip("Repoint to moved/renamed source folder for multi-file project")
        export_menu.addAction(relocate_source_action)
        
        export_menu.addSeparator()
        
        # Supervertaler Bilingual Table exports
        export_review_table_action = QAction("Supervertaler Bilingual Table - With &Tags (DOCX)...", self)
        export_review_table_action.triggered.connect(self.export_review_table_with_tags)
        export_menu.addAction(export_review_table_action)
        
        export_review_table_formatted_action = QAction("Supervertaler Bilingual Table - &Formatted (DOCX)...", self)
        export_review_table_formatted_action.triggered.connect(self.export_review_table_formatted)
        export_menu.addAction(export_review_table_formatted_action)
        
        export_menu.addSeparator()
        
        export_grid_action = QAction("TMX from &Grid (all segments)...", self)
        export_grid_action.triggered.connect(self.export_tmx_from_grid)
        export_menu.addAction(export_grid_action)
        
        export_selected_action = QAction("TMX from &Selected Segments...", self)
        export_selected_action.triggered.connect(self.export_tmx_from_selected)
        export_menu.addAction(export_selected_action)
        
        export_tm_action = QAction("TMX from &TM(s) for Current Project...", self)
        export_tm_action.triggered.connect(self.export_tmx_from_tm_database)
        export_menu.addAction(export_tm_action)
        
        file_menu.addSeparator()
        
        # Project Info
        project_info_action = QAction("üìã Project &Info...", self)
        project_info_action.triggered.connect(self.show_project_info_dialog)
        file_menu.addAction(project_info_action)
        
        file_menu.addSeparator()
        
        exit_action = QAction("E&xit", self)
        exit_action.setShortcut(QKeySequence.StandardKey.Quit)
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit Menu
        edit_menu = menubar.addMenu("&Edit")
        
        self.undo_action = QAction("&Undo", self)
        self.undo_action.setShortcut(QKeySequence.StandardKey.Undo)
        self.undo_action.triggered.connect(self.undo_action_handler)
        self.undo_action.setEnabled(False)
        edit_menu.addAction(self.undo_action)
        
        self.redo_action = QAction("&Redo", self)
        self.redo_action.setShortcut(QKeySequence.StandardKey.Redo)
        self.redo_action.triggered.connect(self.redo_action_handler)
        self.redo_action.setEnabled(False)
        edit_menu.addAction(self.redo_action)
        
        edit_menu.addSeparator()
        
        find_action = QAction("&Find...", self)
        find_action.setShortcut(QKeySequence.StandardKey.Find)
        find_action.triggered.connect(self.show_find_replace_dialog)
        edit_menu.addAction(find_action)
        
        replace_action = QAction("&Replace...", self)
        replace_action.setShortcut(QKeySequence.StandardKey.Replace)
        replace_action.triggered.connect(self.show_find_replace_dialog)
        edit_menu.addAction(replace_action)
        
        edit_menu.addSeparator()
        
        goto_action = QAction("&Go to Segment...\tCtrl+G", self)
        goto_action.triggered.connect(self.show_goto_dialog)
        edit_menu.addAction(goto_action)
        
        edit_menu.addSeparator()
        
        translate_action = QAction("&Translate Segment", self)
        translate_action.setShortcut("Ctrl+T")
        translate_action.triggered.connect(self.translate_current_segment)
        edit_menu.addAction(translate_action)

        translate_menu = edit_menu.addMenu("Batch &Translate")

        translate_selected_not_started_action = QAction("Translate selected not-started segments", self)
        translate_selected_not_started_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("selected_not_started")
        )
        translate_menu.addAction(translate_selected_not_started_action)

        translate_all_not_started_action = QAction("Translate all not-started segments", self)
        translate_all_not_started_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_not_started")
        )
        translate_menu.addAction(translate_all_not_started_action)

        translate_all_pretranslated_action = QAction("Translate all pre-translated segments", self)
        translate_all_pretranslated_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_pretranslated")
        )
        translate_menu.addAction(translate_all_pretranslated_action)

        translate_pending_action = QAction("Translate all not-started & pre-translated", self)
        translate_pending_action.setShortcut("Ctrl+Shift+T")
        translate_pending_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_not_started_pretranslated")
        )
        translate_menu.addAction(translate_pending_action)

        translate_translatable_action = QAction("Translate all translatable segments", self)
        translate_translatable_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_translatable")
        )
        translate_menu.addAction(translate_translatable_action)

        translate_all_segments_action = QAction("Translate all segments (all statuses)", self)
        translate_all_segments_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_segments")
        )
        translate_menu.addAction(translate_all_segments_action)
        
        translate_menu.addSeparator()
        
        # NEW: Translate only empty segments (for re-running failed batches)
        translate_empty_action = QAction("Translate all empty segments", self)
        translate_empty_action.setToolTip("Translate segments with empty target (useful after partial batch translation)")
        translate_empty_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("all_empty")
        )
        translate_menu.addAction(translate_empty_action)
        
        translate_filtered_action = QAction("Translate all filtered segments", self)
        translate_filtered_action.setToolTip("Translate only segments currently visible after filtering")
        translate_filtered_action.triggered.connect(
            lambda checked=False: self.translate_multiple_segments("filtered_segments")
        )
        translate_menu.addAction(translate_filtered_action)
        
        edit_menu.addSeparator()
        
        # Bulk Operations submenu
        bulk_menu = edit_menu.addMenu("Bulk &Operations")

        confirm_selected_action = QAction("‚úÖ &Confirm Selected Segments", self)
        confirm_selected_action.setShortcut("Ctrl+Shift+Return")
        confirm_selected_action.setToolTip("Confirm all selected segments (Ctrl+Shift+Enter)")
        confirm_selected_action.triggered.connect(self.confirm_selected_segments_from_menu)
        bulk_menu.addAction(confirm_selected_action)

        # Change Status submenu
        status_submenu = bulk_menu.addMenu("üè∑Ô∏è Change &Status")
        user_statuses = [
            ("not_started", "‚ùå &Not started"),
            ("pretranslated", "ü§ñ &Pre-translated"),
            ("translated", "‚úèÔ∏è &Translated"),
            ("confirmed", "‚úî &Confirmed"),
            ("tr_confirmed", "üåü T&R confirmed"),
            ("proofread", "üü™ Proo&fread"),
            ("approved", "‚≠ê &Approved"),
            ("rejected", "üö´ Re&jected"),
        ]
        for status_key, label in user_statuses:
            action = QAction(label, self)
            action.triggered.connect(lambda checked, s=status_key: self.change_status_selected(s, from_menu=True))
            status_submenu.addAction(action)

        clear_translations_action = QAction("üóëÔ∏è &Clear Translations", self)
        clear_translations_action.setToolTip("Clear translations for selected segments")
        clear_translations_action.triggered.connect(self.clear_selected_translations_from_menu)
        bulk_menu.addAction(clear_translations_action)
        
        copy_source_to_target_action = QAction("üìã Copy &Source to Target", self)
        copy_source_to_target_action.setToolTip("Copy source text to target for selected/filtered segments")
        copy_source_to_target_action.triggered.connect(self.copy_source_to_target_bulk)
        bulk_menu.addAction(copy_source_to_target_action)
        
        send_to_tm_action = QAction("üíæ &Send Segments to TM...", self)
        send_to_tm_action.setToolTip("Send confirmed segments to a writable Translation Memory")
        send_to_tm_action.triggered.connect(self.send_segments_to_tm_dialog)
        bulk_menu.addAction(send_to_tm_action)
        
        bulk_menu.addSeparator()
        
        clean_tags_action = QAction("üßπ Clean &Tags...", self)
        clean_tags_action.setToolTip("Remove formatting tags from selected segments")
        clean_tags_action.triggered.connect(self.show_clean_tags_dialog)
        bulk_menu.addAction(clean_tags_action)
        
        proofread_action = QAction("‚úÖ &Proofread Translation...", self)
        proofread_action.setToolTip("Use AI to proofread and verify translation quality")
        proofread_action.triggered.connect(self.show_proofread_dialog)
        bulk_menu.addAction(proofread_action)
        
        clear_proofread_notes_action = QAction("üóëÔ∏è Clear All &Proofreading Notes", self)
        clear_proofread_notes_action.setToolTip("Remove all AI proofreading notes from entire project (preserves your personal notes)")
        clear_proofread_notes_action.triggered.connect(self._bulk_clear_proofreading_notes)
        bulk_menu.addAction(clear_proofread_notes_action)
        
        edit_menu.addSeparator()
        
        # Superlookup
        superlookup_action = QAction("üîç &Superlookup...", self)
        superlookup_action.setShortcut("Ctrl+Alt+L")
        # Tab indices: Grid=0, Project resources=1, Tools=2, Settings=3
        superlookup_action.triggered.connect(lambda: self._go_to_superlookup() if hasattr(self, 'main_tabs') else None)  # Navigate to Superlookup
        edit_menu.addAction(superlookup_action)
        
        # View Menu
        view_menu = menubar.addMenu("&View")
        
        # Navigation submenu
        nav_menu = view_menu.addMenu("üìë &Navigate To")
        
        go_editor_action = QAction("üìù &Grid", self)
        go_editor_action.triggered.connect(lambda: self.main_tabs.setCurrentIndex(0) if hasattr(self, 'main_tabs') else None)
        nav_menu.addAction(go_editor_action)
        
        go_resources_action = QAction("üóÇÔ∏è Project &resources", self)
        go_resources_action.triggered.connect(lambda: self.main_tabs.setCurrentIndex(1) if hasattr(self, 'main_tabs') else None)
        nav_menu.addAction(go_resources_action)
        
        go_prompt_manager_action = QAction("‚ö° &QuickMenu", self)
        go_prompt_manager_action.triggered.connect(lambda: self.main_tabs.setCurrentIndex(2) if hasattr(self, 'main_tabs') else None)
        nav_menu.addAction(go_prompt_manager_action)
        
        go_tools_action = QAction("üõ†Ô∏è &Tools", self)
        go_tools_action.triggered.connect(lambda: self.main_tabs.setCurrentIndex(3) if hasattr(self, 'main_tabs') else None)
        nav_menu.addAction(go_tools_action)
        
        go_settings_action = QAction("‚öôÔ∏è &Settings", self)
        go_settings_action.triggered.connect(lambda: self.main_tabs.setCurrentIndex(4) if hasattr(self, 'main_tabs') else None)
        nav_menu.addAction(go_settings_action)
        
        view_menu.addSeparator()
        
        # Grid Text section
        grid_zoom_menu = view_menu.addMenu("üìä &Grid Text Zoom")
        
        grid_zoom_in = QAction("Grid Zoom &In", self)
        grid_zoom_in.setShortcut("Ctrl+=")
        grid_zoom_in.triggered.connect(self.zoom_in)
        grid_zoom_menu.addAction(grid_zoom_in)
        
        grid_zoom_out = QAction("Grid Zoom &Out", self)
        grid_zoom_out.setShortcut(QKeySequence.StandardKey.ZoomOut)
        grid_zoom_out.triggered.connect(self.zoom_out)
        grid_zoom_menu.addAction(grid_zoom_out)

        # Note: Do not add separate Ctrl++/Ctrl+- actions here.
        # QKeySequence.StandardKey.ZoomIn/ZoomOut already maps to these keys on many layouts,
        # and duplicates cause: "QAction::event: Ambiguous shortcut overload".
        grid_zoom_menu.addSeparator()
        
        grid_font_family_menu = grid_zoom_menu.addMenu("Grid Font &Family")
        font_families = ["Calibri", "Segoe UI", "Arial", "Consolas", "Verdana", 
                        "Times New Roman", "Georgia", "Courier New"]
        for font_name in font_families:
            font_action = QAction(font_name, self)
            font_action.triggered.connect(lambda checked, f=font_name: self.set_font_family(f))
            grid_font_family_menu.addAction(font_action)
        
        view_menu.addSeparator()
        
        # Translation Results Pane section
        results_zoom_menu = view_menu.addMenu("üìã Translation &Results Pane")
        
        results_zoom_in_action = QAction("Results Zoom &In", self)
        results_zoom_in_action.setShortcut("Ctrl+Shift+=")
        results_zoom_in_action.triggered.connect(self.results_pane_zoom_in)
        results_zoom_menu.addAction(results_zoom_in_action)
        
        results_zoom_out_action = QAction("Results Zoom &Out", self)
        results_zoom_out_action.setShortcut("Ctrl+Shift+-")
        results_zoom_out_action.triggered.connect(self.results_pane_zoom_out)
        results_zoom_menu.addAction(results_zoom_out_action)
        
        results_zoom_reset_action = QAction("Results Zoom &Reset", self)
        results_zoom_reset_action.triggered.connect(self.results_pane_zoom_reset)
        results_zoom_menu.addAction(results_zoom_reset_action)
        
        results_zoom_menu.addSeparator()
        
        results_note = QAction("(Includes match list + compare boxes)", self)
        results_note.setEnabled(False)
        results_zoom_menu.addAction(results_note)
        
        # Match Panel zoom section
        match_panel_zoom_menu = view_menu.addMenu("üîç &Match Panel")
        
        match_panel_zoom_in_action = QAction("Match Panel Zoom &In", self)
        match_panel_zoom_in_action.setShortcut("Ctrl+Alt+=")
        match_panel_zoom_in_action.triggered.connect(self.match_panel_zoom_in)
        match_panel_zoom_menu.addAction(match_panel_zoom_in_action)
        
        match_panel_zoom_out_action = QAction("Match Panel Zoom &Out", self)
        match_panel_zoom_out_action.setShortcut("Ctrl+Alt+-")
        match_panel_zoom_out_action.triggered.connect(self.match_panel_zoom_out)
        match_panel_zoom_menu.addAction(match_panel_zoom_out_action)
        
        match_panel_zoom_reset_action = QAction("Match Panel Zoom &Reset", self)
        match_panel_zoom_reset_action.triggered.connect(self.match_panel_zoom_reset)
        match_panel_zoom_menu.addAction(match_panel_zoom_reset_action)

        view_menu.addSeparator()
        
        # Termview visibility toggle
        self.termview_visible_action = QAction("üîç &Termview Under Grid", self)
        self.termview_visible_action.setCheckable(True)
        self.termview_visible_action.setChecked(True)  # Default: visible
        self.termview_visible_action.triggered.connect(self.toggle_termview_under_grid)
        self.termview_visible_action.setToolTip("Show/hide the Termview panel under the grid")
        view_menu.addAction(self.termview_visible_action)

        view_menu.addSeparator()

        auto_resize_action = QAction("üìê &Auto-Resize Rows", self)
        auto_resize_action.triggered.connect(self.auto_resize_rows)
        auto_resize_action.setToolTip("Automatically resize all rows to fit content")
        view_menu.addAction(auto_resize_action)

        view_menu.addSeparator()
        
        # Multi-file project progress
        file_progress_action = QAction("üìÅ &File Progress...", self)
        file_progress_action.triggered.connect(self.show_file_progress_dialog)
        file_progress_action.setToolTip("View translation progress per file (multi-file projects)")
        view_menu.addAction(file_progress_action)
        
        # Proofreading results
        proofread_results_action = QAction("‚úÖ &Proofreading Results...", self)
        proofread_results_action.triggered.connect(self.show_proofreading_results_dialog)
        proofread_results_action.setToolTip("View and manage proofreading issues")
        view_menu.addAction(proofread_results_action)

        view_menu.addSeparator()

        theme_action = QAction("üé® &Theme Editor...", self)
        theme_action.triggered.connect(self.show_theme_editor)
        view_menu.addAction(theme_action)

        # Tools Menu
        tools_menu = menubar.addMenu("&Tools")
        
        # Tools in same order as Tools tab
        autofingers_action = QAction("‚úã &AutoFingers...", self)
        autofingers_action.setShortcut("Ctrl+Shift+A")
        autofingers_action.triggered.connect(self.show_autofingers)
        tools_menu.addAction(autofingers_action)
        
        superconverter_action = QAction("üîÑ Super&converter...", self)
        superconverter_action.triggered.connect(lambda: self._navigate_to_tool("Superconverter"))
        tools_menu.addAction(superconverter_action)
        
        pdf_rescue_action = QAction("üìÑ &PDF Rescue...", self)
        pdf_rescue_action.triggered.connect(lambda: self._navigate_to_tool("PDF Rescue"))
        tools_menu.addAction(pdf_rescue_action)
        
        superbench_action = QAction("üìä Super&bench...", self)
        superbench_action.triggered.connect(lambda: self._navigate_to_tool("Superbench"))
        tools_menu.addAction(superbench_action)
        
        superbrowser_action = QAction("üåê Super&browser...", self)
        superbrowser_action.triggered.connect(lambda: self._navigate_to_tool("Superbrowser"))
        tools_menu.addAction(superbrowser_action)
        
        supercleaner_action = QAction("üßπ Supercleaner...", self)
        supercleaner_action.triggered.connect(lambda: self._navigate_to_tool("Supercleaner"))
        tools_menu.addAction(supercleaner_action)
        
        superlookup_action = QAction("üîç Super&lookup (Ctrl+K)...", self)
        # Note: Actual Ctrl+K shortcut handled by QShortcut in setup_global_shortcuts()
        # which calls show_concordance_search() for proper selection capture
        superlookup_action.triggered.connect(self.show_concordance_search)
        tools_menu.addAction(superlookup_action)
        
        supervoice_action = QAction("üé§ Super&voice...", self)
        supervoice_action.triggered.connect(lambda: self._navigate_to_tool("Supervoice"))
        tools_menu.addAction(supervoice_action)
        
        encoding_action = QAction("üîß &Text Encoding Repair...", self)
        encoding_action.triggered.connect(lambda: self._navigate_to_tool("Text Encoding Repair"))
        tools_menu.addAction(encoding_action)
        
        tmx_editor_action = QAction("‚úèÔ∏è T&MX Editor...", self)
        tmx_editor_action.triggered.connect(lambda: self._navigate_to_tool("TMX Editor"))
        tools_menu.addAction(tmx_editor_action)
        
        tracked_changes_action = QAction("üîÑ Tracked &Changes...", self)
        tracked_changes_action.triggered.connect(lambda: self._navigate_to_tool("Tracked Changes"))
        tools_menu.addAction(tracked_changes_action)
        
        tools_menu.addSeparator()
        
        image_extractor_action = QAction("üñºÔ∏è &Image Extractor (Superimage)...", self)
        image_extractor_action.triggered.connect(self.show_image_extractor_from_tools)
        image_extractor_action.setToolTip("Extract images from DOCX files")
        tools_menu.addAction(image_extractor_action)
        
        scratchpad_action = QAction("üìù Scratch&pad...", self)
        scratchpad_action.setShortcut("Ctrl+Shift+P")
        scratchpad_action.triggered.connect(self.show_scratchpad)
        scratchpad_action.setToolTip("Private notes for this project (never exported to CAT tools)")
        tools_menu.addAction(scratchpad_action)
        
        tools_menu.addSeparator()

        settings_action = QAction("&Settings...", self)
        settings_action.triggered.connect(lambda: self._go_to_settings_tab())
        tools_menu.addAction(settings_action)
        
        # Help Menu
        help_menu = menubar.addMenu("&Help")

        # Documentation links (GitHub URLs for universal access)
        # Removed internal manual link ‚Äî documentation migrated to GitBook

        # Place Supervertaler Help at the top of the Help menu
        superdocs_action = QAction("Supervertaler Help", self)
        superdocs_action.setToolTip("Online documentation (GitBook)")
        superdocs_action.triggered.connect(lambda: self._open_url("https://supervertaler.gitbook.io/superdocs/"))
        help_menu.addAction(superdocs_action)

        setup_wizard_action = QAction("üöÄ Setup Wizard...", self)
        setup_wizard_action.setToolTip("Run the initial setup wizard (data folder location, features overview)")
        setup_wizard_action.triggered.connect(lambda: self._show_setup_wizard(is_first_run=False))
        help_menu.addAction(setup_wizard_action)

        help_menu.addSeparator()

        shortcuts_action = QAction("‚å®Ô∏è Keyboard Shortcuts", self)
        shortcuts_action.triggered.connect(lambda: self._open_url("https://github.com/michaelbeijer/Supervertaler/blob/main/docs/guides/KEYBOARD_SHORTCUTS.md"))
        help_menu.addAction(shortcuts_action)

        changelog_action = QAction("üìù Changelog", self)
        changelog_action.triggered.connect(lambda: self._open_url("https://github.com/michaelbeijer/Supervertaler/blob/main/CHANGELOG.md"))
        help_menu.addAction(changelog_action)

        update_check_action = QAction("üîÑ Check for Updates...", self)
        update_check_action.setToolTip("Check whether you are running the latest Supervertaler release")
        update_check_action.triggered.connect(self.check_for_updates)
        help_menu.addAction(update_check_action)

        copy_version_info_action = QAction("üìã Copy Version Info", self)
        copy_version_info_action.setToolTip("Copy version and system info to clipboard (useful for support)")
        copy_version_info_action.triggered.connect(self.copy_version_info_to_clipboard)
        help_menu.addAction(copy_version_info_action)

        help_menu.addSeparator()

        github_action = QAction("üîó GitHub Repository", self)
        github_action.triggered.connect(lambda: self._open_url("https://github.com/michaelbeijer/Supervertaler"))
        help_menu.addAction(github_action)

        help_menu.addSeparator()
        
        # AutoHotkey setup (Windows only)
        if os.name == 'nt':
            ahk_setup_action = QAction("‚å®Ô∏è Setup AutoHotkey (Global Hotkey)", self)
            ahk_setup_action.setToolTip("Configure AutoHotkey for Superlookup global hotkey (Ctrl+Alt+L)")
            ahk_setup_action.triggered.connect(self._show_ahk_setup_from_menu)
            help_menu.addAction(ahk_setup_action)
            help_menu.addSeparator()

        about_action = QAction("‚ÑπÔ∏è About", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    
    def record_undo_state(self, segment_id, old_target, new_target, old_status, new_status):
        """Record an undo state when grid cells are edited"""
        # Don't record if nothing actually changed
        if old_target == new_target and old_status == new_status:
            return
        
        # Add to undo stack
        undo_entry = {
            "segment_id": segment_id,
            "old_target": old_target,
            "new_target": new_target,
            "old_status": old_status,
            "new_status": new_status
        }
        self.undo_stack.append(undo_entry)
        
        # Trim undo stack to max levels
        if len(self.undo_stack) > self.max_undo_levels:
            self.undo_stack.pop(0)
        
        # Clear redo stack (can't redo after new edit)
        self.redo_stack.clear()
        
        # Update menu actions
        self.update_undo_redo_actions()
    
    def undo_action_handler(self):
        """Handle Undo (Ctrl+Z) action"""
        if not self.undo_stack:
            return
        
        # Pop last action from undo stack
        action = self.undo_stack.pop()
        
        # Find the segment
        segment_id = action["segment_id"]
        segment = None
        for seg in self.current_project.segments:
            if seg.segment_id == segment_id:
                segment = seg
                break
        
        if not segment:
            return
        
        # Revert to old values
        segment.target_text = action["old_target"]
        segment.status = action["old_status"]
        
        # Update grid display
        row = self.find_grid_row_by_segment_id(segment_id)
        if row is not None:
            # Update target text cell
            target_item = self.grid.item(row, 2)
            if target_item:
                target_item.setText(action["old_target"])
            
            # Update status cell
            status_item = self.grid.item(row, 3)
            if status_item:
                status_item.setText(action["old_status"])
        
        # Move action to redo stack
        self.redo_stack.append(action)
        
        # Update menu actions
        self.update_undo_redo_actions()
    
    def redo_action_handler(self):
        """Handle Redo (Ctrl+Shift+Z / Ctrl+Y) action"""
        if not self.redo_stack:
            return
        
        # Pop last action from redo stack
        action = self.redo_stack.pop()
        
        # Find the segment
        segment_id = action["segment_id"]
        segment = None
        for seg in self.current_project.segments:
            if seg.segment_id == segment_id:
                segment = seg
                break
        
        if not segment:
            return
        
        # Reapply new values
        segment.target_text = action["new_target"]
        segment.status = action["new_status"]
        
        # Update grid display
        row = self.find_grid_row_by_segment_id(segment_id)
        if row is not None:
            # Update target text cell
            target_item = self.grid.item(row, 2)
            if target_item:
                target_item.setText(action["new_target"])
            
            # Update status cell
            status_item = self.grid.item(row, 3)
            if status_item:
                status_item.setText(action["new_status"])
        
        # Move action back to undo stack
        self.undo_stack.append(action)
        
        # Update menu actions
        self.update_undo_redo_actions()
    
    def update_undo_redo_actions(self):
        """Update enabled/disabled state of undo/redo menu actions"""
        self.undo_action.setEnabled(len(self.undo_stack) > 0)
        self.redo_action.setEnabled(len(self.redo_stack) > 0)
    
    def find_grid_row_by_segment_id(self, segment_id):
        """Find the grid row index for a given segment ID"""
        for row in range(self.grid.rowCount()):
            id_item = self.grid.item(row, 0)
            if id_item and id_item.text() == str(segment_id):
                return row
        return None
    
    def create_quick_access_toolbar(self):
        """Create Quick Access Toolbar above ribbon"""
        from PyQt6.QtWidgets import QToolBar, QWidget, QHBoxLayout
        from PyQt6.QtCore import QSize
        
        qat = QToolBar("Quick Access")
        qat.setMovable(False)
        qat.setFloatable(False)
        qat.setIconSize(QSize(20, 20))
        qat.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonIconOnly)
        qat.setMaximumHeight(28)
        qat.setMinimumWidth(170)  # Fixed width to align ribbon tabs
        qat.setMaximumWidth(170)
        
        # Styling for compact appearance
        qat.setStyleSheet("""
            QToolBar {
                background: transparent;
                border: none;
                spacing: 2px;
                padding: 2px;
            }
            QToolButton {
                background: transparent;
                border: 1px solid transparent;
                border-radius: 3px;
                padding: 2px;
                margin: 0px;
                font-size: 14pt;
            }
            QToolButton:hover {
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            QToolButton:pressed {
                background: rgba(0, 0, 0, 0.1);
            }
        """)
        
        # Empty toolbar - all buttons removed, minimize moved to ribbon
        # Add empty separator just to maintain spacing
        qat.addSeparator()
        
        return qat
    
    def create_ribbon(self):
        """
        Create modern ribbon interface - DISABLED
        Ribbon functionality has been moved to traditional menu bar.
        This code is kept for potential future use.
        """
        # Ribbon removed - all actions are now in the menu bar
        # Keeping this method for potential future re-enablement
        return
        
        # from modules.ribbon_widget import RibbonWidget, RibbonTab, RibbonGroup, RibbonButton
        # 
        # # Create ribbon widget
        # self.ribbon = RibbonWidget(self)
        # 
        # # Connect ribbon actions to methods
        # self.ribbon.action_triggered.connect(self.handle_ribbon_action)
        
        # Ribbon code commented out - all functionality moved to menu bar
        # HOME TAB - Project management and navigation
        # home_tab = RibbonTab()
        # project_group = RibbonGroup("Project")
        # project_group.add_button(self.ribbon.create_button("New", "üìÑ", "new", "New project (Ctrl+N)"))
        # ... (all ribbon tab creation code commented out)
        # All actions are now available in the traditional menu bar
    
    def create_ribbon_toolbar(self):
        """Create a toolbar to hold the ribbon - DISABLED"""
        # Ribbon removed - using traditional menu bar instead
        # This method kept for potential future use
        return None
    
    def toggle_ribbon_minimized(self, minimized: bool):
        """Toggle ribbon between full and minimized (tabs-only) mode - DISABLED"""
        # Ribbon removed - no action needed
        self.ribbon_minimized = minimized  # Store state for backwards compatibility
        pass
    
    def show_ribbon_temporarily(self, index: int):
        """Show ribbon temporarily when tab clicked in minimized mode - DISABLED"""
        # Ribbon removed - no action needed
        pass
    
    def on_main_tab_changed(self, index: int):
        """Handle main tab change"""
        # Ribbon removed - menu bar remains constant across all tabs
        # No context switching needed
        pass
    
    def create_main_layout(self):
        """Create main application layout with all-tab interface"""
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(5, 0, 5, 5)  # Reduced top margin to minimize space below menu bar
        
        # ===== SIMPLIFIED TAB-BASED UI =====
        # Single tab widget with all functionality
        from modules.unified_prompt_manager_qt import UnifiedPromptManagerQt
        
        # Create main tab widget
        self.main_tabs = QTabWidget()
        self.main_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.main_tabs.tabBar().setDrawBase(False)
        self.main_tabs.setStyleSheet("""
            QTabBar::tab { padding: 8px 15px; outline: 0; }
            QTabBar::tab:focus { outline: none; }
            QTabBar::tab:selected { 
                border-bottom: 1px solid #2196F3; 
                background-color: rgba(33, 150, 243, 0.08);
            }
        """)
        
        # ===== 1. GRID TAB =====
        # Contains the translation grid
        grid_widget = self.create_grid_view_widget_for_home()
        self.main_tabs.addTab(grid_widget, "üìù Grid")
        
        # ===== 2. PROJECT RESOURCES TAB =====
        # Contains TM, Termbases, Non-Translatables
        resources_tab = self.create_resources_tab()
        self.main_tabs.addTab(resources_tab, "üóÇÔ∏è Resources")
        
        # ===== 3. PROMPT MANAGER TAB =====
        # Unified prompt system: folder structure = menu hierarchy for in-app + global access
        from modules.unified_prompt_manager_qt import UnifiedPromptManagerQt
        prompt_widget = QWidget()
        self.prompt_manager_qt = UnifiedPromptManagerQt(self, standalone=False)
        self.prompt_manager_qt.create_tab(prompt_widget)
        self.main_tabs.addTab(prompt_widget, "üìù Prompt Manager")
        
        # Keep backward compatibility reference
        self.document_views_widget = self.main_tabs
        
        # 4. TOOLS
        tools_tab = self.create_specialised_tools_tab()
        self.main_tabs.addTab(tools_tab, "üõ†Ô∏è Tools")

        # 5. SETTINGS
        settings_tab = self.create_settings_tab()
        self.main_tabs.addTab(settings_tab, "‚öôÔ∏è Settings")
        
        # Set startup tab to Grid (index 0)
        self.main_tabs.setCurrentIndex(0)
        
        main_layout.addWidget(self.main_tabs)
        
        # Connect tab changes to handle view refreshes
        self.main_tabs.currentChanged.connect(self._on_main_tab_changed)

    
    def _create_placeholder_tab(self, title: str, description: str) -> QWidget:
        """Create a simple placeholder tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        
        header = QLabel(title)
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        placeholder = QLabel(description)
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("color: #888; font-size: 12px;")
        layout.addWidget(placeholder, stretch=1)
        
        return tab
    
    def create_non_translatables_tab(self) -> QWidget:
        """Create the Non-Translatables tab - manage non-translatable content"""
        from modules.non_translatables_manager import NonTranslatablesManager, NonTranslatableList
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Header
        header = QLabel("üö´ Non-Translatables")
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Description
        desc = QLabel("Manage terms and phrases that should not be translated (brand names, product names, technical identifiers, etc.).\n"
                      "Non-translatables are highlighted in pastel yellow in the source text and Translation Results panel.")
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #666; font-size: 11px; margin-bottom: 10px;")
        layout.addWidget(desc)
        
        # Initialize NT manager
        nt_path = self.user_data_path / "resources" / "non_translatables"
        nt_path.mkdir(parents=True, exist_ok=True)
        self.nt_manager = NonTranslatablesManager(str(nt_path), self.log)
        
        # Try to load existing lists or convert from plain text
        existing_nt_files = list(nt_path.glob("*.svntl")) + list(nt_path.glob("*.ntl"))
        if not existing_nt_files:
            # Check for plain text file to convert
            txt_file = nt_path / "non-translatables.txt"
            if txt_file.exists():
                self.log("üìÑ Found plain text NT file, converting to .svntl format...")
                nt_list = self.nt_manager.load_from_plain_text(str(txt_file), "Default Non-Translatables")
                if nt_list:
                    self.nt_manager.save_list(nt_list)
                    self.nt_manager.lists[nt_list.name] = nt_list
                    self.nt_manager.active_lists.append(nt_list.name)
        else:
            self.nt_manager.load_all_lists()
        
        # Toolbar
        toolbar = QHBoxLayout()
        
        # List selection combo
        list_combo = QComboBox()
        list_combo.setMinimumWidth(200)
        list_combo.setToolTip("Select a non-translatable list")
        toolbar.addWidget(QLabel("List:"))
        toolbar.addWidget(list_combo)
        
        # Buttons
        new_btn = QPushButton("‚ûï New List")
        new_btn.setToolTip("Create a new non-translatable list")
        toolbar.addWidget(new_btn)
        
        import_btn = QPushButton("üì• Import")
        import_btn.setToolTip("Import from file (.svntl, .ntl, .txt, or memoQ .mqres)")
        toolbar.addWidget(import_btn)
        
        export_btn = QPushButton("üì§ Export")
        export_btn.setToolTip("Export selected list")
        toolbar.addWidget(export_btn)
        
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.setToolTip("Delete selected list")
        toolbar.addWidget(delete_btn)
        
        toolbar.addStretch()
        
        # Active checkbox
        active_checkbox = CheckmarkCheckBox("Active")
        active_checkbox.setToolTip("Toggle whether this list is active for matching")
        toolbar.addWidget(active_checkbox)
        
        layout.addLayout(toolbar)
        
        # Split view: entry list on left, add/edit on right
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left: Entry list
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # Search box
        search_box = QLineEdit()
        search_box.setPlaceholderText("Search entries...")
        left_layout.addWidget(search_box)
        
        # Entry table
        entry_table = QTableWidget()
        entry_table.setColumnCount(2)
        entry_table.setHorizontalHeaderLabels(["Entry", "Category"])
        entry_table.horizontalHeader().setStretchLastSection(True)
        entry_table.setColumnWidth(0, 250)
        entry_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        entry_table.setAlternatingRowColors(True)
        entry_table.setSortingEnabled(True)  # Enable column sorting
        entry_table.horizontalHeader().setSortIndicatorShown(True)
        entry_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)  # Enable right-click menu
        left_layout.addWidget(entry_table)
        
        # Entry count
        count_label = QLabel("0 entries")
        count_label.setStyleSheet("color: #666; font-size: 10px;")
        left_layout.addWidget(count_label)
        
        splitter.addWidget(left_widget)
        
        # Right: Add/Edit panel
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(10, 0, 0, 0)
        
        right_layout.addWidget(QLabel("<b>Add/Edit Entry</b>"))
        
        entry_input = QLineEdit()
        entry_input.setPlaceholderText("Enter non-translatable term...")
        right_layout.addWidget(entry_input)
        
        category_input = QLineEdit()
        category_input.setPlaceholderText("Category (optional)")
        right_layout.addWidget(category_input)
        
        notes_input = QTextEdit()
        notes_input.setPlaceholderText("Notes (optional)")
        notes_input.setMaximumHeight(80)
        right_layout.addWidget(notes_input)
        
        add_btn = QPushButton("‚ûï Add Entry")
        right_layout.addWidget(add_btn)
        
        remove_btn = QPushButton("üóëÔ∏è Remove Selected")
        right_layout.addWidget(remove_btn)
        
        right_layout.addStretch()
        
        # Bulk operations
        bulk_group = QGroupBox("Bulk Import")
        bulk_layout = QVBoxLayout(bulk_group)
        
        bulk_text = QTextEdit()
        bulk_text.setPlaceholderText("Paste multiple entries (one per line) for bulk import...")
        bulk_text.setMaximumHeight(100)
        bulk_layout.addWidget(bulk_text)
        
        bulk_btn = QPushButton("Import All")
        bulk_layout.addWidget(bulk_btn)
        
        right_layout.addWidget(bulk_group)
        
        splitter.addWidget(right_widget)
        splitter.setSizes([500, 300])
        
        layout.addWidget(splitter, stretch=1)
        
        # Store references for callbacks
        self.nt_list_combo = list_combo
        self.nt_entry_table = entry_table
        self.nt_count_label = count_label
        self.nt_active_checkbox = active_checkbox
        
        # Populate list combo
        def refresh_list_combo():
            list_combo.clear()
            for name, nt_list in self.nt_manager.lists.items():
                active_marker = "‚úì " if nt_list.is_active else ""
                list_combo.addItem(f"{active_marker}{name}", name)
            
            if list_combo.count() == 0:
                list_combo.addItem("(No lists - create or import one)", "")
        
        # Populate entry table for selected list
        def refresh_entry_table():
            # Disable sorting while populating to avoid performance issues
            entry_table.setSortingEnabled(False)
            entry_table.setRowCount(0)
            current_name = list_combo.currentData()
            
            if not current_name or current_name not in self.nt_manager.lists:
                count_label.setText("0 entries")
                active_checkbox.setChecked(False)
                entry_table.setSortingEnabled(True)
                return
            
            nt_list = self.nt_manager.lists[current_name]
            active_checkbox.blockSignals(True)
            active_checkbox.setChecked(nt_list.is_active)
            active_checkbox.blockSignals(False)
            
            search_term = search_box.text().lower()
            
            filtered = [e for e in nt_list.entries 
                       if not search_term or search_term in e.text.lower()]
            
            entry_table.setRowCount(len(filtered))
            for row, entry in enumerate(filtered):
                entry_table.setItem(row, 0, QTableWidgetItem(entry.text))
                entry_table.setItem(row, 1, QTableWidgetItem(entry.category))
            
            # Re-enable sorting after populating
            entry_table.setSortingEnabled(True)
            
            count_label.setText(f"{len(nt_list.entries)} entries ({len(filtered)} shown)")
        
        # Connect signals
        list_combo.currentIndexChanged.connect(refresh_entry_table)
        search_box.textChanged.connect(refresh_entry_table)
        
        # Helper to save NT settings to project
        def save_nt_settings_to_project():
            """Save active NT list names to project settings"""
            if hasattr(self, 'current_project') and self.current_project:
                active_list_names = [name for name, lst in self.nt_manager.lists.items() if lst.is_active]
                if not hasattr(self.current_project, 'nt_settings'):
                    self.current_project.nt_settings = {}
                self.current_project.nt_settings['active_lists'] = active_list_names
                self.log(f"üíæ Saved NT settings to project: {len(active_list_names)} active list(s)")
        
        # Active toggle
        def on_active_toggle(checked):
            current_name = list_combo.currentData()
            if current_name and current_name in self.nt_manager.lists:
                self.nt_manager.set_list_active(current_name, checked)
                refresh_list_combo()
                # Keep selection
                for i in range(list_combo.count()):
                    if list_combo.itemData(i) == current_name:
                        list_combo.setCurrentIndex(i)
                        break
                # Save to project settings
                save_nt_settings_to_project()
        
        active_checkbox.toggled.connect(on_active_toggle)
        
        # New list
        def on_new_list():
            name, ok = QInputDialog.getText(tab, "New Non-Translatable List", "List name:")
            if ok and name:
                if name in self.nt_manager.lists:
                    QMessageBox.warning(tab, "Error", f"List '{name}' already exists.")
                    return
                nt_list = self.nt_manager.create_list(name)
                self.nt_manager.save_list(nt_list)
                refresh_list_combo()
                # Select new list
                for i in range(list_combo.count()):
                    if list_combo.itemData(i) == name:
                        list_combo.setCurrentIndex(i)
                        break
        
        new_btn.clicked.connect(on_new_list)
        
        # Add entry
        def on_add_entry():
            text = entry_input.text().strip()
            if not text:
                return
            
            current_name = list_combo.currentData()
            if not current_name:
                QMessageBox.warning(tab, "Error", "Please select or create a list first.")
                return
            
            self.nt_manager.add_entry(current_name, text, 
                                      notes_input.toPlainText(), 
                                      category_input.text())
            self.nt_manager.save_list(self.nt_manager.lists[current_name])
            
            entry_input.clear()
            notes_input.clear()
            category_input.clear()
            refresh_entry_table()
        
        add_btn.clicked.connect(on_add_entry)
        entry_input.returnPressed.connect(on_add_entry)
        
        # Remove entry
        def on_remove_entry():
            current_name = list_combo.currentData()
            if not current_name:
                return
            
            selected = entry_table.selectedItems()
            if not selected:
                return
            
            # Get unique row indices
            rows = set(item.row() for item in selected)
            
            # Get entry texts to remove
            for row in sorted(rows, reverse=True):
                text_item = entry_table.item(row, 0)
                if text_item:
                    self.nt_manager.remove_entry(current_name, text_item.text())
            
            self.nt_manager.save_list(self.nt_manager.lists[current_name])
            refresh_entry_table()
        
        remove_btn.clicked.connect(on_remove_entry)
        
        # Right-click context menu for entry table
        def on_entry_context_menu(pos):
            selected = entry_table.selectedItems()
            if not selected:
                return
            
            menu = QMenu(entry_table)
            
            # Get selected row count
            rows = set(item.row() for item in selected)
            count_text = f"Delete {len(rows)} entr{'ies' if len(rows) > 1 else 'y'}"
            
            delete_action = QAction(f"üóëÔ∏è {count_text}", menu)
            delete_action.triggered.connect(on_remove_entry)
            menu.addAction(delete_action)
            
            menu.exec(entry_table.viewport().mapToGlobal(pos))
        
        entry_table.customContextMenuRequested.connect(on_entry_context_menu)
        
        # Delete key shortcut for entry table
        def on_entry_key_press(event):
            if event.key() == Qt.Key.Key_Delete:
                on_remove_entry()
            else:
                QTableWidget.keyPressEvent(entry_table, event)
        
        entry_table.keyPressEvent = on_entry_key_press
        
        # Bulk import
        def on_bulk_import():
            current_name = list_combo.currentData()
            if not current_name:
                QMessageBox.warning(tab, "Error", "Please select or create a list first.")
                return
            
            text = bulk_text.toPlainText()
            lines = [l.strip() for l in text.splitlines() if l.strip()]
            
            if not lines:
                return
            
            added = 0
            for line in lines:
                if line not in [e.text for e in self.nt_manager.lists[current_name].entries]:
                    self.nt_manager.add_entry(current_name, line)
                    added += 1
            
            self.nt_manager.save_list(self.nt_manager.lists[current_name])
            bulk_text.clear()
            refresh_entry_table()
            
            QMessageBox.information(tab, "Bulk Import", f"Added {added} entries ({len(lines) - added} duplicates skipped)")
        
        bulk_btn.clicked.connect(on_bulk_import)
        
        # Import from file
        def on_import():
            filepath, _ = QFileDialog.getOpenFileName(
                tab, "Import Non-Translatables",
                str(nt_path),
                "All Supported (*.svntl *.ntl *.txt *.mqres);;Supervertaler NT List (*.svntl *.ntl);;Plain Text (*.txt);;memoQ Non-Translatables (*.mqres)"
            )
            
            if not filepath:
                return
            
            filepath_lower = filepath.lower()
            
            # Load based on file type
            if filepath_lower.endswith('.mqres'):
                imported_list = self.nt_manager.import_memoq_mqres(filepath)
            elif filepath_lower.endswith('.svntl') or filepath_lower.endswith('.ntl'):
                imported_list = self.nt_manager.load_list(filepath)
            else:
                imported_list = self.nt_manager.load_from_plain_text(filepath)
            
            if not imported_list:
                QMessageBox.warning(tab, "Import Error", "Failed to import file. Check the log for details.")
                return
            
            # Ask user whether to create new list or merge
            current_name = list_combo.currentData()
            if current_name and current_name in self.nt_manager.lists:
                # Create custom dialog with clear button labels
                msg_box = QMessageBox(tab)
                msg_box.setWindowTitle("Import Options")
                msg_box.setText(f"Import {len(imported_list.entries)} entries")
                msg_box.setInformativeText(f"Choose how to import into your non-translatables:")
                msg_box.setIcon(QMessageBox.Icon.Question)
                
                create_btn = msg_box.addButton(f"Create New List", QMessageBox.ButtonRole.YesRole)
                merge_btn = msg_box.addButton(f"Merge into '{current_name}'", QMessageBox.ButtonRole.NoRole)
                cancel_btn = msg_box.addButton(QMessageBox.StandardButton.Cancel)
                
                msg_box.exec()
                clicked = msg_box.clickedButton()
                
                if clicked == cancel_btn:
                    return
                elif clicked == merge_btn:
                    # Merge into current list
                    added, skipped = self.nt_manager.merge_into_list(current_name, imported_list)
                    self.nt_manager.save_list(self.nt_manager.lists[current_name])
                    refresh_entry_table()
                    QMessageBox.information(tab, "Import Complete", 
                                          f"Merged {added} entries into '{current_name}'\n({skipped} duplicates skipped)")
                    return
            
            # Create new list
            # Check for name collision
            new_name = imported_list.name
            counter = 1
            while new_name in self.nt_manager.lists:
                new_name = f"{imported_list.name} ({counter})"
                counter += 1
            
            imported_list.name = new_name
            self.nt_manager.lists[new_name] = imported_list
            self.nt_manager.active_lists.append(new_name)
            self.nt_manager.save_list(imported_list)
            
            refresh_list_combo()
            
            # Select imported list
            for i in range(list_combo.count()):
                if list_combo.itemData(i) == new_name:
                    list_combo.setCurrentIndex(i)
                    break
            
            QMessageBox.information(tab, "Import Complete", 
                                  f"Created list '{new_name}' with {len(imported_list.entries)} entries")
        
        import_btn.clicked.connect(on_import)
        
        # Export
        def on_export():
            current_name = list_combo.currentData()
            if not current_name or current_name not in self.nt_manager.lists:
                QMessageBox.warning(tab, "Error", "Please select a list to export.")
                return
            
            filepath, selected_filter = QFileDialog.getSaveFileName(
                tab, "Export Non-Translatables",
                str(nt_path / f"{current_name}.svntl"),
                "Supervertaler NT List (*.svntl);;Plain Text (*.txt)"
            )
            
            if not filepath:
                return
            
            if "Plain Text" in selected_filter or filepath.lower().endswith('.txt'):
                success = self.nt_manager.export_to_plain_text(current_name, filepath)
            else:
                success = self.nt_manager.export_list(current_name, filepath)
            
            if success:
                QMessageBox.information(tab, "Export Complete", f"Exported to:\n{filepath}")
            else:
                QMessageBox.warning(tab, "Export Error", "Failed to export. Check the log for details.")
        
        export_btn.clicked.connect(on_export)
        
        # Delete list
        def on_delete():
            current_name = list_combo.currentData()
            if not current_name or current_name not in self.nt_manager.lists:
                return
            
            confirm = QMessageBox.question(
                tab, "Delete List",
                f"Are you sure you want to delete '{current_name}'?\n\nThis cannot be undone.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if confirm == QMessageBox.StandardButton.Yes:
                self.nt_manager.delete_list(current_name)
                refresh_list_combo()
                refresh_entry_table()
        
        delete_btn.clicked.connect(on_delete)
        
        # Initial population
        refresh_list_combo()
        if list_combo.count() > 0:
            refresh_entry_table()
        
        return tab
    
    def create_prompt_manager_tab(self) -> QWidget:
        """Create the Unified Prompt Library tab - Simplified 2-Layer Architecture"""
        from modules.unified_prompt_manager_qt import UnifiedPromptManagerQt
        
        # Create Unified Prompt Manager widget (embedded mode, not standalone)
        prompt_widget = QWidget()
        self.prompt_manager_qt = UnifiedPromptManagerQt(self, standalone=False)
        self.prompt_manager_qt.create_tab(prompt_widget)
        
        return prompt_widget
    
    
    def create_superconverter_tab(self) -> QWidget:
        """Create the Superconverter tab - Format conversion tools"""
        container = QWidget()
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)
        
        # Header
        header = QLabel("üîÑ Superconverter")
        header.setStyleSheet("font-size: 16pt; font-weight: bold; color: #1976D2;")
        main_layout.addWidget(header)
        
        # Description
        description = QLabel(
            "Convert translation data between different formats - perfect for AI workflows, CAT tool exchanges, and data processing."
        )
        description.setWordWrap(True)
        description.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        main_layout.addWidget(description)
        
        main_layout.addSpacing(5)
        
        # Create tabbed interface for different conversion types
        tabs = QTabWidget()
        tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; }")
        
        # Tab 1: Bilingual Export (current project)
        bilingual_tab = QWidget()
        bilingual_layout = QVBoxLayout(bilingual_tab)
        bilingual_layout.setContentsMargins(15, 15, 15, 15)
        
        bilingual_info = QLabel(
            "<b>Export Current Project</b><br><br>"
            "Export your translation project as a Markdown table - perfect for AI chat interfaces like ChatGPT and Claude.<br><br>"
            "The table format renders beautifully and makes it easy for AI to understand and process your segments."
        )
        bilingual_info.setWordWrap(True)
        bilingual_info.setTextFormat(Qt.TextFormat.RichText)
        bilingual_layout.addWidget(bilingual_info)
        
        bilingual_layout.addSpacing(15)
        
        bilingual_btn = QPushButton("üìÑ Export as Markdown Table")
        bilingual_btn.setMinimumHeight(40)
        bilingual_btn.setStyleSheet(
            "QPushButton { background-color: #2196F3; color: white; font-weight: bold; "
            "border: none; border-radius: 5px; padding: 10px; outline: none; }"
            "QPushButton:hover { background-color: #1976D2; }"
        )
        bilingual_btn.clicked.connect(self.export_bilingual_table_markdown)
        bilingual_layout.addWidget(bilingual_btn)
        
        bilingual_layout.addStretch()
        tabs.addTab(bilingual_tab, "üìä Bilingual Table")
        
        # Tab 2: Document Converter (monolingual docs to Markdown)
        doc_tab = QWidget()
        doc_layout = QVBoxLayout(doc_tab)
        doc_layout.setContentsMargins(15, 15, 15, 15)
        
        doc_info = QLabel(
            "<b>Convert Documents to Markdown</b><br><br>"
            "Convert DOCX or TXT documents to Markdown format, preserving structure (headings, lists, paragraphs).<br><br>"
            "Perfect for preparing documents for AI processing or publishing on web platforms."
        )
        doc_info.setWordWrap(True)
        doc_info.setTextFormat(Qt.TextFormat.RichText)
        doc_layout.addWidget(doc_info)
        
        doc_layout.addSpacing(15)
        
        # Single file button
        single_doc_btn = QPushButton("üìÑ Convert Single Document")
        single_doc_btn.setMinimumHeight(40)
        single_doc_btn.setStyleSheet(
            "QPushButton { background-color: #4CAF50; color: white; font-weight: bold; "
            "border: none; border-radius: 5px; padding: 10px; outline: none; }"
            "QPushButton:hover { background-color: #388E3C; }"
        )
        single_doc_btn.clicked.connect(self.convert_document_to_markdown)
        doc_layout.addWidget(single_doc_btn)
        
        doc_layout.addSpacing(10)
        
        # Batch conversion button
        batch_doc_btn = QPushButton("üìÅ Batch Convert Multiple Documents")
        batch_doc_btn.setMinimumHeight(40)
        batch_doc_btn.setStyleSheet(
            "QPushButton { background-color: #FF9800; color: white; font-weight: bold; "
            "border: none; border-radius: 5px; padding: 10px; outline: none; }"
            "QPushButton:hover { background-color: #F57C00; }"
        )
        batch_doc_btn.clicked.connect(self.batch_convert_documents_to_markdown)
        doc_layout.addWidget(batch_doc_btn)
        
        doc_layout.addStretch()
        tabs.addTab(doc_tab, "üìù Document ‚Üí Markdown")
        
        # Tab 3: TMX Tools (placeholder for future)
        tmx_tab = QWidget()
        tmx_layout = QVBoxLayout(tmx_tab)
        tmx_layout.setContentsMargins(15, 15, 15, 15)
        
        tmx_info = QLabel(
            "<b>TMX Conversion Tools</b><br><br>"
            "Convert Translation Memory eXchange (TMX) files to and from tab-delimited format.<br><br>"
            "<i>Coming soon...</i>"
        )
        tmx_info.setWordWrap(True)
        tmx_info.setTextFormat(Qt.TextFormat.RichText)
        tmx_info.setStyleSheet("color: #888;")
        tmx_layout.addWidget(tmx_info)
        
        tmx_layout.addSpacing(15)
        
        tmx_to_tsv_btn = QPushButton("TMX ‚Üí Tab-delimited")
        tmx_to_tsv_btn.setMinimumHeight(40)
        tmx_to_tsv_btn.setEnabled(False)
        tmx_to_tsv_btn.setStyleSheet("QPushButton:disabled { color: #999; background-color: #E0E0E0; }")
        tmx_layout.addWidget(tmx_to_tsv_btn)
        
        tmx_layout.addSpacing(10)
        
        tsv_to_tmx_btn = QPushButton("Tab-delimited ‚Üí TMX")
        tsv_to_tmx_btn.setMinimumHeight(40)
        tsv_to_tmx_btn.setEnabled(False)
        tsv_to_tmx_btn.setStyleSheet("QPushButton:disabled { color: #999; background-color: #E0E0E0; }")
        tmx_layout.addWidget(tsv_to_tmx_btn)
        
        tmx_layout.addStretch()
        tabs.addTab(tmx_tab, "üîÑ TMX Tools")
        
        main_layout.addWidget(tabs)
        
        return container
    
    def create_supercleaner_tab(self) -> QWidget:
        """Create the Supercleaner tab - Clean DOCX documents"""
        from modules.supercleaner_ui import SupercleanerUI
        
        # Create container widget with header
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)
        
        # Header (matches TMX Editor / AutoFingers / PDF Rescue style)
        header = QLabel("üßπ Supercleaner")
        header.setStyleSheet("font-size: 16pt; font-weight: bold; color: #1976D2;")
        layout.addWidget(header, 0)
        
        # Description box (matches other tools style)
        description = QLabel(
            "Clean DOCX documents before translation - removes formatting issues, excessive tags, and OCR artifacts.\n"
            "Inspired by TransTools Document Cleaner, Unbreaker, and CodeZapper."
        )
        description.setWordWrap(True)
        description.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(description, 0)
        
        # Create Supercleaner UI widget
        supercleaner = SupercleanerUI(parent=self)
        layout.addWidget(supercleaner, 1)  # 1 = stretch factor
        
        # Store reference
        self.supercleaner_embedded = supercleaner
        
        return container
    
    def create_tmx_editor_tab(self) -> QWidget:
        """Create the TMX Editor tab - Edit TMs"""
        from modules.tmx_editor_qt import TmxEditorUIQt
        
        # Create container widget with Superlookup style header
        container = QWidget()
        layout = QVBoxLayout(container)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)  # Reduced from 10 to 5 for tighter spacing
        
        # Header (matches Superlookup / AutoFingers / PDF Rescue style)
        header = QLabel("üìù TMX Editor")
        header.setStyleSheet("font-size: 16pt; font-weight: bold; color: #1976D2;")
        layout.addWidget(header, 0)  # 0 = no stretch, stays compact
        
        # Description box (matches Superlookup / AutoFingers / PDF Rescue style)
        description = QLabel(
            "Edit translation memory files directly - inspired by Heartsome TMX Editor.\n"
            "Open, edit, filter, and manage your TMX translation memories."
        )
        description.setWordWrap(True)
        description.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(description, 0)  # 0 = no stretch, stays compact
        
        # Create TMX Editor widget (embedded mode) - pass database manager
        tmx_editor = TmxEditorUIQt(parent=None, standalone=False, db_manager=self.db_manager)
        layout.addWidget(tmx_editor, 1)  # 1 = stretch factor, expands to fill space
        
        # Store reference for potential future use
        self.tmx_editor_embedded = tmx_editor
        
        return container
    
    def create_reference_images_tab(self) -> QWidget:
        """Create the Image Context tab - Load images as visual context for AI translation"""
        from modules.image_extractor import ImageExtractor
        
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(5)
        
        # === IMAGE CONTEXT SECTION (TOP) ===
        context_group = QGroupBox("üéØ Image Context - Load Images for AI Translation")
        context_layout = QVBoxLayout()
        
        # Description
        context_desc = QLabel(
            "Load figure images to automatically include with AI translations when text references them (e.g., 'Figure 1', 'see fig 2A').\n"
            "The AI will 'see' the images and better translate technical descriptions and part references."
        )
        context_desc.setWordWrap(True)
        context_desc.setStyleSheet("font-size: 10px; padding: 5px; border-radius: 3px;")
        context_layout.addWidget(context_desc)
        
        # Context controls row
        context_controls = QHBoxLayout()
        
        load_context_btn = QPushButton("üìÅ Load Images Folder")
        load_context_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border-radius: 3px;
                border: none;
                outline: none;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
        """)
        load_context_btn.clicked.connect(self._on_load_image_context_folder)
        context_controls.addWidget(load_context_btn)
        
        clear_context_btn = QPushButton("üóëÔ∏è Clear")
        clear_context_btn.clicked.connect(self._on_clear_image_context)
        clear_context_btn.setMaximumWidth(80)
        context_controls.addWidget(clear_context_btn)
        
        # Status label
        self.image_context_status_label = QLabel("No images loaded")
        self.image_context_status_label.setStyleSheet("color: #999; font-size: 11px; padding: 5px;")
        context_controls.addWidget(self.image_context_status_label, 1)
        
        context_layout.addLayout(context_controls)
        context_group.setLayout(context_layout)
        main_layout.addWidget(context_group)
        
        # === IMAGE EXTRACTOR SECTION (BOTTOM) ===
        extractor_group = QGroupBox("üõ†Ô∏è Image Extractor - Extract Images from DOCX Files")
        extractor_layout = QVBoxLayout()
        
        # Compact header with title and extract button in one row
        header_layout = QHBoxLayout()
        
        title = QLabel("Extract images to save them for later use as context")
        title.setStyleSheet("font-size: 14px; font-weight: bold; color: #2c3e50;")
        header_layout.addWidget(title)
        
        header_layout.addStretch()
        
        # Extract button (moved to top)
        extract_btn = QPushButton("üñºÔ∏è Extract Images")
        extract_btn.setStyleSheet("""
            QPushButton {
                background-color: #3498db;
                color: white;
                font-weight: bold;
                font-size: 12px;
                padding: 6px 12px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #2980b9;
            }
        """)
        extract_btn.clicked.connect(self._on_extract_images)
        header_layout.addWidget(extract_btn)
        
        main_layout.addLayout(header_layout)
        
        # Compact controls in a single row
        controls_layout = QHBoxLayout()
        
        # Input files
        add_file_btn = QPushButton("üìÑ Add File")
        add_file_btn.clicked.connect(self._on_add_docx_file_for_extraction)
        add_file_btn.setMaximumWidth(100)
        controls_layout.addWidget(add_file_btn)
        
        add_folder_btn = QPushButton("üìÅ Folder")
        add_folder_btn.clicked.connect(self._on_add_docx_folder_for_extraction)
        add_folder_btn.setMaximumWidth(80)
        controls_layout.addWidget(add_folder_btn)
        
        clear_list_btn = QPushButton("üóëÔ∏è")
        clear_list_btn.clicked.connect(lambda: self.image_extractor_file_list.clear())
        clear_list_btn.setMaximumWidth(40)
        clear_list_btn.setToolTip("Clear file list")
        controls_layout.addWidget(clear_list_btn)
        
        # File list (compact, inline)
        self.image_extractor_file_list = QListWidget()
        self.image_extractor_file_list.setMaximumHeight(60)
        self.image_extractor_file_list.setStyleSheet("font-size: 9px;")
        controls_layout.addWidget(self.image_extractor_file_list, 1)
        
        # Auto-folder checkbox
        self.image_extractor_auto_folder = CheckmarkCheckBox("üìÅ Auto-folder")
        self.image_extractor_auto_folder.setChecked(False)
        self.image_extractor_auto_folder.setToolTip("Create 'Images' folder next to each DOCX file")
        self.image_extractor_auto_folder.toggled.connect(self._on_auto_folder_toggled)
        controls_layout.addWidget(self.image_extractor_auto_folder)
        
        # Output directory
        self.image_extractor_output_dir = QLineEdit()
        self.image_extractor_output_dir.setPlaceholderText("Output directory...")
        self.image_extractor_output_dir.setMaximumWidth(200)
        controls_layout.addWidget(self.image_extractor_output_dir)
        
        browse_btn = QPushButton("Browse...")
        browse_btn.clicked.connect(self._on_browse_output_dir_for_extraction)
        browse_btn.setMaximumWidth(80)
        controls_layout.addWidget(browse_btn)
        
        # Filename prefix
        controls_layout.addWidget(QLabel("Prefix:"))
        self.image_extractor_prefix = QLineEdit("Fig.")
        self.image_extractor_prefix.setMaximumWidth(60)
        controls_layout.addWidget(self.image_extractor_prefix)
        
        main_layout.addLayout(controls_layout)
        
        # Main horizontal splitter (left: operations, right: preview)
        results_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left panel: Status and file list
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        status_label = QLabel("üìã Results")
        status_label.setStyleSheet("font-weight: bold; font-size: 9px; color: #666;")
        left_layout.addWidget(status_label)
        
        # Status text area (resizable)
        self.image_extractor_status = QTextEdit()
        self.image_extractor_status.setReadOnly(True)
        self.image_extractor_status.setMinimumHeight(50)
        self.image_extractor_status.setStyleSheet("font-size: 9px;")
        self.image_extractor_status.setPlaceholderText("Extraction status...")
        left_layout.addWidget(self.image_extractor_status)
        
        # Extracted files list
        files_label = QLabel("üìÇ Extracted Files (click to preview)")
        files_label.setStyleSheet("font-weight: bold; font-size: 9px; color: #666; margin-top: 3px;")
        left_layout.addWidget(files_label)
        
        self.image_extractor_files_list = QListWidget()
        self.image_extractor_files_list.itemClicked.connect(self._on_file_list_item_clicked)
        self.image_extractor_files_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #ccc;
                font-size: 9px;
            }
            QListWidget::item {
                padding: 3px;
                border-bottom: 1px solid #eee;
            }
            QListWidget::item:selected {
                background-color: #e3f2fd;
                color: black;
            }
        """)
        left_layout.addWidget(self.image_extractor_files_list)
        
        results_splitter.addWidget(left_widget)
        
        # Right panel: Full-height image preview
        preview_widget = QWidget()
        preview_layout = QVBoxLayout(preview_widget)
        preview_layout.setContentsMargins(0, 0, 0, 0)
        
        preview_label = QLabel("üñºÔ∏è Image Preview")
        preview_label.setStyleSheet("font-weight: bold; font-size: 9px; color: #666;")
        preview_layout.addWidget(preview_label)
        
        # Large image display area with scroll
        preview_scroll = QScrollArea()
        preview_scroll.setWidgetResizable(True)
        preview_scroll.setStyleSheet("QScrollArea { border: 1px solid #ccc; }")
        preview_scroll.setMinimumWidth(300)
        
        self.image_extractor_preview = QLabel()
        self.image_extractor_preview.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.image_extractor_preview.setStyleSheet("padding: 10px;")
        self.image_extractor_preview.setText("No image selected\n\nClick on a file in the list to preview\nor\nExtract images to see them here")
        self.image_extractor_preview.setWordWrap(True)
        
        preview_scroll.setWidget(self.image_extractor_preview)
        preview_layout.addWidget(preview_scroll)
        
        # Preview navigation buttons at bottom
        nav_layout = QHBoxLayout()
        
        self.preview_prev_btn = QPushButton("‚óÄ Previous")
        self.preview_prev_btn.clicked.connect(self._on_preview_prev)
        self.preview_prev_btn.setEnabled(False)
        nav_layout.addWidget(self.preview_prev_btn)
        
        self.preview_image_label = QLabel("No images")
        self.preview_image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.preview_image_label.setStyleSheet("font-size: 8px; color: #666;")
        nav_layout.addWidget(self.preview_image_label)
        
        self.preview_next_btn = QPushButton("Next ‚ñ∂")
        self.preview_next_btn.clicked.connect(self._on_preview_next)
        self.preview_next_btn.setEnabled(False)
        nav_layout.addWidget(self.preview_next_btn)
        
        preview_layout.addLayout(nav_layout)
        
        results_splitter.addWidget(preview_widget)
        
        # Set initial splitter sizes (40% left, 60% right)
        results_splitter.setSizes([400, 600])
        
        main_layout.addWidget(results_splitter)
        
        # Initialize extractor and preview state
        self.image_extractor = ImageExtractor()
        self.extracted_image_files = []
        self.current_preview_index = 0
        
        return tab
    
    def create_pdf_rescue_tab(self) -> QWidget:
        """Create the PDF Rescue tab - AI OCR"""
        from modules.pdf_rescue_Qt import PDFRescueQt
        
        # Create PDF Rescue widget (embedded mode, not standalone)
        pdf_rescue_widget = QWidget()
        self.pdf_rescue_qt = PDFRescueQt(self, standalone=False)
        self.pdf_rescue_qt.create_tab(pdf_rescue_widget)
        
        return pdf_rescue_widget
    
    def create_encoding_repair_tab(self) -> QWidget:
        """Create the Encoding Repair tab - Text Encoding Tool"""
        from modules.encoding_repair_Qt import EncodingRepairQt
        
        # Create Encoding Repair widget (embedded mode, not standalone)
        encoding_repair_widget = QWidget()
        self.encoding_repair_qt = EncodingRepairQt(self, standalone=False)
        self.encoding_repair_qt.create_tab(encoding_repair_widget)
        
        return encoding_repair_widget
    
    def create_tracked_changes_tab(self) -> QWidget:
        """Create the Tracked Changes tab - Post-Translation Analysis"""
        return self._create_placeholder_tab(
            "üìä Tracked Changes",
            "Tracked Changes - Coming Soon\n\nFeatures:\n‚Ä¢ Track translation changes\n‚Ä¢ Version history\n‚Ä¢ Comparison reports"
        )
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # Image Extractor Helper Methods
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _on_add_docx_file_for_extraction(self):
        """Add a single DOCX file to the extraction list"""
        file_path, _ = fdh.get_open_file_name(
            self,
            "Select DOCX File",
            "Word Documents (*.docx)"
        )
        
        if file_path:
            # Avoid duplicates
            items = [self.image_extractor_file_list.item(i).text() 
                    for i in range(self.image_extractor_file_list.count())]
            if file_path not in items:
                self.image_extractor_file_list.addItem(file_path)
    
    def _on_add_docx_folder_for_extraction(self):
        """Add all DOCX files from a folder to the extraction list"""
        folder_path = fdh.get_existing_directory(
            self,
            "Select Folder Containing DOCX Files"
        )
        
        if folder_path:
            import glob
            docx_files = glob.glob(os.path.join(folder_path, "*.docx"))
            
            # Get existing items to avoid duplicates
            items = [self.image_extractor_file_list.item(i).text() 
                    for i in range(self.image_extractor_file_list.count())]
            
            added = 0
            for docx_file in docx_files:
                if docx_file not in items:
                    self.image_extractor_file_list.addItem(docx_file)
                    added += 1
            
            if added > 0:
                self.image_extractor_status.append(f"‚úÖ Added {added} DOCX file(s) from folder")
    
    def _on_browse_output_dir_for_extraction(self):
        """Browse for output directory"""
        folder_path = fdh.get_existing_directory(
            self,
            "Select Output Directory for Extracted Images"
        )
        
        if folder_path:
            self.image_extractor_output_dir.setText(folder_path)
    
    def _on_auto_folder_toggled(self, checked):
        """Handle auto-folder checkbox toggle"""
        # Disable/enable output directory selection based on auto-folder
        self.image_extractor_output_dir.setEnabled(not checked)
        
        if checked:
            self.image_extractor_output_dir.setPlaceholderText("Auto: 'Images' folder next to each DOCX")
        else:
            self.image_extractor_output_dir.setPlaceholderText("Choose output directory...")
    
    def _on_file_list_item_clicked(self, item):
        """Handle click on extracted file list item"""
        if not item:
            return
        
        # Get the file path stored in the item
        file_path = item.data(Qt.ItemDataRole.UserRole)
        
        if file_path and file_path in self.extracted_image_files:
            # Update current index and preview
            self.current_preview_index = self.extracted_image_files.index(file_path)
            self._update_preview()
    
    def _on_extract_images(self):
        """Extract images from all DOCX files in the list"""
        # Validate inputs
        if self.image_extractor_file_list.count() == 0:
            QMessageBox.warning(
                self,
                "No Files",
                "Please add at least one DOCX file to extract images from."
            )
            return
        
        # Check if using auto-folder mode
        use_auto_folder = self.image_extractor_auto_folder.isChecked()
        
        if not use_auto_folder:
            output_dir = self.image_extractor_output_dir.text().strip()
            if not output_dir:
                QMessageBox.warning(
                    self,
                    "No Output Directory",
                    "Please select an output directory for the extracted images."
                )
                return
        
        prefix = self.image_extractor_prefix.text().strip()
        if not prefix:
            prefix = "Fig."
        
        # Get list of files
        docx_files = [self.image_extractor_file_list.item(i).text() 
                     for i in range(self.image_extractor_file_list.count())]
        
        # Clear status, file list, and preview
        self.image_extractor_status.clear()
        self.image_extractor_status.append("üîÑ Starting image extraction...\n")
        self.image_extractor_files_list.clear()
        self.extracted_image_files = []
        self.current_preview_index = 0
        self.image_extractor_preview.setText("No image selected\n\nClick on a file in the list to preview\nor\nExtract images to see them here")
        QApplication.processEvents()
        
        try:
            total_count = 0
            all_extracted_files = []
            
            if use_auto_folder:
                # Extract to "Images" folder next to each DOCX
                self.image_extractor_status.append("üìÅ Mode: Auto-folder (Images subfolder per DOCX)\n")
                
                for docx_file in docx_files:
                    docx_dir = os.path.dirname(docx_file)
                    docx_name = os.path.splitext(os.path.basename(docx_file))[0]
                    auto_output_dir = os.path.join(docx_dir, "Images")
                    
                    self.image_extractor_status.append(f"üìÑ Processing: {os.path.basename(docx_file)}")
                    
                    count, files = self.image_extractor.extract_images_from_docx(
                        docx_file,
                        auto_output_dir,
                        prefix
                    )
                    
                    total_count += count
                    all_extracted_files.extend(files)
                    
                    if count > 0:
                        self.image_extractor_status.append(f"   ‚úÖ {count} image(s) ‚Üí {auto_output_dir}")
                    else:
                        self.image_extractor_status.append(f"   ‚ö†Ô∏è  No images found")
                    
                    QApplication.processEvents()
                
                output_msg = f"Images saved in 'Images' subfolders next to each DOCX file"
            else:
                # Extract all to single directory
                output_dir = self.image_extractor_output_dir.text().strip()
                self.image_extractor_status.append(f"üìÅ Output directory: {output_dir}\n")
                
                total_count, all_extracted_files = self.image_extractor.extract_from_multiple_docx(
                    docx_files, 
                    output_dir, 
                    prefix
                )
                
                output_msg = output_dir
            
            # Show results
            self.image_extractor_status.append(f"\n‚úÖ Successfully extracted {total_count} images!")
            
            if all_extracted_files:
                # Store files for preview
                self.extracted_image_files = all_extracted_files
                self.current_preview_index = 0
                
                # Populate file list
                self.image_extractor_files_list.clear()
                for i, file_path in enumerate(all_extracted_files, 1):
                    item = QListWidgetItem(f"{i}. {os.path.basename(file_path)}")
                    item.setData(Qt.ItemDataRole.UserRole, file_path)  # Store full path
                    item.setToolTip(file_path)  # Show full path on hover
                    self.image_extractor_files_list.addItem(item)
                
                # Enable preview buttons
                if len(self.extracted_image_files) > 0:
                    self.preview_prev_btn.setEnabled(len(self.extracted_image_files) > 1)
                    self.preview_next_btn.setEnabled(len(self.extracted_image_files) > 1)
                    
                    # Select and show first image
                    self.image_extractor_files_list.setCurrentRow(0)
                    self._update_preview()
            
            # Success message
            QMessageBox.information(
                self,
                "Extraction Complete",
                f"Successfully extracted {total_count} images!\n\n{output_msg}"
            )
            
        except Exception as e:
            self.image_extractor_status.append(f"\n‚ùå Error: {str(e)}")
            QMessageBox.critical(
                self,
                "Extraction Error",
                f"An error occurred during extraction:\n{str(e)}"
            )
    
    def _update_preview(self):
        """Update the image preview with the current image"""
        if not self.extracted_image_files or self.current_preview_index >= len(self.extracted_image_files):
            self.image_extractor_preview.setText("No image selected\n\nClick on a file in the list to preview\nor\nExtract images to see them here")
            self.preview_image_label.setText("No images")
            return
        
        image_path = self.extracted_image_files[self.current_preview_index]
        
        # Update list selection to match current preview
        if hasattr(self, 'image_extractor_files_list'):
            self.image_extractor_files_list.setCurrentRow(self.current_preview_index)
        
        try:
            from PyQt6.QtGui import QPixmap
            
            pixmap = QPixmap(image_path)
            
            if not pixmap.isNull():
                # Get the scroll area size for better scaling
                scroll_area = self.image_extractor_preview.parent()
                if scroll_area and hasattr(scroll_area, 'viewport'):
                    viewport_size = scroll_area.viewport().size()
                    max_width = viewport_size.width() - 40  # Account for padding
                    max_height = viewport_size.height() - 40
                else:
                    # Fallback to larger default size
                    max_width = 800
                    max_height = 600
                
                # Scale image to fit preview area while maintaining aspect ratio
                scaled_pixmap = pixmap.scaled(
                    max_width, max_height,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                )
                
                self.image_extractor_preview.setPixmap(scaled_pixmap)
                
                # Update label with size info
                self.preview_image_label.setText(
                    f"Image {self.current_preview_index + 1} of {len(self.extracted_image_files)}: "
                    f"{os.path.basename(image_path)} ({pixmap.width()}√ó{pixmap.height()}px)"
                )
            else:
                self.image_extractor_preview.setText(f"Failed to load image:\n{os.path.basename(image_path)}")
                
        except Exception as e:
            self.image_extractor_preview.setText(f"Error loading image:\n{str(e)}")
    
    def _on_preview_prev(self):
        """Show previous image in preview"""
        if self.extracted_image_files and self.current_preview_index > 0:
            self.current_preview_index -= 1
            self._update_preview()
    
    def _on_preview_next(self):
        """Show next image in preview"""
        if self.extracted_image_files and self.current_preview_index < len(self.extracted_image_files) - 1:
            self.current_preview_index += 1
            self._update_preview()

    # === IMAGE CONTEXT METHODS ===
    
    def _on_load_image_context_folder(self):
        """Load a folder of figure images for AI translation context"""
        from PyQt6.QtWidgets import QFileDialog
        
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Folder with Figure Images",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if folder:
            try:
                count = self.figure_context.load_from_folder(folder)
                
                if count > 0:
                    self.image_context_status_label.setText(
                        f"‚úÖ {count} image{'s' if count != 1 else ''} loaded from: {os.path.basename(folder)}"
                    )
                    self.image_context_status_label.setStyleSheet("color: #4CAF50; font-weight: bold; font-size: 11px; padding: 5px;")
                    self.log(f"[Image Context] Loaded {count} images from {folder}")
                    
                    # Update Prompt Manager display
                    if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                        self.prompt_manager_qt.update_image_context_display()
                    
                    QMessageBox.information(
                        self,
                        "Images Loaded",
                        f"Successfully loaded {count} figure image{'s' if count != 1 else ''}.\n\n"
                        f"These images will automatically be included with AI translations when the text "
                        f"references figures (e.g., 'Figure 1', 'see fig 2A')."
                    )
                else:
                    self.image_context_status_label.setText("‚ö†Ô∏è No valid images found in folder")
                    self.image_context_status_label.setStyleSheet("color: #FF9800; font-size: 11px; padding: 5px;")
                    QMessageBox.warning(
                        self,
                        "No Images Found",
                        "The selected folder does not contain any valid image files.\n\n"
                        "Supported formats: .png, .jpg, .jpeg, .gif, .bmp, .tiff\n"
                        "Filename examples: 'Figure 1.png', 'fig2a.jpg', 'Fig. 3-B.png'"
                    )
            except Exception as e:
                self.image_context_status_label.setText(f"‚ùå Error loading images")
                self.image_context_status_label.setStyleSheet("color: #F44336; font-size: 11px; padding: 5px;")
                self.log(f"[Image Context] Error loading images: {e}")
                QMessageBox.critical(
                    self,
                    "Error Loading Images",
                    f"Failed to load images from folder:\n\n{str(e)}"
                )
    
    def _on_clear_image_context(self):
        """Clear all loaded image context"""
        if self.figure_context.has_images():
            reply = QMessageBox.question(
                self,
                "Clear Image Context",
                f"Clear {self.figure_context.get_image_count()} loaded image{'s' if self.figure_context.get_image_count() != 1 else ''}?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.figure_context.clear()
                self.image_context_status_label.setText("No images loaded")
                self.image_context_status_label.setStyleSheet("color: #999; font-size: 11px; padding: 5px;")
                self.log("[Image Context] Cleared all images")
                
                # Update Prompt Manager display
                if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                    self.prompt_manager_qt.update_image_context_display()
        else:
            QMessageBox.information(
                self,
                "No Images Loaded",
                "There are no images currently loaded."
            )

    def create_llm_leaderboard_tab(self) -> QWidget:
        """Create the Superbench tab - Benchmark LLM translation quality"""
        from modules.llm_superbench_ui import LLMLeaderboardUI

        # Create LLM client factory that uses existing API keys
        def llm_client_factory(provider: str, model_id: str):
            from modules.llm_clients import LLMClient
            api_keys = self._get_api_keys()

            # Map provider names to API key names
            # (gemini uses "google" as the key name in api_keys.txt)
            provider_to_key = {
                "openai": "openai",
                "claude": "claude",
                "gemini": "google"  # Gemini uses Google API key
            }

            key_name = provider_to_key.get(provider, provider)
            api_key = api_keys.get(key_name, "")

            if not api_key:
                raise ValueError(f"No API key configured for {provider}. Please add it in Settings.")

            return LLMClient(api_key=api_key, provider=provider, model=model_id)

        # Create and return the leaderboard UI widget
        leaderboard_widget = LLMLeaderboardUI(
            parent=self,
            llm_client_factory=llm_client_factory
        )

        return leaderboard_widget

    def create_superbrowser_tab(self) -> QWidget:
        """Create the Superbrowser tab - Multi-Chat AI Browser"""
        from modules.superbrowser import SuperbrowserWidget

        # Create and return the Superbrowser widget
        superbrowser_widget = SuperbrowserWidget(parent=self, user_data_path=self.user_data_path)

        return superbrowser_widget

    def create_superdocs_tab(self) -> QWidget:
        """Create the Help tab - Online Documentation Viewer"""
        # The embedded docs viewer was removed in favor of online documentation.
        placeholder = QWidget()
        layout = QVBoxLayout(placeholder)
        label = QLabel("üìö Supervertaler Help is now available online.\n\nVisit https://supervertaler.gitbook.io/superdocs/ to view the documentation.")
        label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        label.setStyleSheet("color: #888; font-size: 12px;")
        layout.addWidget(label)
        return placeholder

    def _get_api_keys(self) -> dict:
        """Get API keys from settings"""
        from modules.llm_clients import load_api_keys
        return load_api_keys()
    
    def show_concordance_search(self, initial_query: str = None):
        """
        Show concordance search (Ctrl+K) - now uses Superlookup instead of separate dialog.
        
        Superlookup provides concordance search plus:
        - Termbase search
        - Machine Translation
        - Web Resources
        
        The view can be toggled between Horizontal (table) and Vertical (list) modes.
        """
        try:
            # Get selected text if available and no initial query
            if not initial_query:
                # First check the currently focused widget (most reliable)
                focus_widget = QApplication.focusWidget()
                if focus_widget and hasattr(focus_widget, 'textCursor'):
                    cursor = focus_widget.textCursor()
                    if cursor.hasSelection():
                        initial_query = cursor.selectedText()
                        self.log(f"[Concordance] Got selection from focus widget: '{initial_query[:30]}...'")
                
                # Fallback: check source/target cells directly
                if not initial_query and hasattr(self, 'table') and self.table:
                    current_row = self.table.currentRow()
                    if current_row >= 0:
                        # Try source column first (column 2)
                        source_widget = self.table.cellWidget(current_row, 2)
                        if source_widget and hasattr(source_widget, 'textCursor'):
                            cursor = source_widget.textCursor()
                            if cursor.hasSelection():
                                initial_query = cursor.selectedText()
                        
                        # If no selection in source, try target column (column 3)
                        if not initial_query:
                            target_widget = self.table.cellWidget(current_row, 3)
                            if target_widget and hasattr(target_widget, 'textCursor'):
                                cursor = target_widget.textCursor()
                                if cursor.hasSelection():
                                    initial_query = cursor.selectedText()
            
            # Get project language pair
            source_lang = getattr(self, 'source_language', None)
            target_lang = getattr(self, 'target_language', None)
            
            # Log for debugging
            if initial_query:
                self.log(f"[Concordance] Opening Superlookup with query: '{initial_query[:50]}...' (lang: {source_lang} ‚Üí {target_lang})")
            else:
                self.log(f"[Concordance] Opening Superlookup (no selection)")
            
            # Navigate to Superlookup tab
            self._go_to_superlookup()
            
            # Trigger search if we have a query
            if hasattr(self, 'lookup_tab') and self.lookup_tab:
                if initial_query:
                    # Use vertical view for traditional concordance layout
                    # Pass language pair from project
                    self.lookup_tab.search_with_query(
                        initial_query, 
                        switch_to_vertical=True,
                        source_lang=source_lang,
                        target_lang=target_lang
                    )
                else:
                    # Just focus the source text input
                    self.lookup_tab.source_text.setFocus()
                    # Reset language dropdowns to "Any" (index 0) for unrestricted search
                    if hasattr(self.lookup_tab, 'lang_from_combo'):
                        self.lookup_tab.lang_from_combo.setCurrentIndex(0)  # "Any"
                    if hasattr(self.lookup_tab, 'lang_to_combo'):
                        self.lookup_tab.lang_to_combo.setCurrentIndex(0)  # "Any"
                    # Switch to vertical view for consistency
                    if hasattr(self.lookup_tab, 'tm_view_vertical_radio'):
                        self.lookup_tab.tm_view_vertical_radio.setChecked(True)
                        
        except Exception as e:
            self.log(f"Error opening concordance search: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Error", f"Failed to open concordance search:\n{str(e)}")
    
    def show_tm_manager_tab(self, tab_index: int = 0):
        """Show TM Manager dialog opened to specific tab"""
        from modules.tm_manager_qt import TMManagerDialog
        
        try:
            dialog = TMManagerDialog(self, self.db_manager, self.log)
            dialog.tabs.setCurrentIndex(tab_index)
            dialog.exec()
        except Exception as e:
            self.log(f"Error opening TM Manager: {e}")
            QMessageBox.critical(self, "Error", f"Failed to open TM Manager:\n{str(e)}")

    def create_log_tab(self) -> QWidget:
        """Create the Log tab - Session Log"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)

        # Top toolbar with detach button
        toolbar = QWidget()
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(0, 0, 0, 0)

        detach_btn = QPushButton("ü™ü Detach Log Window")
        detach_btn.setToolTip("Open log in a separate window that can be moved to another screen")
        detach_btn.clicked.connect(self.detach_log_window)
        toolbar_layout.addWidget(detach_btn)

        clear_btn = QPushButton("üóëÔ∏è Clear Log")
        clear_btn.setToolTip("Clear all log messages")
        clear_btn.clicked.connect(self.clear_log)
        toolbar_layout.addWidget(clear_btn)

        toolbar_layout.addStretch()
        layout.addWidget(toolbar)

        # Log display area
        self.session_log = QPlainTextEdit()
        self.session_log.setReadOnly(True)
        self.session_log.setStyleSheet("""
            QPlainTextEdit {
                font-family: 'Consolas', 'Courier New', monospace;
                font-size: 9px;
                border: 1px solid #ccc;
            }
        """)
        layout.addWidget(self.session_log)

        # Initialize with welcome message
        self.session_log.setPlainText("Session Log - Ready\n" + "="*50 + "\n")

        # List to track detached log windows
        self.detached_log_windows = []

        return tab

    def detach_log_window(self):
        """Create a detached log window"""
        detached_window = DetachedLogWindow(self)
        detached_window.show()
        self.detached_log_windows.append(detached_window)
        self.log("ü™ü Log window detached")

    def clear_log(self):
        """Clear the log"""
        reply = QMessageBox.question(
            self,
            "Clear Log",
            "Are you sure you want to clear the log?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        if reply == QMessageBox.StandardButton.Yes:
            self.session_log.setPlainText("Session Log - Ready\n" + "="*50 + "\n")
            # Also clear detached windows
            for window in self.detached_log_windows:
                if window and not window.isHidden():
                    window.log_display.setPlainText("Session Log - Ready\n" + "="*50 + "\n")

    def _on_main_tab_changed(self, index: int):
        """Handle main tab changes (Grid/Project resources/Tools/Settings)"""
        try:
            if index == 0:  # Grid
                # Grid refreshes automatically when segments change
                pass
            elif index == 1:  # Project resources
                # Refresh AI Assistant LLM client when switching to Project resources tab
                # Prompts tab is inside Project resources, so refresh LLM settings when going there
                if hasattr(self, 'prompt_manager_qt'):
                    llm_settings = self.load_llm_settings()
                    self.current_provider = llm_settings.get('provider', 'openai')
                    provider_key = f"{self.current_provider}_model"
                    self.current_model = llm_settings.get(provider_key)
                    # Reinitialize AI Assistant's LLM client
                    self.prompt_manager_qt._init_llm_client()
        except Exception as e:
            self.log(f"‚ö†Ô∏è Error switching main tabs: {e}")
            import traceback
            traceback.print_exc()
    
    def detach_superlookup(self):
        """Detach Superlookup into a separate window for second screen use"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QPushButton
        
        try:
            # If already detached, just show the window
            if hasattr(self, 'lookup_detached_window') and self.lookup_detached_window and self.lookup_detached_window.isVisible():
                self.lookup_detached_window.raise_()
                self.lookup_detached_window.activateWindow()
                return
            
            # Create detached window
            self.lookup_detached_window = QDialog(self)
            self.lookup_detached_window.setWindowTitle("üîç Superlookup - Supervertaler")
            self.lookup_detached_window.setMinimumSize(600, 700)
            self.lookup_detached_window.resize(700, 800)
            
            # Set window flags to ensure it appears as a proper window
            self.lookup_detached_window.setWindowFlags(
                Qt.WindowType.Window | 
                Qt.WindowType.WindowCloseButtonHint | 
                Qt.WindowType.WindowMinimizeButtonHint |
                Qt.WindowType.WindowMaximizeButtonHint
            )
            
            # Position window to the right of main window, or center on same screen if no space
            main_geometry = self.geometry()
            
            # Get the screen that contains the main window (handles multi-monitor setups)
            app = QApplication.instance()
            screen = app.screenAt(main_geometry.center())
            if not screen:
                # Fallback to primary screen
                screen = app.primaryScreen()
            
            screen_geometry = screen.geometry()
            
            # Try to place to the right of main window
            new_x = main_geometry.right() + 20
            new_y = main_geometry.top()
            
            # If window would go off-screen to the right, center it on the main window's screen
            if new_x + 700 > screen_geometry.right():
                # Center horizontally on screen, place above main window
                new_x = screen_geometry.left() + (screen_geometry.width() - 700) // 2
                new_y = max(screen_geometry.top() + 50, main_geometry.top() - 100)
                
            # Ensure window stays on screen
            new_x = max(screen_geometry.left() + 10, min(new_x, screen_geometry.right() - 710))
            new_y = max(screen_geometry.top() + 10, min(new_y, screen_geometry.bottom() - 810))
            
            self.lookup_detached_window.move(int(new_x), int(new_y))
            
            # Make sure window is raised and activated - use QTimer to ensure it's after window is shown
            QTimer.singleShot(100, lambda: (
                self.lookup_detached_window.raise_(),
                self.lookup_detached_window.activateWindow(),
                self.lookup_detached_window.setFocus()
            ))
            
            layout = QVBoxLayout(self.lookup_detached_window)
            layout.setContentsMargins(10, 10, 10, 10)
            layout.setSpacing(5)
            
            # Header with reattach button
            header_layout = QVBoxLayout()
            
            header_title = QLabel("üîç Superlookup")
            header_title.setStyleSheet("font-size: 16px; font-weight: bold; color: #333;")
            header_layout.addWidget(header_title)
            
            button_layout = QVBoxLayout()
            reattach_btn = QPushButton("üì• Attach to Main Window")
            reattach_btn.setToolTip("Re-attach Superlookup to the Home tab")
            reattach_btn.setStyleSheet("font-size: 9pt; padding: 4px 12px; max-width: 200px;")
            reattach_btn.clicked.connect(self.reattach_superlookup)
            button_layout.addWidget(reattach_btn, alignment=Qt.AlignmentFlag.AlignRight)
            header_layout.addLayout(button_layout)
            
            layout.addLayout(header_layout)
            
            # Create new Superlookup instance for detached window
            # Or move the existing one - better to create new to avoid widget parenting issues
            detached_lookup = SuperlookupTab(self.lookup_detached_window, user_data_path=self.user_data_path)
            
            # Explicitly copy theme_manager reference
            detached_lookup.theme_manager = self.theme_manager
            
            # Copy TM database reference if available
            if hasattr(self, 'tm_database') and self.tm_database:
                detached_lookup.tm_database = self.tm_database
                if detached_lookup.engine:
                    detached_lookup.engine.set_tm_database(self.tm_database)
            
            # Copy home lookup state if it exists
            if hasattr(self, 'home_lookup_widget') and self.home_lookup_widget:
                # Copy source text
                source_text = self.home_lookup_widget.source_text.toPlainText()
                detached_lookup.source_text.setPlainText(source_text)
                
                # Copy TM database reference
                if hasattr(self.home_lookup_widget, 'tm_database'):
                    detached_lookup.tm_database = self.home_lookup_widget.tm_database
            
            layout.addWidget(detached_lookup, stretch=1)
            
            # Store reference for cleanup
            self.lookup_detached_widget = detached_lookup
            
            # Handle window close
            def on_close():
                self.lookup_detached_window = None
                self.lookup_detached_widget = None
            
            self.lookup_detached_window.finished.connect(on_close)
            
            # Show window (non-modal)
            self.lookup_detached_window.setWindowModality(Qt.WindowModality.NonModal)
            self.lookup_detached_window.show()
            self.log("Superlookup detached to separate window")
        except Exception as e:
            import traceback
            error_msg = f"Error detaching Superlookup: {str(e)}\n{traceback.format_exc()}"
            self.log(error_msg)
            QMessageBox.warning(self, "Error", f"Could not detach Superlookup:\n{str(e)}")
    
    def reattach_superlookup(self):
        """Re-attach Superlookup to the Home tab"""
        if not self.lookup_detached_window:
            return
        
        # Copy state back to home widget if it exists
        if (hasattr(self, 'home_lookup_widget') and self.home_lookup_widget and 
            hasattr(self, 'lookup_detached_widget') and self.lookup_detached_widget):
            # Copy source text
            source_text = self.lookup_detached_widget.source_text.toPlainText()
            self.home_lookup_widget.source_text.setPlainText(source_text)
        
        # Close detached window
        self.lookup_detached_window.close()
        self.lookup_detached_window = None
        if hasattr(self, 'lookup_detached_widget'):
            self.lookup_detached_widget = None
        
        self.log("Superlookup re-attached to Home tab")
    
    def create_resources_tab(self):
        """Create the Project resources tab with nested sub-tabs"""
        from PyQt6.QtWidgets import QTabWidget
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create nested tab widget
        resources_tabs = QTabWidget()
        resources_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        resources_tabs.tabBar().setDrawBase(False)
        resources_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        self.resources_tabs = resources_tabs  # Store for navigation
        
        # Add nested tabs
        tm_tab = self.create_translation_memories_tab()
        resources_tabs.addTab(tm_tab, "üíæ TMs")
        
        termbase_tab = self.create_termbases_tab()
        resources_tabs.addTab(termbase_tab, "üè∑Ô∏è Glossaries")
        
        nt_tab = self.create_non_translatables_tab()
        resources_tabs.addTab(nt_tab, "üö´ Non-Translatables")
        
        ref_tab = self.create_reference_images_tab()
        resources_tabs.addTab(ref_tab, "üéØ Image Context")
        
        layout.addWidget(resources_tabs)
        
        return tab
    
    def create_specialised_tools_tab(self):
        """Create the Specialised Tools tab with nested sub-tabs"""
        from PyQt6.QtWidgets import QTabWidget
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create nested tab widget
        modules_tabs = QTabWidget()
        modules_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        modules_tabs.tabBar().setDrawBase(False)
        modules_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        self.modules_tabs = modules_tabs  # Store for navigation
        
        # Add nested tabs (alphabetical order)
        autofingers_tab = AutoFingersWidget(self)
        modules_tabs.addTab(autofingers_tab, "‚úã AutoFingers")
        
        # Superconverter - Format conversion tools
        superconverter_tab = self.create_superconverter_tab()
        modules_tabs.addTab(superconverter_tab, "üîÑ Superconverter")
        
        pdf_tab = self.create_pdf_rescue_tab()
        modules_tabs.addTab(pdf_tab, "üìÑ PDF Rescue")
        
        # Superbench
        leaderboard_tab = self.create_llm_leaderboard_tab()
        modules_tabs.addTab(leaderboard_tab, "üìä Superbench")
        
        # Superbrowser - Multi-Chat AI Browser
        superbrowser_tab = self.create_superbrowser_tab()
        modules_tabs.addTab(superbrowser_tab, "üåê Superbrowser")

        supercleaner_tab = self.create_supercleaner_tab()
        modules_tabs.addTab(supercleaner_tab, "üßπ Supercleaner")

        # Superdocs removed (online GitBook will be used instead)

        lookup_tab = SuperlookupTab(self, user_data_path=self.user_data_path)
        self.lookup_tab = lookup_tab  # Store reference for later use
        modules_tabs.addTab(lookup_tab, "üîç Superlookup")

        # Supervoice - Voice Commands & Dictation
        supervoice_tab = self._create_voice_dictation_settings_tab()
        modules_tabs.addTab(supervoice_tab, "üé§ Supervoice")

        encoding_tab = self.create_encoding_repair_tab()
        modules_tabs.addTab(encoding_tab, "üîß Text Encoding Repair")
        
        tmx_tab = self.create_tmx_editor_tab()
        modules_tabs.addTab(tmx_tab, "‚úèÔ∏è TMX Editor")
        
        tracked_tab = self.create_tracked_changes_tab()
        modules_tabs.addTab(tracked_tab, "üîÑ Tracked Changes")

        layout.addWidget(modules_tabs)

        return tab
    
    def create_translation_memories_tab(self):
        """Create the Translation Memories tab with nested sub-tabs"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Check if database is available
        if not (hasattr(self, 'db_manager') and self.db_manager):
            placeholder = QLabel("Translation Memories Manager\n\nDatabase not initialized.")
            placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            placeholder.setStyleSheet("color: #888; font-size: 12px;")
            layout.addWidget(placeholder, stretch=1)
            return tab
        
        # Import TM metadata manager
        from modules.tm_metadata_manager import TMMetadataManager
        tm_metadata_mgr = TMMetadataManager(self.db_manager, self.log)
        self.tm_metadata_mgr = tm_metadata_mgr  # Store for later use
        
        # Create nested tab widget for TM functionality
        tm_tabs = QTabWidget()
        tm_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        tm_tabs.tabBar().setDrawBase(False)
        tm_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        
        # Tab 1: TM List (Management) - manage multiple TMs
        tm_list_tab = self._create_tm_list_tab(tm_metadata_mgr)
        tm_tabs.addTab(tm_list_tab, "üìã TM List")
        
        # Tab 2: Browse All - browse ALL active TMs together
        from modules.tm_manager_qt import TMManagerDialog
        temp_manager = TMManagerDialog(self, self.db_manager, self.log)
        tm_tabs.addTab(temp_manager.browser_tab, "üìñ Browse All")
        
        # Note: Concordance tab removed - functionality moved to Superlookup (Ctrl+K)
        # Note: Import/Export tab removed - functionality available in TM List tab
        
        # Tab 3: Statistics - aggregate stats for all TMs
        tm_tabs.addTab(temp_manager.stats_tab, "üìä Statistics")
        
        # Tab 4: Maintenance - cleanup and maintenance tools
        tm_tabs.addTab(temp_manager.maintenance_tab, "üßπ Maintenance")
        
        # Store reference to prevent garbage collection
        tab._tm_manager = temp_manager
        
        layout.addWidget(tm_tabs)
        
        return tab
    
    def _create_tm_list_tab(self, tm_metadata_mgr):
        """Create the TM List sub-tab with table and management buttons"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Header
        header = QLabel("üíæ TMs")
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Description
        desc = QLabel("Manage TMs. Activate/deactivate TMs for current project. Import client TMX files as named TMs.")
        desc.setStyleSheet("color: #666; font-size: 11px; margin-bottom: 10px;")
        layout.addWidget(desc)
        
        # Search bar
        search_layout = QHBoxLayout()
        search_box = QLineEdit()
        search_box.setPlaceholderText("Search TMs...")
        search_box.setMaximumWidth(300)
        search_layout.addWidget(search_box)
        search_layout.addStretch()
        layout.addLayout(search_layout)
        
        # Help message for first-time users
        help_msg = QLabel(
            "üí° <b>Translation Memories</b><br>"
            "‚Ä¢ <b>Read</b> (green ‚úì): TM is used for matching segments<br>"
            "‚Ä¢ <b>Write</b> (blue ‚úì): TM is updated with new translations<br>"
            "‚Ä¢ <b>Typical Setup</b>: Main TM (Read + Write) + Reference TMs (Read only)"
        )
        help_msg.setWordWrap(True)
        help_msg.setStyleSheet("background-color: #e3f2fd; padding: 8px; border-radius: 4px; color: #1976d2;")
        layout.addWidget(help_msg)
        
        # Bulk action controls
        bulk_layout = QHBoxLayout()
        bulk_layout.addWidget(QLabel("Quick Actions:"))
        
        read_header_checkbox = CheckmarkCheckBox("Select All Read")
        bulk_layout.addWidget(read_header_checkbox)
        
        write_header_checkbox = BlueCheckmarkCheckBox("Select All Write")
        bulk_layout.addWidget(write_header_checkbox)
        
        bulk_layout.addStretch()
        layout.addLayout(bulk_layout)
        
        # TM list with table
        tm_table = QTableWidget()
        tm_table.setColumnCount(7)
        tm_table.setHorizontalHeaderLabels(["TM Name", "Languages", "Entries", "Read", "Write", "Last Modified", "Description"])
        tm_table.horizontalHeader().setStretchLastSection(True)
        tm_table.setColumnWidth(0, 250)
        tm_table.setColumnWidth(1, 120)
        tm_table.setColumnWidth(2, 80)
        tm_table.setColumnWidth(3, 60)
        tm_table.setColumnWidth(4, 60)
        tm_table.setColumnWidth(5, 150)
        
        # Get current project (for lambda closures below)
        current_project = self.current_project if hasattr(self, 'current_project') else None
        project_id = current_project.id if (current_project and hasattr(current_project, 'id')) else None
        
        # Connect header checkboxes to toggle all
        def toggle_all_read(checked):
            for row in range(tm_table.rowCount()):
                checkbox = tm_table.cellWidget(row, 3)
                if checkbox and isinstance(checkbox, CheckmarkCheckBox):
                    checkbox.setChecked(checked)
        
        def toggle_all_write(checked):
            for row in range(tm_table.rowCount()):
                checkbox = tm_table.cellWidget(row, 4)
                if checkbox and isinstance(checkbox, BlueCheckmarkCheckBox):
                    checkbox.setChecked(checked)
        
        read_header_checkbox.toggled.connect(toggle_all_read)
        write_header_checkbox.toggled.connect(toggle_all_write)
        
        # Populate TM list
        def refresh_tm_list():
            # Get current project dynamically (not captured in closure!)
            # Use GLOBAL_PROJECT_ID (0) when no project is loaded for Superlookup support
            current_proj = self.current_project if hasattr(self, 'current_project') else None
            refresh_project_id = current_proj.id if (current_proj and hasattr(current_proj, 'id')) else 0  # 0 = global
            
            tms = tm_metadata_mgr.get_all_tms()
            tm_table.setRowCount(len(tms))
            
            for row, tm in enumerate(tms):
                # Check if active (Read mode) for current project or global (0)
                # Note: is_tm_active now supports project_id=0 for global activations
                is_readable = tm_metadata_mgr.is_tm_active(tm['id'], refresh_project_id)
                # Default: read-only (Write unchecked) - read_only=True means not writable
                # If read_only is not set in database, treat as read-only by default
                is_writable = not tm.get('read_only', True)  # Default to True (read-only) if not set
                
                # TM Name (bold if readable)
                name_item = QTableWidgetItem(tm['name'])
                if is_readable:
                    font = name_item.font()
                    font.setBold(True)
                    name_item.setFont(font)
                tm_table.setItem(row, 0, name_item)
                
                # Languages (normalized format: nl-NL, en-US, etc.)
                from modules.tmx_generator import normalize_lang_variant
                src_lang = normalize_lang_variant(tm['source_lang']) if tm['source_lang'] else '?'
                tgt_lang = normalize_lang_variant(tm['target_lang']) if tm['target_lang'] else '?'
                langs = f"{src_lang} ‚Üí {tgt_lang}"
                tm_table.setItem(row, 1, QTableWidgetItem(langs))
                
                # Entry count
                tm_table.setItem(row, 2, QTableWidgetItem(str(tm['entry_count'])))
                
                # Read checkbox (green checkmark)
                read_checkbox = CheckmarkCheckBox()
                read_checkbox.setChecked(is_readable)
                read_checkbox.setToolTip("Read: TM is used for matching segments")
                
                def on_read_toggle(checked, tm_id=tm['id'], row_idx=row):
                    # Get current project ID dynamically
                    # Use 0 (global) when no project is loaded - allows Superlookup to work
                    curr_proj = self.current_project if hasattr(self, 'current_project') else None
                    curr_proj_id = curr_proj.id if (curr_proj and hasattr(curr_proj, 'id')) else 0  # 0 = global
                    
                    # Activate/deactivate for reading
                    if checked:
                        success = tm_metadata_mgr.activate_tm(tm_id, curr_proj_id)
                    else:
                        success = tm_metadata_mgr.deactivate_tm(tm_id, curr_proj_id)
                    
                    if success:
                        status = "readable" if checked else "not readable"
                        self.log(f"‚úÖ TM {tm_id} set to {status}")
                        # Update name to be bold if readable
                        name_item = tm_table.item(row_idx, 0)
                        if name_item:
                            font = name_item.font()
                            font.setBold(checked)
                            name_item.setFont(font)
                        
                        # Invalidate translation cache so matches are refreshed with new TM settings
                        self.invalidate_translation_cache(smart_invalidation=False)
                    else:
                        self.log(f"‚ùå Failed to toggle TM {tm_id}")
                        # Revert checkbox on failure
                        sender_checkbox = tm_table.cellWidget(row_idx, 3)
                        if sender_checkbox:
                            sender_checkbox.blockSignals(True)
                            sender_checkbox.setChecked(not checked)
                            sender_checkbox.blockSignals(False)
                
                read_checkbox.toggled.connect(on_read_toggle)
                tm_table.setCellWidget(row, 3, read_checkbox)
                
                # Write checkbox (blue checkmark)
                write_checkbox = BlueCheckmarkCheckBox()
                write_checkbox.setChecked(is_writable)
                write_checkbox.setToolTip("Write: TM is updated with new translations")
                
                def on_write_toggle(checked, tm_id=tm['id'], row_idx=row):
                    # Invert logic: checked = writable, so set read_only to NOT checked
                    success = tm_metadata_mgr.set_read_only(tm_id, not checked)
                    if success:
                        status = "writable" if checked else "read-only"
                        self.log(f"‚úÖ TM {tm_id} set to {status}")
                    else:
                        # Revert on failure
                        sender = tm_table.cellWidget(row_idx, 4)
                        if sender:
                            sender.blockSignals(True)
                            sender.setChecked(not checked)
                            sender.blockSignals(False)
                
                write_checkbox.toggled.connect(on_write_toggle)
                tm_table.setCellWidget(row, 4, write_checkbox)
                
                # Last modified
                modified = tm['modified_date'] or tm['created_date'] or ''
                if modified:
                    # Format datetime nicely
                    try:
                        from datetime import datetime
                        dt = datetime.fromisoformat(modified)
                        modified = dt.strftime("%Y-%m-%d %H:%M")
                    except:
                        pass
                tm_table.setItem(row, 5, QTableWidgetItem(modified))
                
                # Description
                desc_text = tm['description'] or ''
                tm_table.setItem(row, 6, QTableWidgetItem(desc_text))
            
            # Update header checkbox states based on current selection
            read_header_checkbox.blockSignals(True)
            write_header_checkbox.blockSignals(True)
            all_read_checked = all(tm_table.cellWidget(r, 3).isChecked() if tm_table.cellWidget(r, 3) else False for r in range(tm_table.rowCount())) if tm_table.rowCount() > 0 else False
            all_write_checked = all(tm_table.cellWidget(r, 4).isChecked() if tm_table.cellWidget(r, 4) else False for r in range(tm_table.rowCount())) if tm_table.rowCount() > 0 else False
            read_header_checkbox.setChecked(all_read_checked)
            write_header_checkbox.setChecked(all_write_checked)
            read_header_checkbox.blockSignals(False)
            write_header_checkbox.blockSignals(False)
        
        # Store callback as instance attribute so load_project can refresh UI after restoration
        self.tm_tab_refresh_callback = refresh_tm_list
        
        refresh_tm_list()
        layout.addWidget(tm_table, stretch=1)
        
        # Button bar
        button_layout = QHBoxLayout()
        
        create_btn = QPushButton("+ Create New TM")
        # Get project_id dynamically - use 0 (global) when no project is loaded
        create_btn.clicked.connect(lambda: self._show_create_tm_dialog(
            tm_metadata_mgr, refresh_tm_list,
            self.current_project.id if (hasattr(self, 'current_project') and self.current_project and hasattr(self.current_project, 'id')) else 0
        ))
        button_layout.addWidget(create_btn)
        
        import_btn = QPushButton("üì• Import TMX")
        import_btn.setToolTip("Import TMX file as a new TM or add to existing TM")
        import_btn.clicked.connect(lambda: self._import_tmx_as_tm(tm_metadata_mgr, tm_table, refresh_tm_list))
        button_layout.addWidget(import_btn)
        
        export_btn = QPushButton("üì§ Export TM")
        export_btn.setToolTip("Export selected TM to TMX file")
        export_btn.clicked.connect(lambda: self._export_tm_to_tmx(tm_metadata_mgr, tm_table))
        button_layout.addWidget(export_btn)
        
        edit_btn = QPushButton("‚úèÔ∏è Edit/Maintain TM")
        edit_btn.setToolTip("Open editor for selected TM (Browse, Import/Export, Maintenance)")
        edit_btn.clicked.connect(lambda: self._show_tm_editor_dialog(tm_metadata_mgr, tm_table))
        button_layout.addWidget(edit_btn)
        
        delete_btn = QPushButton("üóëÔ∏è Delete TM")
        delete_btn.clicked.connect(lambda: self._delete_tm(tm_metadata_mgr, tm_table, refresh_tm_list))
        button_layout.addWidget(delete_btn)
        
        button_layout.addStretch()
        layout.addLayout(button_layout)
        
        return tab
    
    def _show_tm_context_menu(self, tm_table, tm_metadata_mgr, refresh_callback, pos):
        """Show context menu for TM table"""
        current_row = tm_table.rowAt(pos.y())
        if current_row < 0:
            return
        
        # Get TM info from the row (column 0 = TM Name)
        name_item = tm_table.item(current_row, 0)
        if not name_item:
            return
        
        tm_name = name_item.text()
        
        # Find the TM in the list
        all_tms = tm_metadata_mgr.get_all_tms()
        tm = None
        for t in all_tms:
            if t['name'] == tm_name:
                tm = t
                break
        
        if not tm:
            return
        
        menu = QMenu(tm_table)
        
        # Check if this TM is already the project TM
        is_project_tm = tm.get('is_project_tm', False)
        
        # Get current project
        current_proj = self.current_project if hasattr(self, 'current_project') else None
        project_id = current_proj.id if (current_proj and hasattr(current_proj, 'id')) else None
        
        if project_id:
            if not is_project_tm:
                set_project_action = menu.addAction("üìå Set as Project TM")
                set_project_action.triggered.connect(
                    lambda: self._set_tm_as_project(tm['id'], project_id, tm_metadata_mgr, refresh_callback)
                )
            else:
                unset_project_action = menu.addAction("üìå Unset as Project TM")
                unset_project_action.triggered.connect(
                    lambda: self._unset_tm_as_project(tm['id'], tm_metadata_mgr, refresh_callback)
                )
        else:
            no_project_action = menu.addAction("‚ö†Ô∏è Load a project first")
            no_project_action.setEnabled(False)
        
        menu.addSeparator()
        
        # Read-only toggle
        is_readonly = tm.get('read_only', False)
        readonly_text = "‚úèÔ∏è Set as Writable" if is_readonly else "üîí Set as Read-Only"
        readonly_action = menu.addAction(readonly_text)
        readonly_action.triggered.connect(
            lambda: self._toggle_tm_readonly(tm['id'], not is_readonly, tm_metadata_mgr, refresh_callback)
        )
        
        menu.exec(tm_table.viewport().mapToGlobal(pos))
    
    def _set_tm_as_project(self, tm_id, project_id, tm_metadata_mgr, refresh_callback):
        """Set a TM as the project TM"""
        success = tm_metadata_mgr.set_as_project_tm(tm_id, project_id)
        if success:
            self.log(f"‚úÖ Set TM as Project TM")
            refresh_callback()
        else:
            QMessageBox.warning(self, "Error", "Failed to set TM as Project TM")
    
    def _unset_tm_as_project(self, tm_id, tm_metadata_mgr, refresh_callback):
        """Unset a TM as project TM"""
        success = tm_metadata_mgr.unset_project_tm(tm_id)
        if success:
            self.log(f"‚úÖ Unset Project TM")
            refresh_callback()
        else:
            QMessageBox.warning(self, "Error", "Failed to unset Project TM")
    
    def _toggle_tm_readonly(self, tm_id, readonly, tm_metadata_mgr, refresh_callback):
        """Toggle read-only status of a TM"""
        success = tm_metadata_mgr.set_read_only(tm_id, readonly)
        if success:
            status = "read-only" if readonly else "writable"
            self.log(f"‚úÖ Set TM as {status}")
            refresh_callback()
        else:
            QMessageBox.warning(self, "Error", f"Failed to set TM as {'read-only' if readonly else 'writable'}")
    
    def import_tmx_file(self):
        """Import TMX file into translation memory with language variant handling"""
        try:
            file_path, _ = fdh.get_open_file_name(
                self, 
                "Import TMX File", 
                "TMX Files (*.tmx);;All Files (*.*)"
            )
            
            if file_path and self.tm_database:
                # Get target languages
                source_lang = getattr(self.current_project, 'source_lang', 'en') if self.current_project else 'en'
                target_lang = getattr(self.current_project, 'target_lang', 'nl') if self.current_project else 'nl'
                
                # Detect TMX languages
                tmx_langs = self.tm_database.detect_tmx_languages(file_path)
                self.log(f"TMX languages detected: {tmx_langs}")
                
                # Check compatibility
                compat = self.tm_database.check_language_compatibility(tmx_langs, source_lang, target_lang)
                
                if not compat['compatible']:
                    QMessageBox.warning(
                        self, "Language Mismatch",
                        f"TMX file languages ({', '.join(tmx_langs)}) don't match project languages ({source_lang}, {target_lang}).\n\n"
                        "Cannot import this TMX file."
                    )
                    return
                
                # Handle variant mismatch
                if compat.get('variant_match'):
                    choice = self._show_language_variant_dialog(compat)
                    
                    if choice == 'cancel':
                        return
                    
                    # Show progress dialog
                    from PyQt6.QtWidgets import QProgressDialog
                    from PyQt6.QtCore import Qt
                    import time
                    
                    # Create progress dialog with cancel button
                    progress = QProgressDialog("Counting translation units...", "Cancel", 0, 100, self)
                    progress.setWindowTitle("TMX Import")
                    progress.setWindowModality(Qt.WindowModality.WindowModal)
                    progress.setMinimumDuration(0)
                    progress.setAutoClose(False)
                    progress.setAutoReset(False)
                    progress.setValue(0)
                    progress.show()
                    QApplication.processEvents()
                    
                    # Track if user cancelled
                    cancelled = False
                    start_time = time.time()
                    
                    def update_progress(current, total, message):
                        nonlocal cancelled
                        if progress.wasCanceled():
                            cancelled = True
                            return
                        
                        if total > 0:
                            percentage = int((current / total) * 100)
                            progress.setValue(percentage)
                            
                            # Calculate time stats
                            elapsed = time.time() - start_time
                            if current > 0:
                                rate = current / elapsed
                                remaining = (total - current) / rate if rate > 0 else 0
                                
                                # Format message with stats
                                time_info = f" (~{int(remaining/60)}m {int(remaining%60)}s remaining)" if remaining > 10 else ""
                                progress.setLabelText(f"{message}\nRate: {int(rate):,} entries/sec{time_info}")
                            else:
                                progress.setLabelText(message)
                        else:
                            progress.setLabelText(message)
                        
                        QApplication.processEvents()
                    
                    if choice == 'import_strip':
                        # Import with variant stripping
                        tm_id, count = self.tm_database.load_tmx_file(
                            file_path, source_lang, target_lang, 
                            tm_name=None, read_only=False, progress_callback=update_progress
                        )
                        progress.close()
                        
                        if not cancelled:
                            self.log(f"Imported {count} entries (variants stripped: {compat['tmx_source']}, {compat['tmx_target']} ‚Üí {source_lang}, {target_lang})")
                            QMessageBox.information(
                                self, "Import Complete",
                                f"TMX imported successfully!\n\nEntries: {count:,}\n"
                                f"Mapped: {compat['tmx_source']}, {compat['tmx_target']} ‚Üí {source_lang}, {target_lang}"
                            )
                        else:
                            self.log("TMX import cancelled by user")
                            QMessageBox.information(self, "Import Cancelled", f"Import stopped.\n\nPartial entries may have been imported: {count:,}")
                    elif choice == 'create_new':
                        # Create new TM with variant languages
                        tm_id, count = self.tm_database.load_tmx_file(
                            file_path, compat['tmx_source'], compat['tmx_target'],
                            tm_name=None, read_only=False, progress_callback=update_progress
                        )
                        progress.close()
                        
                        if not cancelled:
                            self.log(f"Created new TM with variants: {compat['tmx_source']}, {compat['tmx_target']}")
                            QMessageBox.information(
                                self, "Import Complete", 
                                f"New TM created!\n\nTM ID: {tm_id}\nEntries: {count:,}\n"
                                f"Languages: {compat['tmx_source']}, {compat['tmx_target']}"
                            )
                        else:
                            self.log("TMX import cancelled by user")
                            QMessageBox.information(self, "Import Cancelled", f"Import stopped.\n\nPartial entries may have been imported: {count:,}")
                else:
                    # Exact match - proceed normally with real-time progress
                    from PyQt6.QtWidgets import QProgressDialog
                    from PyQt6.QtCore import Qt
                    import time
                    
                    progress = QProgressDialog("Counting translation units...", "Cancel", 0, 100, self)
                    progress.setWindowTitle("TMX Import")
                    progress.setWindowModality(Qt.WindowModality.WindowModal)
                    progress.setMinimumDuration(0)
                    progress.setAutoClose(False)
                    progress.setAutoReset(False)
                    progress.setValue(0)
                    progress.show()
                    QApplication.processEvents()
                    
                    cancelled = False
                    start_time = time.time()
                    
                    def update_progress(current, total, message):
                        nonlocal cancelled
                        if progress.wasCanceled():
                            cancelled = True
                            return
                        
                        if total > 0:
                            percentage = int((current / total) * 100)
                            progress.setValue(percentage)
                            
                            # Calculate time stats
                            elapsed = time.time() - start_time
                            if current > 0:
                                rate = current / elapsed
                                remaining = (total - current) / rate if rate > 0 else 0
                                
                                # Format message with stats
                                time_info = f" (~{int(remaining/60)}m {int(remaining%60)}s remaining)" if remaining > 10 else ""
                                progress.setLabelText(f"{message}\nRate: {int(rate):,} entries/sec{time_info}")
                            else:
                                progress.setLabelText(message)
                        else:
                            progress.setLabelText(message)
                        
                        QApplication.processEvents()
                    
                    tm_id, count = self.tm_database.load_tmx_file(file_path, source_lang, target_lang, progress_callback=update_progress)
                    progress.close()
                    
                    if not cancelled:
                        self.log(f"Successfully imported {count} entries from TMX file")
                        QMessageBox.information(self, "Import Complete", f"TMX imported!\n\nEntries: {count:,}\nTM ID: {tm_id}")
                    else:
                        self.log("TMX import cancelled by user")
                        QMessageBox.information(self, "Import Cancelled", f"Import stopped.\n\nPartial entries may have been imported: {count:,}")
            
        except Exception as e:
            self.log(f"Error importing TMX file: {e}")
            QMessageBox.critical(self, "Import Error", f"Failed to import TMX:\n\n{e}")
    
    def _show_language_variant_dialog(self, compat_info: dict) -> str:
        """Show dialog for handling language variant mismatch. Returns 'import_strip', 'create_new', or 'cancel'"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QRadioButton, QButtonGroup
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Language Variant Detected")
        dialog.setMinimumWidth(500)
        
        layout = QVBoxLayout(dialog)
        
        # Explanation
        info_text = (
            f"<h3>‚ö†Ô∏è Language Variant Mismatch</h3>"
            f"<p>The TMX file uses language variants that don't exactly match your TM:</p>"
            f"<table style='margin: 10px 0;'>"
            f"<tr><td><b>TMX languages:</b></td><td>{compat_info['tmx_source']} ‚Üí {compat_info['tmx_target']}</td></tr>"
            f"<tr><td><b>Your TM languages:</b></td><td>{compat_info['target_source']} ‚Üí {compat_info['target_target']}</td></tr>"
            f"</table>"
            f"<p>How would you like to proceed?</p>"
        )
        
        info_label = QLabel(info_text)
        info_label.setWordWrap(True)
        info_label.setTextFormat(Qt.TextFormat.RichText)
        layout.addWidget(info_label)
        
        # Radio button group
        button_group = QButtonGroup(dialog)
        
        option1 = CheckmarkRadioButton(f"Import into existing TM (strip variants: {compat_info['tmx_source']},{compat_info['tmx_target']} ‚Üí {compat_info['target_source']},{compat_info['target_target']})")
        option1.setChecked(True)
        option1.setToolTip("Import translations by matching base languages, ignoring regional variants")
        button_group.addButton(option1, 1)
        layout.addWidget(option1)
        
        option2 = CheckmarkRadioButton(f"Create new TM with variant languages ({compat_info['tmx_source']}, {compat_info['tmx_target']})")
        option2.setToolTip("Create a separate TM preserving the exact language variants from the TMX")
        button_group.addButton(option2, 2)
        layout.addWidget(option2)
        
        layout.addSpacing(20)
        
        # Buttons
        from PyQt6.QtWidgets import QHBoxLayout
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        btn_layout.addWidget(cancel_btn)
        
        ok_btn = QPushButton("Continue")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(dialog.accept)
        btn_layout.addWidget(ok_btn)
        
        layout.addLayout(btn_layout)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            if option1.isChecked():
                return 'import_strip'
            elif option2.isChecked():
                return 'create_new'
        
        return 'cancel'
    
    def export_target_only_docx(self):
        """Export target text only as a monolingual DOCX document, preserving original formatting"""
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project with segments first")
                return
            
            # Check if there are any translations
            segments = list(self.current_project.segments)
            translated_count = sum(1 for seg in segments if seg.target and seg.target.strip())
            
            if translated_count == 0:
                QMessageBox.warning(
                    self, "No Translations", 
                    "No translated segments found.\n\nPlease translate some segments before exporting."
                )
                return
            
            # Warn if not all segments are translated
            total_count = len(segments)
            if translated_count < total_count:
                reply = QMessageBox.question(
                    self, "Incomplete Translation",
                    f"Only {translated_count} of {total_count} segments are translated.\n\n"
                    f"Untranslated segments will use source text.\n\n"
                    f"Continue with export?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply != QMessageBox.StandardButton.Yes:
                    return
            
            # Get save path
            default_name = ""
            if self.current_project.name:
                default_name = self.current_project.name.replace(" ", "_") + "_translated.docx"
            
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export Target Only DOCX",
                default_name,
                "Word Documents (*.docx);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            # Ensure .docx extension
            if not file_path.lower().endswith('.docx'):
                file_path += '.docx'
            
            from docx import Document
            import shutil
            
            # Check if we have the original document to use as template
            original_path = getattr(self, 'original_docx', None) or getattr(self, 'current_document_path', None)
            
            if original_path and os.path.exists(original_path):
                # Copy original document and replace text - preserves all formatting
                self.log(f"Using original document as template: {os.path.basename(original_path)}")
                shutil.copy2(original_path, file_path)
                
                doc = Document(file_path)
                
                # Helper function to strip all formatting tags (for matching only)
                import re
                def strip_all_tags(text):
                    """Remove all formatting and list tags from text"""
                    text = re.sub(r'</?li-[bo]>', '', text)  # <li-b>, </li-b>, <li-o>, </li-o>
                    text = re.sub(r'</?li>', '', text)       # <li>, </li>
                    text = re.sub(r'</?[biu]>', '', text)    # <b>, </b>, <i>, </i>, <u>, </u>
                    text = re.sub(r'</?bi>', '', text)       # <bi>, </bi>
                    return text.strip()
                
                def clean_special_chars(text):
                    """Remove problematic Unicode characters like object replacement char"""
                    # Remove Unicode Object Replacement Character (U+FFFC) and similar
                    text = text.replace('\ufffc', '')  # Object Replacement Character
                    text = text.replace('\ufffe', '')  # Noncharacter
                    text = text.replace('\uffff', '')  # Noncharacter
                    text = text.replace('\u0000', '')  # Null character
                    return text
                
                def apply_formatted_text_to_paragraph(para, tagged_text):
                    """
                    Replace paragraph text with tagged text, applying bold/italic/underline formatting.
                    Parses tags like <b>, <i>, <u>, <bi> and creates appropriate runs.
                    """
                    # Clean special characters first
                    text = clean_special_chars(tagged_text)
                    
                    # Strip list tags - they don't affect formatting
                    text = re.sub(r'</?li-[bo]>', '', text)
                    text = re.sub(r'</?li>', '', text)
                    
                    # Clear existing runs
                    for run in para.runs:
                        run.clear()
                    # Remove the cleared runs
                    for run in list(para.runs):
                        run._element.getparent().remove(run._element)
                    
                    # Parse tags and create runs with formatting
                    # Pattern matches tags or text between tags
                    tag_pattern = re.compile(r'(</?(?:b|i|u|bi)>)')
                    parts = tag_pattern.split(text)
                    
                    is_bold = False
                    is_italic = False
                    is_underline = False
                    
                    for part in parts:
                        if not part:
                            continue
                        
                        # Check if this is a tag
                        if part == '<b>':
                            is_bold = True
                        elif part == '</b>':
                            is_bold = False
                        elif part == '<i>':
                            is_italic = True
                        elif part == '</i>':
                            is_italic = False
                        elif part == '<u>':
                            is_underline = True
                        elif part == '</u>':
                            is_underline = False
                        elif part == '<bi>':
                            is_bold = True
                            is_italic = True
                        elif part == '</bi>':
                            is_bold = False
                            is_italic = False
                        else:
                            # This is text content - create a run with current formatting
                            if part.strip() or part:  # Include whitespace
                                run = para.add_run(part)
                                run.bold = is_bold
                                run.italic = is_italic
                                run.underline = is_underline
                
                # Build a mapping of source text (without tags) to raw target text (with tags)
                text_map = {}
                for seg in segments:
                    # Strip tags from source for matching against original DOCX
                    source_clean = strip_all_tags(seg.source) if seg.source else ""
                    source_clean = clean_special_chars(source_clean)
                    # Keep raw target text WITH tags for formatting
                    target_raw = seg.target.strip() if seg.target and seg.target.strip() else seg.source
                    if source_clean and target_raw:
                        text_map[source_clean] = target_raw
                
                def replace_segments_in_text(original_text, text_map):
                    """Replace all matching segments in text, handling partial matches."""
                    result = original_text
                    # Sort by length (longest first) to avoid partial replacement issues
                    for source_clean, target_raw in sorted(text_map.items(), key=lambda x: len(x[0]), reverse=True):
                        if source_clean in result:
                            # Get clean target (no tags) for text replacement
                            target_clean = strip_all_tags(target_raw)
                            target_clean = clean_special_chars(target_clean)
                            result = result.replace(source_clean, target_clean)
                    return result
                
                replaced_count = 0
                
                # Replace text in paragraphs (outside tables)
                for para in doc.paragraphs:
                    para_text = para.text.strip()
                    
                    # First try exact match (single segment = whole paragraph)
                    if para_text in text_map:
                        target_text = text_map[para_text]
                        apply_formatted_text_to_paragraph(para, target_text)
                        replaced_count += 1
                    else:
                        # Try partial replacement (paragraph contains multiple segments)
                        new_text = replace_segments_in_text(para_text, text_map)
                        if new_text != para_text:
                            # Text was changed - update paragraph
                            # For partial replacements, we lose formatting tags but at least translate
                            for run in para.runs:
                                run.clear()
                            for run in list(para.runs):
                                run._element.getparent().remove(run._element)
                            para.add_run(new_text)
                            replaced_count += 1
                
                # Replace text in tables
                for table in doc.tables:
                    for row in table.rows:
                        for cell in row.cells:
                            for para in cell.paragraphs:
                                para_text = para.text.strip()
                                
                                # First try exact match
                                if para_text in text_map:
                                    target_text = text_map[para_text]
                                    apply_formatted_text_to_paragraph(para, target_text)
                                    replaced_count += 1
                                else:
                                    # Try partial replacement
                                    new_text = replace_segments_in_text(para_text, text_map)
                                    if new_text != para_text:
                                        for run in para.runs:
                                            run.clear()
                                        for run in list(para.runs):
                                            run._element.getparent().remove(run._element)
                                        para.add_run(new_text)
                                        replaced_count += 1
                
                doc.save(file_path)
                self.log(f"‚úì Replaced {replaced_count} text segments in original document structure")
                
            else:
                # No original document - create simple paragraph-based export
                self.log("No original document found - creating new document (formatting may differ)")
                
                # Helper function to strip all formatting tags (if not already defined)
                import re
                def strip_all_tags(text):
                    """Remove all formatting and list tags from text"""
                    text = re.sub(r'</?li-[bo]>', '', text)  # <li-b>, </li-b>, <li-o>, </li-o>
                    text = re.sub(r'</?li>', '', text)       # <li>, </li>
                    text = re.sub(r'</?[biu]>', '', text)    # <b>, </b>, <i>, </i>, <u>, </u>
                    text = re.sub(r'</?bi>', '', text)       # <bi>, </bi>
                    return text.strip()
                
                def clean_special_chars(text):
                    """Remove problematic Unicode characters"""
                    text = text.replace('\ufffc', '')  # Object Replacement Character
                    text = text.replace('\ufffe', '')  # Noncharacter
                    text = text.replace('\uffff', '')  # Noncharacter
                    text = text.replace('\u0000', '')  # Null character
                    return text
                
                def add_formatted_text_to_paragraph(para, tagged_text):
                    """Add text with formatting tags to a paragraph."""
                    # Clean special characters first
                    text = clean_special_chars(tagged_text)
                    
                    # Strip list tags
                    text = re.sub(r'</?li-[bo]>', '', text)
                    text = re.sub(r'</?li>', '', text)
                    
                    # Parse and apply formatting
                    tag_pattern = re.compile(r'(</?(?:b|i|u|bi)>)')
                    parts = tag_pattern.split(text)
                    
                    is_bold = False
                    is_italic = False
                    is_underline = False
                    
                    for part in parts:
                        if not part:
                            continue
                        if part == '<b>':
                            is_bold = True
                        elif part == '</b>':
                            is_bold = False
                        elif part == '<i>':
                            is_italic = True
                        elif part == '</i>':
                            is_italic = False
                        elif part == '<u>':
                            is_underline = True
                        elif part == '</u>':
                            is_underline = False
                        elif part == '<bi>':
                            is_bold = True
                            is_italic = True
                        elif part == '</bi>':
                            is_bold = False
                            is_italic = False
                        else:
                            if part:
                                run = para.add_run(part)
                                run.bold = is_bold
                                run.italic = is_italic
                                run.underline = is_underline
                
                doc = Document()
                
                for seg in segments:
                    raw_text = seg.target.strip() if seg.target and seg.target.strip() else seg.source
                    para = doc.add_paragraph()
                    
                    # Try to apply heading style if segment has heading style
                    if hasattr(seg, 'style') and seg.style:
                        style_lower = seg.style.lower()
                        if 'heading 1' in style_lower:
                            para.style = 'Heading 1'
                        elif 'heading 2' in style_lower:
                            para.style = 'Heading 2'
                        elif 'heading 3' in style_lower:
                            para.style = 'Heading 3'
                        elif 'title' in style_lower:
                            para.style = 'Title'
                    
                    # Add text with formatting
                    if raw_text:
                        add_formatted_text_to_paragraph(para, raw_text)
                
                doc.save(file_path)
            
            self.log(f"‚úì Exported {len(segments)} segments to: {os.path.basename(file_path)}")
            
            QMessageBox.information(
                self, "Export Complete",
                f"Successfully exported {translated_count} translated segments to:\n\n{os.path.basename(file_path)}"
            )
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for DOCX export.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            self.log(f"‚úó Export failed: {str(e)}")
            QMessageBox.critical(self, "Export Error", f"Failed to export DOCX:\n\n{str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_review_table_with_tags(self):
        """Export Supervertaler Bilingual Table with formatting tags visible.
        
        This format is intended for proofreaders who will edit and return the file
        for re-import into Supervertaler.
        """
        self._export_review_table(apply_formatting=False)
    
    def export_review_table_formatted(self):
        """Export Supervertaler Bilingual Table with formatting applied (bold, italic, underline).
        
        This format is intended for end clients who want to see the actual formatting
        rather than the tags.
        """
        # Warn user that this format cannot be re-imported with tags
        reply = QMessageBox.warning(
            self, "Formatted Export - Tags Will Be Applied",
            "This export applies formatting (bold, italic, underline) to the text.\n\n"
            "‚ö†Ô∏è Formatting tags will be converted to actual Word formatting.\n"
            "This version CANNOT be re-imported to restore tagged formatting.\n\n"
            "Use 'Bilingual Table - With Tags' if you need to re-import after review.\n\n"
            "Continue with formatted export?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        self._export_review_table(apply_formatting=True)
    
    def _add_hyperlink_to_paragraph(self, paragraph, url, text):
        """Add a hyperlink to a paragraph in a Word document.
        
        Args:
            paragraph: The paragraph to add the hyperlink to
            url: The URL for the hyperlink
            text: The display text for the hyperlink
            
        Returns:
            The run containing the hyperlink text (for further formatting)
        """
        from docx.oxml.ns import qn
        from docx.oxml import OxmlElement
        
        # Get the document part
        part = paragraph.part
        
        # Create the relationship
        r_id = part.relate_to(url, 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink', is_external=True)
        
        # Create the hyperlink element
        hyperlink = OxmlElement('w:hyperlink')
        hyperlink.set(qn('r:id'), r_id)
        
        # Create a new run for the hyperlink text
        new_run = OxmlElement('w:r')
        rPr = OxmlElement('w:rPr')
        
        # Add the text
        text_elem = OxmlElement('w:t')
        text_elem.text = text
        new_run.append(rPr)
        new_run.append(text_elem)
        hyperlink.append(new_run)
        
        # Add hyperlink to paragraph
        paragraph._p.append(hyperlink)
        
        # Return a reference to the run for further formatting
        # We need to return a proper Run object
        from docx.text.run import Run
        return Run(new_run, paragraph)
    
    def _export_review_table(self, apply_formatting=False):
        """Internal method to export Supervertaler Bilingual Table.
        
        Args:
            apply_formatting: If True, apply bold/italic/underline formatting.
                            If False, show raw Supervertaler tags.
        """
        import re
        
        # Check if we have segments
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Data", "No segments to export")
            return
        
        segments = list(self.current_project.segments)
        
        if not segments:
            QMessageBox.warning(self, "No Data", "No segments to export")
            return
        
        # Determine default filename
        project_name = getattr(self.current_project, 'name', 'project')
        if hasattr(self, 'current_project_path') and self.current_project_path:
            project_name = Path(self.current_project_path).stem
        
        format_suffix = "_bilingual_formatted" if apply_formatting else "_bilingual"
        default_name = f"{project_name}{format_suffix}.docx"
        
        # Get save path
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Bilingual Table" if not apply_formatting else "Export Bilingual Table (Formatted)",
            default_name,
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            from docx import Document
            from docx.shared import Inches, Pt, RGBColor
            from docx.enum.table import WD_TABLE_ALIGNMENT
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            from docx.oxml.ns import qn
            from docx.oxml import OxmlElement
            
            doc = Document()

            # Set up document margins and landscape orientation
            from docx.enum.section import WD_ORIENT
            sections = doc.sections
            for section in sections:
                # Set landscape orientation for better visualization of long segments
                section.orientation = WD_ORIENT.LANDSCAPE
                # Swap page dimensions for landscape
                section.page_width, section.page_height = section.page_height, section.page_width
                # Set margins
                section.left_margin = Inches(0.5)
                section.right_margin = Inches(0.5)
                section.top_margin = Inches(0.5)
                section.bottom_margin = Inches(0.5)
            
            # Language code to display name mapping
            LANG_DISPLAY_NAMES = {
                'en': 'English', 'en-US': 'English (US)', 'en-GB': 'English (UK)', 'en-AU': 'English (AU)',
                'nl': 'Dutch', 'nl-NL': 'Dutch (NL)', 'nl-BE': 'Dutch (Belgium)',
                'de': 'German', 'de-DE': 'German (DE)', 'de-AT': 'German (AT)', 'de-CH': 'German (CH)',
                'fr': 'French', 'fr-FR': 'French (FR)', 'fr-CA': 'French (CA)', 'fr-BE': 'French (BE)',
                'es': 'Spanish', 'es-ES': 'Spanish (ES)', 'es-MX': 'Spanish (MX)', 'es-AR': 'Spanish (AR)',
                'it': 'Italian', 'it-IT': 'Italian (IT)',
                'pt': 'Portuguese', 'pt-PT': 'Portuguese (PT)', 'pt-BR': 'Portuguese (BR)',
                'ru': 'Russian', 'zh': 'Chinese', 'zh-CN': 'Chinese (Simplified)', 'zh-TW': 'Chinese (Traditional)',
                'ja': 'Japanese', 'ko': 'Korean', 'ar': 'Arabic', 'pl': 'Polish', 'sv': 'Swedish',
                'da': 'Danish', 'no': 'Norwegian', 'fi': 'Finnish', 'cs': 'Czech', 'hu': 'Hungarian',
                'tr': 'Turkish', 'el': 'Greek', 'he': 'Hebrew', 'th': 'Thai', 'vi': 'Vietnamese',
            }
            
            def get_language_display_name(lang_value):
                """Convert language code or name to display name."""
                if not lang_value:
                    return "Unknown"
                # If it's already a nice display name (contains space or parentheses), use it
                if ' ' in lang_value or '(' in lang_value:
                    return lang_value
                # Look up in our mapping
                if lang_value in LANG_DISPLAY_NAMES:
                    return LANG_DISPLAY_NAMES[lang_value]
                # Try lowercase
                if lang_value.lower() in LANG_DISPLAY_NAMES:
                    return LANG_DISPLAY_NAMES[lang_value.lower()]
                # Capitalize first letter as fallback
                return lang_value.capitalize() if lang_value else "Unknown"
            
            # Get language names for column headers
            source_lang = "Source"
            target_lang = "Target"
            if self.current_project:
                source_lang = get_language_display_name(self.current_project.source_lang) or "Source"
                target_lang = get_language_display_name(self.current_project.target_lang) or "Target"
            
            # === HEADER SECTION ===
            # Add decorative line above title
            header_line = doc.add_paragraph()
            header_line.alignment = WD_ALIGN_PARAGRAPH.CENTER
            line_run = header_line.add_run("‚îÅ" * 50)
            line_run.font.color.rgb = RGBColor(0, 102, 204)
            line_run.font.size = Pt(10)
            header_line.paragraph_format.space_after = Pt(6)
            
            # Add title with link to Supervertaler website
            title = doc.add_paragraph()
            title.alignment = WD_ALIGN_PARAGRAPH.CENTER
            title.paragraph_format.space_before = Pt(0)
            title.paragraph_format.space_after = Pt(6)
            
            # Add globe emoji and "Supervertaler Bilingual Table" in blue (no link on title)
            globe_run = title.add_run("üåê ")
            globe_run.font.size = Pt(18)
            
            title_run = title.add_run("Supervertaler Bilingual Table")
            title_run.font.size = Pt(18)
            title_run.font.bold = True
            title_run.font.color.rgb = RGBColor(0, 102, 204)
            
            # Add subtitle with clickable website URL
            subtitle = doc.add_paragraph()
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
            subtitle.paragraph_format.space_before = Pt(0)
            subtitle.paragraph_format.space_after = Pt(6)
            
            # Make Supervertaler.com a clickable link
            url_link = self._add_hyperlink_to_paragraph(subtitle, "https://supervertaler.com/", "Supervertaler.com")
            url_link.font.size = Pt(10)
            url_link.font.color.rgb = RGBColor(0, 102, 204)
            url_link.font.underline = True
            
            # Add decorative line below title
            footer_line = doc.add_paragraph()
            footer_line.alignment = WD_ALIGN_PARAGRAPH.CENTER
            line_run2 = footer_line.add_run("‚îÅ" * 50)
            line_run2.font.color.rgb = RGBColor(0, 102, 204)
            line_run2.font.size = Pt(10)
            footer_line.paragraph_format.space_after = Pt(12)
            
            # Add project info in a nice format
            info = doc.add_paragraph()
            info.add_run(f"Project: ").bold = True
            info.add_run(f"{project_name}\n")
            info.add_run(f"Languages: ").bold = True
            info.add_run(f"{source_lang} ‚Üí {target_lang}\n")
            info.add_run(f"Segments: ").bold = True
            info.add_run(f"{len(segments)}\n")
            info.add_run(f"Exported: ").bold = True
            info.add_run(f"{datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
            
            # Add important notice
            notice = doc.add_paragraph()
            notice.paragraph_format.space_before = Pt(6)
            if not apply_formatting:
                warning_run = notice.add_run("‚ö†Ô∏è Important: ")
                warning_run.bold = True
                warning_run.font.color.rgb = RGBColor(180, 100, 0)
                notice.add_run("Do not change segment numbers (#) or source text. ").italic = True
                notice.add_run("This file can be re-imported into Supervertaler after proofreading.").italic = True
            else:
                notice.add_run("Note: This version shows applied formatting and is for client delivery or archiving. It cannot be re-imported.").italic = True
            
            # Create table with 5 columns: #, Source Language, Target Language, Status, Notes
            table = doc.add_table(rows=1, cols=5)
            table.style = 'Table Grid'
            table.alignment = WD_TABLE_ALIGNMENT.CENTER
            
            # Set column widths
            widths = [Inches(0.5), Inches(3.0), Inches(3.0), Inches(0.8), Inches(1.2)]
            for i, width in enumerate(widths):
                for cell in table.columns[i].cells:
                    cell.width = width
            
            # Add header row with actual language names
            header_cells = table.rows[0].cells
            headers = ['#', source_lang, target_lang, 'Status', 'Notes']
            for i, header in enumerate(headers):
                header_cells[i].text = header
                # Make header bold and shaded
                for para in header_cells[i].paragraphs:
                    for run in para.runs:
                        run.bold = True
                        run.font.size = Pt(10)
                # Add shading to header
                shading = OxmlElement('w:shd')
                shading.set(qn('w:fill'), 'DDDDDD')
                header_cells[i]._tc.get_or_add_tcPr().append(shading)
            
            # Helper function to add formatted text to a cell
            def add_formatted_text_to_cell(cell, text, apply_fmt=False):
                """Add text to cell, optionally applying formatting."""
                from docx.shared import RGBColor
                
                # Clear existing content
                for para in cell.paragraphs:
                    para.clear()
                
                if not text:
                    return
                
                para = cell.paragraphs[0]
                para.paragraph_format.space_before = Pt(2)
                para.paragraph_format.space_after = Pt(2)
                
                if not apply_fmt:
                    # Show raw text with tags in pink text (like in Supervertaler)
                    # Parse to find tags and color them - includes Supervertaler tags AND CAT tool tags
                    # Supervertaler tags: <b>, <i>, <u>, <bi>, <li>, <li-o>, <li-b>
                    # memoQ tags: {1}, [2}, {3], [uicontrol id="..."], {tagname}
                    # Trados tags: <1>, </1>
                    tag_pattern = re.compile(
                        r'('
                        r'</?(?:b|i|u|bi|li|li-[bo])>'  # Supervertaler tags
                        r'|</?[0-9]+>'  # Trados numeric tags: <1>, </1>
                        r'|\[[^}\]]+\}'  # memoQ mixed: [anything}
                        r'|\{[^\[\]]+\]'  # memoQ mixed: {anything]
                        r'|\[[a-zA-Z][^}\]]*\s[^}\]]*\]'  # memoQ content: [tag attr...]
                        r'|\{[a-zA-Z][a-zA-Z0-9_-]*\}'  # memoQ closing: {tagname}
                        r'|\[[0-9]+\]'  # memoQ numeric: [1]
                        r'|\{[0-9]+\}'  # memoQ/Phrase numeric: {1}
                        r')'
                    )
                    parts = tag_pattern.split(text)
                    
                    for part in parts:
                        if not part:
                            continue
                        run = para.add_run(part)
                        run.font.size = Pt(9)
                        
                        # Check if this is a tag - make text memoQ dark red
                        if tag_pattern.match(part):
                            run.font.color.rgb = RGBColor(127, 0, 1)  # memoQ dark red (#7f0001)
                else:
                    # Parse tags and apply formatting
                    # First handle list tags - convert to visible markers
                    text = re.sub(r'<li-b>\s*', '‚Ä¢ ', text)
                    text = re.sub(r'<li-o>\s*', '‚ó¶ ', text)  # Open circle for nested
                    text = re.sub(r'<li>\s*', '‚Äì ', text)
                    text = re.sub(r'</li-[bo]>', '', text)
                    text = re.sub(r'</li>', '', text)
                    
                    # Parse formatting tags
                    tag_pattern = re.compile(r'(</?(?:b|i|u|bi)>)')
                    parts = tag_pattern.split(text)
                    
                    is_bold = False
                    is_italic = False
                    is_underline = False
                    
                    for part in parts:
                        if not part:
                            continue
                        if part == '<b>':
                            is_bold = True
                        elif part == '</b>':
                            is_bold = False
                        elif part == '<i>':
                            is_italic = True
                        elif part == '</i>':
                            is_italic = False
                        elif part == '<u>':
                            is_underline = True
                        elif part == '</u>':
                            is_underline = False
                        elif part == '<bi>':
                            is_bold = True
                            is_italic = True
                        elif part == '</bi>':
                            is_bold = False
                            is_italic = False
                        else:
                            # Regular text
                            run = para.add_run(part)
                            run.font.size = Pt(9)
                            run.bold = is_bold
                            run.italic = is_italic
                            run.underline = is_underline
            
            # Helper to get status display text
            def get_status_display(status):
                """Convert status to user-friendly display text."""
                status_map = {
                    'translated': 'Translated',
                    'tr_confirmed': 'Confirmed',
                    'confirmed': 'Confirmed',
                    'draft': 'Draft',
                    'not_translated': 'Not Translated',
                    'proofread': 'Proofread',
                    'approved': 'Approved',
                    'rejected': 'Rejected',
                    'needs_review': 'Needs Review',
                    'edited': 'Edited',
                    'mt': 'MT',
                    'tm_match': 'TM Match',
                    'fuzzy_match': 'Fuzzy'
                }
                return status_map.get(status, status.replace('_', ' ').title() if status else '')
            
            # Add segment rows
            for i, seg in enumerate(segments):
                row = table.add_row()
                cells = row.cells
                
                # Segment number
                cells[0].text = str(i + 1)
                for para in cells[0].paragraphs:
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    for run in para.runs:
                        run.font.size = Pt(9)
                
                # Source text
                source_text = seg.source if hasattr(seg, 'source') else ''
                add_formatted_text_to_cell(cells[1], source_text, apply_formatting)
                
                # Target text
                target_text = seg.target if hasattr(seg, 'target') else ''
                add_formatted_text_to_cell(cells[2], target_text, apply_formatting)
                
                # Status
                status = seg.status if hasattr(seg, 'status') else ''
                cells[3].text = get_status_display(status)
                for para in cells[3].paragraphs:
                    para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                    for run in para.runs:
                        run.font.size = Pt(8)
                        # Color-code status
                        if status in ('confirmed', 'tr_confirmed', 'proofread', 'approved'):
                            run.font.color.rgb = RGBColor(0, 128, 0)  # Green
                        elif status in ('not_translated', 'rejected'):
                            run.font.color.rgb = RGBColor(200, 0, 0)  # Red
                        elif status in ('draft', 'needs_review'):
                            run.font.color.rgb = RGBColor(200, 100, 0)  # Orange
                
                # Notes column - populate with segment notes if available
                notes_text = seg.notes if hasattr(seg, 'notes') else ''
                cells[4].text = notes_text
                for para in cells[4].paragraphs:
                    for run in para.runs:
                        run.font.size = Pt(8)
            
            # Add footer with branding
            footer_para = doc.add_paragraph()
            footer_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
            footer_para.paragraph_format.space_before = Pt(12)
            
            # Add decorative line
            footer_line_run = footer_para.add_run("\n" + "‚îÅ" * 50 + "\n")
            footer_line_run.font.size = Pt(10)
            footer_line_run.font.color.rgb = RGBColor(0, 102, 204)
            
            # Add footer text: "Supervertaler Bilingual Table | Supervertaler.com"
            footer_text = doc.add_paragraph()
            footer_text.alignment = WD_ALIGN_PARAGRAPH.CENTER
            
            brand_run = footer_text.add_run("Supervertaler Bilingual Table")
            brand_run.font.size = Pt(9)
            brand_run.font.color.rgb = RGBColor(100, 100, 100)
            
            separator_run = footer_text.add_run(" | ")
            separator_run.font.size = Pt(9)
            separator_run.font.color.rgb = RGBColor(150, 150, 150)
            
            # Add clickable website link in footer
            footer_link = self._add_hyperlink_to_paragraph(footer_text, "https://supervertaler.com/", "Supervertaler.com")
            footer_link.font.size = Pt(9)
            footer_link.font.color.rgb = RGBColor(0, 102, 204)
            footer_link.font.underline = True
            
            # Save the document
            doc.save(file_path)
            
            format_type = "formatted" if apply_formatting else "with tags"
            self.log(f"‚úì Exported bilingual table ({format_type}) with {len(segments)} segments to: {Path(file_path).name}")
            
            QMessageBox.information(
                self, "Export Complete",
                f"Successfully exported {len(segments)} segments to bilingual table:\n\n{os.path.basename(file_path)}\n\n"
                + ("This formatted version is suitable for client review." if apply_formatting 
                   else "This version with tags can be re-imported after proofreading.")
            )
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for DOCX export.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            self.log(f"‚úó Export failed: {str(e)}")
            QMessageBox.critical(self, "Export Error", f"Failed to export bilingual table:\n\n{str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_tmx_from_grid(self):
        """Export all segments from current project grid as TMX file"""
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project first")
                return
            
            file_path, _ = fdh.get_save_file_name(
                self, 
                "Export Grid as TMX", 
                "TMX Files (*.tmx);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            source_segments = []
            target_segments = []
            entry_count = 0
            
            # Export all segments from grid (including empty translations)
            self.log("Exporting all segments from grid...")
            for segment in self.current_project.segments:
                source_text = segment.source
                target_text = segment.target if segment.target else ""
                
                if source_text:
                    source_segments.append(source_text)
                    target_segments.append(target_text)
                    entry_count += 1
            
            self.log(f"Found {entry_count} segments in grid")
            
            if entry_count == 0:
                QMessageBox.warning(self, "No Data", "No segments found in grid")
                return
            
            # Generate and save TMX
            from modules.tmx_generator import TMXGenerator
            tmx_generator = TMXGenerator(log_callback=self.log)
            
            source_lang = self.current_project.source_lang or "en"
            target_lang = self.current_project.target_lang or "nl"
            
            tmx_tree = tmx_generator.generate_tmx(
                source_segments=source_segments,
                target_segments=target_segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            if tmx_generator.save_tmx(tmx_tree, file_path):
                self.log(f"‚úì Exported TMX from grid: {file_path} ({entry_count} segments)")
                QMessageBox.information(
                    self, 
                    "Export Complete", 
                    f"Grid exported to TMX successfully!\n\n"
                    f"File: {file_path}\n"
                    f"Segments: {entry_count}\n"
                    f"Language pair: {source_lang} ‚Üí {target_lang}"
                )
            else:
                QMessageBox.warning(self, "Export Error", "Failed to save TMX file")
            
        except Exception as e:
            self.log(f"‚úó Error exporting grid as TMX: {e}")
            import traceback
            self.log(traceback.format_exc())
            QMessageBox.critical(self, "Export Error", f"Failed to export:\n\n{str(e)}")
    
    def export_tmx_from_selected(self):
        """Export only selected segments from grid as TMX file"""
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project first")
                return
            
            # Get selected rows from table
            selected_rows = set()
            for index in self.table.selectedIndexes():
                selected_rows.add(index.row())
            
            if not selected_rows:
                QMessageBox.warning(
                    self, 
                    "No Selection", 
                    "Please select one or more rows in the grid first.\n\n"
                    "Click on row numbers or use Ctrl+Click to select multiple rows."
                )
                return
            
            file_path, _ = QFileDialog.getSaveFileName(
                self, 
                "Export Selected Segments as TMX", 
                "supervertaler_selected.tmx", 
                "TMX Files (*.tmx);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            source_segments = []
            target_segments = []
            entry_count = 0
            
            # Export only selected segments
            self.log(f"Exporting {len(selected_rows)} selected segments...")
            for row in sorted(selected_rows):
                if row < len(self.current_project.segments):
                    segment = self.current_project.segments[row]
                    source_text = segment.source
                    target_text = segment.target if segment.target else ""
                    
                    if source_text:
                        source_segments.append(source_text)
                        target_segments.append(target_text)
                        entry_count += 1
            
            self.log(f"Selected {entry_count} segments to export")
            
            if entry_count == 0:
                QMessageBox.warning(self, "No Data", "No valid segments selected")
                return
            
            # Generate and save TMX
            from modules.tmx_generator import TMXGenerator
            tmx_generator = TMXGenerator(log_callback=self.log)
            
            source_lang = self.current_project.source_lang or "en"
            target_lang = self.current_project.target_lang or "nl"
            
            tmx_tree = tmx_generator.generate_tmx(
                source_segments=source_segments,
                target_segments=target_segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            if tmx_generator.save_tmx(tmx_tree, file_path):
                self.log(f"‚úì Exported TMX from selected: {file_path} ({entry_count} segments)")
                QMessageBox.information(
                    self, 
                    "Export Complete", 
                    f"Selected segments exported to TMX successfully!\n\n"
                    f"File: {file_path}\n"
                    f"Segments: {entry_count}\n"
                    f"Language pair: {source_lang} ‚Üí {target_lang}"
                )
            else:
                QMessageBox.warning(self, "Export Error", "Failed to save TMX file")
            
        except Exception as e:
            self.log(f"‚úó Error exporting selected segments as TMX: {e}")
            import traceback
            self.log(traceback.format_exc())
            QMessageBox.critical(self, "Export Error", f"Failed to export:\n\n{str(e)}")
    
    def export_tmx_from_tm_database(self):
        """Export translation memory entries as TMX file"""
        try:
            if not self.tm_database:
                QMessageBox.warning(self, "Error", "Translation memory database not available")
                return
            
            # Get TM entries from database
            tm_entries = self.tm_database.get_tm_entries(tm_id=None, limit=None)
            if not tm_entries:
                QMessageBox.warning(
                    self, 
                    "No Data", 
                    "No translation units in Translation Memory database.\n\n"
                    "Please import a TM or save translations to the TM first."
                )
                return
            
            file_path, _ = QFileDialog.getSaveFileName(
                self, 
                "Export TM Database as TMX", 
                "supervertaler_tm_database.tmx", 
                "TMX Files (*.tmx);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            source_segments = []
            target_segments = []
            
            # Extract segments from TM entries
            self.log(f"Exporting {len(tm_entries)} entries from TM database...")
            for entry in tm_entries:
                source_segments.append(entry.get('source_text', entry.get('source', '')))
                target_segments.append(entry.get('target_text', entry.get('target', '')))
            
            # Generate and save TMX
            from modules.tmx_generator import TMXGenerator
            tmx_generator = TMXGenerator(log_callback=self.log)
            
            # Use project languages or defaults
            source_lang = "en"
            target_lang = "nl"
            if self.current_project:
                source_lang = self.current_project.source_lang or "en"
                target_lang = self.current_project.target_lang or "nl"
            
            tmx_tree = tmx_generator.generate_tmx(
                source_segments=source_segments,
                target_segments=target_segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            if tmx_generator.save_tmx(tmx_tree, file_path):
                self.log(f"‚úì Exported TMX from TM database: {file_path} ({len(tm_entries)} entries)")
                QMessageBox.information(
                    self, 
                    "Export Complete", 
                    f"Translation Memory exported to TMX successfully!\n\n"
                    f"File: {file_path}\n"
                    f"Entries: {len(tm_entries)}\n"
                    f"Language pair: {source_lang} ‚Üí {target_lang}"
                )
            else:
                QMessageBox.warning(self, "Export Error", "Failed to save TMX file")
            
        except Exception as e:
            self.log(f"‚úó Error exporting TM database as TMX: {e}")
            import traceback
            self.log(traceback.format_exc())
            QMessageBox.critical(self, "Export Error", f"Failed to export:\n\n{str(e)}")
    
    def export_tm_as_tmx(self):
        """Legacy function - exports grid segments (for backward compatibility)"""
        self.export_tmx_from_grid()
    
    
    
    
    def clear_tm_entries(self):
        """Clear all translation memory entries (with confirmation)"""
        try:
            reply = QMessageBox.question(
                self, 
                "Clear Translation Memory", 
                "‚ö†Ô∏è WARNING: This will permanently delete ALL translation memory entries!\n\nThis action cannot be undone. Are you sure?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                # Double confirmation
                reply2 = QMessageBox.question(
                    self, 
                    "Final Confirmation", 
                    "Last chance! Are you absolutely sure you want to delete all TM entries?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if reply2 == QMessageBox.StandardButton.Yes and self.tm_database:
                    # Clear TM entries
                    import sqlite3
                    db_path = self.user_data_path / "resources" / "supervertaler.db"
                    conn = sqlite3.connect(str(db_path))
                    cursor = conn.cursor()
                    cursor.execute("DELETE FROM translation_units")
                    conn.commit()
                    conn.close()
                    
                    self.log("All translation memory entries cleared")
                    QMessageBox.information(self, "TM Cleared", "All translation memory entries have been deleted.")
            
        except Exception as e:
            self.log(f"Error clearing TM entries: {e}")
            QMessageBox.critical(self, "Clear Error", f"Failed to clear TM entries:\n\n{e}")
    
    def create_segmentation_rules_tab(self):
        """Create Segmentation Rules management tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Header
        header = QLabel("üìè Segmentation Rules")
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Description
        desc = QLabel("Manage language-specific segmentation rules for accurate sentence/segment boundaries.")
        desc.setStyleSheet("color: #666; font-size: 11px; margin-bottom: 10px;")
        layout.addWidget(desc)
        
        # Language Selection
        lang_group = QGroupBox("Select Language")
        lang_layout = QHBoxLayout()
        
        lang_combo = QComboBox()
        languages = ["English (en)", "Dutch (nl)", "German (de)", "French (fr)", "Spanish (es)", "Italian (it)", "Portuguese (pt)", "Chinese (zh)", "Japanese (ja)", "Arabic (ar)"]
        lang_combo.addItems(languages)
        lang_layout.addWidget(QLabel("Language:"))
        lang_layout.addWidget(lang_combo, 1)
        
        lang_group.setLayout(lang_layout)
        layout.addWidget(lang_group)
        
        # Segmentation Rules
        rules_group = QGroupBox("Segmentation Rules")
        rules_layout = QVBoxLayout()
        
        # Current implementation info
        current_info = QLabel(
            "Current Implementation: SimpleSegmenter (language-agnostic)\n\n"
            "‚Ä¢ Segments on: . ! ? (followed by space/newline)\n"
            "‚Ä¢ Handles basic abbreviations: Mr. Dr. etc.\n"
            "‚Ä¢ Preserves paragraph breaks\n"
            "‚Ä¢ Treats each table cell as separate segment"
        )
        current_info.setStyleSheet("padding: 10px; border-radius: 4px; font-family: monospace;")
        rules_layout.addWidget(current_info)
        
        # Future implementation section
        future_label = QLabel("üöß Language-Specific Rules (Planned):")
        future_label.setStyleSheet("font-weight: bold; margin-top: 15px;")
        rules_layout.addWidget(future_label)
        
        future_info = QLabel(
            "‚Ä¢ German: Handle compound sentences, different abbreviations\n"
            "‚Ä¢ Chinese/Japanese: Word boundary detection, different punctuation\n"
            "‚Ä¢ Arabic: Right-to-left text handling\n"
            "‚Ä¢ French: Quotation mark handling, spacing rules\n"
            "‚Ä¢ Custom: User-defined regex patterns and exceptions"
        )
        future_info.setStyleSheet("color: #666; margin-left: 20px;")
        rules_layout.addWidget(future_info)
        
        rules_group.setLayout(rules_layout)
        layout.addWidget(rules_group)
        
        # Management buttons (for future implementation)
        buttons_group = QGroupBox("Rule Management")
        buttons_layout = QVBoxLayout()
        
        # Test segmentation button
        test_btn = QPushButton("üß™ Test Segmentation")
        test_btn.setToolTip("Test current segmentation rules on sample text")
        test_btn.clicked.connect(self.test_segmentation_rules)
        buttons_layout.addWidget(test_btn)
        
        # Import/Export buttons (disabled for now)
        import_btn = QPushButton("üì• Import Rules")
        import_btn.setToolTip("Import segmentation rules from file (Coming Soon)")
        import_btn.setEnabled(False)
        buttons_layout.addWidget(import_btn)
        
        export_btn = QPushButton("üì§ Export Rules")
        export_btn.setToolTip("Export current segmentation rules (Coming Soon)")
        export_btn.setEnabled(False)
        buttons_layout.addWidget(export_btn)
        
        buttons_group.setLayout(buttons_layout)
        layout.addWidget(buttons_group)
        
        layout.addStretch()
        
        return tab
    
    def test_segmentation_rules(self):
        """Test current segmentation rules with sample text"""
        from PyQt6.QtWidgets import QInputDialog
        
        sample_text = (
            "Hello world. This is a test! How are you? "
            "Mr. Smith went to Dr. Jones. "
            "The U.S.A. is great. "
            "What about this... and that? "
            "End of test."
        )
        
        text, ok = QInputDialog.getMultiLineText(
            self, 
            "Test Segmentation", 
            "Enter text to test segmentation:\n(Default sample text provided)",
            sample_text
        )
        
        if ok and text:
            try:
                # Test with current segmenter
                from modules.simple_segmenter import SimpleSegmenter
                segmenter = SimpleSegmenter()
                
                # Create fake paragraph list for testing
                paragraphs = [(0, text)]
                segments = segmenter.segment_paragraphs(paragraphs)
                
                # Show results
                result_text = f"Input text:\n{text}\n\n"
                result_text += f"Segmentation results ({len(segments)} segments):\n"
                result_text += "=" * 50 + "\n"
                
                for i, (para_id, segment_text) in enumerate(segments, 1):
                    result_text += f"{i}. {segment_text}\n"
                
                QMessageBox.information(
                    self,
                    "Segmentation Test Results",
                    result_text
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Segmentation Test Error",
                    f"Error testing segmentation:\n\n{e}"
                )
    
    def _update_both_termviews(self, source_text, termbase_list, nt_matches, status_hint=None):
        """Update all three Termview instances with the same data.

        Termview locations:
        1. Under grid (collapsible via View menu)
        2. Match Panel tab (top section)

        Args:
            source_text: The source text for the current segment
            termbase_list: List of termbase match dictionaries
            nt_matches: List of NT (Never Translate) matches
            status_hint: Optional hint for display when no matches:
                         'no_termbases_activated' - no glossaries activated for project
                         'wrong_language' - activated glossaries don't match project language
        """
        # Update left Termview (under grid)
        if hasattr(self, 'termview_widget') and self.termview_widget:
            try:
                self.termview_widget.update_with_matches(source_text, termbase_list, nt_matches, status_hint)
            except Exception as e:
                self.log(f"Error updating left termview: {e}")

        # Update Match Panel Termview
        if hasattr(self, 'termview_widget_match') and self.termview_widget_match:
            try:
                self.termview_widget_match.update_with_matches(source_text, termbase_list, nt_matches, status_hint)
            except Exception as e:
                self.log(f"Error updating Match Panel termview: {e}")

    def _update_termview_for_segment(self, segment):
        """Explicitly update termview for a segment (v1.9.182).

        This is called directly from Ctrl+Enter navigation to ensure
        the termview updates immediately, bypassing the deferred timer approach.
        """
        if not segment or not hasattr(self, 'termview_widget'):
            return

        try:
            # Use in-memory index for fast lookup
            stored_matches = self.find_termbase_matches_in_source(segment.source)

            # Convert dict format to list format for termview
            termbase_matches = [
                {
                    'source_term': match_data.get('source', ''),
                    'target_term': match_data.get('translation', ''),
                    'termbase_name': match_data.get('termbase_name', ''),
                    'ranking': match_data.get('ranking', 99),
                    'is_project_termbase': match_data.get('is_project_termbase', False),
                    'term_id': match_data.get('term_id'),
                    'termbase_id': match_data.get('termbase_id'),
                    'notes': match_data.get('notes', '')
                }
                for match_data in stored_matches.values()
            ] if stored_matches else []

            # Get NT matches
            nt_matches = self.find_nt_matches_in_source(segment.source)

            # Get status hint
            status_hint = self._get_termbase_status_hint()

            # Update both Termview widgets
            self._update_both_termviews(segment.source, termbase_matches, nt_matches, status_hint)

        except Exception as e:
            self.log(f"Error in _update_termview_for_segment: {e}")

    def _get_termbase_status_hint(self) -> str:
        """Check termbase activation status and return appropriate hint.

        Returns:
            'no_termbases_activated' - if no glossaries are activated for this project
            'wrong_language' - if activated glossaries don't match project language pair
            None - if everything is correctly configured
        """
        if not self.current_project:
            return None

        project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
        if not project_id:
            return None

        # Check if termbase manager is available
        if not hasattr(self, 'termbase_mgr') or not self.termbase_mgr:
            return None

        try:
            # Get active termbase IDs for this project
            active_tb_ids = self.termbase_mgr.get_active_termbase_ids(project_id)

            # Check if no termbases are activated
            if not active_tb_ids or len(active_tb_ids) == 0:
                return 'no_termbases_activated'

            # Check if any activated termbases match the project's language pair
            project_source = (self.current_project.source_lang or '').lower()
            project_target = (self.current_project.target_lang or '').lower()

            # Get all termbases and check language pairs
            all_termbases = self.termbase_mgr.get_all_termbases()
            has_matching_language = False

            for tb in all_termbases:
                if tb['id'] in active_tb_ids:
                    tb_source = (tb.get('source_lang') or '').lower()
                    tb_target = (tb.get('target_lang') or '').lower()
                    # Match if: no language set, or languages match (bidirectional)
                    if (not tb_source and not tb_target) or \
                       (tb_source == project_source and tb_target == project_target) or \
                       (tb_source == project_target and tb_target == project_source):
                        has_matching_language = True
                        break

            if not has_matching_language:
                return 'wrong_language'

            return None  # All good

        except Exception as e:
            self.log(f"Error checking termbase status: {e}")
            return None

    def _refresh_termbase_display_for_current_segment(self):
        """Refresh only termbase/glossary display for the current segment.
        
        This is a targeted refresh that does NOT trigger a TM search.
        Use this after adding a term to a glossary to update the display
        without the overhead of re-searching translation memories.
        """
        current_row = self.table.currentRow()
        if current_row < 0 or not self.current_project:
            return
        
        # Get the segment from the grid (use ID from cell, not row index)
        id_item = self.table.item(current_row, 0)
        if not id_item:
            return
        
        try:
            segment_id = int(id_item.text())
        except (ValueError, AttributeError):
            return
        
        segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
        if not segment:
            return
        
        # Clear only the termbase cache for this segment (NOT the TM cache)
        with self.termbase_cache_lock:
            if segment.id in self.termbase_cache:
                del self.termbase_cache[segment.id]
                self.log(f"üóëÔ∏è Cleared termbase cache for segment {segment.id}")
        
        # Search for fresh termbase matches
        termbase_matches = self.find_termbase_matches_in_source(segment.source)
        
        # Update termbase cache
        with self.termbase_cache_lock:
            self.termbase_cache[segment.id] = termbase_matches
        
        # Update TermView widget
        if hasattr(self, 'termview_widget') and self.termview_widget:
            try:
                # Convert termbase matches to list format for termview
                # Note: find_termbase_matches_in_source returns dict with 'source' and 'translation' keys
                termbase_list = [
                    {
                        'source_term': match.get('source', ''),  # 'source' not 'source_term'
                        'target_term': match.get('translation', ''),  # 'translation' not 'target_term'
                        'termbase_name': match.get('termbase_name', ''),
                        'ranking': match.get('ranking', 99),
                        'is_project_termbase': match.get('is_project_termbase', False),
                        'term_id': match.get('term_id'),
                        'termbase_id': match.get('termbase_id'),
                        'notes': match.get('notes', '')
                    }
                    for match in termbase_matches.values() if isinstance(match, dict)
                ] if isinstance(termbase_matches, dict) else []
                
                # Get NT matches
                nt_matches = self.find_nt_matches_in_source(segment.source)

                # Get status hint for termbase activation
                status_hint = self._get_termbase_status_hint()

                # Update both Termview widgets (left and right)
                self._update_both_termviews(segment.source, termbase_list, nt_matches, status_hint)
            except Exception as e:
                self.log(f"Error updating termview: {e}")
        
        # Update Translation Results panel termbase section (without touching TM)
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                try:
                    # Get the existing matches from the panel and update only Termbases
                    if hasattr(panel, 'current_matches') and panel.current_matches:
                        # Convert termbase matches to TranslationMatch format
                        # Note: find_termbase_matches_in_source returns 'source' and 'translation' keys
                        from modules.translation_results_panel import TranslationMatch
                        tb_matches = []
                        for match_data in termbase_matches.values():
                            if isinstance(match_data, dict):
                                tb_match = TranslationMatch(
                                    source=match_data.get('source', ''),  # 'source' not 'source_term'
                                    target=match_data.get('translation', ''),  # 'translation' not 'target_term'
                                    relevance=100.0,
                                    match_type='Termbase',
                                    provider=match_data.get('termbase_name', 'Glossary'),
                                    metadata={
                                        'termbase_name': match_data.get('termbase_name', ''),
                                        'ranking': match_data.get('ranking', 99),
                                        'is_project_termbase': match_data.get('is_project_termbase', False),
                                        'term_id': match_data.get('term_id'),
                                        'termbase_id': match_data.get('termbase_id'),
                                        'notes': match_data.get('notes', '')
                                    }
                                )
                                tb_matches.append(tb_match)
                        
                        # Update just the Termbases section
                        panel.current_matches['Termbases'] = tb_matches
                        panel.set_matches(panel.current_matches)
                except Exception as e:
                    self.log(f"Error updating results panel termbases: {e}")
        
        # OPTIMIZATION: Skip full rehighlight for quick-add performance
        # The TermView widget already shows the updated matches, and full rehighlight
        # is expensive for long segments (runs spellcheck, tag detection, termbase highlighting)
        # The highlighting will update automatically on next segment navigation
        # 
        # Re-highlight termbase matches in the source cell
        # source_widget = self.table.cellWidget(current_row, 2)
        # if source_widget and hasattr(source_widget, 'rehighlight'):
        #     source_widget.rehighlight()
        
        self.log(f"üîÑ Refreshed termbase display for segment {segment.id} (TM untouched)")
    
    def add_term_pair_to_termbase(self, source_text: str, target_text: str):
        """Add a term pair to active termbase(s) with metadata dialog"""
        # Check if we have a current project
        if not hasattr(self, 'current_project') or not self.current_project:
            QMessageBox.warning(self, "No Active Project", "Please open or create a project before adding terms to glossary.")
            return
        
        # Get active termbases for current project
        if not hasattr(self, 'termbase_mgr') or not self.termbase_mgr:
            QMessageBox.critical(self, "Error", "Glossary manager not initialized")
            return
        
        # Generate a simple project ID from the project file path (use hash of path)
        import hashlib
        project_id = None
        if hasattr(self, 'project_file_path') and self.project_file_path:
            project_id = int(hashlib.md5(self.project_file_path.encode()).hexdigest()[:8], 16)
        else:
            # Use project name as fallback
            project_id = int(hashlib.md5(self.current_project.name.encode()).hexdigest()[:8], 16)
        
        # Get all termbases (not just active) so newly created ones appear in the dialog
        active_termbases = self.termbase_mgr.get_all_termbases()
        
        if not active_termbases:
            QMessageBox.warning(self, "No Glossary", "Please create or activate at least one glossary in Resources ‚Üí Glossaries tab.")
            return
        
        # Show metadata dialog with termbase selection
        dialog = TermMetadataDialog(source_text, target_text, active_termbases, self, user_data_path=self.user_data_path)
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return  # User cancelled
        
        metadata = dialog.get_metadata()
        selected_termbase_ids = dialog.get_selected_termbases()
        source_synonyms = dialog.get_source_synonyms()
        target_synonyms = dialog.get_target_synonyms()
        
        if not selected_termbase_ids:
            QMessageBox.warning(self, "No Glossary Selected", "Please select at least one glossary to save the term to.")
            return
        
        # Store the selected termbase IDs for quick add (Ctrl+Q)
        self._last_selected_termbase_ids = selected_termbase_ids
        self.log(f"üíæ Stored last-selected termbase IDs for Ctrl+Q: {selected_termbase_ids}")
        
        # Get source and target languages from current project
        source_lang = self.current_project.source_lang if self.current_project else 'English'
        target_lang = self.current_project.target_lang if self.current_project else 'Dutch'
        
        # Convert to language codes for database storage
        source_lang_code = self._convert_language_to_code(source_lang)
        target_lang_code = self._convert_language_to_code(target_lang)
        
        self.log(f"üìù Adding term with languages: {source_lang} ({source_lang_code}) ‚Üí {target_lang} ({target_lang_code})")
        if source_synonyms:
            self.log(f"   With {len(source_synonyms)} source synonym(s): {', '.join([s['text'] for s in source_synonyms])}")
        if target_synonyms:
            self.log(f"   With {len(target_synonyms)} target synonym(s): {', '.join([s['text'] for s in target_synonyms])}")
        
        # Add term to selected termbases only
        success_count = 0
        duplicate_count = 0
        error_count = 0
        for tb in active_termbases:
            if tb['id'] not in selected_termbase_ids:
                continue  # Skip unselected termbases
            
            try:
                term_id = self.termbase_mgr.add_term(
                    termbase_id=tb['id'],
                    source_term=source_text,
                    target_term=target_text,
                    source_lang=source_lang_code,
                    target_lang=target_lang_code,
                    notes=metadata['notes'],
                    domain=metadata['domain'],
                    project=metadata['project'],
                    client=metadata['client'],
                    # priority removed - now managed at termbase level via ranking
                    forbidden=metadata['forbidden']
                )
                
                if term_id:
                    success_count += 1
                    self.log(f"‚úì Added term to termbase '{tb['name']}': {source_text} ‚Üí {target_text}")
                    
                    # Add source synonyms if any
                    if source_synonyms:
                        for syn_data in source_synonyms:
                            if self.termbase_mgr.add_synonym(
                                term_id, 
                                syn_data['text'], 
                                language='source',
                                display_order=syn_data['order'],
                                forbidden=syn_data['forbidden']
                            ):
                                forbidden_marker = " (forbidden)" if syn_data['forbidden'] else ""
                                self.log(f"  ‚úì Added source synonym: {syn_data['text']}{forbidden_marker}")
                            else:
                                self.log(f"  ‚úó Failed to add source synonym: {syn_data['text']}")
                    
                    # Add target synonyms if any
                    if target_synonyms:
                        for syn_data in target_synonyms:
                            if self.termbase_mgr.add_synonym(
                                term_id, 
                                syn_data['text'], 
                                language='target',
                                display_order=syn_data['order'],
                                forbidden=syn_data['forbidden']
                            ):
                                forbidden_marker = " (forbidden)" if syn_data['forbidden'] else ""
                                self.log(f"  ‚úì Added target synonym: {syn_data['text']}{forbidden_marker}")
                            else:
                                self.log(f"  ‚úó Failed to add target synonym: {syn_data['text']}")

                else:
                    duplicate_count += 1
                    
            except Exception as e:
                error_count += 1
                self.log(f"‚úó Error adding term to termbase '{tb['name']}': {e}")
        
        # Show result
        if success_count > 0:
            self._play_sound_effect('glossary_term_added')

            # Non-modal info bar message (status bar)
            try:
                if hasattr(self, 'statusBar') and self.statusBar():
                    if success_count == 1:
                        self.statusBar().showMessage(f"‚úì Added glossary entry: {source_text} ‚Üí {target_text} (to 1 glossary)", 3500)
                    else:
                        self.statusBar().showMessage(f"‚úì Added glossary entry to {success_count} glossaries: {source_text} ‚Üí {target_text}", 3500)
            except Exception:
                pass

            QMessageBox.information(self, "Term Added", f"Successfully added term pair to {success_count} glossary(s):\\n\\nSource: {source_text}\\nTarget: {target_text}\\n\\nDomain: {metadata['domain'] or '(none)'}")
            
            # Refresh termbase display (NOT TM - that would be wasteful)
            self._refresh_termbase_display_for_current_segment()
            
            # IMPORTANT: Refresh the termbase list UI if it's currently open to update term counts
            # Find the termbase tab and call its refresh function
            if hasattr(self, 'termbase_tab_refresh_callback') and self.termbase_tab_refresh_callback:
                self.log("üîÑ Refreshing glossary list to update term counts")
                self.termbase_tab_refresh_callback()
            else:
                self.log("‚ö†Ô∏è No glossary refresh callback found (tab not initialized yet)")
        else:
            if duplicate_count > 0 and error_count == 0:
                self._play_sound_effect('glossary_term_duplicate')
                try:
                    if hasattr(self, 'statusBar') and self.statusBar():
                        self.statusBar().showMessage("‚ö† Duplicate glossary entry (not added)", 3500)
                except Exception:
                    pass
                QMessageBox.warning(
                    self,
                    "Duplicate Term",
                    "This term already exists in the selected glossary(s). Duplicate terms are not allowed."
                )
            else:
                self._play_sound_effect('glossary_term_error')
                try:
                    if hasattr(self, 'statusBar') and self.statusBar():
                        self.statusBar().showMessage("‚ùå Error adding glossary entry (see log)", 3500)
                except Exception:
                    pass
                QMessageBox.warning(self, "Error Adding Term", "Failed to add term to any glossary. Check the log for details.")
    
    def quick_add_term_pair_to_termbase(self, source_text: str, target_text: str):
        """Quick add a term pair to the last-used termbase without showing any dialogs (Ctrl+Q)
        
        Uses the termbase(s) selected in the last Ctrl+E dialog. If none selected yet,
        prompts the user to use Ctrl+E first.
        """
        # Check if we have a current project
        if not hasattr(self, 'current_project') or not self.current_project:
            QMessageBox.warning(self, "No Active Project", "Please open or create a project before adding terms to glossary.")
            return
        
        # Get termbase manager
        if not hasattr(self, 'termbase_mgr') or not self.termbase_mgr:
            QMessageBox.critical(self, "Error", "Glossary manager not initialized")
            return
        
        # Check if we have a last-selected termbase from Ctrl+E
        if not hasattr(self, '_last_selected_termbase_ids') or not self._last_selected_termbase_ids:
            QMessageBox.information(self, "No Glossary Selected", 
                "Please use Ctrl+E first to select which glossary to save terms to.\n\n"
                "After that, Ctrl+Q will quick-save to the same glossary(s).")
            return
        
        # Get all termbases to find the ones matching the saved IDs
        all_termbases = self.termbase_mgr.get_all_termbases()
        
        if not all_termbases:
            QMessageBox.warning(self, "No Glossary", 
                "Please create at least one glossary in Resources ‚Üí Glossaries tab.")
            return
        
        # Find the termbases that match the saved IDs
        target_termbases = [tb for tb in all_termbases if tb['id'] in self._last_selected_termbase_ids]
        
        if not target_termbases:
            QMessageBox.warning(self, "Glossary Not Found", 
                "The previously selected glossary(s) could not be found.\n\n"
                "Please use Ctrl+E to select a glossary again.")
            self._last_selected_termbase_ids = None
            return
        
        # Get source and target languages from current project
        source_lang = self.current_project.source_lang if self.current_project else 'English'
        target_lang = self.current_project.target_lang if self.current_project else 'Dutch'
        
        # Convert to language codes for database storage
        source_lang_code = self._convert_language_to_code(source_lang)
        target_lang_code = self._convert_language_to_code(target_lang)
        
        termbase_names = [tb['name'] for tb in target_termbases]
        self.log(f"‚ö° Quick-adding term: {source_text} ‚Üí {target_text}")
        self.log(f"   To termbase(s): {', '.join(termbase_names)}")
        
        success_count = 0
        duplicate_count = 0
        error_count = 0
        for target_termbase in target_termbases:
            try:
                term_id = self.termbase_mgr.add_term(
                    termbase_id=target_termbase['id'],
                    source_term=source_text,
                    target_term=target_text,
                    source_lang=source_lang_code,
                    target_lang=target_lang_code,
                    notes="",
                    domain="",
                    project="",
                    client="",
                    forbidden=False
                )
                
                if term_id:
                    success_count += 1
                    self.log(f"‚úì Quick-added term to '{target_termbase['name']}': {source_text} ‚Üí {target_text}")
                else:
                    duplicate_count += 1
            except Exception as e:
                error_count += 1
                self.log(f"‚úó Error quick-adding term to '{target_termbase['name']}': {e}")
        
        if success_count > 0:
            self._play_sound_effect('glossary_term_added')
            # Show brief success notification in statusbar instead of dialog
            if hasattr(self, 'statusBar') and self.statusBar():
                if success_count == 1:
                    self.statusBar().showMessage(f"‚úì Added: {source_text} ‚Üí {target_text} (to {termbase_names[0]})", 3000)
                else:
                    self.statusBar().showMessage(f"‚úì Added: {source_text} ‚Üí {target_text} (to {success_count} termbases)", 3000)
            
            # Refresh termbase display (NOT TM - that would be wasteful)
            self._refresh_termbase_display_for_current_segment()
            
            # Refresh termbase list UI if open
            if hasattr(self, 'termbase_tab_refresh_callback') and self.termbase_tab_refresh_callback:
                self.termbase_tab_refresh_callback()
        else:
            if duplicate_count > 0 and error_count == 0:
                self._play_sound_effect('glossary_term_duplicate')
                if hasattr(self, 'statusBar') and self.statusBar():
                    self.statusBar().showMessage("‚ö† Duplicate glossary entry (not added)", 3500)
                QMessageBox.warning(self, "Duplicate Term", "This term already exists in the glossary. Duplicate terms are not allowed.")
            else:
                self._play_sound_effect('glossary_term_error')
                if hasattr(self, 'statusBar') and self.statusBar():
                    self.statusBar().showMessage("‚ùå Error adding glossary entry (see log)", 3500)
                QMessageBox.warning(self, "Error", "Failed to add term. Check the log for details.")

    def _quick_add_term_with_priority(self, glossary_rank: int):
        """Quick add selected term pair to the glossary with the specified ranking
        
        Gets selected text from source and target cells, then adds to the glossary
        that has the specified priority ranking (1 = highest priority, 2 = second, etc.)
        
        Args:
            glossary_rank: Which glossary to add to (1 = first/highest priority, 2 = second, etc.)
        """
        # Get current row
        current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
        if current_row < 0:
            self.statusBar().showMessage("No segment selected", 3000)
            return
        
        # Get source selection
        source_widget = self.table.cellWidget(current_row, 2)
        source_text = ""
        if source_widget and hasattr(source_widget, 'textCursor'):
            source_text = source_widget.textCursor().selectedText().strip()
        
        # Get target selection
        target_widget = self.table.cellWidget(current_row, 3)
        target_text = ""
        if target_widget and hasattr(target_widget, 'textCursor'):
            target_text = target_widget.textCursor().selectedText().strip()
        
        # Validate selections
        if not source_text or not target_text:
            self.statusBar().showMessage("Select text in both Source and Target cells first", 3000)
            return
        
        # Check prerequisites
        if not hasattr(self, 'current_project') or not self.current_project:
            self.statusBar().showMessage("No project open", 3000)
            return
        
        if not hasattr(self, 'termbase_mgr') or not self.termbase_mgr:
            self.statusBar().showMessage("Glossary manager not initialized", 3000)
            return
        
        project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
        if not project_id:
            self.statusBar().showMessage("No project ID - save project first", 3000)
            return
        
        # Get glossaries with their priority from database
        target_termbase = None
        all_termbases = self.termbase_mgr.get_all_termbases()
        
        # Build list of (termbase, priority) for active glossaries
        ranked_termbases = []
        for tb in all_termbases:
            tb_id = tb['id']
            # Query priority from database (returns None if not activated)
            priority = self.termbase_mgr.get_termbase_priority(tb_id, project_id)
            if priority is not None:
                ranked_termbases.append((tb, priority))
        
        # Sort by priority (lower = higher priority, so #1 is first)
        ranked_termbases.sort(key=lambda x: x[1])
        
        self.log(f"üîç Looking for glossary at rank #{glossary_rank}. Found {len(ranked_termbases)} active glossaries: {[(t[0]['name'], t[1]) for t in ranked_termbases]}")
        
        # Find the glossary with the specified priority number
        for tb, priority in ranked_termbases:
            if priority == glossary_rank:
                target_termbase = tb
                break
        
        if not target_termbase:
            self.statusBar().showMessage(f"No glossary with Priority #{glossary_rank} - check Project Resources ‚Üí Glossaries", 3000)
            return
        
        # Get language codes
        source_lang = self.current_project.source_lang if self.current_project else 'English'
        target_lang = self.current_project.target_lang if self.current_project else 'Dutch'
        source_lang_code = self._convert_language_to_code(source_lang)
        target_lang_code = self._convert_language_to_code(target_lang)
        
        self.log(f"‚ö° Quick-adding term to rank #{glossary_rank} glossary '{target_termbase['name']}': {source_text} ‚Üí {target_text}")
        
        try:
            term_id = self.termbase_mgr.add_term(
                termbase_id=target_termbase['id'],
                source_term=source_text,
                target_term=target_text,
                source_lang=source_lang_code,
                target_lang=target_lang_code,
                priority=99,  # Default priority for the term itself
                notes="",
                domain="",
                project="",
                client="",
                forbidden=False
            )
            
            if term_id:
                self._play_sound_effect('glossary_term_added')
                self.log(f"‚úì Added to '{target_termbase['name']}': {source_text} ‚Üí {target_text}")
                self.statusBar().showMessage(f"‚úì Added to '{target_termbase['name']}': {source_text} ‚Üí {target_text}", 3000)
                
                # OPTIMIZATION: Directly add the new term to cache and TermView instead of full search
                # This avoids the 5-6 second delay from searching all words in long patent segments
                current_row = self.table.currentRow()
                if current_row >= 0 and self.current_project:
                    id_item = self.table.item(current_row, 0)
                    if id_item:
                        try:
                            segment_id = int(id_item.text())
                            segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
                            
                            if segment:
                                # Create match entry for the new term
                                new_match = {
                                    'source': source_text,
                                    'translation': target_text,
                                    'priority': 99,
                                    'ranking': glossary_rank,  # Use the priority rank we just added to
                                    'forbidden': False,
                                    'is_project_termbase': False,
                                    'term_id': term_id,
                                    'termbase_id': target_termbase['id'],
                                    'termbase_name': target_termbase['name'],
                                    'domain': '',
                                    'notes': '',
                                    'project': '',
                                    'client': '',
                                    'target_synonyms': []
                                }
                                
                                # Add to cache directly
                                with self.termbase_cache_lock:
                                    if segment_id not in self.termbase_cache:
                                        self.termbase_cache[segment_id] = {}
                                    # Use term_id as key to avoid duplicates
                                    self.termbase_cache[segment_id][term_id] = new_match
                                    self.log(f"‚ö° Added term directly to cache (instant update)")

                                # v1.9.182: Also add to in-memory termbase index for future lookups
                                import re
                                source_lower = source_text.lower().strip()
                                try:
                                    if any(c in source_lower for c in '.%,/-'):
                                        pattern = re.compile(r'(?<!\w)' + re.escape(source_lower) + r'(?!\w)')
                                    else:
                                        pattern = re.compile(r'\b' + re.escape(source_lower) + r'\b')
                                except re.error:
                                    pattern = None

                                index_entry = {
                                    'term_id': term_id,
                                    'source_term': source_text,
                                    'source_term_lower': source_lower,
                                    'target_term': target_text,
                                    'termbase_id': target_termbase['id'],
                                    'priority': 99,
                                    'domain': '',
                                    'notes': '',
                                    'project': '',
                                    'client': '',
                                    'forbidden': False,
                                    'is_project_termbase': False,
                                    'termbase_name': target_termbase['name'],
                                    'ranking': glossary_rank,
                                    'pattern': pattern,
                                }
                                with self.termbase_index_lock:
                                    self.termbase_index.append(index_entry)
                                    # Re-sort by length (longest first) for proper phrase matching
                                    self.termbase_index.sort(key=lambda x: len(x['source_term_lower']), reverse=True)
                                
                                # Update TermView widget with the new term
                                if hasattr(self, 'termview_widget') and self.termview_widget:
                                    # Get current matches from cache
                                    with self.termbase_cache_lock:
                                        cached_matches = self.termbase_cache.get(segment_id, {})
                                    
                                    # Convert to list format for TermView
                                    termbase_list = [
                                        {
                                            'source_term': match.get('source', ''),
                                            'target_term': match.get('translation', ''),
                                            'termbase_name': match.get('termbase_name', ''),
                                            'ranking': match.get('ranking', 99),
                                            'is_project_termbase': match.get('is_project_termbase', False),
                                            'term_id': match.get('term_id'),
                                            'termbase_id': match.get('termbase_id'),
                                            'notes': match.get('notes', '')
                                        }
                                        for match in cached_matches.values() if isinstance(match, dict)
                                    ]
                                    
                                    # Get NT matches
                                    nt_matches = self.find_nt_matches_in_source(segment.source)

                                    # Get status hint (although after adding a term, it should be fine)
                                    status_hint = self._get_termbase_status_hint()

                                    # Update both Termview widgets (left and right)
                                    self._update_both_termviews(segment.source, termbase_list, nt_matches, status_hint)
                                    self.log(f"‚úÖ Both TermView widgets updated instantly with new term")
                                
                                # Update source cell highlighting with updated cache
                                # Call the highlighting function directly with the new matches
                                self.highlight_source_with_termbase(current_row, segment.source, cached_matches)
                                self.log(f"‚úÖ Source highlighting updated with new term")
                        
                        except Exception as e:
                            self.log(f"‚ö†Ô∏è  Quick cache update failed, falling back to full search: {e}")
                            # Fallback to full refresh if something goes wrong
                            self._refresh_termbase_display_for_current_segment()
                
                # OPTIMIZATION: Skip refreshing the entire termbase table UI (slow)
                # We're just adding ONE term to ONE glossary - no need to rebuild the whole table
                # The term count will update naturally when user switches segments or tabs
                # if hasattr(self, 'termbase_tab_refresh_callback') and self.termbase_tab_refresh_callback:
                #     self.termbase_tab_refresh_callback()
            else:
                self._play_sound_effect('glossary_term_duplicate')
                self.statusBar().showMessage(f"Term already exists in '{target_termbase['name']}'", 3000)
        except Exception as e:
            self.log(f"‚úó Error adding term: {e}")
            self._play_sound_effect('glossary_term_error')
            self.statusBar().showMessage(f"Error adding term: {e}", 3000)

    def add_word_to_dictionary_shortcut(self):
        """Add word at cursor position to custom dictionary (Alt+D shortcut)
        
        Finds the misspelled word at the current cursor position and adds it to the
        custom dictionary. Works when focus is in a grid target cell.
        """
        # Get currently focused widget
        focused_widget = QApplication.focusWidget()
        
        # Check if we're in an editable grid cell
        if not isinstance(focused_widget, EditableGridTextEditor):
            self.statusBar().showMessage("Alt+D: Place cursor on a misspelled word in the target cell first", 3000)
            return
        
        # Get cursor position
        cursor = focused_widget.textCursor()
        
        # Try to find misspelled word at cursor
        word_info = focused_widget._get_misspelled_word_at_cursor(cursor)
        
        if word_info[0] is None:
            # No misspelled word found at cursor
            self.statusBar().showMessage("No misspelled word at cursor position", 3000)
            return
        
        word, start_pos, end_pos = word_info
        
        # Add to dictionary
        focused_widget._add_to_dictionary(word)
        
        # Status message already shown by _add_to_dictionary

    def add_text_to_non_translatables(self, text: str):
        """Add selected text to active non-translatable list(s)"""
        if not text or not text.strip():
            QMessageBox.warning(self, "No Text", "Please select text before adding to non-translatables.")
            return
        
        text = text.strip()
        
        # Check if NT manager is available
        if not hasattr(self, 'nt_manager') or not self.nt_manager:
            QMessageBox.critical(self, "Error", "Non-translatables manager not initialized")
            return
        
        # Get all NT lists
        nt_lists = self.nt_manager.get_all_lists()
        
        if not nt_lists:
            # No lists exist - offer to create one
            result = QMessageBox.question(
                self, 
                "No Non-Translatables List",
                "No non-translatables lists exist. Would you like to create one?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if result == QMessageBox.StandardButton.Yes:
                # Switch to NT tab to create a list
                if hasattr(self, 'tr_tabs') and self.tr_tabs:
                    for i in range(self.tr_tabs.count()):
                        if "Non-Translatable" in self.tr_tabs.tabText(i):
                            self.tr_tabs.setCurrentIndex(i)
                            break
            return
        
        # Get active lists for current project
        project_id = None
        if hasattr(self, 'project_file_path') and self.project_file_path:
            import hashlib
            project_id = int(hashlib.md5(self.project_file_path.encode()).hexdigest()[:8], 16)
        
        active_lists = [lst for lst in nt_lists if lst.is_active]
        
        if not active_lists:
            # No active lists - show selection dialog
            from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QListWidget, QDialogButtonBox, QListWidgetItem
            from PyQt6.QtCore import Qt
            
            dialog = QDialog(self)
            dialog.setWindowTitle("Select Non-Translatables List")
            dialog.setMinimumWidth(350)
            layout = QVBoxLayout(dialog)
            
            layout.addWidget(QLabel(f"Select list(s) to add \"{text}\" to:"))
            
            list_widget = QListWidget()
            for lst in nt_lists:
                item = QListWidgetItem(f"{lst.name} ({len(lst.entries)} entries)")
                item.setData(Qt.ItemDataRole.UserRole, lst.id)
                item.setCheckState(Qt.CheckState.Unchecked)
                list_widget.addItem(item)
            layout.addWidget(list_widget)
            
            buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
            buttons.accepted.connect(dialog.accept)
            buttons.rejected.connect(dialog.reject)
            layout.addWidget(buttons)
            
            if dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            # Get selected lists
            selected_lists = []
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                if item.checkState() == Qt.CheckState.Checked:
                    list_id = item.data(Qt.ItemDataRole.UserRole)
                    for lst in nt_lists:
                        if lst.id == list_id:
                            selected_lists.append(lst)
                            break
            
            if not selected_lists:
                QMessageBox.warning(self, "No List Selected", "Please select at least one list.")
                return
            
            active_lists = selected_lists
        
        # Add to all active lists
        from modules.non_translatables_manager import NonTranslatable
        success_count = 0
        duplicate_count = 0
        
        for lst in active_lists:
            # Check if already exists
            if any(entry.text.lower() == text.lower() for entry in lst.entries):
                duplicate_count += 1
                self.log(f"‚ö†Ô∏è '{text}' already exists in NT list '{lst.name}'")
                continue
            
            # Create new entry
            new_entry = NonTranslatable(
                text=text,
                case_sensitive=True,
                category="",
                notes=f"Added from grid selection"
            )
            lst.entries.append(new_entry)
            
            # Save the list
            if self.nt_manager.save_list(lst):
                success_count += 1
                self.log(f"‚úÖ Added '{text}' to NT list '{lst.name}'")
            else:
                self.log(f"‚ùå Failed to save NT list '{lst.name}'")
        
        # Show result
        if success_count > 0:
            QMessageBox.information(
                self, 
                "Added to Non-Translatables",
                f"Added \"{text}\" to {success_count} list(s)." + 
                (f"\n\n{duplicate_count} list(s) already contained this entry." if duplicate_count else "")
            )
            
            # Refresh highlighting for current segment
            current_row = self.table.currentRow()
            if current_row >= 0 and current_row < len(self.current_project.segments):
                # Clear any NT cache if exists
                segment = self.current_project.segments[current_row]
                
                # Refresh the source cell highlighting
                source_widget = self.table.cellWidget(current_row, 2)
                if source_widget and hasattr(source_widget, 'highlight_termbase_matches'):
                    source_text = source_widget.toPlainText()
                    nt_matches = self.find_nt_matches_in_source(source_text)
                    if nt_matches and hasattr(source_widget, 'highlight_non_translatables'):
                        source_widget.highlight_non_translatables(nt_matches)
                
                # Trigger panel refresh
                self._last_selected_row = -1
                self.on_cell_selected(current_row, self.table.currentColumn(), -1, -1)
        elif duplicate_count > 0:
            QMessageBox.information(
                self,
                "Already Exists",
                f"\"{text}\" already exists in all active non-translatables lists."
            )
        else:
            QMessageBox.warning(self, "Error", "Failed to add to any non-translatables list.")
    
    def create_termbases_tab(self):
        """Create the Termbases tab - manage all termbases (global and project-specific)"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Header
        header = QLabel("üìö Glossaries")
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Description
        desc = QLabel("Manage glossaries for terminology searching. Activate/deactivate for current project.")
        desc.setStyleSheet("color: #666; font-size: 11px; margin-bottom: 10px;")
        layout.addWidget(desc)
        
        # Check if database is available
        if not (hasattr(self, 'db_manager') and self.db_manager):
            placeholder = QLabel("Glossary Manager\n\nDatabase not initialized.")
            placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
            placeholder.setStyleSheet("color: #888; font-size: 12px;")
            layout.addWidget(placeholder, stretch=1)
            return tab
        
        # Import here to avoid issues if database not available
        from modules.termbase_manager import TermbaseManager
        termbase_mgr = TermbaseManager(self.db_manager, self.log)
        self.termbase_mgr = termbase_mgr  # Store for later use in get_termbase_code
        
        # ========== MAIN SPLITTER ==========
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # ========== LEFT PANEL: Termbase List ==========
        left_panel = QWidget()
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 5, 0)
        
        # Search bar
        search_layout = QHBoxLayout()
        search_box = QLineEdit()
        search_box.setPlaceholderText("Search glossaries...")
        search_box.setMaximumWidth(300)
        search_layout.addWidget(search_box)
        search_layout.addStretch()
        left_layout.addLayout(search_layout)
        
        # Help message
        help_msg = QLabel(
            "üí° <b>Glossaries</b><br>"
            "‚Ä¢ <b>Read</b> (green ‚úì): Glossary is used for terminology matching<br>"
            "‚Ä¢ <b>Write</b> (blue ‚úì): Glossary is updated with new terms<br>"
            "‚Ä¢ <b>Priority</b>: Manually set 1-N (lower = higher priority). Priority #1 = Project Glossary.<br>"
            "‚Ä¢ <b>AI</b> (orange ‚úì): Send glossary terms to LLM with every translation (increases prompt size)"
        )
        help_msg.setWordWrap(True)
        help_msg.setStyleSheet("background-color: #e3f2fd; padding: 8px; border-radius: 4px; color: #1976d2;")
        left_layout.addWidget(help_msg)
        
        # Bulk action controls
        tb_bulk_layout = QHBoxLayout()
        tb_bulk_layout.addWidget(QLabel("Quick Actions:"))
        
        tb_read_header_checkbox = CheckmarkCheckBox("Select All Read")
        tb_bulk_layout.addWidget(tb_read_header_checkbox)
        
        tb_write_header_checkbox = BlueCheckmarkCheckBox("Select All Write")
        tb_bulk_layout.addWidget(tb_write_header_checkbox)
        
        tb_bulk_layout.addStretch()
        left_layout.addLayout(tb_bulk_layout)
        
        # Termbase list with table
        termbase_table = QTableWidget()
        self.termbase_table = termbase_table  # Store for external access (Superlookup navigation)
        termbase_table.setColumnCount(8)
        termbase_table.setHorizontalHeaderLabels(["Type", "Name", "Languages", "Terms", "Read", "Write", "Priority", "AI"])
        termbase_table.horizontalHeader().setStretchLastSection(False)
        termbase_table.setColumnWidth(0, 80)   # Type (Project/Background)
        termbase_table.setColumnWidth(1, 180)  # Name
        termbase_table.setColumnWidth(2, 100)  # Languages
        termbase_table.setColumnWidth(3, 50)   # Terms
        termbase_table.setColumnWidth(4, 50)   # Read checkbox
        termbase_table.setColumnWidth(5, 50)   # Write checkbox
        termbase_table.setColumnWidth(6, 60)   # Priority
        termbase_table.setColumnWidth(7, 40)   # AI checkbox
        termbase_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        termbase_table.setSelectionMode(QTableWidget.SelectionMode.SingleSelection)
        termbase_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)  # Disable inline editing
        
        # Enable context menu for termbase table
        termbase_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        termbase_table.customContextMenuRequested.connect(
            lambda pos: self._show_termbase_context_menu(pos, termbase_table, termbase_mgr, refresh_termbase_list)
        )
        
        # Get current project
        current_project = self.current_project if hasattr(self, 'current_project') else None
        # current_project is a Project object, not a dict
        project_id = current_project.id if (current_project and hasattr(current_project, 'id')) else None
        
        # Filter function for search box
        def filter_termbase_table(search_text):
            """Filter termbase table rows by name"""
            search_text = search_text.lower().strip()
            for row in range(termbase_table.rowCount()):
                name_item = termbase_table.item(row, 1)
                if name_item:
                    name = name_item.text().lower()
                    # Show row if search text is in the name, or if search is empty
                    termbase_table.setRowHidden(row, search_text and search_text not in name)
        
        # Connect search box to filter function
        search_box.textChanged.connect(filter_termbase_table)
        
        # Connect header checkboxes to toggle all
        def toggle_all_tb_read(checked):
            for row in range(termbase_table.rowCount()):
                checkbox = termbase_table.cellWidget(row, 4)
                if checkbox and isinstance(checkbox, CheckmarkCheckBox):
                    checkbox.setChecked(checked)
        
        def toggle_all_tb_write(checked):
            for row in range(termbase_table.rowCount()):
                checkbox = termbase_table.cellWidget(row, 5)
                if checkbox and isinstance(checkbox, BlueCheckmarkCheckBox):
                    checkbox.setChecked(checked)
        
        tb_read_header_checkbox.toggled.connect(toggle_all_tb_read)
        tb_write_header_checkbox.toggled.connect(toggle_all_tb_write)
        
        # ========== RIGHT PANEL: Terms Editor ==========
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(5, 0, 0, 0)
        
        # Terms header with termbase name
        terms_header_layout = QHBoxLayout()
        terms_header = QLabel("üìù Terms")
        terms_header.setStyleSheet("font-size: 13px; font-weight: bold;")
        terms_header_layout.addWidget(terms_header)
        
        selected_tb_label = QLabel("Select a glossary to view/edit terms")
        selected_tb_label.setStyleSheet("color: #666; font-style: italic;")
        terms_header_layout.addWidget(selected_tb_label)
        terms_header_layout.addStretch()
        right_layout.addLayout(terms_header_layout)
        
        # Search/filter for terms
        terms_search_layout = QHBoxLayout()
        terms_search_box = QLineEdit()
        terms_search_box.setPlaceholderText("Filter terms...")
        terms_search_box.setMaximumWidth(250)
        terms_search_layout.addWidget(terms_search_box)
        self.terms_search_box = terms_search_box  # Store for external access
        terms_search_layout.addStretch()
        right_layout.addLayout(terms_search_layout)
        
        # ========== PAGINATION CONTROLS ==========
        # State variables for pagination (using lists to allow modification in nested functions)
        terms_page_size = [100]  # Terms per page
        terms_current_page = [0]  # Current page (0-indexed)
        terms_total_count = [0]  # Total terms in current termbase
        terms_filter_text = ['']  # Current filter text
        
        pagination_layout = QHBoxLayout()
        pagination_layout.setContentsMargins(0, 5, 0, 5)
        
        # Page size selector
        page_size_label = QLabel("Show:")
        page_size_combo = QComboBox()
        page_size_combo.addItems(["50", "100", "250", "500", "All"])
        page_size_combo.setCurrentText("100")
        page_size_combo.setFixedWidth(70)
        pagination_layout.addWidget(page_size_label)
        pagination_layout.addWidget(page_size_combo)
        
        pagination_layout.addSpacing(20)
        
        # Navigation buttons
        first_page_btn = QPushButton("‚èÆ")
        first_page_btn.setFixedWidth(30)
        first_page_btn.setToolTip("First page")
        prev_page_btn = QPushButton("‚óÄ")
        prev_page_btn.setFixedWidth(30)
        prev_page_btn.setToolTip("Previous page")
        
        page_info_label = QLabel("Page 1 of 1")
        page_info_label.setStyleSheet("padding: 0 10px;")
        
        next_page_btn = QPushButton("‚ñ∂")
        next_page_btn.setFixedWidth(30)
        next_page_btn.setToolTip("Next page")
        last_page_btn = QPushButton("‚è≠")
        last_page_btn.setFixedWidth(30)
        last_page_btn.setToolTip("Last page")
        
        pagination_layout.addWidget(first_page_btn)
        pagination_layout.addWidget(prev_page_btn)
        pagination_layout.addWidget(page_info_label)
        pagination_layout.addWidget(next_page_btn)
        pagination_layout.addWidget(last_page_btn)
        
        pagination_layout.addSpacing(20)
        
        # Total count label
        total_terms_label = QLabel("(0 terms total)")
        total_terms_label.setStyleSheet("color: #666;")
        pagination_layout.addWidget(total_terms_label)
        
        pagination_layout.addStretch()
        right_layout.addLayout(pagination_layout)
        
        # Terms table - columns: Source, Target, Priority, Domain, Notes, Project, Client, Forbidden, Delete
        terms_table = QTableWidget()
        terms_table.setColumnCount(9)
        terms_table.setHorizontalHeaderLabels(["Source Term", "Target Term", "Priority", "Domain", "Notes", "Project", "Client", "Forbidden", ""])
        terms_table.horizontalHeader().setStretchLastSection(False)
        terms_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)  # Source
        terms_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)  # Target
        terms_table.setColumnWidth(2, 60)   # Priority
        terms_table.setColumnWidth(3, 100)  # Domain
        terms_table.setColumnWidth(4, 120)  # Notes
        terms_table.setColumnWidth(5, 100)  # Project
        terms_table.setColumnWidth(6, 100)  # Client
        terms_table.setColumnWidth(7, 70)   # Forbidden
        terms_table.setColumnWidth(8, 30)   # Delete button
        terms_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        right_layout.addWidget(terms_table, stretch=1)
        
        # Store current termbase ID for the terms panel
        current_terms_tb_id = [None]  # Use list to allow modification in nested function
        
        def filter_terms_table(search_text):
            """Filter terms table rows by source or target term"""
            search_text = search_text.lower().strip()
            terms_filter_text[0] = search_text
            # When filter changes, reset to page 0 and reload
            terms_current_page[0] = 0
            if current_terms_tb_id[0]:
                load_terms_page()
        
        terms_search_box.textChanged.connect(filter_terms_table)
        
        def update_pagination_ui():
            """Update pagination controls based on current state"""
            page_size = terms_page_size[0]
            total = terms_total_count[0]
            current = terms_current_page[0]
            
            if page_size == 0:  # "All" selected
                total_pages = 1
            else:
                total_pages = max(1, (total + page_size - 1) // page_size)
            
            page_info_label.setText(f"Page {current + 1} of {total_pages}")
            total_terms_label.setText(f"({total:,} terms total)")
            
            # Enable/disable navigation buttons
            first_page_btn.setEnabled(current > 0)
            prev_page_btn.setEnabled(current > 0)
            next_page_btn.setEnabled(current < total_pages - 1)
            last_page_btn.setEnabled(current < total_pages - 1)
        
        def load_terms_page():
            """Load current page of terms from the database"""
            if current_terms_tb_id[0] is None:
                return
            
            terms_table.setRowCount(0)
            terms_table.blockSignals(True)
            
            try:
                tb_id = current_terms_tb_id[0]
                filter_text = terms_filter_text[0]
                page_size = terms_page_size[0]
                offset = terms_current_page[0] * page_size if page_size > 0 else 0
                
                # Build query with optional filter
                if filter_text:
                    # Count filtered results
                    self.db_manager.cursor.execute(
                        """SELECT COUNT(*) FROM termbase_terms 
                           WHERE termbase_id = CAST(? AS TEXT) 
                           AND (LOWER(source_term) LIKE ? OR LOWER(target_term) LIKE ?)""",
                        (tb_id, f'%{filter_text}%', f'%{filter_text}%')
                    )
                    terms_total_count[0] = self.db_manager.cursor.fetchone()[0]
                    
                    # Get filtered page
                    if page_size > 0:
                        self.db_manager.cursor.execute(
                            """SELECT id, source_term, target_term, priority, domain, notes, project, client, forbidden 
                               FROM termbase_terms 
                               WHERE termbase_id = CAST(? AS TEXT) 
                               AND (LOWER(source_term) LIKE ? OR LOWER(target_term) LIKE ?)
                               ORDER BY source_term LIMIT ? OFFSET ?""",
                            (tb_id, f'%{filter_text}%', f'%{filter_text}%', page_size, offset)
                        )
                    else:  # All
                        self.db_manager.cursor.execute(
                            """SELECT id, source_term, target_term, priority, domain, notes, project, client, forbidden 
                               FROM termbase_terms 
                               WHERE termbase_id = CAST(? AS TEXT) 
                               AND (LOWER(source_term) LIKE ? OR LOWER(target_term) LIKE ?)
                               ORDER BY source_term""",
                            (tb_id, f'%{filter_text}%', f'%{filter_text}%')
                        )
                else:
                    # Count all results
                    self.db_manager.cursor.execute(
                        "SELECT COUNT(*) FROM termbase_terms WHERE termbase_id = CAST(? AS TEXT)",
                        (tb_id,)
                    )
                    terms_total_count[0] = self.db_manager.cursor.fetchone()[0]
                    
                    # Get page
                    if page_size > 0:
                        self.db_manager.cursor.execute(
                            """SELECT id, source_term, target_term, priority, domain, notes, project, client, forbidden 
                               FROM termbase_terms WHERE termbase_id = CAST(? AS TEXT) 
                               ORDER BY source_term LIMIT ? OFFSET ?""",
                            (tb_id, page_size, offset)
                        )
                    else:  # All
                        self.db_manager.cursor.execute(
                            """SELECT id, source_term, target_term, priority, domain, notes, project, client, forbidden 
                               FROM termbase_terms WHERE termbase_id = CAST(? AS TEXT) ORDER BY source_term""",
                            (tb_id,)
                        )
                
                terms = self.db_manager.cursor.fetchall()
                terms_table.setRowCount(len(terms))
                
                for row, term in enumerate(terms):
                    term_id, source, target, priority, domain, notes, project, client, forbidden = term
                    
                    # Source term (editable)
                    source_item = QTableWidgetItem(source or "")
                    source_item.setData(Qt.ItemDataRole.UserRole, term_id)
                    terms_table.setItem(row, 0, source_item)
                    
                    # Target term (editable)
                    target_item = QTableWidgetItem(target or "")
                    terms_table.setItem(row, 1, target_item)
                    
                    # Priority (editable)
                    priority_item = QTableWidgetItem(str(priority) if priority is not None else "50")
                    terms_table.setItem(row, 2, priority_item)
                    
                    # Domain (editable)
                    domain_item = QTableWidgetItem(domain or "")
                    terms_table.setItem(row, 3, domain_item)
                    
                    # Notes (editable)
                    notes_item = QTableWidgetItem(notes or "")
                    terms_table.setItem(row, 4, notes_item)
                    
                    # Project (editable)
                    project_item = QTableWidgetItem(project or "")
                    terms_table.setItem(row, 5, project_item)
                    
                    # Client (editable)
                    client_item = QTableWidgetItem(client or "")
                    terms_table.setItem(row, 6, client_item)
                    
                    # Forbidden (checkbox)
                    forbidden_checkbox = CheckmarkCheckBox()
                    forbidden_checkbox.setChecked(bool(forbidden))
                    forbidden_checkbox.setToolTip("Mark term as forbidden (do not use)")
                    forbidden_checkbox.toggled.connect(lambda checked, tid=term_id: save_forbidden_state(tid, checked))
                    terms_table.setCellWidget(row, 7, forbidden_checkbox)
                    
                    # Delete button
                    delete_btn = QPushButton("üóë")
                    delete_btn.setFixedSize(24, 24)
                    delete_btn.setToolTip("Delete this term")
                    delete_btn.setStyleSheet("QPushButton { border: none; } QPushButton:hover { background-color: #ffcccc; }")
                    delete_btn.clicked.connect(lambda checked, tid=term_id: delete_term(tid))
                    terms_table.setCellWidget(row, 8, delete_btn)
                
                update_pagination_ui()
                
            except Exception as e:
                self.log(f"‚ö†Ô∏è Error loading terms: {e}")
            finally:
                terms_table.blockSignals(False)
        
        def load_terms_for_termbase(tb_id, tb_name):
            """Load terms from selected termbase into the terms table (resets to page 1)"""
            current_terms_tb_id[0] = tb_id
            terms_current_page[0] = 0  # Reset to first page
            terms_filter_text[0] = ''  # Clear filter
            terms_search_box.clear()  # Clear search box
            selected_tb_label.setText(f"<b>{tb_name}</b>")
            selected_tb_label.setStyleSheet("color: #1976d2; font-weight: bold;")
            
            load_terms_page()
            self.log(f"üìù Loaded {terms_total_count[0]:,} terms from termbase '{tb_name}'")
        
        # Pagination button handlers
        def go_first_page():
            terms_current_page[0] = 0
            load_terms_page()
        
        def go_prev_page():
            if terms_current_page[0] > 0:
                terms_current_page[0] -= 1
                load_terms_page()
        
        def go_next_page():
            page_size = terms_page_size[0]
            if page_size > 0:
                total_pages = (terms_total_count[0] + page_size - 1) // page_size
                if terms_current_page[0] < total_pages - 1:
                    terms_current_page[0] += 1
                    load_terms_page()
        
        def go_last_page():
            page_size = terms_page_size[0]
            if page_size > 0:
                total_pages = max(1, (terms_total_count[0] + page_size - 1) // page_size)
                terms_current_page[0] = total_pages - 1
                load_terms_page()
        
        def on_page_size_changed(text):
            if text == "All":
                terms_page_size[0] = 0
            else:
                terms_page_size[0] = int(text)
            terms_current_page[0] = 0  # Reset to first page
            load_terms_page()
        
        first_page_btn.clicked.connect(go_first_page)
        prev_page_btn.clicked.connect(go_prev_page)
        next_page_btn.clicked.connect(go_next_page)
        last_page_btn.clicked.connect(go_last_page)
        page_size_combo.currentTextChanged.connect(on_page_size_changed)

        def save_forbidden_state(term_id, forbidden):
            """Save the forbidden state of a term"""
            try:
                self.db_manager.cursor.execute(
                    "UPDATE termbase_terms SET forbidden = ? WHERE id = ?",
                    (1 if forbidden else 0, term_id)
                )
                self.db_manager.connection.commit()
                # Clear termbase cache
                with self.termbase_cache_lock:
                    self.termbase_cache.clear()
            except Exception as e:
                self.log(f"‚ö†Ô∏è Error saving forbidden state: {e}")
        
        def delete_term(term_id):
            """Delete a term from the termbase"""
            reply = QMessageBox.question(
                self, "Delete Term",
                "Are you sure you want to delete this term?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                try:
                    self.db_manager.cursor.execute("DELETE FROM termbase_terms WHERE id = ?", (term_id,))
                    self.db_manager.connection.commit()
                    self.log(f"üóëÔ∏è Deleted term {term_id}")
                    # Reload terms
                    if current_terms_tb_id[0]:
                        # Get current termbase name from table
                        for row in range(termbase_table.rowCount()):
                            name_item = termbase_table.item(row, 1)
                            if name_item and name_item.data(Qt.ItemDataRole.UserRole) == current_terms_tb_id[0]:
                                load_terms_for_termbase(current_terms_tb_id[0], name_item.text())
                                break
                    # Also refresh termbase list to update term count
                    refresh_termbase_list()
                    # Clear termbase cache
                    with self.termbase_cache_lock:
                        self.termbase_cache.clear()
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Failed to delete term: {e}")
        
        def save_term_edit(row, column):
            """Save edited term to database"""
            if current_terms_tb_id[0] is None:
                return
            
            # Skip columns that have widgets (Forbidden=7, Delete=8)
            if column in (7, 8):
                return
            
            source_item = terms_table.item(row, 0)
            if not source_item:
                return
            
            term_id = source_item.data(Qt.ItemDataRole.UserRole)
            if not term_id:
                return
            
            source = terms_table.item(row, 0).text() if terms_table.item(row, 0) else ""
            target = terms_table.item(row, 1).text() if terms_table.item(row, 1) else ""
            priority_text = terms_table.item(row, 2).text() if terms_table.item(row, 2) else "50"
            domain = terms_table.item(row, 3).text() if terms_table.item(row, 3) else ""
            notes = terms_table.item(row, 4).text() if terms_table.item(row, 4) else ""
            project = terms_table.item(row, 5).text() if terms_table.item(row, 5) else ""
            client = terms_table.item(row, 6).text() if terms_table.item(row, 6) else ""
            
            # Parse priority as integer
            try:
                priority = int(priority_text) if priority_text else 50
            except ValueError:
                priority = 50
            
            try:
                self.db_manager.cursor.execute(
                    """UPDATE termbase_terms 
                       SET source_term = ?, target_term = ?, priority = ?, domain = ?, notes = ?, project = ?, client = ? 
                       WHERE id = ?""",
                    (source, target, priority, domain, notes, project, client, term_id)
                )
                self.db_manager.connection.commit()
                # Clear termbase cache
                with self.termbase_cache_lock:
                    self.termbase_cache.clear()
            except Exception as e:
                self.log(f"‚ö†Ô∏è Error saving term: {e}")
        
        terms_table.cellChanged.connect(save_term_edit)
        
        # Add new term button
        terms_btn_layout = QHBoxLayout()
        add_term_btn = QPushButton("+ Add Term")
        add_term_btn.setEnabled(False)
        
        def add_new_term():
            """Add a new empty term to the current termbase"""
            if current_terms_tb_id[0] is None:
                return
            
            try:
                # Don't specify id - let SQLite auto-generate it (INTEGER PRIMARY KEY AUTOINCREMENT)
                self.db_manager.cursor.execute(
                    """INSERT INTO termbase_terms (termbase_id, source_term, target_term, priority, domain, notes, project, client, forbidden) 
                       VALUES (CAST(? AS TEXT), '', '', 50, '', '', '', '', 0)""",
                    (current_terms_tb_id[0],)
                )
                self.db_manager.connection.commit()
                
                # Reload terms and refresh termbase list
                for row in range(termbase_table.rowCount()):
                    name_item = termbase_table.item(row, 1)
                    if name_item and name_item.data(Qt.ItemDataRole.UserRole) == current_terms_tb_id[0]:
                        load_terms_for_termbase(current_terms_tb_id[0], name_item.text())
                        break
                refresh_termbase_list()
                
                # Select the new row for editing
                terms_table.setCurrentCell(terms_table.rowCount() - 1, 0)
                terms_table.editItem(terms_table.item(terms_table.rowCount() - 1, 0))
                
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to add term: {e}")
        
        add_term_btn.clicked.connect(add_new_term)
        terms_btn_layout.addWidget(add_term_btn)
        terms_btn_layout.addStretch()
        right_layout.addLayout(terms_btn_layout)
        
        # Connect termbase table selection to load terms
        def on_termbase_selected():
            """Handle termbase selection change"""
            selected_rows = termbase_table.selectionModel().selectedRows()
            if selected_rows:
                row = selected_rows[0].row()
                name_item = termbase_table.item(row, 1)
                if name_item:
                    tb_id = name_item.data(Qt.ItemDataRole.UserRole)
                    tb_name = name_item.text()
                    load_terms_for_termbase(tb_id, tb_name)
                    add_term_btn.setEnabled(True)
        
        self._on_termbase_selected = on_termbase_selected  # Store for external access
        termbase_table.itemSelectionChanged.connect(on_termbase_selected)
        
        # Populate termbase list
        def refresh_termbase_list():
            # CRITICAL FIX: Get project_id dynamically, not from closure
            # Use 0 (global) when no project is loaded for Superlookup support
            current_proj = self.current_project if hasattr(self, 'current_project') else None
            refresh_project_id = current_proj.id if (current_proj and hasattr(current_proj, 'id')) else 0  # 0 = global
            
            self.log(f"üìã Refreshing termbase list (project_id: {refresh_project_id})")
            termbases = termbase_mgr.get_all_termbases()
            self.log(f"  Found {len(termbases)} termbase(s) in database")
            termbase_table.setRowCount(len(termbases))
            
            # Count active readable termbases (for priority range)
            num_active = sum(1 for tb in termbases 
                           if termbase_mgr.is_termbase_active(tb['id'], refresh_project_id))
            
            for row, tb in enumerate(termbases):
                # Check if readable (activated) for current project or global (0)
                is_readable = termbase_mgr.is_termbase_active(tb['id'], refresh_project_id)
                # Check if writable (not read-only)
                is_writable = not tb.get('read_only', True)  # Default to True (read-only) if not set
                
                # Get manual priority from termbase_activation table
                priority = termbase_mgr.get_termbase_priority(tb['id'], refresh_project_id) if is_readable else None
                is_project_tb = (priority == 1)  # Priority #1 = project termbase
                
                # Type (Project/Background) - auto-determined by priority
                if is_project_tb:
                    type_label = QLabel("üìå Project")
                    type_label.setStyleSheet("color: #FF69B4; font-weight: bold;")  # Pink
                else:
                    type_label = QLabel("Background")
                    type_label.setStyleSheet("color: #666;")
                termbase_table.setCellWidget(row, 0, type_label)
                
                # Name (bold if readable, pink if project termbase)
                name_item = QTableWidgetItem(tb['name'])
                name_item.setData(Qt.ItemDataRole.UserRole, tb['id'])
                if is_readable:
                    font = name_item.font()
                    font.setBold(True)
                    name_item.setFont(font)
                if is_project_tb:
                    name_item.setForeground(QColor("#FF69B4"))  # Pink for project termbase
                termbase_table.setItem(row, 1, name_item)
                
                # Languages
                langs = f"{tb['source_lang'] or '?'} ‚Üí {tb['target_lang'] or '?'}"
                termbase_table.setItem(row, 2, QTableWidgetItem(langs))
                
                # Term count
                try:
                    self.db_manager.cursor.execute("SELECT COUNT(*) FROM termbase_terms WHERE termbase_id = CAST(? AS TEXT)", (tb['id'],))
                    live_count = self.db_manager.cursor.fetchone()[0]
                except Exception as e:
                    live_count = tb.get('term_count', 0)
                termbase_table.setItem(row, 3, QTableWidgetItem(str(live_count)))
                
                # Read checkbox (green)
                read_checkbox = CheckmarkCheckBox()
                read_checkbox.setChecked(is_readable)
                read_checkbox.setToolTip("Read: Glossary is used for terminology matching")
                
                def on_read_toggle(checked, tb_id=tb['id'], row_idx=row):
                    # Use 0 (global) when no project is loaded - allows Superlookup to work
                    curr_proj = self.current_project if hasattr(self, 'current_project') else None
                    curr_proj_id = curr_proj.id if (curr_proj and hasattr(curr_proj, 'id')) else 0  # 0 = global

                    if checked:
                        termbase_mgr.activate_termbase(tb_id, curr_proj_id)
                    else:
                        termbase_mgr.deactivate_termbase(tb_id, curr_proj_id)

                    # Clear cache and rebuild in-memory index (v1.9.182)
                    with self.termbase_cache_lock:
                        self.termbase_cache.clear()
                    self._build_termbase_index()  # Rebuild index with new activation state
                    refresh_termbase_list()
                
                read_checkbox.toggled.connect(on_read_toggle)
                termbase_table.setCellWidget(row, 4, read_checkbox)
                
                # Write checkbox (blue)
                write_checkbox = BlueCheckmarkCheckBox()
                write_checkbox.setChecked(is_writable)
                write_checkbox.setToolTip("Write: Glossary is updated with new terms")
                
                def on_write_toggle(checked, tb_id=tb['id'], row_idx=row):
                    # Invert logic: checked = writable, so set read_only to NOT checked
                    success = termbase_mgr.set_termbase_read_only(tb_id, not checked)
                    if success:
                        status = "writable" if checked else "read-only"
                        self.log(f"‚úÖ Termbase {tb_id} set to {status}")
                    else:
                        # Revert on failure
                        sender = termbase_table.cellWidget(row_idx, 5)
                        if sender:
                            sender.blockSignals(True)
                            sender.setChecked(not checked)
                            sender.blockSignals(False)
                
                write_checkbox.toggled.connect(on_write_toggle)
                termbase_table.setCellWidget(row, 5, write_checkbox)
                
                # Priority (dropdown for readable termbases)
                if is_readable and refresh_project_id and num_active > 0:
                    priority_combo = QComboBox()
                    
                    # Populate dropdown with available priorities (1 to num_active)
                    for p in range(1, num_active + 1):
                        priority_combo.addItem(f"#{p}", p)
                    
                    # Set current priority
                    if priority:
                        priority_combo.setCurrentIndex(priority - 1)
                    else:
                        priority_combo.setCurrentIndex(0)
                    
                    # Pink styling for priority #1
                    if priority == 1:
                        priority_combo.setStyleSheet("QComboBox { color: #FF69B4; font-weight: bold; }")
                        priority_combo.setToolTip("Priority #1 - Project Glossary (highest priority)\nSelect different priority from dropdown")
                    else:
                        priority_combo.setToolTip(f"Priority #{priority} (1=highest, {num_active}=lowest)\nMultiple glossaries can share same priority.")
                    
                    def on_priority_change(index, tb_id=tb['id'], row_idx=row):
                        # Get selected priority from combo box
                        combo = termbase_table.cellWidget(row_idx, 6)
                        if not combo:
                            return
                        new_priority = combo.currentData()
                        
                        self.log(f"üîÑ Priority change triggered: TB {tb_id} ‚Üí #{new_priority}")
                        curr_proj = self.current_project if hasattr(self, 'current_project') else None
                        curr_proj_id = curr_proj.id if (curr_proj and hasattr(curr_proj, 'id')) else None
                        if not curr_proj_id:
                            self.log(f"‚ö†Ô∏è No project loaded, cannot change priority")
                            return
                        
                        self.log(f"üîÑ Setting priority for TB {tb_id}, Project {curr_proj_id}")
                        success = termbase_mgr.set_termbase_priority(tb_id, curr_proj_id, new_priority)
                        if success:
                            self.log(f"‚úÖ Successfully set termbase {tb_id} priority to #{new_priority}")
                            # Update styling based on new priority
                            sender = termbase_table.cellWidget(row_idx, 6)
                            if sender:
                                if new_priority == 1:
                                    sender.setStyleSheet("QComboBox { color: #FF69B4; font-weight: bold; }")
                                    sender.setToolTip("Priority #1 - Project Glossary (highest priority)\nSelect different priority from dropdown")
                                else:
                                    sender.setStyleSheet("")
                                    sender.setToolTip(f"Priority #{new_priority} (1=highest, {num_active}=lowest)\nMultiple glossaries can share same priority.")
                            
                            # Update Type column and styling for all rows
                            for r in range(termbase_table.rowCount()):
                                type_widget = termbase_table.cellWidget(r, 0)
                                priority_widget = termbase_table.cellWidget(r, 6)
                                if type_widget and priority_widget and isinstance(priority_widget, QComboBox):
                                    # Block signals during update to prevent recursion
                                    priority_widget.blockSignals(True)
                                    current_priority = priority_widget.currentData()
                                    name_item = termbase_table.item(r, 1)
                                    
                                    # Update Type column
                                    if current_priority == 1:
                                        type_widget.setText("üìå Project")
                                        type_widget.setStyleSheet("color: #FF69B4; font-weight: bold;")
                                        if name_item:
                                            name_item.setForeground(QColor("#FF69B4"))
                                        # Update combobox styling for #1
                                        priority_widget.setStyleSheet("QComboBox { color: #FF69B4; font-weight: bold; }")
                                        priority_widget.setToolTip("Priority #1 - Project Glossary (highest priority)\nSelect different priority from dropdown")
                                    else:
                                        type_widget.setText("Background")
                                        type_widget.setStyleSheet("color: #666;")
                                        if name_item:
                                            name_item.setForeground(QColor("#000"))
                                        # Update combobox styling for non-#1
                                        priority_widget.setStyleSheet("")
                                        priority_widget.setToolTip(f"Priority #{current_priority} (1=highest, {num_active}=lowest)\nMultiple glossaries can share same priority.")
                                    
                                    # Unblock signals after update
                                    priority_widget.blockSignals(False)
                            
                            # Clear cache for termbase matching (once, outside loop)
                            with self.termbase_cache_lock:
                                self.termbase_cache.clear()
                    
                    priority_combo.currentIndexChanged.connect(on_priority_change)
                    termbase_table.setCellWidget(row, 6, priority_combo)
                else:
                    # Non-readable termbase: show dash
                    priority_item = QTableWidgetItem("‚Äî")
                    priority_item.setForeground(QColor("#999"))
                    priority_item.setToolTip("No priority - glossary not readable")
                    priority_item.setFlags(priority_item.flags() & ~Qt.ItemFlag.ItemIsEditable)
                    termbase_table.setItem(row, 6, priority_item)

                # AI checkbox (purple/orange) - whether to inject terms into LLM prompts
                ai_enabled = termbase_mgr.get_termbase_ai_inject(tb['id'])
                ai_checkbox = OrangeCheckmarkCheckBox()
                ai_checkbox.setChecked(ai_enabled)
                ai_checkbox.setToolTip("AI: Send glossary terms to LLM with translation prompts")

                def on_ai_toggle(checked, tb_id=tb['id'], tb_name=tb['name']):
                    if checked:
                        # Show warning when enabling
                        from PyQt6.QtWidgets import QMessageBox
                        msg = QMessageBox()
                        msg.setWindowTitle("Enable AI Injection")
                        msg.setText(f"Enable AI injection for '{tb_name}'?")
                        msg.setInformativeText(
                            "When enabled, ALL terms from this glossary will be sent to the LLM "
                            "with every translation request.\n\n"
                            "This helps the AI consistently use your preferred terminology "
                            "throughout the translation.\n\n"
                            "Recommended for small, curated glossaries (< 500 terms)."
                        )
                        msg.setStandardButtons(QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
                        msg.setDefaultButton(QMessageBox.StandardButton.Yes)
                        if msg.exec() != QMessageBox.StandardButton.Yes:
                            # User cancelled - revert checkbox
                            sender = termbase_table.cellWidget(termbase_table.currentRow(), 7)
                            if sender:
                                sender.blockSignals(True)
                                sender.setChecked(False)
                                sender.blockSignals(False)
                            return
                    termbase_mgr.set_termbase_ai_inject(tb_id, checked)
                    self.log(f"{'‚úÖ Enabled' if checked else '‚ùå Disabled'} AI injection for glossary: {tb_name}")

                ai_checkbox.toggled.connect(on_ai_toggle)
                termbase_table.setCellWidget(row, 7, ai_checkbox)

            # Update header checkbox states based on current selection
            tb_read_header_checkbox.blockSignals(True)
            tb_write_header_checkbox.blockSignals(True)
            all_tb_read_checked = all(termbase_table.cellWidget(r, 4).isChecked() if termbase_table.cellWidget(r, 4) else False for r in range(termbase_table.rowCount())) if termbase_table.rowCount() > 0 else False
            all_tb_write_checked = all(termbase_table.cellWidget(r, 5).isChecked() if termbase_table.cellWidget(r, 5) else False for r in range(termbase_table.rowCount())) if termbase_table.rowCount() > 0 else False
            tb_read_header_checkbox.setChecked(all_tb_read_checked)
            tb_write_header_checkbox.setChecked(all_tb_write_checked)
            tb_read_header_checkbox.blockSignals(False)
            tb_write_header_checkbox.blockSignals(False)
        
        # Store callback as instance attribute so add_term_to_termbase can call it
        self.termbase_tab_refresh_callback = refresh_termbase_list
        
        refresh_termbase_list()
        left_layout.addWidget(termbase_table, stretch=1)
        
        # Button bar for left panel
        button_layout = QHBoxLayout()
        
        create_btn = QPushButton("+ Create New")
        create_btn.clicked.connect(lambda: self._show_create_termbase_dialog(termbase_mgr, refresh_termbase_list, project_id))
        button_layout.addWidget(create_btn)
        
        extract_btn = QPushButton("üîç Extract Terms")
        extract_btn.setToolTip("Extract terminology from project segments to create project glossary")
        extract_btn.setEnabled(project_id is not None)  # Only enabled when project is loaded
        extract_btn.clicked.connect(lambda: self._show_term_extraction_dialog(termbase_mgr, refresh_termbase_list, project_id))
        button_layout.addWidget(extract_btn)
        
        import_btn = QPushButton("üì• Import")
        import_btn.clicked.connect(lambda: self._import_termbase(termbase_mgr, termbase_table))
        button_layout.addWidget(import_btn)
        
        export_btn = QPushButton("üì§ Export")
        export_btn.clicked.connect(lambda: self._export_termbase(termbase_mgr, termbase_table))
        button_layout.addWidget(export_btn)
        
        delete_btn = QPushButton("üóëÔ∏è Delete")
        delete_btn.clicked.connect(lambda: self._delete_termbase(termbase_mgr, termbase_table, refresh_termbase_list))
        button_layout.addWidget(delete_btn)
        
        button_layout.addStretch()
        left_layout.addLayout(button_layout)
        
        # Add panels to splitter
        main_splitter.addWidget(left_panel)
        main_splitter.addWidget(right_panel)
        main_splitter.setSizes([500, 500])  # Equal initial split
        main_splitter.setStretchFactor(0, 1)
        main_splitter.setStretchFactor(1, 1)
        
        layout.addWidget(main_splitter, stretch=1)
        
        return tab
    
    def _show_create_termbase_dialog(self, termbase_mgr, refresh_callback, project_id):
        """Show dialog to create new glossary"""
        from modules.termbase_manager import TermbaseManager
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Create New Glossary")
        dialog.setMinimumWidth(400)
        
        layout = QFormLayout()
        
        # Name
        name_field = QLineEdit()
        layout.addRow("Glossary Name:", name_field)
        
        # Source language
        source_lang_field = QLineEdit()
        source_lang_field.setPlaceholderText("e.g., en, nl, de")
        layout.addRow("Source Language:", source_lang_field)
        
        # Target language
        target_lang_field = QLineEdit()
        target_lang_field.setPlaceholderText("e.g., en, nl, de")
        layout.addRow("Target Language:", target_lang_field)
        
        # Description
        desc_field = QTextEdit()
        desc_field.setMaximumHeight(80)
        layout.addRow("Description:", desc_field)
        
        # Scope - use styled checkboxes instead of radio buttons for better visibility
        scope_group = QButtonGroup()
        scope_group.setExclusive(True)  # Only one can be checked
        
        global_checkbox = BlueCheckmarkCheckBox("Global (all projects)")
        global_checkbox.setChecked(True)
        project_checkbox = PinkCheckmarkCheckBox("Project-specific")
        
        scope_group.addButton(global_checkbox, 0)
        scope_group.addButton(project_checkbox, 1)
        
        scope_layout = QHBoxLayout()
        scope_layout.addWidget(global_checkbox)
        scope_layout.addWidget(project_checkbox)
        layout.addRow("Scope:", scope_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        create_btn = QPushButton("Create")
        cancel_btn = QPushButton("Cancel")
        
        def create_termbase():
            name = name_field.text().strip()
            if not name:
                QMessageBox.warning(dialog, "Error", "Please enter a glossary name")
                return
            
            source_lang = source_lang_field.text().strip() or None
            target_lang = target_lang_field.text().strip() or None
            description = desc_field.toPlainText().strip()
            is_global = scope_group.checkedId() == 0
            
            tb_project_id = None if is_global else project_id
            
            tb_id = termbase_mgr.create_termbase(
                name=name,
                source_lang=source_lang,
                target_lang=target_lang,
                project_id=tb_project_id,
                description=description,
                is_global=is_global
            )
            
            if tb_id:
                self._play_sound_effect('glossary_created')
                QMessageBox.information(dialog, "Success", f"Glossary '{name}' created successfully!")
                refresh_callback()
                dialog.accept()
            else:
                QMessageBox.critical(dialog, "Error", "Failed to create glossary")
        
        create_btn.clicked.connect(create_termbase)
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(create_btn)
        button_layout.addWidget(cancel_btn)
        layout.addRow("", button_layout)
        
        dialog.setLayout(layout)
        dialog.exec()
    
    def _show_term_extraction_dialog(self, termbase_mgr, refresh_callback, project_id):
        """Show dialog to extract terms from project segments"""
        from modules.term_extractor import TermExtractor
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Extract Terms from Project")
        dialog.setMinimumWidth(800)
        dialog.setMinimumHeight(600)
        
        layout = QVBoxLayout()
        
        # Info label
        info_label = QLabel("Extract terminology from project source segments to create a project glossary.")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Source text section
        source_group = QGroupBox("Source Text")
        source_layout = QVBoxLayout()
        
        # Text source options
        source_type_layout = QHBoxLayout()
        use_project_radio = CheckmarkRadioButton("Use project segments")
        use_project_radio.setChecked(True)
        use_manual_radio = CheckmarkRadioButton("Paste text manually")
        
        source_type_layout.addWidget(use_project_radio)
        source_type_layout.addWidget(use_manual_radio)
        source_type_layout.addStretch()
        source_layout.addLayout(source_type_layout)
        
        # Manual text input
        text_input = QTextEdit()
        text_input.setPlaceholderText("Paste source text here...")
        text_input.setMaximumHeight(150)
        text_input.setEnabled(False)
        source_layout.addWidget(text_input)
        
        def on_source_type_changed():
            text_input.setEnabled(use_manual_radio.isChecked())
        
        use_project_radio.toggled.connect(on_source_type_changed)
        use_manual_radio.toggled.connect(on_source_type_changed)
        
        source_group.setLayout(source_layout)
        layout.addWidget(source_group)
        
        # Extraction parameters
        params_group = QGroupBox("Extraction Parameters")
        params_layout = QFormLayout()
        
        # Source language
        lang_combo = QComboBox()
        lang_combo.addItems(["en", "nl", "de", "fr", "es"])
        params_layout.addRow("Source Language:", lang_combo)
        
        # Min frequency
        freq_spin = QSpinBox()
        freq_spin.setMinimum(1)
        freq_spin.setMaximum(20)
        freq_spin.setValue(2)
        params_layout.addRow("Min Frequency:", freq_spin)
        
        # Max n-gram
        ngram_spin = QSpinBox()
        ngram_spin.setMinimum(1)
        ngram_spin.setMaximum(5)
        ngram_spin.setValue(3)
        params_layout.addRow("Max N-gram:", ngram_spin)
        
        # Max terms
        max_terms_spin = QSpinBox()
        max_terms_spin.setMinimum(10)
        max_terms_spin.setMaximum(1000)
        max_terms_spin.setValue(100)
        params_layout.addRow("Max Terms:", max_terms_spin)
        
        params_group.setLayout(params_layout)
        layout.addWidget(params_group)
        
        # Extract button
        extract_btn = QPushButton("üîç Extract Terms")
        extract_btn.setMaximumWidth(150)
        
        # Results table
        results_table = QTableWidget()
        results_table.setColumnCount(4)
        results_table.setHorizontalHeaderLabels(["Select", "Term", "Frequency", "Score"])
        results_table.horizontalHeader().setStretchLastSection(False)
        results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        results_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        results_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        results_table.setVisible(False)
        
        results_label = QLabel("Extracted terms will appear here")
        results_label.setVisible(False)
        
        layout.addWidget(extract_btn)
        layout.addWidget(results_label)
        layout.addWidget(results_table)
        
        extracted_terms = []
        
        def extract_terms():
            """Extract terms and populate results table"""
            # Get source text
            if use_project_radio.isChecked():
                # Get all source segments from current project
                if not self.current_project:
                    QMessageBox.warning(dialog, "Error", "No project is currently loaded")
                    return
                
                segments = []
                for i in range(self.grid_widget.grid.rowCount()):
                    source_widget = self.grid_widget.grid.cellWidget(i, self.grid_widget.source_col)
                    if source_widget:
                        text = source_widget.toPlainText().strip()
                        if text:
                            segments.append(text)
                
                if not segments:
                    QMessageBox.warning(dialog, "Error", "No source segments found in project")
                    return
                
                source_text = "\n".join(segments)
            else:
                source_text = text_input.toPlainText().strip()
                if not source_text:
                    QMessageBox.warning(dialog, "Error", "Please enter some text to analyze")
                    return
            
            # Extract terms
            try:
                extractor = TermExtractor(
                    source_lang=lang_combo.currentText(),
                    min_frequency=freq_spin.value(),
                    max_ngram=ngram_spin.value()
                )
                
                terms = extractor.extract_terms(source_text)
                
                # Limit to max terms
                terms = terms[:max_terms_spin.value()]
                
                if not terms:
                    QMessageBox.information(dialog, "No Terms", "No terms were extracted with the current parameters. Try lowering the minimum frequency.")
                    return
                
                # Store for later use
                nonlocal extracted_terms
                extracted_terms = terms
                
                # Populate table
                results_table.setRowCount(len(terms))
                for i, term in enumerate(terms):
                    # Checkbox
                    check_item = QTableWidgetItem()
                    check_item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)
                    check_item.setCheckState(Qt.CheckState.Checked)
                    results_table.setItem(i, 0, check_item)
                    
                    # Term
                    results_table.setItem(i, 1, QTableWidgetItem(term['term']))
                    
                    # Frequency
                    freq_item = QTableWidgetItem(str(term['frequency']))
                    freq_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                    results_table.setItem(i, 2, freq_item)
                    
                    # Score
                    score_item = QTableWidgetItem(f"{term['score']:.2f}")
                    score_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                    results_table.setItem(i, 3, score_item)
                
                results_table.setVisible(True)
                results_label.setText(f"Extracted {len(terms)} terms (select terms to add):")
                results_label.setVisible(True)
                
                self.log(f"‚úì Extracted {len(terms)} terms from project")
                
            except Exception as e:
                QMessageBox.critical(dialog, "Error", f"Failed to extract terms: {str(e)}")
                self.log(f"‚úó Term extraction failed: {e}")
        
        extract_btn.clicked.connect(extract_terms)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        create_btn = QPushButton("Create Project Glossary")
        create_btn.setToolTip("Create a new project glossary with selected terms")
        
        cancel_btn = QPushButton("Cancel")
        
        def create_project_termbase():
            """Create project termbase with selected terms"""
            if not extracted_terms:
                QMessageBox.warning(dialog, "Error", "Please extract terms first")
                return
            
            # Get selected terms
            selected = []
            for i in range(results_table.rowCount()):
                check_item = results_table.item(i, 0)
                if check_item and check_item.checkState() == Qt.CheckState.Checked:
                    selected.append(extracted_terms[i])
            
            if not selected:
                QMessageBox.warning(dialog, "Error", "Please select at least one term")
                return
            
            # Ask for termbase name
            name, ok = QInputDialog.getText(
                dialog,
                "Termbase Name",
                "Enter name for project termbase:",
                text=f"{self.current_project.get('name', 'Project')} Terminology"
            )
            
            if not ok or not name.strip():
                return
            
            # Create termbase
            source_lang = lang_combo.currentText()
            tb_id = termbase_mgr.create_termbase(
                name=name.strip(),
                source_lang=source_lang,
                target_lang=None,  # Source-only termbase
                project_id=project_id,
                description=f"Extracted terminology from project segments ({len(selected)} terms)",
                is_global=False,
                is_project_termbase=True
            )
            
            if not tb_id:
                QMessageBox.critical(dialog, "Error", "Failed to create glossary. There may already be a project glossary for this project.")
                return
            
            # Add terms (source only, target = empty string)
            added = 0
            for term in selected:
                success = termbase_mgr.add_term(
                    termbase_id=tb_id,
                    source_term=term['term'],
                    target_term="",  # Empty target for source-only
                    priority=50
                )
                if success:
                    added += 1
            
            self.log(f"‚úì Created project termbase '{name}' with {added} terms")
            QMessageBox.information(
                dialog,
                "Success",
                f"Project termbase '{name}' created with {added} terms!"
            )
            
            # Clear cache and refresh
            with self.termbase_cache_lock:
                self.termbase_cache.clear()
            refresh_callback()
            dialog.accept()
        
        create_btn.clicked.connect(create_project_termbase)
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(create_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)
        
        dialog.setLayout(layout)
        dialog.exec()
    
    def _show_termbase_context_menu(self, pos, termbase_table, termbase_mgr, refresh_callback):
        """Show context menu for termbase table with Rename and Delete options"""
        # Get the row under the cursor
        item = termbase_table.itemAt(pos)
        if not item:
            return
        
        row = item.row()
        name_item = termbase_table.item(row, 1)
        if not name_item:
            return
        
        tb_name = name_item.text()
        tb_id = name_item.data(Qt.ItemDataRole.UserRole)
        
        menu = QMenu(self)
        
        # Rename action
        rename_action = QAction("‚úèÔ∏è Rename Glossary", self)
        rename_action.triggered.connect(
            lambda: self._rename_termbase_dialog(tb_id, tb_name, termbase_mgr, refresh_callback)
        )
        menu.addAction(rename_action)
        
        menu.addSeparator()
        
        # Delete action
        delete_action = QAction("üóëÔ∏è Delete Glossary", self)
        delete_action.triggered.connect(
            lambda: self._delete_termbase(termbase_mgr, termbase_table, refresh_callback)
        )
        menu.addAction(delete_action)
        
        menu.exec(termbase_table.viewport().mapToGlobal(pos))
    
    def _rename_termbase_dialog(self, termbase_id, current_name, termbase_mgr, refresh_callback):
        """Show dialog to rename a termbase"""
        from PyQt6.QtWidgets import QInputDialog
        
        new_name, ok = QInputDialog.getText(
            self,
            "Rename Glossary",
            f"Enter new name for '{current_name}':",
            text=current_name
        )
        
        if ok and new_name and new_name.strip():
            new_name = new_name.strip()
            if new_name != current_name:
                if termbase_mgr.rename_termbase(termbase_id, new_name):
                    self.log(f"‚úì Renamed glossary '{current_name}' to '{new_name}'")
                    QMessageBox.information(self, "Success", f"Glossary renamed to '{new_name}'")
                    # Clear cache and refresh
                    with self.termbase_cache_lock:
                        self.termbase_cache.clear()
                    refresh_callback()
                else:
                    QMessageBox.critical(self, "Error", "Failed to rename glossary")
    
    def _delete_termbase(self, termbase_mgr, termbase_table, refresh_callback):
        """Delete selected termbase"""
        selected_row = termbase_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a glossary to delete")
            return
        
        # Get termbase info from Name column (column 1 - has ID stored in UserRole)
        name_item = termbase_table.item(selected_row, 1)
        if not name_item:
            QMessageBox.warning(self, "Error", "Could not read glossary information")
            return
        
        tb_name = name_item.text()
        termbase_id = name_item.data(Qt.ItemDataRole.UserRole)
        
        if not termbase_id:
            QMessageBox.warning(self, "Error", "Could not find glossary ID")
            return
        
        # Confirm deletion
        reply = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete glossary '{tb_name}'?\n\nThis will permanently delete all terms in this glossary.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            # Use the termbase ID we got from row data
            if termbase_id:
                try:
                    # Delete from database
                    cursor = self.db_manager.cursor
                    cursor.execute("DELETE FROM termbase_terms WHERE termbase_id = ?", (termbase_id,))
                    cursor.execute("DELETE FROM termbase_activation WHERE termbase_id = ?", (termbase_id,))
                    cursor.execute("DELETE FROM termbases WHERE id = ?", (termbase_id,))
                    self.db_manager.connection.commit()
                    
                    self.log(f"‚úì Deleted glossary: {tb_name}")
                    QMessageBox.information(self, "Success", f"Glossary '{tb_name}' has been deleted")
                    
                    # Clear cache and refresh
                    with self.termbase_cache_lock:
                        self.termbase_cache.clear()
                    refresh_callback()
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to delete glossary: {str(e)}")
                    self.log(f"‚úó Error deleting termbase: {e}")
    
    def _refresh_termbase_table(self, termbase_table, termbase_mgr):
        """Refresh termbase table to show updated term counts"""
        # Get current project ID
        current_proj = self.current_project if hasattr(self, 'current_project') else None
        project_id = current_proj.id if (current_proj and hasattr(current_proj, 'id')) else 0
        
        # Update term counts for each row
        for row in range(termbase_table.rowCount()):
            name_item = termbase_table.item(row, 1)
            if name_item:
                tb_id = name_item.data(Qt.ItemDataRole.UserRole)
                if tb_id:
                    try:
                        self.db_manager.cursor.execute(
                            "SELECT COUNT(*) FROM termbase_terms WHERE termbase_id = CAST(? AS TEXT)", 
                            (tb_id,)
                        )
                        term_count = self.db_manager.cursor.fetchone()[0]
                        count_item = termbase_table.item(row, 3)
                        if count_item:
                            count_item.setText(str(term_count))
                    except Exception as e:
                        self.log(f"‚ö† Error updating term count: {e}")
    
    def _import_termbase(self, termbase_mgr, termbase_table):
        """Import terms into selected termbase from TSV file"""
        selected_row = termbase_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a glossary to import into")
            return
        
        # Get termbase info from Name column (column 1 - has ID stored in UserRole)
        name_item = termbase_table.item(selected_row, 1)
        if not name_item:
            QMessageBox.warning(self, "Error", "Could not read glossary information")
            return
        
        tb_name = name_item.text()
        termbase_id = name_item.data(Qt.ItemDataRole.UserRole)
        
        if not termbase_id:
            QMessageBox.warning(self, "Error", "Could not find glossary ID")
            return
        
        # File dialog
        from PyQt6.QtWidgets import QFileDialog
        filepath, _ = QFileDialog.getOpenFileName(
            self,
            "Import Glossary",
            "",
            "TSV Files (*.tsv *.txt);;All Files (*.*)"
        )
        
        if not filepath:
            return
        
        # Show options dialog
        options_dialog = QDialog(self)
        options_dialog.setWindowTitle("Import Options")
        options_dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(options_dialog)
        
        # Info
        info_label = QLabel(f"Importing into glossary: <b>{tb_name}</b>")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Duplicate handling
        dup_group = QGroupBox("Duplicate Handling")
        dup_layout = QVBoxLayout()
        
        skip_radio = CheckmarkRadioButton("Skip duplicates (keep existing terms)")
        skip_radio.setChecked(True)
        update_radio = CheckmarkRadioButton("Update duplicates (overwrite existing terms)")
        
        dup_layout.addWidget(skip_radio)
        dup_layout.addWidget(update_radio)
        dup_group.setLayout(dup_layout)
        layout.addWidget(dup_group)
        
        # Buttons
        button_box = QHBoxLayout()
        button_box.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(options_dialog.reject)
        button_box.addWidget(cancel_btn)
        
        import_btn = QPushButton("Import")
        import_btn.setStyleSheet("font-weight: bold; background-color: #4CAF50; color: white; padding: 8px 20px; border: none; outline: none;")
        import_btn.clicked.connect(options_dialog.accept)
        button_box.addWidget(import_btn)
        
        layout.addLayout(button_box)
        
        if options_dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Create progress dialog with scrolling log
        progress_dialog = QDialog(self)
        progress_dialog.setWindowTitle("Importing Glossary")
        progress_dialog.setMinimumSize(600, 400)
        progress_dialog.setModal(True)
        
        progress_layout = QVBoxLayout(progress_dialog)
        
        # Header info
        header_label = QLabel(f"<b>üì• Importing into: {tb_name}</b>")
        header_label.setStyleSheet("font-size: 12pt; padding: 5px;")
        progress_layout.addWidget(header_label)
        
        # File info
        import os
        file_info = QLabel(f"File: {os.path.basename(filepath)}")
        file_info.setStyleSheet("color: #666; padding: 2px 5px;")
        progress_layout.addWidget(file_info)
        
        # Progress bar
        progress_bar = QProgressBar()
        progress_bar.setMinimum(0)
        progress_bar.setMaximum(100)
        progress_bar.setValue(0)
        progress_bar.setTextVisible(True)
        progress_layout.addWidget(progress_bar)
        
        # Stats labels row
        stats_layout = QHBoxLayout()
        imported_label = QLabel("‚úÖ Imported: 0")
        imported_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        skipped_label = QLabel("‚è≠Ô∏è Skipped: 0")
        skipped_label.setStyleSheet("color: #FF9800;")
        errors_label = QLabel("‚ùå Errors: 0")
        errors_label.setStyleSheet("color: #F44336;")
        stats_layout.addWidget(imported_label)
        stats_layout.addWidget(skipped_label)
        stats_layout.addWidget(errors_label)
        stats_layout.addStretch()
        progress_layout.addLayout(stats_layout)
        
        # Scrolling log area
        log_label = QLabel("Import Log:")
        log_label.setStyleSheet("font-weight: bold; padding-top: 10px;")
        progress_layout.addWidget(log_label)
        
        log_text = QTextEdit()
        log_text.setReadOnly(True)
        log_text.setFont(QFont("Consolas", 9))
        log_text.setStyleSheet("background-color: #1e1e1e; color: #d4d4d4; border: 1px solid #555;")
        progress_layout.addWidget(log_text)
        
        # Close button (initially disabled)
        close_btn = QPushButton("Close")
        close_btn.setEnabled(False)
        close_btn.clicked.connect(progress_dialog.accept)
        progress_layout.addWidget(close_btn)
        
        # Show dialog
        progress_dialog.show()
        QApplication.processEvents()
        
        # Progress callback function
        import_stats = {'imported': 0, 'skipped': 0, 'errors': 0}
        
        def progress_callback(current, total, message):
            """Update progress dialog with import progress"""
            if total > 0:
                percent = int((current / total) * 100)
                progress_bar.setValue(percent)
                progress_bar.setFormat(f"{current}/{total} ({percent}%)")
            
            # Update stats from message
            if message.startswith("‚úÖ"):
                import_stats['imported'] += 1
                imported_label.setText(f"‚úÖ Imported: {import_stats['imported']}")
            elif message.startswith("‚è≠Ô∏è"):
                import_stats['skipped'] += 1
                skipped_label.setText(f"‚è≠Ô∏è Skipped: {import_stats['skipped']}")
            elif message.startswith("‚ùå"):
                import_stats['errors'] += 1
                errors_label.setText(f"‚ùå Errors: {import_stats['errors']}")
            
            # Add to log
            log_text.append(message)
            
            # Auto-scroll to bottom
            scrollbar = log_text.verticalScrollBar()
            scrollbar.setValue(scrollbar.maximum())
            
            # Process events to keep UI responsive
            QApplication.processEvents()
        
        # Perform import with progress callback
        from modules.termbase_import_export import TermbaseImporter
        importer = TermbaseImporter(self.db_manager, termbase_mgr)
        
        self.log(f"üì• Importing termbase from {filepath}...")
        
        result = importer.import_tsv(
            filepath=filepath,
            termbase_id=termbase_id,
            skip_duplicates=skip_radio.isChecked(),
            update_duplicates=update_radio.isChecked(),
            progress_callback=progress_callback
        )
        
        # Update final stats
        progress_bar.setValue(100)
        imported_label.setText(f"‚úÖ Imported: {result.imported_count}")
        skipped_label.setText(f"‚è≠Ô∏è Skipped: {result.skipped_count}")
        errors_label.setText(f"‚ùå Errors: {result.error_count}")
        
        # Add summary to log
        log_text.append("")
        log_text.append("=" * 50)
        if result.success:
            log_text.append(f"‚úì Import complete: {result.imported_count} terms imported")
            if result.skipped_count > 0:
                log_text.append(f"  Skipped {result.skipped_count} duplicates")
            if result.error_count > 0:
                log_text.append(f"  {result.error_count} errors occurred")
            header_label.setText(f"<b>‚úì Import Complete: {tb_name}</b>")
            header_label.setStyleSheet("font-size: 12pt; padding: 5px; color: #4CAF50;")
        else:
            log_text.append(f"‚úó Import failed: {result.message}")
            header_label.setText(f"<b>‚úó Import Failed: {tb_name}</b>")
            header_label.setStyleSheet("font-size: 12pt; padding: 5px; color: #F44336;")
        
        # Enable close button
        close_btn.setEnabled(True)
        close_btn.setFocus()
        
        # Wait for user to close dialog
        progress_dialog.exec()
        
        # Log and clear cache
        if result.success:
            self.log(f"‚úì {result.message}")
            with self.termbase_cache_lock:
                self.termbase_cache.clear()
            
            # Refresh the termbase table to show updated term counts
            self._refresh_termbase_table(termbase_table, termbase_mgr)
        else:
            self.log(f"‚úó Import failed: {result.message}")
    
    def _export_termbase(self, termbase_mgr, termbase_table):
        """Export selected termbase to TSV file"""
        selected_row = termbase_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a glossary to export")
            return
        
        # Get termbase info from Name column (column 1 - has ID stored in UserRole)
        name_item = termbase_table.item(selected_row, 1)
        if not name_item:
            QMessageBox.warning(self, "Error", "Could not read glossary information")
            return
        
        tb_name = name_item.text()
        termbase_id = name_item.data(Qt.ItemDataRole.UserRole)
        
        if not termbase_id:
            QMessageBox.warning(self, "Error", "Could not find glossary ID")
            return
        
        # File dialog
        from PyQt6.QtWidgets import QFileDialog
        default_filename = f"{tb_name.replace(' ', '_')}.tsv"
        filepath, _ = QFileDialog.getSaveFileName(
            self,
            "Export Glossary",
            default_filename,
            "TSV Files (*.tsv);;Text Files (*.txt);;All Files (*.*)"
        )
        
        if not filepath:
            return
        
        # Show options dialog
        options_dialog = QDialog(self)
        options_dialog.setWindowTitle("Export Options")
        options_dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(options_dialog)
        
        # Info
        info_label = QLabel(f"Exporting glossary: <b>{tb_name}</b>")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Metadata checkbox
        metadata_check = CheckmarkCheckBox("Include all metadata (project, client, forbidden)")
        metadata_check.setChecked(True)
        layout.addWidget(metadata_check)
        
        # Buttons
        button_box = QHBoxLayout()
        button_box.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(options_dialog.reject)
        button_box.addWidget(cancel_btn)
        
        export_btn = QPushButton("Export")
        export_btn.setStyleSheet("font-weight: bold; background-color: #2196F3; color: white; padding: 8px 20px; border: none; outline: none;")
        export_btn.clicked.connect(options_dialog.accept)
        button_box.addWidget(export_btn)
        
        layout.addLayout(button_box)
        
        if options_dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Perform export
        from modules.termbase_import_export import TermbaseExporter
        exporter = TermbaseExporter(self.db_manager, termbase_mgr)
        
        self.log(f"üì§ Exporting termbase to {filepath}...")
        
        success, message = exporter.export_tsv(
            termbase_id=termbase_id,
            filepath=filepath,
            include_metadata=metadata_check.isChecked()
        )
        
        # Show result
        if success:
            QMessageBox.information(self, "Export Complete", message)
            self.log(f"‚úì {message}")
        else:
            QMessageBox.critical(self, "Export Failed", message)
            self.log(f"‚úó Export failed: {message}")
    
    def _update_term_forbidden(self, term_id: int, forbidden: bool):
        """Update forbidden flag for a term"""
        try:
            cursor = self.db_manager.cursor
            cursor.execute("UPDATE termbase_terms SET forbidden = ? WHERE id = ?", (1 if forbidden else 0, term_id))
            self.db_manager.connection.commit()
            self.log(f"‚úì Updated term {term_id} forbidden status to {forbidden}")
        except Exception as e:
            self.log(f"‚úó Error updating term forbidden status: {e}")
    
    def _show_edit_terms_dialog(self, termbase_mgr, termbase_table, refresh_callback):
        """Show dialog to edit terms in selected termbase"""
        selected_row = termbase_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a glossary first")
            return
        
        # Get termbase ID and name from table (column 1 is Name with ID stored in UserRole)
        name_item = termbase_table.item(selected_row, 1)
        if not name_item:
            QMessageBox.warning(self, "Error", "Could not find selected glossary")
            return
        
        termbase_id = name_item.data(Qt.ItemDataRole.UserRole)
        tb_name = name_item.text()
        
        if not termbase_id:
            QMessageBox.warning(self, "Error", "Could not find selected glossary")
            return
        
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Edit Terms - {tb_name}")
        dialog.setMinimumSize(700, 500)
        
        layout = QVBoxLayout()
        
        # Terms table
        terms_table = QTableWidget()
        terms_table.setColumnCount(8)
        terms_table.setHorizontalHeaderLabels(["Source", "Target", "Domain", "Priority", "Notes", "Project", "Client", "Forbidden"])
        terms_table.horizontalHeader().setStretchLastSection(False)
        terms_table.setColumnWidth(0, 120)
        terms_table.setColumnWidth(1, 120)
        terms_table.setColumnWidth(2, 100)
        terms_table.setColumnWidth(3, 60)
        terms_table.setColumnWidth(4, 150)
        terms_table.setColumnWidth(5, 100)
        terms_table.setColumnWidth(6, 100)
        terms_table.setColumnWidth(7, 80)
        
        # Load terms
        def refresh_terms_table():
            terms = termbase_mgr.get_terms(termbase_id)
            terms_table.setRowCount(len(terms))
            
            for row, term in enumerate(terms):
                # Store term ID in first column (hidden from user)
                source_item = QTableWidgetItem(term['source_term'])
                source_item.setData(Qt.ItemDataRole.UserRole, term['id'])  # Store term ID
                terms_table.setItem(row, 0, source_item)
                
                terms_table.setItem(row, 1, QTableWidgetItem(term['target_term']))
                terms_table.setItem(row, 2, QTableWidgetItem(term['domain'] or ""))
                
                priority_item = QTableWidgetItem(str(term['priority']))
                priority_item.setFlags(priority_item.flags() | Qt.ItemFlag.ItemIsEditable)
                terms_table.setItem(row, 3, priority_item)
                
                # Notes column (truncated for display)
                notes_text = term.get('notes', '') or ""
                if len(notes_text) > 50:
                    notes_text = notes_text[:47] + "..."
                terms_table.setItem(row, 4, QTableWidgetItem(notes_text))
                
                # Project and Client columns
                terms_table.setItem(row, 5, QTableWidgetItem(term.get('project', '') or ""))
                terms_table.setItem(row, 6, QTableWidgetItem(term.get('client', '') or ""))
                
                # Forbidden checkbox
                forbidden_check = CheckmarkCheckBox()
                forbidden_check.setChecked(term['forbidden'])
                forbidden_check.toggled.connect(lambda checked, t_id=term['id']: self._update_term_forbidden(t_id, checked))
                terms_table.setCellWidget(row, 7, forbidden_check)
        
        # Handle term field changes
        def on_term_changed(item: QTableWidgetItem):
            if item.column() == 3:  # Priority column
                term_id = terms_table.item(item.row(), 0).data(Qt.ItemDataRole.UserRole)
                try:
                    new_priority = int(item.text())
                    new_priority = max(1, min(99, new_priority))
                    item.setText(str(new_priority))
                    
                    # Update in database
                    cursor = self.db_manager.cursor
                    cursor.execute("UPDATE termbase_terms SET priority = ? WHERE id = ?", (new_priority, term_id))
                    self.db_manager.connection.commit()
                    self.log(f"‚úì Updated term priority to {new_priority}")
                except ValueError:
                    terms = termbase_mgr.get_terms(termbase_id)
                    original = next((t for t in terms if t['id'] == term_id), None)
                    if original:
                        item.setText(str(original['priority']))
        
        terms_table.itemChanged.connect(on_term_changed)
        refresh_terms_table()
        layout.addWidget(QLabel(f"Terms in '{tb_name}':"), 0)
        layout.addWidget(terms_table, 1)
        
        # Add term section
        add_layout = QHBoxLayout()
        
        source_field = QLineEdit()
        source_field.setPlaceholderText("Source term")
        add_layout.addWidget(source_field)
        
        target_field = QLineEdit()
        target_field.setPlaceholderText("Target term")
        add_layout.addWidget(target_field)
        
        priority_spin = QSpinBox()
        priority_spin.setMinimum(1)
        priority_spin.setMaximum(99)
        priority_spin.setValue(50)
        priority_spin.setMaximumWidth(60)
        add_layout.addWidget(QLabel("Priority:"))
        add_layout.addWidget(priority_spin)
        
        add_btn = QPushButton("+ Add")
        def add_term():
            source = source_field.text().strip()
            target = target_field.text().strip()
            if not source or not target:
                QMessageBox.warning(dialog, "Error", "Both source and target terms are required")
                return
            
            termbase_mgr.add_term(
                termbase_id=termbase_id,
                source_term=source,
                target_term=target,
                priority=priority_spin.value()
            )
            
            source_field.clear()
            target_field.clear()
            refresh_terms_table()
        
        add_btn.clicked.connect(add_term)
        add_layout.addWidget(add_btn)
        layout.addLayout(add_layout)
        
        # Action buttons
        action_layout = QHBoxLayout()
        
        # Edit selected term button
        edit_term_btn = QPushButton("‚úèÔ∏è Edit Selected Term")
        def edit_selected_term():
            selected_row = terms_table.currentRow()
            if selected_row < 0:
                QMessageBox.warning(dialog, "Error", "Please select a term to edit")
                return
            
            term_id = terms_table.item(selected_row, 0).data(Qt.ItemDataRole.UserRole)
            if term_id:
                from modules.termbase_entry_editor import TermbaseEntryEditor
                edit_dialog = TermbaseEntryEditor(
                    parent=self,
                    db_manager=self.db_manager,
                    termbase_id=termbase_id,
                    term_id=term_id
                )
                if edit_dialog.exec():
                    refresh_terms_table()
        
        edit_term_btn.clicked.connect(edit_selected_term)
        action_layout.addWidget(edit_term_btn)
        
        # Delete selected term button
        delete_term_btn = QPushButton("üóëÔ∏è Delete Selected Term")
        delete_term_btn.setStyleSheet("background-color: #f44336; color: white; font-weight: bold;")
        def delete_selected_term():
            selected_row = terms_table.currentRow()
            if selected_row < 0:
                QMessageBox.warning(dialog, "Error", "Please select a term to delete")
                return
            
            term_id = terms_table.item(selected_row, 0).data(Qt.ItemDataRole.UserRole)
            source_term = terms_table.item(selected_row, 0).text()
            target_term = terms_table.item(selected_row, 1).text()
            
            if term_id:
                reply = QMessageBox.question(
                    dialog,
                    "Confirm Deletion",
                    f"Delete this term?\n\nSource: {source_term}\nTarget: {target_term}\n\nThis action cannot be undone.",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )
                
                if reply == QMessageBox.StandardButton.Yes:
                    try:
                        cursor = self.db_manager.cursor
                        cursor.execute("DELETE FROM termbase_terms WHERE id = ?", (term_id,))
                        self.db_manager.connection.commit()
                        self.log(f"‚úì Deleted term: {source_term} ‚Üí {target_term}")
                        refresh_terms_table()
                    except Exception as e:
                        QMessageBox.critical(dialog, "Error", f"Failed to delete term: {e}")
        
        delete_term_btn.clicked.connect(delete_selected_term)
        action_layout.addWidget(delete_term_btn)
        
        action_layout.addStretch()
        layout.addLayout(action_layout)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn)
        
        dialog.setLayout(layout)
        dialog.exec()
    
    # ========================================================================
    # TRANSLATION MEMORY HELPER METHODS
    # ========================================================================
    
    def _show_create_tm_dialog(self, tm_metadata_mgr, refresh_callback, project_id):
        """Show dialog to create new TM"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Create New Translation Memory")
        dialog.setMinimumWidth(450)
        
        layout = QFormLayout()
        
        # TM Name
        name_field = QLineEdit()
        name_field.setPlaceholderText("e.g., ClientX_Medical_2024")
        layout.addRow("TM Name:", name_field)
        
        # TM ID (auto-generated from name, but editable)
        tm_id_field = QLineEdit()
        tm_id_field.setPlaceholderText("e.g., clientx_medical_2024")
        layout.addRow("TM ID:", tm_id_field)
        
        # Auto-generate TM ID from name
        def update_tm_id():
            name = name_field.text().strip()
            if name and not tm_id_field.text():
                # Convert name to valid tm_id
                tm_id = name.lower().replace(' ', '_').replace('-', '_')
                # Remove special characters
                tm_id = ''.join(c for c in tm_id if c.isalnum() or c == '_')
                tm_id_field.setText(tm_id)
        
        name_field.textChanged.connect(update_tm_id)
        
        # Source language
        source_lang_field = QLineEdit()
        source_lang_field.setPlaceholderText("e.g., en, nl, de")
        layout.addRow("Source Language:", source_lang_field)
        
        # Target language
        target_lang_field = QLineEdit()
        target_lang_field.setPlaceholderText("e.g., en, nl, de")
        layout.addRow("Target Language:", target_lang_field)
        
        # Description
        desc_field = QTextEdit()
        desc_field.setMaximumHeight(80)
        desc_field.setPlaceholderText("Optional description...")
        layout.addRow("Description:", desc_field)
        
        # Buttons
        button_box = QHBoxLayout()
        button_box.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        button_box.addWidget(cancel_btn)
        
        create_btn = QPushButton("Create")
        create_btn.setStyleSheet("font-weight: bold;")
        create_btn.clicked.connect(dialog.accept)
        button_box.addWidget(create_btn)
        
        layout.addRow("", button_box)
        
        dialog.setLayout(layout)
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            name = name_field.text().strip()
            tm_id = tm_id_field.text().strip()
            source_lang = source_lang_field.text().strip() or None
            target_lang = target_lang_field.text().strip() or None
            description = desc_field.toPlainText().strip()
            
            if not name:
                QMessageBox.warning(self, "Error", "Please enter a TM name")
                return
            
            if not tm_id:
                QMessageBox.warning(self, "Error", "Please enter a TM ID")
                return
            
            # Create TM
            result = tm_metadata_mgr.create_tm(
                name=name,
                tm_id=tm_id,
                source_lang=source_lang,
                target_lang=target_lang,
                description=description
            )
            
            if result:
                # Auto-activate for current project (or global=0 if no project loaded)
                if project_id is not None:
                    tm_metadata_mgr.activate_tm(result, project_id)
                
                QMessageBox.information(self, "Success", f"Translation Memory '{name}' created successfully!")
                refresh_callback()
            else:
                QMessageBox.critical(self, "Error", "Failed to create TM. The TM name or ID may already exist.")
    
    def _import_tmx_as_tm(self, tm_metadata_mgr, tm_table, refresh_callback):
        """Import TMX file as a new TM or add to existing TM"""
        from PyQt6.QtWidgets import QFileDialog, QRadioButton, QButtonGroup
        
        # File dialog
        filepath, _ = QFileDialog.getOpenFileName(
            self,
            "Import TMX File",
            "",
            "TMX Files (*.tmx);;All Files (*.*)"
        )
        
        if not filepath:
            return
        
        # Ask user: create new TM or add to existing?
        choice_dialog = QDialog(self)
        choice_dialog.setWindowTitle("Import TMX")
        choice_dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(choice_dialog)
        
        layout.addWidget(QLabel(f"Importing: {filepath}\n"))
        layout.addWidget(QLabel("Choose import option:"))
        
        new_tm_radio = CheckmarkRadioButton("Create new TM from this TMX")
        new_tm_radio.setChecked(True)
        layout.addWidget(new_tm_radio)
        
        existing_tm_radio = CheckmarkRadioButton("Add to existing TM")
        layout.addWidget(existing_tm_radio)
        
        # TM selection combo (for existing TM option)
        tm_combo = QComboBox()
        tm_combo.setEnabled(False)
        tms = tm_metadata_mgr.get_all_tms()
        for tm in tms:
            tm_combo.addItem(tm['name'], tm['tm_id'])
        layout.addWidget(tm_combo)
        
        existing_tm_radio.toggled.connect(tm_combo.setEnabled)
        
        # Buttons
        button_box = QHBoxLayout()
        button_box.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(choice_dialog.reject)
        button_box.addWidget(cancel_btn)
        
        import_btn = QPushButton("Import")
        import_btn.setStyleSheet("font-weight: bold;")
        import_btn.clicked.connect(choice_dialog.accept)
        button_box.addWidget(import_btn)
        
        layout.addLayout(button_box)
        
        if choice_dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Determine target tm_id
        target_tm_id = None
        
        if new_tm_radio.isChecked():
            # Create new TM - ask for name
            from pathlib import Path
            default_name = Path(filepath).stem  # Use filename without extension
            
            name, ok = QInputDialog.getText(
                self,
                "New TM Name",
                "Enter name for the new Translation Memory:",
                text=default_name
            )
            
            if not ok or not name:
                return
            
            # Generate tm_id from name
            tm_id = name.lower().replace(' ', '_').replace('-', '_')
            tm_id = ''.join(c for c in tm_id if c.isalnum() or c == '_')
            
            # Detect TMX languages BEFORE creating TM
            if not self.tm_database:
                self.initialize_tm_database()
            
            if not self.tm_database:
                QMessageBox.critical(self, "Error", "TM database not available")
                return
            
            tmx_langs = self.tm_database.detect_tmx_languages(filepath)
            
            if len(tmx_langs) < 2:
                QMessageBox.warning(
                    self, "Invalid TMX",
                    f"TMX file must contain at least 2 languages.\nFound: {', '.join(tmx_langs) if tmx_langs else 'none'}"
                )
                return
            
            # Let user select source and target from detected languages
            lang_dialog = QDialog(self)
            lang_dialog.setWindowTitle("Select Language Pair")
            lang_dialog.setMinimumWidth(400)
            
            lang_layout = QVBoxLayout(lang_dialog)
            lang_layout.addWidget(QLabel(f"TMX file contains {len(tmx_langs)} languages:\n{', '.join(tmx_langs)}\n"))
            lang_layout.addWidget(QLabel("Select source and target languages:"))
            
            # Source language combo
            src_layout = QHBoxLayout()
            src_layout.addWidget(QLabel("Source:"))
            src_combo = QComboBox()
            for lang in tmx_langs:
                src_combo.addItem(lang)
            src_layout.addWidget(src_combo)
            lang_layout.addLayout(src_layout)
            
            # Target language combo
            tgt_layout = QHBoxLayout()
            tgt_layout.addWidget(QLabel("Target:"))
            tgt_combo = QComboBox()
            for lang in tmx_langs:
                tgt_combo.addItem(lang)
            # Default to second language if available
            if len(tmx_langs) > 1:
                tgt_combo.setCurrentIndex(1)
            tgt_layout.addWidget(tgt_combo)
            lang_layout.addLayout(tgt_layout)
            
            # Buttons
            lang_button_box = QHBoxLayout()
            lang_button_box.addStretch()
            
            lang_cancel_btn = QPushButton("Cancel")
            lang_cancel_btn.clicked.connect(lang_dialog.reject)
            lang_button_box.addWidget(lang_cancel_btn)
            
            lang_ok_btn = QPushButton("OK")
            lang_ok_btn.setStyleSheet("font-weight: bold;")
            lang_ok_btn.clicked.connect(lang_dialog.accept)
            lang_button_box.addWidget(lang_ok_btn)
            
            lang_layout.addLayout(lang_button_box)
            
            if lang_dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            detected_src = src_combo.currentText()
            detected_tgt = tgt_combo.currentText()
            
            # Validate that source != target
            if detected_src == detected_tgt:
                QMessageBox.warning(
                    self, "Invalid Selection",
                    "Source and target languages must be different."
                )
                return
            
            # Create TM metadata entry with detected languages
            db_id = tm_metadata_mgr.create_tm(
                name=name,
                tm_id=tm_id,
                source_lang=detected_src,
                target_lang=detected_tgt,
                description=f"Imported from {Path(filepath).name}"
            )
            
            if not db_id:
                QMessageBox.critical(self, "Error", "Failed to create TM metadata")
                return
            
            target_tm_id = tm_id
        else:
            # Use existing TM
            target_tm_id = tm_combo.currentData()
            if not target_tm_id:
                QMessageBox.warning(self, "Error", "No TM selected")
                return
        
        # Import TMX
        try:
            if not self.tm_database:
                self.initialize_tm_database()
            
            if self.tm_database:
                # Import using existing TM database import method
                # Get TM languages from metadata
                tm_info = tm_metadata_mgr.get_tm_by_tm_id(target_tm_id)
                if not tm_info:
                    QMessageBox.critical(self, "Error", f"TM '{target_tm_id}' not found")
                    return
                
                tm_src_lang = tm_info.get('source_lang')
                tm_tgt_lang = tm_info.get('target_lang')
                
                # If TM has NULL languages, detect from TMX and let user select
                if not tm_src_lang or not tm_tgt_lang:
                    tmx_langs = self.tm_database.detect_tmx_languages(filepath)
                    
                    if len(tmx_langs) < 2:
                        QMessageBox.warning(
                            self, "Invalid TMX",
                            f"TMX file must contain at least 2 languages.\nFound: {', '.join(tmx_langs) if tmx_langs else 'none'}"
                        )
                        return
                    
                    # Let user select source and target from detected languages
                    lang_dialog = QDialog(self)
                    lang_dialog.setWindowTitle("Select Language Pair")
                    lang_dialog.setMinimumWidth(400)
                    
                    lang_layout = QVBoxLayout(lang_dialog)
                    lang_layout.addWidget(QLabel(f"TMX file contains {len(tmx_langs)} languages:\n{', '.join(tmx_langs)}\n"))
                    lang_layout.addWidget(QLabel("Select source and target languages:"))
                    
                    # Source language combo
                    src_layout = QHBoxLayout()
                    src_layout.addWidget(QLabel("Source:"))
                    src_combo = QComboBox()
                    for lang in tmx_langs:
                        src_combo.addItem(lang)
                    src_layout.addWidget(src_combo)
                    lang_layout.addLayout(src_layout)
                    
                    # Target language combo
                    tgt_layout = QHBoxLayout()
                    tgt_layout.addWidget(QLabel("Target:"))
                    tgt_combo = QComboBox()
                    for lang in tmx_langs:
                        tgt_combo.addItem(lang)
                    # Default to second language if available
                    if len(tmx_langs) > 1:
                        tgt_combo.setCurrentIndex(1)
                    tgt_layout.addWidget(tgt_combo)
                    lang_layout.addLayout(tgt_layout)
                    
                    # Buttons
                    lang_button_box = QHBoxLayout()
                    lang_button_box.addStretch()
                    
                    lang_cancel_btn = QPushButton("Cancel")
                    lang_cancel_btn.clicked.connect(lang_dialog.reject)
                    lang_button_box.addWidget(lang_cancel_btn)
                    
                    lang_ok_btn = QPushButton("OK")
                    lang_ok_btn.setStyleSheet("font-weight: bold;")
                    lang_ok_btn.clicked.connect(lang_dialog.accept)
                    lang_button_box.addWidget(lang_ok_btn)
                    
                    lang_layout.addLayout(lang_button_box)
                    
                    if lang_dialog.exec() != QDialog.DialogCode.Accepted:
                        return
                    
                    tm_src_lang = src_combo.currentText()
                    tm_tgt_lang = tgt_combo.currentText()
                    
                    # Validate that source != target
                    if tm_src_lang == tm_tgt_lang:
                        QMessageBox.warning(
                            self, "Invalid Selection",
                            "Source and target languages must be different."
                        )
                        return
                    
                    # Update TM metadata with detected languages
                    tm_metadata_mgr.update_tm(
                        target_tm_id,
                        source_lang=tm_src_lang,
                        target_lang=tm_tgt_lang
                    )
                    self.log(f"‚úì Updated TM '{target_tm_id}' with detected languages: {tm_src_lang} ‚Üí {tm_tgt_lang}")
                
                # Detect TMX languages and check compatibility
                tmx_langs = self.tm_database.detect_tmx_languages(filepath)
                compat = self.tm_database.check_language_compatibility(tmx_langs, tm_src_lang, tm_tgt_lang)
                
                if not compat['compatible']:
                    QMessageBox.warning(
                        self, "Language Mismatch",
                        f"TMX languages ({', '.join(tmx_langs)}) don't match TM languages ({tm_src_lang}, {tm_tgt_lang})"
                    )
                    return
                
                # Determine if we should strip variants
                strip_variants = compat.get('variant_match', False)
                if strip_variants:
                    reply = QMessageBox.question(
                        self, "Language Variants Detected",
                        f"TMX has language variants:\n{compat['tmx_source']}, {compat['tmx_target']}\n\n"
                        f"TM expects:\n{tm_src_lang}, {tm_tgt_lang}\n\n"
                        "Import by matching base languages?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                    if reply != QMessageBox.StandardButton.Yes:
                        return
                
                # Import into existing TM with real-time progress dialog
                from PyQt6.QtWidgets import QProgressDialog
                from PyQt6.QtCore import Qt
                import time
                
                progress = QProgressDialog("Counting translation units...", "Cancel", 0, 100, self)
                progress.setWindowTitle("TMX Import")
                progress.setWindowModality(Qt.WindowModality.WindowModal)
                progress.setMinimumDuration(0)
                progress.setAutoClose(False)
                progress.setAutoReset(False)
                progress.setValue(0)
                progress.show()
                QApplication.processEvents()
                
                cancelled = False
                start_time = time.time()
                
                def update_progress(current, total, message):
                    nonlocal cancelled
                    if progress.wasCanceled():
                        cancelled = True
                        return
                    
                    if total > 0:
                        percentage = int((current / total) * 100)
                        progress.setValue(percentage)
                        
                        # Calculate time stats
                        elapsed = time.time() - start_time
                        if current > 0:
                            rate = current / elapsed
                            remaining = (total - current) / rate if rate > 0 else 0
                            
                            # Format message with stats
                            time_info = f" (~{int(remaining/60)}m {int(remaining%60)}s remaining)" if remaining > 10 else ""
                            progress.setLabelText(f"{message}\nRate: {int(rate):,} entries/sec{time_info}")
                        else:
                            progress.setLabelText(message)
                    else:
                        progress.setLabelText(message)
                    
                    QApplication.processEvents()
                
                count = self.tm_database._load_tmx_into_db(
                    filepath, tm_src_lang, tm_tgt_lang, target_tm_id, 
                    strip_variants=strip_variants, progress_callback=update_progress
                )
                
                progress.close()
                
                if not cancelled:
                    # Update entry count
                    tm_metadata_mgr.update_entry_count(target_tm_id)
                    self.log(f"Imported {count} entries into TM '{target_tm_id}'")
                    
                    QMessageBox.information(self, "Success", f"TMX imported successfully into TM '{target_tm_id}'!\n\nEntries imported: {count:,}")
                else:
                    self.log(f"TMX import cancelled by user. Partial import: {count} entries")
                    QMessageBox.information(self, "Import Cancelled", f"Import stopped.\n\nPartial entries imported: {count:,}")
                refresh_callback()
            else:
                QMessageBox.critical(self, "Error", "TM database not available")
        except Exception as e:
            self.log(f"‚úó Error importing TMX: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Import Error", f"Failed to import TMX:\n\n{str(e)}")
    
    def _export_tm_to_tmx(self, tm_metadata_mgr, tm_table):
        """Export selected TM to TMX file"""
        selected_row = tm_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a TM to export")
            return
        
        # Get TM (column 0 = TM Name)
        tm_name = tm_table.item(selected_row, 0).text()
        tms = tm_metadata_mgr.get_all_tms()
        tm = next((t for t in tms if t['name'] == tm_name), None)
        if not tm:
            QMessageBox.warning(self, "Error", "Could not find selected TM")
            return
        
        # File dialog
        from PyQt6.QtWidgets import QFileDialog
        default_filename = f"{tm_name.replace(' ', '_')}.tmx"
        filepath, _ = QFileDialog.getSaveFileName(
            self,
            "Export TM to TMX",
            default_filename,
            "TMX Files (*.tmx);;All Files (*.*)"
        )
        
        if not filepath:
            return
        
        try:
            # Get all entries for this TM
            cursor = self.db_manager.cursor
            cursor.execute("""
                SELECT source_text, target_text 
                FROM translation_units 
                WHERE tm_id = ?
                ORDER BY id
            """, (tm['tm_id'],))
            
            entries = cursor.fetchall()
            
            if not entries:
                QMessageBox.warning(self, "Empty TM", "This TM has no entries to export")
                return
            
            # Generate TMX
            from modules.tmx_generator import TMXGenerator
            tmx_generator = TMXGenerator(log_callback=self.log)
            
            source_segments = [e[0] for e in entries]
            target_segments = [e[1] for e in entries]
            
            tmx_tree = tmx_generator.generate_tmx(
                source_segments=source_segments,
                target_segments=target_segments,
                source_lang=tm['source_lang'] or "en",
                target_lang=tm['target_lang'] or "nl"
            )
            
            if tmx_generator.save_tmx(tmx_tree, filepath):
                self.log(f"‚úì Exported TM '{tm_name}' to {filepath} ({len(entries)} entries)")
                QMessageBox.information(
                    self,
                    "Export Complete",
                    f"TM exported successfully!\n\nFile: {filepath}\nEntries: {len(entries)}"
                )
            else:
                QMessageBox.warning(self, "Export Error", "Failed to save TMX file")
        
        except Exception as e:
            self.log(f"‚úó Error exporting TM: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Export Error", f"Failed to export TM:\n\n{str(e)}")
    
    def _delete_tm(self, tm_metadata_mgr, tm_table, refresh_callback):
        """Delete selected TM"""
        selected_row = tm_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a TM to delete")
            return
        
        # Get TM (column 0 = TM Name)
        tm_name = tm_table.item(selected_row, 0).text()
        tms = tm_metadata_mgr.get_all_tms()
        tm = next((t for t in tms if t['name'] == tm_name), None)
        if not tm:
            return
        
        # Confirm deletion
        reply = QMessageBox.question(
            self,
            "Delete TM",
            f"Delete TM '{tm_name}'?\n\nThis will also delete all {tm['entry_count']} translation units in this TM.\n\nThis action cannot be undone!",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            if tm_metadata_mgr.delete_tm(tm['id'], delete_entries=True):
                QMessageBox.information(self, "Success", f"TM '{tm_name}' deleted successfully")
                refresh_callback()
            else:
                QMessageBox.critical(self, "Error", "Failed to delete TM")
    
    def _show_tm_editor_dialog(self, tm_metadata_mgr, tm_table):
        """Show TM Editor dialog for selected TM (combines old TM Manager functionality)"""
        selected_row = tm_table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select a TM to edit")
            return
        
        # Get TM (column 0 = TM Name)
        tm_name = tm_table.item(selected_row, 0).text()
        tms = tm_metadata_mgr.get_all_tms()
        tm = next((t for t in tms if t['name'] == tm_name), None)
        if not tm:
            return
        
        # Open TM Editor with this specific TM
        from modules.tm_editor_dialog import TMEditorDialog
        dialog = TMEditorDialog(self, self.db_manager, self.log, tm_id=tm['tm_id'], tm_name=tm_name)
        dialog.exec()
    
    # ========================================================================
    # SETTINGS TAB
    # ========================================================================
    
    def create_settings_tab(self):
        """Create the Settings tab - moved from Tools > Options dialog"""
        from PyQt6.QtWidgets import QTabWidget, QScrollArea
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create nested tab widget
        settings_tabs = QTabWidget()
        settings_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        settings_tabs.tabBar().setDrawBase(False)
        settings_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        self.settings_tabs = settings_tabs  # Store for reference
        
        # Scroll area wrapper for each tab (for long content)
        scroll_area_wrapper = lambda widget: self._wrap_in_scroll(widget)
        
        # ===== TAB 1: General Settings =====
        general_tab = self._create_general_settings_tab()
        settings_tabs.addTab(scroll_area_wrapper(general_tab), "‚öôÔ∏è General")
        
        # ===== TAB 2: AI Settings (LLM, Ollama) =====
        ai_tab = self._create_ai_settings_tab()
        ai_scroll = scroll_area_wrapper(ai_tab)
        settings_tabs.addTab(ai_scroll, "ü§ñ AI Settings")
        self.ai_settings_scroll = ai_scroll  # Store reference for scrolling to API keys
        
        # ===== TAB 3: Language Pair Settings =====
        lang_tab = self._create_language_pair_tab()
        settings_tabs.addTab(scroll_area_wrapper(lang_tab), "üåê Language Pair")
        
        # ===== TAB 4: MT Settings =====
        mt_tab = self._create_mt_settings_tab()
        settings_tabs.addTab(scroll_area_wrapper(mt_tab), "üåê MT Settings")
        
        # ===== TAB 5: View Settings =====
        view_tab = self._create_view_settings_tab()
        settings_tabs.addTab(scroll_area_wrapper(view_tab), "üîç View Settings")

        # ===== TAB 6: System Prompts (Layer 1) =====
        system_prompts_tab = self._create_system_prompts_tab()
        settings_tabs.addTab(scroll_area_wrapper(system_prompts_tab), "üìù System Prompts")

        # ===== TAB 7: Debug Settings =====
        debug_tab = self._create_debug_settings_tab()
        settings_tabs.addTab(scroll_area_wrapper(debug_tab), "üêõ Debug")

        # ===== TAB 8: Features (Optional Modules) =====
        features_tab = self._create_features_settings_tab()
        settings_tabs.addTab(scroll_area_wrapper(features_tab), "üì¶ Features")

        # ===== TAB 9: Domain Detection Keywords =====
        domain_keywords_tab = self._create_domain_keywords_tab()
        settings_tabs.addTab(scroll_area_wrapper(domain_keywords_tab), "üéØ Domain Detection")

        # ===== TAB 10: Segmentation Rules =====
        seg_tab = self.create_segmentation_rules_tab()
        settings_tabs.addTab(scroll_area_wrapper(seg_tab), "üìè Segmentation Rules")

        # ===== TAB 11: Keyboard Shortcuts =====
        from modules.keyboard_shortcuts_widget import KeyboardShortcutsWidget
        shortcuts_tab = KeyboardShortcutsWidget(self)
        settings_tabs.addTab(shortcuts_tab, "‚å®Ô∏è Keyboard Shortcuts")

        # ===== TAB 12: Log (moved from main tabs) =====
        log_tab = self.create_log_tab()
        settings_tabs.addTab(log_tab, "üìã Log")
        
        layout.addWidget(settings_tabs)
        
        # Apply saved UI font scale on startup
        saved_scale = self._get_global_ui_font_scale()
        if saved_scale != 100:
            # Defer application to ensure widgets are fully created
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(100, lambda: self._apply_global_ui_font_scale(saved_scale))
        
        return tab
    
    def _wrap_in_scroll(self, widget):
        """Wrap a widget in a scroll area"""
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(widget)
        scroll.setStyleSheet("QScrollArea { border: none; }")
        return scroll
    
    def _create_language_pair_tab(self):
        """Create Language Pair Settings tab content"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # Language Pair Settings group
        lang_group = QGroupBox("Translation Language Pair")
        lang_layout = QVBoxLayout()
        
        info_label = QLabel(
            "Set your default source and target languages for translation projects."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("font-size: 9pt; padding: 8px; border-radius: 3px;")
        lang_layout.addWidget(info_label)
        
        # Language selection layout
        lang_select_layout = QHBoxLayout()
        
        # Source language
        source_label = QLabel("Source Language:")
        source_combo = QComboBox()
        
        # Available languages (from Tkinter version)
        available_languages = [
            "Afrikaans", "Albanian", "Arabic", "Armenian", "Basque", "Bengali",
            "Bulgarian", "Catalan", "Chinese (Simplified)", "Chinese (Traditional)",
            "Croatian", "Czech", "Danish", "Dutch", "English", "Estonian",
            "Finnish", "French", "Galician", "Georgian", "German", "Greek",
            "Hebrew", "Hindi", "Hungarian", "Icelandic", "Indonesian", "Irish",
            "Italian", "Japanese", "Korean", "Latvian", "Lithuanian", "Macedonian",
            "Malay", "Norwegian", "Persian", "Polish", "Portuguese", "Romanian",
            "Russian", "Serbian", "Slovak", "Slovenian", "Spanish", "Swahili",
            "Swedish", "Thai", "Turkish", "Ukrainian", "Urdu", "Vietnamese", "Welsh"
        ]
        source_combo.addItems(available_languages)
        source_combo.setCurrentText(self.source_language)
        
        lang_select_layout.addWidget(source_label)
        lang_select_layout.addWidget(source_combo, 1)
        
        # Swap button
        swap_btn = QPushButton("üîÑ Swap")
        swap_btn.setToolTip("Swap source and target languages")
        lang_select_layout.addWidget(swap_btn)
        
        # Target language
        target_label = QLabel("Target Language:")
        target_combo = QComboBox()
        target_combo.addItems(available_languages)
        target_combo.setCurrentText(self.target_language)
        
        lang_select_layout.addWidget(target_label)
        lang_select_layout.addWidget(target_combo, 1)
        
        lang_layout.addLayout(lang_select_layout)
        
        # Swap functionality
        def on_swap():
            source_val = source_combo.currentText()
            target_val = target_combo.currentText()
            source_combo.setCurrentText(target_val)
            target_combo.setCurrentText(source_val)
        
        swap_btn.clicked.connect(on_swap)
        
        lang_group.setLayout(lang_layout)
        layout.addWidget(lang_group)
        
        # Save button
        save_btn = QPushButton("üíæ Save Language Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        save_btn.clicked.connect(lambda: self._save_language_settings_from_ui(source_combo, target_combo))
        layout.addWidget(save_btn)
        
        layout.addStretch()
        
        return tab
    
    def _create_ai_settings_tab(self):
        """Create unified AI Settings tab - combines LLM, Ollama, and AI Assistant settings"""
        from PyQt6.QtWidgets import QCheckBox, QGroupBox, QPushButton
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        # Load current settings
        settings = self.load_llm_settings()
        enabled_providers = self.load_provider_enabled_states()
        general_settings = self.load_general_settings()
        general_prefs = self.load_general_settings()
        
        # ========== INFO BOX: Free vs Paid Providers ==========
        info_frame = QFrame()
        info_frame.setStyleSheet("""
            QFrame {
                background-color: #E8F4FD;
                border: 1px solid #B8D4E8;
                border-radius: 6px;
                padding: 10px;
            }
            QLabel {
                background: transparent;
                border: none;
            }
        """)
        info_layout = QVBoxLayout(info_frame)
        info_layout.setContentsMargins(12, 8, 12, 8)
        info_layout.setSpacing(4)
        
        info_title = QLabel("üí° <b>Free vs Paid API Access</b>")
        info_layout.addWidget(info_title)
        
        info_text = QLabel(
            "‚Ä¢ <b>Google Gemini</b> ‚Äî <span style='color: green;'>FREE tier available</span> (15 req/min, 1M tokens/day)<br>"
            "‚Ä¢ <b>Ollama</b> ‚Äî <span style='color: green;'>100% FREE</span> (runs locally on your computer)<br>"
            "‚Ä¢ <b>OpenAI</b> ‚Äî Paid API only (no free tier)<br>"
            "‚Ä¢ <b>Anthropic Claude</b> ‚Äî Paid API only (no free tier)<br><br>"
            "‚ö†Ô∏è <b>Note:</b> This app uses <i>API keys</i>, not web chat interfaces. "
            "ChatGPT Plus and Claude Pro web subscriptions do NOT include API access."
        )
        info_text.setWordWrap(True)
        info_text.setStyleSheet("font-size: 11px;")
        info_layout.addWidget(info_text)
        
        layout.addWidget(info_frame)
        
        # ========== SECTION 1: LLM Provider Selection ==========
        provider_group = QGroupBox("ü§ñ LLM Provider Selection")
        provider_layout = QVBoxLayout()
        
        provider_label = QLabel("Select your preferred AI translation provider:")
        provider_layout.addWidget(provider_label)
        
        # Provider radio buttons (custom styled)
        provider_button_group = QButtonGroup(tab)
        
        openai_radio = CustomRadioButton("OpenAI (GPT-4o, GPT-5, o1, o3)")
        openai_radio.setChecked(settings.get('provider', 'openai') == 'openai')
        provider_button_group.addButton(openai_radio)
        provider_layout.addWidget(openai_radio)
        
        claude_radio = CustomRadioButton("Anthropic Claude (Claude Sonnet 4.5)")
        claude_radio.setChecked(settings.get('provider', 'openai') == 'claude')
        provider_button_group.addButton(claude_radio)
        provider_layout.addWidget(claude_radio)
        
        gemini_radio = CustomRadioButton("Google Gemini (Gemini 2.5 Flash)")
        gemini_radio.setChecked(settings.get('provider', 'openai') == 'gemini')
        provider_button_group.addButton(gemini_radio)
        provider_layout.addWidget(gemini_radio)
        
        # Local LLM option (Ollama)
        ollama_radio = CustomRadioButton("üñ•Ô∏è Local LLM (Ollama - runs on your computer)")
        ollama_radio.setChecked(settings.get('provider', 'openai') == 'ollama')
        provider_button_group.addButton(ollama_radio)
        provider_layout.addWidget(ollama_radio)
        
        provider_group.setLayout(provider_layout)
        layout.addWidget(provider_group)
        
        # ========== SECTION 2: Model Selection ==========
        model_group = QGroupBox("üì¶ Model Selection")
        model_layout = QVBoxLayout()
        
        model_label = QLabel("Choose the specific model to use:")
        model_layout.addWidget(model_label)
        
        # OpenAI models
        openai_model_label = QLabel("<b>OpenAI Models:</b>")
        model_layout.addWidget(openai_model_label)
        
        openai_combo = QComboBox()
        openai_combo.addItems([
            "gpt-4o (Recommended)",
            "gpt-4o-mini (Fast & Economical)",
            "gpt-5 (Reasoning, Temperature 1.0)",
            "o3-mini (Reasoning, Temperature 1.0)",
            "o1 (Reasoning, Temperature 1.0)",
            "gpt-4-turbo"
        ])
        openai_combo.setToolTip(
            "GPT-4o (Recommended): Fast, reliable, excellent for general translation.\n"
            "GPT-4o-mini: Faster and cheaper, good quality for simple text.\n"
            "GPT-5/o1/o3-mini: Deep reasoning models for complex text."
        )
        current_openai_model = settings.get('openai_model', 'gpt-4o')
        for i in range(openai_combo.count()):
            if current_openai_model in openai_combo.itemText(i).lower():
                openai_combo.setCurrentIndex(i)
                break
        openai_combo.setEnabled(openai_radio.isChecked())
        model_layout.addWidget(openai_combo)
        
        model_layout.addSpacing(10)
        
        # Claude models
        claude_model_label = QLabel("<b>Claude Models:</b>")
        model_layout.addWidget(claude_model_label)
        
        claude_combo = QComboBox()
        claude_combo.addItems([
            "claude-sonnet-4-5-20250929 (Recommended - Best Balance)",
            "claude-haiku-4-5-20251001 (Fast & Affordable)",
            "claude-opus-4-1-20250805 (Premium - Complex Reasoning)"
        ])
        claude_combo.setToolTip(
            "Claude Sonnet 4.5: Best balance of speed, quality, and cost.\n"
            "Claude Haiku 4.5: 2x faster, 1/3 the cost.\n"
            "Claude Opus 4.1: Premium model for complex reasoning."
        )
        current_claude_model = settings.get('claude_model', 'claude-sonnet-4-5-20250929')
        for i in range(claude_combo.count()):
            if current_claude_model in claude_combo.itemText(i):
                claude_combo.setCurrentIndex(i)
                break
        claude_combo.setEnabled(claude_radio.isChecked())
        model_layout.addWidget(claude_combo)
        
        model_layout.addSpacing(10)
        
        # Gemini models
        gemini_model_label = QLabel("<b>Gemini Models:</b>")
        model_layout.addWidget(gemini_model_label)
        
        gemini_combo = QComboBox()
        gemini_combo.addItems([
            "gemini-2.5-flash (Recommended - Best Balance)",
            "gemini-2.5-flash-lite (Fastest & Most Economical)",
            "gemini-2.5-pro (Premium - Complex Reasoning)",
            "gemini-3-pro-preview (Latest - Superior Performance)",
            "gemini-2.0-flash-exp (Experimental)"
        ])
        gemini_combo.setToolTip(
            "Gemini 2.5 Flash: Best price-performance balance.\n"
            "Gemini 2.5 Flash-Lite: Fastest and cheapest.\n"
            "Gemini 2.5 Pro: Premium for complex problems.\n"
            "Gemini 3 Pro Preview: Latest model with superior reasoning and coding."
        )
        current_gemini_model = settings.get('gemini_model', 'gemini-2.5-flash')
        for i in range(gemini_combo.count()):
            if current_gemini_model in gemini_combo.itemText(i):
                gemini_combo.setCurrentIndex(i)
                break
        gemini_combo.setEnabled(gemini_radio.isChecked())
        model_layout.addWidget(gemini_combo)
        
        model_layout.addSpacing(10)
        
        # Local LLM (Ollama) models
        ollama_model_label = QLabel("<b>üñ•Ô∏è Local LLM Models (Ollama):</b>")
        model_layout.addWidget(ollama_model_label)
        
        # Import the LocalLLMStatusWidget for embedded status
        try:
            from modules.local_llm_setup import LocalLLMStatusWidget, check_ollama_status, RECOMMENDED_MODELS
            
            # Create embedded status widget
            ollama_status_widget = LocalLLMStatusWidget()
            ollama_status_widget.setEnabled(ollama_radio.isChecked())
            model_layout.addWidget(ollama_status_widget)
            
            # Store reference for saving settings
            tab.ollama_status_widget = ollama_status_widget
            
        except ImportError as e:
            # Fallback if module not available
            ollama_fallback = QLabel("‚ö†Ô∏è Local LLM module not available")
            ollama_fallback.setStyleSheet("color: orange;")
            model_layout.addWidget(ollama_fallback)
            ollama_status_widget = None
            tab.ollama_status_widget = None
        
        # Connect radio buttons to enable/disable combos
        def update_combo_states():
            openai_combo.setEnabled(openai_radio.isChecked())
            claude_combo.setEnabled(claude_radio.isChecked())
            gemini_combo.setEnabled(gemini_radio.isChecked())
            if ollama_status_widget:
                ollama_status_widget.setEnabled(ollama_radio.isChecked())
        
        # Handler to show setup dialog when Ollama is selected but not running
        def on_ollama_selected(checked):
            if checked:
                try:
                    from modules.local_llm_setup import check_ollama_status, LocalLLMSetupDialog
                    status = check_ollama_status()
                    
                    if not status.get('running', False):
                        from PyQt6.QtWidgets import QMessageBox
                        msg = QMessageBox(self)
                        msg.setWindowTitle("Local LLM Setup Required")
                        msg.setIcon(QMessageBox.Icon.Information)
                        msg.setText(
                            "<b>üñ•Ô∏è Local LLM (Ollama) Selected</b><br><br>"
                            "Ollama is not currently running on your computer.<br><br>"
                            "Would you like to open the setup wizard?"
                        )
                        msg.setStandardButtons(
                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                        )
                        msg.setDefaultButton(QMessageBox.StandardButton.Yes)
                        
                        if msg.exec() == QMessageBox.StandardButton.Yes:
                            setup_dialog = LocalLLMSetupDialog(self)
                            setup_dialog.exec()
                            if ollama_status_widget:
                                ollama_status_widget.refresh_status()
                except Exception as e:
                    self.log(f"Error checking Ollama status: {e}")
        
        openai_radio.toggled.connect(update_combo_states)
        claude_radio.toggled.connect(update_combo_states)
        gemini_radio.toggled.connect(update_combo_states)
        ollama_radio.toggled.connect(update_combo_states)
        ollama_radio.toggled.connect(on_ollama_selected)
        
        model_group.setLayout(model_layout)
        layout.addWidget(model_group)

        # ========== SECTION 2b: Model Version Checker ==========
        version_check_group = QGroupBox("üîÑ Model Version Checker")
        version_check_layout = QVBoxLayout()

        version_check_info = QLabel(
            "Automatically check for new LLM models from OpenAI, Anthropic, and Google.\n"
            "Get notified when new models are available and easily add them to Supervertaler."
        )
        version_check_info.setWordWrap(True)
        version_check_layout.addWidget(version_check_info)

        # Auto-check setting
        auto_check_models_cb = CheckmarkCheckBox("Enable automatic model checking (once per day on startup)")
        auto_check_models_cb.setChecked(general_settings.get('auto_check_models', True))
        auto_check_models_cb.setToolTip(
            "When enabled, Supervertaler will check for new models once per day when you start the application.\n"
            "You'll see a popup if new models are detected."
        )
        version_check_layout.addWidget(auto_check_models_cb)

        # Manual check button
        manual_check_btn = QPushButton("üîç Check for New Models Now")
        manual_check_btn.setToolTip("Manually check for new models from all providers")
        manual_check_btn.clicked.connect(lambda: self._check_for_new_models(force=True))
        version_check_layout.addWidget(manual_check_btn)

        # Store reference for saving
        self.auto_check_models_cb = auto_check_models_cb

        version_check_group.setLayout(version_check_layout)
        layout.addWidget(version_check_group)

        # ========== SECTION 2c: API Keys ==========
        api_keys_group = QGroupBox("üîë API Keys")
        api_keys_layout = QVBoxLayout()

        api_keys_info = QLabel(
            f"Configure your API keys in:<br>"
            f"<code>{self.user_data_path / 'api_keys.txt'}</code>"
        )
        api_keys_info.setWordWrap(True)
        api_keys_layout.addWidget(api_keys_info)

        open_keys_btn = QPushButton("üìù Open API Keys File")
        open_keys_btn.clicked.connect(lambda: self.open_api_keys_file())
        api_keys_layout.addWidget(open_keys_btn)

        api_keys_group.setLayout(api_keys_layout)
        layout.addWidget(api_keys_group)

        # ========== SECTION 3: Enable/Disable LLM Providers ==========
        provider_enable_group = QGroupBox("‚úÖ Enable/Disable LLM Providers")
        provider_enable_layout = QVBoxLayout()
        
        provider_enable_info = QLabel(
            "Uncheck providers you don't want to use. Only enabled providers will be available."
        )
        provider_enable_info.setWordWrap(True)
        provider_enable_info.setStyleSheet("font-size: 9pt; color: #666; padding: 5px;")
        provider_enable_layout.addWidget(provider_enable_info)
        
        openai_enable_cb = CheckmarkCheckBox("Enable OpenAI")
        openai_enable_cb.setChecked(enabled_providers.get('llm_openai', True))
        provider_enable_layout.addWidget(openai_enable_cb)
        
        claude_enable_cb = CheckmarkCheckBox("Enable Claude")
        claude_enable_cb.setChecked(enabled_providers.get('llm_claude', True))
        provider_enable_layout.addWidget(claude_enable_cb)
        
        gemini_enable_cb = CheckmarkCheckBox("Enable Gemini")
        gemini_enable_cb.setChecked(enabled_providers.get('llm_gemini', True))
        provider_enable_layout.addWidget(gemini_enable_cb)
        
        ollama_enable_cb = CheckmarkCheckBox("Enable Local LLM (Ollama)")
        ollama_enable_cb.setChecked(enabled_providers.get('llm_ollama', True))
        provider_enable_layout.addWidget(ollama_enable_cb)
        
        provider_enable_group.setLayout(provider_enable_layout)
        layout.addWidget(provider_enable_group)
        
        # ========== SECTION 4: Local LLM (Ollama) Advanced Settings ==========
        ollama_group = QGroupBox("üñ•Ô∏è Local LLM (Ollama) Advanced Settings")
        ollama_layout = QVBoxLayout()
        
        ollama_keepwarm_cb = CheckmarkCheckBox("Keep model warm (prevent unloading)")
        ollama_keepwarm_cb.setChecked(general_settings.get('ollama_keepwarm', False))
        ollama_keepwarm_cb.setToolTip(
            "When enabled, sends a small ping to Ollama every 4 minutes\n"
            "to keep the model loaded in memory for faster translations.\n\n"
            "Drawback: Model keeps using RAM even when not translating."
        )
        ollama_layout.addWidget(ollama_keepwarm_cb)
        
        ollama_info = QLabel(
            "üí° <b>Tip:</b> Ollama normally unloads models after 5 minutes of inactivity.\n"
            "Enable 'Keep warm' for faster translations if you translate frequently."
        )
        ollama_info.setWordWrap(True)
        ollama_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        ollama_layout.addWidget(ollama_info)
        
        ollama_group.setLayout(ollama_layout)
        layout.addWidget(ollama_group)
        
        # ========== SECTION 5: AI Translation Preferences ==========
        prefs_group = QGroupBox("‚öôÔ∏è AI Translation Preferences")
        prefs_layout = QVBoxLayout()
        prefs_layout.setSpacing(10)
        
        # Load current preferences
        batch_size = general_prefs.get('batch_size', 20)
        surrounding_segments = general_prefs.get('surrounding_segments', 5)
        use_full_context = general_prefs.get('use_full_context', True)
        check_tm_before_api = general_prefs.get('check_tm_before_api', True)
        auto_propagate_100 = general_prefs.get('auto_propagate_100', True)
        
        # Batch Size
        batch_size_layout = QHBoxLayout()
        batch_size_label = QLabel("Batch Size (segments per API call):")
        batch_size_layout.addWidget(batch_size_label)
        batch_size_spin = QSpinBox()
        batch_size_spin.setMinimum(1)
        batch_size_spin.setMaximum(500)
        batch_size_spin.setValue(batch_size)
        batch_size_spin.setToolTip("Larger batches = faster but higher API cost per call")
        batch_size_layout.addWidget(batch_size_spin)
        batch_size_layout.addStretch()
        prefs_layout.addLayout(batch_size_layout)
        batch_size_info = QLabel("  ‚ìò Larger batches = faster but higher API cost. Default: 20")
        batch_size_info.setStyleSheet("font-size: 9pt; color: #666; padding-left: 20px;")
        prefs_layout.addWidget(batch_size_info)
        
        prefs_layout.addSpacing(5)
        
        # Surrounding segments
        surrounding_layout = QHBoxLayout()
        surrounding_label = QLabel("Surrounding segments (single-segment translation):")
        surrounding_layout.addWidget(surrounding_label)
        surrounding_spin = QSpinBox()
        surrounding_spin.setMinimum(0)
        surrounding_spin.setMaximum(20)
        surrounding_spin.setValue(surrounding_segments)
        surrounding_layout.addWidget(surrounding_spin)
        surrounding_segments_label = QLabel("segments before/after")
        surrounding_layout.addWidget(surrounding_segments_label)
        surrounding_layout.addStretch()
        prefs_layout.addLayout(surrounding_layout)
        surrounding_info = QLabel("  ‚ìò Context for single-segment translation. 0 = no context. Default: 5")
        surrounding_info.setStyleSheet("font-size: 9pt; color: #666; padding-left: 20px;")
        prefs_layout.addWidget(surrounding_info)
        
        prefs_layout.addSpacing(5)
        
        # Include full document context
        full_context_cb = CheckmarkCheckBox("Include surrounding context in batch translation")
        full_context_cb.setChecked(use_full_context)
        prefs_layout.addWidget(full_context_cb)
        
        # Context window size slider
        context_window_size = general_prefs.get('context_window_size', 50)
        context_layout = QHBoxLayout()
        context_label = QLabel("  Context window:")
        context_layout.addWidget(context_label)
        context_slider = QSlider(Qt.Orientation.Horizontal)
        context_slider.setMinimum(0)
        context_slider.setMaximum(200)
        context_slider.setValue(context_window_size)
        context_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        context_slider.setTickInterval(25)
        context_slider.setEnabled(use_full_context)
        context_layout.addWidget(context_slider)
        context_value_label = QLabel(f"{context_window_size} segments")
        context_value_label.setMinimumWidth(100)
        context_layout.addWidget(context_value_label)
        context_layout.addStretch()
        prefs_layout.addLayout(context_layout)
        
        # Update label when slider changes
        def update_context_label(value):
            if value == 0:
                context_value_label.setText("0 (disabled)")
            else:
                total_segs = len(self.current_project.segments) if self.current_project else 300
                context_segs = min(value * 2 + batch_size_spin.value(), total_segs)
                percentage = int((context_segs / total_segs) * 100) if total_segs > 0 else 0
                context_value_label.setText(f"{value} seg (~{percentage}% of doc)")
        
        context_slider.valueChanged.connect(update_context_label)
        full_context_cb.stateChanged.connect(lambda: context_slider.setEnabled(full_context_cb.isChecked()))
        update_context_label(context_window_size)
        
        prefs_layout.addSpacing(10)
        
        # Document context for AI prompts
        quickmenu_context_label = QLabel("<b>Document Context (for AI prompts):</b>")
        prefs_layout.addWidget(quickmenu_context_label)
        
        quickmenu_context_percent = general_prefs.get('quickmenu_context_percent', 50)
        quickmenu_context_layout = QHBoxLayout()
        quickmenu_context_layout.addWidget(QLabel("  Document context size:"))
        quickmenu_context_slider = QSlider(Qt.Orientation.Horizontal)
        quickmenu_context_slider.setMinimum(0)
        quickmenu_context_slider.setMaximum(100)
        quickmenu_context_slider.setValue(quickmenu_context_percent)
        quickmenu_context_slider.setTickPosition(QSlider.TickPosition.TicksBelow)
        quickmenu_context_slider.setTickInterval(10)
        quickmenu_context_layout.addWidget(quickmenu_context_slider)
        quickmenu_context_value_label = QLabel(f"{quickmenu_context_percent}%")
        quickmenu_context_value_label.setMinimumWidth(60)
        quickmenu_context_layout.addWidget(quickmenu_context_value_label)
        quickmenu_context_layout.addStretch()
        prefs_layout.addLayout(quickmenu_context_layout)
        
        quickmenu_context_info = QLabel(
            "  ‚ìò When using {{SOURCE+TARGET_CONTEXT}} or {{SOURCE_CONTEXT}} placeholders in QuickMenu prompts.\n"
            "  0% = disabled, 50% = half the document (default), 100% = entire document.\n"
            "  Limit: maximum 100 segments for performance."
        )
        quickmenu_context_info.setStyleSheet("font-size: 9pt; color: #666; padding-left: 20px;")
        quickmenu_context_info.setWordWrap(True)
        prefs_layout.addWidget(quickmenu_context_info)
        
        def update_quickmenu_context_label(value):
            if value == 0:
                quickmenu_context_value_label.setText("0% (disabled)")
            else:
                quickmenu_context_value_label.setText(f"{value}%")
        
        quickmenu_context_slider.valueChanged.connect(update_quickmenu_context_label)
        
        prefs_layout.addSpacing(5)
        
        # Check TM before API call - with fuzzy or exact mode (single-segment translation only)
        tm_check_label = QLabel("<b>Check TM before single-segment AI translation (Ctrl+T):</b>")
        prefs_layout.addWidget(tm_check_label)
        
        # Get current settings
        check_tm_exact_only = general_prefs.get('check_tm_exact_only', False)
        
        # Radio buttons for TM check mode
        tm_no_check_rb = CheckmarkRadioButton("Don't check TM - always call AI")
        tm_fuzzy_rb = CheckmarkRadioButton("Check TM first (including fuzzy matches)")
        tm_exact_rb = CheckmarkRadioButton("Check TM first (only 100% matches - faster)")
        
        # Set initial state
        if not check_tm_before_api:
            tm_no_check_rb.setChecked(True)
        elif check_tm_exact_only:
            tm_exact_rb.setChecked(True)
        else:
            tm_fuzzy_rb.setChecked(True)
        
        prefs_layout.addWidget(tm_no_check_rb)
        prefs_layout.addWidget(tm_fuzzy_rb)
        prefs_layout.addWidget(tm_exact_rb)
        
        prefs_layout.addSpacing(5)
        
        # Auto-propagate 100% TM matches
        auto_propagate_cb = CheckmarkCheckBox("Auto-propagate 100% TM matches")
        auto_propagate_cb.setChecked(auto_propagate_100)
        prefs_layout.addWidget(auto_propagate_cb)
        
        prefs_layout.addSpacing(5)
        
        # TM/Termbase lookup delay
        lookup_delay = general_prefs.get('lookup_delay', 1500)
        delay_layout = QHBoxLayout()
        delay_label = QLabel("TM/Glossary lookup delay:")
        delay_layout.addWidget(delay_label)
        delay_spin = QSpinBox()
        delay_spin.setMinimum(0)
        delay_spin.setMaximum(10000)
        delay_spin.setSingleStep(100)
        delay_spin.setValue(lookup_delay)
        delay_spin.setSuffix(" ms")
        delay_layout.addWidget(delay_spin)
        delay_layout.addStretch()
        prefs_layout.addLayout(delay_layout)
        delay_info = QLabel("  ‚ìò Prevents searches while navigating quickly. Default: 1500ms")
        delay_info.setStyleSheet("font-size: 9pt; color: #666; padding-left: 20px;")
        prefs_layout.addWidget(delay_info)
        
        prefs_group.setLayout(prefs_layout)
        layout.addWidget(prefs_group)
        
        # ========== SECTION 6: AI Behavior Settings ==========
        behavior_group = QGroupBox("üéØ AI Behavior Settings")
        behavior_layout = QVBoxLayout()
        
        # LLM matching toggle
        llm_matching_cb = CheckmarkCheckBox("Enable LLM (AI) matching on segment selection")
        llm_matching_cb.setChecked(self.enable_llm_matching)
        llm_matching_cb.setToolTip(
            "‚ö†Ô∏è WARNING: LLM translations take 10-20 seconds per segment!\n\n"
            "When enabled, AI translations are automatically generated when you select a segment.\n"
            "RECOMMENDED: Keep DISABLED. Use 'Translate with AI' button instead."
        )
        behavior_layout.addWidget(llm_matching_cb)
        self.llm_matching_checkbox = llm_matching_cb
        
        # Auto-generate markdown
        auto_markdown_cb = CheckmarkCheckBox("Auto-generate markdown for imported documents")
        auto_markdown_cb.setChecked(general_settings.get('auto_generate_markdown', False))
        auto_markdown_cb.setToolTip(
            "Automatically convert imported documents to markdown format\n"
            "for AI Assistant access in user_data_private/ai_assistant/current_document/"
        )
        behavior_layout.addWidget(auto_markdown_cb)
        
        # LLM match limits
        behavior_layout.addSpacing(10)
        llm_limits_label = QLabel("<b>LLM Match Limits:</b>")
        behavior_layout.addWidget(llm_limits_label)
        
        current_limits = general_settings.get('match_limits', {"LLM": 3, "MT": 3, "TM": 5, "Termbases": 10})
        
        llm_limit_layout = QHBoxLayout()
        llm_limit_layout.addWidget(QLabel("üß† Maximum LLM matches to display:"))
        llm_spin = QSpinBox()
        llm_spin.setRange(1, 10)
        llm_spin.setValue(current_limits.get("LLM", 3))
        llm_spin.setSuffix(" matches")
        llm_limit_layout.addWidget(llm_spin)
        llm_limit_layout.addStretch()
        behavior_layout.addLayout(llm_limit_layout)
        
        behavior_group.setLayout(behavior_layout)
        layout.addWidget(behavior_group)

        # ========== SAVE BUTTON ==========
        save_btn = QPushButton("üíæ Save AI Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px; outline: none;")
        save_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        save_btn.clicked.connect(lambda: self._save_ai_settings_from_ui(
            openai_radio, claude_radio, gemini_radio, ollama_radio,
            openai_combo, claude_combo, gemini_combo,
            tab.ollama_status_widget,
            openai_enable_cb, claude_enable_cb, gemini_enable_cb, ollama_enable_cb,
            batch_size_spin, surrounding_spin, full_context_cb, context_slider,
            tm_no_check_rb, tm_fuzzy_rb, tm_exact_rb, auto_propagate_cb, delay_spin,
            ollama_keepwarm_cb,
            llm_matching_cb, auto_markdown_cb, llm_spin,
            quickmenu_context_slider
        ))
        layout.addWidget(save_btn)
        
        layout.addStretch()
        
        return tab
    
    def _create_mt_settings_tab(self):
        """Create MT Settings tab content"""
        from PyQt6.QtWidgets import QCheckBox, QGroupBox, QPushButton
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        enabled_providers = self.load_provider_enabled_states()
        
        # Enable/Disable MT Providers
        mt_provider_group = QGroupBox("Machine Translation Providers")
        mt_provider_layout = QVBoxLayout()
        
        mt_info = QLabel(
            "Enable or disable individual MT providers. Supervertaler will use the first available enabled provider in priority order:\n"
            "1. Google Translate, 2. DeepL, 3. Microsoft Translator, 4. Amazon Translate, 5. ModernMT, 6. MyMemory"
        )
        mt_info.setWordWrap(True)
        mt_info.setStyleSheet("font-size: 9pt; color: #666; padding: 5px;")
        mt_provider_layout.addWidget(mt_info)
        
        google_translate_enable_cb = CheckmarkCheckBox("Enable Google Translate")
        google_translate_enable_cb.setChecked(enabled_providers.get('mt_google_translate', True))
        mt_provider_layout.addWidget(google_translate_enable_cb)
        
        deepl_enable_cb = CheckmarkCheckBox("Enable DeepL")
        deepl_enable_cb.setChecked(enabled_providers.get('mt_deepl', True))
        mt_provider_layout.addWidget(deepl_enable_cb)
        
        microsoft_enable_cb = CheckmarkCheckBox("Enable Microsoft Translator")
        microsoft_enable_cb.setChecked(enabled_providers.get('mt_microsoft', True))
        mt_provider_layout.addWidget(microsoft_enable_cb)
        
        amazon_enable_cb = CheckmarkCheckBox("Enable Amazon Translate")
        amazon_enable_cb.setChecked(enabled_providers.get('mt_amazon', True))
        mt_provider_layout.addWidget(amazon_enable_cb)
        
        modernmt_enable_cb = CheckmarkCheckBox("Enable ModernMT")
        modernmt_enable_cb.setChecked(enabled_providers.get('mt_modernmt', True))
        mt_provider_layout.addWidget(modernmt_enable_cb)
        
        mymemory_enable_cb = CheckmarkCheckBox("Enable MyMemory (Free tier)")
        mymemory_enable_cb.setChecked(enabled_providers.get('mt_mymemory', True))
        mt_provider_layout.addWidget(mymemory_enable_cb)
        
        mt_provider_group.setLayout(mt_provider_layout)
        layout.addWidget(mt_provider_group)
        
        # API Keys info for MT
        mt_api_keys_group = QGroupBox("API Keys")
        mt_api_keys_layout = QVBoxLayout()
        
        mt_api_keys_info = QLabel(
            f"Configure your MT API keys in:<br>"
            f"<code>{self.user_data_path / 'api_keys.txt'}</code><br><br>"
            f"See example file for format:<br>"
            f"<code>{self.user_data_path / 'api_keys.example.txt'}</code>"
        )
        mt_api_keys_info.setWordWrap(True)
        mt_api_keys_layout.addWidget(mt_api_keys_info)
        
        # Button to open API keys file
        mt_open_keys_btn = QPushButton("üìù Open API Keys File")
        mt_open_keys_btn.clicked.connect(lambda: self.open_api_keys_file())
        mt_api_keys_layout.addWidget(mt_open_keys_btn)
        
        mt_api_keys_group.setLayout(mt_api_keys_layout)
        layout.addWidget(mt_api_keys_group)
        
        # Save button
        save_btn = QPushButton("üíæ Save MT Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        save_btn.clicked.connect(lambda: self._save_mt_settings_from_ui(
            google_translate_enable_cb, deepl_enable_cb, microsoft_enable_cb,
            amazon_enable_cb, modernmt_enable_cb, mymemory_enable_cb
        ))
        layout.addWidget(save_btn)
        
        layout.addStretch()
        
        return tab
    
    def _find_autohotkey_for_settings(self):
        """Find AutoHotkey executable for settings display (doesn't modify state)"""
        # Standard installation paths
        username = os.environ.get('USERNAME', '')
        ahk_paths = [
            r"C:\Program Files\AutoHotkey\v2\AutoHotkey.exe",
            r"C:\Program Files\AutoHotkey\v2\AutoHotkey64.exe",
            r"C:\Program Files\AutoHotkey\AutoHotkey.exe",
            r"C:\Program Files (x86)\AutoHotkey\AutoHotkey.exe",
            fr"C:\Users\{username}\AppData\Local\Programs\AutoHotkey\AutoHotkey.exe",
        ]
        
        for path in ahk_paths:
            if os.path.exists(path):
                return path, 'detected'
        
        return None, None
    
    def _browse_autohotkey_for_settings(self, line_edit):
        """Browse for AutoHotkey executable and update line edit"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Locate AutoHotkey Executable",
            "C:\\Program Files",
            "Executable Files (*.exe);;All Files (*.*)"
        )
        
        if file_path:
            line_edit.setText(file_path)
    
    def _create_general_settings_tab(self):
        """Create General Settings tab content"""
        from PyQt6.QtWidgets import QCheckBox, QGroupBox, QPushButton, QLineEdit, QFileDialog
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        general_settings = self.load_general_settings()
        
        # Startup Settings group
        startup_group = QGroupBox("Startup Settings")
        startup_layout = QVBoxLayout()
        
        restore_last_project_cb = CheckmarkCheckBox("Restore last project on startup")
        restore_last_project_cb.setChecked(general_settings.get('restore_last_project', False))
        restore_last_project_cb.setToolTip(
            "When enabled, Supervertaler will automatically open the last project you were working on when the application starts."
        )
        startup_layout.addWidget(restore_last_project_cb)
        
        auto_open_log_cb = CheckmarkCheckBox("Auto-open log window on startup (detached)")
        auto_open_log_cb.setChecked(general_settings.get('auto_open_log', False))
        auto_open_log_cb.setToolTip(
            "When enabled, the log window will automatically open in a separate detached window when Supervertaler starts."
        )
        startup_layout.addWidget(auto_open_log_cb)
        
        startup_group.setLayout(startup_layout)
        layout.addWidget(startup_group)

        # Data Folder Location group
        data_folder_group = QGroupBox("üìÅ Data Folder Location")
        data_folder_layout = QVBoxLayout()
        
        data_folder_info = QLabel(
            "Your translation memories, glossaries, prompts, and settings are stored here:"
        )
        data_folder_info.setWordWrap(True)
        data_folder_layout.addWidget(data_folder_info)
        
        # Path display with browse button
        path_row = QHBoxLayout()
        
        data_path_edit = QLineEdit()
        data_path_edit.setText(str(self.user_data_path))
        data_path_edit.setReadOnly(True)
        data_path_edit.setToolTip("Current data folder location")
        path_row.addWidget(data_path_edit)
        
        change_path_btn = QPushButton("Change...")
        change_path_btn.setToolTip("Choose a different location for your data folder")
        
        def change_data_path():
            """Let user change their data folder location."""
            from PyQt6.QtWidgets import QMessageBox
            
            folder = QFileDialog.getExistingDirectory(
                self, 
                "Choose New Data Folder Location",
                str(Path.home())
            )
            if folder:
                folder_path = Path(folder)
                # Append "Supervertaler" if user didn't include it
                if folder_path.name != "Supervertaler":
                    folder_path = folder_path / "Supervertaler"
                
                # Warn if switching to a folder with existing data
                if folder_path.exists() and folder_path != self.user_data_path:
                    has_content = any(folder_path.iterdir())
                    if has_content:
                        reply = QMessageBox.question(
                            self,
                            "Existing Data Found",
                            f"The folder already contains data:\n{folder_path}\n\n"
                            "Do you want to use this existing data?",
                            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel
                        )
                        if reply != QMessageBox.StandardButton.Yes:
                            return
                
                # Create the folder
                folder_path.mkdir(parents=True, exist_ok=True)
                
                # Ask if they want to copy existing data
                if self.user_data_path.exists() and self.user_data_path != folder_path:
                    reply = QMessageBox.question(
                        self,
                        "Copy Existing Data?",
                        f"Would you like to copy your existing data to the new location?\n\n"
                        f"From: {self.user_data_path}\n"
                        f"To: {folder_path}\n\n"
                        "This will NOT delete the original data.",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                    if reply == QMessageBox.StandardButton.Yes:
                        import shutil
                        try:
                            for item in self.user_data_path.iterdir():
                                dest = folder_path / item.name
                                if item.is_dir():
                                    shutil.copytree(item, dest, dirs_exist_ok=True)
                                else:
                                    shutil.copy2(item, dest)
                            self.log(f"‚úÖ Copied data to new location")
                        except Exception as e:
                            QMessageBox.warning(self, "Copy Error", f"Failed to copy data: {e}")
                
                # Save the new path
                save_user_data_path(folder_path)
                data_path_edit.setText(str(folder_path))
                
                # Update and reinitialize
                self.user_data_path = folder_path
                self._reinitialize_with_new_data_path()
                
                QMessageBox.information(
                    self,
                    "Data Folder Changed",
                    f"Data folder changed to:\n{folder_path}\n\n"
                    "All managers have been reinitialized."
                )
        
        change_path_btn.clicked.connect(change_data_path)
        path_row.addWidget(change_path_btn)
        
        open_folder_btn = QPushButton("Open")
        open_folder_btn.setToolTip("Open this folder in your file manager")
        open_folder_btn.clicked.connect(lambda: os.startfile(str(self.user_data_path)) if sys.platform == 'win32' 
                                         else subprocess.run(['xdg-open' if sys.platform == 'linux' else 'open', str(self.user_data_path)]))
        path_row.addWidget(open_folder_btn)
        
        data_folder_layout.addLayout(path_row)
        
        data_folder_tip = QLabel(
            "üí° This folder persists across updates. Back it up regularly!"
        )
        data_folder_tip.setStyleSheet("color: #666; font-size: 9pt;")
        data_folder_layout.addWidget(data_folder_tip)
        
        data_folder_group.setLayout(data_folder_layout)
        layout.addWidget(data_folder_group)

        # Sound Effects group
        sound_group = QGroupBox("üîä Sound Effects")
        sound_layout = QVBoxLayout()

        sound_effects_cb = CheckmarkCheckBox("Enable minimalist sound effects")
        sound_effects_cb.setChecked(general_settings.get('enable_sound_effects', False))
        sound_effects_cb.setToolTip(
            "Plays a subtle system beep for certain operations (e.g. glossary creation, match insertion).\n"
            "Disable if you prefer a silent workflow."
        )
        sound_layout.addWidget(sound_effects_cb)

        # Per-event sound mapping (Windows system beeps)
        sound_effects_map = general_settings.get('sound_effects_map', {})
        sound_choices = [
            ("(None)", "none"),
            ("OK", "ok"),
            ("Asterisk", "asterisk"),
            ("Exclamation", "exclamation"),
            ("Hand", "hand"),
            ("Question", "question"),
            ("Windows Proximity Notification (.wav)", "windows_proximity_wav"),
            ("Windows Restore (.wav)", "windows_restore_wav"),
            ("Windows Navigation Start (.wav)", "windows_navigation_start_wav"),
            ("Speech Disambiguation (.wav)", "speech_disambiguation_wav"),
            ("Windows Startup (.wav)", "windows_startup_wav"),
        ]

        def make_sound_combo(default_key: str) -> QComboBox:
            combo = QComboBox()
            for label, key in sound_choices:
                combo.addItem(label, key)
            # Set initial
            idx = combo.findData(default_key)
            if idx >= 0:
                combo.setCurrentIndex(idx)
            return combo

        event_rows = QFormLayout()
        event_rows.setContentsMargins(0, 0, 0, 0)
        event_rows.setSpacing(6)

        # Store combos so save button can persist them
        sound_event_combos = {}

        # Glossary entry added (term pair)
        default_term_added = sound_effects_map.get('glossary_term_added', 'asterisk')
        sound_event_combos['glossary_term_added'] = make_sound_combo(default_term_added)
        event_rows.addRow("Glossary entry added:", sound_event_combos['glossary_term_added'])

        # Glossary created (collection)
        default_glossary_created = sound_effects_map.get('glossary_created', 'asterisk')
        sound_event_combos['glossary_created'] = make_sound_combo(default_glossary_created)
        event_rows.addRow("Glossary created:", sound_event_combos['glossary_created'])

        # Compare Panel match inserted/replaced
        default_match_inserted = sound_effects_map.get('match_inserted', 'ok')
        sound_event_combos['match_inserted'] = make_sound_combo(default_match_inserted)
        event_rows.addRow("Match inserted/replaced:", sound_event_combos['match_inserted'])

        # Glossary entry duplicate
        default_term_duplicate = sound_effects_map.get('glossary_term_duplicate', 'exclamation')
        sound_event_combos['glossary_term_duplicate'] = make_sound_combo(default_term_duplicate)
        event_rows.addRow("Glossary entry duplicate:", sound_event_combos['glossary_term_duplicate'])

        # Glossary add error
        default_term_error = sound_effects_map.get('glossary_term_error', 'hand')
        sound_event_combos['glossary_term_error'] = make_sound_combo(default_term_error)
        event_rows.addRow("Glossary add error:", sound_event_combos['glossary_term_error'])

        # Segment confirmed (Ctrl+Enter)
        default_segment_confirmed = sound_effects_map.get('segment_confirmed', 'none')
        sound_event_combos['segment_confirmed'] = make_sound_combo(default_segment_confirmed)
        event_rows.addRow("Segment confirmed:", sound_event_combos['segment_confirmed'])

        # 100% TM match found
        default_tm_100_match = sound_effects_map.get('tm_100_percent_match', 'none')
        sound_event_combos['tm_100_percent_match'] = make_sound_combo(default_tm_100_match)
        event_rows.addRow("100% TM match alert:", sound_event_combos['tm_100_percent_match'])

        # Fuzzy TM match found (< 100%)
        default_tm_fuzzy_match = sound_effects_map.get('tm_fuzzy_match', 'none')
        sound_event_combos['tm_fuzzy_match'] = make_sound_combo(default_tm_fuzzy_match)
        event_rows.addRow("Fuzzy TM match found:", sound_event_combos['tm_fuzzy_match'])

        sound_layout.addLayout(event_rows)

        sound_note = QLabel("üí° Uses Windows system beeps (no audio files).")
        sound_note.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        sound_layout.addWidget(sound_note)

        sound_group.setLayout(sound_layout)
        layout.addWidget(sound_group)

        # Auto Backup Settings group
        backup_group = QGroupBox("üíæ Auto Backup Settings")
        backup_layout = QVBoxLayout()

        backup_info = QLabel(
            "Supervertaler can automatically back up your project at regular intervals\n"
            "to prevent data loss. Both a project.json and TMX file will be saved."
        )
        backup_info.setWordWrap(True)
        backup_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        backup_layout.addWidget(backup_info)

        # Enable auto backup checkbox
        enable_backup_cb = CheckmarkCheckBox("Enable automatic backups")
        enable_backup_cb.setChecked(general_settings.get('enable_auto_backup', True))
        enable_backup_cb.setToolTip(
            "When enabled, Supervertaler will automatically save your project and export\n"
            "a TMX file at the configured interval. This helps prevent data loss."
        )
        backup_layout.addWidget(enable_backup_cb)

        # Backup interval spinner
        interval_layout = QHBoxLayout()
        interval_label = QLabel("Backup interval:")
        interval_layout.addWidget(interval_label)

        backup_interval_spin = QSpinBox()
        backup_interval_spin.setRange(1, 60)
        backup_interval_spin.setValue(general_settings.get('backup_interval_minutes', 5))
        backup_interval_spin.setSuffix(" minutes")
        backup_interval_spin.setToolTip(
            "Set how often Supervertaler should automatically save your project.\n"
            "Default: 5 minutes. Range: 1-60 minutes."
        )
        interval_layout.addWidget(backup_interval_spin)
        interval_layout.addStretch()
        backup_layout.addLayout(interval_layout)

        backup_group.setLayout(backup_layout)
        layout.addWidget(backup_group)

        # Store references for saving
        self.enable_backup_cb = enable_backup_cb
        self.backup_interval_spin = backup_interval_spin

        # TM and glossary settings section
        tm_termbase_group = QGroupBox("TM and glossary settings")
        tm_termbase_layout = QVBoxLayout()
        
        # Auto-propagate exact TM matches
        auto_propagate_cb = CheckmarkCheckBox("Auto-propagate exact TM matches (100%)")
        auto_propagate_cb.setChecked(general_settings.get('auto_propagate_exact_matches', True))
        auto_propagate_cb.setToolTip(
            "Automatically fill target with 100% TM matches when a segment is selected and empty.\n"
            "This saves time by applying exact matches without manual confirmation."
        )
        tm_termbase_layout.addWidget(auto_propagate_cb)
        
        # Auto-insert 100% matches on segment selection
        auto_insert_100_cb = CheckmarkCheckBox("Auto-insert 100% TM matches when selecting segment")
        auto_insert_100_cb.setChecked(general_settings.get('auto_insert_100_percent_matches', True))
        auto_insert_100_cb.setToolTip(
            "When enabled, 100% TM matches are automatically inserted into the target field\n"
            "as soon as you select a segment (even if target is not empty).\n"
            "Like memoQ's auto-propagation feature for exact matches."
        )
        tm_termbase_layout.addWidget(auto_insert_100_cb)
        
        # Auto-confirm 100% matches when navigating with Ctrl+Enter
        auto_confirm_100_cb = CheckmarkCheckBox("Auto-confirm 100% TM matches when navigating (Ctrl+Enter)")
        auto_confirm_100_cb.setChecked(general_settings.get('auto_confirm_100_percent_matches', False))
        auto_confirm_100_cb.setToolTip(
            "When enabled, Ctrl+Enter will automatically insert, confirm, and skip past\n"
            "segments that have 100% TM matches. This speeds up workflow by automatically\n"
            "handling perfect matches while navigating through unconfirmed segments."
        )
        tm_termbase_layout.addWidget(auto_confirm_100_cb)
        
        # Sub-option: Allow overwriting existing translations
        auto_confirm_overwrite_cb = CheckmarkCheckBox("    ‚Ü≥ Also overwrite existing translations with 100% TM matches")
        auto_confirm_overwrite_cb.setChecked(general_settings.get('auto_confirm_overwrite_existing', False))
        auto_confirm_overwrite_cb.setToolTip(
            "When enabled, auto-confirm will also replace existing target content\n"
            "(including pre-translations or machine translations) with 100% TM matches.\n\n"
            "Useful when you've confirmed a segment higher up, and want identical segments\n"
            "lower down to automatically use your confirmed translation."
        )
        auto_confirm_overwrite_cb.setEnabled(auto_confirm_100_cb.isChecked())
        auto_confirm_100_cb.toggled.connect(auto_confirm_overwrite_cb.setEnabled)
        tm_termbase_layout.addWidget(auto_confirm_overwrite_cb)
        
        # TM Save Mode
        tm_save_label = QLabel("TM Save Mode:")
        tm_save_mode_combo = QComboBox()
        tm_save_mode_combo.addItem("Save all translations (with timestamps)", "all")
        tm_save_mode_combo.addItem("Save only latest translation (overwrite)", "latest")
        current_tm_mode = general_settings.get('tm_save_mode', 'latest')
        tm_save_mode_combo.setCurrentIndex(0 if current_tm_mode == 'all' else 1)
        tm_save_mode_combo.setToolTip(
            "All translations: Keeps all versions of translations for the same source segment with timestamps.\n"
            "The system will prefer the most recent translation when showing matches.\n\n"
            "Latest only: Overwrites old translations - only the most recent translation is kept.\n"
            "This prevents the TM from growing with old/obsolete translations."
        )
        tm_save_layout_h = QHBoxLayout()
        tm_save_layout_h.addWidget(tm_save_label)
        tm_save_layout_h.addWidget(tm_save_mode_combo)
        tm_save_layout_h.addStretch()
        tm_termbase_layout.addLayout(tm_save_layout_h)
        
        # TM/Glossary matching toggle
        tm_matching_cb = CheckmarkCheckBox("Enable TM && Glossary Matching")
        tm_matching_cb.setChecked(self.enable_tm_matching)  # Load current state
        tm_matching_cb.setToolTip(
            "When enabled, TM and glossary searches are performed automatically\n"
            "when you select a segment (after a 1.5 second delay). Disable to improve performance\n"
            "when navigating quickly through segments."
        )
        tm_matching_cb.toggled.connect(self.toggle_tm_termbase_matching)
        tm_termbase_layout.addWidget(tm_matching_cb)
        
        # Glossary grid highlighting toggle
        tb_highlight_cb = CheckmarkCheckBox("Highlight glossary matches in source cells")
        tb_highlight_cb.setChecked(general_settings.get('enable_termbase_grid_highlighting', True))
        tb_highlight_cb.setToolTip(
            "When enabled, glossary matches are highlighted with colored backgrounds in the source column.\n"
            "Higher priority terms are shown with darker blue, lower priority with lighter blue.\n"
            "This provides visual feedback similar to memoQ's termbase highlighting."
        )
        tm_termbase_layout.addWidget(tb_highlight_cb)

        # Glossary display order
        tb_order_label = QLabel("Glossary match display order:")
        tb_order_combo = QComboBox()
        tb_order_combo.addItem("Order of appearance in source text", "appearance")
        tb_order_combo.addItem("Alphabetical (A-Z)", "alphabetical")
        tb_order_combo.addItem("By length (longest first)", "length")
        current_order = general_settings.get('termbase_display_order', 'appearance')
        order_index = {'appearance': 0, 'alphabetical': 1, 'length': 2}.get(current_order, 0)
        tb_order_combo.setCurrentIndex(order_index)
        tb_order_combo.setToolTip(
            "Choose how glossary matches are sorted in the translation results panel:\n\n"
            "‚Ä¢ Order of appearance: Matches appear in the order they occur in the source text (default)\n"
            "‚Ä¢ Alphabetical: Matches are sorted alphabetically by source term (A-Z)\n"
            "‚Ä¢ By length: Longer matches appear first (useful for prioritizing multi-word terms)"
        )
        tb_order_layout = QHBoxLayout()
        tb_order_layout.addWidget(tb_order_label)
        tb_order_layout.addWidget(tb_order_combo)
        tb_order_layout.addStretch()
        tm_termbase_layout.addLayout(tb_order_layout)

        # Hide shorter matches checkbox
        tb_hide_shorter_cb = CheckmarkCheckBox("Hide shorter glossary matches included in longer ones")
        tb_hide_shorter_cb.setChecked(general_settings.get('termbase_hide_shorter_matches', False))
        tb_hide_shorter_cb.setToolTip(
            "When enabled, shorter terms that are fully contained within longer matched terms are hidden.\n\n"
            "Example: If both 'cooling' and 'cooling system' match, only 'cooling system' is shown.\n"
            "This reduces clutter in the translation results panel."
        )
        tm_termbase_layout.addWidget(tb_hide_shorter_cb)

        self.tm_matching_checkbox = tm_matching_cb  # Store reference for updates
        self.auto_propagate_checkbox = auto_propagate_cb  # Store reference for updates
        self.auto_insert_100_checkbox = auto_insert_100_cb  # Store reference for updates
        self.tb_highlight_checkbox = tb_highlight_cb  # Store reference for updates

        tm_termbase_group.setLayout(tm_termbase_layout)
        layout.addWidget(tm_termbase_group)

        # Editor Settings group
        editor_group = QGroupBox("‚úçÔ∏è Editor Settings")
        editor_layout = QVBoxLayout()

        # Smart word selection toggle
        smart_selection_cb = CheckmarkCheckBox("Enable smart word selection")
        smart_selection_cb.setChecked(general_settings.get('enable_smart_word_selection', True))
        smart_selection_cb.setToolTip(
            "When enabled, selecting part of a word automatically expands to the full word.\n\n"
            "Example: Selecting 'ductiv' in 'productivity' will automatically select the full word 'productivity'.\n\n"
            "This makes word selection faster and less stressful during translation.\n"
            "Works with hyphens (self-contained) and apostrophes (don't, l'homme)."
        )
        editor_layout.addWidget(smart_selection_cb)
        self.smart_selection_checkbox = smart_selection_cb  # Store reference

        editor_group.setLayout(editor_layout)
        layout.addWidget(editor_group)

        # AutoHotkey Settings group (Windows only - for Superlookup global hotkey)
        if os.name == 'nt':
            ahk_group = QGroupBox("‚å®Ô∏è AutoHotkey Settings (Superlookup Global Hotkey)")
            ahk_layout = QVBoxLayout()
            
            ahk_info = QLabel(
                "AutoHotkey enables the global hotkey (Ctrl+Alt+L) for Superlookup,\n"
                "allowing you to look up selected text from any application."
            )
            ahk_info.setWordWrap(True)
            ahk_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
            ahk_layout.addWidget(ahk_info)
            
            # Current status
            ahk_status_layout = QHBoxLayout()
            ahk_status_label = QLabel("Status:")
            ahk_status_layout.addWidget(ahk_status_label)
            
            # Check if hotkey is registered
            hotkey_active = False
            if hasattr(self, 'lookup_tab') and hasattr(self.lookup_tab, 'hotkey_registered'):
                hotkey_active = self.lookup_tab.hotkey_registered
            
            status_text = "‚úÖ Active" if hotkey_active else "‚ùå Not active"
            ahk_status_value = QLabel(status_text)
            ahk_status_value.setStyleSheet("font-weight: bold; color: green;" if hotkey_active else "font-weight: bold; color: #c00;")
            ahk_status_layout.addWidget(ahk_status_value)
            ahk_status_layout.addStretch()
            ahk_layout.addLayout(ahk_status_layout)
            
            # Path input
            ahk_path_layout = QHBoxLayout()
            ahk_path_label = QLabel("AutoHotkey Path:")
            ahk_path_layout.addWidget(ahk_path_label)
            
            ahk_path_edit = QLineEdit()
            ahk_path_edit.setPlaceholderText("Leave empty to auto-detect, or specify custom path...")
            saved_ahk_path = general_settings.get('autohotkey_path', '')
            ahk_path_edit.setText(saved_ahk_path)
            ahk_path_edit.setToolTip(
                "If AutoHotkey is installed in a non-standard location,\n"
                "specify the full path to AutoHotkey.exe here.\n"
                "Leave empty to use auto-detection."
            )
            ahk_path_layout.addWidget(ahk_path_edit, stretch=1)
            
            # Browse button
            ahk_browse_btn = QPushButton("üìÅ Browse...")
            ahk_browse_btn.setMaximumWidth(100)
            ahk_browse_btn.clicked.connect(lambda: self._browse_autohotkey_for_settings(ahk_path_edit))
            ahk_path_layout.addWidget(ahk_browse_btn)
            
            ahk_layout.addLayout(ahk_path_layout)
            
            # Detected path info
            detected_path, source = self._find_autohotkey_for_settings()
            if detected_path:
                detected_label = QLabel(f"üí° Detected: {detected_path}")
                detected_label.setStyleSheet("color: #666; font-size: 9pt;")
                ahk_layout.addWidget(detected_label)
            else:
                not_found_label = QLabel("‚ö†Ô∏è AutoHotkey not found. Download from autohotkey.com")
                not_found_label.setStyleSheet("color: #d97706; font-size: 9pt;")
                ahk_layout.addWidget(not_found_label)
            
            # Note about restart
            restart_note = QLabel("üí° Changes require restart to take effect.")
            restart_note.setStyleSheet("color: #666; font-size: 9pt; font-style: italic;")
            ahk_layout.addWidget(restart_note)
            
            ahk_group.setLayout(ahk_layout)
            layout.addWidget(ahk_group)
            
            # Store reference for saving
            self.ahk_path_edit = ahk_path_edit

        # Find & Replace settings group
        find_replace_group = QGroupBox("Find && Replace Settings")
        find_replace_layout = QVBoxLayout()
        
        allow_replace_cb = CheckmarkCheckBox("Allow Replace in Source Text")
        allow_replace_cb.setChecked(self.allow_replace_in_source)
        allow_replace_cb.setToolTip(
            "‚ö†Ô∏è WARNING: Enabling this allows replacing text in the source column.\n"
            "This can be dangerous as it modifies your original source text.\n"
            "Use with extreme caution!"
        )
        find_replace_layout.addWidget(allow_replace_cb)
        
        # Add warning label
        warning_label = QLabel(
            "‚ö†Ô∏è <b>Warning:</b> Replacing in source text modifies your original content.\n"
            "This feature is disabled by default for safety."
        )
        warning_label.setWordWrap(True)
        warning_label.setStyleSheet("color: #d97706; padding: 10px; border-radius: 3px;")
        find_replace_layout.addWidget(warning_label)
        
        find_replace_group.setLayout(find_replace_layout)
        layout.addWidget(find_replace_group)
        
        # Precision Scroll Settings group
        scroll_group = QGroupBox("‚¨ÜÔ∏è‚¨áÔ∏è Precision Scroll Settings")
        scroll_layout = QVBoxLayout()
        
        scroll_info = QLabel(
            "Configure how much the precision scroll buttons (‚ñ≤‚ñº) move the grid.\n"
            "Higher values = finer increments (smaller movements)."
        )
        scroll_info.setWordWrap(True)
        scroll_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        scroll_layout.addWidget(scroll_info)
        
        # Scroll increment slider/spinbox
        scroll_control_layout = QHBoxLayout()
        scroll_label = QLabel("Scroll precision:")
        scroll_control_layout.addWidget(scroll_label)
        
        precision_spin = QSpinBox()
        precision_spin.setRange(1, 10)
        precision_spin.setValue(general_settings.get('precision_scroll_divisor', 3))
        precision_spin.setSuffix(" (divisor)")
        precision_spin.setToolTip(
            "Control how far each button click scrolls the grid.\n\n"
            "1 = 50 pixels (coarse)\n"
            "3 = 40 pixels (default)\n"
            "5 = 30 pixels (fine)\n"
            "10 = 5 pixels (very fine)\n\n"
            "Higher values = smaller increments = more precise control."
        )
        scroll_control_layout.addWidget(precision_spin)
        
        # Preview label
        preview_label = QLabel()
        def update_preview(value):
            if value == 1:
                preview_label.setText("‚ÜïÔ∏è Coarse (full row)")
            elif value <= 3:
                preview_label.setText("‚ÜïÔ∏è Medium (default)")
            elif value <= 6:
                preview_label.setText("‚ÜïÔ∏è Fine")
            else:
                preview_label.setText("‚ÜïÔ∏è Very fine")
        update_preview(precision_spin.value())
        precision_spin.valueChanged.connect(update_preview)
        
        scroll_control_layout.addWidget(preview_label)
        scroll_control_layout.addStretch()
        scroll_layout.addLayout(scroll_control_layout)
        
        # Auto-center active segment toggle
        auto_center_cb = CheckmarkCheckBox("Keep active segment centered (like memoQ/Trados)")
        auto_center_cb.setChecked(general_settings.get('auto_center_active_segment', False))
        auto_center_cb.setToolTip(
            "When enabled, the grid automatically scrolls to keep the currently selected segment\n"
            "centered in the viewport when you navigate between segments.\n"
            "This matches the behavior of memoQ, Trados, and other CAT tools."
        )
        scroll_layout.addWidget(auto_center_cb)
        
        scroll_group.setLayout(scroll_layout)
        layout.addWidget(scroll_group)
        
        # Store references for saving
        self.precision_spin = precision_spin
        self.auto_center_cb = auto_center_cb
        
        # üß™ Experimental Performance group
        experimental_group = QGroupBox("üß™ Experimental Performance")
        experimental_layout = QVBoxLayout()
        
        exp_info = QLabel(
            "‚ö†Ô∏è These options are for testing and debugging performance.\n"
            "Use with caution - they may affect application behavior."
        )
        exp_info.setWordWrap(True)
        exp_info.setStyleSheet("color: #d97706; font-size: 9pt; padding: 5px;")
        experimental_layout.addWidget(exp_info)
        
        # Cache kill switch
        disable_cache_cb = CheckmarkCheckBox("Disable ALL caches (direct lookups every time)")
        disable_cache_cb.setChecked(general_settings.get('disable_all_caches', False))
        disable_cache_cb.setToolTip(
            "When enabled, ALL caching is bypassed:\n"
            "‚Ä¢ Termbase cache\n"
            "‚Ä¢ Translation matches cache\n"
            "‚Ä¢ Prefetch system\n\n"
            "Every segment navigation will perform fresh database lookups.\n"
            "Use this to test if caching is causing issues or to measure\n"
            "baseline performance without any caching."
        )
        experimental_layout.addWidget(disable_cache_cb)
        self.disable_cache_checkbox = disable_cache_cb
        
        experimental_group.setLayout(experimental_layout)
        layout.addWidget(experimental_group)
        
        # Translation Results Match Limits group
        match_limits_group = QGroupBox("üìä Translation Results - Match Limits")
        match_limits_layout = QVBoxLayout()
        
        info_label = QLabel(
            "Configure the maximum number of matches to display for each match type.\n"
            "Reducing limits improves performance and reduces clutter."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        match_limits_layout.addWidget(info_label)
        
        # Create spinboxes for each match type
        limits_grid = QVBoxLayout()
        limits_grid.setSpacing(5)
        
        current_limits = general_settings.get('match_limits', {
            "LLM": 3,
            "MT": 3,
            "TM": 5,
            "Termbases": 10
        })
        
        # LLM limit
        llm_layout = QHBoxLayout()
        llm_layout.addWidget(QLabel("üß† LLM (AI) matches:"))
        llm_spin = QSpinBox()
        llm_spin.setRange(1, 10)
        llm_spin.setValue(current_limits.get("LLM", 3))
        llm_spin.setSuffix(" matches")
        llm_layout.addWidget(llm_spin)
        llm_layout.addStretch()
        limits_grid.addLayout(llm_layout)
        
        # MT limit
        mt_layout = QHBoxLayout()
        mt_layout.addWidget(QLabel("ü§ñ MT (Machine Translation) matches:"))
        mt_spin = QSpinBox()
        mt_spin.setRange(1, 10)
        mt_spin.setValue(current_limits.get("MT", 3))
        mt_spin.setSuffix(" matches")
        mt_layout.addWidget(mt_spin)
        mt_layout.addStretch()
        limits_grid.addLayout(mt_layout)
        
        # TM limit
        tm_limit_layout = QHBoxLayout()
        tm_limit_layout.addWidget(QLabel("üíæ TM (Translation Memory) matches:"))
        tm_limit_spin = QSpinBox()
        tm_limit_spin.setRange(1, 20)
        tm_limit_spin.setValue(current_limits.get("TM", 5))
        tm_limit_spin.setSuffix(" matches")
        tm_limit_layout.addWidget(tm_limit_spin)
        tm_limit_layout.addStretch()
        limits_grid.addLayout(tm_limit_layout)
        
        # Glossary limit
        tb_layout = QHBoxLayout()
        tb_layout.addWidget(QLabel("üìö Glossary matches:"))
        tb_spin = QSpinBox()
        tb_spin.setRange(1, 50)
        tb_spin.setValue(current_limits.get("Termbases", 10))
        tb_spin.setSuffix(" matches")
        tb_layout.addWidget(tb_spin)
        tb_layout.addStretch()
        limits_grid.addLayout(tb_layout)
        
        match_limits_layout.addLayout(limits_grid)
        match_limits_group.setLayout(match_limits_layout)
        layout.addWidget(match_limits_group)
        
        # Save button
        save_btn = QPushButton("üíæ Save General Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        save_btn.clicked.connect(lambda: self._save_general_settings_from_ui(
            restore_last_project_cb, allow_replace_cb, auto_propagate_cb,
            llm_spin, mt_spin, tm_limit_spin, tb_spin,
            auto_open_log_cb, auto_insert_100_cb, tm_save_mode_combo, tb_highlight_cb,
            enable_backup_cb, backup_interval_spin,
            tb_order_combo, tb_hide_shorter_cb, smart_selection_cb,
            ahk_path_edit=getattr(self, 'ahk_path_edit', None),
            auto_center_cb=auto_center_cb,
            auto_confirm_100_cb=auto_confirm_100_cb,
            auto_confirm_overwrite_cb=auto_confirm_overwrite_cb,
            sound_effects_cb=sound_effects_cb,
            sound_event_combos=sound_event_combos,
            disable_cache_cb=disable_cache_cb
        ))
        layout.addWidget(save_btn)
        
        layout.addStretch()
        
        return tab
    
    def _create_view_settings_tab(self):
        """Create View Settings tab content"""
        from PyQt6.QtWidgets import QGroupBox, QPushButton, QButtonGroup, QColorDialog
        from PyQt6.QtGui import QColor
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        font_settings = self.load_general_settings()
        
        # Grid Text Font Settings section
        grid_group = QGroupBox("üìä Grid Text Font Settings")
        grid_layout = QVBoxLayout()
        
        grid_size_info = QLabel(
            "Set the default font family and size for the grid (source and target columns).\n"
            "You can also adjust size using View menu ‚Üí Grid Text Zoom.\n"
            "If your favourite font is missing, contact the developer!"
        )
        grid_size_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        grid_size_info.setWordWrap(True)
        grid_layout.addWidget(grid_size_info)
        
        # Font family dropdown
        grid_font_family_layout = QHBoxLayout()
        grid_font_family_layout.addWidget(QLabel("Font Family:"))
        grid_font_family_combo = QComboBox()
        font_families = ["Calibri", "Segoe UI", "Arial", "Consolas", "Verdana", 
                        "Times New Roman", "Georgia", "Courier New", "Tahoma", "Trebuchet MS"]
        grid_font_family_combo.addItems(font_families)
        current_font_family = font_settings.get('grid_font_family', self.default_font_family)
        if current_font_family in font_families:
            grid_font_family_combo.setCurrentText(current_font_family)
        else:
            grid_font_family_combo.setCurrentText("Calibri")
        grid_font_family_combo.setToolTip("Select the font family for grid text")
        grid_font_family_layout.addWidget(grid_font_family_combo)
        grid_font_family_layout.addStretch()
        grid_layout.addLayout(grid_font_family_layout)
        
        # Font size spinbox
        grid_spin_layout = QHBoxLayout()
        grid_spin_layout.addWidget(QLabel("Font Size:"))
        grid_font_spin = QSpinBox()
        grid_font_spin.setMinimum(7)
        grid_font_spin.setMaximum(72)
        grid_font_spin.setValue(font_settings.get('grid_font_size', 11))
        grid_font_spin.setSuffix(" pt")
        grid_font_spin.setToolTip("Grid font size (7-72 pt)")
        grid_font_spin.setMinimumHeight(28)
        grid_font_spin.setMinimumWidth(80)
        # Fix spinbox arrow buttons - ensure both up and down work correctly
        grid_font_spin.setStyleSheet("""
            QSpinBox {
                padding-right: 20px;
            }
            QSpinBox::up-button {
                width: 20px;
                height: 14px;
            }
            QSpinBox::down-button {
                width: 20px;
                height: 14px;
            }
        """)
        grid_spin_layout.addWidget(grid_font_spin)
        grid_spin_layout.addStretch()
        grid_layout.addLayout(grid_spin_layout)
        
        # Live preview section
        preview_label = QLabel("Preview:")
        preview_label.setStyleSheet("font-weight: bold; margin-top: 8px;")
        grid_layout.addWidget(preview_label)
        
        # Preview container with border to simulate grid
        preview_container = QFrame()
        preview_container.setFrameStyle(QFrame.Shape.Box | QFrame.Shadow.Sunken)
        preview_container.setStyleSheet("border: 1px solid #ccc;")
        preview_container_layout = QVBoxLayout(preview_container)
        preview_container_layout.setContentsMargins(0, 0, 0, 0)
        preview_container_layout.setSpacing(0)
        
        # Source row (read-only style - light gray background)
        source_preview = QLabel()
        source_preview.setTextFormat(Qt.TextFormat.RichText)
        source_preview.setWordWrap(True)
        source_preview.setStyleSheet("padding: 6px; border-bottom: 1px solid #ddd;")
        source_preview.setToolTip("Source text preview")
        preview_container_layout.addWidget(source_preview)
        
        # Target row (editable style - white background)
        target_preview = QLabel()
        target_preview.setTextFormat(Qt.TextFormat.RichText)
        target_preview.setWordWrap(True)
        target_preview.setStyleSheet("padding: 6px;")
        target_preview.setToolTip("Target text preview")
        preview_container_layout.addWidget(target_preview)
        
        grid_layout.addWidget(preview_container)
        
        # Function to update preview
        def update_font_preview():
            font_family = grid_font_family_combo.currentText()
            font_size = grid_font_spin.value()
            tag_color = font_settings.get('tag_highlight_color', '#7f0001')
            
            # Sample text with a tag
            source_html = f'<span style="font-family: {font_family}; font-size: {font_size}pt;">The <span style="background-color: {tag_color};">&lt;b&gt;</span>quick<span style="background-color: {tag_color};">&lt;/b&gt;</span> brown fox jumps.</span>'
            target_html = f'<span style="font-family: {font_family}; font-size: {font_size}pt;">De <span style="background-color: {tag_color};">&lt;b&gt;</span>snelle<span style="background-color: {tag_color};">&lt;/b&gt;</span> bruine vos springt.</span>'
            
            source_preview.setText(source_html)
            target_preview.setText(target_html)
        
        # Connect signals to update preview
        grid_font_family_combo.currentTextChanged.connect(update_font_preview)
        grid_font_spin.valueChanged.connect(update_font_preview)
        
        # Initial preview update
        update_font_preview()
        
        grid_group.setLayout(grid_layout)
        layout.addWidget(grid_group)
        
        # Translation Results Pane & Tag Coloring section
        results_group = QGroupBox("üìã Translation Results Pane && Tag Colors")
        results_layout = QVBoxLayout()
        
        results_size_info = QLabel(
            "Set the default font sizes for the translation results pane.\n"
            "You can also adjust these using View menu ‚Üí Translation Results Pane."
        )
        results_size_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        results_size_info.setWordWrap(True)
        results_layout.addWidget(results_size_info)
        
        # Match list font size
        match_spin_layout = QHBoxLayout()
        match_spin_layout.addWidget(QLabel("Match List Font Size:"))
        match_font_spin = QSpinBox()
        match_font_spin.setMinimum(7)
        match_font_spin.setMaximum(16)
        match_font_spin.setValue(font_settings.get('results_match_font_size', 9))
        match_font_spin.setSuffix(" pt")
        match_font_spin.setToolTip("Match list font size (7-16 pt)")
        match_spin_layout.addWidget(match_font_spin)
        match_spin_layout.addStretch()
        results_layout.addLayout(match_spin_layout)
        
        # Compare boxes font size
        compare_spin_layout = QHBoxLayout()
        compare_spin_layout.addWidget(QLabel("Compare Boxes Font Size:"))
        compare_font_spin = QSpinBox()
        compare_font_spin.setMinimum(7)
        compare_font_spin.setMaximum(14)
        compare_font_spin.setValue(font_settings.get('results_compare_font_size', 9))
        compare_font_spin.setSuffix(" pt")
        compare_font_spin.setToolTip("Compare boxes font size (7-14 pt)")
        compare_spin_layout.addWidget(compare_font_spin)
        compare_spin_layout.addStretch()
        results_layout.addLayout(compare_spin_layout)
        
        # Show tags checkbox
        show_tags_layout = QHBoxLayout()
        show_tags_check = CheckmarkCheckBox("Show HTML/XML tags in match text")
        show_tags_check.setChecked(font_settings.get('results_show_tags', False))
        show_tags_check.setToolTip("When enabled, tags like <b>, <li>, etc. are displayed. When disabled, only the text content is shown.")
        show_tags_layout.addWidget(show_tags_check)
        show_tags_layout.addStretch()
        results_layout.addLayout(show_tags_layout)
        
        # Tag highlight color picker
        tag_color_layout = QHBoxLayout()
        tag_color_layout.addWidget(QLabel("Tag Highlight Color:"))
        
        from PyQt6.QtWidgets import QColorDialog
        from PyQt6.QtGui import QColor
        
        # Get current tag color or default to memoQ dark red
        current_color = font_settings.get('tag_highlight_color', '#7f0001')
        tag_color_btn = QPushButton()
        tag_color_btn.setFixedSize(80, 25)
        tag_color_btn.setStyleSheet(f"background-color: {current_color}; border: 1px solid #999;")
        tag_color_btn.setToolTip("Color for CAT tool tags (e.g. <b>, [uicontrol], {MQ}) in the grid and results pane")
        
        def choose_tag_color():
            # Set up preset colors in the color dialog
            preset_colors = [
                '#7f0001',  # memoQ dark red (default)
                '#996666',  # Dusty rose
                '#9AAFC7',  # Slate blue
                '#B8A9C9',  # Dusty lavender
                '#A05050',  # Muted red
                '#FFB6C1',  # Light pink (old default)
                '#FF69B4',  # Hot pink
                '#D4A5A5',  # Muted rose
            ]
            for i, preset in enumerate(preset_colors):
                QColorDialog.setCustomColor(i, QColor(preset))
            
            color = QColorDialog.getColor(QColor(current_color), self, "Choose Tag Highlight Color")
            if color.isValid():
                hex_color = color.name()
                tag_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                tag_color_btn.setProperty('selected_color', hex_color)
        
        tag_color_btn.clicked.connect(choose_tag_color)
        tag_color_btn.setProperty('selected_color', current_color)
        tag_color_layout.addWidget(tag_color_btn)
        
        # Reset tag color button
        reset_tag_color_btn = QPushButton("Reset")
        reset_tag_color_btn.setFixedSize(50, 25)
        reset_tag_color_btn.setToolTip("Reset to default memoQ red (#7f0001)")
        def reset_tag_color():
            default_color = '#7f0001'
            tag_color_btn.setStyleSheet(f"background-color: {default_color}; border: 1px solid #999;")
            tag_color_btn.setProperty('selected_color', default_color)
        reset_tag_color_btn.clicked.connect(reset_tag_color)
        tag_color_layout.addWidget(reset_tag_color_btn)
        
        tag_color_layout.addStretch()
        results_layout.addLayout(tag_color_layout)

        # Badge text color picker
        badge_text_color_layout = QHBoxLayout()
        badge_text_color_layout.addWidget(QLabel("Badge Text Color:"))
        
        # Get current badge text color or default to dark gray
        current_badge_color = font_settings.get('badge_text_color', '#333333')
        badge_text_color_btn = QPushButton()
        badge_text_color_btn.setFixedSize(80, 25)
        badge_text_color_btn.setStyleSheet(f"background-color: {current_badge_color}; border: 1px solid #999;")
        badge_text_color_btn.setToolTip("Color for match number badges in Translation Results panel")
        
        def choose_badge_text_color():
            # Set up preset colors in the color dialog
            preset_colors = [
                '#333333',  # Dark gray (default)
                '#212121',  # Material Design off-black
                '#2C2C2C',  # Charcoal
                '#37474F',  # Slate gray
                '#000000',  # Pure black
                '#444444',  # Medium gray
                '#1A1A1A',  # Near black
                '#505050',  # Lighter gray
            ]
            for i, preset in enumerate(preset_colors):
                QColorDialog.setCustomColor(i, QColor(preset))
            
            color = QColorDialog.getColor(QColor(current_badge_color), self, "Choose Badge Text Color")
            if color.isValid():
                hex_color = color.name()
                badge_text_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                badge_text_color_btn.setProperty('selected_color', hex_color)
        
        badge_text_color_btn.clicked.connect(choose_badge_text_color)
        badge_text_color_btn.setProperty('selected_color', current_badge_color)
        badge_text_color_layout.addWidget(badge_text_color_btn)
        
        # Reset badge text color button
        reset_badge_text_color_btn = QPushButton("Reset")
        reset_badge_text_color_btn.setFixedSize(50, 25)
        reset_badge_text_color_btn.setToolTip("Reset to default dark gray (#333333)")
        def reset_badge_text_color():
            default_color = '#333333'
            badge_text_color_btn.setStyleSheet(f"background-color: {default_color}; border: 1px solid #999;")
            badge_text_color_btn.setProperty('selected_color', default_color)
        reset_badge_text_color_btn.clicked.connect(reset_badge_text_color)
        badge_text_color_layout.addWidget(reset_badge_text_color_btn)
        
        badge_text_color_layout.addStretch()
        results_layout.addLayout(badge_text_color_layout)

        # Invisible character color picker
        invisible_char_color_layout = QHBoxLayout()
        invisible_char_color_layout.addWidget(QLabel("Invisible Char Color:"))

        # Get current invisible character color or default to light gray
        current_invisible_color = font_settings.get('invisible_char_color', '#999999')
        invisible_char_color_btn = QPushButton()
        invisible_char_color_btn.setFixedSize(80, 25)
        invisible_char_color_btn.setStyleSheet(f"background-color: {current_invisible_color}; border: 1px solid #999;")
        invisible_char_color_btn.setToolTip("Color for invisible character symbols (¬∑‚Üí¬∞¬∂)")

        def choose_invisible_char_color():
            color = QColorDialog.getColor(QColor(current_invisible_color), self, "Choose Invisible Character Color")
            if color.isValid():
                hex_color = color.name()
                invisible_char_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                invisible_char_color_btn.setProperty('selected_color', hex_color)

        invisible_char_color_btn.clicked.connect(choose_invisible_char_color)
        invisible_char_color_btn.setProperty('selected_color', current_invisible_color)
        invisible_char_color_layout.addWidget(invisible_char_color_btn)
        
        # Reset invisible char color button
        reset_invisible_color_btn = QPushButton("Reset")
        reset_invisible_color_btn.setFixedSize(50, 25)
        reset_invisible_color_btn.setToolTip("Reset to default gray (#999999)")
        def reset_invisible_color():
            default_color = '#999999'
            invisible_char_color_btn.setStyleSheet(f"background-color: {default_color}; border: 1px solid #999;")
            invisible_char_color_btn.setProperty('selected_color', default_color)
        reset_invisible_color_btn.clicked.connect(reset_invisible_color)
        invisible_char_color_layout.addWidget(reset_invisible_color_btn)
        
        invisible_char_color_layout.addStretch()
        results_layout.addLayout(invisible_char_color_layout)

        results_group.setLayout(results_layout)
        layout.addWidget(results_group)

        # Grid Row Colors section (memoQ-style alternating row colors)
        row_colors_group = QGroupBox("üé® Grid Row Colors")
        row_colors_layout = QVBoxLayout()
        
        row_colors_info = QLabel(
            "Configure alternating row colors for the translation grid.\n"
            "This creates a visual distinction between rows (like memoQ)."
        )
        row_colors_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        row_colors_info.setWordWrap(True)
        row_colors_layout.addWidget(row_colors_info)
        
        # Enable alternating colors checkbox
        alt_colors_check = CheckmarkCheckBox("Enable alternating row colors")
        alt_colors_check.setChecked(font_settings.get('enable_alternating_row_colors', True))
        alt_colors_check.setToolTip("When enabled, even and odd rows have different background colors")
        row_colors_layout.addWidget(alt_colors_check)
        
        # Even row color picker (lighter/default)
        even_color_layout = QHBoxLayout()
        even_color_layout.addWidget(QLabel("Even Row Color:"))
        
        even_row_color = font_settings.get('even_row_color', '#FFFFFF')
        even_color_btn = QPushButton()
        even_color_btn.setFixedSize(80, 25)
        even_color_btn.setStyleSheet(f"background-color: {even_row_color}; border: 1px solid #999;")
        even_color_btn.setToolTip("Background color for even rows (0, 2, 4, ...)")
        
        def choose_even_color():
            color = QColorDialog.getColor(QColor(even_row_color), self, "Choose Even Row Color")
            if color.isValid():
                hex_color = color.name()
                even_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                even_color_btn.setProperty('selected_color', hex_color)
        
        even_color_btn.clicked.connect(choose_even_color)
        even_color_btn.setProperty('selected_color', even_row_color)
        even_color_layout.addWidget(even_color_btn)
        even_color_layout.addStretch()
        row_colors_layout.addLayout(even_color_layout)
        
        # Odd row color picker (darker/alternate)
        odd_color_layout = QHBoxLayout()
        odd_color_layout.addWidget(QLabel("Odd Row Color:"))
        
        odd_row_color = font_settings.get('odd_row_color', '#F0F0F0')
        odd_color_btn = QPushButton()
        odd_color_btn.setFixedSize(80, 25)
        odd_color_btn.setStyleSheet(f"background-color: {odd_row_color}; border: 1px solid #999;")
        odd_color_btn.setToolTip("Background color for odd rows (1, 3, 5, ...)")
        
        def choose_odd_color():
            color = QColorDialog.getColor(QColor(odd_row_color), self, "Choose Odd Row Color")
            if color.isValid():
                hex_color = color.name()
                odd_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                odd_color_btn.setProperty('selected_color', hex_color)
        
        odd_color_btn.clicked.connect(choose_odd_color)
        odd_color_btn.setProperty('selected_color', odd_row_color)
        odd_color_layout.addWidget(odd_color_btn)
        odd_color_layout.addStretch()
        row_colors_layout.addLayout(odd_color_layout)
        
        # Reset to defaults button
        reset_colors_btn = QPushButton("Reset to Default Colors")
        reset_colors_btn.setToolTip("Reset to white (#FFFFFF) and light gray (#F0F0F0)")
        def reset_row_colors():
            even_color_btn.setStyleSheet("background-color: #FFFFFF; border: 1px solid #999;")
            even_color_btn.setProperty('selected_color', '#FFFFFF')
            odd_color_btn.setStyleSheet("background-color: #F0F0F0; border: 1px solid #999;")
            odd_color_btn.setProperty('selected_color', '#F0F0F0')
        reset_colors_btn.clicked.connect(reset_row_colors)
        row_colors_layout.addWidget(reset_colors_btn)
        
        row_colors_group.setLayout(row_colors_layout)
        layout.addWidget(row_colors_group)
        
        # Focus Border Settings section
        focus_border_group = QGroupBox("üîµ Target Cell Focus Border")
        focus_border_layout = QVBoxLayout()
        
        focus_border_info = QLabel(
            "Customize the border that appears around the target cell when it has focus."
        )
        focus_border_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        focus_border_info.setWordWrap(True)
        focus_border_layout.addWidget(focus_border_info)
        
        # Border color picker
        border_color_layout = QHBoxLayout()
        border_color_layout.addWidget(QLabel("Border Color:"))
        
        focus_border_color = font_settings.get('focus_border_color', '#f1b79a')
        border_color_btn = QPushButton()
        border_color_btn.setFixedSize(80, 25)
        border_color_btn.setStyleSheet(f"background-color: {focus_border_color}; border: 1px solid #999;")
        border_color_btn.setToolTip("Color of the focus border around target cells")
        
        def choose_border_color():
            color = QColorDialog.getColor(QColor(focus_border_color), self, "Choose Focus Border Color")
            if color.isValid():
                hex_color = color.name()
                border_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                border_color_btn.setProperty('selected_color', hex_color)
        
        border_color_btn.clicked.connect(choose_border_color)
        border_color_btn.setProperty('selected_color', focus_border_color)
        border_color_layout.addWidget(border_color_btn)
        
        # Reset to default color button
        reset_border_color_btn = QPushButton("Reset")
        reset_border_color_btn.setFixedWidth(50)
        reset_border_color_btn.setToolTip("Reset to default blue (#2196F3)")
        def reset_border_color():
            border_color_btn.setStyleSheet("background-color: #2196F3; border: 1px solid #999;")
            border_color_btn.setProperty('selected_color', '#2196F3')
        reset_border_color_btn.clicked.connect(reset_border_color)
        border_color_layout.addWidget(reset_border_color_btn)
        border_color_layout.addStretch()
        focus_border_layout.addLayout(border_color_layout)
        
        # Border thickness spinbox
        thickness_layout = QHBoxLayout()
        thickness_layout.addWidget(QLabel("Border Thickness:"))
        border_thickness_spin = QSpinBox()
        border_thickness_spin.setMinimum(1)
        border_thickness_spin.setMaximum(10)
        border_thickness_spin.setValue(font_settings.get('focus_border_thickness', 2))
        border_thickness_spin.setSuffix(" px")
        border_thickness_spin.setMinimumWidth(90)
        border_thickness_spin.setMinimumHeight(28)
        border_thickness_spin.setButtonSymbols(QSpinBox.ButtonSymbols.UpDownArrows)
        border_thickness_spin.setToolTip("Thickness of the focus border (1-10 pixels)")
        # Fix spinbox arrow buttons - ensure both up and down work correctly
        border_thickness_spin.setStyleSheet("""
            QSpinBox {
                padding-right: 20px;
            }
            QSpinBox::up-button {
                width: 20px;
                height: 14px;
            }
            QSpinBox::down-button {
                width: 20px;
                height: 14px;
            }
        """)
        thickness_layout.addWidget(border_thickness_spin)
        thickness_layout.addStretch()
        focus_border_layout.addLayout(thickness_layout)
        
        focus_border_group.setLayout(focus_border_layout)
        layout.addWidget(focus_border_group)
        
        # Tab Position Settings section
        tab_position_group = QGroupBox("üìê Tab Layout")
        tab_position_layout = QVBoxLayout()
        
        tab_position_info = QLabel(
            "Control the position of Termview and Session Log tabs relative to the grid."
        )
        tab_position_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        tab_position_info.setWordWrap(True)
        tab_position_layout.addWidget(tab_position_info)
        
        # Show Termview/Session Log tabs above grid checkbox
        tabs_above_check = CheckmarkCheckBox("Show Termview/Session Log tabs above grid")
        tabs_above_check.setChecked(font_settings.get('tabs_above_grid', False))
        tabs_above_check.setToolTip("When enabled, Termview and Session Log tabs appear above the grid instead of below.\nRequires closing and reopening the project tab to take effect.")
        tab_position_layout.addWidget(tabs_above_check)
        
        tab_position_group.setLayout(tab_position_layout)
        layout.addWidget(tab_position_group)
        
        # Glossary Highlight Style section
        tb_highlight_group = QGroupBox("üè∑Ô∏è Glossary Highlight Style")
        tb_highlight_layout = QVBoxLayout()
        
        tb_highlight_info = QLabel(
            "Choose how glossary matches are highlighted in the source text.\n"
            "Different styles offer varying levels of visual prominence."
        )
        tb_highlight_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        tb_highlight_info.setWordWrap(True)
        tb_highlight_layout.addWidget(tb_highlight_info)
        
        # Style selection radio buttons
        tb_style_layout = QVBoxLayout()
        
        # Get current setting
        current_tb_style = font_settings.get('termbase_highlight_style', 'semibold')
        
        # Background highlight (current default)
        tb_style_background = CheckmarkRadioButton("Background Color - Pastel green background (current default)")
        tb_style_background.setToolTip("Traditional highlight with pastel green background colors based on priority")
        tb_style_background.setChecked(current_tb_style == 'background')
        tb_style_layout.addWidget(tb_style_background)
        
        # Dotted underline (code editor style)
        tb_style_dotted = CheckmarkRadioButton("Dotted Underline - Subtle dotted line below text (IDE style)")
        tb_style_dotted.setToolTip("Unobtrusive dotted underline like code editors use for suggestions")
        tb_style_dotted.setChecked(current_tb_style == 'dotted')
        tb_style_layout.addWidget(tb_style_dotted)
        
        # Semibold text (typographic)
        tb_style_semibold = CheckmarkRadioButton("Semibold Text - Slightly bolder text with tinted color")
        tb_style_semibold.setToolTip("Typographic approach: text appears slightly heavier/darker without adding visual elements")
        tb_style_semibold.setChecked(current_tb_style == 'semibold')
        tb_style_layout.addWidget(tb_style_semibold)
        
        # Button group for mutual exclusion
        tb_style_group = QButtonGroup(self)
        tb_style_group.addButton(tb_style_background, 0)
        tb_style_group.addButton(tb_style_dotted, 1)
        tb_style_group.addButton(tb_style_semibold, 2)
        
        tb_highlight_layout.addLayout(tb_style_layout)
        
        # Dotted underline color picker (only shown when dotted style selected)
        dotted_color_layout = QHBoxLayout()
        dotted_color_label = QLabel("Underline Color:")
        dotted_color_layout.addWidget(dotted_color_label)
        
        dotted_underline_color = font_settings.get('termbase_dotted_color', '#808080')
        dotted_color_btn = QPushButton()
        dotted_color_btn.setFixedSize(80, 25)
        dotted_color_btn.setStyleSheet(f"background-color: {dotted_underline_color}; border: 1px solid #999;")
        dotted_color_btn.setToolTip("Color for dotted underline (soft blue-grey recommended)")
        
        def choose_dotted_color():
            color = QColorDialog.getColor(QColor(dotted_underline_color), self, "Choose Dotted Underline Color")
            if color.isValid():
                hex_color = color.name()
                dotted_color_btn.setStyleSheet(f"background-color: {hex_color}; border: 1px solid #999;")
                dotted_color_btn.setProperty('selected_color', hex_color)
        
        dotted_color_btn.clicked.connect(choose_dotted_color)
        dotted_color_btn.setProperty('selected_color', dotted_underline_color)
        dotted_color_layout.addWidget(dotted_color_btn)
        
        # Reset to default color button
        reset_dotted_btn = QPushButton("Reset")
        reset_dotted_btn.setFixedWidth(50)
        reset_dotted_btn.setToolTip("Reset to default color (#808080)")
        def reset_dotted_color():
            dotted_color_btn.setStyleSheet("background-color: #808080; border: 1px solid #999;")
            dotted_color_btn.setProperty('selected_color', '#808080')
        reset_dotted_btn.clicked.connect(reset_dotted_color)
        dotted_color_layout.addWidget(reset_dotted_btn)
        
        dotted_color_layout.addStretch()
        tb_highlight_layout.addLayout(dotted_color_layout)
        
        # Store references for save function
        self._tb_style_group = tb_style_group
        self._tb_dotted_color_btn = dotted_color_btn
        
        tb_highlight_group.setLayout(tb_highlight_layout)
        layout.addWidget(tb_highlight_group)
        
        # Termview Font Settings section
        termview_group = QGroupBox("üîç Termview Font Settings")
        termview_layout = QVBoxLayout()
        
        termview_info = QLabel(
            "Configure the font appearance for the Termview inline terminology display."
        )
        termview_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        termview_info.setWordWrap(True)
        termview_layout.addWidget(termview_info)
        
        # Font family dropdown
        termview_font_family_layout = QHBoxLayout()
        termview_font_family_layout.addWidget(QLabel("Font Family:"))
        termview_font_family_combo = QComboBox()
        termview_font_family_combo.addItems(font_families)  # Same fonts as grid
        current_termview_font_family = font_settings.get('termview_font_family', 'Segoe UI')
        if current_termview_font_family in font_families:
            termview_font_family_combo.setCurrentText(current_termview_font_family)
        else:
            termview_font_family_combo.setCurrentText("Segoe UI")
        termview_font_family_combo.setToolTip("Select the font family for Termview text")
        termview_font_family_layout.addWidget(termview_font_family_combo)
        termview_font_family_layout.addStretch()
        termview_layout.addLayout(termview_font_family_layout)
        
        # Font size spinbox
        termview_size_layout = QHBoxLayout()
        termview_size_layout.addWidget(QLabel("Font Size:"))
        termview_font_spin = QSpinBox()
        termview_font_spin.setMinimum(6)
        termview_font_spin.setMaximum(16)
        termview_font_spin.setValue(font_settings.get('termview_font_size', 10))
        termview_font_spin.setSuffix(" pt")
        termview_font_spin.setToolTip("Termview font size (6-16 pt)")
        termview_font_spin.setMinimumHeight(28)
        termview_font_spin.setMinimumWidth(80)
        # Fix spinbox arrow buttons - ensure both up and down work correctly
        termview_font_spin.setStyleSheet("""
            QSpinBox {
                padding-right: 20px;
            }
            QSpinBox::up-button {
                width: 20px;
                height: 14px;
            }
            QSpinBox::down-button {
                width: 20px;
                height: 14px;
            }
        """)
        termview_size_layout.addWidget(termview_font_spin)
        termview_size_layout.addStretch()
        termview_layout.addLayout(termview_size_layout)
        
        # Font weight checkbox
        termview_bold_layout = QHBoxLayout()
        termview_bold_check = CheckmarkCheckBox("Bold font")
        termview_bold_check.setChecked(font_settings.get('termview_font_bold', False))
        termview_bold_check.setToolTip("Display Termview text in bold")
        termview_bold_layout.addWidget(termview_bold_check)
        termview_bold_layout.addStretch()
        termview_layout.addLayout(termview_bold_layout)
        
        termview_group.setLayout(termview_layout)
        layout.addWidget(termview_group)
        
        # ===== Global UI Font Scale =====
        ui_scale_group = QGroupBox("üñ•Ô∏è Global UI Font Scale")
        ui_scale_layout = QVBoxLayout()

        ui_scale_info = QLabel(
            "Adjust the font size for the entire application UI. Useful for Linux/macOS users where\n"
            "Qt applications may render with smaller fonts, or for high-DPI displays.\n"
            "Changes apply immediately. Default is 100%."
        )
        ui_scale_info.setWordWrap(True)
        ui_scale_layout.addWidget(ui_scale_info)

        ui_scale_row = QHBoxLayout()
        ui_scale_row.addWidget(QLabel("UI Font Scale:"))
        ui_scale_spin = QSpinBox()
        ui_scale_spin.setMinimum(50)
        ui_scale_spin.setMaximum(200)
        ui_scale_spin.setValue(font_settings.get('global_ui_font_scale', font_settings.get('settings_ui_font_scale', 100)))
        ui_scale_spin.setSuffix("%")
        ui_scale_spin.setSingleStep(10)
        ui_scale_spin.setToolTip("Scale entire application UI text (50%-200%)")
        ui_scale_spin.setMinimumHeight(28)
        ui_scale_spin.setMinimumWidth(90)
        ui_scale_spin.setStyleSheet("""
            QSpinBox {
                padding-right: 20px;
            }
            QSpinBox::up-button {
                width: 20px;
                height: 14px;
            }
            QSpinBox::down-button {
                width: 20px;
                height: 14px;
            }
        """)
        ui_scale_row.addWidget(ui_scale_spin)

        # Apply button for immediate feedback
        apply_scale_btn = QPushButton("Apply")
        apply_scale_btn.setToolTip("Apply font scale immediately")
        apply_scale_btn.clicked.connect(lambda: self._apply_global_ui_font_scale(ui_scale_spin.value()))
        ui_scale_row.addWidget(apply_scale_btn)
        
        ui_scale_row.addStretch()
        ui_scale_layout.addLayout(ui_scale_row)
        
        # Store reference for saving
        self._ui_scale_spin = ui_scale_spin
        
        ui_scale_group.setLayout(ui_scale_layout)
        layout.addWidget(ui_scale_group)
        
        # Quick Reference section
        reference_group = QGroupBox("‚å®Ô∏è Font Size Quick Reference")
        reference_layout = QVBoxLayout()
        
        reference_text = QLabel(
            "<b>All Zoom Controls:</b><br>"
            "View ‚Üí Grid Text Zoom<br>"
            "‚Ä¢ Ctrl+= (or Ctrl+NumPad +) - Increase<br>"
            "‚Ä¢ Ctrl+- (or Ctrl+NumPad -) - Decrease<br><br>"
            "View ‚Üí Translation Results Pane<br>"
            "‚Ä¢ Ctrl+Shift++ (Ctrl+Shift+=) - Increase<br>"
            "‚Ä¢ Ctrl+Shift+- - Decrease<br>"
            "‚Ä¢ Results Zoom Reset - Back to default (9pt)<br>"
        )
        reference_text.setTextFormat(Qt.TextFormat.RichText)
        reference_text.setWordWrap(True)
        reference_layout.addWidget(reference_text)
        
        reference_group.setLayout(reference_layout)
        layout.addWidget(reference_group)
        
        # Save button
        save_btn = QPushButton("üíæ Save View Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        
        def save_view_settings_with_scale():
            # Save the UI scale setting first
            if hasattr(self, '_ui_scale_spin'):
                self._apply_global_ui_font_scale(self._ui_scale_spin.value())
            # Then save other view settings
            self._save_view_settings_from_ui(
                grid_font_spin, match_font_spin, compare_font_spin, show_tags_check, tag_color_btn,
                alt_colors_check, even_color_btn, odd_color_btn, invisible_char_color_btn, grid_font_family_combo,
                termview_font_family_combo, termview_font_spin, termview_bold_check,
                border_color_btn, border_thickness_spin, badge_text_color_btn, tabs_above_check
            )
        
        save_btn.clicked.connect(save_view_settings_with_scale)
        layout.addWidget(save_btn)
        
        layout.addStretch()

        return tab

    def _create_voice_dictation_settings_tab(self):
        """Create Supervoice Settings tab content with Voice Commands"""
        from PyQt6.QtWidgets import (QGroupBox, QPushButton, QComboBox, QSpinBox, 
                                     QTableWidget, QTableWidgetItem, QHeaderView,
                                     QAbstractItemView, QCheckBox)

        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Load current dictation settings
        dictation_settings = self.load_dictation_settings()

        # Header info
        header_info = QLabel(
            "üé§ <b>Supervoice</b> - Hands-free translation with voice commands.<br>"
            "Press <b>F9</b> to start recording. Speak commands or dictate text."
        )
        header_info.setTextFormat(Qt.TextFormat.RichText)
        header_info.setStyleSheet("font-size: 9pt; color: #444; padding: 10px; background-color: #E3F2FD; border-radius: 4px;")
        header_info.setWordWrap(True)
        layout.addWidget(header_info)

        # ===== Voice Commands Section =====
        commands_group = QGroupBox("üó£Ô∏è Voice Commands (Talon-style)")
        commands_layout = QVBoxLayout()

        # Enable voice commands checkbox
        voice_cmd_enabled = QCheckBox("Enable voice commands (spoken phrases trigger actions)")
        voice_cmd_enabled.setChecked(dictation_settings.get('voice_commands_enabled', True))
        voice_cmd_enabled.setToolTip("When enabled, spoken phrases like 'confirm' or 'next segment' will execute commands instead of being inserted as text")
        commands_layout.addWidget(voice_cmd_enabled)
        self.voice_commands_enabled_checkbox = voice_cmd_enabled

        commands_info = QLabel(
            "Voice commands let you control Supervertaler by voice. Say a phrase to execute an action.\n"
            "If no command matches, the spoken text is inserted as dictation."
        )
        commands_info.setStyleSheet("font-size: 8pt; padding: 8px; color: #666;")
        commands_info.setWordWrap(True)
        commands_layout.addWidget(commands_info)

        # Commands table
        self.voice_commands_table = QTableWidget()
        self.voice_commands_table.setColumnCount(4)
        self.voice_commands_table.setHorizontalHeaderLabels(["Phrase", "Aliases", "Action", "Category"])
        self.voice_commands_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.voice_commands_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.voice_commands_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.voice_commands_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        self.voice_commands_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.voice_commands_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.voice_commands_table.setMinimumHeight(200)
        self.voice_commands_table.setMaximumHeight(300)
        
        # Populate table with current commands
        self._populate_voice_commands_table()
        commands_layout.addWidget(self.voice_commands_table)

        # Command buttons
        cmd_btn_layout = QHBoxLayout()
        
        add_cmd_btn = QPushButton("‚ûï Add Command")
        add_cmd_btn.clicked.connect(self._add_voice_command)
        cmd_btn_layout.addWidget(add_cmd_btn)
        
        edit_cmd_btn = QPushButton("‚úèÔ∏è Edit Command")
        edit_cmd_btn.clicked.connect(self._edit_voice_command)
        cmd_btn_layout.addWidget(edit_cmd_btn)
        
        remove_cmd_btn = QPushButton("üóëÔ∏è Remove Command")
        remove_cmd_btn.clicked.connect(self._remove_voice_command)
        cmd_btn_layout.addWidget(remove_cmd_btn)
        
        cmd_btn_layout.addStretch()
        
        reset_cmd_btn = QPushButton("üîÑ Reset to Defaults")
        reset_cmd_btn.clicked.connect(self._reset_voice_commands)
        cmd_btn_layout.addWidget(reset_cmd_btn)
        
        commands_layout.addLayout(cmd_btn_layout)

        commands_group.setLayout(commands_layout)
        layout.addWidget(commands_group)

        # ===== Always-On Mode Section =====
        alwayson_group = QGroupBox("üéß Always-On Listening Mode")
        alwayson_layout = QVBoxLayout()

        alwayson_info = QLabel(
            "Always-on mode continuously listens for speech. When you speak, it automatically\n"
            "records, transcribes, and processes as a command or dictation. No need to press F9!"
        )
        alwayson_info.setStyleSheet("font-size: 8pt; padding: 8px; color: #666;")
        alwayson_info.setWordWrap(True)
        alwayson_layout.addWidget(alwayson_info)

        # Status row
        status_row = QHBoxLayout()
        
        # Status indicator
        self.alwayson_status_label = QLabel("‚ö™ Not active")
        self.alwayson_status_label.setStyleSheet("font-size: 9pt; padding: 5px;")
        status_row.addWidget(self.alwayson_status_label)
        
        status_row.addStretch()
        
        # Start/Stop button
        self.alwayson_toggle_btn = QPushButton("‚ñ∂Ô∏è Start Always-On Listening")
        self.alwayson_toggle_btn.setStyleSheet("padding: 8px 15px;")
        self.alwayson_toggle_btn.clicked.connect(self._toggle_alwayson_listening)
        status_row.addWidget(self.alwayson_toggle_btn)
        
        alwayson_layout.addLayout(status_row)

        # Recognition Engine row
        engine_row = QHBoxLayout()
        engine_row.addWidget(QLabel("Recognition Engine:"))
        
        self.recognition_engine_combo = QComboBox()
        self.recognition_engine_combo.addItems([
            "Local Whisper (offline, slower)",
            "OpenAI Whisper API (online, fast & accurate)"
        ])
        saved_engine = dictation_settings.get('recognition_engine', 'local')
        if saved_engine == 'api':
            self.recognition_engine_combo.setCurrentIndex(1)
        else:
            self.recognition_engine_combo.setCurrentIndex(0)
        self.recognition_engine_combo.setToolTip(
            "Local: Uses Whisper model on your computer (works offline, but slower and less accurate)\n"
            "API: Uses OpenAI's cloud API (faster, much more accurate, requires API key)"
        )
        engine_row.addWidget(self.recognition_engine_combo)
        
        engine_row.addStretch()
        alwayson_layout.addLayout(engine_row)

        # Sensitivity row
        sensitivity_row = QHBoxLayout()
        sensitivity_row.addWidget(QLabel("Mic Sensitivity:"))
        
        self.sensitivity_combo = QComboBox()
        self.sensitivity_combo.addItems(["Low (noisy environment)", "Medium (normal)", "High (quiet environment)"])
        self.sensitivity_combo.setCurrentIndex(1)  # Default to medium
        saved_sensitivity = dictation_settings.get('alwayson_sensitivity', 'medium')
        if saved_sensitivity == 'low':
            self.sensitivity_combo.setCurrentIndex(0)
        elif saved_sensitivity == 'high':
            self.sensitivity_combo.setCurrentIndex(2)
        self.sensitivity_combo.setToolTip("Adjust how sensitive the microphone is to speech detection")
        sensitivity_row.addWidget(self.sensitivity_combo)
        
        sensitivity_row.addStretch()
        
        alwayson_layout.addLayout(sensitivity_row)

        # Note about F9 and API
        f9_note = QLabel(
            "üí° <b>Tip:</b> OpenAI API is <b>highly recommended</b> for always-on mode - it's much faster and more accurate "
            "for short voice commands. Requires an OpenAI API key in Settings ‚Üí AI Settings."
        )
        f9_note.setTextFormat(Qt.TextFormat.RichText)
        f9_note.setStyleSheet("font-size: 8pt; padding: 8px; color: #666; background-color: #E8F5E9; border-radius: 4px;")
        f9_note.setWordWrap(True)
        alwayson_layout.addWidget(f9_note)

        alwayson_group.setLayout(alwayson_layout)
        layout.addWidget(alwayson_group)

        # ===== Whisper Model Settings =====
        model_group = QGroupBox("ü§ñ Speech Recognition Model")
        model_layout = QVBoxLayout()

        model_info = QLabel(
            "Whisper model size (larger = more accurate but slower):\n"
            "‚Ä¢ tiny: ~75 MB  ‚Ä¢  base: ~142 MB (recommended)  ‚Ä¢  small: ~466 MB\n"
            "‚Ä¢ medium: ~1.5 GB  ‚Ä¢  large: ~2.9 GB"
        )
        model_info.setStyleSheet("font-size: 8pt; padding: 8px;")
        model_info.setWordWrap(True)
        model_layout.addWidget(model_info)

        model_select_layout = QHBoxLayout()
        model_select_layout.addWidget(QLabel("Model:"))
        model_combo = QComboBox()
        model_combo.addItems(["tiny", "base", "small", "medium", "large"])
        model_combo.setCurrentText(dictation_settings.get('model', 'base'))
        model_select_layout.addWidget(model_combo)
        
        model_select_layout.addSpacing(20)
        model_select_layout.addWidget(QLabel("Max Duration:"))
        duration_spin = QSpinBox()
        duration_spin.setMinimum(3)
        duration_spin.setMaximum(60)
        duration_spin.setValue(dictation_settings.get('max_duration', 10))
        duration_spin.setSuffix(" sec")
        model_select_layout.addWidget(duration_spin)
        
        model_select_layout.addSpacing(20)
        model_select_layout.addWidget(QLabel("Language:"))
        lang_combo = QComboBox()
        lang_combo.addItems([
            "Auto (use project target language)",
            "English", "Dutch", "German", "French", "Spanish",
            "Italian", "Portuguese", "Polish", "Russian",
            "Chinese", "Japanese", "Korean"
        ])
        lang_combo.setCurrentText(dictation_settings.get('language', 'Auto (use project target language)'))
        model_select_layout.addWidget(lang_combo)
        
        model_select_layout.addStretch()
        model_layout.addLayout(model_select_layout)

        model_group.setLayout(model_layout)
        layout.addWidget(model_group)

        # ===== AutoHotkey Integration =====
        ahk_group = QGroupBox("‚å®Ô∏è AutoHotkey Integration (System Commands)")
        ahk_layout = QVBoxLayout()

        ahk_info = QLabel(
            "Voice commands can trigger AutoHotkey scripts for system-level automation.\n"
            "This enables controlling other applications (memoQ, Trados, Word) by voice."
        )
        ahk_info.setStyleSheet("font-size: 8pt; padding: 8px; color: #666;")
        ahk_info.setWordWrap(True)
        ahk_layout.addWidget(ahk_info)

        ahk_btn_layout = QHBoxLayout()
        
        ahk_status = self._check_ahk_installed()
        ahk_status_label = QLabel(ahk_status)
        ahk_status_label.setStyleSheet("font-size: 8pt; padding: 4px;")
        ahk_btn_layout.addWidget(ahk_status_label)
        
        ahk_btn_layout.addStretch()
        
        open_ahk_folder_btn = QPushButton("üìÇ Open Scripts Folder")
        open_ahk_folder_btn.clicked.connect(self._open_voice_scripts_folder)
        ahk_btn_layout.addWidget(open_ahk_folder_btn)
        
        ahk_layout.addLayout(ahk_btn_layout)
        ahk_group.setLayout(ahk_layout)
        layout.addWidget(ahk_group)

        # Save button
        save_btn = QPushButton("üíæ Save Supervoice Settings")
        save_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 10px; border: none; outline: none;")
        save_btn.clicked.connect(lambda: self._save_voice_settings(
            model_combo.currentText(),
            duration_spin.value(),
            lang_combo.currentText(),
            voice_cmd_enabled.isChecked()
        ))
        layout.addWidget(save_btn)

        # Store references
        self.dictation_model_combo = model_combo
        self.dictation_duration_spin = duration_spin
        self.dictation_lang_combo = lang_combo

        layout.addStretch()

        return tab

    def _populate_voice_commands_table(self):
        """Populate the voice commands table with current commands"""
        if not hasattr(self, 'voice_command_manager'):
            return
        
        table = self.voice_commands_table
        table.setRowCount(0)
        
        for cmd in self.voice_command_manager.commands:
            row = table.rowCount()
            table.insertRow(row)
            
            table.setItem(row, 0, QTableWidgetItem(cmd.phrase))
            table.setItem(row, 1, QTableWidgetItem(", ".join(cmd.aliases) if cmd.aliases else ""))
            table.setItem(row, 2, QTableWidgetItem(cmd.description or cmd.action))
            table.setItem(row, 3, QTableWidgetItem(cmd.category))

    def _add_voice_command(self):
        """Add a new voice command"""
        dialog = VoiceCommandEditDialog(self)
        if dialog.exec():
            cmd = dialog.get_command()
            self.voice_command_manager.add_command(cmd)
            self._populate_voice_commands_table()

    def _edit_voice_command(self):
        """Edit selected voice command"""
        table = self.voice_commands_table
        selected = table.selectedItems()
        if not selected:
            QMessageBox.information(self, "Edit Command", "Please select a command to edit.")
            return
        
        row = selected[0].row()
        phrase = table.item(row, 0).text()
        
        # Find the command
        cmd = next((c for c in self.voice_command_manager.commands if c.phrase == phrase), None)
        if not cmd:
            return
        
        dialog = VoiceCommandEditDialog(self, cmd)
        if dialog.exec():
            # Remove old, add new
            self.voice_command_manager.remove_command(phrase)
            new_cmd = dialog.get_command()
            self.voice_command_manager.add_command(new_cmd)
            self._populate_voice_commands_table()

    def _remove_voice_command(self):
        """Remove selected voice command"""
        table = self.voice_commands_table
        selected = table.selectedItems()
        if not selected:
            QMessageBox.information(self, "Remove Command", "Please select a command to remove.")
            return
        
        row = selected[0].row()
        phrase = table.item(row, 0).text()
        
        reply = QMessageBox.question(
            self, "Remove Command",
            f"Remove voice command '{phrase}'?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.voice_command_manager.remove_command(phrase)
            self._populate_voice_commands_table()

    def _reset_voice_commands(self):
        """Reset voice commands to defaults"""
        reply = QMessageBox.question(
            self, "Reset Commands",
            "Reset all voice commands to defaults?\n\nThis will remove any custom commands you've added.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.voice_command_manager.commands = self.voice_command_manager.DEFAULT_COMMANDS.copy()
            self.voice_command_manager.save_commands()
            self._populate_voice_commands_table()
            QMessageBox.information(self, "Reset Complete", "Voice commands have been reset to defaults.")

    def _check_ahk_installed(self) -> str:
        """Check if AutoHotkey is installed"""
        ahk_exe = self.voice_command_manager._find_ahk_executable() if hasattr(self, 'voice_command_manager') else None
        if ahk_exe:
            return "‚úÖ AutoHotkey detected"
        else:
            return "‚ö†Ô∏è AutoHotkey not found - install from autohotkey.com for system commands"

    def _open_voice_scripts_folder(self):
        """Open the voice scripts folder"""
        import subprocess
        scripts_folder = self.user_data_path / "voice_scripts"
        scripts_folder.mkdir(parents=True, exist_ok=True)
        subprocess.Popen(['explorer', str(scripts_folder)])

    def _toggle_alwayson_listening(self):
        """Toggle always-on voice listening mode"""
        if self.voice_listener and self.voice_listener.is_listening:
            # Stop listening
            self.voice_listener.stop()
            self.voice_listener = None
            self._update_alwayson_ui("stopped")
            self.log("üîá Always-on listening stopped")
            self.status_bar.showMessage("üîá Always-on listening stopped", 3000)
        else:
            # Start listening
            try:
                dictation_settings = self.load_dictation_settings()
                model_name = dictation_settings.get('model', 'base')
                
                # Check recognition engine setting
                use_api = dictation_settings.get('recognition_engine', 'local') == 'api'
                
                # If using API, check if we have an OpenAI key
                api_key = None
                if use_api:
                    api_keys = self.load_api_keys()
                    api_key = api_keys.get('openai') or api_keys.get('openai_api_key')
                    if not api_key:
                        # If no API key, only fall back if Local Whisper is actually installed.
                        try:
                            import whisper  # noqa: F401
                        except ImportError:
                            QMessageBox.warning(
                                self, "OpenAI API Key Required",
                                "To use OpenAI Whisper API, please set your OpenAI API key in:\n\n"
                                "Settings ‚Üí AI Settings ‚Üí OpenAI API Key\n\n"
                                "Local Whisper is not installed either.\n\n"
                                "Install offline Local Whisper with:\n"
                                "  pip install supervertaler[local-whisper]"
                            )
                            return
                        QMessageBox.warning(
                            self, "OpenAI API Key Required",
                            "To use OpenAI Whisper API, please set your OpenAI API key in:\n\n"
                            "Settings ‚Üí AI Settings ‚Üí OpenAI API Key\n\n"
                            "Falling back to local Whisper model."
                        )
                        use_api = False
                
                # Get language setting
                lang_setting = dictation_settings.get('language', 'Auto (use project target language)')
                if lang_setting.startswith('Auto'):
                    target_lang = self.current_project.target_lang if self.current_project else 'en'
                    lang_map = {
                        'nl': 'nl', 'nl_NL': 'nl', 'nl_BE': 'nl',
                        'en': 'en', 'en_US': 'en', 'en_GB': 'en',
                        'de': 'de', 'de_DE': 'de',
                        'fr': 'fr', 'fr_FR': 'fr',
                        'es': 'es', 'es_ES': 'es',
                    }
                    lang_code = lang_map.get(target_lang, 'auto')
                else:
                    lang_code = lang_setting.lower()[:2]
                
                # Create listener
                self.voice_listener = ContinuousVoiceListener(
                    command_manager=self.voice_command_manager,
                    model_name=model_name,
                    language=lang_code,
                    use_api=use_api,
                    api_key=api_key
                )
                
                # Set sensitivity
                if hasattr(self, 'sensitivity_combo'):
                    idx = self.sensitivity_combo.currentIndex()
                    sensitivity = ['low', 'medium', 'high'][idx]
                    self.voice_listener.set_sensitivity(sensitivity)
                
                # Connect signals
                self.voice_listener.speech_detected.connect(self._on_alwayson_speech)
                self.voice_listener.command_detected.connect(self._on_alwayson_command)
                self.voice_listener.text_for_dictation.connect(self._on_alwayson_dictation)
                self.voice_listener.status_update.connect(self._on_alwayson_status)
                self.voice_listener.error_occurred.connect(self._on_alwayson_error)
                self.voice_listener.vad_status_changed.connect(self._on_alwayson_vad_status)
                self.voice_listener.listening_started.connect(lambda: self._update_alwayson_ui("listening"))
                self.voice_listener.listening_stopped.connect(lambda: self._update_alwayson_ui("stopped"))
                
                # Log which engine we're using
                if use_api:
                    self.log("üéß Always-on listening started (OpenAI API - fast & accurate)")
                else:
                    self.log(f"üéß Always-on listening started (local Whisper '{model_name}')")
                
                # Start
                self.voice_listener.start()
                self.log("üéß Always-on listening started")
                
            except Exception as e:
                import traceback
                self.log(f"‚ùå Failed to start always-on listening: {e}")
                self.log(traceback.format_exc())
                QMessageBox.critical(self, "Always-On Error", f"Failed to start always-on listening:\n\n{e}")

    def _update_alwayson_ui(self, status: str):
        """Update the always-on UI elements"""
        # Update settings panel UI (if visible)
        if hasattr(self, 'alwayson_status_label'):
            if status == "listening" or status == "waiting":
                self.alwayson_status_label.setText("üü¢ Listening for speech...")
                self.alwayson_status_label.setStyleSheet("font-size: 9pt; padding: 5px; color: #2E7D32;")
                self.alwayson_toggle_btn.setText("‚èπÔ∏è Stop Always-On Listening")
                self.alwayson_toggle_btn.setStyleSheet("padding: 8px 15px; background-color: #FFCDD2;")
            elif status == "recording":
                self.alwayson_status_label.setText("üî¥ Recording...")
                self.alwayson_status_label.setStyleSheet("font-size: 9pt; padding: 5px; color: #C62828;")
            elif status == "processing":
                self.alwayson_status_label.setText("‚è≥ Processing...")
                self.alwayson_status_label.setStyleSheet("font-size: 9pt; padding: 5px; color: #F57C00;")
            else:  # stopped or other
                self.alwayson_status_label.setText("‚ö™ Not active")
                self.alwayson_status_label.setStyleSheet("font-size: 9pt; padding: 5px;")
                self.alwayson_toggle_btn.setText("‚ñ∂Ô∏è Start Always-On Listening")
                self.alwayson_toggle_btn.setStyleSheet("padding: 8px 15px;")
        
        # Update status bar indicator (always visible when active)
        if hasattr(self, 'alwayson_indicator_label'):
            if status == "listening" or status == "waiting":
                self.alwayson_indicator_label.setText("üé§ VOICE COMMANDS ON")
                self.alwayson_indicator_label.setStyleSheet("font-size: 11px; font-weight: bold; color: #2E7D32; background-color: #C8E6C9; padding: 2px 6px; border-radius: 3px;")
                self.alwayson_indicator_label.setToolTip("Always-on voice listening ACTIVE\nClick to stop")
                self.alwayson_indicator_label.show()
            elif status == "recording":
                self.alwayson_indicator_label.setText("üî¥ REC")
                self.alwayson_indicator_label.setStyleSheet("font-size: 11px; font-weight: bold; color: white; background-color: #C62828; padding: 2px 6px; border-radius: 3px;")
                self.alwayson_indicator_label.setToolTip("Recording speech...")
                self.alwayson_indicator_label.show()
            elif status == "processing":
                self.alwayson_indicator_label.setText("‚è≥ ...")
                self.alwayson_indicator_label.setStyleSheet("font-size: 11px; font-weight: bold; color: #F57C00; background-color: #FFF3E0; padding: 2px 6px; border-radius: 3px;")
                self.alwayson_indicator_label.setToolTip("Processing speech...")
                self.alwayson_indicator_label.show()
            else:  # stopped or other
                self.alwayson_indicator_label.hide()
        
        # Update grid toolbar button (if exists)
        if hasattr(self, 'grid_alwayson_btn'):
            if status == "listening" or status == "waiting":
                self.grid_alwayson_btn.setText("üéß Voice Commands ON")
                self.grid_alwayson_btn.setChecked(True)
                self.grid_alwayson_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #2E7D32;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 3px;
                    }
                    QPushButton:checked {
                        background-color: #2E7D32;
                    }
                """)
            elif status == "recording":
                self.grid_alwayson_btn.setText("üî¥ REC")
                self.grid_alwayson_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #C62828;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 3px;
                    }
                    QPushButton:checked {
                        background-color: #C62828;
                    }
                """)
            elif status == "processing":
                self.grid_alwayson_btn.setText("‚è≥ ...")
                self.grid_alwayson_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #F57C00;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 3px;
                    }
                    QPushButton:checked {
                        background-color: #F57C00;
                    }
                """)
            else:  # stopped or other
                self.grid_alwayson_btn.setText("üéß Voice Commands OFF")
                self.grid_alwayson_btn.setChecked(False)
                self.grid_alwayson_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #757575;
                        color: white;
                        font-weight: bold;
                        padding: 4px 8px;
                        border-radius: 3px;
                    }
                    QPushButton:checked {
                        background-color: #2E7D32;
                    }
                """)

    def _on_alwayson_speech(self, text: str):
        """Handle raw speech from always-on listener"""
        self.log(f"üé§ Heard: {text}")

    def _on_alwayson_command(self, phrase: str, result: str):
        """Handle command execution from always-on listener"""
        self.log(f"üé§ Command: {phrase} ‚Üí {result}")
        self.status_bar.showMessage(f"üé§ {result}", 3000)

    def _on_alwayson_dictation(self, text: str):
        """Handle dictation text from always-on listener (no command matched)"""
        # Insert into focused widget
        focused_widget = QApplication.focusWidget()
        
        if isinstance(focused_widget, EditableGridTextEditor):
            current_text = focused_widget.toPlainText()
            if current_text:
                focused_widget.setPlainText(current_text + " " + text)
            else:
                focused_widget.setPlainText(text)
            cursor = focused_widget.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            focused_widget.setTextCursor(cursor)
            self.status_bar.showMessage(f"‚úÖ Dictation: {text[:50]}...", 3000)
        else:
            self.log(f"üí¨ Dictation (no target): {text}")
            self.status_bar.showMessage(f"üí¨ {text[:50]}...", 3000)

    def _on_alwayson_status(self, message: str):
        """Handle status updates from always-on listener"""
        self.log(message)
        if hasattr(self, 'alwayson_status_label'):
            # Keep status label updated but don't override state-based status
            pass

    def _on_alwayson_error(self, error: str):
        """Handle errors from always-on listener"""
        self.log(f"‚ùå Always-on error: {error}")
        QMessageBox.warning(self, "Always-On Error", f"Voice listener error:\n\n{error}")

    def _on_alwayson_vad_status(self, status: str):
        """Handle VAD status changes (waiting/recording/processing)"""
        self._update_alwayson_ui(status)

    def _toggle_alwayson_from_statusbar(self):
        """Toggle always-on listening when clicking the status bar indicator"""
        self._toggle_alwayson_listening()

    def _toggle_alwayson_from_grid_btn(self, checked: bool, btn: QPushButton):
        """Toggle always-on listening from the grid toolbar button"""
        self._toggle_alwayson_listening()
        # Button state will be updated by _update_alwayson_ui

    def _save_voice_settings(self, model: str, duration: int, language: str, voice_commands_enabled: bool):
        """Save all voice settings including voice commands enabled state, sensitivity, and recognition engine"""
        # Save base settings
        self.save_dictation_settings(model, duration, language)
        
        # Save voice commands enabled state, sensitivity, and recognition engine
        prefs_file = self.user_data_path / "ui_preferences.json"
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        if 'dictation_settings' not in prefs:
            prefs['dictation_settings'] = {}
        prefs['dictation_settings']['voice_commands_enabled'] = voice_commands_enabled
        
        # Save sensitivity setting
        if hasattr(self, 'sensitivity_combo'):
            idx = self.sensitivity_combo.currentIndex()
            sensitivity = ['low', 'medium', 'high'][idx]
            prefs['dictation_settings']['alwayson_sensitivity'] = sensitivity
        
        # Save recognition engine setting
        if hasattr(self, 'recognition_engine_combo'):
            idx = self.recognition_engine_combo.currentIndex()
            engine = 'api' if idx == 1 else 'local'
            prefs['dictation_settings']['recognition_engine'] = engine
        
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
            
            # Update active listener if running
            if self.voice_listener and hasattr(self, 'sensitivity_combo'):
                idx = self.sensitivity_combo.currentIndex()
                sensitivity = ['low', 'medium', 'high'][idx]
                self.voice_listener.set_sensitivity(sensitivity)
                self.log(f"‚úì Updated always-on sensitivity to: {sensitivity}")
                
        except Exception as e:
            self.log(f"‚ö† Could not save voice command settings: {e}")

    def _create_system_prompts_tab(self):
        """Create System Prompts (Layer 1) Settings tab content"""
        from PyQt6.QtWidgets import QGroupBox, QPushButton, QTextEdit, QComboBox

        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Header info
        header_group = QGroupBox("üìù System Prompts (Layer 1)")
        header_layout = QVBoxLayout()

        info_label = QLabel(
            "<b>System Prompts are the foundation of Supervertaler's 2-Layer Prompt Architecture.</b><br><br>"
            "These prompts are <b>always applied</b> and contain critical infrastructure instructions:<br>"
            "‚Ä¢ CAT tool tag preservation (memoQ, Trados, CafeTran)<br>"
            "‚Ä¢ Formatting rules and output standards<br>"
            "‚Ä¢ Language-specific conventions (numbers, dates, typography)<br>"
            "‚Ä¢ Professional translation context<br><br>"
            "<i>Layer 2 (Custom Prompts) are managed in the Prompts tab and can be freely attached/detached.</i>"
        )
        info_label.setTextFormat(Qt.TextFormat.RichText)
        info_label.setWordWrap(True)
        info_label.setStyleSheet("font-size: 9pt; padding: 12px; border-radius: 3px;")
        header_layout.addWidget(info_label)

        header_group.setLayout(header_layout)
        layout.addWidget(header_group)

        # Mode selector
        mode_group = QGroupBox("üéØ Select System Prompt Mode")
        mode_layout = QVBoxLayout()

        mode_info = QLabel(
            "Supervertaler uses different system prompts for different translation modes:"
        )
        mode_info.setStyleSheet("font-size: 9pt; color: #666; padding: 8px;")
        mode_info.setWordWrap(True)
        mode_layout.addWidget(mode_info)

        mode_selector_layout = QHBoxLayout()
        mode_selector_layout.addWidget(QLabel("Mode:"))
        mode_combo = QComboBox()
        mode_combo.addItems([
            "Single Segment Translation",
            "Batch DOCX Translation",
            "Batch Bilingual Translation"
        ])
        mode_combo.setToolTip("Select which system prompt to view/edit")
        mode_selector_layout.addWidget(mode_combo)
        mode_selector_layout.addStretch()
        mode_layout.addLayout(mode_selector_layout)

        mode_group.setLayout(mode_layout)
        layout.addWidget(mode_group)

        # Editor
        editor_group = QGroupBox("‚úèÔ∏è Edit System Prompt")
        editor_layout = QVBoxLayout()

        editor_info = QLabel(
            "Edit the system prompt below. Use {{SOURCE_LANGUAGE}}, {{TARGET_LANGUAGE}}, and {{SOURCE_TEXT}} as placeholders."
        )
        editor_info.setStyleSheet("font-size: 8pt; padding: 8px; border-radius: 2px;")
        editor_info.setWordWrap(True)
        editor_layout.addWidget(editor_info)

        system_prompt_editor = QTextEdit()
        system_prompt_editor.setStyleSheet("font-family: 'Consolas', 'Courier New', monospace; font-size: 9pt;")
        system_prompt_editor.setMinimumHeight(500)  # Increased from 400 to 500
        system_prompt_editor.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)  # Enable word wrap
        system_prompt_editor.setAcceptRichText(False)  # Plain text only
        editor_layout.addWidget(system_prompt_editor, 1)  # Added stretch factor of 1 to allow expansion

        editor_group.setLayout(editor_layout)
        layout.addWidget(editor_group, 1)  # Added stretch factor of 1 to allow expansion

        # Buttons
        buttons_layout = QHBoxLayout()

        reset_btn = QPushButton("üîÑ Reset to Default")
        reset_btn.setToolTip("Restore the default system prompt for this mode")
        reset_btn.clicked.connect(lambda: self._reset_system_prompt(mode_combo, system_prompt_editor))
        buttons_layout.addWidget(reset_btn)

        buttons_layout.addStretch()

        save_btn = QPushButton("üíæ Save System Prompt")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        save_btn.clicked.connect(lambda: self._save_system_prompt_from_ui(mode_combo, system_prompt_editor))
        buttons_layout.addWidget(save_btn)

        layout.addLayout(buttons_layout)

        # Load initial prompt
        self._load_system_prompt_into_editor(mode_combo, system_prompt_editor)

        # Connect mode change to load new prompt
        mode_combo.currentIndexChanged.connect(lambda: self._load_system_prompt_into_editor(mode_combo, system_prompt_editor))

        return tab

    def _load_system_prompt_into_editor(self, mode_combo, editor):
        """Load the selected system prompt into the editor"""
        mode_map = {
            "Single Segment Translation": "single",
            "Batch DOCX Translation": "batch_docx",
            "Batch Bilingual Translation": "batch_bilingual"
        }

        selected_mode = mode_combo.currentText()
        mode_key = mode_map.get(selected_mode, "single")

        # Load from prompt_manager_qt if available
        if hasattr(self, 'prompt_manager_qt'):
            prompt_text = self.prompt_manager_qt.get_system_template(mode_key)
        else:
            # Fallback: load from JSON file
            system_prompts_file = self.user_data_path / "prompt_library" / "system_prompts_layer1.json"
            if system_prompts_file.exists():
                import json
                with open(system_prompts_file, 'r', encoding='utf-8') as f:
                    system_prompts = json.load(f)
                prompt_text = system_prompts.get(mode_key, "# SYSTEM PROMPT\n\nNo prompt defined.")
            else:
                prompt_text = "# SYSTEM PROMPT\n\nNo prompt defined."

        editor.setPlainText(prompt_text)

    def _save_system_prompt_from_ui(self, mode_combo, editor):
        """Save the edited system prompt"""
        mode_map = {
            "Single Segment Translation": "single",
            "Batch DOCX Translation": "batch_docx",
            "Batch Bilingual Translation": "batch_bilingual"
        }

        selected_mode = mode_combo.currentText()
        mode_key = mode_map.get(selected_mode, "single")
        prompt_text = editor.toPlainText()

        # Save to prompt_manager_qt if available
        if hasattr(self, 'prompt_manager_qt'):
            self.prompt_manager_qt.system_templates[mode_key] = prompt_text

        # Always save to JSON file
        import json
        system_prompts_file = self.user_data_path / "prompt_library" / "system_prompts_layer1.json"
        system_prompts_file.parent.mkdir(parents=True, exist_ok=True)

        # Load existing prompts
        if system_prompts_file.exists():
            with open(system_prompts_file, 'r', encoding='utf-8') as f:
                system_prompts = json.load(f)
        else:
            system_prompts = {}

        # Update and save
        system_prompts[mode_key] = prompt_text
        with open(system_prompts_file, 'w', encoding='utf-8') as f:
            json.dump(system_prompts, f, indent=2, ensure_ascii=False)

        self.log(f"‚úì Saved system prompt: {selected_mode}")
        QMessageBox.information(
            self,
            "System Prompt Saved",
            f"System prompt for '{selected_mode}' has been saved successfully."
        )

    def _reset_system_prompt(self, mode_combo, editor):
        """Reset system prompt to default"""
        mode_map = {
            "Single Segment Translation": "single",
            "Batch DOCX Translation": "batch_docx",
            "Batch Bilingual Translation": "batch_bilingual"
        }

        selected_mode = mode_combo.currentText()
        mode_key = mode_map.get(selected_mode, "single")

        # Confirm reset
        reply = QMessageBox.question(
            self,
            "Reset System Prompt",
            f"Are you sure you want to reset the system prompt for '{selected_mode}' to its default value?\n\n"
            "This will discard any custom changes you've made.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            # Get default from unified_prompt_manager
            if hasattr(self, 'unified_prompt_manager'):
                default_prompt = self.unified_prompt_manager._get_default_system_template(mode_key)
                editor.setPlainText(default_prompt)
                self.log(f"‚úì Reset system prompt to default: {selected_mode}")

    def _create_debug_settings_tab(self):
        """Create Debug Settings tab content"""
        from PyQt6.QtWidgets import QGroupBox, QPushButton, QTextEdit
        
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        
        debug_settings = self.load_general_settings()
        
        # Debug Mode section
        debug_group = QGroupBox("üêõ Debug Mode")
        debug_layout = QVBoxLayout()
        
        info_label = QLabel(
            "<b>Debug Mode</b> enables verbose logging to help diagnose performance issues.\n\n"
            "When enabled, detailed logs will show:\n"
            "‚Ä¢ Every text change event in the grid\n"
            "‚Ä¢ Database update operations (BEFORE/AFTER)\n"
            "‚Ä¢ Cell selection events\n"
            "‚Ä¢ Signal connections\n\n"
            "‚ö†Ô∏è <b>Warning:</b> Debug mode generates a LOT of log output and may slow down the application.\n"
            "Only enable when troubleshooting specific issues."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("font-size: 9pt; padding: 10px; border-radius: 4px;")
        debug_layout.addWidget(info_label)
        
        debug_layout.addSpacing(10)
        
        # Enable debug mode checkbox
        debug_mode_cb = CheckmarkCheckBox("Enable verbose debug logging")
        debug_mode_cb.setChecked(debug_settings.get('debug_mode_enabled', False))
        debug_mode_cb.setToolTip(
            "When enabled, shows detailed debug messages in the log.\n"
            "This helps diagnose performance issues but generates a lot of output."
        )
        debug_layout.addWidget(debug_mode_cb)
        
        # Auto-export debug logs checkbox
        debug_export_cb = CheckmarkCheckBox("Auto-export debug logs to file")
        debug_export_cb.setChecked(debug_settings.get('debug_auto_export', False))
        debug_export_cb.setToolTip(
            "When enabled, automatically saves debug logs to:\n"
            "supervertaler_debug_log_<timestamp>.txt in the program root.\n"
            "Logs are exported every 5 minutes or when you close the application."
        )
        debug_export_cb.setEnabled(debug_mode_cb.isChecked())  # Only enabled if debug mode is on
        debug_layout.addWidget(debug_export_cb)
        
        # Link the checkboxes
        debug_mode_cb.toggled.connect(lambda checked: debug_export_cb.setEnabled(checked))
        
        debug_layout.addSpacing(10)
        
        # Export log button
        export_btn = QPushButton("üìÅ Export Debug Log Now")
        export_btn.setToolTip("Export the current debug log buffer to a timestamped file")
        export_btn.clicked.connect(self.export_debug_log_now)
        debug_layout.addWidget(export_btn)
        
        # Clear log buffer button
        clear_btn = QPushButton("üóëÔ∏è Clear Debug Log Buffer")
        clear_btn.setToolTip("Clear the in-memory debug log buffer")
        clear_btn.clicked.connect(self.clear_debug_log_buffer)
        debug_layout.addWidget(clear_btn)
        
        debug_group.setLayout(debug_layout)
        layout.addWidget(debug_group)
        
        # Performance Settings section
        perf_group = QGroupBox("‚ö° Performance Settings")
        perf_layout = QVBoxLayout()
        
        perf_info = QLabel(
            "<b>Performance Tuning</b> - These settings control UI responsiveness.\n\n"
            "Higher delays = more responsive typing but slower lookups.\n"
            "Lower delays = faster lookups but potential UI freezes during typing."
        )
        perf_info.setWordWrap(True)
        perf_info.setStyleSheet("font-size: 9pt; padding: 10px; border-radius: 4px;")
        perf_layout.addWidget(perf_info)
        
        perf_layout.addSpacing(10)
        
        # Target text debounce delay
        debounce_layout = QHBoxLayout()
        debounce_layout.addWidget(QLabel("Target text save delay:"))
        debounce_spin = QSpinBox()
        debounce_spin.setRange(100, 5000)
        debounce_spin.setValue(debug_settings.get('target_debounce_delay', 1000))
        debounce_spin.setSingleStep(100)
        debounce_spin.setSuffix(" ms")
        debounce_spin.setToolTip(
            "Delay before saving target text changes to database.\n"
            "1000ms (default) = good balance between responsiveness and data safety.\n"
            "Higher values = less database overhead but longer delay before saving."
        )
        debounce_layout.addWidget(debounce_spin)
        debounce_layout.addStretch()
        perf_layout.addLayout(debounce_layout)
        
        perf_group.setLayout(perf_layout)
        layout.addWidget(perf_group)
        
        # Save button
        save_btn = QPushButton("üíæ Save Debug Settings")
        save_btn.setStyleSheet("font-weight: bold; padding: 8px;")
        save_btn.clicked.connect(lambda: self._save_debug_settings_from_ui(
            debug_mode_cb, debug_export_cb, debounce_spin
        ))
        layout.addWidget(save_btn)
        
        layout.addStretch()
        
        return tab

    def _create_features_settings_tab(self):
        """Create Features Settings tab - view optional modules and installation status."""
        from PyQt6.QtWidgets import QGroupBox, QPushButton, QProgressBar, QTextEdit, QFrame, QSplitter
        from modules.feature_manager import get_feature_manager, FEATURE_MODULES
        import sys
        
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(15, 15, 15, 15)
        main_layout.setSpacing(10)
        
        fm = get_feature_manager(str(self.user_data_path))
        
        is_frozen_build = bool(getattr(sys, 'frozen', False))

        # Header info with legend
        header_subtitle = (
            "Supervertaler has a modular design. Core features work out of the box. "
            "Optional features require additional packages."
        )
        if is_frozen_build:
            header_subtitle += (
                " <b>Note:</b> This is the Windows EXE build; you can't install pip extras into this portable app. "
                "To add optional features, install the Python version (pip) or download a separate EXE build that includes them."
            )
        else:
            header_subtitle += " See install commands on the right."

        header_info = QLabel(
            "üì¶ <b>Optional Feature Modules</b><br>"
            f"<span style='color:#666;'>{header_subtitle}</span><br><br>"
            "<b>‚úÖ Installed</b> ‚Äî Feature is ready to use&nbsp;&nbsp;&nbsp;&nbsp;"
            "<b>‚ùå Not installed</b> ‚Äî Run the install command to add this feature"
        )
        header_info.setTextFormat(Qt.TextFormat.RichText)
        header_info.setStyleSheet("font-size: 9pt; color: #444; padding: 10px; background-color: #E3F2FD; border-radius: 4px;")
        header_info.setWordWrap(True)
        main_layout.addWidget(header_info)
        
        # Size summary
        total_available = sum(f.size_mb for f in FEATURE_MODULES.values() if f.is_available())
        total_possible = sum(f.size_mb for f in FEATURE_MODULES.values())
        installed_count = sum(1 for f in FEATURE_MODULES.values() if f.is_available())
        total_count = len(FEATURE_MODULES)
        
        size_label = QLabel(
            f"üíæ <b>Status:</b> {installed_count}/{total_count} optional features installed (~{total_available} MB of ~{total_possible} MB possible)"
        )
        size_label.setTextFormat(Qt.TextFormat.RichText)
        size_label.setStyleSheet("font-size: 9pt; padding: 3px;")
        main_layout.addWidget(size_label)
        
        # === TWO-COLUMN LAYOUT ===
        columns_layout = QHBoxLayout()
        columns_layout.setSpacing(15)
        
        # LEFT COLUMN: Feature groups (scrollable)
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(10)
        
        # Group features by category
        categories = fm.get_features_by_category()
        
        for category, features in categories.items():
            group = QGroupBox(f"üìÅ {category}")
            group_layout = QVBoxLayout()
            group_layout.setSpacing(6)
            
            for feature in features:
                # Main feature row
                feature_layout = QHBoxLayout()
                feature_layout.setSpacing(8)
                
                # Status icon and name
                if feature.is_available():
                    status_text = f"‚úÖ {feature.icon} <b>{feature.name}</b>"
                    status_style = "font-size: 9pt; color: #2E7D32;"
                else:
                    status_text = f"‚ùå {feature.icon} <b>{feature.name}</b>"
                    status_style = "font-size: 9pt; color: #C62828;"
                
                name_label = QLabel(status_text)
                name_label.setTextFormat(Qt.TextFormat.RichText)
                name_label.setStyleSheet(status_style)
                feature_layout.addWidget(name_label, stretch=1)
                
                # Size label
                size_lbl = QLabel(f"~{feature.size_mb} MB")
                size_lbl.setStyleSheet("color: #666; font-size: 8pt;")
                size_lbl.setFixedWidth(55)
                feature_layout.addWidget(size_lbl)
                
                group_layout.addLayout(feature_layout)
                
                # Description + packages (always show packages)
                pkg_str = ", ".join(feature.packages)
                if feature.is_available():
                    # Installed: show packages in blue/teal
                    desc_text = (
                        f"{feature.description}<br>"
                        f"<span style='color:#0277BD; font-family:Consolas,monospace;'>üì¶ {pkg_str}</span>"
                    )
                else:
                    # Not installed: show packages in red
                    desc_text = (
                        f"{feature.description}<br>"
                        f"<span style='color:#C62828; font-family:Consolas,monospace;'>üì¶ Requires: {pkg_str}</span>"
                    )
                desc_style = "font-size: 8pt; color: #555; padding-left: 24px; padding-bottom: 6px;"
                
                desc_label = QLabel(desc_text)
                desc_label.setTextFormat(Qt.TextFormat.RichText)
                desc_label.setWordWrap(True)
                desc_label.setStyleSheet(desc_style)
                group_layout.addWidget(desc_label)
            
            group.setLayout(group_layout)
            left_layout.addWidget(group)
        
        left_layout.addStretch()
        
        # Make left side scrollable
        left_scroll = QScrollArea()
        left_scroll.setWidget(left_widget)
        left_scroll.setWidgetResizable(True)
        left_scroll.setFrameShape(QFrame.Shape.NoFrame)
        left_scroll.setMinimumWidth(400)
        
        # RIGHT COLUMN: Installation commands
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        
        # Install header
        if is_frozen_build:
            install_header_text = (
                "<b>üîß Installation Commands</b><br>"
                "<span style='font-size:8pt; color:#666;'>These commands apply to the <b>Python/pip</b> install (not the Windows EXE build).</span>"
            )
        else:
            install_header_text = (
                "<b>üîß Installation Commands</b><br>"
                "<span style='font-size:8pt; color:#666;'>Run in Terminal to add features</span>"
            )
        install_header = QLabel(install_header_text)
        install_header.setTextFormat(Qt.TextFormat.RichText)
        install_header.setStyleSheet("padding: 5px;")
        right_layout.addWidget(install_header)
        
        # Terminal style for both text boxes
        terminal_style = """
            QTextEdit {
                font-family: Consolas, 'Courier New', monospace;
                font-size: 9pt;
                background-color: #1E1E1E;
                color: #D4D4D4;
                padding: 8px;
                border: 1px solid #333;
                border-radius: 4px;
            }
            QScrollBar:vertical {
                background-color: #2D2D2D;
                width: 12px;
            }
            QScrollBar::handle:vertical {
                background-color: #5A5A5A;
                border-radius: 5px;
                min-height: 20px;
                margin: 2px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #787878;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """
        
        # Tabs for PyPI vs Repo
        commands_tabs = QTabWidget()
        commands_tabs.setStyleSheet("QTabWidget::pane { border: none; }")
        
        # Tab 1: PyPI install
        pypi_text = QTextEdit()
        pypi_text.setReadOnly(True)
        pypi_text.setStyleSheet(terminal_style)
        if is_frozen_build:
            pypi_prefix = (
                "# WINDOWS EXE BUILD NOTE\n"
                "# This portable EXE does not support installing extras via pip inside the app.\n"
                "# To add Local Whisper: Download the FULL Windows build from GitHub releases.\n"
                "#\n"
                "# Releases: https://github.com/michaelbeijer/Supervertaler/releases/latest\n\n"
            )
        else:
            pypi_prefix = "# If you installed via: pip install supervertaler\n\n"

        pypi_text.setPlainText(
            pypi_prefix +
            "# ADD FEATURES:\n"
            "pip install supervertaler[voice]       # ~150 MB\n"
            "pip install supervertaler[web]         # ~100 MB\n"
            "pip install supervertaler[pdf]         # ~30 MB\n"
            "pip install supervertaler[mt]          # ~30 MB\n\n"
            "# MULTIPLE:\n"
            "pip install supervertaler[voice,web]\n\n"
            "# EVERYTHING:\n"
            "pip install supervertaler[all]         # ~300 MB\n\n"
            "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            "# EXTRAS (copy-paste these names):\n"
            "# voice, web, pdf, mt, hunspell, windows\n"
            "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
        commands_tabs.addTab(pypi_text, "üì¶ PyPI")
        
        # Tab 2: Repo clone
        repo_text = QTextEdit()
        repo_text.setReadOnly(True)
        repo_text.setStyleSheet(terminal_style)
        if is_frozen_build:
            repo_prefix = (
                "# PYTHON DEV INSTALL NOTE\n"
                "# These commands are for developers / Python installs (not the EXE build).\n\n"
            )
        else:
            repo_prefix = "# If you cloned from GitHub:\n\n"

        repo_text.setPlainText(
            repo_prefix +
            "# OPTION A - Direct install:\n"
            "pip install .\n"
            "pip install sounddevice numpy\n"
            "pip install supervertaler[local-whisper]  # Optional: offline Local Whisper (heavy)\n"
            "pip install PyQt6-WebEngine\n"
            "pip install PyMuPDF\n"
            "pip install deepl boto3\n\n"
            "# OPTION B - Editable install:\n"
            "cd C:\\path\\to\\Supervertaler\n"
            "pip install -e .\n"
            "pip install -e .[all]  # Everything\n\n"
            "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            "# ALL PACKAGES (copy-paste):\n"
            "# sounddevice PyQt6-WebEngine PyMuPDF deepl boto3\n"
            "# spylls keyboard ahk\n"
            "#\n"
            "# spylls = Pure Python Hunspell (works on Windows!)\n"
            "# Supports regional variants like en-US, en-GB, etc.\n"
            "# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
        commands_tabs.addTab(repo_text, "üìÇ Repo")
        
        right_layout.addWidget(commands_tabs, stretch=1)
        
        # Tip at bottom of right column
        tip_label = QLabel(
            "<i>üí° Tip: Install only what you need to save disk space!</i>"
        )
        tip_label.setTextFormat(Qt.TextFormat.RichText)
        tip_label.setStyleSheet("font-size: 8pt; color: #666; padding: 5px;")
        right_layout.addWidget(tip_label)
        
        # Add columns to layout
        columns_layout.addWidget(left_scroll, stretch=2)
        columns_layout.addWidget(right_widget, stretch=1)
        
        main_layout.addLayout(columns_layout, stretch=1)
        
        return tab
    
    def _save_debug_settings_from_ui(self, debug_mode_cb, debug_export_cb, debounce_spin):
        """Save debug settings from UI"""
        self.debug_mode_enabled = debug_mode_cb.isChecked()
        self.debug_auto_export = debug_export_cb.isChecked()
        
        general_settings = self.load_general_settings()
        general_settings['debug_mode_enabled'] = self.debug_mode_enabled
        general_settings['debug_auto_export'] = self.debug_auto_export
        general_settings['target_debounce_delay'] = debounce_spin.value()
        self.save_general_settings(general_settings)
        
        self.log(f"‚úì Debug settings saved: Debug Mode={'ON' if self.debug_mode_enabled else 'OFF'}, Auto-export={'ON' if self.debug_auto_export else 'OFF'}")
        QMessageBox.information(self, "Settings Saved", "Debug settings have been saved successfully.")
    
    def export_debug_log_now(self):
        """Export debug log buffer to file immediately"""
        from datetime import datetime
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"supervertaler_debug_log_{timestamp}.txt"
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"Supervertaler Debug Log\n")
                f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write("="*80 + "\n\n")
                
                if self.debug_log_buffer:
                    f.write("\n".join(self.debug_log_buffer))
                else:
                    f.write("(No debug logs in buffer)")
            
            self.log(f"‚úì Debug log exported to: {filename}")
            QMessageBox.information(
                self,
                "Log Exported",
                f"Debug log exported successfully to:\n{filename}\n\n"
                f"Log entries: {len(self.debug_log_buffer)}"
            )
        except Exception as e:
            self.log(f"‚ùå Error exporting debug log: {e}")
            QMessageBox.warning(self, "Export Failed", f"Failed to export debug log:\n{e}")
    
    def clear_debug_log_buffer(self):
        """Clear the debug log buffer"""
        buffer_size = len(self.debug_log_buffer)
        self.debug_log_buffer.clear()
        self.log(f"‚úì Debug log buffer cleared ({buffer_size} entries removed)")
        QMessageBox.information(self, "Buffer Cleared", f"Debug log buffer cleared.\n{buffer_size} entries removed.")

    def _create_domain_keywords_tab(self):
        """Create Domain Detection Keywords tab content"""
        from PyQt6.QtWidgets import QGroupBox, QPushButton, QTextEdit, QTabWidget

        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)

        # Introduction
        intro_label = QLabel(
            "<h3>üéØ Automated Domain Detection</h3>"
            "<p>Supervertaler automatically identifies document types (Legal, Medical, Technical, Patent) "
            "to generate domain-appropriate translation prompts.</p>"
            "<p><b>Keywords below</b> are used for detection. The system counts matches and selects the domain "
            "with the highest score (minimum 2 matches required).</p>"
            "<p>üí° <b>Tip:</b> Add domain-specific terminology to improve detection accuracy for your projects.</p>"
        )
        intro_label.setWordWrap(True)
        intro_label.setStyleSheet("font-size: 10pt; padding: 10px; border-radius: 4px;")
        layout.addWidget(intro_label)

        # Load current keywords from prompt_manager_qt.py default lists
        keywords = self._load_domain_keywords()

        # Create tab widget for each domain
        domain_tabs = QTabWidget()
        domain_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        domain_tabs.tabBar().setDrawBase(False)
        domain_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")

        # Legal domain
        legal_tab = QWidget()
        legal_layout = QVBoxLayout(legal_tab)
        legal_info = QLabel("<b>Legal/Notarial Documents:</b> Notarial deeds, contracts, court documents, Belgian law")
        legal_info.setWordWrap(True)
        legal_layout.addWidget(legal_info)
        self.legal_keywords_edit = QTextEdit()
        self.legal_keywords_edit.setPlainText("\n".join(keywords['legal']))
        self.legal_keywords_edit.setPlaceholderText("Enter keywords, one per line...")
        legal_layout.addWidget(self.legal_keywords_edit)
        domain_tabs.addTab(legal_tab, "‚öñÔ∏è Legal")

        # Medical domain
        medical_tab = QWidget()
        medical_layout = QVBoxLayout(medical_tab)
        medical_info = QLabel("<b>Medical Documents:</b> Clinical reports, procedures, pharmaceutical documents")
        medical_info.setWordWrap(True)
        medical_layout.addWidget(medical_info)
        self.medical_keywords_edit = QTextEdit()
        self.medical_keywords_edit.setPlainText("\n".join(keywords['medical']))
        self.medical_keywords_edit.setPlaceholderText("Enter keywords, one per line...")
        medical_layout.addWidget(self.medical_keywords_edit)
        domain_tabs.addTab(medical_tab, "üè• Medical")

        # Patent domain
        patent_tab = QWidget()
        patent_layout = QVBoxLayout(patent_tab)
        patent_info = QLabel("<b>Patent Documents:</b> Patent applications, claims, prior art references")
        patent_info.setWordWrap(True)
        patent_layout.addWidget(patent_info)
        self.patent_keywords_edit = QTextEdit()
        self.patent_keywords_edit.setPlainText("\n".join(keywords['patent']))
        self.patent_keywords_edit.setPlaceholderText("Enter keywords, one per line...")
        patent_layout.addWidget(self.patent_keywords_edit)
        domain_tabs.addTab(patent_tab, "üî¨ Patent")

        # Technical domain
        technical_tab = QWidget()
        technical_layout = QVBoxLayout(technical_tab)
        technical_info = QLabel("<b>Technical Documents:</b> Manuals, specifications, installation guides")
        technical_info.setWordWrap(True)
        technical_layout.addWidget(technical_info)
        self.technical_keywords_edit = QTextEdit()
        self.technical_keywords_edit.setPlainText("\n".join(keywords['technical']))
        self.technical_keywords_edit.setPlaceholderText("Enter keywords, one per line...")
        technical_layout.addWidget(self.technical_keywords_edit)
        domain_tabs.addTab(technical_tab, "üîß Technical")

        layout.addWidget(domain_tabs)

        # Save and Reset buttons
        buttons_layout = QHBoxLayout()

        reset_btn = QPushButton("üîÑ Reset to Defaults")
        reset_btn.setToolTip("Reset all keyword lists to default values")
        reset_btn.clicked.connect(self._reset_domain_keywords_to_defaults)
        buttons_layout.addWidget(reset_btn)

        buttons_layout.addStretch()

        save_btn = QPushButton("üíæ Save Domain Keywords")
        save_btn.setToolTip("Save custom domain detection keywords")
        save_btn.clicked.connect(self._save_domain_keywords)
        save_btn.setStyleSheet("font-weight: bold; padding: 8px 16px;")
        buttons_layout.addWidget(save_btn)

        layout.addLayout(buttons_layout)

        return tab

    def _load_domain_keywords(self):
        """Load domain keywords from settings or use defaults"""
        settings = self.load_general_settings()

        # Default keywords - MULTILINGUAL (matches prompt_manager_qt.py)
        # Includes English + Dutch + French + German keywords
        defaults = {
            'legal': [
                # English
                'notarial deed', 'notary', 'legal contract', 'deed of', 'legal document',
                'testament', 'mortgage', 'clause', 'hereby', 'whereas', 'contractual',
                'court', 'judgment', 'plaintiff', 'defendant', 'attorney', 'barrister',
                'articles of association', 'general meeting', 'extraordinary general meeting',
                # Dutch/Flemish
                'notari√´le akte', 'notaris', 'rechtbank', 'vonnis', 'statuten',
                'algemene vergadering', 'buitengewone algemene vergadering', 'meester',
                'advocaat', 'artikel', 'wetboek', 'rechtspersonenregister',
                # French
                'acte notari√©', 'notaire', 'tribunal', 'jugement', 'statuts',
                'assembl√©e g√©n√©rale', 'ma√Ætre',
                # German
                'notarielle urkunde', 'notar', 'gericht', 'urteil', 'satzung'
            ],
            'medical': [
                # English
                'patient', 'diagnosis', 'medical', 'clinical', 'procedure',
                'treatment', 'symptom', 'disease', 'medication', 'pharmaceutical',
                'surgery', 'anatomical', 'pathology', 'radiology', 'hospital',
                # Dutch
                'pati√´nt', 'diagnose', 'medisch', 'klinisch', 'behandeling',
                'symptoom', 'ziekte', 'medicijn', 'chirurgie', 'ziekenhuis',
                # French
                'm√©dical', 'clinique', 'traitement', 'sympt√¥me', 'maladie',
                'm√©dicament', 'chirurgie', 'h√¥pital',
                # German
                'medizinisch', 'klinisch', 'behandlung', 'symptom', 'krankheit',
                'medikament', 'krankenhaus'
            ],
            'patent': [
                # English
                'patent', 'claim', 'invention', 'embodiment', 'prior art',
                'apparatus', 'method comprising', 'said', 'wherein', 'configured to',
                # Dutch
                'octrooi', 'conclusie', 'uitvinding', 'uitvoeringsvorm',
                # French
                'brevet', 'revendication', 'invention', 'mode de r√©alisation',
                # German
                'patentanspruch', 'erfindung', 'ausf√ºhrungsform'
            ],
            'technical': [
                # English
                'specification', 'component', 'assembly', 'technical manual',
                'installation', 'maintenance', 'user guide', 'operating instructions',
                'safety warning', 'dimensions', 'tolerance',
                # Dutch
                'specificatie', 'onderdeel', 'montage', 'technische handleiding',
                'installatie', 'onderhoud', 'gebruikershandleiding', 'veiligheidswaarschuwing',
                # French
                'sp√©cification', 'composant', 'assemblage', 'manuel technique',
                'entretien', 'avertissement de s√©curit√©',
                # German
                'spezifikation', 'komponente', 'montage', 'technisches handbuch',
                'wartung', 'sicherheitswarnung'
            ]
        }

        # Load custom keywords if saved
        return {
            'legal': settings.get('domain_keywords_legal', defaults['legal']),
            'medical': settings.get('domain_keywords_medical', defaults['medical']),
            'patent': settings.get('domain_keywords_patent', defaults['patent']),
            'technical': settings.get('domain_keywords_technical', defaults['technical'])
        }

    def _save_domain_keywords(self):
        """Save domain detection keywords to settings"""
        keywords = {
            'domain_keywords_legal': [kw.strip() for kw in self.legal_keywords_edit.toPlainText().split('\n') if kw.strip()],
            'domain_keywords_medical': [kw.strip() for kw in self.medical_keywords_edit.toPlainText().split('\n') if kw.strip()],
            'domain_keywords_patent': [kw.strip() for kw in self.patent_keywords_edit.toPlainText().split('\n') if kw.strip()],
            'domain_keywords_technical': [kw.strip() for kw in self.technical_keywords_edit.toPlainText().split('\n') if kw.strip()]
        }

        # Save to general settings
        settings = self.load_general_settings()
        settings.update(keywords)
        self.save_general_settings(settings)

        self.log(f"‚úì Domain detection keywords saved")
        QMessageBox.information(
            self,
            "Keywords Saved",
            "Domain detection keywords have been saved successfully.\n\n"
            "The updated keywords will be used for automatic domain detection "
            "when generating translation prompts."
        )

    def _reset_domain_keywords_to_defaults(self):
        """Reset all domain keywords to default values"""
        reply = QMessageBox.question(
            self,
            "Reset to Defaults",
            "Are you sure you want to reset all domain keywords to their default values?\n\n"
            "This will overwrite any custom keywords you've added.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )

        if reply == QMessageBox.StandardButton.Yes:
            defaults = self._load_domain_keywords()  # Gets defaults when no custom settings exist

            # Clear saved keywords from settings
            settings = self.load_general_settings()
            settings.pop('domain_keywords_legal', None)
            settings.pop('domain_keywords_medical', None)
            settings.pop('domain_keywords_patent', None)
            settings.pop('domain_keywords_technical', None)
            self.save_general_settings(settings)

            # Reload defaults and update UI
            defaults = self._load_domain_keywords()
            self.legal_keywords_edit.setPlainText("\n".join(defaults['legal']))
            self.medical_keywords_edit.setPlainText("\n".join(defaults['medical']))
            self.patent_keywords_edit.setPlainText("\n".join(defaults['patent']))
            self.technical_keywords_edit.setPlainText("\n".join(defaults['technical']))

            self.log("‚úì Domain keywords reset to defaults")
            QMessageBox.information(self, "Reset Complete", "Domain keywords have been reset to default values.")

    def _save_llm_settings_from_ui(self, openai_radio, claude_radio, gemini_radio, ollama_radio,
                                   openai_combo, claude_combo, gemini_combo,
                                   ollama_status_widget,
                                   openai_enable_cb, claude_enable_cb, gemini_enable_cb, ollama_enable_cb,
                                   batch_size_spin, surrounding_spin, full_context_cb, context_slider,
                                   tm_no_check_rb, tm_fuzzy_rb, tm_exact_rb, auto_propagate_cb,
                                   delay_spin):
        """Save LLM settings from UI"""
        # Determine selected provider
        if openai_radio.isChecked():
            provider = 'openai'
        elif claude_radio.isChecked():
            provider = 'claude'
        elif gemini_radio.isChecked():
            provider = 'gemini'
        elif ollama_radio.isChecked():
            provider = 'ollama'
        else:
            provider = 'openai'  # Default fallback
        
        # Get Ollama model from widget if available
        ollama_model = 'qwen2.5:7b'  # Default
        if ollama_status_widget and hasattr(ollama_status_widget, 'get_selected_model'):
            selected = ollama_status_widget.get_selected_model()
            if selected:
                ollama_model = selected
        
        new_settings = {
            'provider': provider,
            'openai_model': openai_combo.currentText().split()[0],
            'claude_model': claude_combo.currentText().split()[0],
            'gemini_model': gemini_combo.currentText().split()[0],
            'ollama_model': ollama_model
        }
        self.save_llm_settings(new_settings)

        # Update current provider and model attributes for AI Assistant
        self.current_provider = new_settings['provider']
        provider_key = f"{self.current_provider}_model"
        self.current_model = new_settings.get(provider_key)

        enabled_states = {
            'llm_openai': openai_enable_cb.isChecked(),
            'llm_claude': claude_enable_cb.isChecked(),
            'llm_gemini': gemini_enable_cb.isChecked(),
            'llm_ollama': ollama_enable_cb.isChecked()
        }
        # Merge with existing MT settings
        existing = self.load_provider_enabled_states()
        enabled_states.update({k: v for k, v in existing.items() if k.startswith('mt_')})
        self.save_provider_enabled_states(enabled_states)
        
        # Save translation preferences
        general_prefs = self.load_general_settings()
        general_prefs['batch_size'] = batch_size_spin.value()
        general_prefs['surrounding_segments'] = surrounding_spin.value()
        general_prefs['use_full_context'] = full_context_cb.isChecked()
        general_prefs['context_window_size'] = context_slider.value()
        # Save TM check mode settings
        general_prefs['check_tm_before_api'] = not tm_no_check_rb.isChecked()
        general_prefs['check_tm_exact_only'] = tm_exact_rb.isChecked()
        general_prefs['auto_propagate_100'] = auto_propagate_cb.isChecked()
        general_prefs['lookup_delay'] = delay_spin.value()
        self.save_general_settings(general_prefs)
        
        # Update LLM indicator in status bar
        self._update_llm_indicator()
        
        self.log(f"‚úì LLM settings saved: Provider={new_settings['provider']}, Batch Size={batch_size_spin.value()}")
        QMessageBox.information(self, "Settings Saved", "LLM settings have been saved successfully.")
    
    def _save_ai_settings_from_ui(self, openai_radio, claude_radio, gemini_radio, ollama_radio,
                                   openai_combo, claude_combo, gemini_combo,
                                   ollama_status_widget,
                                   openai_enable_cb, claude_enable_cb, gemini_enable_cb, ollama_enable_cb,
                                   batch_size_spin, surrounding_spin, full_context_cb, context_slider,
                                   tm_no_check_rb, tm_fuzzy_rb, tm_exact_rb, auto_propagate_cb, delay_spin,
                                   ollama_keepwarm_cb,
                                   llm_matching_cb, auto_markdown_cb, llm_spin,
                                   quickmenu_context_slider):
        """Save all AI settings from the unified AI Settings tab"""
        # Determine selected provider
        if openai_radio.isChecked():
            provider = 'openai'
        elif claude_radio.isChecked():
            provider = 'claude'
        elif gemini_radio.isChecked():
            provider = 'gemini'
        elif ollama_radio.isChecked():
            provider = 'ollama'
        else:
            provider = 'openai'  # Default fallback
        
        # Get Ollama model from widget if available
        ollama_model = 'qwen2.5:7b'  # Default
        if ollama_status_widget and hasattr(ollama_status_widget, 'get_selected_model'):
            selected = ollama_status_widget.get_selected_model()
            if selected:
                ollama_model = selected
        
        new_settings = {
            'provider': provider,
            'openai_model': openai_combo.currentText().split()[0],
            'claude_model': claude_combo.currentText().split()[0],
            'gemini_model': gemini_combo.currentText().split()[0],
            'ollama_model': ollama_model
        }
        self.save_llm_settings(new_settings)

        # Update current provider and model attributes for AI Assistant
        self.current_provider = new_settings['provider']
        provider_key = f"{self.current_provider}_model"
        self.current_model = new_settings.get(provider_key)

        # Save LLM provider enabled states
        enabled_states = {
            'llm_openai': openai_enable_cb.isChecked(),
            'llm_claude': claude_enable_cb.isChecked(),
            'llm_gemini': gemini_enable_cb.isChecked(),
            'llm_ollama': ollama_enable_cb.isChecked()
        }
        # Merge with existing MT settings
        existing = self.load_provider_enabled_states()
        enabled_states.update({k: v for k, v in existing.items() if k.startswith('mt_')})
        self.save_provider_enabled_states(enabled_states)
        
        # Update LLM matching setting
        self.enable_llm_matching = llm_matching_cb.isChecked()
        
        # Update auto-markdown setting
        self.auto_generate_markdown = auto_markdown_cb.isChecked()
        
        # Save all general settings including AI-related ones
        general_prefs = self.load_general_settings()
        general_prefs['batch_size'] = batch_size_spin.value()
        general_prefs['surrounding_segments'] = surrounding_spin.value()
        general_prefs['use_full_context'] = full_context_cb.isChecked()
        general_prefs['context_window_size'] = context_slider.value()
        general_prefs['quickmenu_context_percent'] = quickmenu_context_slider.value()
        # Save TM check mode settings
        general_prefs['check_tm_before_api'] = not tm_no_check_rb.isChecked()
        general_prefs['check_tm_exact_only'] = tm_exact_rb.isChecked()
        general_prefs['auto_propagate_100'] = auto_propagate_cb.isChecked()
        general_prefs['lookup_delay'] = delay_spin.value()
        general_prefs['ollama_keepwarm'] = ollama_keepwarm_cb.isChecked()
        general_prefs['enable_llm_matching'] = llm_matching_cb.isChecked()
        general_prefs['auto_generate_markdown'] = auto_markdown_cb.isChecked()
        general_prefs['auto_check_models'] = self.auto_check_models_cb.isChecked()
        
        # Update LLM match limits
        if 'match_limits' not in general_prefs:
            general_prefs['match_limits'] = {}
        general_prefs['match_limits']['LLM'] = llm_spin.value()
        
        self.save_general_settings(general_prefs)
        
        # Handle Ollama keep-warm timer
        if ollama_keepwarm_cb.isChecked():
            self._start_ollama_keepwarm_timer()
        else:
            self._stop_ollama_keepwarm_timer()
        
        # Apply LLM match limits to results panels
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                if hasattr(panel, 'match_limits'):
                    panel.match_limits['LLM'] = llm_spin.value()
        
        # Update LLM indicator in status bar
        self._update_llm_indicator()
        
        self.log(f"‚úì AI settings saved: Provider={provider}, Model={self.current_model}")
        QMessageBox.information(self, "Settings Saved", "AI settings have been saved successfully.")
    
    def _save_mt_settings_from_ui(self, google_cb, deepl_cb, microsoft_cb, amazon_cb, modernmt_cb, mymemory_cb):
        """Save MT settings from UI"""
        enabled_states = {
            'mt_google_translate': google_cb.isChecked(),
            'mt_deepl': deepl_cb.isChecked(),
            'mt_microsoft': microsoft_cb.isChecked(),
            'mt_amazon': amazon_cb.isChecked(),
            'mt_modernmt': modernmt_cb.isChecked(),
            'mt_mymemory': mymemory_cb.isChecked()
        }
        # Merge with existing LLM settings
        existing = self.load_provider_enabled_states()
        enabled_states.update({k: v for k, v in existing.items() if k.startswith('llm_')})
        self.save_provider_enabled_states(enabled_states)
        
        self.log("‚úì MT settings saved")
        QMessageBox.information(self, "Settings Saved", "MT settings have been saved successfully.")
    
    def _save_general_settings_from_ui(self, restore_cb, allow_replace_cb, auto_propagate_cb,
                                       llm_spin=None, mt_spin=None, tm_limit_spin=None, tb_spin=None,
                                       auto_open_log_cb=None, auto_insert_100_cb=None, tm_save_mode_combo=None, tb_highlight_cb=None,
                                       enable_backup_cb=None, backup_interval_spin=None,
                                       tb_order_combo=None, tb_hide_shorter_cb=None, smart_selection_cb=None,
                                       ahk_path_edit=None, auto_center_cb=None, auto_confirm_100_cb=None,
                                       auto_confirm_overwrite_cb=None, sound_effects_cb=None, sound_event_combos=None,
                                       disable_cache_cb=None):
        """Save general settings from UI (non-AI settings only)"""
        self.allow_replace_in_source = allow_replace_cb.isChecked()
        self.update_warning_banner()

        # Update auto-propagate state
        self.auto_propagate_exact_matches = auto_propagate_cb.isChecked()
        
        # Update auto-insert setting
        if auto_insert_100_cb is not None:
            self.auto_insert_100_percent_matches = auto_insert_100_cb.isChecked()
        
        # Update auto-confirm 100% matches setting
        if auto_confirm_100_cb is not None:
            self.auto_confirm_100_percent_matches = auto_confirm_100_cb.isChecked()
        
        # Update auto-confirm overwrite existing setting
        if auto_confirm_overwrite_cb is not None:
            self.auto_confirm_overwrite_existing = auto_confirm_overwrite_cb.isChecked()
        
        # Update auto-center active segment setting
        if auto_center_cb is not None:
            self.auto_center_active_segment = auto_center_cb.isChecked()
            self.log(f"üíæ Saving auto-center setting: {self.auto_center_active_segment}")
        
        # Update termbase grid highlighting setting
        if tb_highlight_cb is not None:
            self.enable_termbase_grid_highlighting = tb_highlight_cb.isChecked()

        # Update termbase display settings
        if tb_order_combo is not None:
            self.termbase_display_order = tb_order_combo.currentData()
        if tb_hide_shorter_cb is not None:
            self.termbase_hide_shorter_matches = tb_hide_shorter_cb.isChecked()

        # Load existing settings to preserve AI-related ones
        existing_settings = self.load_general_settings()
        
        general_settings = {
            'restore_last_project': restore_cb.isChecked(),
            'auto_open_log': auto_open_log_cb.isChecked() if auto_open_log_cb is not None else False,
            'auto_propagate_exact_matches': self.auto_propagate_checkbox.isChecked() if hasattr(self, 'auto_propagate_checkbox') else self.auto_propagate_exact_matches,
            'auto_insert_100_percent_matches': auto_insert_100_cb.isChecked() if auto_insert_100_cb is not None else (self.auto_insert_100_checkbox.isChecked() if hasattr(self, 'auto_insert_100_checkbox') else True),
            'auto_confirm_100_percent_matches': auto_confirm_100_cb.isChecked() if auto_confirm_100_cb is not None else False,
            'auto_confirm_overwrite_existing': auto_confirm_overwrite_cb.isChecked() if auto_confirm_overwrite_cb is not None else False,
            'tm_save_mode': tm_save_mode_combo.currentData() if tm_save_mode_combo is not None else 'latest',
            'auto_generate_markdown': existing_settings.get('auto_generate_markdown', False),  # Preserve AI setting
            'enable_termbase_grid_highlighting': tb_highlight_cb.isChecked() if tb_highlight_cb is not None else True,
            'enable_llm_matching': existing_settings.get('enable_llm_matching', False),  # Preserve AI setting
            'termbase_display_order': tb_order_combo.currentData() if tb_order_combo is not None else 'appearance',
            'termbase_hide_shorter_matches': tb_hide_shorter_cb.isChecked() if tb_hide_shorter_cb is not None else False,
            'enable_smart_word_selection': smart_selection_cb.isChecked() if smart_selection_cb is not None else True,
            'precision_scroll_divisor': self.precision_spin.value() if hasattr(self, 'precision_spin') else 3,
            'auto_center_active_segment': self.auto_center_cb.isChecked() if hasattr(self, 'auto_center_cb') else False,
            'enable_auto_backup': enable_backup_cb.isChecked() if enable_backup_cb is not None else True,
            'backup_interval_minutes': backup_interval_spin.value() if backup_interval_spin is not None else 5,
            'ollama_keepwarm': existing_settings.get('ollama_keepwarm', False),  # Preserve AI setting
            'grid_font_size': self.default_font_size,
            'results_match_font_size': 9,
            'results_compare_font_size': 9,
            'autohotkey_path': ahk_path_edit.text().strip() if ahk_path_edit is not None else existing_settings.get('autohotkey_path', ''),
            'enable_sound_effects': sound_effects_cb.isChecked() if sound_effects_cb is not None else existing_settings.get('enable_sound_effects', False),
            'disable_all_caches': disable_cache_cb.isChecked() if disable_cache_cb is not None else existing_settings.get('disable_all_caches', False)
        }

        # Keep a fast-access instance value
        self.enable_sound_effects = general_settings.get('enable_sound_effects', False)
        
        # Update cache kill switch
        if disable_cache_cb is not None:
            self.disable_all_caches = disable_cache_cb.isChecked()
            if self.disable_all_caches:
                self.log("üß™ EXPERIMENTAL: All caches DISABLED - direct lookups enabled")
                # Stop any running background workers that use the database
                if hasattr(self, 'termbase_batch_stop_event'):
                    self.termbase_batch_stop_event.set()
                if hasattr(self, 'prefetch_stop_event'):
                    self.prefetch_stop_event.set()
            else:
                self.log("‚úì Caches enabled (normal mode)")

        # Persist per-event sound mapping
        existing_map = existing_settings.get('sound_effects_map', {}) if isinstance(existing_settings, dict) else {}
        new_map = dict(existing_map) if isinstance(existing_map, dict) else {}
        if isinstance(sound_event_combos, dict):
            for event_key, combo in sound_event_combos.items():
                try:
                    new_map[event_key] = combo.currentData()
                except Exception:
                    pass
        # Ensure key exists even if UI wasn't present
        if 'glossary_term_added' not in new_map:
            new_map['glossary_term_added'] = existing_map.get('glossary_term_added', 'asterisk') if isinstance(existing_map, dict) else 'asterisk'
        if 'glossary_created' not in new_map:
            new_map['glossary_created'] = existing_map.get('glossary_created', 'asterisk') if isinstance(existing_map, dict) else 'asterisk'
        if 'match_inserted' not in new_map:
            new_map['match_inserted'] = existing_map.get('match_inserted', 'ok') if isinstance(existing_map, dict) else 'ok'
        if 'glossary_term_duplicate' not in new_map:
            new_map['glossary_term_duplicate'] = existing_map.get('glossary_term_duplicate', 'exclamation') if isinstance(existing_map, dict) else 'exclamation'
        if 'glossary_term_error' not in new_map:
            new_map['glossary_term_error'] = existing_map.get('glossary_term_error', 'hand') if isinstance(existing_map, dict) else 'hand'

        general_settings['sound_effects_map'] = new_map
        self.sound_effects_map = new_map
        
        # Add match limits if provided (MT, TM, Termbase - LLM is handled in AI Settings)
        if all([mt_spin, tm_limit_spin, tb_spin]):
            existing_limits = existing_settings.get('match_limits', {})
            general_settings['match_limits'] = {
                'LLM': existing_limits.get('LLM', 3),  # Preserve LLM limit from AI settings
                'MT': mt_spin.value(),
                'TM': tm_limit_spin.value(),
                'Termbases': tb_spin.value()
            }
            # Apply to all results panels immediately
            if hasattr(self, 'results_panels'):
                for panel in self.results_panels:
                    panel.match_limits = general_settings['match_limits']
        
        # Update instance variable from checkbox
        if auto_insert_100_cb is not None:
            self.auto_insert_100_percent_matches = auto_insert_100_cb.isChecked()
        elif hasattr(self, 'auto_insert_100_checkbox'):
            self.auto_insert_100_percent_matches = self.auto_insert_100_checkbox.isChecked()
        
        # Update TM save mode
        if tm_save_mode_combo is not None:
            self.tm_save_mode = tm_save_mode_combo.currentData()
        
        self.save_general_settings(general_settings)

        # If a project is active, also save settings to project file (project overrides)
        if self.current_project:
            self.current_project.general_settings_overrides = {
                'auto_center_active_segment': self.auto_center_active_segment,
                'auto_propagate_exact_matches': self.auto_propagate_exact_matches,
                'auto_insert_100_percent_matches': self.auto_insert_100_percent_matches,
                'auto_confirm_100_percent_matches': self.auto_confirm_100_percent_matches,
                'auto_confirm_overwrite_existing': self.auto_confirm_overwrite_existing,
                'enable_termbase_grid_highlighting': self.enable_termbase_grid_highlighting,
                'precision_scroll_divisor': self.precision_scroll_divisor,
                'termbase_display_order': self.termbase_display_order,
                'termbase_hide_shorter_matches': self.termbase_hide_shorter_matches,
                'enable_smart_word_selection': self.enable_smart_word_selection,
                'enable_sound_effects': self.enable_sound_effects,
                'sound_effects_map': getattr(self, 'sound_effects_map', {}),
            }
            self.log("üíæ Settings also saved to active project")
            self.project_modified = True  # Mark project as modified

        # Restart auto backup timer if settings changed
        if enable_backup_cb is not None or backup_interval_spin is not None:
            self.restart_auto_backup_timer()

        self.log("‚úì General settings saved")
        QMessageBox.information(self, "Settings Saved", "General settings have been saved successfully.")
    
    def _save_view_settings_from_ui(self, grid_spin, match_spin, compare_spin, show_tags_check=None, tag_color_btn=None,
                                     alt_colors_check=None, even_color_btn=None, odd_color_btn=None, invisible_char_color_btn=None,
                                     grid_font_family_combo=None, termview_font_family_combo=None, termview_font_spin=None, termview_bold_check=None,
                                     border_color_btn=None, border_thickness_spin=None, badge_text_color_btn=None, tabs_above_check=None):
        """Save view settings from UI"""
        general_settings = {
            'restore_last_project': self.load_general_settings().get('restore_last_project', False),
            'auto_propagate_exact_matches': self.auto_propagate_exact_matches,  # Keep existing value
            'grid_font_size': grid_spin.value(),
            'results_match_font_size': match_spin.value(),
            'results_compare_font_size': compare_spin.value(),
            'enable_tm_termbase_matching': self.enable_tm_matching  # Save TM/termbase matching state
        }
        
        # Add tabs above grid setting if provided
        if tabs_above_check is not None:
            general_settings['tabs_above_grid'] = tabs_above_check.isChecked()
            self.tabs_above_grid = tabs_above_check.isChecked()
        
        # Add font family if provided
        if grid_font_family_combo is not None:
            general_settings['grid_font_family'] = grid_font_family_combo.currentText()
        
        # Add Termview font settings if provided
        if termview_font_family_combo is not None:
            general_settings['termview_font_family'] = termview_font_family_combo.currentText()
        if termview_font_spin is not None:
            general_settings['termview_font_size'] = termview_font_spin.value()
        if termview_bold_check is not None:
            general_settings['termview_font_bold'] = termview_bold_check.isChecked()

        # Add tag color if provided
        if tag_color_btn:
            tag_color = tag_color_btn.property('selected_color')
            if tag_color:
                general_settings['tag_highlight_color'] = tag_color
                EditableGridTextEditor.tag_highlight_color = tag_color

        # Add badge text color if provided
        if badge_text_color_btn:
            badge_text_color = badge_text_color_btn.property('selected_color')
            if badge_text_color:
                general_settings['badge_text_color'] = badge_text_color
                from modules.translation_results_panel import CompactMatchItem
                CompactMatchItem.badge_text_color = badge_text_color

        # Add invisible character color if provided
        if invisible_char_color_btn:
            invisible_char_color = invisible_char_color_btn.property('selected_color')
            if invisible_char_color:
                general_settings['invisible_char_color'] = invisible_char_color
                self.invisible_char_color = invisible_char_color
        
        # Add focus border settings if provided
        if border_color_btn is not None:
            border_color = border_color_btn.property('selected_color')
            # Fallback: if property is empty, try to parse from stylesheet
            if not border_color:
                style = border_color_btn.styleSheet()
                if 'background-color:' in style:
                    import re
                    match = re.search(r'background-color:\s*(#[0-9A-Fa-f]{6})', style)
                    if match:
                        border_color = match.group(1)
            if border_color:
                general_settings['focus_border_color'] = border_color
                EditableGridTextEditor.focus_border_color = border_color
        
        if border_thickness_spin is not None:
            thickness = border_thickness_spin.value()
            general_settings['focus_border_thickness'] = thickness
            EditableGridTextEditor.focus_border_thickness = thickness
        
        # Add alternating row color settings
        if alt_colors_check is not None:
            general_settings['enable_alternating_row_colors'] = alt_colors_check.isChecked()
            self.enable_alternating_row_colors = alt_colors_check.isChecked()
        
        if even_color_btn is not None:
            even_color = even_color_btn.property('selected_color')
            if even_color:
                general_settings['even_row_color'] = even_color
                self.even_row_color = even_color
        
        if odd_color_btn is not None:
            odd_color = odd_color_btn.property('selected_color')
            if odd_color:
                general_settings['odd_row_color'] = odd_color
                self.odd_row_color = odd_color
        
        # Save termbase highlight style settings
        if hasattr(self, '_tb_style_group') and self._tb_style_group is not None:
            checked_id = self._tb_style_group.checkedId()
            style_map = {0: 'background', 1: 'dotted', 2: 'semibold'}
            tb_style = style_map.get(checked_id, 'background')
            general_settings['termbase_highlight_style'] = tb_style
            self.termbase_highlight_style = tb_style
        
        if hasattr(self, '_tb_dotted_color_btn') and self._tb_dotted_color_btn is not None:
            dotted_color = self._tb_dotted_color_btn.property('selected_color')
            if dotted_color:
                general_settings['termbase_dotted_color'] = dotted_color
                self.termbase_dotted_color = dotted_color
        
        self.save_general_settings(general_settings)
        
        # Apply termview font settings immediately to BOTH termview widgets
        if hasattr(self, 'termview_widget') and self.termview_widget is not None:
            termview_family = general_settings.get('termview_font_family', 'Segoe UI')
            termview_size = general_settings.get('termview_font_size', 10)
            termview_bold = general_settings.get('termview_font_bold', False)
            self.termview_widget.set_font_settings(termview_family, termview_size, termview_bold)
        
        # Also apply to the Match Panel's Termview widget
        if hasattr(self, 'termview_widget_match') and self.termview_widget_match is not None:
            termview_family = general_settings.get('termview_font_family', 'Segoe UI')
            termview_size = general_settings.get('termview_font_size', 10)
            termview_bold = general_settings.get('termview_font_bold', False)
            self.termview_widget_match.set_font_settings(termview_family, termview_size, termview_bold)
        
        # Apply font family and size immediately
        font_changed = False
        if grid_font_family_combo is not None and self.default_font_family != grid_font_family_combo.currentText():
            self.default_font_family = grid_font_family_combo.currentText()
            font_changed = True
        if self.default_font_size != grid_spin.value():
            self.default_font_size = grid_spin.value()
            font_changed = True
        if font_changed and hasattr(self, 'table') and self.table is not None:
            self.apply_font_to_grid()
            self.auto_resize_rows()
        
        # Apply results pane font sizes to all panels
        if hasattr(self, 'results_panels'):
            from modules.translation_results_panel import CompactMatchItem
            if CompactMatchItem.font_size_pt != match_spin.value():
                CompactMatchItem.set_font_size(match_spin.value())
                for panel in self.results_panels:
                    if hasattr(panel, 'set_font_size'):
                        panel.set_font_size(match_spin.value())
        
            from modules.translation_results_panel import TranslationResultsPanel
            if TranslationResultsPanel.compare_box_font_size != compare_spin.value():
                TranslationResultsPanel.compare_box_font_size = compare_spin.value()
                for panel in self.results_panels:
                    if hasattr(panel, 'set_compare_box_font_size'):
                        panel.set_compare_box_font_size(compare_spin.value())
            
            # Apply show_tags setting
            if show_tags_check:
                show_tags = show_tags_check.isChecked()
                CompactMatchItem.show_tags = show_tags
                for panel in self.results_panels:
                    if hasattr(panel, 'set_show_tags'):
                        panel.set_show_tags(show_tags)
            
            # Apply tag color setting
            if tag_color_btn:
                tag_color = tag_color_btn.property('selected_color')
                if tag_color:
                    for panel in self.results_panels:
                        if hasattr(panel, 'set_tag_color'):
                            panel.set_tag_color(tag_color)

        # Apply badge text color to all results panels
        if badge_text_color_btn and hasattr(self, 'results_panels'):
            badge_text_color = badge_text_color_btn.property('selected_color')
            if badge_text_color:
                from modules.translation_results_panel import CompactMatchItem
                CompactMatchItem.badge_text_color = badge_text_color

        # Apply invisible char color to grid cells
        if invisible_char_color_btn and hasattr(self, 'table') and self.table is not None:
            invisible_char_color = invisible_char_color_btn.property('selected_color')
            if invisible_char_color:
                # Update all cell highlighters
                for row in range(self.table.rowCount()):
                    for col in [2, 3]:  # Source and target columns
                        widget = self.table.cellWidget(row, col)
                        if widget and hasattr(widget, 'highlighter'):
                            widget.highlighter.set_invisible_char_color(invisible_char_color)

        # Apply focus border settings to all grid cells
        if (border_color_btn is not None or border_thickness_spin is not None) and hasattr(self, 'table') and self.table is not None:
            # Refresh all EditableGridTextEditor widgets with new border settings
            border_color = EditableGridTextEditor.focus_border_color
            border_thickness = EditableGridTextEditor.focus_border_thickness
            self.log(f"Applying focus border: color={border_color}, thickness={border_thickness}px")
            
            for row in range(self.table.rowCount()):
                widget = self.table.cellWidget(row, 3)  # Target column
                if widget and isinstance(widget, EditableGridTextEditor):
                    # Update the stylesheet with new border settings
                    widget.setStyleSheet(f"""
                        QTextEdit {{
                            border: none;
                            padding: 0px 4px 0px 0px;
                        }}
                        QTextEdit:focus {{
                            border: {border_thickness}px solid {border_color};
                        }}
                        QTextEdit::selection {{
                            background-color: #D0E7FF;
                            color: black;
                        }}
                    """)

        # Refresh grid to apply tag colors
        if hasattr(self, 'table') and self.table is not None:
            self.refresh_grid_tag_colors()
            # Also refresh row colors
            self.apply_alternating_row_colors()
        
        self.log("‚úì View settings saved and applied")
        # Use explicit QMessageBox instance to ensure proper dialog closing
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Icon.Information)
        msg.setWindowTitle("Settings Saved")
        msg.setText("View settings have been saved and applied successfully.")
        msg.setStandardButtons(QMessageBox.StandardButton.Ok)
        msg.exec()
    
    def _apply_global_ui_font_scale(self, scale_percent: int):
        """Apply font scale to the entire application UI"""
        general_settings = self.load_general_settings()
        general_settings['global_ui_font_scale'] = scale_percent
        # Remove old key if present (migration)
        if 'settings_ui_font_scale' in general_settings:
            del general_settings['settings_ui_font_scale']
        self.save_general_settings(general_settings)

        # Update ThemeManager and reapply theme
        if hasattr(self, 'theme_manager') and self.theme_manager is not None:
            self.theme_manager.font_scale = scale_percent
            self.theme_manager.apply_theme(QApplication.instance())

        # Update status bar and main tabs fonts
        self._update_status_bar_fonts(scale_percent)
        self._update_main_tabs_fonts(scale_percent)
        self.log(f"‚úì Global UI font scale set to {scale_percent}%")

    def _update_status_bar_fonts(self, scale_percent: int):
        """Update status bar label fonts based on scale percentage"""
        base_size = int(9 * scale_percent / 100)
        small_size = max(7, base_size)
        style = f"font-size: {small_size}pt;"

        # Update all status bar labels if they exist
        for attr_name in ['segment_count_label', 'file_label', 'tm_status_label',
                          'termbase_status_label', 'source_lang_label', 'target_lang_label']:
            if hasattr(self, attr_name):
                label = getattr(self, attr_name)
                if label is not None:
                    label.setStyleSheet(style)

    def _update_main_tabs_fonts(self, scale_percent: int):
        """Update main tab bar fonts based on scale percentage"""
        base_size = int(10 * scale_percent / 100)
        if hasattr(self, 'main_tabs') and self.main_tabs is not None:
            self.main_tabs.tabBar().setStyleSheet(f"font-size: {base_size}pt;")

    def _get_global_ui_font_scale(self) -> int:
        """Get the current global UI font scale percentage"""
        general_settings = self.load_general_settings()
        # Check new key first, fall back to old key for migration
        return general_settings.get('global_ui_font_scale',
                                    general_settings.get('settings_ui_font_scale', 100))
    
    def create_grid_view_widget(self):
        """Create the Grid View widget (existing grid functionality)"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Splitter for grid and assistance panel
        self.editor_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left side: Grid container with filter boxes
        grid_container = QWidget()
        grid_layout = QVBoxLayout(grid_container)
        grid_layout.setContentsMargins(0, 0, 0, 0)
        grid_layout.setSpacing(5)
        
        # Warning banner for replace in source (hidden by default)
        editor_warning = self._get_warning_banner('editor_grid')
        grid_layout.addWidget(editor_warning)
        editor_warning.hide()  # Hidden by default
        
        # Filter panel (like memoQ)
        filter_panel = QWidget()
        filter_layout = QHBoxLayout(filter_panel)
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(10)
        
        # Source filter
        source_filter_label = QLabel("Filter Source:")
        self.source_filter = self._ensure_shared_filter(
            'source_filter',
            "Type to filter source segments...",
            on_change=self.apply_filters,
            on_return=self.apply_filters,
        )
        
        # Target filter
        target_filter_label = QLabel("Filter Target:")
        self.target_filter = self._ensure_shared_filter(
            'target_filter',
            "Type to filter target segments...",
            on_change=self.apply_filters,
            on_return=self.apply_filters,
        )
        
        # Clear filters button
        clear_filters_btn = QPushButton("Clear Filters")
        clear_filters_btn.clicked.connect(self.clear_filters)
        clear_filters_btn.setMaximumWidth(100)

        # Show Invisibles button with dropdown menu
        show_invisibles_btn = QPushButton("¬∂ Show Invisibles")
        show_invisibles_btn.setMaximumWidth(140)
        show_invisibles_btn.setStyleSheet("background-color: #607D8B; color: white; font-weight: bold;")
        show_invisibles_menu = QMenu(show_invisibles_btn)

        # Create checkable actions for each invisible character type
        self.show_spaces_action = show_invisibles_menu.addAction("Spaces (¬∑)")
        self.show_spaces_action.setCheckable(True)
        self.show_spaces_action.setChecked(False)
        self.show_spaces_action.triggered.connect(lambda: self.toggle_invisible_display('spaces'))

        self.show_tabs_action = show_invisibles_menu.addAction("Tabs (‚Üí)")
        self.show_tabs_action.setCheckable(True)
        self.show_tabs_action.setChecked(False)
        self.show_tabs_action.triggered.connect(lambda: self.toggle_invisible_display('tabs'))

        self.show_nbsp_action = show_invisibles_menu.addAction("Non-breaking Spaces (¬∞)")
        self.show_nbsp_action.setCheckable(True)
        self.show_nbsp_action.setChecked(False)
        self.show_nbsp_action.triggered.connect(lambda: self.toggle_invisible_display('nbsp'))

        self.show_linebreaks_action = show_invisibles_menu.addAction("Line Breaks (¬∂)")
        self.show_linebreaks_action.setCheckable(True)
        self.show_linebreaks_action.setChecked(False)
        self.show_linebreaks_action.triggered.connect(lambda: self.toggle_invisible_display('linebreaks'))

        show_invisibles_menu.addSeparator()

        # Toggle All option
        toggle_all_action = show_invisibles_menu.addAction("Toggle All")
        toggle_all_action.triggered.connect(self.toggle_all_invisibles)

        show_invisibles_btn.setMenu(show_invisibles_menu)

        # Spellcheck toggle button with dropdown menu
        # Load saved spellcheck state from preferences
        saved_enabled = self._load_spellcheck_settings()
        self.spellcheck_enabled = saved_enabled
        TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
        
        self.spellcheck_btn = QPushButton("üìù Spellcheck")
        self.spellcheck_btn.setMaximumWidth(120)
        self.spellcheck_btn.setCheckable(True)
        self.spellcheck_btn.setChecked(self.spellcheck_enabled)
        self._update_spellcheck_button_style()
        
        # Create dropdown menu for spellcheck options
        spellcheck_menu = QMenu(self.spellcheck_btn)
        
        # Toggle spellcheck action
        self.spellcheck_toggle_action = spellcheck_menu.addAction("Enable Spellcheck")
        self.spellcheck_toggle_action.setCheckable(True)
        self.spellcheck_toggle_action.setChecked(self.spellcheck_enabled)
        self.spellcheck_toggle_action.triggered.connect(self._toggle_spellcheck)
        
        spellcheck_menu.addSeparator()
        
        # Open custom dictionary action
        open_dict_action = spellcheck_menu.addAction("üìñ Manage Custom Dictionary...")
        open_dict_action.triggered.connect(self._open_custom_dictionary_dialog)
        
        # Show spellcheck info
        info_action = spellcheck_menu.addAction("‚ÑπÔ∏è Spellcheck Info")
        info_action.triggered.connect(self._show_spellcheck_info)
        
        self.spellcheck_btn.setMenu(spellcheck_menu)
        # Also allow clicking the button itself to toggle
        self.spellcheck_btn.clicked.connect(self._toggle_spellcheck_from_button)

        filter_layout.addWidget(source_filter_label)
        filter_layout.addWidget(self.source_filter, stretch=1)
        filter_layout.addWidget(target_filter_label)
        filter_layout.addWidget(self.target_filter, stretch=1)
        filter_layout.addWidget(clear_filters_btn)
        filter_layout.addWidget(show_invisibles_btn)
        filter_layout.addWidget(self.spellcheck_btn)
        
        grid_layout.addWidget(filter_panel)
        
        # Translation Grid (create it if it doesn't exist or has been deleted)
        if not hasattr(self, 'table') or not self._widget_is_alive(self.table):
            self.create_translation_grid()
        grid_layout.addWidget(self.table)
        
        # Add grid container to splitter
        self.editor_splitter.addWidget(grid_container)
        
        # Set splitter proportions - Qt displays RIGHT to LEFT
        # Position 0 (grid/RIGHT) gets 1000, Position 1 (assistance/LEFT) gets 400
        self.editor_splitter.setSizes([1000, 400])
        
        layout.addWidget(self.editor_splitter)
        
        self.update_warning_banner()

        return widget
    
    def create_grid_view_widget_for_home(self):
        """Create Grid View widget with translation results panel on the right (memoQ style)"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Main horizontal splitter: Grid+Segment Editor (left) and Translation Results (right)
        main_horizontal_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Left side: Vertical splitter with Grid (top) and Segment Editor/Comments (bottom)
        left_vertical_splitter = QSplitter(Qt.Orientation.Vertical)
        
        # Top of left side: Grid container with filter boxes
        grid_container = QWidget()
        grid_layout = QVBoxLayout(grid_container)
        grid_layout.setContentsMargins(0, 0, 0, 0)
        grid_layout.setSpacing(5)
        
        # Warning banner for replace in source (hidden by default)
        home_warning = self._get_warning_banner('home_grid')
        grid_layout.addWidget(home_warning)
        home_warning.hide()  # Hidden by default
        
        # Filter panel (like memoQ)
        filter_panel = QWidget()
        filter_layout = QHBoxLayout(filter_panel)
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(10)
        
        # Source filter
        source_filter_label = QLabel("Filter Source:")
        self.source_filter = self._ensure_shared_filter(
            'source_filter',
            "Type to filter source segments... (Press Enter or click Filter)",
            on_return=self.apply_filters,
        )
        
        # Target filter
        target_filter_label = QLabel("Filter Target:")
        self.target_filter = self._ensure_shared_filter(
            'target_filter',
            "Type to filter target segments... (Press Enter or click Filter)",
            on_return=self.apply_filters,
        )
        
        # Filter button (activates the filter)
        apply_filter_btn = QPushButton("Filter")
        apply_filter_btn.clicked.connect(self.apply_filters)
        apply_filter_btn.setMaximumWidth(80)
        apply_filter_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        
        # Clear filters button
        clear_filters_btn = QPushButton("Clear Filters")
        clear_filters_btn.clicked.connect(self.clear_filters)
        clear_filters_btn.setMaximumWidth(100)
        
        # Quick Filters dropdown menu
        quick_filter_btn = QPushButton("‚ö° Quick Filters")
        quick_filter_btn.setMaximumWidth(130)
        quick_filter_btn.setStyleSheet("background-color: #D84315; color: white; font-weight: bold;")
        quick_filter_menu = QMenu(self)
        quick_filter_menu.addAction("üîç Empty segments", lambda: self.apply_quick_filter("empty"))
        quick_filter_menu.addAction("‚ùå Not translated", lambda: self.apply_quick_filter("not_translated"))
        quick_filter_menu.addAction("‚úì Confirmed", lambda: self.apply_quick_filter("confirmed"))
        quick_filter_menu.addAction("üîí Locked", lambda: self.apply_quick_filter("locked"))
        quick_filter_menu.addAction("üîì Not locked", lambda: self.apply_quick_filter("not_locked"))
        quick_filter_menu.addAction("üí¨ Commented", lambda: self.apply_quick_filter("commented"))
        quick_filter_btn.setMenu(quick_filter_menu)
        
        # Advanced Filters dialog button
        advanced_filter_btn = QPushButton("‚öôÔ∏è Advanced Filters")
        advanced_filter_btn.clicked.connect(self.show_advanced_filters_dialog)
        advanced_filter_btn.setMaximumWidth(160)
        advanced_filter_btn.setStyleSheet("background-color: #2196F3; color: white; font-weight: bold;")

        # Sort dropdown button (similar to memoQ)
        sort_btn = QPushButton("‚áÖ Sort")
        sort_btn.setMaximumWidth(100)
        sort_btn.setStyleSheet("background-color: #FF9800; color: white; font-weight: bold;")
        sort_menu = QMenu(sort_btn)

        # Initialize sort state if not exists
        if not hasattr(self, 'current_sort'):
            self.current_sort = None  # None = document order

        # Sort by source text
        sort_menu.addAction("üìù Source A ‚Üí Z", lambda: self.apply_sort('source_asc'))
        sort_menu.addAction("üìù Source Z ‚Üí A", lambda: self.apply_sort('source_desc'))

        sort_menu.addSeparator()

        # Sort by target text
        sort_menu.addAction("üìÑ Target A ‚Üí Z", lambda: self.apply_sort('target_asc'))
        sort_menu.addAction("üìÑ Target Z ‚Üí A", lambda: self.apply_sort('target_desc'))

        sort_menu.addSeparator()

        # Sort by text length
        sort_menu.addAction("üìè Source (longer first)", lambda: self.apply_sort('source_length_desc'))
        sort_menu.addAction("üìè Source (shorter first)", lambda: self.apply_sort('source_length_asc'))
        sort_menu.addAction("üìè Target (longer first)", lambda: self.apply_sort('target_length_desc'))
        sort_menu.addAction("üìè Target (shorter first)", lambda: self.apply_sort('target_length_asc'))

        sort_menu.addSeparator()

        # Sort by match rate
        sort_menu.addAction("üéØ Match Rate (higher first)", lambda: self.apply_sort('match_desc'))
        sort_menu.addAction("üéØ Match Rate (lower first)", lambda: self.apply_sort('match_asc'))

        sort_menu.addSeparator()

        # Sort by frequency
        sort_menu.addAction("üìä Source Frequency (higher first)", lambda: self.apply_sort('source_freq_desc'))
        sort_menu.addAction("üìä Source Frequency (lower first)", lambda: self.apply_sort('source_freq_asc'))
        sort_menu.addAction("üìä Target Frequency (higher first)", lambda: self.apply_sort('target_freq_desc'))
        sort_menu.addAction("üìä Target Frequency (lower first)", lambda: self.apply_sort('target_freq_asc'))

        sort_menu.addSeparator()

        # Sort by last changed
        sort_menu.addAction("üïí Last Changed (newest first)", lambda: self.apply_sort('modified_desc'))
        sort_menu.addAction("üïí Last Changed (oldest first)", lambda: self.apply_sort('modified_asc'))

        sort_menu.addSeparator()

        # Sort by row status
        sort_menu.addAction("üö¶ Row Status", lambda: self.apply_sort('status'))

        sort_menu.addSeparator()

        # Reset to document order
        sort_menu.addAction("‚Ü©Ô∏è Document Order (default)", lambda: self.apply_sort(None))

        sort_btn.setMenu(sort_menu)
        sort_btn.setToolTip("Sort segments by various criteria")

        # File filter dropdown (for multi-file projects)
        self.file_filter_combo = QComboBox()
        self.file_filter_combo.setMinimumWidth(150)
        self.file_filter_combo.setMaximumWidth(250)
        self.file_filter_combo.addItem("üìÅ All Files", None)
        self.file_filter_combo.currentIndexChanged.connect(self._on_file_filter_changed)
        self.file_filter_combo.setToolTip("Filter segments by file (multi-file projects only)")
        self.file_filter_combo.hide()  # Hidden by default, shown for multi-file projects

        # Show Invisibles button with dropdown menu
        show_invisibles_btn_home = QPushButton("¬∂ Show Invisibles")
        show_invisibles_btn_home.setMaximumWidth(140)
        show_invisibles_btn_home.setStyleSheet("background-color: #607D8B; color: white; font-weight: bold;")
        show_invisibles_menu_home = QMenu(show_invisibles_btn_home)

        # Use the same actions (they're stored as instance variables)
        if not hasattr(self, 'show_spaces_action'):
            # Create actions if they don't exist yet (first time)
            self.show_spaces_action = show_invisibles_menu_home.addAction("Spaces (¬∑)")
            self.show_spaces_action.setCheckable(True)
            self.show_spaces_action.setChecked(False)
            self.show_spaces_action.triggered.connect(lambda: self.toggle_invisible_display('spaces'))

            self.show_tabs_action = show_invisibles_menu_home.addAction("Tabs (‚Üí)")
            self.show_tabs_action.setCheckable(True)
            self.show_tabs_action.setChecked(False)
            self.show_tabs_action.triggered.connect(lambda: self.toggle_invisible_display('tabs'))

            self.show_nbsp_action = show_invisibles_menu_home.addAction("Non-breaking Spaces (¬∞)")
            self.show_nbsp_action.setCheckable(True)
            self.show_nbsp_action.setChecked(False)
            self.show_nbsp_action.triggered.connect(lambda: self.toggle_invisible_display('nbsp'))

            self.show_linebreaks_action = show_invisibles_menu_home.addAction("Line Breaks (¬∂)")
            self.show_linebreaks_action.setCheckable(True)
            self.show_linebreaks_action.setChecked(False)
            self.show_linebreaks_action.triggered.connect(lambda: self.toggle_invisible_display('linebreaks'))

            show_invisibles_menu_home.addSeparator()

            toggle_all_action = show_invisibles_menu_home.addAction("Toggle All")
            toggle_all_action.triggered.connect(self.toggle_all_invisibles)
        else:
            # Reuse existing actions
            show_invisibles_menu_home.addAction(self.show_spaces_action)
            show_invisibles_menu_home.addAction(self.show_tabs_action)
            show_invisibles_menu_home.addAction(self.show_nbsp_action)
            show_invisibles_menu_home.addAction(self.show_linebreaks_action)
            show_invisibles_menu_home.addSeparator()
            toggle_all_action = show_invisibles_menu_home.addAction("Toggle All")
            toggle_all_action.triggered.connect(self.toggle_all_invisibles)

        show_invisibles_btn_home.setMenu(show_invisibles_menu_home)

        # Spellcheck toggle button (reuse the same instance variable from Editor tab)
        if not hasattr(self, 'spellcheck_btn') or self.spellcheck_btn is None:
            # Create spellcheck button if it doesn't exist yet
            self.spellcheck_btn = QPushButton("üìù Spellcheck")
            self.spellcheck_btn.setMaximumWidth(120)
            self.spellcheck_btn.setCheckable(True)
            self.spellcheck_btn.setChecked(self.spellcheck_enabled)
            self._update_spellcheck_button_style()
            
            # Create dropdown menu for spellcheck options
            spellcheck_menu = QMenu(self.spellcheck_btn)
            
            # Toggle spellcheck action
            self.spellcheck_toggle_action = spellcheck_menu.addAction("Enable Spellcheck")
            self.spellcheck_toggle_action.setCheckable(True)
            self.spellcheck_toggle_action.setChecked(self.spellcheck_enabled)
            self.spellcheck_toggle_action.triggered.connect(self._toggle_spellcheck)
            
            spellcheck_menu.addSeparator()
            
            # Open custom dictionary action
            open_dict_action = spellcheck_menu.addAction("üìñ Manage Custom Dictionary...")
            open_dict_action.triggered.connect(self._open_custom_dictionary_dialog)
            
            # Show spellcheck info
            info_action = spellcheck_menu.addAction("‚ÑπÔ∏è Spellcheck Info")
            info_action.triggered.connect(self._show_spellcheck_info)
            
            self.spellcheck_btn.setMenu(spellcheck_menu)
            self.spellcheck_btn.clicked.connect(self._toggle_spellcheck_from_button)

        filter_layout.addWidget(source_filter_label)
        filter_layout.addWidget(self.source_filter, stretch=1)
        filter_layout.addWidget(target_filter_label)
        filter_layout.addWidget(self.target_filter, stretch=1)
        filter_layout.addWidget(apply_filter_btn)
        filter_layout.addWidget(clear_filters_btn)
        filter_layout.addWidget(quick_filter_btn)
        filter_layout.addWidget(advanced_filter_btn)
        filter_layout.addWidget(sort_btn)  # Sort dropdown
        filter_layout.addWidget(self.file_filter_combo)  # File filter for multi-file projects
        filter_layout.addWidget(show_invisibles_btn_home)
        filter_layout.addWidget(self.spellcheck_btn)
        
        # Don't add filter_panel to grid_layout yet - will be positioned based on tabs_above_grid setting
        
        # Pagination controls (like Tkinter version)
        pagination_panel = QWidget()
        pagination_panel.setStyleSheet("padding: 5px;")
        pagination_layout = QHBoxLayout(pagination_panel)
        pagination_layout.setContentsMargins(10, 5, 10, 5)
        pagination_layout.setSpacing(10)
        
        # Pagination label (left side)
        if not hasattr(self, 'pagination_label') or not self._widget_is_alive(self.pagination_label):
            self.pagination_label = QLabel("Segments 1-50 of 0")
        self.pagination_label.setStyleSheet("color: #555;")
        pagination_layout.addWidget(self.pagination_label)

        # Tip label for Ctrl+, shortcut (subtle, helpful for new users)
        tip_label = QLabel("üí° Tip: Ctrl+, inserts the next tag from source")
        tip_label.setStyleSheet("color: #888; font-size: 9pt; margin-left: 20px;")
        tip_label.setToolTip("Select text first to wrap it with a tag pair (e.g., <b>selection</b>)")
        pagination_layout.addWidget(tip_label)

        pagination_layout.addStretch()
        
        # Pagination controls (right side)
        # First page button
        if not hasattr(self, 'first_page_btn') or not self._widget_is_alive(self.first_page_btn):
            self.first_page_btn = QPushButton("‚èÆ First")
            self.first_page_btn.setMaximumWidth(70)
            if hasattr(self, 'go_to_first_page'):
                self.first_page_btn.clicked.connect(self.go_to_first_page)
        pagination_layout.addWidget(self.first_page_btn)
        
        # Previous page button
        if not hasattr(self, 'prev_page_btn') or not self._widget_is_alive(self.prev_page_btn):
            self.prev_page_btn = QPushButton("‚óÄ Prev")
            self.prev_page_btn.setMaximumWidth(70)
            if hasattr(self, 'go_to_prev_page'):
                self.prev_page_btn.clicked.connect(self.go_to_prev_page)
        pagination_layout.addWidget(self.prev_page_btn)
        
        # Page number input
        page_label = QLabel("Page:")
        pagination_layout.addWidget(page_label)
        
        if not hasattr(self, 'page_number_input') or not self._widget_is_alive(self.page_number_input):
            self.page_number_input = QLineEdit()
            self.page_number_input.setMaximumWidth(50)
            self.page_number_input.setText("1")
            if hasattr(self, 'go_to_page'):
                self.page_number_input.returnPressed.connect(self.go_to_page)
        pagination_layout.addWidget(self.page_number_input)
        
        if not hasattr(self, 'total_pages_label') or not self._widget_is_alive(self.total_pages_label):
            self.total_pages_label = QLabel("of 1")
        pagination_layout.addWidget(self.total_pages_label)
        
        # Next page button
        if not hasattr(self, 'next_page_btn') or not self._widget_is_alive(self.next_page_btn):
            self.next_page_btn = QPushButton("Next ‚ñ∂")
            self.next_page_btn.setMaximumWidth(70)
            if hasattr(self, 'go_to_next_page'):
                self.next_page_btn.clicked.connect(self.go_to_next_page)
        pagination_layout.addWidget(self.next_page_btn)
        
        # Last page button
        if not hasattr(self, 'last_page_btn') or not self._widget_is_alive(self.last_page_btn):
            self.last_page_btn = QPushButton("Last ‚è≠")
            self.last_page_btn.setMaximumWidth(70)
            if hasattr(self, 'go_to_last_page'):
                self.last_page_btn.clicked.connect(self.go_to_last_page)
        pagination_layout.addWidget(self.last_page_btn)
        
        # Page size selector
        page_size_label = QLabel("Per page:")
        pagination_layout.addWidget(page_size_label)
        
        if not hasattr(self, 'page_size_combo') or not self._widget_is_alive(self.page_size_combo):
            self.page_size_combo = QComboBox()
            self.page_size_combo.addItems(["5", "10", "25", "50", "100", "200", "All"])
            if not hasattr(self, 'grid_page_size'):
                self.grid_page_size = 50
            self.page_size_combo.setCurrentText(str(self.grid_page_size) if self.grid_page_size != 999999 else "All")
            if hasattr(self, 'on_page_size_changed'):
                self.page_size_combo.currentTextChanged.connect(self.on_page_size_changed)
        self.page_size_combo.setMaximumWidth(80)
        pagination_layout.addWidget(self.page_size_combo)
        
        # Create a combined filter + pagination container for flexible positioning
        filter_pagination_container = QWidget()
        filter_pagination_layout = QVBoxLayout(filter_pagination_container)
        filter_pagination_layout.setContentsMargins(0, 0, 0, 0)
        filter_pagination_layout.setSpacing(2)
        filter_pagination_layout.addWidget(filter_panel)
        filter_pagination_layout.addWidget(pagination_panel)
        
        # Store reference for later positioning
        self.filter_pagination_container = filter_pagination_container
        
        # Note: filter_pagination_container will be added to layout based on tabs_above_grid setting
        
        # Note: Pagination methods (go_to_first_page, go_to_prev_page, etc.) will be implemented
        # when pagination functionality is fully added. For now, buttons are created but won't work.
        
        # Translation Grid (create it if it doesn't exist or has been deleted)
        if not hasattr(self, 'table') or not self._widget_is_alive(self.table):
            self.create_translation_grid()
        grid_layout.addWidget(self.table)
        
        # Compact toolbar below grid with action buttons
        toolbar = QWidget()
        toolbar_layout = QHBoxLayout(toolbar)
        toolbar_layout.setContentsMargins(5, 5, 5, 5)
        toolbar_layout.setSpacing(8)
        
        # Segment info label
        tab_seg_info = QLabel("Segment: -")
        tab_seg_info.setStyleSheet("font-weight: bold;")
        toolbar_layout.addWidget(tab_seg_info)
        
        # View mode segmented control (WYSIWYG / Tags)
        from PyQt6.QtWidgets import QButtonGroup

        view_mode_container = QWidget()
        view_mode_layout = QHBoxLayout(view_mode_container)
        view_mode_layout.setContentsMargins(0, 0, 0, 0)
        view_mode_layout.setSpacing(0)

        # Create button group to ensure only one is checked
        view_mode_group = QButtonGroup(self)
        view_mode_group.setExclusive(True)

        # WYSIWYG button (left)
        wysiwyg_btn = QPushButton("WYSIWYG")
        wysiwyg_btn.setCheckable(True)
        wysiwyg_btn.setChecked(False)
        wysiwyg_btn.setToolTip("WYSIWYG View (Ctrl+Alt+T)\nShows formatted text without raw tags")
        wysiwyg_btn.setStyleSheet("""
            QPushButton {
                background-color: #757575;
                color: white;
                font-weight: bold;
                padding: 4px 12px;
                border: none;
                border-top-left-radius: 3px;
                border-bottom-left-radius: 3px;
            }
            QPushButton:checked {
                background-color: #9C27B0;
            }
            QPushButton:hover:!checked {
                background-color: #858585;
            }
        """)
        wysiwyg_btn.clicked.connect(lambda: self.toggle_tag_view(False, None))
        view_mode_group.addButton(wysiwyg_btn, 0)
        view_mode_layout.addWidget(wysiwyg_btn)

        # Tags button (right)
        tags_btn = QPushButton("Tags")
        tags_btn.setCheckable(True)
        tags_btn.setChecked(True)  # Default: Tags mode
        tags_btn.setToolTip("Tag View (Ctrl+Alt+T)\nShows raw tags like <b>bold</b>")
        tags_btn.setStyleSheet("""
            QPushButton {
                background-color: #757575;
                color: white;
                font-weight: bold;
                padding: 4px 12px;
                border: none;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
            }
            QPushButton:checked {
                background-color: #9C27B0;
            }
            QPushButton:hover:!checked {
                background-color: #858585;
            }
        """)
        tags_btn.clicked.connect(lambda: self.toggle_tag_view(True, None))
        view_mode_group.addButton(tags_btn, 1)
        view_mode_layout.addWidget(tags_btn)

        toolbar_layout.addWidget(view_mode_container)

        # Store references for keyboard shortcut and programmatic access
        self.wysiwyg_btn = wysiwyg_btn
        self.tags_btn = tags_btn
        self.view_mode_group = view_mode_group
        
        # Initialize tag view state
        if not hasattr(self, 'show_tags'):
            self.show_tags = True  # Default: show tags
        
        # Status selector
        from modules.statuses import get_status, STATUSES
        status_label = QLabel("Status:")
        tab_status_combo = QComboBox()
        tab_status_combo.setMinimumWidth(130)  # Ensure full status text is visible
        for status_key in STATUSES.keys():
            definition = get_status(status_key)
            tab_status_combo.addItem(definition.label, status_key)
        tab_status_combo.currentIndexChanged.connect(self.on_tab_status_combo_changed)
        toolbar_layout.addWidget(status_label)
        toolbar_layout.addWidget(tab_status_combo)
        
        toolbar_layout.addWidget(QLabel("|"))  # Separator
        
        preview_prompt_btn = QPushButton("üß™ Preview Prompts")
        preview_prompt_btn.setToolTip("Preview the complete assembled prompt\n(System Prompt + Custom Prompts + current segment)")
        preview_prompt_btn.setStyleSheet("background-color: #9C27B0; color: white; font-weight: bold; padding: 4px 8px; border: none; outline: none;")
        preview_prompt_btn.clicked.connect(self._preview_combined_prompt_from_grid)
        toolbar_layout.addWidget(preview_prompt_btn)
        
        dictate_btn = QPushButton("üé§ Dictation")
        dictate_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 4px 8px; border: none; outline: none;")
        dictate_btn.clicked.connect(self.start_voice_dictation)
        dictate_btn.setToolTip("Start/stop voice dictation (F9)")
        toolbar_layout.addWidget(dictate_btn)
        
        # Always-On Voice toggle button
        alwayson_btn = QPushButton("üéß Voice Commands OFF")
        alwayson_btn.setCheckable(True)
        alwayson_btn.setChecked(False)
        alwayson_btn.setStyleSheet("""
            QPushButton {
                background-color: #757575;
                color: white;
                font-weight: bold;
                padding: 4px 8px;
                border-radius: 3px;
            }
            QPushButton:checked {
                background-color: #2E7D32;
            }
        """)
        alwayson_btn.setToolTip("Toggle always-on voice listening\n\nWhen ON: Listens continuously for voice commands\nNo need to press F9")
        alwayson_btn.clicked.connect(lambda checked: self._toggle_alwayson_from_grid_btn(checked, alwayson_btn))
        toolbar_layout.addWidget(alwayson_btn)
        self.grid_alwayson_btn = alwayson_btn  # Store reference
        
        toolbar_layout.addStretch()
        
        save_next_btn = QPushButton("‚úì Confirm && Next")
        save_next_btn.setStyleSheet("background-color: #2196F3; color: white; font-weight: bold; padding: 4px 8px; border: none; outline: none;")
        save_next_btn.clicked.connect(self.confirm_selected_or_next)
        save_next_btn.setToolTip("Confirm current segment and go to next unconfirmed (Ctrl+Enter)")
        toolbar_layout.addWidget(save_next_btn)
        
        grid_layout.addWidget(toolbar)
        
        # Store references
        self.tab_seg_info = tab_seg_info
        self.tab_status_combo = tab_status_combo
        self.tab_dictate_btn = dictate_btn
        
        # Create Termview and Session Log tabs widget
        from PyQt6.QtWidgets import QTabWidget
        from modules.termview_widget import TermviewWidget
        
        bottom_tabs = QTabWidget()
        bottom_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        
        # Termview tab
        self.termview_widget = TermviewWidget(self, db_manager=self.db_manager, log_callback=self.log, theme_manager=self.theme_manager)
        self.termview_widget.term_insert_requested.connect(self.insert_termview_text)
        self.termview_widget.edit_entry_requested.connect(self._on_termview_edit_entry)
        self.termview_widget.delete_entry_requested.connect(self._on_termview_delete_entry)
        
        # Apply saved termview font settings
        font_settings = self.load_general_settings()
        termview_family = font_settings.get('termview_font_family', 'Segoe UI')
        termview_size = font_settings.get('termview_font_size', 10)
        termview_bold = font_settings.get('termview_font_bold', False)
        self.termview_widget.set_font_settings(termview_family, termview_size, termview_bold)
        
        # Session Log tab
        session_log_widget = QWidget()
        session_log_layout = QVBoxLayout(session_log_widget)
        session_log_layout.setContentsMargins(5, 5, 5, 5)
        
        self.session_log_text = QPlainTextEdit()
        self.session_log_text.setReadOnly(True)
        self.session_log_text.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)
        self.session_log_text.setStyleSheet("font-family: 'Consolas', 'Courier New', monospace; font-size: 9pt;")
        session_log_layout.addWidget(self.session_log_text)
        
        # Notes tab (for segment notes - copy from Translation Results panel)
        notes_widget = QWidget()
        notes_layout = QVBoxLayout(notes_widget)
        notes_layout.setContentsMargins(5, 5, 5, 5)
        
        self.bottom_notes_edit = QPlainTextEdit()
        self.bottom_notes_edit.setPlaceholderText("Add notes about this segment, context, or translation concerns...")
        self.bottom_notes_edit.setStyleSheet("font-size: 10pt;")
        self.bottom_notes_edit.textChanged.connect(self._on_bottom_notes_changed)
        notes_layout.addWidget(self.bottom_notes_edit)
        
        # Add only Termview tab to bottom_tabs (Segment Note and Session Log will be in right panel)
        bottom_tabs.addTab(self.termview_widget, "üîç Termview")
        
        # Default to Termview tab (index 0)
        bottom_tabs.setCurrentIndex(0)
        
        # Store reference to bottom_tabs for later access
        self.bottom_tabs = bottom_tabs
        
        # Store notes_widget and session_log_widget for adding to right panel later
        self._notes_widget_for_right_panel = notes_widget
        self._session_log_widget_for_right_panel = session_log_widget
        
        # Scratchpad widget (for private translator notes - project-level, not segment-level)
        scratchpad_widget = QWidget()
        scratchpad_layout = QVBoxLayout(scratchpad_widget)
        scratchpad_layout.setContentsMargins(5, 5, 5, 5)
        
        # Info label at top
        scratchpad_info = QLabel(
            "üìù <b>Private notes for this project</b><br>"
            "<small>Stored in .svproj file only ‚Äî never exported to CAT tools</small>"
        )
        scratchpad_info.setWordWrap(True)
        scratchpad_info.setStyleSheet("color: #666; font-size: 9pt; padding: 3px; background: #f9f9f9; border-radius: 3px; margin-bottom: 5px;")
        scratchpad_layout.addWidget(scratchpad_info)
        
        self.scratchpad_edit = QPlainTextEdit()
        self.scratchpad_edit.setPlaceholderText(
            "Use this scratchpad for your private notes:\n\n"
            "‚Ä¢ Terminology decisions\n"
            "‚Ä¢ Client preferences\n"
            "‚Ä¢ Research findings\n"
            "‚Ä¢ Questions to ask\n"
            "‚Ä¢ Reminders"
        )
        self.scratchpad_edit.setStyleSheet("font-family: 'Consolas', 'Courier New', monospace; font-size: 10pt;")
        self.scratchpad_edit.textChanged.connect(self._on_scratchpad_changed)
        scratchpad_layout.addWidget(self.scratchpad_edit)
        
        self._scratchpad_widget_for_right_panel = scratchpad_widget
        
        # Create a container for the left side that will hold everything
        left_container = QWidget()
        left_container_layout = QVBoxLayout(left_container)
        left_container_layout.setContentsMargins(0, 0, 0, 0)
        left_container_layout.setSpacing(0)
        
        # Add widgets based on tabs_above_grid setting
        if self.tabs_above_grid:
            # Layout: Filter/Pagination ‚Üí Termview tabs ‚Üí Grid
            # This keeps terminology matches closest to the segment being edited
            left_container_layout.addWidget(filter_pagination_container)
            left_vertical_splitter.addWidget(bottom_tabs)
            left_vertical_splitter.addWidget(grid_container)
            # Set vertical splitter proportions: Tabs smaller, grid larger
            left_vertical_splitter.setSizes([200, 600])
        else:
            # Layout: Filter/Pagination ‚Üí Grid ‚Üí Termview tabs (default)
            left_container_layout.addWidget(filter_pagination_container)
            left_vertical_splitter.addWidget(grid_container)
            left_vertical_splitter.addWidget(bottom_tabs)
            # Set vertical splitter proportions: Grid larger, tabs smaller
            left_vertical_splitter.setSizes([600, 200])
        
        left_container_layout.addWidget(left_vertical_splitter)
        left_vertical_splitter.setHandleWidth(8)
        left_vertical_splitter.setChildrenCollapsible(False)
        
        # Allow left panel to shrink smaller so right panel can expand
        left_container.setMinimumWidth(400)  # Allow grid to shrink to 400px minimum
        
        # Add left side to main horizontal splitter
        main_horizontal_splitter.addWidget(left_container)
        
        # Right side: Translation Results panel with Preview tab
        from modules.translation_results_panel import TranslationResultsPanel
        
        # Create tabbed container for right panel
        right_tabs = QTabWidget()
        right_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        right_tabs.tabBar().setDrawBase(False)
        right_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        
        # Tab 1: Translation Results
        self.translation_results_panel = TranslationResultsPanel(right_tabs, parent_app=self)
        
        # Connect signals for match selection/insertion
        self.translation_results_panel.match_selected.connect(self.on_match_selected)
        self.translation_results_panel.match_inserted.connect(self.on_match_inserted)
        
        # Connect notes editing to save segment notes
        if hasattr(self.translation_results_panel, 'notes_edit') and self.translation_results_panel.notes_edit:
            self.translation_results_panel.notes_edit.textChanged.connect(self._on_results_panel_notes_changed)
        
        # Register this panel so it receives updates when segments are selected
        if not hasattr(self, 'results_panels'):
            self.results_panels = []
        self.results_panels.append(self.translation_results_panel)
        
        # Track tab indices for visibility-aware default selection
        tab_index = 0
        results_tab_index = -1
        compare_tab_index = -1
        preview_tab_index = -1
        
        # Tab 1: Translation Results (conditionally added)
        if self.show_translation_results_pane:
            right_tabs.addTab(self.translation_results_panel, "üîç Translation Results")
            results_tab_index = tab_index
            tab_index += 1
        else:
            # Hide the panel if not added as tab (it still exists as child widget)
            self.translation_results_panel.hide()
        
        # Tab 2: Match Panel (Termview + TM Source/Target) - shown first by default
        match_panel_widget = self._create_match_panel()
        self.match_panel_widget = match_panel_widget  # Store reference for mode detection
        right_tabs.addTab(match_panel_widget, "üéØ Match Panel")
        match_panel_tab_index = tab_index
        tab_index += 1
        
        # Tab 4: Document Preview (always added)
        preview_widget = self._create_preview_tab()
        right_tabs.addTab(preview_widget, "üìÑ Preview")
        preview_tab_index = tab_index
        self._preview_tab_index = preview_tab_index  # Store for visibility checks
        tab_index += 1
        
        # Tab 5: Segment Note (moved from bottom panel)
        right_tabs.addTab(self._notes_widget_for_right_panel, "üìù Segment note")
        tab_index += 1
        
        # Tab 6: Session Log (moved from bottom panel)
        right_tabs.addTab(self._session_log_widget_for_right_panel, "üìã Session Log")
        tab_index += 1
        
        # Tab 7: Scratchpad (private translator notes for the whole project)
        right_tabs.addTab(self._scratchpad_widget_for_right_panel, "üìù Scratchpad")
        tab_index += 1
        
        # Set default selected tab to Match Panel (always show Match Panel first)
        right_tabs.setCurrentIndex(match_panel_tab_index)
        
        # Store reference for later use
        self.right_tabs = right_tabs
        
        # Allow right panel to expand larger for better splitter flexibility
        right_tabs.setMinimumWidth(250)  # Prevent complete collapse
        right_tabs.setMaximumWidth(16777215)  # Remove maximum width constraint (Qt max = 16777215)
        
        main_horizontal_splitter.addWidget(right_tabs)
        
        # Set stretch factors so both sides can resize freely
        main_horizontal_splitter.setStretchFactor(0, 7)  # Left panel gets 70% weight
        main_horizontal_splitter.setStretchFactor(1, 3)  # Right panel gets 30% weight
        
        # Set horizontal splitter proportions: Grid area larger, results smaller
        # Give more space to the grid+editor on the left
        main_horizontal_splitter.setSizes([900, 400])
        main_horizontal_splitter.setHandleWidth(8)
        main_horizontal_splitter.setChildrenCollapsible(False)
        
        layout.addWidget(main_horizontal_splitter)
        
        self.update_warning_banner()

        return widget
    
    # Pagination methods
    def _get_total_pages(self) -> int:
        """Calculate total number of pages based on segment count and page size"""
        if not self.current_project or not self.current_project.segments:
            return 1
        total_segments = len(self.current_project.segments)
        if not hasattr(self, 'grid_page_size') or self.grid_page_size >= 999999:
            return 1  # "All" selected
        return max(1, (total_segments + self.grid_page_size - 1) // self.grid_page_size)
    
    def _update_pagination_ui(self):
        """Update pagination labels and button states"""
        if not self.current_project or not self.current_project.segments:
            if hasattr(self, 'pagination_label') and self._widget_is_alive(self.pagination_label):
                self.pagination_label.setText("Segments 0-0 of 0")
            if hasattr(self, 'total_pages_label') and self._widget_is_alive(self.total_pages_label):
                self.total_pages_label.setText("of 1")
            if hasattr(self, 'page_number_input') and self._widget_is_alive(self.page_number_input):
                self.page_number_input.setText("1")
            return
        
        total_segments = len(self.current_project.segments)
        total_pages = self._get_total_pages()
        
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        if not hasattr(self, 'grid_page_size'):
            self.grid_page_size = 50
        
        # Clamp current page to valid range
        self.grid_current_page = max(0, min(self.grid_current_page, total_pages - 1))
        
        # Calculate segment range for current page
        if self.grid_page_size >= 999999:
            # "All" mode - show all segments
            start_seg = 1
            end_seg = total_segments
        else:
            start_seg = self.grid_current_page * self.grid_page_size + 1
            end_seg = min((self.grid_current_page + 1) * self.grid_page_size, total_segments)
        
        # Update labels
        if hasattr(self, 'pagination_label') and self._widget_is_alive(self.pagination_label):
            self.pagination_label.setText(f"Segments {start_seg}-{end_seg} of {total_segments}")
        
        if hasattr(self, 'total_pages_label') and self._widget_is_alive(self.total_pages_label):
            self.total_pages_label.setText(f"of {total_pages}")
        
        if hasattr(self, 'page_number_input') and self._widget_is_alive(self.page_number_input):
            self.page_number_input.setText(str(self.grid_current_page + 1))
        
        # Enable/disable navigation buttons
        is_first_page = self.grid_current_page == 0
        is_last_page = self.grid_current_page >= total_pages - 1
        
        if hasattr(self, 'first_page_btn') and self._widget_is_alive(self.first_page_btn):
            self.first_page_btn.setEnabled(not is_first_page)
        if hasattr(self, 'prev_page_btn') and self._widget_is_alive(self.prev_page_btn):
            self.prev_page_btn.setEnabled(not is_first_page)
        if hasattr(self, 'next_page_btn') and self._widget_is_alive(self.next_page_btn):
            self.next_page_btn.setEnabled(not is_last_page)
        if hasattr(self, 'last_page_btn') and self._widget_is_alive(self.last_page_btn):
            self.last_page_btn.setEnabled(not is_last_page)
    
    def _apply_pagination_to_grid(self):
        """Show/hide rows based on current page, optionally constrained by active filters.

        IMPORTANT: When a text filter is active (Filter Source/Target boxes), we show ALL
        matching rows across the entire document, ignoring pagination. This ensures users
        can find content regardless of which page they're on.
        
        When no filter is active, normal pagination applies.
        """
        if not self.current_project or not self.current_project.segments:
            return
        
        total_segments = len(self.current_project.segments)
        
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        if not hasattr(self, 'grid_page_size'):
            self.grid_page_size = 50
        
        # If a text filter (Filter Source/Target) is active, it will populate an allowlist
        # of row indices that are allowed to be visible.
        filter_allowlist = getattr(self, '_active_text_filter_rows', None)
        
        # When a filter is active, show ALL matching rows (ignore pagination)
        # When no filter is active, apply normal pagination
        if filter_allowlist is not None:
            # Filter mode: show all matching rows across the entire document
            self.table.setUpdatesEnabled(False)
            try:
                for row in range(total_segments):
                    self.table.setRowHidden(row, row not in filter_allowlist)
            finally:
                self.table.setUpdatesEnabled(True)
        else:
            # Normal pagination mode
            if self.grid_page_size >= 999999:
                # "All" mode - show everything
                start_row = 0
                end_row = total_segments
            else:
                start_row = self.grid_current_page * self.grid_page_size
                end_row = min(start_row + self.grid_page_size, total_segments)
            
            # Batch show/hide for performance
            self.table.setUpdatesEnabled(False)
            try:
                for row in range(total_segments):
                    in_page = start_row <= row < end_row
                    self.table.setRowHidden(row, not in_page)
            finally:
                self.table.setUpdatesEnabled(True)
        
        # Update pagination UI
        self._update_pagination_ui()
    
    def go_to_first_page(self):
        """Navigate to first page"""
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        if self.grid_current_page != 0:
            self.grid_current_page = 0
            self._apply_pagination_to_grid()
    
    def go_to_prev_page(self):
        """Navigate to previous page"""
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        if self.grid_current_page > 0:
            self.grid_current_page -= 1
            self._apply_pagination_to_grid()
    
    def go_to_next_page(self):
        """Navigate to next page"""
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        total_pages = self._get_total_pages()
        if self.grid_current_page < total_pages - 1:
            self.grid_current_page += 1
            self._apply_pagination_to_grid()
    
    def select_range_page_up(self):
        """Select a range of segments upward (Shift+Page Up).
        
        Extends selection from current row upward by one page worth of segments.
        If no selection anchor exists, starts from current row.
        """
        if not hasattr(self, 'table') or not self.table or not self.current_project:
            return
        
        current_row = self.table.currentRow()
        if current_row < 0:
            return
        
        # Calculate page size (number of segments to select)
        page_size = getattr(self, 'grid_page_size', 50)
        if page_size == "All" or page_size is None:
            page_size = 50  # Default to 50 if "All" is selected
        
        # Get or set the selection anchor (starting point for range selection)
        if not hasattr(self, '_selection_anchor_row'):
            self._selection_anchor_row = current_row
        
        # Calculate target row (one page up from current, but not below 0)
        target_row = max(0, current_row - page_size)
        
        # Select range from anchor to target
        self._select_range_between(self._selection_anchor_row, target_row)
        
        # Move focus to the target row
        self.table.setCurrentCell(target_row, 3)  # Column 3 is target cell
        self.table.scrollToItem(self.table.item(target_row, 0))
    
    def select_range_page_down(self):
        """Select a range of segments downward (Shift+Page Down).
        
        Extends selection from current row downward by one page worth of segments.
        If no selection anchor exists, starts from current row.
        """
        if not hasattr(self, 'table') or not self.table or not self.current_project:
            return
        
        current_row = self.table.currentRow()
        if current_row < 0:
            return
        
        # Calculate page size (number of segments to select)
        page_size = getattr(self, 'grid_page_size', 50)
        if page_size == "All" or page_size is None:
            page_size = 50  # Default to 50 if "All" is selected
        
        # Get or set the selection anchor (starting point for range selection)
        if not hasattr(self, '_selection_anchor_row'):
            self._selection_anchor_row = current_row
        
        # Calculate target row (one page down from current, but not beyond last segment)
        max_row = len(self.current_project.segments) - 1
        target_row = min(max_row, current_row + page_size)
        
        # Select range from anchor to target
        self._select_range_between(self._selection_anchor_row, target_row)
        
        # Move focus to the target row
        self.table.setCurrentCell(target_row, 3)  # Column 3 is target cell
        self.table.scrollToItem(self.table.item(target_row, 0))
    
    def _select_range_between(self, start_row: int, end_row: int):
        """Select all rows between start_row and end_row (inclusive).
        
        Args:
            start_row: Selection anchor row
            end_row: Target row to extend selection to
        """
        if not hasattr(self, 'table') or not self.table:
            return
        
        # Determine actual start and end (handle both directions)
        min_row = min(start_row, end_row)
        max_row = max(start_row, end_row)
        
        # Clear existing selection
        self.table.clearSelection()
        
        # Select the range using QTableWidgetSelectionRange
        col_count = self.table.columnCount()
        selection_range = QTableWidgetSelectionRange(min_row, 0, max_row, col_count - 1)
        self.table.setRangeSelected(selection_range, True)
    
    def _clear_selection_anchor(self):
        """Clear the selection anchor when a non-shift click occurs."""
        if hasattr(self, '_selection_anchor_row'):
            del self._selection_anchor_row

    def go_to_last_page(self):
        """Navigate to last page"""
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        total_pages = self._get_total_pages()
        if self.grid_current_page != total_pages - 1:
            self.grid_current_page = total_pages - 1
            self._apply_pagination_to_grid()
    
    def go_to_page(self):
        """Navigate to specific page from input field"""
        if not hasattr(self, 'page_number_input') or not self._widget_is_alive(self.page_number_input):
            return
        try:
            page_num = int(self.page_number_input.text())
            total_pages = self._get_total_pages()
            if not hasattr(self, 'grid_current_page'):
                self.grid_current_page = 0
            new_page = max(0, min(page_num - 1, total_pages - 1))  # Convert to 0-indexed and clamp
            if new_page != self.grid_current_page:
                self.grid_current_page = new_page
                self._apply_pagination_to_grid()
            else:
                # Even if same page, update the input to show clamped value
                self.page_number_input.setText(str(self.grid_current_page + 1))
        except ValueError:
            # Invalid input, reset to current page
            if hasattr(self, 'grid_current_page'):
                self.page_number_input.setText(str(self.grid_current_page + 1))
    
    def on_page_size_changed(self, text: str):
        """Handle page size change"""
        if not hasattr(self, 'grid_page_size'):
            self.grid_page_size = 50
        
        old_page_size = self.grid_page_size
        
        if text == "All":
            self.grid_page_size = 999999
        else:
            try:
                self.grid_page_size = int(text)
            except ValueError:
                self.grid_page_size = 50
        
        # Reset to first page when page size changes
        if not hasattr(self, 'grid_current_page'):
            self.grid_current_page = 0
        else:
            self.grid_current_page = 0
        
        # Apply the new pagination
        self._apply_pagination_to_grid()
    
    def _widget_is_alive(self, widget: Optional[QWidget]) -> bool:
        """Return True if the underlying Qt object still exists."""
        if widget is None:
            return False
        try:
            return not sip.isdeleted(widget)
        except RuntimeError:
            return False

    def _get_line_edit_text(self, attr_name: str) -> str:
        """Safely fetch text from a shared QLineEdit, handling deleted widgets."""
        widget = getattr(self, attr_name, None)
        if not self._widget_is_alive(widget):
            setattr(self, attr_name, None)
            return ""
        return widget.text()

    def _ensure_shared_filter(self, attr_name: str, placeholder: str,
                               on_change: Optional[Callable] = None,
                               on_return: Optional[Callable] = None) -> QLineEdit:
        """Create (or recreate) shared filter widgets that may be destroyed during layout swaps."""
        widget = getattr(self, attr_name, None)
        if not self._widget_is_alive(widget):
            widget = QLineEdit()
            if on_change is not None:
                widget.textChanged.connect(on_change)
            if on_return is not None:
                widget.returnPressed.connect(on_return)
            setattr(self, attr_name, widget)
        widget.setPlaceholderText(placeholder)
        return widget

    def _ensure_primary_filters_ready(self):
        """Make sure the grid filters exist before programmatic use."""
        self.source_filter = self._ensure_shared_filter(
            'source_filter',
            "Type to filter source segments...",
            on_change=self.apply_filters,
            on_return=self.apply_filters,
        )
        self.target_filter = self._ensure_shared_filter(
            'target_filter',
            "Type to filter target segments...",
            on_change=self.apply_filters,
            on_return=self.apply_filters,
        )

    def _build_warning_banner(self, key: str) -> QWidget:
        banner = QWidget()
        banner.setObjectName(f"{key}_warning_banner")
        banner.setStyleSheet(
            "background-color: #dc2626; color: white; padding: 8px; border-radius: 4px;"
        )
        warning_layout = QHBoxLayout(banner)
        warning_layout.setContentsMargins(10, 5, 10, 5)

        warning_icon = QLabel("‚ö†Ô∏è")
        warning_icon.setStyleSheet("font-size: 16px; background: transparent;")
        warning_layout.addWidget(warning_icon)

        warning_text = QLabel(
            "<b>WARNING:</b> Replace in Source Text is ENABLED. "
            "This allows modifying your original source segments. Use with extreme caution!"
        )
        warning_text.setStyleSheet("background: transparent; font-weight: bold;")
        warning_text.setWordWrap(True)
        warning_layout.addWidget(warning_text, stretch=1)

        settings_link = QPushButton("‚öôÔ∏è Disable in Options")
        settings_link.setStyleSheet(
            "background-color: rgba(255, 255, 255, 0.2); color: white; "
            "border: 1px solid white; padding: 4px 12px; border-radius: 3px; font-weight: bold;"
        )
        settings_link.setCursor(Qt.CursorShape.PointingHandCursor)
        settings_link.clicked.connect(self._go_to_settings_tab)
        warning_layout.addWidget(settings_link)

        return banner

    def _get_warning_banner(self, key: str) -> QWidget:
        """Return a per-host warning banner widget, recreating it if needed."""
        banner = self.warning_banners.get(key)
        if not self._widget_is_alive(banner):
            banner = self._build_warning_banner(key)
            self.warning_banners[key] = banner
        elif banner.parent() is not None:
            banner.setParent(None)
        return banner

    def create_translation_grid(self):
        """Create the translation grid (QTableWidget)"""
        self.table = QTableWidget()
        
        # Configure columns
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["#", "Type", "Source", "Target", "Status"])
        
        # Column widths - Source and Target columns stretch to fill space, others are interactive
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)  # ID
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)  # Type
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)  # Source - stretch to fill space
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)  # Target - stretch to fill space
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Interactive)  # Status - allow resizing
        header.setStretchLastSection(False)  # Don't auto-stretch last section (we use Stretch mode for Source/Target)
        
        # Set initial column widths - give Source and Target equal space
        # ID column width will be auto-adjusted by _update_segment_column_width() after segments load
        self.table.setColumnWidth(0, 35)   # ID - temporary, auto-adjusts to fit content
        self.table.setColumnWidth(1, 40)   # Type - narrower
        self.table.setColumnWidth(2, 400)  # Source
        self.table.setColumnWidth(3, 400)  # Target
        self.table.setColumnWidth(4, 60)   # Status - compact
        
        # Enable word wrap in cells (both display and edit mode)
        self.table.setWordWrap(True)
        
        # Apply custom delegate for word wrap in edit mode
        # Pass None for assistance_panel (keyboard shortcuts disabled for now)
        # Pass allow_replace_in_source setting to control source editing
        self.table.setItemDelegate(WordWrapDelegate(None, self.table, self.allow_replace_in_source))
        
        # Row behavior - Enable multi-selection with full row selection (memoQ-style)
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)  # Select full rows for multi-selection
        self.table.setSelectionMode(QTableWidget.SelectionMode.ExtendedSelection)  # Allow Ctrl/Shift multi-selection
        
        # Alternating row colors (simplified view)
        self.table.setAlternatingRowColors(True)

        # Simplified grid styling - subtle borders and padding only
        # Note: Colors are controlled by theme_manager.py for proper dark mode support
        self.table.setStyleSheet("""
            QTableWidget::item {
                padding: 4px;
                border: none;
                border-bottom: 1px solid rgba(128, 128, 128, 0.15);
                border-right: 1px solid rgba(128, 128, 128, 0.15);
            }
            QTableWidget::item:last-child {
                border-right: none;
            }
        """)
        
        # Simplified editing: Double-click only (no F2 key) - companion tool philosophy
        # Grid is primarily for viewing/reviewing, with minor edits allowed
        self.table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked)
        
        # Enable context menu for bulk operations
        self.table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.show_grid_context_menu)
        
        # Connect signals for debugging
        self.table.itemChanged.connect(self.on_cell_changed)
        self.table.currentCellChanged.connect(self.on_cell_selected)
        self.table.itemClicked.connect(self.on_cell_clicked)
        self.table.cellDoubleClicked.connect(self.on_cell_double_clicked)

        # Add additional selection signal for row-based selection mode
        self.table.itemSelectionChanged.connect(self.on_selection_changed)

        # Debug: Confirm signal connections
        self.log("üîå Table signals connected: currentCellChanged, itemClicked, cellDoubleClicked, itemSelectionChanged")
        
        # Add precision scroll buttons (memoQ-style)
        self.add_precision_scroll_buttons()
    
    def add_precision_scroll_buttons(self):
        """Add precision scroll buttons at top/bottom of scrollbar (memoQ-style)"""
        from PyQt6.QtWidgets import QPushButton
        from PyQt6.QtCore import Qt, QTimer
        
        # Get the vertical scrollbar
        scrollbar = self.table.verticalScrollBar()
        
        # Create scroll up button (appears at top)
        self.scroll_up_btn = QPushButton("‚ñ≤", self.table)
        self.scroll_up_btn.setFixedSize(18, 22)
        self.scroll_up_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(240, 240, 240, 220);
                border: 1px solid #ccc;
                border-radius: 3px;
                font-size: 9pt;
                font-weight: bold;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: #2196F3;
                color: white;
                border: 1px solid #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.scroll_up_btn.setToolTip("Scroll up one row (Precision scroll)")
        self.scroll_up_btn.clicked.connect(lambda: self.precision_scroll(-1))
        self.scroll_up_btn.raise_()  # Bring to front
        self.scroll_up_btn.show()  # Start visible for testing
        
        # Create scroll down button (appears at bottom)
        self.scroll_down_btn = QPushButton("‚ñº", self.table)
        self.scroll_down_btn.setFixedSize(18, 22)
        self.scroll_down_btn.setStyleSheet("""
            QPushButton {
                background-color: rgba(240, 240, 240, 220);
                border: 1px solid #ccc;
                border-radius: 3px;
                font-size: 9pt;
                font-weight: bold;
                padding: 0px;
            }
            QPushButton:hover {
                background-color: #2196F3;
                color: white;
                border: 1px solid #1976D2;
            }
            QPushButton:pressed {
                background-color: #1565C0;
            }
        """)
        self.scroll_down_btn.setToolTip("Scroll down one row (Precision scroll)")
        self.scroll_down_btn.clicked.connect(lambda: self.precision_scroll(1))
        self.scroll_down_btn.raise_()  # Bring to front
        self.scroll_down_btn.show()  # Start visible for testing
        
        # Position buttons initially
        QTimer.singleShot(100, self.position_precision_scroll_buttons)
        
        # Update position when table is resized
        self.table.resizeEvent = self._table_resize_event_wrapper(self.table.resizeEvent)
    
    def _table_resize_event_wrapper(self, original_resize_event):
        """Wrapper for table resize event to reposition scroll buttons"""
        def wrapped_resize_event(event):
            result = original_resize_event(event)
            self.position_precision_scroll_buttons()
            return result
        return wrapped_resize_event
    
    def precision_scroll(self, direction):
        """Scroll table by a small amount for fine-tuned navigation
        Args:
            direction: -1 for up, 1 for down
        """
        scrollbar = self.table.verticalScrollBar()
        current = scrollbar.value()
        
        # Use fixed pixel amounts based on divisor (inversely related)
        # Higher divisor = smaller scroll amount = finer control
        divisor = getattr(self, 'precision_scroll_divisor', 3)
        
        # Map divisor (1-10) to scroll amount (50-5 pixels)
        # divisor 1 = 50px, divisor 3 = 30px, divisor 5 = 20px, divisor 10 = 5px
        scroll_amount = max(5, 55 - (divisor * 5))
        
        new_value = current + (direction * scroll_amount)
        scrollbar.setValue(new_value)
    
    def position_precision_scroll_buttons(self):
        """Position precision scroll buttons at top/bottom of scrollbar"""
        if not hasattr(self, 'scroll_up_btn') or not hasattr(self, 'scroll_down_btn'):
            return
        
        scrollbar = self.table.verticalScrollBar()
        
        # Always position buttons, even if scrollbar not visible yet
        table_width = self.table.width()
        table_height = self.table.height()
        
        # Position buttons to the left of scrollbar (scrollbar is ~17px wide)
        scrollbar_width = scrollbar.width() if scrollbar.isVisible() else 17
        x_pos = table_width - scrollbar_width - 24  # 24 = button width + small margin
        
        # Up button at top (below header)
        header_height = self.table.horizontalHeader().height()
        self.scroll_up_btn.move(x_pos, header_height + 5)
        
        # Down button at bottom (above status bar area)
        self.scroll_down_btn.move(x_pos, table_height - 30)
        
        # Show/hide based on scrollbar visibility
        if scrollbar.isVisible():
            self.scroll_up_btn.show()
            self.scroll_down_btn.show()
        else:
            self.scroll_up_btn.hide()
            self.scroll_down_btn.hide()
    
    def create_assistance_panel(self):
        """Create the assistance panel widget (Translation Results) with compact resizeable design"""
        from PyQt6.QtWidgets import QWidget, QVBoxLayout, QTabWidget
        from modules.translation_results_panel import TranslationResultsPanel
        
        tabs = QTabWidget()
        tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        tabs.tabBar().setDrawBase(False)
        tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        tabs.setTabPosition(QTabWidget.TabPosition.South)  # Tabs at bottom for easy access
        
        # Get match limits from settings
        general_settings = self.load_general_settings()
        match_limits = general_settings.get('match_limits', {
            "LLM": 3,
            "MT": 3,
            "TM": 5,
            "Termbases": 10
        })
        
        try:
            # Create translation results panel with dynamic font sizing
            results_panel = TranslationResultsPanel(tabs, parent_app=self)
            results_panel.match_inserted.connect(self.on_match_inserted)
            tabs.addTab(results_panel, "üîç Translation Results")
            
            # Store reference so we can update it when segments are selected
            if not hasattr(self, 'results_panels'):
                self.results_panels = []
            self.results_panels.append(results_panel)
        except ImportError as e:
            print(f"Warning: Could not import TranslationResultsPanel: {e}")
            placeholder = QWidget()
            tabs.addTab(placeholder, "üîç Translation Results")
        
        # Tab 2: Segment Editor
        editor_widget = QWidget()
        editor_layout = QVBoxLayout(editor_widget)
        editor_layout.setContentsMargins(10, 10, 10, 10)
        
        # Segment info header
        info_layout = QHBoxLayout()
        tab_seg_info = QLabel("Select a segment to edit")
        tab_seg_info.setStyleSheet("font-weight: bold; font-size: 11pt;")
        info_layout.addWidget(tab_seg_info, stretch=1)

        # Status selector
        from modules.statuses import STATUSES
        status_label = QLabel("Status:")
        tab_status_combo = QComboBox()
        tab_status_combo.setMinimumWidth(130)  # Ensure full status text is visible
        for status_key in STATUSES.keys():
            definition = get_status(status_key)
            tab_status_combo.addItem(definition.label, status_key)
        tab_status_combo.currentIndexChanged.connect(self.on_tab_status_combo_changed)
        info_layout.addWidget(status_label)
        info_layout.addWidget(tab_status_combo)
        editor_layout.addLayout(info_layout)
        
        # Source text (read-only)
        source_label = QLabel("Source:")
        source_label.setStyleSheet("font-weight: bold;")
        editor_layout.addWidget(source_label)
        tab_source_editor = QTextEdit()
        tab_source_editor.setReadOnly(True)
        tab_source_editor.setMaximumHeight(100)
        tab_source_editor.setStyleSheet("")
        editor_layout.addWidget(tab_source_editor)
        
        # Target text (editable)
        target_label = QLabel("Target:")
        target_label.setStyleSheet("font-weight: bold;")
        editor_layout.addWidget(target_label)
        tab_target_editor = QTextEdit()
        tab_target_editor.setMaximumHeight(100)
        tab_target_editor.textChanged.connect(self.on_tab_target_change)
        editor_layout.addWidget(tab_target_editor)
        
        # Store references to THIS panel's widgets so we can update them
        editor_widget.seg_info_label = tab_seg_info
        editor_widget.source_editor = tab_source_editor
        editor_widget.target_editor = tab_target_editor
        editor_widget.status_combo = tab_status_combo
        
        # Action buttons
        button_layout = QHBoxLayout()
        copy_btn = QPushButton("üìã Copy Source ‚Üí Target")
        copy_btn.clicked.connect(self.copy_source_to_tab_target)
        clear_btn = QPushButton("üóëÔ∏è Clear Target")
        clear_btn.clicked.connect(self.clear_tab_target)

        # Voice dictation button
        dictate_btn = QPushButton("üé§ Dictation (F9)")
        dictate_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        dictate_btn.clicked.connect(self.start_voice_dictation)
        dictate_btn.setToolTip("Click or press F9 to start/stop voice dictation")

        # Store reference to dictate button for state updates
        editor_widget.dictate_btn = dictate_btn

        save_btn = QPushButton("üíæ Save")
        save_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        save_btn.clicked.connect(self.save_tab_segment)
        save_next_btn = QPushButton("‚úì Confirm && Next (Ctrl+Enter)")
        save_next_btn.setStyleSheet("background-color: #2196F3; color: white; font-weight: bold;")
        save_next_btn.clicked.connect(self.confirm_selected_or_next)

        button_layout.addWidget(copy_btn)
        button_layout.addWidget(clear_btn)
        button_layout.addWidget(dictate_btn)
        button_layout.addStretch()
        button_layout.addWidget(save_btn)
        button_layout.addWidget(save_next_btn)
        editor_layout.addLayout(button_layout)
        
        editor_layout.addStretch()
        tabs.addTab(editor_widget, "üìù Segment Editor")
        
        # Tab 3: Comments Editor
        notes_widget = QWidget()
        notes_layout = QVBoxLayout(notes_widget)
        notes_layout.setContentsMargins(10, 10, 10, 10)
        
        notes_header = QLabel("Segment Comments")
        notes_header.setStyleSheet("font-weight: bold; font-size: 11pt;")
        notes_layout.addWidget(notes_header)
        
        tab_notes_editor = QTextEdit()
        tab_notes_editor.setPlaceholderText("Add comments for this segment...\n\n"
                                            "Comments are saved per segment and can include:\n"
                                            "‚Ä¢ Translation context\n"
                                            "‚Ä¢ Client preferences\n"
                                            "‚Ä¢ Terminology decisions\n"
                                            "‚Ä¢ Questions or clarifications needed")
        tab_notes_editor.textChanged.connect(self.on_tab_notes_change)
        notes_layout.addWidget(tab_notes_editor)
        
        # Store reference to THIS panel's comments editor
        notes_widget.notes_editor = tab_notes_editor
        
        notes_button_layout = QHBoxLayout()
        save_notes_btn = QPushButton("üíæ Save Comments")
        save_notes_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        save_notes_btn.clicked.connect(self.save_tab_notes)
        notes_button_layout.addStretch()
        notes_button_layout.addWidget(save_notes_btn)
        notes_layout.addLayout(notes_button_layout)
        
        tabs.addTab(notes_widget, "üìã Comments")
        
        # Store references to tab widgets for updates
        tabs.editor_widget = editor_widget
        tabs.notes_widget = notes_widget
        
        # Keep track of all tabbed panels
        if not hasattr(self, 'tabbed_panels'):
            self.tabbed_panels = []
        self.tabbed_panels.append(tabs)
        
        return tabs
    
    def on_match_selected(self, match):
        """Handle match selection from TranslationResultsPanel"""
        # This will be called when user selects a match in the panel
        # Can be used for highlighting, compare boxes, etc.
        pass
    
    def on_match_inserted(self, match_text: str):
        """
        Handle match insertion (user pressed Ctrl+number or Spacebar in match pane)
        Insert the match text at the cursor position in the currently selected target cell
        WITHOUT confirming the segment or moving to next
        """
        try:
            if not self.current_project or not self.table:
                return
            
            # Get current row
            row = self.table.currentRow()
            col = self.table.currentColumn()
            
            if row >= 0:
                # CRITICAL: Get segment by ID from grid, not by row index!
                id_item = self.table.item(row, 0)
                if not id_item:
                    self.log(f"‚ö†Ô∏è No segment ID found at row {row}")
                    return
                
                try:
                    segment_id = int(id_item.text())
                except (ValueError, AttributeError):
                    self.log(f"‚ö†Ô∏è Could not parse segment ID from row {row}")
                    return
                
                # Find segment by ID
                segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
                if not segment:
                    self.log(f"‚ö†Ô∏è Could not find segment with ID {segment_id}")
                    return
                
                # Get the target cell widget (EditableGridTextEditor)
                target_widget = self.table.cellWidget(row, 3)  # Column 3 is target
                
                if target_widget and isinstance(target_widget, QTextEdit):
                    # Insert text at cursor position
                    cursor = target_widget.textCursor()
                    cursor.insertText(match_text)
                    
                    # Update the segment data
                    segment.target = target_widget.toPlainText()
                    
                    # Set focus back to the target editor
                    target_widget.setFocus()
                    
                    self.log(f"‚úì Match inserted into segment {segment.id} at cursor position")
                elif col == 3:
                    # Fallback: If no widget exists, create one or set text directly
                    segment.target = match_text
                    
                    # Try to update via cellWidget first
                    if target_widget:
                        target_widget.setPlainText(match_text)
                    
                    self.log(f"‚úì Match inserted into segment {row + 1}")
                else:
                    self.log(f"‚ö† Please click on the target cell first to insert match")
            
        except Exception as e:
            self.log(f"Error inserting match: {e}")
            import traceback
            traceback.print_exc()
    
    # ========================================================================
    # PROJECT MANAGEMENT
    # ========================================================================
    
    def new_project(self):
        """Create a new project"""
        from PyQt6.QtWidgets import (
            QVBoxLayout, QHBoxLayout, QFormLayout, QGroupBox, QTextEdit,
            QComboBox, QRadioButton, QButtonGroup, QPushButton, QTabWidget
        )
        from modules.simple_segmenter import SimpleSegmenter
        
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("New Translation Project")
        dialog.setMinimumWidth(700)
        dialog.setMinimumHeight(500)
        
        layout = QVBoxLayout(dialog)
        
        # Project Settings Group
        settings_group = QGroupBox("Project Settings")
        settings_layout = QFormLayout()
        
        # Project name
        name_input = QLineEdit()
        name_input.setText("Untitled Project")
        name_input.selectAll()
        settings_layout.addRow("Project Name:", name_input)
        
        # Source language
        source_lang_combo = QComboBox()
        # Full language list matching Settings ‚Üí Language Pair (with ISO 639-1 codes)
        available_langs = [
            ("Afrikaans", "af"), ("Albanian", "sq"), ("Arabic", "ar"), ("Armenian", "hy"),
            ("Basque", "eu"), ("Bengali", "bn"), ("Bulgarian", "bg"), ("Catalan", "ca"),
            ("Chinese (Simplified)", "zh-CN"), ("Chinese (Traditional)", "zh-TW"),
            ("Croatian", "hr"), ("Czech", "cs"), ("Danish", "da"), ("Dutch", "nl"),
            ("English", "en"), ("Estonian", "et"), ("Finnish", "fi"), ("French", "fr"),
            ("Galician", "gl"), ("Georgian", "ka"), ("German", "de"), ("Greek", "el"),
            ("Hebrew", "he"), ("Hindi", "hi"), ("Hungarian", "hu"), ("Icelandic", "is"),
            ("Indonesian", "id"), ("Irish", "ga"), ("Italian", "it"), ("Japanese", "ja"),
            ("Korean", "ko"), ("Latvian", "lv"), ("Lithuanian", "lt"), ("Macedonian", "mk"),
            ("Malay", "ms"), ("Norwegian", "no"), ("Persian", "fa"), ("Polish", "pl"),
            ("Portuguese", "pt"), ("Romanian", "ro"), ("Russian", "ru"), ("Serbian", "sr"),
            ("Slovak", "sk"), ("Slovenian", "sl"), ("Spanish", "es"), ("Swahili", "sw"),
            ("Swedish", "sv"), ("Thai", "th"), ("Turkish", "tr"), ("Ukrainian", "uk"),
            ("Urdu", "ur"), ("Vietnamese", "vi"), ("Welsh", "cy"),
        ]
        for lang_name, lang_code in available_langs:
            source_lang_combo.addItem(lang_name, lang_code)
        settings_layout.addRow("Source Language:", source_lang_combo)

        # Target language
        target_lang_combo = QComboBox()
        for lang_name, lang_code in available_langs:
            target_lang_combo.addItem(lang_name, lang_code)

        # Set defaults based on global language settings
        source_lang_combo.setCurrentText(self.source_language)
        target_lang_combo.setCurrentText(self.target_language)
        
        settings_layout.addRow("Target Language:", target_lang_combo)
        
        settings_group.setLayout(settings_layout)
        layout.addWidget(settings_group)
        
        # Import Options Group
        import_group = QGroupBox("Import Source Text")
        import_layout = QVBoxLayout()
        
        # Tab widget for different import methods
        import_tabs = QTabWidget()
        import_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        import_tabs.tabBar().setDrawBase(False)
        import_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        
        # Tab 1: Paste Text
        paste_tab = QWidget()
        paste_layout = QVBoxLayout(paste_tab)
        paste_layout.addWidget(QLabel("Paste or type your source text below:"))
        
        text_input = QTextEdit()
        text_input.setPlaceholderText(
            "Paste your text here...\n\n"
            "Text will be automatically segmented into sentences.\n"
            "Each sentence becomes a translatable segment."
        )
        paste_layout.addWidget(text_input)
        import_tabs.addTab(paste_tab, "üìù Paste Text")
        
        # Tab 2: Load from File
        file_tab = QWidget()
        file_layout = QVBoxLayout(file_tab)
        file_layout.addWidget(QLabel("Load text from a file:"))
        
        file_path_display = QLineEdit()
        file_path_display.setPlaceholderText("No file selected...")
        file_path_display.setReadOnly(True)
        
        browse_btn = QPushButton("üìÅ Browse...")
        
        def browse_file():
            file_path, _ = QFileDialog.getOpenFileName(
                dialog,
                "Select Text File",
                "",
                "Text Files (*.txt);;All Files (*.*)"
            )
            if file_path:
                file_path_display.setText(file_path)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        text_input.setText(f.read())
                    import_tabs.setCurrentIndex(0)  # Switch to paste tab to show loaded text
                except Exception as e:
                    QMessageBox.warning(dialog, "Error", f"Could not load file:\n{e}")
        
        browse_btn.clicked.connect(browse_file)
        
        file_btn_layout = QHBoxLayout()
        file_btn_layout.addWidget(file_path_display)
        file_btn_layout.addWidget(browse_btn)
        file_layout.addLayout(file_btn_layout)
        file_layout.addStretch()
        
        import_tabs.addTab(file_tab, "üìÑ Load File")
        
        # Tab 3: Start Empty
        empty_tab = QWidget()
        empty_layout = QVBoxLayout(empty_tab)
        empty_layout.addWidget(QLabel("Create an empty project:"))
        empty_layout.addWidget(QLabel("You can add segments manually after creation."))
        empty_layout.addStretch()
        import_tabs.addTab(empty_tab, "\u2b50 Start Empty")
        
        import_layout.addWidget(import_tabs)
        import_group.setLayout(import_layout)
        layout.addWidget(import_group)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        create_btn = QPushButton("Create Project")
        create_btn.setDefault(True)
        create_btn.setMinimumWidth(120)
        create_btn.clicked.connect(dialog.accept)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.setMinimumWidth(120)
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addWidget(create_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)
        
        # Show dialog
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Create project
        project_name = name_input.text().strip() or "Untitled Project"
        source_lang = source_lang_combo.currentData()
        target_lang = target_lang_combo.currentData()
        
        # Validate languages
        if source_lang == target_lang:
            QMessageBox.warning(
                self,
                "Invalid Languages",
                "Source and target languages must be different!"
            )
            return
        
        # Create project
        self.current_project = Project(
            name=project_name,
            source_lang=source_lang,
            target_lang=target_lang,
            segments=[]
        )

        # Sync global language settings with new project languages
        self.source_language = source_lang
        self.target_language = target_lang

        # Process source text if provided
        source_text = text_input.toPlainText().strip()
        if source_text:
            try:
                segmenter = SimpleSegmenter()
                sentences = segmenter.segment_text(source_text)
                
                # Create segments
                for idx, sentence in enumerate(sentences, start=1):
                    if sentence.strip():
                        segment = Segment(
                            id=idx,
                            source=sentence.strip(),
                            target="",
                            status="untranslated"
                        )
                        self.current_project.segments.append(segment)
                
                self.log(f"Created {len(self.current_project.segments)} segments from source text")
            except Exception as e:
                QMessageBox.warning(
                    self,
                    "Segmentation Error",
                    f"Could not segment text:\n{e}\n\nProject created but no segments added."
                )
        
        # Update UI
        self.project_file_path = None
        self.project_modified = True  # Mark as modified since it hasn't been saved
        self.update_window_title()
        self.load_segments_to_grid()
        self.initialize_tm_database()  # Initialize TM for this project
        
        # Clear scratchpad for new project
        self._update_scratchpad_for_project()
        
        self.log(f"Created new project: {project_name} ({source_lang} ‚Üí {target_lang})")
        
        # Prompt to save
        if self.current_project.segments:
            reply = QMessageBox.question(
                self,
                "Save Project",
                "Would you like to save your new project now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.Yes:
                self.save_project_as()
    
    def closeEvent(self, event):
        """Handle application close - cleanup AHK process"""
        try:
            # Clean up ahk library if used
            if hasattr(self, 'lookup_tab') and hasattr(self.lookup_tab, '_using_ahk_library') and self.lookup_tab._using_ahk_library:
                if hasattr(self.lookup_tab, '_ahk') and self.lookup_tab._ahk:
                    try:
                        self.lookup_tab._ahk.stop_hotkeys()
                        print("[Superlookup] ahk library hotkeys stopped")
                    except Exception as e:
                        print(f"[Superlookup] Error stopping ahk library: {e}")
            
            # Terminate external AutoHotkey process if running (fallback method)
            if hasattr(self, 'lookup_tab') and hasattr(self.lookup_tab, 'ahk_process') and self.lookup_tab.ahk_process:
                try:
                    self.lookup_tab.ahk_process.terminate()
                    self.lookup_tab.ahk_process.wait(timeout=2)
                    print("[Superlookup] AHK process terminated")
                except:
                    # Force kill if terminate doesn't work
                    try:
                        self.lookup_tab.ahk_process.kill()
                    except:
                        pass
        except Exception as e:
            print(f"[Superlookup] Error terminating AHK: {e}")
        
        # Accept the close event
        event.accept()
    
    def open_project(self):
        """Open a project file"""
        file_path, _ = fdh.get_open_file_name(
            self,
            "Open Project",
            "Supervertaler Projects (*.svproj);;Legacy Projects (*.json);;All Files (*.*)"
        )
        
        if file_path:
            self.load_project(file_path)
    
    def load_project(self, file_path: str):
        """Load project from file"""
        try:
            # Try UTF-8 first, fall back to latin-1 if it fails
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
            except UnicodeDecodeError:
                self.log(f"‚ö† UTF-8 decoding failed, trying latin-1 encoding...")
                with open(file_path, 'r', encoding='latin-1') as f:
                    data = json.load(f)
            
            # If no name in file, use filename
            if 'name' not in data:
                data['name'] = Path(file_path).stem
            
            self.current_project = Project.from_dict(data)
            self.project_file_path = file_path
            self.project_modified = False

            # Sync global language settings with project languages
            if self.current_project.source_lang:
                self.source_language = self.current_project.source_lang
            if self.current_project.target_lang:
                self.target_language = self.current_project.target_lang

            # Restore prompt settings if they exist (unified library)
            if hasattr(self.current_project, 'prompt_settings') and self.current_project.prompt_settings:
                prompt_settings = self.current_project.prompt_settings
                if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                    library = self.prompt_manager_qt.library
                    
                    # Restore primary prompt
                    primary_path = prompt_settings.get('active_primary_prompt_path')
                    if primary_path:
                        # Check if it's an external prompt (path starts with [EXTERNAL])
                        if primary_path.startswith('[EXTERNAL] '):
                            # Extract the actual file path
                            external_file_path = primary_path[len('[EXTERNAL] '):]
                            if os.path.exists(external_file_path):
                                success, _ = library.set_external_primary_prompt(external_file_path)
                                if success:
                                    # Update the UI label
                                    display_name = Path(external_file_path).stem
                                    self.prompt_manager_qt.primary_prompt_label.setText(f"üìÅ {display_name}")
                                    self.prompt_manager_qt.primary_prompt_label.setStyleSheet("color: #000; font-weight: bold;")
                                    # Display the external prompt in the editor
                                    self.prompt_manager_qt._display_external_prompt_in_editor(external_file_path, display_name)
                                    self.log(f"‚úì Restored external primary prompt: {display_name}")
                            else:
                                self.log(f"‚ö† External prompt file not found: {external_file_path}")
                        elif primary_path in library.prompts:
                            # Regular library prompt
                            self.prompt_manager_qt._set_primary_prompt(primary_path)
                            self.log(f"‚úì Restored primary prompt: {primary_path}")
                    
                    # Restore attached prompts
                    attached_paths = prompt_settings.get('attached_prompt_paths', [])
                    for path in attached_paths:
                        if path in library.prompts:
                            # Use the UI method to update both internal state and UI
                            self.prompt_manager_qt._attach_prompt(path)
                            self.log(f"‚úì Restored attached prompt: {path}")
                    
                    # Restore mode
                    mode = prompt_settings.get('mode', 'single')
                    if hasattr(self.prompt_manager_qt, 'set_mode'):
                        self.prompt_manager_qt.set_mode(mode)
                
                # Restore image context folder
                image_folder = prompt_settings.get('image_context_folder')
                if image_folder and hasattr(self, 'figure_context') and self.figure_context:
                    try:
                        if os.path.exists(image_folder):
                            count = self.figure_context.load_from_folder(image_folder)
                            if count > 0:
                                if hasattr(self, 'image_context_status_label'):
                                    self.image_context_status_label.setText(f"‚úÖ {count} images loaded: {Path(image_folder).name}")
                                    self.image_context_status_label.setStyleSheet("color: #4CAF50; font-weight: bold; font-size: 11px; padding: 5px;")
                                self.log(f"‚úÖ Restored image context: {count} images from {image_folder}")
                        else:
                            self.log(f"‚ö†Ô∏è  Saved image folder not found: {image_folder}")
                    except Exception as e:
                        self.log(f"‚ùå Error restoring image context: {e}")
                
                # Restore Image Extractor file list
                extractor_files = prompt_settings.get('image_extractor_files', [])
                if extractor_files and hasattr(self, 'image_extractor_file_list'):
                    self.image_extractor_file_list.clear()
                    valid_files = []
                    for file_path in extractor_files:
                        if os.path.exists(file_path):
                            self.image_extractor_file_list.addItem(file_path)
                            valid_files.append(file_path)
                        else:
                            self.log(f"‚ö†Ô∏è Image extractor file not found: {file_path}")
                    if valid_files:
                        self.log(f"‚úÖ Restored {len(valid_files)} files in Image Extractor")
            
            # Restore original DOCX path for structure-preserving export
            if hasattr(self.current_project, 'original_docx_path') and self.current_project.original_docx_path:
                docx_path = self.current_project.original_docx_path
                if os.path.exists(docx_path):
                    self.original_docx = docx_path
                    self.current_document_path = docx_path
                    self.log(f"‚úì Restored original DOCX path: {Path(docx_path).name}")
                else:
                    self.log(f"‚ö†Ô∏è Original DOCX not found: {docx_path}")
            
            # Restore SDLPPX handler for Trados package projects
            if hasattr(self.current_project, 'sdlppx_source_path') and self.current_project.sdlppx_source_path:
                sdlppx_path = self.current_project.sdlppx_source_path
                if os.path.exists(sdlppx_path):
                    try:
                        from modules.sdlppx_handler import TradosPackageHandler
                        self.sdlppx_handler = TradosPackageHandler(log_callback=self.log)
                        package = self.sdlppx_handler.load_package(sdlppx_path)
                        if package:
                            self.sdlppx_source_file = sdlppx_path  # Store source file path for export
                            self.log(f"‚úì Restored Trados package handler: {Path(sdlppx_path).name}")
                            self.log(f"  ‚Üí SDLRPX export enabled for this project")
                        else:
                            self.log(f"‚ö†Ô∏è Could not load SDLPPX package: {sdlppx_path}")
                            self.sdlppx_handler = None
                    except Exception as e:
                        self.log(f"‚ö†Ô∏è Could not restore SDLPPX handler: {e}")
                        self.sdlppx_handler = None
                else:
                    self.log(f"‚ö†Ô∏è SDLPPX package not found: {sdlppx_path}")
                    self.sdlppx_handler = None
            
            self.load_segments_to_grid()
            self.initialize_tm_database()  # Initialize TM for this project
            self.update_window_title()
            self.add_to_recent_projects(file_path)
            
            # Auto-resize rows for better initial display
            self.auto_resize_rows()
            
            # Update file filter dropdown for multi-file projects
            if hasattr(self, '_update_file_filter_combo'):
                self._update_file_filter_combo()
            
            # Restore activated TMs for this project
            if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                if project_id:
                    # First deactivate all TMs for this project (start clean)
                    all_tms = self.tm_metadata_mgr.get_all_tms()
                    for tm in all_tms:
                        self.tm_metadata_mgr.deactivate_tm(tm['id'], project_id)

                    # Then restore saved TM activations if they exist
                    if hasattr(self.current_project, 'tm_settings') and self.current_project.tm_settings:
                        activated_tm_ids = self.current_project.tm_settings.get('activated_tm_ids', [])
                        if activated_tm_ids:
                            # Activate the saved TMs and restore read_only status
                            tm_read_only_status = self.current_project.tm_settings.get('tm_read_only_status', {})
                            for tm_id in activated_tm_ids:
                                # Find TM by tm_id (not db id)
                                tm = next((t for t in all_tms if t['tm_id'] == tm_id), None)
                                if tm:
                                    self.tm_metadata_mgr.activate_tm(tm['id'], project_id)
                                    # Restore read_only status if saved
                                    if tm_id in tm_read_only_status:
                                        read_only = tm_read_only_status[tm_id]
                                        self.tm_metadata_mgr.set_read_only(tm['id'], read_only)
                                        status = "read-only" if read_only else "writable"
                                        self.log(f"‚úì Restored TM: {tm['name']} (activated, {status})")
                                    else:
                                        self.log(f"‚úì Restored activated TM: {tm['name']}")
                                else:
                                    self.log(f"‚ö†Ô∏è Could not find TM with tm_id: {tm_id}")

                    # Refresh TM UI to show (de)activations
                    if hasattr(self, 'tm_tab_refresh_callback'):
                        self.tm_tab_refresh_callback()

            # Restore activated termbases for this project
            if hasattr(self, 'termbase_mgr') and self.termbase_mgr and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                if project_id:
                    # First deactivate all termbases for this project (start clean)
                    all_termbases = self.termbase_mgr.get_all_termbases()
                    for tb in all_termbases:
                        self.termbase_mgr.deactivate_termbase(tb['id'], project_id)
                    
                    # Then restore saved active termbases (if any)
                    if hasattr(self.current_project, 'termbase_settings') and self.current_project.termbase_settings:
                        active_termbase_ids = self.current_project.termbase_settings.get('active_termbase_ids', [])
                        termbase_priorities = self.current_project.termbase_settings.get('termbase_priorities', {})
                        
                        if active_termbase_ids:
                            for tb_id in active_termbase_ids:
                                # Find termbase by id
                                tb = next((t for t in all_termbases if t['id'] == tb_id), None)
                                if tb:
                                    self.termbase_mgr.activate_termbase(tb_id, project_id)
                                    self.log(f"‚úì Restored activated termbase: {tb['name']}")
                                    
                                    # Restore priority if saved
                                    if str(tb_id) in termbase_priorities:
                                        priority = termbase_priorities[str(tb_id)]
                                        self.termbase_mgr.set_termbase_priority(tb_id, project_id, priority)
                                        self.log(f"‚úì Restored termbase priority: {tb['name']} ‚Üí #{priority}")
                                else:
                                    self.log(f"‚ö†Ô∏è Could not find termbase with id: {tb_id}")
                        else:
                            self.log(f"üìã No active termbases saved for this project")
                    else:
                        self.log(f"üìã No termbase settings found in project file")
                    
                    # Refresh termbase UI to show restored activations
                    if hasattr(self, 'termbase_tab_refresh_callback'):
                        self.termbase_tab_refresh_callback()
                        self.log(f"‚úì Refreshed termbase UI with restored activations")
            
            # Restore activated non-translatables lists for this project
            if hasattr(self, 'nt_manager') and self.nt_manager and self.current_project:
                if hasattr(self.current_project, 'nt_settings') and self.current_project.nt_settings:
                    active_list_names = self.current_project.nt_settings.get('active_lists', [])
                    
                    if active_list_names:
                        # First deactivate all lists
                        for name in list(self.nt_manager.lists.keys()):
                            self.nt_manager.set_list_active(name, False)
                        
                        # Then activate the saved lists
                        for list_name in active_list_names:
                            if list_name in self.nt_manager.lists:
                                self.nt_manager.set_list_active(list_name, True)
                                self.log(f"‚úì Restored active NT list: {list_name}")
                            else:
                                self.log(f"‚ö†Ô∏è Could not find NT list: {list_name}")
                        
                        # Refresh NT UI if available
                        if hasattr(self, 'nt_list_combo') and self.nt_list_combo:
                            # Trigger refresh by resetting combo selection
                            current_idx = self.nt_list_combo.currentIndex()
                            self.nt_list_combo.setCurrentIndex(-1)
                            self.nt_list_combo.setCurrentIndex(current_idx if current_idx >= 0 else 0)
                    else:
                        self.log(f"üìã No active NT lists saved for this project")
                else:
                    self.log(f"üìã No NT settings found in project file")
            
            # Restore spellcheck settings from project
            if self.current_project.spellcheck_settings:
                spellcheck_settings = self.current_project.spellcheck_settings
                self.spellcheck_enabled = spellcheck_settings.get('enabled', False)
                TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
                
                # Update UI elements
                if hasattr(self, 'spellcheck_btn'):
                    self.spellcheck_btn.setChecked(self.spellcheck_enabled)
                if hasattr(self, 'spellcheck_toggle_action'):
                    self.spellcheck_toggle_action.setChecked(self.spellcheck_enabled)
                self._update_spellcheck_button_style()
                
                # Always use the project's target language for spellcheck
                # (ignore any saved language - target language is the correct one)
                project_target = self.current_project.target_lang if self.current_project else self.target_language
                if project_target and self.spellcheck_manager.set_language(project_target):
                    if self.spellcheck_enabled:
                        self.log(f"‚úì Spellcheck enabled for target language: {project_target}")
                    else:
                        self.log(f"‚úì Spellcheck initialized for target language: {project_target} (disabled)")
                else:
                    self.log(f"‚ö† Spellcheck dictionary not available for {project_target}")
            else:
                # No spellcheck settings in project - always initialize for target language
                # (even if spellcheck is disabled, set the language so it's ready when enabled)
                if self.current_project:
                    project_target = self.current_project.target_lang
                    if project_target and self.spellcheck_manager.set_language(project_target):
                        self.log(f"‚úì Spellcheck initialized for target language: {project_target}")
            
            # Restore results pane font sizes from project
            if hasattr(self.current_project, 'ui_settings') and self.current_project.ui_settings:
                match_size = self.current_project.ui_settings.get('results_match_font_size')
                compare_size = self.current_project.ui_settings.get('results_compare_font_size')
                
                if match_size and 7 <= match_size <= 16:
                    from modules.translation_results_panel import CompactMatchItem
                    CompactMatchItem.set_font_size(match_size)
                    if hasattr(self, 'results_panels'):
                        for panel in self.results_panels:
                            if hasattr(panel, 'set_font_size'):
                                panel.set_font_size(match_size)
                
                if compare_size and 7 <= compare_size <= 14:
                    from modules.translation_results_panel import TranslationResultsPanel
                    TranslationResultsPanel.compare_box_font_size = compare_size
                    if hasattr(self, 'results_panels'):
                        for panel in self.results_panels:
                            if hasattr(panel, 'set_compare_box_font_size'):
                                panel.set_compare_box_font_size(compare_size)
            
            # Set Superlookup language dropdowns to match project languages
            if hasattr(self, 'lookup_tab') and self.lookup_tab and self.current_project:
                source_lang = self.current_project.source_lang
                target_lang = self.current_project.target_lang
                if source_lang or target_lang:
                    self.lookup_tab.set_project_languages(source_lang, target_lang)
                    self.log(f"‚úì Set Superlookup languages: {source_lang} ‚Üí {target_lang}")
            
            # Load project-specific settings (override general settings while project is active)
            if hasattr(self.current_project, 'general_settings_overrides') and self.current_project.general_settings_overrides:
                project_settings = self.current_project.general_settings_overrides
                
                # Override general settings with project-specific ones
                if 'auto_center_active_segment' in project_settings:
                    self.auto_center_active_segment = project_settings['auto_center_active_segment']
                    self.log(f"‚úì Project override: auto-center = {self.auto_center_active_segment}")
                
                if 'auto_propagate_exact_matches' in project_settings:
                    self.auto_propagate_exact_matches = project_settings['auto_propagate_exact_matches']
                    self.log(f"‚úì Project override: auto-propagate = {self.auto_propagate_exact_matches}")
                
                if 'auto_insert_100_percent_matches' in project_settings:
                    self.auto_insert_100_percent_matches = project_settings['auto_insert_100_percent_matches']
                    self.log(f"‚úì Project override: auto-insert 100% = {self.auto_insert_100_percent_matches}")
                
                if 'auto_confirm_100_percent_matches' in project_settings:
                    self.auto_confirm_100_percent_matches = project_settings['auto_confirm_100_percent_matches']
                    self.log(f"‚úì Project override: auto-confirm 100% = {self.auto_confirm_100_percent_matches}")
                
                if 'enable_termbase_grid_highlighting' in project_settings:
                    self.enable_termbase_grid_highlighting = project_settings['enable_termbase_grid_highlighting']
                    self.log(f"‚úì Project override: termbase highlighting = {self.enable_termbase_grid_highlighting}")
                
                if 'precision_scroll_divisor' in project_settings:
                    self.precision_scroll_divisor = project_settings['precision_scroll_divisor']
                    self.log(f"‚úì Project override: precision scroll = {self.precision_scroll_divisor}")
                
                if 'termbase_display_order' in project_settings:
                    self.termbase_display_order = project_settings['termbase_display_order']
                
                if 'termbase_hide_shorter_matches' in project_settings:
                    self.termbase_hide_shorter_matches = project_settings['termbase_hide_shorter_matches']
                
                if 'enable_smart_word_selection' in project_settings:
                    self.enable_smart_word_selection = project_settings['enable_smart_word_selection']
                
                if 'enable_sound_effects' in project_settings:
                    self.enable_sound_effects = project_settings['enable_sound_effects']
                    self.log(f"‚úì Project override: sound effects = {self.enable_sound_effects}")
                
                if 'sound_effects_map' in project_settings:
                    self.sound_effects_map = project_settings['sound_effects_map']
                    self.log(f"‚úì Project override: sound effects map loaded")
            
            # Update scratchpad with project's private notes
            self._update_scratchpad_for_project()
            
            self.log(f"‚úì Loaded project: {self.current_project.name} ({len(self.current_project.segments)} segments)")

            
            # Start background batch processing of termbase matches for all segments
            # This pre-fills the cache while user works on the project
            self._start_termbase_batch_worker()
            
            # Start prefetch worker for first 50 segments (instant switching like memoQ)
            if len(self.current_project.segments) > 0:
                prefetch_ids = [seg.id for seg in self.current_project.segments[:50]]
                self._start_prefetch_worker(prefetch_ids)
            
        except UnicodeDecodeError as e:
            error_msg = (
                f"Failed to load project - file encoding error:\n\n"
                f"{str(e)}\n\n"
                f"The project file may be corrupted or saved with an incompatible encoding.\n"
                f"This can happen if the file was edited outside Supervertaler.\n\n"
                f"Try opening the file in a text editor and re-saving it as UTF-8."
            )
            QMessageBox.critical(self, "Encoding Error", error_msg)
            self.log(f"‚úó Encoding error loading project: {e}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load project:\n{str(e)}")
            self.log(f"‚úó Error loading project: {e}")

    def _build_termbase_index(self):
        """
        Build in-memory index of ALL terms from activated termbases (v1.9.182).

        This is called ONCE on project load and replaces thousands of per-word
        database queries with a single bulk load + fast in-memory lookups.

        Performance: Reduces 349-segment termbase search from 365 seconds to <1 second.
        """
        import re
        import time
        start_time = time.time()

        if not self.current_project or not hasattr(self, 'db_manager') or not self.db_manager:
            return

        project_id = self.current_project.id if hasattr(self.current_project, 'id') else None

        # Query ALL terms from activated termbases in ONE query
        # This replaces ~17,500 individual queries (349 segments √ó 50 words each)
        query = """
            SELECT
                t.id, t.source_term, t.target_term, t.termbase_id, t.priority,
                t.domain, t.notes, t.project, t.client, t.forbidden,
                tb.is_project_termbase, tb.name as termbase_name,
                COALESCE(ta.priority, tb.ranking) as ranking
            FROM termbase_terms t
            LEFT JOIN termbases tb ON CAST(t.termbase_id AS INTEGER) = tb.id
            LEFT JOIN termbase_activation ta ON ta.termbase_id = tb.id
                AND ta.project_id = ? AND ta.is_active = 1
            WHERE (ta.is_active = 1 OR tb.is_project_termbase = 1)
        """

        new_index = []
        try:
            self.db_manager.cursor.execute(query, [project_id or 0])
            rows = self.db_manager.cursor.fetchall()

            for row in rows:
                source_term = row[1]  # source_term
                if not source_term:
                    continue

                source_term_lower = source_term.lower().strip()
                if len(source_term_lower) < 2:
                    continue

                # Pre-compile regex pattern for word-boundary matching
                # This avoids recompiling the same pattern thousands of times
                try:
                    # Handle terms with punctuation differently
                    if any(c in source_term_lower for c in '.%,/-'):
                        pattern = re.compile(r'(?<!\w)' + re.escape(source_term_lower) + r'(?!\w)')
                    else:
                        pattern = re.compile(r'\b' + re.escape(source_term_lower) + r'\b')
                except re.error:
                    # If regex fails, use simple substring matching
                    pattern = None

                new_index.append({
                    'term_id': row[0],
                    'source_term': source_term,
                    'source_term_lower': source_term_lower,
                    'target_term': row[2],
                    'termbase_id': row[3],
                    'priority': row[4],
                    'domain': row[5],
                    'notes': row[6],
                    'project': row[7],
                    'client': row[8],
                    'forbidden': row[9],
                    'is_project_termbase': row[10],
                    'termbase_name': row[11],
                    'ranking': row[12],
                    'pattern': pattern,  # Pre-compiled regex
                })

            # Sort by term length (longest first) for better phrase matching
            new_index.sort(key=lambda x: len(x['source_term_lower']), reverse=True)

            # Thread-safe update of the index
            with self.termbase_index_lock:
                self.termbase_index = new_index

            elapsed = time.time() - start_time
            self.log(f"‚úÖ Built termbase index: {len(new_index)} terms in {elapsed:.2f}s")

        except Exception as e:
            self.log(f"‚ùå Failed to build termbase index: {e}")
            import traceback
            self.log(traceback.format_exc())

    def _search_termbase_in_memory(self, source_text: str) -> dict:
        """
        Search termbase using in-memory index (v1.9.182).

        This replaces _search_termbases_thread_safe() for batch operations.
        Instead of N database queries (one per word), we do:
        - 1 pass through the index (typically ~1000 terms)
        - Fast string 'in' check + pre-compiled regex validation

        Performance: <1ms per segment vs 1+ second per segment.
        """
        if not source_text:
            return {}

        with self.termbase_index_lock:
            if not self.termbase_index:
                return {}
            index = self.termbase_index  # Local reference for thread safety

        source_lower = source_text.lower()
        matches = {}

        for term in index:
            term_lower = term['source_term_lower']

            # Quick substring check first (very fast, implemented in C)
            if term_lower not in source_lower:
                continue

            # Word boundary validation using pre-compiled pattern
            pattern = term.get('pattern')
            if pattern:
                if not pattern.search(source_lower):
                    continue

            # Term matches! Add to results
            term_id = term['term_id']
            matches[term_id] = {
                'source': term['source_term'],
                'translation': term['target_term'],
                'term_id': term_id,
                'termbase_id': term['termbase_id'],
                'termbase_name': term['termbase_name'],
                'priority': term['priority'],
                'ranking': term['ranking'],
                'is_project_termbase': term['is_project_termbase'],
                'forbidden': term['forbidden'],
                'domain': term['domain'],
                'notes': term['notes'],
                'project': term['project'],
                'client': term['client'],
            }

        return matches

    def _start_termbase_batch_worker(self):
        """
        Start background thread to batch-process termbase matches for all segments.
        This pre-fills the cache while the user works on the project.
        """
        if not self.current_project or len(self.current_project.segments) == 0:
            return

        # Build in-memory termbase index FIRST (v1.9.182)
        # This is the key optimization: load all terms once, then do fast in-memory lookups
        self._build_termbase_index()

        # üß™ EXPERIMENTAL: Skip batch worker if cache kill switch is enabled
        if getattr(self, 'disable_all_caches', False):
            self.log("üß™ Termbase batch worker SKIPPED (caches disabled)")
            return

        # Stop any existing worker thread
        self.termbase_batch_stop_event.set()
        if self.termbase_batch_worker_thread and self.termbase_batch_worker_thread.is_alive():
            self.log("‚èπÔ∏è  Stopping existing termbase batch worker...")
            self.termbase_batch_worker_thread.join(timeout=2)

        # Reset stop event for new worker
        self.termbase_batch_stop_event.clear()

        # Start new background worker thread
        segment_count = len(self.current_project.segments)
        self.log(f"üîÑ Starting background termbase batch processor for {segment_count} segments...")
        
        self.termbase_batch_worker_thread = threading.Thread(
            target=self._termbase_batch_worker_run,
            args=(self.current_project.segments,),
            daemon=True  # Daemon thread - won't prevent program exit
        )
        self.termbase_batch_worker_thread.start()
    
    def _termbase_batch_worker_run(self, segments):
        """
        Background worker thread: process all segments and populate termbase cache.
        Runs in separate thread to not block UI.

        v1.9.182: Now uses in-memory termbase index for 1000x faster lookups.
        Old approach: 365 seconds for 349 segments (1 second/segment)
        New approach: <1 second for 349 segments (<3ms/segment)
        """
        if not segments:
            return

        try:
            processed = 0
            cached = 0
            with_matches = 0
            start_time = time.time()

            for segment in segments:
                # Check if stop event was signaled (user closed project or started new one)
                if self.termbase_batch_stop_event.is_set():
                    self.log(f"‚èπÔ∏è  Termbase batch worker stopped by user (processed {processed} segments)")
                    break

                segment_id = segment.id

                # Skip if already in cache (thread-safe check)
                with self.termbase_cache_lock:
                    if segment_id in self.termbase_cache:
                        cached += 1
                        continue

                # v1.9.182: Use in-memory index for instant lookup (no database queries!)
                try:
                    matches = self._search_termbase_in_memory(segment.source)

                    # Store in cache (thread-safe) - even empty results to avoid re-lookup
                    with self.termbase_cache_lock:
                        self.termbase_cache[segment_id] = matches

                    processed += 1
                    if matches:
                        with_matches += 1

                except Exception as e:
                    self.log(f"‚ùå Error processing segment {segment_id} in batch worker: {e}")
                    continue

            elapsed = time.time() - start_time
            total_cached = len(self.termbase_cache)
            rate = processed / elapsed if elapsed > 0 else 0
            self.log(f"‚úÖ Termbase batch worker complete: {processed} segments in {elapsed:.2f}s " +
                     f"({rate:.0f} seg/sec, {with_matches} with matches)")

        except Exception as e:
            self.log(f"‚ùå Termbase batch worker error: {e}")
            import traceback
            self.log(traceback.format_exc())
    
    def _search_termbases_thread_safe(self, source_text: str, cursor, source_lang: str = None, target_lang: str = None, project_id: int = None) -> Dict[str, str]:
        """
        Search termbases using a provided cursor (thread-safe for background threads).
        This method allows background workers to query the database without SQLite threading errors.

        Implements BIDIRECTIONAL matching: searches both source_term and target_term columns.
        When a match is found on target_term, source and target are swapped in the result.
        This matches memoQ/Trados behavior where a NL‚ÜíEN termbase also works for EN‚ÜíNL projects.

        Args:
            source_text: The source text to search for
            cursor: A database cursor from a thread-local connection
            source_lang: Source language code
            target_lang: Target language code
            project_id: Current project ID (required to filter by activated termbases)

        Returns:
            Dictionary of {term: translation} matches
        """
        if not source_text or not cursor:
            return {}

        try:
            # Convert language names to codes (match interactive search logic)
            source_lang_code = self._convert_language_to_code(source_lang) if source_lang else None
            target_lang_code = self._convert_language_to_code(target_lang) if target_lang else None

            words = source_text.split()
            source_text_lower = source_text.lower()
            matches: Dict[str, Dict] = {}

            import re

            for word in words:
                clean_word = word.strip('.,!?;:')
                if len(clean_word) < 2:
                    continue

                try:
                    # JOIN termbases AND termbase_activation to filter by activated termbases
                    # This matches the logic in database_manager.py search_termbases()
                    # BIDIRECTIONAL: Search both source_term (forward) and target_term (reverse)
                    # Using UNION to combine both directions
                    query = """
                        SELECT * FROM (
                            -- Forward match: search source_term
                            SELECT
                                t.id, t.source_term, t.target_term, t.termbase_id, t.priority,
                                t.domain, t.notes, t.project, t.client, t.forbidden,
                                tb.is_project_termbase, tb.name as termbase_name,
                                COALESCE(ta.priority, tb.ranking) as ranking,
                                'source' as match_direction
                            FROM termbase_terms t
                            LEFT JOIN termbases tb ON CAST(t.termbase_id AS INTEGER) = tb.id
                            LEFT JOIN termbase_activation ta ON ta.termbase_id = tb.id AND ta.project_id = ? AND ta.is_active = 1
                            WHERE LOWER(t.source_term) LIKE ?
                            AND (ta.is_active = 1 OR tb.is_project_termbase = 1)
                    """
                    params = [project_id if project_id else 0, f"%{clean_word.lower()}%"]

                    # Language filters for forward query
                    if source_lang_code:
                        query += " AND (t.source_lang = ? OR (t.source_lang IS NULL AND tb.source_lang = ?) OR (t.source_lang IS NULL AND tb.source_lang IS NULL))"
                        params.extend([source_lang_code, source_lang_code])
                    if target_lang_code:
                        query += " AND (t.target_lang = ? OR (t.target_lang IS NULL AND tb.target_lang = ?) OR (t.target_lang IS NULL AND tb.target_lang IS NULL))"
                        params.extend([target_lang_code, target_lang_code])

                    # Reverse match: search target_term, swap source/target in output
                    query += """
                            UNION ALL
                            -- Reverse match: search target_term, swap columns
                            SELECT
                                t.id, t.target_term as source_term, t.source_term as target_term,
                                t.termbase_id, t.priority,
                                t.domain, t.notes, t.project, t.client, t.forbidden,
                                tb.is_project_termbase, tb.name as termbase_name,
                                COALESCE(ta.priority, tb.ranking) as ranking,
                                'target' as match_direction
                            FROM termbase_terms t
                            LEFT JOIN termbases tb ON CAST(t.termbase_id AS INTEGER) = tb.id
                            LEFT JOIN termbase_activation ta ON ta.termbase_id = tb.id AND ta.project_id = ? AND ta.is_active = 1
                            WHERE LOWER(t.target_term) LIKE ?
                            AND (ta.is_active = 1 OR tb.is_project_termbase = 1)
                    """
                    params.extend([project_id if project_id else 0, f"%{clean_word.lower()}%"])

                    # Language filters for reverse query (swapped)
                    if source_lang_code:
                        # For reverse: source_lang filters target_lang column
                        query += " AND (t.target_lang = ? OR (t.target_lang IS NULL AND tb.target_lang = ?) OR (t.target_lang IS NULL AND tb.target_lang IS NULL))"
                        params.extend([source_lang_code, source_lang_code])
                    if target_lang_code:
                        # For reverse: target_lang filters source_lang column
                        query += " AND (t.source_lang = ? OR (t.source_lang IS NULL AND tb.source_lang = ?) OR (t.source_lang IS NULL AND tb.source_lang IS NULL))"
                        params.extend([target_lang_code, target_lang_code])

                    # Close UNION and limit
                    query += ") combined LIMIT 30"
                    cursor.execute(query, params)
                    results = cursor.fetchall()

                    for row in results:
                        # Uniform access (columns are already swapped for reverse matches)
                        source_term = row[1] if isinstance(row, tuple) else row['source_term']
                        target_term = row[2] if isinstance(row, tuple) else row['target_term']
                        match_direction = row[13] if isinstance(row, tuple) else row.get('match_direction', 'source')
                        if not source_term or not target_term:
                            continue

                        # Phrase-level validation with word boundaries (case-insensitive)
                        pattern = re.compile(r"\b" + re.escape(source_term.lower()) + r"\b")
                        if not pattern.search(source_text_lower):
                            continue

                        term_id = row[0] if isinstance(row, tuple) else row['id']
                        termbase_id = row[3] if isinstance(row, tuple) else row['termbase_id']
                        priority = row[4] if isinstance(row, tuple) else row['priority']
                        domain = row[5] if isinstance(row, tuple) else row['domain']
                        notes = row[6] if isinstance(row, tuple) else row['notes']
                        project = row[7] if isinstance(row, tuple) else row['project']
                        client = row[8] if isinstance(row, tuple) else row['client']
                        forbidden = row[9] if isinstance(row, tuple) else row['forbidden']
                        is_project_tb = row[10] if isinstance(row, tuple) else row['is_project_termbase']
                        termbase_name = row[11] if isinstance(row, tuple) else row['termbase_name']
                        ranking = row[12] if isinstance(row, tuple) else row.get('ranking', None)

                        existing = matches.get(source_term.strip())
                        # Deduplicate: keep numerically lowest ranking (highest priority)
                        # For project termbases, ranking is None so they always win
                        # Also prefer 'source' matches over 'target' matches when equal
                        if existing:
                            existing_ranking = existing.get('ranking', None)
                            existing_direction = existing.get('match_direction', 'source')
                            if is_project_tb:
                                # Project termbase always wins
                                pass
                            elif existing.get('is_project_termbase'):
                                # Existing is project termbase, skip this one
                                continue
                            elif existing_ranking is not None and ranking is not None:
                                # Both have rankings, keep lower (higher priority)
                                if existing_ranking < ranking:
                                    continue
                                elif existing_ranking == ranking:
                                    # Same ranking: prefer source match over target match
                                    if existing_direction == 'source' and match_direction == 'target':
                                        continue

                        matches[source_term.strip()] = {
                            'translation': target_term.strip(),
                            'term_id': term_id,
                            'termbase_id': termbase_id,
                            'priority': priority,  # Keep for backward compatibility
                            'ranking': ranking,  # NEW: termbase-level ranking
                            'domain': domain or '',
                            'notes': notes or '',
                            'project': project or '',
                            'client': client or '',
                            'forbidden': forbidden or False,
                            'is_project_termbase': bool(is_project_tb),
                            'termbase_name': termbase_name or '',
                            'target_synonyms': [],  # Will be populated below
                            'match_direction': match_direction  # Track if this was a reverse match
                        }

                        # Fetch synonyms for this term
                        # For reverse matches, fetch 'source' synonyms since they become targets
                        try:
                            synonym_lang = 'source' if match_direction == 'target' else 'target'
                            cursor.execute("""
                                SELECT synonym_text FROM termbase_synonyms
                                WHERE term_id = ? AND language = ? AND forbidden = 0
                            """, (term_id, synonym_lang))
                            synonym_rows = cursor.fetchall()
                            for syn_row in synonym_rows:
                                synonym = syn_row[0] if isinstance(syn_row, tuple) else syn_row['synonym_text']
                                if synonym:
                                    matches[source_term.strip()]['target_synonyms'].append(synonym)
                        except Exception:
                            pass  # Synonyms are optional, don't fail on error
                except Exception:
                    # Skip word on any error; continue with next word
                    continue

            return matches
        except Exception:
            return {}
    
    def _trigger_idle_prefetch(self, current_row: int):
        """
        Trigger prefetch for the next few segments while user is idle.
        Called after user stops typing (debounced) - uses their thinking time productively.
        
        This makes Ctrl+Enter feel INSTANT because matches are already cached.
        Also triggers PROACTIVE HIGHLIGHTING for upcoming segments with glossary matches.
        """
        import json

        if not self.current_project or current_row < 0:
            return
        
        try:
            # Prefetch next 5 segments (enough for fast workflow, not too many to waste resources)
            next_segment_ids = []
            already_cached_ids = []
            start_idx = current_row + 1
            end_idx = min(start_idx + 5, len(self.current_project.segments))

            for seg in self.current_project.segments[start_idx:end_idx]:
                # Check if already cached
                with self.translation_matches_cache_lock:
                    if seg.id not in self.translation_matches_cache:
                        next_segment_ids.append(seg.id)
                    else:
                        already_cached_ids.append(seg.id)

            # For already-cached segments, trigger proactive highlighting immediately
            # This handles the case where segments were cached earlier but not highlighted
            for seg_id in already_cached_ids:
                try:
                    with self.termbase_cache_lock:
                        termbase_raw = self.termbase_cache.get(seg_id, {})
                    if termbase_raw:
                        termbase_json = json.dumps(termbase_raw)
                        # Apply highlighting on main thread (we're already on main thread here)
                        self._apply_proactive_highlighting(seg_id, termbase_json)
                except Exception:
                    pass  # Silent failure for proactive highlighting
            
            if next_segment_ids:
                # Start prefetch in background (silent, no logging)
                self._start_prefetch_worker(next_segment_ids)
        except Exception:
            pass  # Silent failure - prefetch is optimization, not critical
    
    def _start_prefetch_worker(self, segment_ids):
        """
        Start background thread to prefetch TM/MT/LLM matches for given segments.
        This enables instant switching between segments without waiting for match lookups.
        """
        if not segment_ids:
            return
        
        # üß™ EXPERIMENTAL: Skip prefetch if cache kill switch is enabled
        if getattr(self, 'disable_all_caches', False):
            return
        
        # Stop any existing worker thread
        self.prefetch_stop_event.set()
        if self.prefetch_worker_thread and self.prefetch_worker_thread.is_alive():
            self.prefetch_worker_thread.join(timeout=2)
        
        # Reset stop event for new worker
        self.prefetch_stop_event.clear()
        
        # Start new background worker thread (silent - no logging)
        self.prefetch_worker_thread = threading.Thread(
            target=self._prefetch_worker_run,
            args=(segment_ids,),
            daemon=True  # Daemon thread - won't prevent program exit
        )
        self.prefetch_worker_thread.start()
    
    def _prefetch_worker_run(self, segment_ids):
        """
        Background worker: prefetch TM/MT/LLM matches for given segments.
        Runs in separate thread to avoid blocking UI.
        
        Creates its own database connection for thread-safe termbase lookups.
        Also emits signal to apply proactive highlighting on the main thread.
        """
        import sqlite3
        import json
        
        # Create thread-local database connection for termbase searches
        thread_db_cursor = None
        thread_db_connection = None
        try:
            if hasattr(self, 'db_manager') and self.db_manager and hasattr(self.db_manager, 'db_path'):
                thread_db_connection = sqlite3.connect(self.db_manager.db_path)
                thread_db_connection.row_factory = sqlite3.Row
                thread_db_cursor = thread_db_connection.cursor()
        except Exception:
            pass  # Continue without thread-local connection - will use cache only
        
        try:
            for idx, segment_id in enumerate(segment_ids):
                # Check stop signal
                if self.prefetch_stop_event.is_set():
                    return
                
                # Check if already cached
                with self.translation_matches_cache_lock:
                    if segment_id in self.translation_matches_cache:
                        continue  # Already cached, skip
                
                # Find segment
                segment = None
                if self.current_project:
                    for seg in self.current_project.segments:
                        if seg.id == segment_id:
                            segment = seg
                            break
                
                if not segment:
                    continue
                
                # Fetch TM/termbase matches (pass cursor for thread-safe termbase lookups)
                matches = self._fetch_all_matches_for_segment(segment, thread_db_cursor)

                # Count matches for logging and proactive highlighting
                tm_count = len(matches.get("TM", []))
                tb_count = len(matches.get("Termbases", []))
                mt_count = len(matches.get("MT", []))
                llm_count = len(matches.get("LLM", []))
                total_matches = tm_count + tb_count + mt_count + llm_count
                
                # Only cache results if we found something
                # Don't cache empty results - let main thread do fresh lookup
                if total_matches > 0:
                    with self.translation_matches_cache_lock:
                        self.translation_matches_cache[segment_id] = matches

                # PROACTIVE HIGHLIGHTING: Emit signal to apply highlighting on main thread
                # This makes upcoming segments show their glossary matches immediately
                if tb_count > 0:
                    try:
                        # Extract raw termbase matches from cache for highlighting
                        with self.termbase_cache_lock:
                            termbase_raw = self.termbase_cache.get(segment_id, {})

                        if termbase_raw:
                            # Convert to JSON for thread-safe signal transfer
                            termbase_json = json.dumps(termbase_raw)
                            # Emit signal - will be handled on main thread
                            self._proactive_highlight_signal.emit(segment_id, termbase_json)
                    except Exception:
                        pass  # Silent fail for proactive highlighting
            
        except Exception as e:
            self.log(f"Error in prefetch worker: {e}")
        
        finally:
            # Close thread-local database connection
            if thread_db_cursor:
                try:
                    thread_db_cursor.close()
                except:
                    pass
            if thread_db_connection:
                try:
                    thread_db_connection.close()
                except:
                    pass
    
    def _fetch_all_matches_for_segment(self, segment, thread_db_cursor=None):
        """
        Fetch TM, MT, and LLM matches for a single segment.
        Used by prefetch worker. Returns matches_dict with all match types.
        
        Args:
            segment: The segment to fetch matches for
            thread_db_cursor: Optional thread-local database cursor for termbase searches.
                              If provided and segment not in termbase_cache, will do direct lookup.
        """
        from modules.translation_results_panel import TranslationMatch
        
        matches_dict = {
            "LLM": [],
            "NT": [],
            "MT": [],
            "TM": [],
            "Termbases": [],
            "NonTrans": []  # Non-translatables
        }
        
        # Get project languages
        source_lang = getattr(self.current_project, 'source_lang', None) if self.current_project else None
        target_lang = getattr(self.current_project, 'target_lang', None) if self.current_project else None
        
        if not source_lang or not target_lang:
            return matches_dict
        
        # Convert language names to codes
        source_lang_code = self._convert_language_to_code(source_lang)
        target_lang_code = self._convert_language_to_code(target_lang)
        
        # 1. TM matches - SKIP in prefetch worker (TM search not thread-safe)
        # TM will be fetched on-demand when user navigates to segment
        pass
        
        # 2. MT matches (if enabled)
        if self.enable_mt_matching:
            # Use the same MT fetching logic as the main search
            # For now, we'll skip MT in prefetch to avoid rate limiting
            # MT will still be fetched on-demand when user clicks
            pass
        
        # 3. LLM matches (if enabled)
        if self.enable_llm_matching:
            # Skip LLM in prefetch - too expensive and slow
            # LLM will still be fetched on-demand when user clicks
            pass
        
        # 4. Termbase matches - try cache first, then direct lookup if cursor provided
        termbase_matches_raw = None
        
        with self.termbase_cache_lock:
            if segment.id in self.termbase_cache:
                termbase_matches_raw = self.termbase_cache[segment.id]
        
        # If not in cache and we have a thread-local cursor, do direct lookup
        if termbase_matches_raw is None and thread_db_cursor is not None:
            try:
                # Get project_id for activation filtering
                current_project_id = None
                if hasattr(self, 'current_project') and self.current_project and hasattr(self.current_project, 'id'):
                    current_project_id = self.current_project.id
                
                termbase_matches_raw = self._search_termbases_thread_safe(
                    segment.source,
                    thread_db_cursor,
                    source_lang=source_lang,
                    target_lang=target_lang,
                    project_id=current_project_id
                )
                # Also populate the termbase cache for future use
                if termbase_matches_raw:
                    with self.termbase_cache_lock:
                        self.termbase_cache[segment.id] = termbase_matches_raw
            except Exception:
                pass  # Silently continue
        
        # Convert raw termbase matches to TranslationMatch objects
        if termbase_matches_raw:
            for term_id, match_info in termbase_matches_raw.items():
                # Extract source term, translation, ranking, and other metadata from match_info
                if isinstance(match_info, dict):
                    source_term = match_info.get('source', '')
                    target_term = match_info.get('translation', '')
                    priority = match_info.get('priority', 50)  # Keep for backward compatibility
                    ranking = match_info.get('ranking', None)  # NEW: termbase ranking
                    forbidden = match_info.get('forbidden', False)
                    is_project_termbase = match_info.get('is_project_termbase', False)
                    termbase_name = match_info.get('termbase_name', 'Default')
                else:
                    # Backward compatibility: if just string (shouldn't happen with new code)
                    source_term = str(term_id)
                    target_term = match_info
                    priority = 50
                    ranking = None
                    forbidden = False
                    is_project_termbase = False
                    termbase_name = 'Default'
                
                match_obj = TranslationMatch(
                    source=source_term,
                    target=target_term,
                    relevance=95,
                    metadata={
                        'termbase_name': termbase_name,
                        'priority': priority,  # Keep for backward compatibility
                        'ranking': ranking,  # NEW: termbase-level ranking
                        'forbidden': forbidden,
                        'is_project_termbase': is_project_termbase,
                        'term_id': match_info.get('term_id') if isinstance(match_info, dict) else None,
                        'termbase_id': match_info.get('termbase_id') if isinstance(match_info, dict) else None,
                        'domain': match_info.get('domain', '') if isinstance(match_info, dict) else '',
                        'notes': match_info.get('notes', '') if isinstance(match_info, dict) else '',
                        'project': match_info.get('project', '') if isinstance(match_info, dict) else '',
                        'client': match_info.get('client', '') if isinstance(match_info, dict) else '',
                        'target_synonyms': match_info.get('target_synonyms', []) if isinstance(match_info, dict) else []
                    },
                    match_type='Termbase',
                    compare_source=source_term,
                    provider_code='TB'
                )
                matches_dict["Termbases"].append(match_obj)
        
        return matches_dict
    
    def stop_prefetch_worker(self):
        """Stop the background prefetch worker gracefully"""
        if self.prefetch_worker_thread and self.prefetch_worker_thread.is_alive():
            self.log("‚èπÔ∏è  Stopping prefetch worker...")
            self.prefetch_stop_event.set()
            self.prefetch_worker_thread.join(timeout=2)
            self.log("‚úì Prefetch worker stopped")
    
    def stop_termbase_batch_worker(self):
        """Stop the background termbase batch worker gracefully"""
        if self.termbase_batch_worker_thread and self.termbase_batch_worker_thread.is_alive():
            self.log("‚èπÔ∏è  Stopping termbase batch worker...")
            self.termbase_batch_stop_event.set()
            self.termbase_batch_worker_thread.join(timeout=2)
            self.log("‚úì Termbase batch worker stopped")
    
    def save_segment_to_activated_tms(self, source: str, target: str):
        """
        Save segment to all writable TMs for current project.

        Note: Uses get_writable_tm_ids() which checks the Write checkbox (read_only=0),
        NOT get_active_tm_ids() which checks the Read checkbox (is_active=1).

        Respects tm_save_mode setting:
        - 'latest': Overwrites existing entries with same source (keeps only newest translation)
        - 'all': Keeps all translations with different targets (default SQLite behavior)

        Args:
            source: Source text
            target: Target text
        """
        if not self.current_project:
            return

        if not hasattr(self.current_project, 'source_lang') or not hasattr(self.current_project, 'target_lang'):
            return

        # Get WRITABLE TM IDs for this project (Write checkbox enabled)
        tm_ids = []

        if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr:
            if hasattr(self, 'current_project') and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None

                if project_id:
                    # Use get_writable_tm_ids() to find TMs with Write enabled
                    tm_ids = self.tm_metadata_mgr.get_writable_tm_ids(project_id)
                else:
                    self.log(f"‚ö†Ô∏è Cannot save to TM: project has no 'id' attribute!")
            else:
                self.log(f"‚ö†Ô∏è Cannot save to TM: No current project loaded!")
        else:
            self.log(f"‚ö†Ô∏è Cannot save to TM: TM metadata manager not available!")

        # If no TMs have Write enabled, skip saving
        if not tm_ids:
            self.log("‚ö†Ô∏è No TMs with Write enabled - segment not saved to TM.")
            self.log(f"   - To fix: Go to Resources > Translation Memories > TM List and enable the Write checkbox")
            return

        # Check TM save mode: 'latest' = overwrite, 'all' = keep all variants
        overwrite_mode = getattr(self, 'tm_save_mode', 'latest') == 'latest'

        # Save to each writable TM
        saved_count = 0
        for tm_id in tm_ids:
            try:
                self.db_manager.add_translation_unit(
                    source=source,
                    target=target,
                    source_lang=self.current_project.source_lang,
                    target_lang=self.current_project.target_lang,
                    tm_id=tm_id,
                    overwrite=overwrite_mode
                )
                saved_count += 1
            except Exception as e:
                self.log(f"‚ö†Ô∏è Could not save to TM '{tm_id}': {e}")

        if saved_count > 0:
            mode_note = " (overwrite)" if overwrite_mode else ""
            msg = f"üíæ Saved segment to {saved_count} TM(s){mode_note}"
            self._queue_tm_save_log(msg)
            # NOTE: Removed cache invalidation here - it was destroying batch worker's cache
            # on every Ctrl+Enter, making navigation extremely slow. The small chance of
            # seeing stale TM matches is far less important than responsive navigation.
    
    def invalidate_translation_cache(self, smart_invalidation=True):
        """
        Invalidate prefetch cache when TM/Termbase is updated.
        
        Args:
            smart_invalidation: If True, only clear future segments (keeps already-seen segments cached).
                               If False, clear entire cache.
        
        Smart mode: When translator saves segment N, only clears cache for segments > N.
        This way, going backwards still uses cache, but going forward gets fresh TM matches.
        """
        with self.translation_matches_cache_lock:
            if not smart_invalidation:
                # Full invalidation (e.g., termbase import, bulk TM import)
                cache_size = len(self.translation_matches_cache)
                if cache_size > 0:
                    self.translation_matches_cache.clear()
                    self.log(f"üîÑ Full cache invalidated ({cache_size} segments cleared)")
            else:
                # Smart invalidation: Only clear segments ahead of current position
                if hasattr(self, 'table') and self.table:
                    current_row = self.table.currentRow()
                    if current_row >= 0 and self.current_project:
                        # Clear cache for all segments AFTER current position
                        segments_to_clear = []
                        for seg in self.current_project.segments[current_row + 1:]:
                            if seg.id in self.translation_matches_cache:
                                segments_to_clear.append(seg.id)
                        
                        for seg_id in segments_to_clear:
                            del self.translation_matches_cache[seg_id]
                        
                        if segments_to_clear:
                            self.log(f"üîÑ Smart cache: cleared {len(segments_to_clear)} future segments (keeping past segments cached)")
                else:
                    # Fallback: full clear if we can't determine position
                    cache_size = len(self.translation_matches_cache)
                    if cache_size > 0:
                        self.translation_matches_cache.clear()
                        self.log(f"üîÑ Cache invalidated ({cache_size} segments)")
    
    def save_project(self):
        """Save current project"""
        if not self.current_project:
            return
        
        if not self.project_file_path:
            self.save_project_as()
        else:
            self.save_project_to_file(self.project_file_path)
    
    def save_project_as(self):
        """Save project with new filename"""
        if not self.current_project:
            return

        file_path, _ = fdh.get_save_file_name(
            self,
            "Save Project As",
            "Supervertaler Projects (*.svproj);;All Files (*.*)"
        )

        if file_path:
            # Ensure .svproj extension
            if not file_path.lower().endswith('.svproj'):
                file_path += '.svproj'
            # Update project name to match the new filename
            new_name = Path(file_path).stem
            self.current_project.name = new_name

            self.save_project_to_file(file_path)
            self.project_file_path = file_path
            self.add_to_recent_projects(file_path)
    
    def save_project_to_file(self, file_path: str):
        """Save project to specified file"""
        try:
            self.current_project.modified = datetime.now().isoformat()
            
            # DEBUG: Log first 5 segments before saving
            self.log(f"üíæ DEBUG: Saving {len(self.current_project.segments)} segments")
            for i, seg in enumerate(self.current_project.segments[:7]):
                self.log(f"üíæ Seg {seg.id}: target='{seg.target[:50] if seg.target else 'EMPTY'}...', status={seg.status}")
            
            # Save prompt settings if prompt manager is available
            if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                # Unified prompt library - save active primary and attached prompts
                library = self.prompt_manager_qt.library
                self.current_project.prompt_settings = {
                    'active_primary_prompt_path': library.active_primary_prompt_path,
                    'attached_prompt_paths': library.attached_prompt_paths.copy() if library.attached_prompt_paths else [],
                    'mode': getattr(self.prompt_manager_qt, 'current_mode', 'single'),
                }
            
            # Save image/figure context folder path
            if hasattr(self, 'figure_context') and self.figure_context and self.figure_context.figure_context_folder:
                if not self.current_project.prompt_settings:
                    self.current_project.prompt_settings = {}
                self.current_project.prompt_settings['image_context_folder'] = self.figure_context.figure_context_folder
            
            # Save Image Extractor file list (DOCX files added for image extraction)
            if hasattr(self, 'image_extractor_file_list') and self.image_extractor_file_list:
                if not self.current_project.prompt_settings:
                    self.current_project.prompt_settings = {}
                extractor_files = [self.image_extractor_file_list.item(i).text() 
                                   for i in range(self.image_extractor_file_list.count())]
                if extractor_files:
                    self.current_project.prompt_settings['image_extractor_files'] = extractor_files
            
            # Save activated TM IDs and read_only status for this project
            if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and hasattr(self.current_project, 'id'):
                project_id = self.current_project.id
                if project_id:
                    activated_tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                    if not hasattr(self.current_project, 'tm_settings'):
                        self.current_project.tm_settings = {}
                    self.current_project.tm_settings['activated_tm_ids'] = activated_tm_ids or []
                    
                    # Save read_only status for each activated TM
                    tm_read_only_status = {}
                    all_tms = self.tm_metadata_mgr.get_all_tms()
                    for tm in all_tms:
                        if tm['tm_id'] in activated_tm_ids:
                            tm_read_only_status[tm['tm_id']] = tm.get('read_only', True)
                    self.current_project.tm_settings['tm_read_only_status'] = tm_read_only_status
            
            # Save results pane font sizes
            if hasattr(self, 'results_panels') and self.results_panels:
                from modules.translation_results_panel import CompactMatchItem, TranslationResultsPanel
                if not self.current_project.ui_settings:
                    self.current_project.ui_settings = {}
                if hasattr(CompactMatchItem, 'font_size_pt'):
                    self.current_project.ui_settings['results_match_font_size'] = CompactMatchItem.font_size_pt
                if hasattr(TranslationResultsPanel, 'compare_box_font_size'):
                    self.current_project.ui_settings['results_compare_font_size'] = TranslationResultsPanel.compare_box_font_size
            
            # Save activated termbase IDs and priorities for this project
            if hasattr(self, 'termbase_mgr') and self.termbase_mgr and hasattr(self.current_project, 'id'):
                project_id = self.current_project.id
                if project_id:
                    active_termbase_ids = self.termbase_mgr.get_active_termbase_ids(project_id)
                    if not hasattr(self.current_project, 'termbase_settings'):
                        self.current_project.termbase_settings = {}
                    self.current_project.termbase_settings['active_termbase_ids'] = active_termbase_ids or []
                    
                    # Also save priorities for each active termbase
                    termbase_priorities = {}
                    for tb_id in active_termbase_ids:
                        priority = self.termbase_mgr.get_termbase_priority(tb_id, project_id)
                        if priority is not None:
                            termbase_priorities[str(tb_id)] = priority
                    self.current_project.termbase_settings['termbase_priorities'] = termbase_priorities
            
            # Save spellcheck settings to project (spellcheck_settings is now properly initialized in dataclass)
            self.current_project.spellcheck_settings['enabled'] = self.spellcheck_enabled
            if hasattr(self, 'target_language'):
                self.current_project.spellcheck_settings['language'] = self.target_language
            
            # Save current general settings as project overrides (while project is active)
            # These will override general_settings.json when this project is loaded
            self.current_project.general_settings_overrides = {
                'auto_center_active_segment': self.auto_center_active_segment,
                'auto_propagate_exact_matches': self.auto_propagate_exact_matches,
                'auto_insert_100_percent_matches': self.auto_insert_100_percent_matches,
                'auto_confirm_100_percent_matches': self.auto_confirm_100_percent_matches,
                'enable_termbase_grid_highlighting': self.enable_termbase_grid_highlighting,
                'precision_scroll_divisor': self.precision_scroll_divisor,
                'termbase_display_order': self.termbase_display_order,
                'termbase_hide_shorter_matches': self.termbase_hide_shorter_matches,
                'enable_smart_word_selection': self.enable_smart_word_selection,
                'enable_sound_effects': self.enable_sound_effects,
                'sound_effects_map': getattr(self, 'sound_effects_map', {}),
            }
            
            # Save original DOCX path for structure-preserving export
            original_path = getattr(self, 'original_docx', None) or getattr(self, 'current_document_path', None)
            if original_path and os.path.exists(original_path):
                self.current_project.original_docx_path = original_path
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.current_project.to_dict(), f, indent=2, ensure_ascii=False)
            
            self.project_modified = False
            self.update_window_title()
            self.log(f"‚úì Saved project: {Path(file_path).name}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save project:\n{str(e)}")
            self.log(f"‚úó Error saving project: {e}")

    def restart_auto_backup_timer(self):
        """Restart the auto backup timer based on current settings"""
        from PyQt6.QtCore import QTimer
        from datetime import datetime

        # Stop existing timer if running
        if self.auto_backup_timer:
            self.auto_backup_timer.stop()
            self.auto_backup_timer = None

        # Load settings
        general_settings = self.load_general_settings()
        enabled = general_settings.get('enable_auto_backup', True)
        interval_minutes = general_settings.get('backup_interval_minutes', 5)

        if not enabled:
            self.log("Auto backup disabled")
            return

        # Create and start timer
        self.auto_backup_timer = QTimer()
        self.auto_backup_timer.timeout.connect(self.perform_auto_backup)
        interval_ms = interval_minutes * 60 * 1000  # Convert minutes to milliseconds
        self.auto_backup_timer.start(interval_ms)

        self.log(f"Auto backup enabled: every {interval_minutes} minute(s)")

    def perform_auto_backup(self):
        """Perform automatic backup of project and TMX"""
        from datetime import datetime
        from modules.tmx_generator import TMXGenerator

        # Check if there's a project to backup
        if not self.current_project or not self.project_file_path:
            return

        try:
            # Save project.json
            self.save_project_to_file(self.project_file_path)

            # Export TMX to same folder as project
            project_dir = Path(self.project_file_path).parent
            project_name = Path(self.project_file_path).stem
            tmx_file_path = project_dir / f"{project_name}_backup.tmx"

            # Prepare segments for TMX export
            source_segments = []
            target_segments = []

            for segment in self.current_project.segments:
                source_text = segment.source
                target_text = segment.target if segment.target else ""

                if source_text:
                    source_segments.append(source_text)
                    target_segments.append(target_text)

            if source_segments:
                # Generate and save TMX
                tmx_generator = TMXGenerator(log_callback=self.log)

                source_lang = self.current_project.source_lang or "en"
                target_lang = self.current_project.target_lang or "nl"

                tmx_tree = tmx_generator.generate_tmx(
                    source_segments=source_segments,
                    target_segments=target_segments,
                    source_lang=source_lang,
                    target_lang=target_lang
                )

                tmx_generator.save_tmx(tmx_tree, str(tmx_file_path))

            # Update last backup time
            self.last_backup_time = datetime.now()
            timestamp = self.last_backup_time.strftime("%H:%M:%S")

            self.log(f"üíæ Auto backup completed at {timestamp}: {Path(self.project_file_path).name} + {tmx_file_path.name}")

        except Exception as e:
            self.log(f"‚ö†Ô∏è Auto backup failed: {e}")

    def close_project(self):
        """Close current project"""
        if not self.current_project:
            QMessageBox.information(self, "No Project", "No project is currently open")
            return
        
        # Check for unsaved changes
        if self.project_modified:
            reply = QMessageBox.question(
                self, "Unsaved Changes",
                "Save current project before closing?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel
            )
            if reply == QMessageBox.StandardButton.Cancel:
                return
            elif reply == QMessageBox.StandardButton.Yes:
                self.save_project()
                # If save was cancelled or failed, project_modified will still be True
                if self.project_modified:
                    return
        
        # Stop background batch workers
        self.stop_termbase_batch_worker()
        self.stop_prefetch_worker()
        
        # Clear caches for this project
        self.termbase_cache.clear()
        self.translation_matches_cache.clear()
        
        # Clear project data
        self.current_project = None
        self.project_file_path = None
        self.project_modified = False
        
        # Clear the grid
        self.clear_grid()
        
        # Clear translation results in all panels
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                if hasattr(panel, 'clear_results'):
                    panel.clear_results()
                if hasattr(panel, 'tm_results_table'):
                    panel.tm_results_table.setRowCount(0)
                if hasattr(panel, 'termbase_results_table'):
                    panel.termbase_results_table.setRowCount(0)
        
        # Update window title
        self.update_window_title()
        
        self.log("‚úì Project closed")
    
    def update_recent_menu(self):
        """Update recent projects menu"""
        self.recent_menu.clear()
        
        recent_projects = self.load_recent_projects()
        
        if not recent_projects:
            no_recent = QAction("No recent projects", self)
            no_recent.setEnabled(False)
            self.recent_menu.addAction(no_recent)
            return
        
        # Add menu items for each recent project
        for i, project_info in enumerate(recent_projects[:self.MAX_RECENT_PROJECTS]):
            path = project_info['path']
            name = project_info['name']
            
            # Show relative path if in workspace, otherwise just filename
            try:
                rel_path = Path(path).relative_to(Path.cwd())
                display_name = f"{i+1}. {name} ({rel_path.parent})"
            except ValueError:
                display_name = f"{i+1}. {name}"
            
            action = QAction(display_name, self)
            action.setStatusTip(path)
            action.triggered.connect(lambda checked, p=path: self._load_recent_project_with_resize(p))
            self.recent_menu.addAction(action)
        
        # Add separator and "Clear Recent" option
        if recent_projects:
            self.recent_menu.addSeparator()
            clear_action = QAction("Clear Recent Projects", self)
            clear_action.triggered.connect(self.clear_recent_projects)
            self.recent_menu.addAction(clear_action)
    
    def _load_recent_project_with_resize(self, project_path: str):
        """Load a project from recent menu and auto-enable row resize"""
        self.load_project(project_path)
        # Auto-enable row resize after loading
        if hasattr(self, 'auto_resize_rows'):
            QTimer.singleShot(100, self.auto_resize_rows)  # Slight delay to ensure grid is fully loaded
    
    def add_to_recent_projects(self, file_path: str):
        """Add project to recent projects list"""
        if not file_path or not os.path.exists(file_path):
            return
        
        # Load existing recent projects
        recent_projects = self.load_recent_projects()
        
        # Create new entry
        new_entry = {
            'path': os.path.abspath(file_path),
            'name': self.current_project.name if self.current_project else Path(file_path).stem,
            'last_opened': datetime.now().isoformat()
        }
        
        # Remove if already exists (to move to top)
        recent_projects = [p for p in recent_projects if p['path'] != new_entry['path']]
        
        # Add to beginning
        recent_projects.insert(0, new_entry)
        
        # Keep only MAX_RECENT_PROJECTS
        recent_projects = recent_projects[:self.MAX_RECENT_PROJECTS]
        
        # Save back to file
        self.save_recent_projects(recent_projects)
        
        # Update menu and home display
        self.update_recent_menu()
        self.update_recent_projects_display()
    
    def load_recent_projects(self) -> List[Dict[str, str]]:
        """Load recent projects from file"""
        if not self.recent_projects_file.exists():
            return []
        
        try:
            # Try UTF-8 first, fall back to latin-1 if it fails
            try:
                with open(self.recent_projects_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
            except UnicodeDecodeError:
                self.log(f"‚ö† UTF-8 decoding failed for recent projects, trying latin-1...")
                with open(self.recent_projects_file, 'r', encoding='latin-1') as f:
                    data = json.load(f)
            
            # Handle both old dict format and new list format
            if isinstance(data, dict):
                # Old format: convert to list
                recent = []
                for key, value in data.items():
                    if isinstance(value, list):
                        # Extract path and name from old list format
                        for item in value:
                            if isinstance(item, dict):
                                recent.append(item)
                            else:
                                # String path
                                recent.append({
                                    'path': str(item),
                                    'name': Path(str(item)).stem,
                                    'last_opened': datetime.now().isoformat()
                                })
                    elif isinstance(value, str):
                        recent.append({
                            'path': value,
                            'name': Path(value).stem,
                            'last_opened': datetime.now().isoformat()
                        })
                return recent
            elif isinstance(data, list):
                # New format: already a list
                # Ensure all entries have required fields
                normalized = []
                for item in data:
                    if isinstance(item, dict) and 'path' in item:
                        # Ensure all required fields exist
                        if 'name' not in item:
                            item['name'] = Path(item['path']).stem
                        if 'last_opened' not in item:
                            item['last_opened'] = datetime.now().isoformat()
                        # Only include if file still exists
                        if os.path.exists(item['path']):
                            normalized.append(item)
                return normalized
            
            return []
        
        except Exception as e:
            self.log(f"Error loading recent projects: {e}")
            return []
    
    def save_recent_projects(self, recent_projects: List[Dict[str, str]]):
        """Save recent projects to file"""
        try:
            # Ensure directory exists
            self.user_data_path.mkdir(parents=True, exist_ok=True)
            
            with open(self.recent_projects_file, 'w', encoding='utf-8') as f:
                json.dump(recent_projects, f, indent=2, ensure_ascii=False)
        
        except Exception as e:
            self.log(f"Error saving recent projects: {e}")
    
    def update_recent_projects_display(self):
        """Update the recent projects display on the home screen"""
        if not hasattr(self, 'recent_projects_layout'):
            return
        
        # Clear existing widgets
        for i in reversed(range(self.recent_projects_layout.count())):
            item = self.recent_projects_layout.itemAt(i)
            if item and item.widget():
                item.widget().deleteLater()
        
        # Load recent projects
        recent_projects = self.load_recent_projects()
        
        if not recent_projects:
            no_recent = QLabel("No recent projects")
            no_recent.setStyleSheet("color: #888; font-style: italic; padding: 10px;")
            no_recent.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.recent_projects_layout.addWidget(no_recent)
            return
        
        # Add project buttons
        for project_info in recent_projects[:5]:  # Show max 5 on home screen
            path = project_info['path']
            name = project_info.get('name', Path(path).stem)
            
            btn = QPushButton(f"üìÑ {name}")
            btn.setStyleSheet("text-align: left; padding: 8px; border-radius: 3px;")
            btn.setCursor(Qt.CursorShape.PointingHandCursor)
            btn.clicked.connect(lambda checked, p=path: self.load_project(p))
            self.recent_projects_layout.addWidget(btn)
        
        self.recent_projects_layout.addStretch()
    
    def clear_recent_projects(self):
        """Clear all recent projects"""
        reply = QMessageBox.question(
            self,
            "Clear Recent Projects",
            "Are you sure you want to clear all recent projects?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.save_recent_projects([])
            self.update_recent_menu()
            if hasattr(self, 'recent_projects_layout'):
                self.update_recent_projects_display()
            self.log("Recent projects cleared")
    
    # ========================================================================
    # MEMOQ BILINGUAL DOCX IMPORT/EXPORT
    # ========================================================================
    
    def import_docx(self):
        """Import a monolingual DOCX document"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select DOCX File",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )

        if not file_path:
            return

        # Show import options dialog with Supercleaner option
        dialog = QDialog(self)
        dialog.setWindowTitle("Import DOCX Options")
        dialog.setMinimumWidth(500)

        layout = QVBoxLayout(dialog)

        # Info message
        info_label = QLabel(
            "You selected the Monolingual DOCX import workflow.\n\n"
            "Projects created with this option can be exported as standard formats "
            "(DOCX, plain text, etc.), but they cannot be exported as memoQ bilingual "
            "DOCX files. If you need memoQ round-tripping, use 'Import memoQ bilingual document'."
        )
        info_label.setWordWrap(True)
        layout.addWidget(info_label)

        layout.addSpacing(15)

        # Language pair selection
        lang_group = QGroupBox("Language Pair")
        lang_layout = QHBoxLayout(lang_group)
        
        # Common languages for translation
        languages = [
            ("English", "en"),
            ("Dutch", "nl"),
            ("German", "de"),
            ("French", "fr"),
            ("Spanish", "es"),
            ("Italian", "it"),
            ("Portuguese", "pt"),
            ("Polish", "pl"),
            ("Russian", "ru"),
            ("Chinese", "zh"),
            ("Japanese", "ja"),
            ("Korean", "ko"),
        ]
        
        source_label = QLabel("Source:")
        source_combo = QComboBox()
        for name, code in languages:
            source_combo.addItem(name, code)
        
        # Load last used languages from settings, or use current project, or default to English
        general_settings = self.load_general_settings()
        last_source = general_settings.get('last_import_source_lang', 
                                          self.current_project.source_lang if self.current_project else 'en')
        last_target = general_settings.get('last_import_target_lang',
                                          self.current_project.target_lang if self.current_project else 'nl')
        
        # Set source combo to last used language
        source_index = 0  # Default to English
        for i in range(source_combo.count()):
            if source_combo.itemData(i) == last_source:
                source_index = i
                break
        source_combo.setCurrentIndex(source_index)
        
        arrow_label = QLabel(" ‚Üí ")
        arrow_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        
        target_label = QLabel("Target:")
        target_combo = QComboBox()
        for name, code in languages:
            target_combo.addItem(name, code)
        
        # Set target combo to last used language
        target_index = 1  # Default to Dutch
        for i in range(target_combo.count()):
            if target_combo.itemData(i) == last_target:
                target_index = i
                break
        target_combo.setCurrentIndex(target_index)
        
        lang_layout.addWidget(source_label)
        lang_layout.addWidget(source_combo)
        lang_layout.addWidget(arrow_label)
        lang_layout.addWidget(target_label)
        lang_layout.addWidget(target_combo)
        lang_layout.addStretch()
        
        layout.addWidget(lang_group)

        layout.addSpacing(10)

        # Supercleaner option
        clean_checkbox = CheckmarkCheckBox("üßπ Clean document before import (Supercleaner)")
        clean_checkbox.setChecked(False)  # Default to disabled
        clean_checkbox.setToolTip(
            "Automatically clean the document before importing:\n"
            "‚Ä¢ Remove formatting issues and excessive tags\n"
            "‚Ä¢ Fix incorrect line breaks (Unbreaker)\n"
            "‚Ä¢ Remove excessive spaces\n"
            "‚Ä¢ Normalize fonts, colors, and sizes\n\n"
            "Recommended for OCR/PDF-converted documents"
        )
        layout.addWidget(clean_checkbox)

        layout.addSpacing(20)

        # Buttons
        button_layout = QHBoxLayout()
        ok_btn = QPushButton("Import")
        ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border: none; outline: none;")
        ok_btn.clicked.connect(dialog.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)

        button_layout.addStretch()
        button_layout.addWidget(cancel_btn)
        button_layout.addWidget(ok_btn)
        layout.addLayout(button_layout)

        # Show dialog
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Store selected languages for import
        self._import_source_lang = source_combo.currentData()
        self._import_target_lang = target_combo.currentData()
        
        # Save selected languages to settings for next time
        general_settings = self.load_general_settings()
        general_settings['last_import_source_lang'] = self._import_source_lang
        general_settings['last_import_target_lang'] = self._import_target_lang
        self.save_general_settings(general_settings)

        # Clean document if requested
        import_path = file_path
        if clean_checkbox.isChecked():
            self.log("üßπ Running Supercleaner on document before import...")
            try:
                from modules.supercleaner import clean_document_simple
                import tempfile
                import shutil

                # Create temp file for cleaned version
                temp_fd, temp_path = tempfile.mkstemp(suffix='.docx')
                os.close(temp_fd)

                # Clean the document
                stats = clean_document_simple(file_path, temp_path, quick_clean=True)

                self.log(f"‚úì Supercleaner complete:")
                self.log(f"  - Paragraphs processed: {stats['paragraphs_processed']}")
                self.log(f"  - Changes made: {stats['changes_made']}")
                for op in stats.get('operations', []):
                    self.log(f"  - {op}")

                import_path = temp_path

            except Exception as e:
                self.log(f"‚ö†Ô∏è Supercleaner error (importing original): {e}")
                QMessageBox.warning(
                    self,
                    "Supercleaner Warning",
                    f"Could not clean document, importing original:\n\n{str(e)}"
                )
                import_path = file_path

        self.import_docx_from_path(import_path)
    
    def import_docx_from_path(self, file_path):
        """Import a monolingual DOCX document from a given path"""
        try:
            self.log(f"Importing: {os.path.basename(file_path)}")
            
            # Import DOCX using the existing docx_handler
            if not hasattr(self, 'docx_handler'):
                from modules.docx_handler import DOCXHandler
                self.docx_handler = DOCXHandler()
            
            paragraphs = self.docx_handler.import_docx(file_path)
            self.original_docx = file_path
            
            # Segment paragraphs
            self.log("Segmenting text...")
            
            # Use simple segmenter if available, otherwise create segments from paragraphs
            if hasattr(self, 'segmenter'):
                segmented = self.segmenter.segment_paragraphs(paragraphs)
            else:
                # Simple fallback segmentation
                from modules.simple_segmenter import SimpleSegmenter
                segmenter = SimpleSegmenter()
                segmented = segmenter.segment_paragraphs(paragraphs)
            
            # Create new project with the imported segments
            from dataclasses import dataclass
            from typing import List, Dict, Any, Optional
            from datetime import datetime
            
            @dataclass
            class ImportedSegment:
                id: int
                source: str
                target: str = ""
                status: str = "untranslated"
                notes: str = ""
                para_id: Optional[int] = None
                is_table: bool = False
                table_info: Optional[tuple] = None
                style: str = "Normal"
                doc_position: int = 0
                type: str = "#"  # Default segment type
            
            # Convert segments
            imported_segments = []
            for seg_id, (para_id, text) in enumerate(segmented, 1):
                # Get paragraph info if available
                para_info = None
                if hasattr(self.docx_handler, '_get_para_info'):
                    para_info = self.docx_handler._get_para_info(para_id)
                
                is_table = False
                table_info = None
                style = "Normal"
                doc_position = para_id if para_id else seg_id
                
                if para_info:
                    style = para_info.style or "Normal"
                    doc_position = getattr(para_info, 'document_position', para_id)
                    if getattr(para_info, 'is_table_cell', False):
                        is_table = True
                        table_info = (
                            getattr(para_info, 'table_index', 0),
                            getattr(para_info, 'row_index', 0),
                            getattr(para_info, 'cell_index', 0)
                        )
                
                segment = ImportedSegment(
                    id=seg_id,
                    source=text,
                    target="",
                    status="untranslated",
                    notes="",
                    para_id=para_id,
                    is_table=is_table,
                    table_info=table_info,
                    style=style,
                    doc_position=doc_position
                )
                imported_segments.append(segment)
            
            # Convert ImportedSegment objects to proper Segment objects
            segments = []
            for imported_seg in imported_segments:
                segment = Segment(
                    id=imported_seg.id,
                    source=imported_seg.source,
                    target=imported_seg.target,
                    status=imported_seg.status,
                    notes=imported_seg.notes,
                    type=imported_seg.type,  # Use actual type from import
                    paragraph_id=imported_seg.para_id if imported_seg.para_id else 0,
                    style=imported_seg.style,  # CRITICAL: Preserve style for heading detection!
                    document_position=imported_seg.doc_position,
                    is_table_cell=imported_seg.is_table,
                    table_info=imported_seg.table_info
                )
                segments.append(segment)
            
            # Create new project using the proper Project class
            # Use user-selected languages from import dialog
            source_lang = getattr(self, '_import_source_lang', None) or 'en'
            target_lang = getattr(self, '_import_target_lang', None) or 'nl'
            
            project = Project(
                name=f"DOCX Import - {os.path.basename(file_path)}",
                source_lang=source_lang,
                target_lang=target_lang,
                segments=segments
            )
            
            # Reset project-type specific highlighting flags
            TagHighlighter._is_cafetran_project = False
            TagHighlighter._is_markdown_project = False
            
            # Set as current project and load into grid
            self.current_project = project
            self.current_document_path = file_path  # Store document path
            self.load_segments_to_grid()

            # Initialize TM for this project
            self.initialize_tm_database()
            
            # Deactivate all resources for new project, then auto-activate language-matching ones
            self._deactivate_all_resources_for_new_project()

            # Auto-resize rows for better initial display
            self.auto_resize_rows()

            # Update status
            self.log(f"‚úì Loaded {len(segments)} segments from {len(paragraphs)} paragraphs")
            self.log(f"üìç Project language pair: {project.source_lang.upper()} ‚Üí {project.target_lang.upper()}")
            self.update_window_title()  # Update window title to show project is loaded
            
            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)

            # Auto-generate markdown if enabled
            if hasattr(self, 'auto_generate_markdown') and self.auto_generate_markdown:
                if hasattr(self, 'prompt_manager_qt'):
                    self.prompt_manager_qt.generate_markdown_for_current_document()

            # Refresh AI Assistant context
            if hasattr(self, 'prompt_manager_qt'):
                self.prompt_manager_qt.refresh_context()
            
            QMessageBox.information(
                self, 
                "Import Complete", 
                f"Successfully imported {len(segments)} segments from:\n{os.path.basename(file_path)}\n\n"
                f"üìç Language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}"
            )
            
        except Exception as e:
            self.log(f"‚úó Import failed: {str(e)}")
            QMessageBox.critical(
                self, 
                "Import Error", 
                f"Failed to import DOCX:\n\n{str(e)}"
            )
    
    # ========================================================================
    # SIMPLE TEXT FILE IMPORT/EXPORT
    # ========================================================================
    
    def import_simple_txt(self):
        """
        Import a simple text file or Markdown file where each line is a source segment.
        
        This is the simplest possible import format:
        - Each line becomes one source segment
        - Empty lines are preserved as empty segments (for structure)
        - After translation, export produces a matching file with translations
        - Markdown files are imported as-is (syntax preserved for round-trip)
        """
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Text or Markdown File",
            "",
            "Text Files (*.txt *.md);;Markdown (*.md);;Plain Text (*.txt);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        # Show import options dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Import Text / Markdown File")
        dialog.setMinimumWidth(500)
        
        layout = QVBoxLayout(dialog)
        
        # Detect if it's a Markdown file
        is_markdown = file_path.lower().endswith('.md')
        
        # Info message
        if is_markdown:
            info_label = QLabel(
                "üìù <b>Markdown File Import</b><br><br>"
                "Each line in the file will become one source segment.<br>"
                "Markdown syntax (<b>**bold**</b>, <i>*italic*</i>, # headings, etc.) is preserved.<br>"
                "After translation, export will produce a matching Markdown file.<br><br>"
                "<b>Tip:</b> Keep Markdown syntax intact when translating!"
            )
        else:
            info_label = QLabel(
                "üìÑ <b>Simple Text File Import</b><br><br>"
                "Each line in the file will become one source segment.<br>"
                "After translation, you can export a matching file with translations.<br><br>"
                "Empty lines are preserved to maintain document structure."
            )
        info_label.setWordWrap(True)
        info_label.setTextFormat(Qt.TextFormat.RichText)
        layout.addWidget(info_label)
        
        layout.addSpacing(15)
        
        # Language pair selection
        lang_group = QGroupBox("Language Pair")
        lang_layout = QHBoxLayout(lang_group)
        
        # Common languages for translation
        languages = [
            ("English", "en"),
            ("Dutch", "nl"),
            ("German", "de"),
            ("French", "fr"),
            ("Spanish", "es"),
            ("Italian", "it"),
            ("Portuguese", "pt"),
            ("Polish", "pl"),
            ("Russian", "ru"),
            ("Chinese", "zh"),
            ("Japanese", "ja"),
            ("Korean", "ko"),
        ]
        
        source_label = QLabel("Source:")
        source_combo = QComboBox()
        for name, code in languages:
            source_combo.addItem(name, code)
        # Default to English as source
        source_combo.setCurrentIndex(0)
        
        arrow_label = QLabel(" ‚Üí ")
        arrow_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        
        target_label = QLabel("Target:")
        target_combo = QComboBox()
        for name, code in languages:
            target_combo.addItem(name, code)
        # Default to Dutch as target
        target_combo.setCurrentIndex(1)
        
        lang_layout.addWidget(source_label)
        lang_layout.addWidget(source_combo)
        lang_layout.addWidget(arrow_label)
        lang_layout.addWidget(target_label)
        lang_layout.addWidget(target_combo)
        lang_layout.addStretch()
        
        layout.addWidget(lang_group)
        
        layout.addSpacing(10)
        
        # Empty line handling option
        empty_checkbox = CheckmarkCheckBox("Skip empty lines (remove blank segments)")
        empty_checkbox.setChecked(False)  # Default: preserve empty lines
        empty_checkbox.setToolTip(
            "When checked, empty lines in the file will be skipped.\n"
            "When unchecked, empty lines become empty segments to preserve structure."
        )
        layout.addWidget(empty_checkbox)
        
        layout.addSpacing(20)
        
        # Buttons
        button_layout = QHBoxLayout()
        ok_btn = QPushButton("Import")
        ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border: none; outline: none;")
        ok_btn.clicked.connect(dialog.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(cancel_btn)
        button_layout.addWidget(ok_btn)
        layout.addLayout(button_layout)
        
        # Show dialog
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Store selected options
        source_lang = source_combo.currentData()
        target_lang = target_combo.currentData()
        skip_empty = empty_checkbox.isChecked()
        
        try:
            self.log(f"üìÑ Importing simple text file: {os.path.basename(file_path)}")
            
            # Read the file
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # Create segments from lines
            segments = []
            for line_num, line in enumerate(lines, 1):
                # Strip trailing newline but preserve the text
                text = line.rstrip('\r\n')
                
                # Skip empty lines if requested
                if skip_empty and not text.strip():
                    continue
                
                segment = Segment(
                    id=len(segments) + 1,
                    source=text,
                    target="",
                    status="untranslated",
                    notes="",
                    type="para",
                    paragraph_id=line_num,
                    document_position=line_num
                )
                segments.append(segment)
            
            if not segments:
                QMessageBox.warning(
                    self, "Empty File",
                    "The file contains no text to import."
                )
                return
            
            # Create new project
            project = Project(
                name=f"{'MD' if is_markdown else 'TXT'} Import - {os.path.basename(file_path)}",
                source_lang=source_lang,
                target_lang=target_lang,
                segments=segments
            )
            
            # Store original file path for export
            project.original_txt_path = file_path
            
            # Reset project-type specific highlighting flags
            TagHighlighter._is_cafetran_project = False
            TagHighlighter._is_markdown_project = is_markdown
            
            # Set as current project and load into grid
            self.current_project = project
            self.current_document_path = file_path
            self.load_segments_to_grid()
            
            # Initialize TM for this project
            self.initialize_tm_database()
            
            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)
            
            # Update status
            empty_count = sum(1 for seg in segments if not seg.source.strip())
            file_type = "Markdown file" if is_markdown else "text file"
            self.log(f"‚úì Loaded {len(segments)} lines from {file_type}")
            if is_markdown:
                self.log(f"  üìù Markdown syntax highlighting enabled")
            if empty_count > 0:
                self.log(f"  ({empty_count} empty lines preserved for structure)")
            self.log(f"üìç Project language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}")
            self.update_window_title()
            
            # Refresh AI Assistant context
            if hasattr(self, 'prompt_manager_qt'):
                self.prompt_manager_qt.refresh_context()
            
            QMessageBox.information(
                self,
                "Import Complete",
                f"Successfully imported {len(segments)} lines from:\n{os.path.basename(file_path)}\n\n"
                f"üìç Language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}"
            )
            
        except UnicodeDecodeError:
            # Try with different encodings
            self.log("‚ö†Ô∏è UTF-8 failed, trying other encodings...")
            for encoding in ['latin-1', 'cp1252', 'iso-8859-1']:
                try:
                    with open(file_path, 'r', encoding=encoding) as f:
                        lines = f.readlines()
                    self.log(f"‚úì Successfully read file with {encoding} encoding")
                    # Re-run import with this encoding
                    # (simplified - just create segments directly)
                    segments = []
                    for line_num, line in enumerate(lines, 1):
                        text = line.rstrip('\r\n')
                        if skip_empty and not text.strip():
                            continue
                        segment = Segment(
                            id=len(segments) + 1,
                            source=text,
                            target="",
                            status="untranslated",
                            notes="",
                            type="para",
                            paragraph_id=line_num,
                            document_position=line_num
                        )
                        segments.append(segment)
                    
                    if segments:
                        project = Project(
                            name=f"TXT Import - {os.path.basename(file_path)}",
                            source_lang=source_lang,
                            target_lang=target_lang,
                            segments=segments
                        )
                        project.original_txt_path = file_path
                        self.current_project = project
                        self.current_document_path = file_path
                        self.load_segments_to_grid()
                        self.initialize_tm_database()
                        self.log(f"‚úì Loaded {len(segments)} lines from text file")
                        self.update_window_title()
                        if hasattr(self, 'prompt_manager_qt'):
                            self.prompt_manager_qt.refresh_context()
                        QMessageBox.information(
                            self,
                            "Import Complete",
                            f"Successfully imported {len(segments)} lines from:\n{os.path.basename(file_path)}\n\n"
                            f"üìç Language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}\n"
                            f"üìù Encoding: {encoding}"
                        )
                        return
                except:
                    continue
            
            QMessageBox.critical(
                self,
                "Encoding Error",
                "Could not read the text file.\n\n"
                "The file may use an unsupported character encoding.\n"
                "Try saving the file as UTF-8 and importing again."
            )
            
        except Exception as e:
            self.log(f"‚úó Import failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Import Error",
                f"Failed to import text file:\n\n{str(e)}"
            )
    
    def export_simple_txt(self):
        """
        Export translations as a simple text file, one line per segment.
        
        The output file will have the exact same structure as the input:
        - Each segment becomes one line
        - Empty segments become empty lines
        - Target text is used (or source if no translation)
        """
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project with segments first")
                return
            
            segments = list(self.current_project.segments)
            
            # Check translation status
            translated_count = sum(1 for seg in segments if seg.target and seg.target.strip())
            total_count = len(segments)
            
            if translated_count == 0:
                QMessageBox.warning(
                    self, "No Translations",
                    "No translated segments found.\n\n"
                    "Please translate some segments before exporting."
                )
                return
            
            # Show export options dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("Export Simple Text File")
            dialog.setMinimumWidth(450)
            
            layout = QVBoxLayout(dialog)
            
            # Status info
            if translated_count < total_count:
                status_label = QLabel(
                    f"‚ö†Ô∏è <b>{translated_count} of {total_count}</b> segments are translated."
                )
                status_label.setTextFormat(Qt.TextFormat.RichText)
                status_label.setStyleSheet("color: #FF9800;")
            else:
                status_label = QLabel(
                    f"‚úÖ All <b>{total_count}</b> segments are translated."
                )
                status_label.setTextFormat(Qt.TextFormat.RichText)
                status_label.setStyleSheet("color: #4CAF50;")
            layout.addWidget(status_label)
            
            layout.addSpacing(10)
            
            # Options group
            options_group = QGroupBox("Untranslated Segments")
            options_layout = QVBoxLayout(options_group)
            
            # Radio buttons for handling untranslated
            use_source_radio = CheckmarkRadioButton("Use source text for untranslated segments")
            use_source_radio.setChecked(True)
            use_empty_radio = CheckmarkRadioButton("Leave untranslated segments empty")
            
            options_layout.addWidget(use_source_radio)
            options_layout.addWidget(use_empty_radio)
            layout.addWidget(options_group)
            
            layout.addSpacing(10)
            
            # Encoding option
            encoding_group = QGroupBox("File Encoding")
            encoding_layout = QHBoxLayout(encoding_group)
            
            encoding_combo = QComboBox()
            encoding_combo.addItem("UTF-8 (recommended)", "utf-8")
            encoding_combo.addItem("UTF-8 with BOM", "utf-8-sig")
            encoding_combo.addItem("Latin-1 (ISO-8859-1)", "latin-1")
            encoding_combo.addItem("Windows-1252", "cp1252")
            encoding_layout.addWidget(encoding_combo)
            encoding_layout.addStretch()
            layout.addWidget(encoding_group)
            
            layout.addSpacing(20)
            
            # Buttons
            button_layout = QHBoxLayout()
            ok_btn = QPushButton("Export")
            ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border: none; outline: none;")
            ok_btn.clicked.connect(dialog.accept)
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            
            button_layout.addStretch()
            button_layout.addWidget(cancel_btn)
            button_layout.addWidget(ok_btn)
            layout.addLayout(button_layout)
            
            if dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            # Get options
            use_source_fallback = use_source_radio.isChecked()
            encoding = encoding_combo.currentData()
            
            # Get save path
            default_name = ""
            if hasattr(self.current_project, 'original_txt_path') and self.current_project.original_txt_path:
                base = os.path.splitext(os.path.basename(self.current_project.original_txt_path))[0]
                default_name = f"{base}_translated.txt"
            elif self.current_project.name:
                default_name = self.current_project.name.replace(" ", "_") + "_translated.txt"
            
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export Simple Text File",
                default_name,
                "Text Files (*.txt);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            # Ensure .txt extension
            if not file_path.lower().endswith('.txt'):
                file_path += '.txt'
            
            # Build output lines
            output_lines = []
            for segment in segments:
                if segment.target and segment.target.strip():
                    # Use translation
                    output_lines.append(segment.target)
                elif use_source_fallback:
                    # Use source text as fallback
                    output_lines.append(segment.source)
                else:
                    # Leave empty
                    output_lines.append("")
            
            # Write file
            with open(file_path, 'w', encoding=encoding, newline='\n') as f:
                for line in output_lines:
                    f.write(line + '\n')
            
            self.log(f"‚úì Exported {len(segments)} lines to: {os.path.basename(file_path)}")
            self.log(f"  Encoding: {encoding}")
            
            QMessageBox.information(
                self,
                "Export Complete",
                f"Successfully exported {len(segments)} lines to:\n{os.path.basename(file_path)}\n\n"
                f"Translated: {translated_count} / {total_count} segments"
            )
            
        except Exception as e:
            self.log(f"‚úó Export failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Export Error",
                f"Failed to export text file:\n\n{str(e)}"
            )
    
    def export_for_ai(self):
        """
        Export segments in AI-readable [SEGMENT] format.
        
        Output format:
            [SEGMENT 0001]
            NL: Source text here
            EN: Target text here (or empty if not translated)
            
            [SEGMENT 0002]
            ...
        
        This format is designed for:
        - AI translation services (ChatGPT, Claude, etc.)
        - AI-assisted review and editing
        - Easy parsing and re-import
        """
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project with segments first")
                return
            
            segments = list(self.current_project.segments)
            
            # Get language codes
            source_lang = self.current_project.source_lang or "Source"
            target_lang = self.current_project.target_lang or "Target"
            
            # Convert to short codes (uppercase) for the format
            source_code = self._convert_language_to_code(source_lang).upper() if source_lang else "SRC"
            target_code = self._convert_language_to_code(target_lang).upper() if target_lang else "TGT"
            
            # Check translation status
            translated_count = sum(1 for seg in segments if seg.target and seg.target.strip())
            total_count = len(segments)
            
            # Show export options dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("Export for AI")
            dialog.setMinimumWidth(500)
            
            layout = QVBoxLayout(dialog)
            
            # Info label
            info_label = QLabel(
                "Export segments in a format optimized for AI systems.\n"
                "Each segment is numbered and labeled with language codes."
            )
            info_label.setWordWrap(True)
            layout.addWidget(info_label)
            
            layout.addSpacing(10)
            
            # Status info
            if translated_count > 0:
                status_label = QLabel(
                    f"üìä <b>{translated_count} of {total_count}</b> segments have translations."
                )
            else:
                status_label = QLabel(
                    f"üìä <b>{total_count}</b> segments (none translated yet)."
                )
            status_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(status_label)
            
            layout.addSpacing(10)
            
            # Language codes group
            lang_group = QGroupBox("Language Codes")
            lang_layout = QGridLayout(lang_group)
            
            lang_layout.addWidget(QLabel("Source:"), 0, 0)
            source_code_edit = QLineEdit(source_code)
            source_code_edit.setMaximumWidth(80)
            source_code_edit.setToolTip("Language code for source text (e.g., NL, EN, DE)")
            lang_layout.addWidget(source_code_edit, 0, 1)
            
            lang_layout.addWidget(QLabel("Target:"), 0, 2)
            target_code_edit = QLineEdit(target_code)
            target_code_edit.setMaximumWidth(80)
            target_code_edit.setToolTip("Language code for target text (e.g., EN, NL, FR)")
            lang_layout.addWidget(target_code_edit, 0, 3)
            
            lang_layout.setColumnStretch(4, 1)  # Push controls left
            layout.addWidget(lang_group)
            
            # Numbering options
            numbering_group = QGroupBox("Segment Numbering")
            numbering_layout = QGridLayout(numbering_group)
            
            numbering_layout.addWidget(QLabel("Start at:"), 0, 0)
            start_spin = QSpinBox()
            start_spin.setRange(1, 99999)
            start_spin.setValue(1)
            start_spin.setMaximumWidth(80)
            numbering_layout.addWidget(start_spin, 0, 1)
            
            numbering_layout.addWidget(QLabel("Zero padding:"), 0, 2)
            padding_spin = QSpinBox()
            padding_spin.setRange(1, 8)
            padding_spin.setValue(4)
            padding_spin.setMaximumWidth(60)
            padding_spin.setToolTip("Number of digits (4 = 0001, 0002...)")
            numbering_layout.addWidget(padding_spin, 0, 3)
            
            numbering_layout.setColumnStretch(4, 1)
            layout.addWidget(numbering_group)
            
            # Content options
            content_group = QGroupBox("Content Options")
            content_layout = QVBoxLayout(content_group)
            
            include_both_radio = CheckmarkRadioButton("Include both source and target (bilingual)")
            include_both_radio.setChecked(True)
            source_only_radio = CheckmarkRadioButton("Source only (for AI translation)")
            target_only_radio = CheckmarkRadioButton("Target only (translated segments)")
            
            content_layout.addWidget(include_both_radio)
            content_layout.addWidget(source_only_radio)
            content_layout.addWidget(target_only_radio)
            layout.addWidget(content_group)
            
            # Filter options
            filter_group = QGroupBox("Segment Filter")
            filter_layout = QVBoxLayout(filter_group)
            
            all_segments_radio = CheckmarkRadioButton("All segments")
            all_segments_radio.setChecked(True)
            untranslated_radio = CheckmarkRadioButton("Untranslated segments only (empty target)")
            translated_radio = CheckmarkRadioButton("Translated segments only (has target)")
            
            filter_layout.addWidget(all_segments_radio)
            filter_layout.addWidget(untranslated_radio)
            filter_layout.addWidget(translated_radio)
            layout.addWidget(filter_group)
            
            layout.addSpacing(10)
            
            # Preview
            preview_group = QGroupBox("Preview")
            preview_layout = QVBoxLayout(preview_group)
            preview_text = QTextEdit()
            preview_text.setReadOnly(True)
            preview_text.setMaximumHeight(120)
            preview_text.setStyleSheet("font-family: Consolas, monospace; font-size: 11px;")
            preview_layout.addWidget(preview_text)
            layout.addWidget(preview_group)
            
            def update_preview():
                src_code = source_code_edit.text().strip() or "SRC"
                tgt_code = target_code_edit.text().strip() or "TGT"
                start = start_spin.value()
                pad = padding_spin.value()
                
                # Use generic example text (not from current segment)
                sample_source = "Source text goes here..."
                sample_target = "Target text goes here..."
                
                if include_both_radio.isChecked():
                    preview = f"[SEGMENT {start:0{pad}d}]\n{src_code}: {sample_source}\n{tgt_code}: {sample_target}\n"
                elif source_only_radio.isChecked():
                    preview = f"[SEGMENT {start:0{pad}d}]\n{src_code}: {sample_source}\n"
                else:
                    preview = f"[SEGMENT {start:0{pad}d}]\n{tgt_code}: {sample_target}\n"
                
                preview_text.setPlainText(preview)
            
            # Connect signals for live preview
            source_code_edit.textChanged.connect(update_preview)
            target_code_edit.textChanged.connect(update_preview)
            start_spin.valueChanged.connect(update_preview)
            padding_spin.valueChanged.connect(update_preview)
            include_both_radio.toggled.connect(update_preview)
            source_only_radio.toggled.connect(update_preview)
            target_only_radio.toggled.connect(update_preview)
            
            update_preview()  # Initial preview
            
            layout.addSpacing(10)
            
            # Buttons
            button_layout = QHBoxLayout()
            ok_btn = QPushButton("Export")
            ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border: none; outline: none;")
            ok_btn.clicked.connect(dialog.accept)
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            
            button_layout.addStretch()
            button_layout.addWidget(cancel_btn)
            button_layout.addWidget(ok_btn)
            layout.addLayout(button_layout)
            
            if dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            # Get options
            src_code = source_code_edit.text().strip() or "SRC"
            tgt_code = target_code_edit.text().strip() or "TGT"
            start_at = start_spin.value()
            padding = padding_spin.value()
            
            # Determine content mode
            if source_only_radio.isChecked():
                content_mode = "source_only"
            elif target_only_radio.isChecked():
                content_mode = "target_only"
            else:
                content_mode = "bilingual"
            
            # Filter segments
            if untranslated_radio.isChecked():
                filtered_segments = [s for s in segments if not (s.target and s.target.strip())]
            elif translated_radio.isChecked():
                filtered_segments = [s for s in segments if s.target and s.target.strip()]
            else:
                filtered_segments = segments
            
            if not filtered_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments match the selected filter criteria."
                )
                return
            
            # Get save path
            default_name = ""
            if self.current_project.name:
                default_name = self.current_project.name.replace(" ", "_") + "_ai_format.txt"
            
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export for AI",
                default_name,
                "Text Files (*.txt);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            # Ensure .txt extension
            if not file_path.lower().endswith('.txt'):
                file_path += '.txt'
            
            # Build output
            output_lines = []
            segment_num = start_at
            
            for seg in filtered_segments:
                output_lines.append(f"[SEGMENT {segment_num:0{padding}d}]")
                
                if content_mode == "bilingual":
                    output_lines.append(f"{src_code}: {seg.source}")
                    output_lines.append(f"{tgt_code}: {seg.target or ''}")
                elif content_mode == "source_only":
                    output_lines.append(f"{src_code}: {seg.source}")
                else:  # target_only
                    output_lines.append(f"{tgt_code}: {seg.target or ''}")
                
                output_lines.append("")  # Blank line between segments
                segment_num += 1
            
            # Write file
            with open(file_path, 'w', encoding='utf-8', newline='\n') as f:
                f.write('\n'.join(output_lines))
            
            self.log(f"‚úì Exported {len(filtered_segments)} segments in AI format to: {os.path.basename(file_path)}")
            
            QMessageBox.information(
                self,
                "Export Complete",
                f"Successfully exported {len(filtered_segments)} segments to:\n{os.path.basename(file_path)}\n\n"
                f"Format: [SEGMENT XXXX] with {src_code}/{tgt_code} labels"
            )
            
        except Exception as e:
            self.log(f"‚úó Export for AI failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Export Error",
                f"Failed to export AI format:\n\n{str(e)}"
            )
    
    def export_bilingual_table_markdown(self):
        """Export current project segments as Markdown table (for AI systems)"""
        try:
            if not self.current_project or not self.current_project.segments:
                QMessageBox.warning(self, "No Project", "Please open a project with segments first")
                return
            
            segments = list(self.current_project.segments)
            
            # Get language names
            source_lang = self.current_project.source_lang or "Source"
            target_lang = self.current_project.target_lang or "Target"
            
            # Check translation status
            translated_count = sum(1 for seg in segments if seg.target and seg.target.strip())
            total_count = len(segments)
            
            # Show export options dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("Export as Markdown Table")
            dialog.setMinimumWidth(500)
            
            layout = QVBoxLayout(dialog)
            
            # Info label
            info_label = QLabel(
                "Export segments as a <b>Markdown table</b> optimized for AI systems.\n"
                "The table format renders beautifully in ChatGPT, Claude, and all AI chat interfaces."
            )
            info_label.setWordWrap(True)
            info_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(info_label)
            
            layout.addSpacing(10)
            
            # Status info
            status_label = QLabel(
                f"üìä <b>{translated_count} of {total_count}</b> segments have translations."
                if translated_count > 0
                else f"üìä <b>{total_count}</b> segments (none translated yet)."
            )
            status_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(status_label)
            
            layout.addSpacing(10)
            
            # Content options
            content_group = QGroupBox("Content Options")
            content_layout = QVBoxLayout(content_group)
            
            include_both_radio = CheckmarkRadioButton(f"Include both {source_lang} and {target_lang} (bilingual table)")
            include_both_radio.setChecked(True)
            source_only_radio = CheckmarkRadioButton(f"{source_lang} only (for AI translation)")
            target_only_radio = CheckmarkRadioButton(f"{target_lang} only (translated segments)")
            
            content_layout.addWidget(include_both_radio)
            content_layout.addWidget(source_only_radio)
            content_layout.addWidget(target_only_radio)
            layout.addWidget(content_group)
            
            # Filter options
            filter_group = QGroupBox("Segment Filter")
            filter_layout = QVBoxLayout(filter_group)
            
            all_segments_radio = CheckmarkRadioButton("All segments")
            all_segments_radio.setChecked(True)
            untranslated_radio = CheckmarkRadioButton("Untranslated segments only (empty target)")
            translated_radio = CheckmarkRadioButton("Translated segments only (has target)")
            
            filter_layout.addWidget(all_segments_radio)
            filter_layout.addWidget(untranslated_radio)
            filter_layout.addWidget(translated_radio)
            layout.addWidget(filter_group)
            
            layout.addSpacing(10)
            
            # Preview
            preview_group = QGroupBox("Preview")
            preview_layout = QVBoxLayout(preview_group)
            preview_text = QTextEdit()
            preview_text.setReadOnly(True)
            preview_text.setMaximumHeight(150)
            preview_text.setStyleSheet("font-family: Consolas, monospace; font-size: 10px;")
            preview_layout.addWidget(preview_text)
            layout.addWidget(preview_group)
            
            def update_preview():
                # Show preview with sample data
                if include_both_radio.isChecked():
                    preview = f"# Translation Project: {self.current_project.name or 'Untitled'}\n\n"
                    preview += f"| Segment | {source_lang} | {target_lang} |\n"
                    preview += "|---------|" + "-" * (len(source_lang) + 2) + "|" + "-" * (len(target_lang) + 2) + "|\n"
                    preview += "| 1 | Source text example... | Target text example... |\n"
                    preview += "| 2 | Another segment... | Translation here... |"
                elif source_only_radio.isChecked():
                    preview = f"# Translation Project: {self.current_project.name or 'Untitled'}\n\n"
                    preview += f"| Segment | {source_lang} |\n"
                    preview += "|---------|" + "-" * (len(source_lang) + 2) + "|\n"
                    preview += "| 1 | Source text example... |\n"
                    preview += "| 2 | Another segment... |"
                else:
                    preview = f"# Translation Project: {self.current_project.name or 'Untitled'}\n\n"
                    preview += f"| Segment | {target_lang} |\n"
                    preview += "|---------|" + "-" * (len(target_lang) + 2) + "|\n"
                    preview += "| 1 | Target text example... |\n"
                    preview += "| 2 | Translation here... |"
                
                preview_text.setPlainText(preview)
            
            # Connect signals for live preview
            include_both_radio.toggled.connect(update_preview)
            source_only_radio.toggled.connect(update_preview)
            target_only_radio.toggled.connect(update_preview)
            
            update_preview()  # Initial preview
            
            layout.addSpacing(10)
            
            # Buttons
            button_layout = QHBoxLayout()
            ok_btn = QPushButton("Export")
            ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border: none; outline: none;")
            ok_btn.clicked.connect(dialog.accept)
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            
            button_layout.addStretch()
            button_layout.addWidget(cancel_btn)
            button_layout.addWidget(ok_btn)
            layout.addLayout(button_layout)
            
            if dialog.exec() != QDialog.DialogCode.Accepted:
                return
            
            # Determine content mode
            if source_only_radio.isChecked():
                content_mode = "source_only"
            elif target_only_radio.isChecked():
                content_mode = "target_only"
            else:
                content_mode = "bilingual"
            
            # Filter segments
            if untranslated_radio.isChecked():
                filtered_segments = [s for s in segments if not (s.target and s.target.strip())]
            elif translated_radio.isChecked():
                filtered_segments = [s for s in segments if s.target and s.target.strip()]
            else:
                filtered_segments = segments
            
            if not filtered_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments match the selected filter criteria."
                )
                return
            
            # Get save path
            default_name = ""
            if self.current_project.name:
                default_name = self.current_project.name.replace(" ", "_") + "_table.md"
            
            file_path, _ = QFileDialog.getSaveFileName(
                self,
                "Export Markdown Table",
                default_name,
                "Markdown Files (*.md);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            # Ensure .md extension
            if not file_path.lower().endswith('.md'):
                file_path += '.md'
            
            # Build Markdown table
            output_lines = []
            output_lines.append(f"# Translation Project: {self.current_project.name or 'Untitled'}")
            output_lines.append("")
            output_lines.append(f"**Languages:** {source_lang} ‚Üí {target_lang}")
            output_lines.append(f"**Segments:** {len(filtered_segments)}")
            output_lines.append(f"**Exported:** {datetime.now().strftime('%Y-%m-%d %H:%M')}")
            output_lines.append("")
            
            # Table header
            if content_mode == "bilingual":
                output_lines.append(f"| Segment | {source_lang} | {target_lang} |")
                output_lines.append("|---------|" + "-" * (len(source_lang) + 2) + "|" + "-" * (len(target_lang) + 2) + "|")
            elif content_mode == "source_only":
                output_lines.append(f"| Segment | {source_lang} |")
                output_lines.append("|---------|" + "-" * (len(source_lang) + 2) + "|")
            else:  # target_only
                output_lines.append(f"| Segment | {target_lang} |")
                output_lines.append("|---------|" + "-" * (len(target_lang) + 2) + "|")
            
            # Table rows
            for i, seg in enumerate(filtered_segments, 1):
                # Escape pipe characters in text for Markdown tables
                source_text = seg.source.replace("|", "\\|").replace("\n", " ")
                target_text = (seg.target or "").replace("|", "\\|").replace("\n", " ")
                
                if content_mode == "bilingual":
                    output_lines.append(f"| {i} | {source_text} | {target_text} |")
                elif content_mode == "source_only":
                    output_lines.append(f"| {i} | {source_text} |")
                else:  # target_only
                    output_lines.append(f"| {i} | {target_text} |")
            
            # Write file
            with open(file_path, 'w', encoding='utf-8', newline='\n') as f:
                f.write('\n'.join(output_lines))
            
            self.log(f"‚úì Exported {len(filtered_segments)} segments as Markdown table to: {os.path.basename(file_path)}")
            
            QMessageBox.information(
                self,
                "Export Complete",
                f"Successfully exported {len(filtered_segments)} segments as Markdown table to:\n\n{os.path.basename(file_path)}\n\n"
                f"This format renders beautifully in ChatGPT, Claude, and other AI chat interfaces!"
            )
            
        except Exception as e:
            self.log(f"‚úó Markdown table export failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Export Error",
                f"Failed to export Markdown table:\n\n{str(e)}"
            )
    
    def convert_document_to_markdown(self):
        """Convert a single DOCX or TXT document to Markdown format, preserving structure"""
        try:
            # Select input file
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Select Document to Convert",
                "",
                "Documents (*.docx *.txt);;All Files (*.*)"
            )
            
            if not file_path:
                return
            
            # Determine output path
            base_name = os.path.splitext(file_path)[0]
            output_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save Markdown File",
                base_name + ".md",
                "Markdown Files (*.md);;All Files (*.*)"
            )
            
            if not output_path:
                return
            
            # Ensure .md extension
            if not output_path.lower().endswith('.md'):
                output_path += '.md'
            
            # Convert based on file type
            if file_path.lower().endswith('.docx'):
                self._convert_docx_to_markdown(file_path, output_path)
            else:  # TXT
                self._convert_txt_to_markdown(file_path, output_path)
            
            self.log(f"‚úì Converted {os.path.basename(file_path)} ‚Üí {os.path.basename(output_path)}")
            
            QMessageBox.information(
                self,
                "Conversion Complete",
                f"Successfully converted document to Markdown:\n\n{os.path.basename(output_path)}"
            )
            
        except Exception as e:
            self.log(f"‚úó Document conversion failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Conversion Error",
                f"Failed to convert document:\n\n{str(e)}"
            )
    
    def batch_convert_documents_to_markdown(self):
        """Batch convert multiple documents to Markdown format"""
        try:
            # Select multiple files
            file_paths, _ = QFileDialog.getOpenFileNames(
                self,
                "Select Documents to Convert",
                "",
                "Documents (*.docx *.txt);;All Files (*.*)"
            )
            
            if not file_paths:
                return
            
            # Select output folder
            output_folder = QFileDialog.getExistingDirectory(
                self,
                "Select Output Folder for Markdown Files",
                "",
                QFileDialog.Option.ShowDirsOnly
            )
            
            if not output_folder:
                return
            
            # Progress dialog
            progress = QProgressDialog(
                "Converting documents to Markdown...",
                "Cancel",
                0,
                len(file_paths),
                self
            )
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumDuration(0)
            
            converted_count = 0
            failed_count = 0
            
            for i, file_path in enumerate(file_paths):
                if progress.wasCanceled():
                    break
                
                progress.setValue(i)
                progress.setLabelText(f"Converting: {os.path.basename(file_path)}")
                QApplication.processEvents()
                
                try:
                    # Determine output path
                    base_name = os.path.splitext(os.path.basename(file_path))[0]
                    output_path = os.path.join(output_folder, base_name + ".md")
                    
                    # Convert based on file type
                    if file_path.lower().endswith('.docx'):
                        self._convert_docx_to_markdown(file_path, output_path)
                    else:  # TXT
                        self._convert_txt_to_markdown(file_path, output_path)
                    
                    converted_count += 1
                    self.log(f"‚úì Converted: {os.path.basename(file_path)}")
                    
                except Exception as e:
                    failed_count += 1
                    self.log(f"‚úó Failed: {os.path.basename(file_path)} - {str(e)}")
            
            progress.setValue(len(file_paths))
            
            # Show summary
            summary = f"Batch conversion complete!\n\n"
            summary += f"‚úì Successfully converted: {converted_count} files\n"
            if failed_count > 0:
                summary += f"‚úó Failed: {failed_count} files\n"
            summary += f"\nOutput folder: {output_folder}"
            
            QMessageBox.information(
                self,
                "Batch Conversion Complete",
                summary
            )
            
        except Exception as e:
            self.log(f"‚úó Batch conversion failed: {str(e)}")
            QMessageBox.critical(
                self,
                "Conversion Error",
                f"Failed to perform batch conversion:\n\n{str(e)}"
            )
    
    def _convert_docx_to_markdown(self, docx_path: str, output_path: str):
        """Convert DOCX document to Markdown, preserving structure"""
        from docx import Document
        
        doc = Document(docx_path)
        markdown_lines = []
        
        # Add document title
        doc_name = os.path.splitext(os.path.basename(docx_path))[0]
        markdown_lines.append(f"# {doc_name}")
        markdown_lines.append("")
        
        for para in doc.paragraphs:
            if not para.text.strip():
                markdown_lines.append("")
                continue
            
            # Check paragraph style
            style = para.style.name.lower()
            text = para.text.strip()
            
            # Detect ALL CAPS headings (common in patent documents)
            words = text.split()
            is_all_caps = (
                len(words) >= 2 and 
                all(word.isupper() or not word.isalpha() for word in words) and
                len(text) <= 100  # Reasonable heading length
            )
            
            if 'heading 1' in style or style == 'title':
                markdown_lines.append(f"# {text}")
            elif 'heading 2' in style:
                markdown_lines.append(f"## {text}")
            elif 'heading 3' in style:
                markdown_lines.append(f"### {text}")
            elif 'heading 4' in style:
                markdown_lines.append(f"#### {text}")
            elif 'heading 5' in style:
                markdown_lines.append(f"##### {text}")
            elif 'heading 6' in style:
                markdown_lines.append(f"###### {text}")
            elif is_all_caps:
                # ALL CAPS line without heading style - treat as heading
                markdown_lines.append(f"## {text.title()}")
            elif 'list bullet' in style or 'bullet' in style:
                markdown_lines.append(f"- {text}")
            elif 'list number' in style or 'numbering' in style:
                markdown_lines.append(f"1. {text}")
            elif 'quote' in style or 'quotation' in style:
                markdown_lines.append(f"> {text}")
            else:
                # Regular paragraph - preserve bold/italic if present
                # Simple formatting detection (runs with bold/italic)
                has_bold = any(run.bold for run in para.runs if run.text.strip())
                has_italic = any(run.italic for run in para.runs if run.text.strip())
                
                if has_bold and has_italic:
                    markdown_lines.append(f"***{text}***")
                elif has_bold:
                    markdown_lines.append(f"**{text}**")
                elif has_italic:
                    markdown_lines.append(f"*{text}*")
                else:
                    markdown_lines.append(text)
            
            markdown_lines.append("")
        
        # Write output
        with open(output_path, 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(markdown_lines))
    
    def _convert_txt_to_markdown(self, txt_path: str, output_path: str):
        """Convert TXT document to Markdown with minimal formatting"""
        with open(txt_path, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        markdown_lines = []
        
        # Add document title
        doc_name = os.path.splitext(os.path.basename(txt_path))[0]
        markdown_lines.append(f"# {doc_name}")
        markdown_lines.append("")
        
        # Process lines - detect simple patterns
        for line in lines:
            stripped = line.strip()
            
            if not stripped:
                markdown_lines.append("")
                continue
            
            # Detect ALL CAPS headings (common in plain text documents)
            # Must be at least 3 words long and all uppercase
            words = stripped.split()
            is_all_caps = (
                len(words) >= 2 and 
                all(word.isupper() or not word.isalpha() for word in words) and
                len(stripped) <= 100  # Reasonable heading length
            )
            
            if is_all_caps:
                # Convert to title case and make it a heading
                markdown_lines.append(f"## {stripped.title()}")
            # Detect simple bullet points
            elif stripped.startswith('- ') or stripped.startswith('* '):
                markdown_lines.append(stripped)
            # Detect numbered lists
            elif len(stripped) > 2 and stripped[0].isdigit() and stripped[1] in '.):':
                markdown_lines.append(stripped)
            # Regular text
            else:
                markdown_lines.append(stripped)
        
        # Write output
        with open(output_path, 'w', encoding='utf-8', newline='\n') as f:
            f.write('\n'.join(markdown_lines))

    # ========================================================================
    # MULTI-FILE FOLDER IMPORT
    # ========================================================================
    
    def import_folder_multifile(self):
        """
        Import multiple files from a folder as a single multi-file project.
        
        Supports:
        - DOCX files (monolingual)
        - TXT files (simple text, one segment per line)
        - memoQ bilingual DOCX (if detected)
        
        All project resources (TM, termbases, prompts) apply to all files.
        """
        from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                                      QGroupBox, QComboBox, QPushButton, QScrollArea,
                                      QFileDialog)
        
        # Select folder
        folder_path = QFileDialog.getExistingDirectory(
            self,
            "Select Folder with Files to Import",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if not folder_path:
            return
        
        # Scan folder for supported files
        supported_extensions = ['.docx', '.txt']
        found_files = []
        
        for filename in sorted(os.listdir(folder_path)):
            ext = os.path.splitext(filename)[1].lower()
            if ext in supported_extensions:
                full_path = os.path.join(folder_path, filename)
                found_files.append({
                    'name': filename,
                    'path': full_path,
                    'type': 'docx' if ext == '.docx' else 'txt',
                    'size': os.path.getsize(full_path)
                })
        
        if not found_files:
            QMessageBox.warning(
                self,
                "No Files Found",
                f"No supported files found in folder:\n{folder_path}\n\n"
                f"Supported formats: DOCX, TXT"
            )
            return
        
        # Show import dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("üìÅ Import Folder - Multi-File Project")
        dialog.setMinimumWidth(600)
        dialog.setMinimumHeight(500)
        
        layout = QVBoxLayout(dialog)
        
        # Info
        info_label = QLabel(
            f"<b>üìÅ Multi-File Project Import</b><br><br>"
            f"Found <b>{len(found_files)}</b> files in: <i>{os.path.basename(folder_path)}</i><br><br>"
            f"All files will be combined into a single project.<br>"
            f"Project resources (TM, termbases, prompts) will apply to all files.<br>"
            f"You can track progress per file in the File Progress panel."
        )
        info_label.setWordWrap(True)
        info_label.setTextFormat(Qt.TextFormat.RichText)
        layout.addWidget(info_label)
        
        layout.addSpacing(10)
        
        # File list with checkboxes
        files_group = QGroupBox(f"Files to Import ({len(found_files)} files)")
        files_layout = QVBoxLayout(files_group)
        
        # Create a scroll area for the checkboxes
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setMinimumHeight(200)
        scroll_area.setMaximumHeight(300)
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setContentsMargins(5, 5, 5, 5)
        scroll_layout.setSpacing(2)
        
        file_checkboxes = []
        for f in found_files:
            size_kb = f['size'] / 1024
            checkbox = CheckmarkCheckBox(f"{f['name']} ({f['type'].upper()}, {size_kb:.1f} KB)")
            checkbox.setChecked(True)  # Select all by default
            checkbox.setProperty("file_data", f)  # Store file data on checkbox
            file_checkboxes.append(checkbox)
            scroll_layout.addWidget(checkbox)
        
        scroll_layout.addStretch()
        scroll_area.setWidget(scroll_widget)
        files_layout.addWidget(scroll_area)
        
        # Selection buttons
        btn_layout = QHBoxLayout()
        select_all_btn = QPushButton("Select All")
        select_all_btn.clicked.connect(lambda: [cb.setChecked(True) for cb in file_checkboxes])
        deselect_all_btn = QPushButton("Deselect All")
        deselect_all_btn.clicked.connect(lambda: [cb.setChecked(False) for cb in file_checkboxes])
        btn_layout.addWidget(select_all_btn)
        btn_layout.addWidget(deselect_all_btn)
        btn_layout.addStretch()
        files_layout.addLayout(btn_layout)
        
        layout.addWidget(files_group)
        
        # Language pair selection
        lang_group = QGroupBox("Language Pair (applies to all files)")
        lang_layout = QHBoxLayout(lang_group)
        
        languages = [
            ("English", "en"),
            ("Dutch", "nl"),
            ("German", "de"),
            ("French", "fr"),
            ("Spanish", "es"),
            ("Italian", "it"),
            ("Portuguese", "pt"),
            ("Polish", "pl"),
            ("Russian", "ru"),
            ("Chinese", "zh"),
            ("Japanese", "ja"),
            ("Korean", "ko"),
        ]
        
        source_label = QLabel("Source:")
        source_combo = QComboBox()
        for name, code in languages:
            source_combo.addItem(name, code)
        source_combo.setCurrentIndex(0)  # English default
        
        arrow_label = QLabel(" ‚Üí ")
        arrow_label.setStyleSheet("font-weight: bold; font-size: 14px;")
        
        target_label = QLabel("Target:")
        target_combo = QComboBox()
        for name, code in languages:
            target_combo.addItem(name, code)
        target_combo.setCurrentIndex(1)  # Dutch default
        
        lang_layout.addWidget(source_label)
        lang_layout.addWidget(source_combo)
        lang_layout.addWidget(arrow_label)
        lang_layout.addWidget(target_label)
        lang_layout.addWidget(target_combo)
        lang_layout.addStretch()
        
        layout.addWidget(lang_group)
        
        # Import format options
        format_group = QGroupBox("Import Options")
        format_layout = QVBoxLayout(format_group)
        
        # memoQ format detection
        memoq_checkbox = CheckmarkCheckBox("Detect memoQ bilingual format (DOCX files with tables)")
        memoq_checkbox.setChecked(False)
        memoq_checkbox.setToolTip("If checked, DOCX files with bilingual tables will be imported as memoQ bilingual format")
        format_layout.addWidget(memoq_checkbox)
        
        layout.addWidget(format_group)
        
        layout.addSpacing(10)
        
        # Buttons
        button_layout = QHBoxLayout()
        ok_btn = QPushButton("üì• Import Selected Files")
        ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 8px 16px; border: none; outline: none;")
        ok_btn.clicked.connect(dialog.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(cancel_btn)
        button_layout.addWidget(ok_btn)
        layout.addLayout(button_layout)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Get selected files from checkboxes
        selected_files = []
        for checkbox in file_checkboxes:
            if checkbox.isChecked():
                selected_files.append(checkbox.property("file_data"))
        
        if not selected_files:
            QMessageBox.warning(self, "No Files Selected", "Please select at least one file to import.")
            return
        
        # Get language settings
        source_lang = source_combo.currentData()
        target_lang = target_combo.currentData()
        detect_memoq = memoq_checkbox.isChecked()
        
        # Import files
        self._import_multifile_project(folder_path, selected_files, source_lang, target_lang, detect_memoq)
    
    def _import_multifile_project(self, folder_path: str, files: list, source_lang: str, target_lang: str, detect_memoq: bool):
        """
        Import multiple files into a single project.
        
        Args:
            folder_path: Path to the folder containing files
            files: List of file dictionaries with 'name', 'path', 'type'
            source_lang: Source language code
            target_lang: Target language code
            detect_memoq: Whether to detect memoQ bilingual format
        """
        from datetime import datetime
        import shutil
        
        self.log(f"üìÅ Importing multi-file project from: {os.path.basename(folder_path)}")
        self.log(f"   Files to import: {len(files)}")
        
        # Create _source_files folder to store copies of original files
        # This ensures we always have the originals for format-preserving export
        source_backup_folder = os.path.join(folder_path, "_source_files")
        try:
            os.makedirs(source_backup_folder, exist_ok=True)
            self.log(f"   üì¶ Backing up source files to: _source_files/")
        except Exception as e:
            self.log(f"   ‚ö†Ô∏è Could not create backup folder: {str(e)}")
            source_backup_folder = None
        
        # Initialize handlers
        if not hasattr(self, 'docx_handler'):
            from modules.docx_handler import DOCXHandler
            self.docx_handler = DOCXHandler()
        
        if not hasattr(self, 'segmenter'):
            from modules.simple_segmenter import SimpleSegmenter
            self.segmenter = SimpleSegmenter()
        
        all_segments = []
        file_metadata = []  # Track file info for the project
        current_segment_id = 1
        
        # Progress dialog
        progress_dialog = QProgressDialog("Importing files...", "Cancel", 0, len(files), self)
        progress_dialog.setWindowTitle("Importing Multi-File Project")
        progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
        progress_dialog.setMinimumDuration(0)
        
        for idx, file_info in enumerate(files):
            if progress_dialog.wasCanceled():
                self.log("‚ùå Import cancelled by user")
                return
            
            progress_dialog.setValue(idx)
            progress_dialog.setLabelText(f"Importing: {file_info['name']} ({idx+1}/{len(files)})")
            QApplication.processEvents()
            
            file_id = idx + 1
            file_name = file_info['name']
            file_path = file_info['path']
            file_type = file_info['type']
            
            self.log(f"   üìÑ [{idx+1}/{len(files)}] {file_name}")
            
            try:
                file_segments = []
                
                # Copy original file to backup folder for safe keeping
                backup_path = None
                if source_backup_folder:
                    try:
                        backup_path = os.path.join(source_backup_folder, file_name)
                        shutil.copy2(file_path, backup_path)
                        self.log(f"      üì¶ Backed up: {file_name}")
                    except Exception as e:
                        self.log(f"      ‚ö†Ô∏è Backup failed: {str(e)}")
                        backup_path = None
                
                if file_type == 'txt':
                    # Simple text file: each line is a segment
                    with open(file_path, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                    
                    for line in lines:
                        text = line.rstrip('\n\r')
                        if text.strip():  # Skip empty lines for segments, but could preserve them
                            segment = Segment(
                                id=current_segment_id,
                                source=text,
                                target="",
                                status=DEFAULT_STATUS.key,
                                file_id=file_id,
                                file_name=file_name
                            )
                            file_segments.append(segment)
                            current_segment_id += 1
                
                elif file_type == 'docx':
                    # Import DOCX file
                    paragraphs = self.docx_handler.import_docx(file_path)
                    segmented = self.segmenter.segment_paragraphs(paragraphs)
                    
                    for para_id, text in segmented:
                        if text.strip():
                            segment = Segment(
                                id=current_segment_id,
                                source=text,
                                target="",
                                status=DEFAULT_STATUS.key,
                                paragraph_id=para_id if para_id else 0,
                                file_id=file_id,
                                file_name=file_name
                            )
                            file_segments.append(segment)
                            current_segment_id += 1
                
                # Track file metadata - use backup path if available, otherwise original
                stored_path = backup_path if backup_path and os.path.exists(backup_path) else file_path
                file_meta = {
                    'id': file_id,
                    'name': file_name,
                    'path': stored_path,
                    'type': file_type,
                    'segment_count': len(file_segments),
                    'start_segment_id': file_segments[0].id if file_segments else None,
                    'end_segment_id': file_segments[-1].id if file_segments else None
                }
                file_metadata.append(file_meta)
                
                all_segments.extend(file_segments)
                self.log(f"      ‚úì {len(file_segments)} segments")
                
            except Exception as e:
                self.log(f"      ‚ùå Error: {str(e)}")
                QMessageBox.warning(
                    self,
                    "Import Error",
                    f"Failed to import file:\n{file_name}\n\nError: {str(e)}\n\nContinuing with remaining files..."
                )
        
        progress_dialog.setValue(len(files))
        progress_dialog.close()
        
        if not all_segments:
            QMessageBox.warning(self, "No Segments", "No segments were imported from the selected files.")
            return
        
        # Create multi-file project
        project = Project(
            name=f"Multi-File Project - {os.path.basename(folder_path)}",
            source_lang=source_lang,
            target_lang=target_lang,
            segments=all_segments,
            is_multifile=True,
            files=file_metadata
        )
        
        # Set as current project
        self.current_project = project
        self.current_document_path = folder_path
        
        # Load into grid
        self.load_segments_to_grid()
        
        # Initialize TM
        self.initialize_tm_database()
        
        # Update UI
        self.update_window_title()
        
        # Update file filter dropdown for multi-file projects
        if hasattr(self, '_update_file_filter_combo'):
            self._update_file_filter_combo()
        
        # Log summary
        self.log(f"‚úì Multi-file project created:")
        self.log(f"   Total segments: {len(all_segments)}")
        self.log(f"   Files: {len(file_metadata)}")
        self.log(f"   Language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}")
        
        # Show success message with summary
        file_summary = "\n".join([f"  ‚Ä¢ {f['name']}: {f['segment_count']} segments" for f in file_metadata[:10]])
        if len(file_metadata) > 10:
            file_summary += f"\n  ... and {len(file_metadata) - 10} more files"
        
        QMessageBox.information(
            self,
            "Multi-File Import Complete",
            f"Successfully imported {len(all_segments)} segments from {len(file_metadata)} files.\n\n"
            f"Language pair: {source_lang.upper()} ‚Üí {target_lang.upper()}\n\n"
            f"Files:\n{file_summary}\n\n"
            f"Use View ‚Üí File Progress to track translation progress per file."
        )

    def relocate_source_folder(self):
        """
        Relocate the source folder for a multi-file project.
        
        This allows users to repoint to moved/renamed source folders so that
        DOCX exports can preserve original formatting.
        """
        from PyQt6.QtWidgets import QFileDialog, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QTableWidget, QTableWidgetItem, QHeaderView
        
        if not self.current_project:
            QMessageBox.warning(self, "No Project", "Please open a project first.")
            return
        
        # Check if this is a multi-file project
        is_multifile = getattr(self.current_project, 'is_multifile', False)
        files = getattr(self.current_project, 'files', [])
        
        if not is_multifile or not files:
            QMessageBox.information(
                self,
                "Single-File Project",
                "This feature is for multi-file projects only.\n\n"
                "Multi-file projects are created via:\n"
                "File ‚Üí Import ‚Üí Folder (Multiple Files)..."
            )
            return
        
        # Check current status of source files
        missing_count = 0
        found_count = 0
        for f in files:
            path = f.get('path', '')
            if path:
                path = os.path.normpath(path)
                if os.path.exists(path):
                    found_count += 1
                else:
                    missing_count += 1
            else:
                missing_count += 1
        
        # Ask user to select new folder
        info_text = (
            f"Current source file status:\n"
            f"  ‚úì Found: {found_count} files\n"
            f"  ‚úó Missing: {missing_count} files\n\n"
            f"Select the folder containing the original source files.\n"
            f"Files will be matched by filename."
        )
        
        result = QMessageBox.question(
            self,
            "üîó Relocate Source Folder",
            info_text + "\n\nProceed to select folder?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if result != QMessageBox.StandardButton.Yes:
            return
        
        # Select new folder
        new_folder = QFileDialog.getExistingDirectory(
            self,
            "Select Folder Containing Original Source Files",
            os.path.dirname(self.current_document_path) if self.current_document_path else ""
        )
        
        if not new_folder:
            return
        
        # Scan new folder for matching files
        self.log(f"üîó Relocating source folder to: {new_folder}")
        
        # Build a map of available files in the new folder (including subfolders)
        available_files = {}
        for root, dirs, filenames in os.walk(new_folder):
            for filename in filenames:
                full_path = os.path.join(root, filename)
                # Store by filename (case-insensitive matching)
                available_files[filename.lower()] = full_path
        
        self.log(f"   Found {len(available_files)} files in selected folder")
        
        # Try to match each project file
        updated_count = 0
        not_found = []
        
        for file_info in files:
            file_name = file_info.get('name', '')
            if not file_name:
                continue
            
            # Try to find matching file
            matched_path = available_files.get(file_name.lower())
            
            if matched_path:
                old_path = file_info.get('path', '')
                file_info['path'] = matched_path
                updated_count += 1
                self.log(f"   ‚úì {file_name} ‚Üí {matched_path}")
            else:
                not_found.append(file_name)
                self.log(f"   ‚úó {file_name} - not found in selected folder")
        
        # Update project
        self.current_project.files = files
        
        # Show results
        if not_found:
            not_found_str = "\n".join([f"  ‚Ä¢ {f}" for f in not_found[:10]])
            if len(not_found) > 10:
                not_found_str += f"\n  ... and {len(not_found) - 10} more"
            
            QMessageBox.warning(
                self,
                "Partial Match",
                f"Updated {updated_count} file paths.\n\n"
                f"Files not found ({len(not_found)}):\n{not_found_str}\n\n"
                f"These files will use fallback export (no formatting preserved).\n\n"
                f"Save the project to keep these changes."
            )
        else:
            QMessageBox.information(
                self,
                "‚úì Source Folder Relocated",
                f"Successfully updated all {updated_count} file paths.\n\n"
                f"DOCX exports will now preserve original formatting.\n\n"
                f"Save the project to keep these changes."
            )
        
        self.log(f"‚úì Relocated {updated_count}/{len(files)} source file paths")

    def export_folder_multifile(self):
        """
        Export a multi-file project to a folder with separate files.
        
        Each file in the project is exported as a separate file in the target folder.
        Supports DOCX (target only) and TXT formats.
        """
        from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                                      QGroupBox, QComboBox, QPushButton, QTableWidget,
                                      QTableWidgetItem, QHeaderView, QProgressDialog,
                                      QFileDialog, QButtonGroup)
        
        if not self.current_project:
            QMessageBox.warning(self, "No Project", "Please open a project first.")
            return
        
        # Check if this is a multi-file project
        is_multifile = getattr(self.current_project, 'is_multifile', False)
        files = getattr(self.current_project, 'files', [])
        
        if not is_multifile or not files:
            QMessageBox.information(
                self,
                "Single-File Project",
                "This is a single-file project.\n\n"
                "Use the regular export options (Target Only DOCX, Simple Text, etc.) instead.\n\n"
                "Folder export is for multi-file projects imported via:\n"
                "File ‚Üí Import ‚Üí Folder (Multiple Files)..."
            )
            return
        
        # Show export dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("üìÅ Export Multi-File Project")
        dialog.setMinimumWidth(650)
        dialog.setMinimumHeight(450)
        
        layout = QVBoxLayout(dialog)
        
        # Info
        segments = self.current_project.segments
        total_segs = len(segments)
        translated_segs = sum(1 for s in segments if s.target and s.target.strip())
        
        info_label = QLabel(
            f"<b>üìÅ Export Multi-File Project</b><br><br>"
            f"Project: {self.current_project.name}<br>"
            f"Files: {len(files)} | Segments: {translated_segs}/{total_segs} translated"
        )
        info_label.setTextFormat(Qt.TextFormat.RichText)
        layout.addWidget(info_label)
        
        layout.addSpacing(10)
        
        # Export format selection
        format_group = QGroupBox("Export Format")
        format_layout = QVBoxLayout(format_group)
        
        format_btn_group = QButtonGroup(dialog)
        
        txt_radio = CheckmarkRadioButton("üìÑ Plain Text (.txt) - One line per segment")
        txt_radio.setChecked(True)
        format_btn_group.addButton(txt_radio, 1)
        format_layout.addWidget(txt_radio)
        
        docx_radio = CheckmarkRadioButton("üìù Word Document (.docx) - Target text only")
        format_btn_group.addButton(docx_radio, 2)
        format_layout.addWidget(docx_radio)
        
        bilingual_radio = CheckmarkRadioButton("üìä Bilingual Table (.docx) - Source | Target columns")
        format_btn_group.addButton(bilingual_radio, 3)
        format_layout.addWidget(bilingual_radio)
        
        layout.addWidget(format_group)
        
        layout.addSpacing(10)
        
        # File preview table
        preview_group = QGroupBox(f"Files to Export ({len(files)} files)")
        preview_layout = QVBoxLayout(preview_group)
        
        preview_table = QTableWidget()
        preview_table.setColumnCount(4)
        preview_table.setHorizontalHeaderLabels(["Original File", "Segments", "Translated", "Output Name"])
        preview_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        preview_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)
        preview_table.setRowCount(len(files))
        preview_table.setAlternatingRowColors(True)
        preview_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        
        for row, file_info in enumerate(files):
            file_id = file_info['id']
            file_name = file_info['name']
            
            # Count segments for this file
            file_segs = [s for s in segments if getattr(s, 'file_id', None) == file_id]
            total = len(file_segs)
            translated = sum(1 for s in file_segs if s.target and s.target.strip())
            
            # Generate output name
            base_name = os.path.splitext(file_name)[0]
            output_name = f"{base_name}_translated.txt"
            
            preview_table.setItem(row, 0, QTableWidgetItem(file_name))
            preview_table.setItem(row, 1, QTableWidgetItem(str(total)))
            preview_table.setItem(row, 2, QTableWidgetItem(f"{translated}/{total}"))
            preview_table.setItem(row, 3, QTableWidgetItem(output_name))
        
        preview_layout.addWidget(preview_table)
        layout.addWidget(preview_group)
        
        # Update output names when format changes
        def update_output_names():
            ext = ".txt" if txt_radio.isChecked() else ".docx"
            for row, file_info in enumerate(files):
                base_name = os.path.splitext(file_info['name'])[0]
                output_name = f"{base_name}_translated{ext}"
                preview_table.setItem(row, 3, QTableWidgetItem(output_name))
        
        txt_radio.toggled.connect(update_output_names)
        docx_radio.toggled.connect(update_output_names)
        bilingual_radio.toggled.connect(update_output_names)
        
        layout.addSpacing(10)
        
        # Buttons
        button_layout = QHBoxLayout()
        ok_btn = QPushButton("üì§ Export to Folder...")
        ok_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 8px 16px; border: none; outline: none;")
        ok_btn.clicked.connect(dialog.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        
        button_layout.addStretch()
        button_layout.addWidget(cancel_btn)
        button_layout.addWidget(ok_btn)
        layout.addLayout(button_layout)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Get export format
        if txt_radio.isChecked():
            export_format = "txt"
        elif docx_radio.isChecked():
            export_format = "docx"
        else:
            export_format = "bilingual"
        
        # Select output folder
        output_folder = QFileDialog.getExistingDirectory(
            self,
            "Select Output Folder for Exported Files",
            "",
            QFileDialog.Option.ShowDirsOnly
        )
        
        if not output_folder:
            return
        
        # Export each file
        self._export_multifile_to_folder(output_folder, export_format)
    
    def _export_multifile_to_folder(self, output_folder: str, export_format: str):
        """
        Export each file in a multi-file project to the output folder.
        
        Args:
            output_folder: Path to output folder
            export_format: 'txt', 'docx', or 'bilingual'
        """
        files = getattr(self.current_project, 'files', [])
        segments = self.current_project.segments
        
        self.log(f"üì§ Exporting multi-file project to: {output_folder}")
        self.log(f"   Format: {export_format.upper()}")
        
        # Progress dialog
        progress_dialog = QProgressDialog("Exporting files...", "Cancel", 0, len(files), self)
        progress_dialog.setWindowTitle("Exporting Multi-File Project")
        progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
        progress_dialog.setMinimumDuration(0)
        
        exported_count = 0
        total_segments_exported = 0
        files_missing_originals = []  # Track files where we couldn't preserve formatting
        
        for idx, file_info in enumerate(files):
            if progress_dialog.wasCanceled():
                self.log("‚ùå Export cancelled by user")
                break
            
            progress_dialog.setValue(idx)
            progress_dialog.setLabelText(f"Exporting: {file_info['name']} ({idx+1}/{len(files)})")
            QApplication.processEvents()
            
            file_id = file_info['id']
            file_name = file_info['name']
            base_name = os.path.splitext(file_name)[0]
            
            # Get original file path for format preservation
            # Normalize path separators (fix mixed forward/back slashes from Google Drive paths)
            original_path = file_info.get('path', None)
            if original_path:
                original_path = os.path.normpath(original_path)
            
            # Check if file exists (for format preservation during DOCX export)
            path_exists = False
            if original_path:
                path_exists = os.path.exists(original_path)
                # Fallback: try to actually open the file (more reliable for virtual filesystems like Google Drive)
                if not path_exists:
                    try:
                        with open(original_path, 'rb') as f:
                            f.read(1)
                        path_exists = True
                    except:
                        pass
            
            # Get segments for this file
            file_segments = [s for s in segments if getattr(s, 'file_id', None) == file_id]
            
            if not file_segments:
                self.log(f"   ‚ö†Ô∏è {file_name}: No segments found, skipping")
                continue
            
            try:
                if export_format == "txt":
                    # Export as plain text
                    output_path = os.path.join(output_folder, f"{base_name}_translated.txt")
                    self._export_file_as_txt(file_segments, output_path)
                    
                elif export_format == "docx":
                    # Export as DOCX (preserving original formatting if possible)
                    output_path = os.path.join(output_folder, f"{base_name}_translated.docx")
                    # Track if we'll preserve formatting
                    format_note = ""
                    if not path_exists:
                        format_note = " (no original - plain text)"
                        files_missing_originals.append(file_name)
                    self._export_file_as_docx(file_segments, output_path, original_path if path_exists else None)
                    
                elif export_format == "bilingual":
                    # Export as bilingual table
                    output_path = os.path.join(output_folder, f"{base_name}_bilingual.docx")
                    format_note = ""
                    self._export_file_as_bilingual(file_segments, output_path)
                
                exported_count += 1
                total_segments_exported += len(file_segments)
                self.log(f"   ‚úì {file_name} ‚Üí {os.path.basename(output_path)} ({len(file_segments)} segments){format_note}")
                
            except Exception as e:
                self.log(f"   ‚ùå {file_name}: Export failed - {str(e)}")
        
        progress_dialog.setValue(len(files))
        progress_dialog.close()
        
        # Show summary
        self.log(f"‚úì Export complete: {exported_count}/{len(files)} files, {total_segments_exported} segments")
        
        # Build message with warning if files were missing originals
        message = (
            f"Successfully exported {exported_count} files to:\n{output_folder}\n\n"
            f"Total segments: {total_segments_exported}\n"
            f"Format: {export_format.upper()}"
        )
        
        if files_missing_originals and export_format == "docx":
            message += (
                f"\n\n‚ö†Ô∏è {len(files_missing_originals)} file(s) exported without original formatting "
                f"(source files not found).\n\n"
                f"To preserve formatting, use:\n"
                f"File ‚Üí Export ‚Üí Relocate Source Folder..."
            )
            self.log(f"   ‚ö†Ô∏è {len(files_missing_originals)} files without original formatting")
        
        QMessageBox.information(
            self,
            "Export Complete",
            message
        )
    
    def _export_file_as_txt(self, segments: list, output_path: str):
        """Export segments to a plain text file (one segment per line)."""
        import re
        
        def strip_tags(text: str) -> str:
            """Remove formatting tags from text."""
            if not text:
                return ""
            text = re.sub(r'</?b>', '', text)
            text = re.sub(r'</?i>', '', text)
            text = re.sub(r'</?u>', '', text)
            text = re.sub(r'</?li-[ob]>', '', text)
            return text
        
        with open(output_path, 'w', encoding='utf-8') as f:
            for segment in segments:
                # Use target if available, otherwise use source
                text = segment.target if segment.target and segment.target.strip() else segment.source
                f.write(strip_tags(text) + '\n')
    
    def _export_file_as_docx(self, segments: list, output_path: str, original_path: str = None):
        """
        Export segments to a DOCX file, preserving original formatting if original file exists.
        
        Uses the DOCXHandler to properly match paragraphs and preserve formatting.
        
        Args:
            segments: List of Segment objects for this file
            output_path: Path to save the exported file
            original_path: Path to the original DOCX file (for format preservation)
        """
        from docx import Document
        from docx.shared import Pt
        import re
        
        def strip_tags(text: str) -> str:
            """Remove formatting tags from text."""
            if not text:
                return ""
            text = re.sub(r'</?b>', '', text)
            text = re.sub(r'</?i>', '', text)
            text = re.sub(r'</?u>', '', text)
            text = re.sub(r'</?li-[ob]>', '', text)
            return text
        
        def file_accessible(path: str) -> bool:
            """Check if file exists and is accessible (works better with Google Drive)."""
            if not path:
                return False
            # Try os.path.exists first
            if os.path.exists(path):
                return True
            # Fallback: try to actually open the file (more reliable for virtual filesystems)
            try:
                with open(path, 'rb') as f:
                    f.read(1)
                return True
            except:
                return False
        
        # If we have the original file, use DOCXHandler for proper format preservation
        if original_path and file_accessible(original_path):
            self.log(f"      üìÑ Using original file as template: {os.path.basename(original_path)}")
            
            try:
                # Create a fresh DOCXHandler for this file
                from modules.docx_handler import DOCXHandler
                handler = DOCXHandler()
                
                # Import the original to set up paragraph mapping
                handler.import_docx(original_path)
                
                # Convert segments to the format expected by export_docx
                export_segments = []
                for seg in segments:
                    text = seg.target if seg.target and seg.target.strip() else seg.source
                    export_segments.append({
                        'paragraph_id': getattr(seg, 'paragraph_id', 0),
                        'source': seg.source,
                        'target': text
                    })
                
                # Use the handler's export which preserves all formatting
                handler.export_docx(export_segments, output_path, preserve_formatting=True)
                return
                
            except Exception as e:
                self.log(f"      ‚ö†Ô∏è DOCXHandler export failed ({str(e)}), falling back to simple export")
        
        # Fallback: create new document (loses formatting)
        self.log(f"      ‚ö†Ô∏è Original file not found, creating new document (formatting not preserved)")
        
        doc = Document()
        
        for segment in segments:
            text = segment.target if segment.target and segment.target.strip() else segment.source
            text = strip_tags(text)
            para = doc.add_paragraph(text)
            for run in para.runs:
                run.font.size = Pt(11)
        
        doc.save(output_path)
    
    def _export_file_as_bilingual(self, segments: list, output_path: str):
        """Export segments to a bilingual DOCX table (Source | Target columns)."""
        from docx import Document
        from docx.shared import Inches, Pt
        import re
        
        def strip_tags(text: str) -> str:
            """Remove formatting tags from text for clean display."""
            if not text:
                return ""
            # Remove inline formatting tags
            text = re.sub(r'</?b>', '', text)
            text = re.sub(r'</?i>', '', text)
            text = re.sub(r'</?u>', '', text)
            text = re.sub(r'</?li-[ob]>', '', text)
            return text
        
        doc = Document()
        
        # Add header
        header = doc.add_paragraph()
        header.add_run(f"Bilingual Export - {len(segments)} segments").bold = True
        
        # Create table
        table = doc.add_table(rows=1, cols=3)
        table.style = 'Table Grid'
        
        # Header row
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = "#"
        hdr_cells[1].text = "Source"
        hdr_cells[2].text = "Target"
        
        # Make header bold
        for cell in hdr_cells:
            for para in cell.paragraphs:
                for run in para.runs:
                    run.bold = True
        
        # Add segments
        for segment in segments:
            row_cells = table.add_row().cells
            row_cells[0].text = str(segment.id)
            row_cells[1].text = strip_tags(segment.source)
            row_cells[2].text = strip_tags(segment.target) if segment.target else ""
        
        # Set column widths
        for row in table.rows:
            row.cells[0].width = Inches(0.5)
            row.cells[1].width = Inches(3.0)
            row.cells[2].width = Inches(3.0)
        
        doc.save(output_path)

    def _interpret_memoq_status(self, status_text: str, has_target: bool) -> Tuple[str, Optional[int]]:
        """Map memoQ status text to internal status and extract match percentage."""
        status_def, match_percent = match_memoq_status(status_text)
        if status_def.key == DEFAULT_STATUS.key and has_target:
            return STATUSES["pretranslated"].key, match_percent
        return status_def.key, match_percent

    def import_memoq_bilingual(self):
        """Import memoQ bilingual DOCX file (table format)"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select memoQ Bilingual DOCX File",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        # Show formatting options dialog
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDialogButtonBox, QGroupBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("memoQ Bilingual Import Options")
        dialog.setMinimumWidth(450)
        layout = QVBoxLayout(dialog)
        
        # Info text
        info_label = QLabel(
            "This workflow imports memoQ bilingual DOCX for round-tripping.\n"
            "The project can be exported back to memoQ bilingual DOCX format."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Formatting options group
        format_group = QGroupBox("Formatting Handling")
        format_layout = QVBoxLayout(format_group)
        
        # Option 1: Ignore formatting (using CheckmarkCheckBox)
        ignore_checkbox = CheckmarkCheckBox("Ignore inline formatting")
        ignore_checkbox.setToolTip("Bold, italic, and underline formatting will not be transferred to translations.\nUse this if formatting causes issues or isn't needed.")
        ignore_checkbox.setChecked(False)  # Default: use smart formatting
        format_layout.addWidget(ignore_checkbox)
        
        ignore_desc = QLabel("    When checked, formatting (bold/italic/underline) will not be applied to translations.")
        ignore_desc.setStyleSheet("color: #888; font-size: 10px; margin-left: 20px;")
        format_layout.addWidget(ignore_desc)
        
        # Option 2: Smart formatting (using CheckmarkCheckBox)
        smart_checkbox = CheckmarkCheckBox("Smart formatting transfer")
        smart_checkbox.setToolTip("Attempts to identify formatted text in source and apply matching formatting to corresponding words in the translation.")
        smart_checkbox.setChecked(True)  # Default
        format_layout.addWidget(smart_checkbox)
        
        smart_desc = QLabel("    When checked, tries to match formatted source phrases to their translations.")
        smart_desc.setStyleSheet("color: #888; font-size: 10px; margin-left: 20px;")
        format_layout.addWidget(smart_desc)
        
        # Make checkboxes mutually exclusive
        def on_ignore_changed(checked):
            if checked:
                smart_checkbox.setChecked(False)
        
        def on_smart_changed(checked):
            if checked:
                ignore_checkbox.setChecked(False)
        
        ignore_checkbox.toggled.connect(on_ignore_changed)
        smart_checkbox.toggled.connect(on_smart_changed)
        
        layout.addWidget(format_group)
        
        # Note about tags - escape the angle brackets so they show literally
        note_label = QLabel(
            "‚ÑπÔ∏è Note: Inline XML tags (like &lt;b&gt;text&lt;/b&gt;) are always preserved regardless of this setting."
        )
        note_label.setWordWrap(True)
        note_label.setStyleSheet("color: #2196F3; font-size: 10px; margin-top: 10px;")
        layout.addWidget(note_label)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Store formatting preference
        self.memoq_smart_formatting = smart_checkbox.isChecked()
        self.log(f"üìÑ memoQ import: {'Smart formatting transfer' if self.memoq_smart_formatting else 'Ignore formatting'}")

        try:
            from docx import Document
            
            # Load the bilingual DOCX
            doc = Document(file_path)
            
            if not doc.tables:
                QMessageBox.critical(
                    self, "Error",
                    "No table found in the DOCX file.\n\nExpected memoQ bilingual format with a table."
                )
                return
            
            table = doc.tables[0]
            
            # Validate table structure (should have at least 3 rows: header, column names, data)
            if len(table.rows) < 3:
                QMessageBox.critical(
                    self, "Error",
                    f"Invalid table structure.\n\nExpected at least 3 rows, found {len(table.rows)}."
                )
                return
            
            # CLASSIC APPROACH: Extract source segments to simple line-by-line list
            source_segments = []
            target_segments = []
            formatting_map = {}  # segment_index -> list of formatting info
            metadata = []  # Store comments, status, etc. for later
            
            for row_idx in range(2, len(table.rows)):
                row = table.rows[row_idx]
                
                # Ensure we have at least 3 cells (0=segment#, 1=source, 2=target)
                if len(row.cells) >= 3:
                    source_cell = row.cells[1]
                    target_cell = row.cells[2]
                    
                    # Convert runs to HTML-tagged text if smart formatting is enabled
                    if self.memoq_smart_formatting:
                        source_text = runs_to_tagged_text(source_cell.paragraphs)
                        target_text = runs_to_tagged_text(target_cell.paragraphs)
                    else:
                        source_text = source_cell.text.strip()
                        target_text = target_cell.text.strip()
                    
                    # Always add (even if empty) to maintain alignment
                    source_segments.append(source_text)
                    target_segments.append(target_text)
                    
                    # Store metadata
                    comment_text = row.cells[3].text.strip() if len(row.cells) >= 4 else ""
                    status_text = row.cells[4].text.strip() if len(row.cells) >= 5 else ""
                    metadata.append({
                        'comment': comment_text,
                        'status': status_text,
                        'target': target_text
                    })
                    
                    # Also extract formatting info for backwards compatibility / export
                    formatting_info = []
                    for paragraph in source_cell.paragraphs:
                        for run in paragraph.runs:
                            run_text = run.text
                            if run_text:  # Only store runs with actual text
                                formatting_info.append({
                                    'text': run_text,
                                    'bold': run.bold == True,
                                    'italic': run.italic == True,
                                    'underline': run.underline == True
                                })
                    
                    # Store formatting for this segment
                    if formatting_info:
                        segment_idx = len(source_segments) - 1
                        formatting_map[segment_idx] = formatting_info
            
            if not source_segments:
                QMessageBox.warning(self, "Warning", "No segments found in the bilingual file.")
                return
            
            # Detect languages from table header (row 1, columns 1 and 2)
            header_row = table.rows[1]
            source_lang = "en"  # Default
            target_lang = "nl"  # Default
            
            if len(header_row.cells) >= 3:
                source_header = header_row.cells[1].text.strip().lower()
                target_header = header_row.cells[2].text.strip().lower()
                
                # Try to detect language from header
                lang_map = {
                    'english': 'en', 'dutch': 'nl', 'german': 'de', 'french': 'fr',
                    'spanish': 'es', 'italian': 'it', 'portuguese': 'pt', 'polish': 'pl',
                    'czech': 'cs', 'slovak': 'sk', 'hungarian': 'hu', 'romanian': 'ro',
                    'bulgarian': 'bg', 'greek': 'el', 'russian': 'ru', 'ukrainian': 'uk',
                    'swedish': 'sv', 'danish': 'da', 'finnish': 'fi', 'norwegian': 'no',
                    'japanese': 'ja', 'chinese': 'zh', 'korean': 'ko', 'arabic': 'ar',
                    'turkish': 'tr', 'hebrew': 'he'
                }
                
                for lang_name, lang_code in lang_map.items():
                    if lang_name in source_header:
                        source_lang = lang_code
                    if lang_name in target_header:
                        target_lang = lang_code
            
            # SAFETY STEP: Save source segments to TXT file for user verification
            txt_file_path = Path(file_path).with_suffix('.txt')
            try:
                with open(txt_file_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(source_segments))
                self.log(f"‚úì Extracted {len(source_segments)} segments to: {txt_file_path.name}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save TXT file:\n\n{e}")
                return
            
            # Show verification dialog
            reply = QMessageBox.question(
                self,
                "Verify Extracted Segments",
                f"Extracted {len(source_segments)} source segments from memoQ file.\n\n"
                f"A text file has been saved for verification:\n{txt_file_path.name}\n\n"
                f"Please check this file to ensure all segments were extracted correctly.\n\n"
                f"Languages detected: {source_lang.upper()} ‚Üí {target_lang.upper()}\n\n"
                f"Continue with import?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.Yes
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                self.log("‚úó User cancelled memoQ import after extraction")
                return
            
            # Store the bilingual DOCX metadata for later export
            self.memoq_source_file = file_path
            self.memoq_source_segments = source_segments
            self.memoq_target_segments = target_segments
            self.memoq_formatting_map = formatting_map
            self.memoq_metadata = metadata
            
            # Create simple project with sequential IDs
            project_name = Path(file_path).stem
            self.current_project = Project(
                name=project_name,
                source_lang=source_lang,
                target_lang=target_lang,
                segments=[]
            )
            
            # Store memoQ source path in project for persistence across saves
            self.current_project.memoq_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Create segments with simple sequential IDs
            for idx, source_text in enumerate(source_segments):
                existing_target = target_segments[idx] if idx < len(target_segments) else ""
                status = "translated" if existing_target.strip() else "not_started"
                
                segment = Segment(
                    id=idx + 1,  # Sequential: 1, 2, 3, 4...
                    source=source_text,
                    target=existing_target,
                    status=status,
                    type="para",
                    notes=metadata[idx].get('comment', '') if idx < len(metadata) else "",
                    memoQ_status=metadata[idx].get('status', '') if idx < len(metadata) else ""
                )
                self.current_project.segments.append(segment)
            
            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Deactivate all resources for new project, then auto-activate language-matching ones
            self._deactivate_all_resources_for_new_project()

            # Auto-resize rows for better initial display
            self.auto_resize_rows()

            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)

            # If smart formatting was used, auto-enable Tags view so user sees the tags
            if self.memoq_smart_formatting:
                self._enable_tag_view_after_import()
            
            self.log(f"‚úì Imported memoQ bilingual DOCX: {len(source_segments)} segments from {Path(file_path).name}")

            # Store current document path for AI Assistant
            self.current_document_path = file_path

            # Generate markdown for AI Assistant if enabled
            if hasattr(self, 'auto_generate_markdown') and self.auto_generate_markdown:
                if hasattr(self, 'prompt_manager_qt'):
                    self.prompt_manager_qt.generate_markdown_for_current_document()

            # Refresh AI Assistant context
            if hasattr(self, 'prompt_manager_qt'):
                self.prompt_manager_qt.refresh_context()

            QMessageBox.information(
                self, "Import Successful",
                f"Imported {len(source_segments)} segment(s) from memoQ bilingual DOCX.\n\n"
                f"File: {Path(file_path).name}\n"
                f"Languages: {source_lang} ‚Üí {target_lang}"
            )
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for memoQ bilingual DOCX import.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import memoQ bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó memoQ import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_memoq_bilingual(self):
        """Export to memoQ bilingual DOCX format with translations"""
        # Check if we have segments
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Data", "No segments to export")
            return

        # Check if a memoQ source file was imported - check both instance var and project
        memoq_source = None
        if hasattr(self, 'memoq_source_file') and self.memoq_source_file:
            memoq_source = self.memoq_source_file
        elif hasattr(self.current_project, 'memoq_source_path') and self.current_project.memoq_source_path:
            memoq_source = self.current_project.memoq_source_path
            # Verify it still exists
            if Path(memoq_source).exists():
                self.memoq_source_file = memoq_source
                self.log(f"‚úì Restored memoQ source from project: {Path(memoq_source).name}")
            else:
                memoq_source = None
        
        if not memoq_source:
            # Prompt user to select the original memoQ bilingual file
            reply = QMessageBox.question(
                self, "Select memoQ Source File",
                "To export to memoQ format, please select the original memoQ bilingual DOCX file.\n\n"
                "This is the file you originally imported from memoQ.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original memoQ Bilingual DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )

                if file_path:
                    self.memoq_source_file = file_path
                    self.log(f"‚úì memoQ source file set: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return
        
        try:
            from docx import Document
            from docx.shared import RGBColor
            
            segments = list(self.current_project.segments)
            translations = [seg.target for seg in segments]

            if not translations or all(not t.strip() for t in translations):
                QMessageBox.warning(self, "Warning", "No translations found to export.")
                return
            
            # Load the original bilingual DOCX
            doc = Document(self.memoq_source_file)
            table = doc.tables[0]
            
            # Write translations to target column (column 2) and update status
            segments_updated = 0
            segments_with_formatting = 0
            
            for i, translation in enumerate(translations):
                segment = segments[i]
                row_idx = i + 2  # Skip header rows (0 and 1)

                # Safety check: ensure we don't go beyond available rows
                if row_idx >= len(table.rows):
                    self.log(f"‚ö† Warning: Row {row_idx} exceeds table rows ({len(table.rows)}), stopping at segment {i}")
                    break

                row = table.rows[row_idx]
                num_cells = len(row.cells)

                # Write translation to column 2 (target) with formatting
                if num_cells >= 3:
                    target_cell = row.cells[2]

                    # Check for embedded HTML tags first (new approach)
                    if has_formatting_tags(translation):
                        segments_with_formatting += 1
                        formatting_info = None  # Tags are in the text itself
                    else:
                        # Get formatting info directly from source cell (preserves color/formatting across sessions)
                        formatting_info = []
                        if num_cells >= 2:
                            source_cell = row.cells[1]
                            for paragraph in source_cell.paragraphs:
                                for run in paragraph.runs:
                                    if run.text:
                                        # Capture color if present
                                        color_hex = None
                                        try:
                                            # Method 1: Check standard rgb property
                                            if run.font.color and run.font.color.rgb:
                                                color_hex = str(run.font.color.rgb)
                                            # Method 2: Check XML directly for w:color val (more robust)
                                            elif run.element.rPr is not None:
                                                from docx.oxml.ns import qn
                                                color_elem = run.element.rPr.find(qn('w:color'))
                                                if color_elem is not None:
                                                    color_hex = color_elem.get(qn('w:val'))
                                                # Method 3: Check if run uses a character style (e.g., mqInternal)
                                                # memoQ stores tag colors in character styles, not inline
                                                if not color_hex:
                                                    style_elem = run.element.rPr.find(qn('w:rStyle'))
                                                    if style_elem is not None:
                                                        style_id = style_elem.get(qn('w:val'))
                                                        if style_id:
                                                            # Lookup the style and get its color
                                                            try:
                                                                style = doc.styles[style_id]
                                                                if style.font.color and style.font.color.rgb:
                                                                    color_hex = str(style.font.color.rgb)
                                                            except KeyError:
                                                                pass  # Style not found
                                        except Exception as e:
                                            if i == 0: 
                                                print(f"Color extract error: {e}")
                                        
                                        # Split run text by tags to allow granular formatting transfer
                                        # This ensures that if a tag like {1} is merged with text in one run,
                                        # we still extract {1} as a separate formatting unit.
                                        import re
                                        # Matches {1}, [1], <tag>, or </tag>
                                        parts = re.split(r'(\{\d+\}|\[\d+\]|<\/?[a-zA-Z0-9_]+[^>]*>)', run.text)
                                        
                                        for part in parts:
                                            if not part:
                                                continue
                                                
                                            formatting_info.append({
                                                'text': part,
                                                'bold': run.bold == True,
                                                'italic': run.italic == True,
                                                'underline': run.underline == True,
                                                'color': color_hex
                                            })
            
                        # Debug logging for first segment to help troubleshoot
                        if i == 0 and formatting_info:
                            color_tags = [f['text'] for f in formatting_info if f.get('color')]
                            if color_tags:
                                self.log(f"üîç Debug: Found colored tags in first segment: {color_tags}")

                        if any(f.get('bold') or f.get('italic') or f.get('underline') or f.get('color') for f in formatting_info):
                            segments_with_formatting += 1

                    # Apply formatting to the target cell
                    self._apply_formatting_to_cell(target_cell, translation, formatting_info)
                    segments_updated += 1

                # Update comments in column 3 (if column exists)
                if num_cells >= 4:
                    if segment.notes and segment.notes.strip():
                        row.cells[3].text = segment.notes.strip()

                # Update status column using compose_memoq_status (if column exists)
                if num_cells >= 5:
                    existing = row.cells[4].text
                    row.cells[4].text = compose_memoq_status(segment.status, segment.match_percent, existing)
            
            # Prompt user to save the updated bilingual file
            # Use the same directory as the original import file
            source_path = Path(self.memoq_source_file)
            default_name = str(source_path.parent / (source_path.stem + "_translated.docx"))
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save memoQ Bilingual DOCX",
                default_name,
                "Word Documents (*.docx);;All Files (*.*)"
            )
            
            if save_path:
                doc.save(save_path)
                
                # Build success message
                success_msg = (
                    f"‚úì Successfully exported {segments_updated} translation(s) to memoQ bilingual DOCX!\n\n"
                    f"File saved: {Path(save_path).name}\n\n"
                )
                
                if segments_with_formatting > 0:
                    success_msg += (
                        f"‚úì Formatting preserved in {segments_with_formatting} segment(s)\n"
                        f"  (bold, italic, underline)\n\n"
                    )
                
                success_msg += (
                    f"‚úì Status updated to 'Confirmed'\n"
                    f"‚úì Table structure preserved\n\n"
                    f"You can now import this file back into memoQ."
                )
                
                self.log(f"‚úì Exported {segments_updated} translations to memoQ bilingual DOCX: {Path(save_path).name}")
                
                QMessageBox.information(self, "Export Successful", success_msg)
        
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for memoQ bilingual DOCX export.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export memoQ bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó memoQ export failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def _apply_formatting_to_cell(self, cell, text, formatting_info=None):
        """
        Apply formatting to a cell based on embedded HTML tags or formatting info from source.
        
        Priority:
        1. If text contains <b>, <i>, <u> tags, parse and apply them directly
        2. Otherwise, use formatting_info for smart transfer (legacy approach)
        3. If neither, just add plain text
        """
        # Clear existing paragraphs
        cell._element.clear_content()
        
        # Add new paragraph
        paragraph = cell.add_paragraph()
        
        if not text:
            return
        
        # PRIORITY 1: Check for embedded HTML tags in the text
        if has_formatting_tags(text):
            # Parse the tags and create runs with formatting
            runs = tagged_text_to_runs(text)
            
            for run_info in runs:
                run_text = run_info.get('text', '')
                if not run_text:
                    continue
                    
                run = paragraph.add_run(run_text)
                
                if run_info.get('bold'):
                    run.bold = True
                if run_info.get('italic'):
                    run.italic = True
                if run_info.get('underline'):
                    run.underline = True
            
            return
        
        # PRIORITY 2: Use formatting_info for smart transfer (legacy approach)
        # Default to True so it works across restarts/without re-importing
        use_smart = getattr(self, 'memoq_smart_formatting', True)
        
        if not formatting_info:
            # No formatting info - just add plain text
            paragraph.add_run(text)
            return
        
        if not use_smart:
            # Explicitly disabled by user (only matters if they just imported)
            paragraph.add_run(text)
            return
        
        # Smart formatting transfer algorithm
        # Step 1: Identify formatted regions in source
        formatted_phrases = []
        for fmt in formatting_info:
            fmt_text = fmt.get('text', '')
            if fmt_text and (fmt.get('bold') or fmt.get('italic') or fmt.get('underline') or fmt.get('color')):
                formatted_phrases.append({
                    'text': fmt_text.strip(),
                    'bold': fmt.get('bold', False),
                    'italic': fmt.get('italic', False),
                    'underline': fmt.get('underline', False),
                    'color': fmt.get('color')
                })
        
        if not formatted_phrases:
            # No formatted text found - add plain text
            paragraph.add_run(text)
            return
        
        # Step 2: Try to find matching phrases in target text
        # Build a list of regions to format in the target
        target_lower = text.lower()
        format_regions = []  # List of (start, end, formatting_dict)
        
        for phrase_info in formatted_phrases:
            source_phrase = phrase_info['text'].lower()
            
            # Try exact match first
            idx = target_lower.find(source_phrase)
            if idx >= 0:
                format_regions.append((idx, idx + len(source_phrase), phrase_info))
                continue
            
            # Try word-by-word matching for multi-word phrases
            source_words = source_phrase.split()
            if len(source_words) > 1:
                # Try to find the first and last word to estimate region
                first_word = source_words[0]
                last_word = source_words[-1]
                
                first_idx = target_lower.find(first_word)
                # Search for last word after first word
                if first_idx >= 0:
                    last_idx = target_lower.find(last_word, first_idx)
                    if last_idx >= 0:
                        # Found a plausible region
                        end_idx = last_idx + len(last_word)
                        # Only use if the region is reasonable (not too different in length)
                        region_len = end_idx - first_idx
                        source_len = len(source_phrase)
                        if 0.3 <= region_len / source_len <= 3.0:
                            format_regions.append((first_idx, end_idx, phrase_info))
        
        if not format_regions:
            # No matches found - just add plain text
            paragraph.add_run(text)
            return
        
        # Step 3: Sort regions and merge overlaps
        format_regions.sort(key=lambda x: x[0])
        
        # Step 4: Build the formatted paragraph with runs
        current_pos = 0
        for start, end, fmt_info in format_regions:
            # Ensure we don't go backwards
            if start < current_pos:
                start = current_pos
            if end <= start:
                continue
            
            # Add unformatted text before this region
            if start > current_pos:
                unformatted_text = text[current_pos:start]
                paragraph.add_run(unformatted_text)
            
            # Add formatted text
            formatted_text = text[start:end]
            run = paragraph.add_run(formatted_text)
            
            if fmt_info.get('bold'):
                run.bold = True
            if fmt_info.get('italic'):
                run.italic = True
            if fmt_info.get('underline'):
                run.underline = True
            
            # Apply color if present
            if fmt_info.get('color'):
                try:
                    from docx.shared import RGBColor
                    hex_color = fmt_info['color']
                    # Convert "FF0000" hex to RGB
                    if len(hex_color) == 6:
                        r = int(hex_color[0:2], 16)
                        g = int(hex_color[2:4], 16)
                        b = int(hex_color[4:6], 16)
                        run.font.color.rgb = RGBColor(r, g, b)
                except Exception:
                    pass
            
            current_pos = end
        
        # Add any remaining unformatted text
        if current_pos < len(text):
            paragraph.add_run(text[current_pos:])
    
    # ========================================================================
    # MEMOQ XLIFF IMPORT/EXPORT
    # ========================================================================
    
    def import_memoq_xliff(self):
        """Import memoQ XLIFF (.mqxliff) file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select memoQ XLIFF File",
            "",
            "memoQ XLIFF (*.mqxliff);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            from modules.mqxliff_handler import MQXLIFFHandler
            
            # Load the file
            handler = MQXLIFFHandler()
            if not handler.load(file_path):
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load memoQ XLIFF file."
                )
                return
            
            # Extract segments (including targets for pretranslated files)
            mqxliff_segments = handler.extract_bilingual_segments()

            if not mqxliff_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments found in the memoQ XLIFF file."
                )
                return

            # Count pretranslated segments
            pretranslated_count = sum(1 for s in mqxliff_segments if s.get('target', '').strip())

            # Convert to internal Segment format
            segments = []
            for i, mq_seg in enumerate(mqxliff_segments):
                # Map status from mqxliff
                status = mq_seg.get('status', 'not_started')
                if status not in ['not_started', 'pre_translated', 'translated', 'confirmed', 'locked']:
                    status = 'not_started'

                segment = Segment(
                    id=i + 1,
                    source=mq_seg.get('source', ''),
                    target=mq_seg.get('target', ''),
                    status=status,
                    notes="",
                )
                segments.append(segment)
            
            # Store the handler and original path for round-trip export
            self.mqxliff_handler = handler
            self.mqxliff_source_file = file_path
            
            # Get language codes from handler
            source_lang = self._normalize_language_code(handler.source_lang)
            target_lang = self._normalize_language_code(handler.target_lang)
            
            # Create new project
            file_name = Path(file_path).stem
            self.current_project = Project(
                name=file_name,
                segments=segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            # Store memoQ XLIFF source path in project for persistence across saves
            self.current_project.mqxliff_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Deactivate all resources for new project, then auto-activate language-matching ones
            self._deactivate_all_resources_for_new_project()

            # Auto-resize rows for better initial display
            self.auto_resize_rows()

            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)

            # Log success
            self.log(f"‚úì Imported {len(segments)} segments from memoQ XLIFF: {Path(file_path).name}")
            self.log(f"  Source: {source_lang}, Target: {target_lang}")
            if pretranslated_count > 0:
                self.log(f"  Pretranslated: {pretranslated_count} segments with target text")

            # Build message with pretranslation info
            msg = f"Successfully imported {len(segments)} segment(s) from memoQ XLIFF.\n\nLanguages: {source_lang} ‚Üí {target_lang}"
            if pretranslated_count > 0:
                msg += f"\n\nPretranslated: {pretranslated_count} segment(s) with target text loaded."

            QMessageBox.information(
                self, "Import Successful",
                msg
            )
        except Exception as e:
            self.log(f"‚ùå Error importing memoQ XLIFF: {e}")
            QMessageBox.critical(
                self, "Import Error",
                f"Error importing memoQ XLIFF file:\n\n{str(e)}"
            )
    
    def _normalize_language_code(self, lang_code: str) -> str:
        """Convert ISO language codes to full language names."""
        # Common ISO 639-1 codes to full names
        lang_map = {
            'en': 'English', 'en-US': 'English', 'en-GB': 'English',
            'nl': 'Dutch', 'nl-NL': 'Dutch', 'nl-BE': 'Dutch',
            'de': 'German', 'de-DE': 'German', 'de-AT': 'German',
            'fr': 'French', 'fr-FR': 'French', 'fr-BE': 'French',
            'es': 'Spanish', 'es-ES': 'Spanish', 'es-MX': 'Spanish',
            'it': 'Italian', 'it-IT': 'Italian',
            'pt': 'Portuguese', 'pt-PT': 'Portuguese', 'pt-BR': 'Portuguese',
            'pl': 'Polish', 'pl-PL': 'Polish',
            'cs': 'Czech', 'cs-CZ': 'Czech',
            'sk': 'Slovak', 'sk-SK': 'Slovak',
            'hu': 'Hungarian', 'hu-HU': 'Hungarian',
            'ro': 'Romanian', 'ro-RO': 'Romanian',
            'bg': 'Bulgarian', 'bg-BG': 'Bulgarian',
            'el': 'Greek', 'el-GR': 'Greek',
            'ru': 'Russian', 'ru-RU': 'Russian',
            'uk': 'Ukrainian', 'uk-UA': 'Ukrainian',
            'ja': 'Japanese', 'ja-JP': 'Japanese',
            'zh': 'Chinese', 'zh-CN': 'Chinese', 'zh-TW': 'Chinese',
            'ko': 'Korean', 'ko-KR': 'Korean',
            'ar': 'Arabic', 'ar-SA': 'Arabic',
            'he': 'Hebrew', 'he-IL': 'Hebrew',
            'tr': 'Turkish', 'tr-TR': 'Turkish',
            'sv': 'Swedish', 'sv-SE': 'Swedish',
            'da': 'Danish', 'da-DK': 'Danish',
            'fi': 'Finnish', 'fi-FI': 'Finnish',
            'no': 'Norwegian', 'nb-NO': 'Norwegian', 'nn-NO': 'Norwegian',
        }
        
        # Try exact match first
        if lang_code in lang_map:
            return lang_map[lang_code]
        
        # Try lowercase match
        lang_lower = lang_code.lower()
        if lang_lower in lang_map:
            return lang_map[lang_lower]
        
        # Try base code (before hyphen)
        if '-' in lang_code:
            base_code = lang_code.split('-')[0].lower()
            if base_code in lang_map:
                return lang_map[base_code]
        
        # Return original if no match found
        return lang_code
    
    def export_memoq_xliff(self):
        """Export to memoQ XLIFF format with translations"""
        # Check if we have segments
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Data", "No segments to export")
            return
        
        # Check if a memoQ XLIFF source file was imported - check both instance var and project
        mqxliff_source = None
        if hasattr(self, 'mqxliff_source_file') and self.mqxliff_source_file:
            mqxliff_source = self.mqxliff_source_file
        elif hasattr(self.current_project, 'mqxliff_source_path') and self.current_project.mqxliff_source_path:
            mqxliff_source = self.current_project.mqxliff_source_path
            # Verify it still exists
            if Path(mqxliff_source).exists():
                self.mqxliff_source_file = mqxliff_source
                self.log(f"‚úì Restored memoQ XLIFF source from project: {Path(mqxliff_source).name}")
                # Reload the handler
                try:
                    from modules.mqxliff_handler import MQXLIFFHandler
                    self.mqxliff_handler = MQXLIFFHandler()
                    if not self.mqxliff_handler.load(mqxliff_source):
                        QMessageBox.critical(self, "Error", "Failed to reload memoQ XLIFF source file")
                        return
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to reload memoQ XLIFF file: {str(e)}")
                    return
            else:
                mqxliff_source = None
        
        if not mqxliff_source:
            # Prompt user to select the original memoQ XLIFF file
            reply = QMessageBox.question(
                self, "Select memoQ XLIFF Source File",
                "To export to memoQ XLIFF format, please select the original memoQ XLIFF file.\n\n"
                "This is the file you originally imported from memoQ.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original memoQ XLIFF File",
                    "",
                    "memoQ XLIFF (*.mqxliff);;All Files (*.*)"
                )
                
                if file_path:
                    self.mqxliff_source_file = file_path
                    self.log(f"‚úì memoQ XLIFF source file set: {Path(file_path).name}")
                    
                    # Load the handler
                    try:
                        from modules.mqxliff_handler import MQXLIFFHandler
                        self.mqxliff_handler = MQXLIFFHandler()
                        if not self.mqxliff_handler.load(file_path):
                            QMessageBox.critical(self, "Error", "Failed to load memoQ XLIFF source file")
                            return
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to load memoQ XLIFF file: {str(e)}")
                        return
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return
        
        # Get output file path
        default_name = Path(self.mqxliff_source_file).stem + "_translated.mqxliff"
        output_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Translated memoQ XLIFF",
            default_name,
            "memoQ XLIFF (*.mqxliff);;All Files (*.*)"
        )
        
        if not output_path:
            return
        
        try:
            # Get translations from current segments
            translations = [seg.target for seg in self.current_project.segments]
            
            # Update the handler with translations
            updated_count = self.mqxliff_handler.update_target_segments(translations)
            
            # Save the updated file
            if self.mqxliff_handler.save(output_path):
                self.log(f"‚úì Exported {updated_count} segments to memoQ XLIFF: {Path(output_path).name}")
                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported {updated_count} translated segment(s) to memoQ XLIFF.\n\n"
                    f"File: {Path(output_path).name}\n\n"
                    f"You can now import this file back into memoQ."
                )
            else:
                QMessageBox.critical(
                    self, "Export Error",
                    "Failed to save memoQ XLIFF file."
                )
        except Exception as e:
            self.log(f"‚ùå Error exporting memoQ XLIFF: {e}")
            QMessageBox.critical(
                self, "Export Error",
                f"Error exporting memoQ XLIFF file:\n\n{str(e)}"
            )
    
    # ========================================================================
    # CAFETRAN BILINGUAL DOCX IMPORT/EXPORT
    # ========================================================================
    
    def import_cafetran_bilingual(self):
        """Import CafeTran bilingual DOCX file (table format with pipe symbols)"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select CafeTran Bilingual DOCX File",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            from modules.cafetran_docx_handler import CafeTranDOCXHandler
            
            # Check if this is a valid CafeTran bilingual DOCX
            if not CafeTranDOCXHandler.is_cafetran_bilingual_docx(file_path):
                QMessageBox.warning(
                    self, "Invalid Format",
                    "This file does not appear to be a CafeTran bilingual DOCX.\n\n"
                    "Expected format: Table with columns ID | Source | Target | Notes | *"
                )
                return
            
            # Load the file
            handler = CafeTranDOCXHandler()
            if not handler.load(file_path):
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load CafeTran bilingual DOCX file."
                )
                return
            
            # Extract segments
            cafetran_segments = handler.extract_source_segments()
            
            if not cafetran_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments found in the CafeTran bilingual DOCX file."
                )
                return
            
            # Convert to internal Segment format - preserve pipe symbols for round-trip
            segments = []
            for i, ct_seg in enumerate(cafetran_segments):
                segment = Segment(
                    id=i + 1,
                    source=ct_seg.source_with_pipes,  # Preserve pipe symbols for formatting
                    target=ct_seg.target_with_pipes if ct_seg.target_with_pipes else "",
                    status=STATUSES["pretranslated"].key if ct_seg.target_with_pipes else DEFAULT_STATUS.key,
                    notes=ct_seg.notes,
                )
                segments.append(segment)
            
            # Store the handler and original path for round-trip export
            self.cafetran_handler = handler
            self.cafetran_source_file = file_path
            
            # Enable CafeTran-specific highlighting (red pipe symbols)
            TagHighlighter._is_cafetran_project = True
            
            # Create new project
            file_name = Path(file_path).stem
            self.current_project = Project(
                name=file_name,
                segments=segments,
                source_lang=self.source_lang_combo.currentText() if hasattr(self, 'source_lang_combo') else "en",
                target_lang=self.target_lang_combo.currentText() if hasattr(self, 'target_lang_combo') else "nl"
            )
            
            # Store CafeTran source path in project for persistence across saves
            self.current_project.cafetran_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = self.current_project.source_lang
            self.target_language = self.current_project.target_lang

            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Deactivate all resources for new project, then auto-activate language-matching ones
            self._deactivate_all_resources_for_new_project()

            # Auto-resize rows for better initial display
            self.auto_resize_rows()

            # Initialize spellcheck for target language
            target_lang = self.current_project.target_lang if self.current_project else 'nl'
            self._initialize_spellcheck_for_target_language(target_lang)

            # Log success
            self.log(f"‚úì Imported {len(segments)} segments from CafeTran bilingual DOCX: {Path(file_path).name}")
            
            QMessageBox.information(
                self, "Import Successful",
                f"Successfully imported {len(segments)} segment(s) from CafeTran bilingual DOCX.\n\n"
                f"File: {Path(file_path).name}\n\n"
                f"Note: Pipe symbol formatting (|) is preserved for export.\n"
                f"You can export back to CafeTran format after translation."
            )
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for CafeTran bilingual DOCX import.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import CafeTran bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó CafeTran import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def import_trados_bilingual(self):
        """Import Trados Studio bilingual review DOCX file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Trados Bilingual Review DOCX File",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        # Show important workflow dialog with critical preparation steps
        workflow_dialog = QMessageBox(self)
        workflow_dialog.setWindowTitle("‚ö†Ô∏è Important: Trados Bilingual Review Workflow")
        workflow_dialog.setIcon(QMessageBox.Icon.Warning)
        workflow_dialog.setText(
            "<b>The Trados bilingual review format requires specific preparation!</b><br><br>"
            "This format is designed for <b>review only</b>, not translation from scratch. "
            "For the round-trip to work correctly, you must prepare the file in Trados first."
        )
        workflow_dialog.setInformativeText(
            "<b>Required Preparation Steps in Trados Studio:</b><br><br>"
            "1. Import your document into Trados Studio<br>"
            "2. Select all segments (Ctrl+A)<br>"
            "3. Copy source to target for all segments<br>"
            "4. Save project<br>"
            "5. Export ‚Üí Bilingual Review (DOCX)<br>"
            "6. Open in Word, select all target text, delete it, save<br><br>"
            "<b>Then in Supervertaler:</b><br>"
            "7. Import the prepared bilingual review DOCX<br>"
            "8. Translate with AI<br>"
            "9. Export ‚Üí Trados Studio ‚Üí Bilingual Review<br>"
            "10. Update from bilingual review in Trados<br><br>"
            "<i>See Help ‚Üí CAT Tool Workflow Guide for details.</i>"
        )
        workflow_dialog.setStandardButtons(
            QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel
        )
        workflow_dialog.setDefaultButton(QMessageBox.StandardButton.Ok)
        workflow_dialog.button(QMessageBox.StandardButton.Ok).setText("I understand, continue")
        workflow_dialog.button(QMessageBox.StandardButton.Cancel).setText("Cancel import")
        
        if workflow_dialog.exec() != QMessageBox.StandardButton.Ok:
            self.log("‚úó User cancelled Trados import")
            return
        
        try:
            from modules.trados_docx_handler import TradosDOCXHandler, detect_bilingual_docx_type
            
            # Check if this is a valid Trados bilingual DOCX
            file_type = detect_bilingual_docx_type(file_path)
            if file_type != "trados":
                QMessageBox.warning(
                    self, "Invalid Format",
                    "This file does not appear to be a Trados bilingual review DOCX.\n\n"
                    "Expected format: Table with columns:\n"
                    "Segment ID | Segment status | Source segment | Target segment"
                )
                return
            
            # Load the file
            handler = TradosDOCXHandler()
            if not handler.load(file_path):
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load Trados bilingual review DOCX file."
                )
                return
            
            # Extract segments
            trados_segments = handler.extract_source_segments()
            
            if not trados_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments found in the Trados bilingual review DOCX file."
                )
                return
            
            # Convert to internal Segment format - preserve tags for round-trip
            segments = []
            for i, t_seg in enumerate(trados_segments):
                segment = Segment(
                    id=i + 1,
                    source=t_seg.source_text,  # Preserve tags like <11>text</11>
                    target=t_seg.target_text if t_seg.target_text else "",
                    status=STATUSES["pretranslated"].key if t_seg.target_text else DEFAULT_STATUS.key,
                    notes=f"Trados Status: {t_seg.status}",
                )
                segments.append(segment)
            
            # Store the handler and original path for round-trip export
            self.trados_handler = handler
            self.trados_source_file = file_path
            
            # Note: trados_source_path will be set on the project after it's created
            
            # Show language selection dialog (Trados files don't specify languages)
            from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDialogButtonBox, QGroupBox
            
            lang_dialog = QDialog(self)
            lang_dialog.setWindowTitle("Select Languages")
            lang_dialog.setMinimumWidth(350)
            lang_layout = QVBoxLayout(lang_dialog)
            
            # Info text
            info_label = QLabel(
                "Trados bilingual review files do not specify the source and target languages.\n"
                "Please select the correct language pair for this project:"
            )
            info_label.setWordWrap(True)
            info_label.setStyleSheet("color: #666; margin-bottom: 10px;")
            lang_layout.addWidget(info_label)
            
            # Language group
            lang_group = QGroupBox("Language Pair")
            lang_group_layout = QVBoxLayout(lang_group)
            
            # Source language
            source_row = QHBoxLayout()
            source_row.addWidget(QLabel("Source Language:"))
            source_combo = QComboBox()
            # Full language list (same as New Project dialog)
            available_languages = [
                "Afrikaans", "Albanian", "Arabic", "Armenian", "Basque", "Bengali",
                "Bulgarian", "Catalan", "Chinese (Simplified)", "Chinese (Traditional)",
                "Croatian", "Czech", "Danish", "Dutch", "English", "Estonian",
                "Finnish", "French", "Galician", "Georgian", "German", "Greek",
                "Hebrew", "Hindi", "Hungarian", "Icelandic", "Indonesian", "Irish",
                "Italian", "Japanese", "Korean", "Latvian", "Lithuanian", "Macedonian",
                "Malay", "Norwegian", "Persian", "Polish", "Portuguese", "Romanian",
                "Russian", "Serbian", "Slovak", "Slovenian", "Spanish", "Swahili",
                "Swedish", "Thai", "Turkish", "Ukrainian", "Urdu", "Vietnamese", "Welsh"
            ]
            source_combo.addItems(available_languages)
            # Try to match current UI selection
            current_source = self.source_lang_combo.currentText() if hasattr(self, 'source_lang_combo') else "English"
            source_idx = source_combo.findText(current_source)
            if source_idx >= 0:
                source_combo.setCurrentIndex(source_idx)
            source_row.addWidget(source_combo)
            lang_group_layout.addLayout(source_row)

            # Target language
            target_row = QHBoxLayout()
            target_row.addWidget(QLabel("Target Language:"))
            target_combo = QComboBox()
            target_combo.addItems(available_languages)
            # Try to match current UI selection
            current_target = self.target_lang_combo.currentText() if hasattr(self, 'target_lang_combo') else "Dutch"
            target_idx = target_combo.findText(current_target)
            if target_idx >= 0:
                target_combo.setCurrentIndex(target_idx)
            target_row.addWidget(target_combo)
            lang_group_layout.addLayout(target_row)

            lang_layout.addWidget(lang_group)

            # Buttons
            lang_buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
            lang_buttons.accepted.connect(lang_dialog.accept)
            lang_buttons.rejected.connect(lang_dialog.reject)
            lang_layout.addWidget(lang_buttons)

            if lang_dialog.exec() != QDialog.DialogCode.Accepted:
                self.log("‚úó User cancelled Trados import during language selection")
                return
            
            source_lang = source_combo.currentText()
            target_lang = target_combo.currentText()
            
            # Create new project with user-selected languages
            file_name = Path(file_path).stem
            self.current_project = Project(
                name=file_name,
                segments=segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            # Store Trados source path in project for persistence across saves
            self.current_project.trados_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Deactivate all resources for new project, then auto-activate language-matching ones
            self._deactivate_all_resources_for_new_project()

            # Auto-resize rows for better initial display
            self.auto_resize_rows()

            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)

            # Count segments with tags
            tagged_count = sum(1 for s in trados_segments if s.source_tags)
            
            # Log success
            self.log(f"‚úì Imported {len(segments)} segments from Trados bilingual DOCX: {Path(file_path).name}")
            if tagged_count:
                self.log(f"  {tagged_count} segments contain inline tags")
            
            QMessageBox.information(
                self, "Import Successful",
                f"Successfully imported {len(segments)} segment(s) from Trados bilingual review DOCX.\n\n"
                f"File: {Path(file_path).name}\n"
                f"Languages: {source_lang} ‚Üí {target_lang}\n"
                f"Segments with tags: {tagged_count}\n\n"
                f"Note: Inline tags (e.g., <11>text</11>) are preserved for export.\n"
                f"Export back to Trados format after translation to maintain tag styling."
            )
            
        except ImportError as e:
            QMessageBox.critical(
                self, "Missing Dependency",
                f"Required library is missing: {e}\n\n"
                "Install dependencies with: pip install python-docx lxml"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import Trados bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó Trados import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_trados_bilingual(self):
        """Export translations back to Trados bilingual review DOCX format"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "No project is currently loaded.")
            return
        
        # Check if we have a Trados source - either from handler or project data
        trados_source = None
        
        # First check if handler is already loaded
        if hasattr(self, 'trados_handler') and self.trados_handler:
            trados_source = getattr(self, 'trados_source_file', None)
        
        # If not, check if project has the source path saved
        if not trados_source and hasattr(self.current_project, 'trados_source_path') and self.current_project.trados_source_path:
            trados_source = self.current_project.trados_source_path
        
        if not trados_source:
            # Prompt user to select the original Trados bilingual file
            reply = QMessageBox.question(
                self, "Select Trados Source File",
                "To export to Trados format, please select the original Trados bilingual review DOCX file.\n\n"
                "This is the file you originally imported from Trados.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original Trados Bilingual Review DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )
                
                if file_path:
                    trados_source = file_path
                    self.trados_source_file = file_path
                    # Also save to project for future exports
                    self.current_project.trados_source_path = file_path
                    self.log(f"‚úì Trados source file set: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return
        
        # Check if source file still exists
        if not Path(trados_source).exists():
            # File not found - give user a chance to locate it
            reply = QMessageBox.question(
                self, "Source File Not Found",
                f"The original Trados source file cannot be found:\n\n"
                f"{trados_source}\n\n"
                f"Would you like to browse for the file in its new location?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original Trados Bilingual Review DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )
                
                if file_path:
                    trados_source = file_path
                    self.trados_source_file = file_path
                    self.current_project.trados_source_path = file_path
                    self.log(f"‚úì Trados source file relocated: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return
        
        # Reload the handler if needed
        if not hasattr(self, 'trados_handler') or not self.trados_handler:
            try:
                from modules.trados_docx_handler import TradosDOCXHandler
                self.trados_handler = TradosDOCXHandler()
                if not self.trados_handler.load(trados_source):
                    QMessageBox.critical(self, "Error", "Failed to reload the Trados source file.")
                    return
                self.trados_source_file = trados_source
                self.log(f"‚úì Reloaded Trados source file for export")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reload Trados source:\n\n{str(e)}")
                return
        
        # Suggest output filename
        source_path = Path(self.trados_source_file)
        suggested_name = source_path.stem + "_translated" + source_path.suffix
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Trados Bilingual DOCX",
            str(source_path.parent / suggested_name),
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            # Collect translations from grid
            translations = {}
            for row in range(self.table.rowCount()):
                target_widget = self.table.cellWidget(row, 3)  # Target column
                if target_widget:
                    target_text = target_widget.toPlainText().strip()
                    if target_text:
                        # Row index in handler is 1-based (row 0 is header)
                        translations[row + 1] = target_text
            
            # Update the handler with translations
            updated = self.trados_handler.update_target_segments(translations)
            
            # Save to new file
            if self.trados_handler.save(file_path):
                self.log(f"‚úì Exported {updated} translated segments to Trados DOCX: {Path(file_path).name}")
                
                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported {updated} translation(s) to Trados bilingual DOCX.\n\n"
                    f"File: {Path(file_path).name}\n\n"
                    f"This file can be imported back into Trados Studio.\n"
                    f"Tag formatting has been preserved."
                )
            else:
                QMessageBox.critical(self, "Export Error", "Failed to save the Trados bilingual DOCX file.")
                
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export Trados bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó Trados export failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def import_sdlppx_package(self):
        """Import a Trados Studio SDLPPX package file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Trados Studio Package (SDLPPX)",
            "",
            "Trados Packages (*.sdlppx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            from modules.sdlppx_handler import TradosPackageHandler
            
            # Load the package
            handler = TradosPackageHandler(log_callback=self.log)
            package = handler.load_package(file_path)
            
            if not package:
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load the Trados Studio package.\n\n"
                    "Please ensure the file is a valid .sdlppx file."
                )
                return
            
            # Show package info dialog
            from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QDialogButtonBox, QGroupBox, QTextEdit
            
            info_dialog = QDialog(self)
            info_dialog.setWindowTitle("Trados Package Information")
            info_dialog.setMinimumWidth(500)
            info_layout = QVBoxLayout(info_dialog)
            
            # Project info and file list
            info_text = f"<b>Project:</b> {package.project_name}<br>"
            info_text += f"<b>Languages:</b> {package.source_lang} ‚Üí {package.target_lang}<br>"
            
            # Count segments
            total_segments = sum(len(f.segments) for f in package.xliff_files)
            file_info = [(Path(f.file_path).name, len(f.segments)) for f in package.xliff_files]
            
            info_text += f"<b>Total segments:</b> {total_segments}<br><br>"
            info_text += "<b>Files in package:</b><br>"
            for fname, count in file_info:
                info_text += f"  ‚Ä¢ {fname}: {count} segments<br>"
            
            info_label = QLabel(info_text)
            info_label.setWordWrap(True)
            info_layout.addWidget(info_label)
            
            # Buttons
            buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
            buttons.button(QDialogButtonBox.StandardButton.Ok).setText("Import")
            buttons.accepted.connect(info_dialog.accept)
            buttons.rejected.connect(info_dialog.reject)
            info_layout.addWidget(buttons)
            
            if info_dialog.exec() != QDialog.DialogCode.Accepted:
                self.log("‚úó User cancelled SDLPPX import")
                handler.cleanup()
                return
            
            # Get all segments from the package
            all_segments = handler.get_all_segments()
            
            if not all_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No translatable segments found in the package."
                )
                handler.cleanup()
                return
            
            # Convert to internal Segment format with proper status mapping
            segments = []
            for i, sdl_seg in enumerate(all_segments):
                # Determine status based on origin, match percent, and text-match attribute
                # Match type hierarchy (highest to lowest confidence):
                # - PM (102%): PerfectMatch or double context (memoQ XLT)
                # - CM (101%): Context match (text + preceding segment match)
                # - 100%: Exact text match only
                # - Fuzzy: 75-99%
                # - Repetition: document-match or auto-propagated
                # - MT: machine translation
                
                if sdl_seg.target_text:
                    if sdl_seg.origin == 'tm':
                        # TM match - check for context match vs regular 100%
                        if sdl_seg.match_percent >= 100:
                            # Check text-match attribute for match type
                            text_match = getattr(sdl_seg, 'text_match', '')
                            if text_match == 'SourceAndTarget':
                                status = STATUSES["cm"].key  # Context match (101%)
                            else:
                                status = STATUSES["tm_100"].key  # Regular 100% match
                        elif sdl_seg.match_percent >= 75:
                            status = STATUSES["tm_fuzzy"].key  # Fuzzy match
                        else:
                            status = STATUSES["pretranslated"].key
                    elif sdl_seg.origin == 'perfect-match':
                        status = STATUSES["pm"].key  # PerfectMatch (102%)
                    elif sdl_seg.origin in ('document-match', 'auto-propagated'):
                        status = STATUSES["repetition"].key  # Internal repetition
                    elif sdl_seg.origin in ('nmt', 'mt', 'machine-translation', 'auto-translation'):
                        status = STATUSES["machine_translated"].key  # Machine translation
                    elif sdl_seg.origin == 'interactive':
                        status = STATUSES["translated"].key  # Manually translated
                    else:
                        status = STATUSES["pretranslated"].key  # Default for other pretranslated
                else:
                    status = DEFAULT_STATUS.key  # Not translated
                
                # Build notes with origin info
                origin_info = ""
                if sdl_seg.origin:
                    text_match = getattr(sdl_seg, 'text_match', '')
                    if sdl_seg.origin == 'tm' and sdl_seg.match_percent > 0:
                        if text_match == 'SourceAndTarget':
                            origin_info = f" | Origin: CM (101%)"
                        else:
                            origin_info = f" | Origin: TM {sdl_seg.match_percent}%"
                    elif sdl_seg.origin == 'perfect-match':
                        origin_info = " | Origin: PM (102%)"
                    elif sdl_seg.origin in ('nmt', 'mt'):
                        origin_info = " | Origin: MT"
                    elif sdl_seg.origin in ('document-match', 'auto-propagated'):
                        origin_info = " | Origin: Repetition"
                    else:
                        origin_info = f" | Origin: {sdl_seg.origin}"
                
                segment = Segment(
                    id=i + 1,
                    source=sdl_seg.source_text,
                    target=sdl_seg.target_text if sdl_seg.target_text else "",
                    status=status,
                    notes=f"SDLXLIFF: {Path(sdl_seg.file_path).name} | Segment: {sdl_seg.segment_id}{origin_info}"
                )
                segments.append(segment)
            
            # Map language codes to full names
            lang_map = {
                'en': 'English', 'en-us': 'English', 'en-gb': 'English',
                'nl': 'Dutch', 'nl-nl': 'Dutch', 'nl-be': 'Dutch',
                'de': 'German', 'de-de': 'German', 'de-at': 'German', 'de-ch': 'German',
                'fr': 'French', 'fr-fr': 'French', 'fr-be': 'French', 'fr-ca': 'French',
                'es': 'Spanish', 'es-es': 'Spanish', 'es-mx': 'Spanish',
                'it': 'Italian', 'it-it': 'Italian',
                'pt': 'Portuguese', 'pt-pt': 'Portuguese', 'pt-br': 'Portuguese',
                'pl': 'Polish', 'pl-pl': 'Polish',
                'zh': 'Chinese', 'zh-cn': 'Chinese', 'zh-tw': 'Chinese',
                'ja': 'Japanese', 'ja-jp': 'Japanese',
                'ko': 'Korean', 'ko-kr': 'Korean',
                'ru': 'Russian', 'ru-ru': 'Russian',
            }
            
            source_lang = lang_map.get(package.source_lang.lower(), package.source_lang)
            target_lang = lang_map.get(package.target_lang.lower(), package.target_lang)
            
            # Create new project
            self.current_project = Project(
                name=package.project_name or Path(file_path).stem,
                segments=segments,
                source_lang=source_lang,
                target_lang=target_lang
            )
            
            # Store handler and package info for round-trip export
            self.sdlppx_handler = handler
            self.sdlppx_source_file = file_path
            self.current_project.sdlppx_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Auto-resize rows for better initial display
            self.auto_resize_rows()
            
            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)
            
            # Count pretranslated segments
            pretrans_count = sum(1 for s in segments if s.target)
            
            self.log(f"‚úì Imported {len(segments)} segments from Trados package: {Path(file_path).name}")
            if pretrans_count:
                self.log(f"  {pretrans_count} segments are pretranslated")
            
            QMessageBox.information(
                self, "Import Successful",
                f"Successfully imported {len(segments)} segment(s) from Trados Studio package.\n\n"
                f"File: {Path(file_path).name}\n"
                f"Languages: {source_lang} ‚Üí {target_lang}\n"
                f"Pretranslated: {pretrans_count}\n\n"
                f"After translation, export back as SDLRPX to return to the Trados user."
            )
            
        except ImportError as e:
            QMessageBox.critical(
                self, "Missing Dependency",
                f"Required library is missing: {e}\n\n"
                "Install dependencies with: pip install lxml"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import Trados package:\n\n{str(e)}")
            self.log(f"‚úó SDLPPX import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_sdlrpx_package(self):
        """Export translations back to a Trados Studio SDLRPX return package."""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "No project is currently loaded.")
            return
        
        # Check if we have an SDLPPX handler
        sdlppx_source = None
        
        if hasattr(self, 'sdlppx_handler') and self.sdlppx_handler:
            sdlppx_source = getattr(self, 'sdlppx_source_file', None)
        
        if not sdlppx_source and hasattr(self.current_project, 'sdlppx_source_path'):
            sdlppx_source = self.current_project.sdlppx_source_path
        
        if not sdlppx_source:
            QMessageBox.warning(
                self, "No SDLPPX Source",
                "This project was not imported from an SDLPPX package.\n\n"
                "To export as SDLRPX, you must first import an SDLPPX package."
            )
            return
        
        # Check if source exists
        if not Path(sdlppx_source).exists():
            # Try to locate the file
            reply = QMessageBox.question(
                self, "Source Package Not Found",
                f"The original SDLPPX package cannot be found:\n\n"
                f"{sdlppx_source}\n\n"
                f"Would you like to browse for the file?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original SDLPPX Package",
                    "",
                    "Trados Packages (*.sdlppx);;All Files (*.*)"
                )
                
                if file_path:
                    sdlppx_source = file_path
                    self.sdlppx_source_file = file_path
                    self.current_project.sdlppx_source_path = file_path
                else:
                    return
            else:
                return
        
        # Reload handler if needed
        if not hasattr(self, 'sdlppx_handler') or not self.sdlppx_handler:
            try:
                from modules.sdlppx_handler import TradosPackageHandler
                self.sdlppx_handler = TradosPackageHandler(log_callback=self.log)
                package = self.sdlppx_handler.load_package(sdlppx_source)
                if not package:
                    QMessageBox.critical(self, "Error", "Failed to reload the SDLPPX package.")
                    return
                self.sdlppx_source_file = sdlppx_source
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reload SDLPPX:\n\n{str(e)}")
                return
        
        # Suggest output filename
        source_path = Path(sdlppx_source)
        suggested_name = source_path.stem + ".sdlrpx"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Trados Return Package (SDLRPX)",
            str(source_path.parent / suggested_name),
            "Trados Return Packages (*.sdlrpx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            # Collect translations from segments (notes are stored in segment objects, not table items)
            # Build mapping from segment_id to translation
            translations = {}
            
            # First sync grid targets to segment objects to ensure we have latest edits
            self._sync_grid_targets_to_segments(self.current_project.segments)
            
            for idx, segment in enumerate(self.current_project.segments):
                notes = getattr(segment, 'notes', '') or ''
                target_text = segment.target.strip() if segment.target else ''
                
                # Extract segment_id from notes
                # Format: "SDLXLIFF: filename.sdlxliff | Segment: {segment_id} | Origin: ..."
                if "Segment:" in notes:
                    parts = notes.split("|")
                    if len(parts) >= 2:
                        seg_part = parts[1].replace("Segment:", "").strip()
                        if target_text:
                            translations[seg_part] = target_text
            
            # Update the handler with translations
            updated = self.sdlppx_handler.update_translations(translations)
            
            # Export return package
            result_path = self.sdlppx_handler.create_return_package(file_path)
            
            if result_path:
                self.log(f"‚úì Exported {updated} translated segments to SDLRPX: {Path(file_path).name}")
                
                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported Trados return package.\n\n"
                    f"File: {Path(file_path).name}\n"
                    f"Translations updated: {updated}\n\n"
                    f"This file can be imported back into Trados Studio by the project manager."
                )
            else:
                QMessageBox.critical(self, "Export Error", "Failed to create the SDLRPX return package.")
                
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export SDLRPX:\n\n{str(e)}")
            self.log(f"‚úó SDLRPX export failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def import_phrase_bilingual(self):
        """Import Phrase (Memsource) bilingual DOCX file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Phrase Bilingual DOCX File",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )

        if not file_path:
            return

        # Show confirmation dialog
        reply = QMessageBox.question(
            self,
            "Confirm Phrase Bilingual Import",
            f"You are about to import a Phrase (Memsource) bilingual DOCX file.\n\n"
            f"File: {Path(file_path).name}\n\n"
            f"This workflow is specifically for Phrase bilingual files with:\n"
            f"‚Ä¢ Multiple tables with 7 columns\n"
            f"‚Ä¢ Inline tags like {{1}}, {{1>text<1}}\n"
            f"‚Ä¢ Editable target column (Column 5)\n\n"
            f"The project can be exported back to Phrase format after translation.\n\n"
            f"Continue with import?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            self.log("‚úó User cancelled Phrase import")
            return

        try:
            from modules.phrase_docx_handler import PhraseDOCXHandler
            from modules.trados_docx_handler import detect_bilingual_docx_type

            # Check if this is a valid Phrase bilingual DOCX
            file_type = detect_bilingual_docx_type(file_path)
            if file_type != "phrase":
                QMessageBox.warning(
                    self, "Invalid Format",
                    "This file does not appear to be a Phrase bilingual DOCX.\n\n"
                    "Expected format: Multiple tables with 7-8 columns and segment IDs containing ':'."
                )
                return

            # Load the file
            handler = PhraseDOCXHandler()
            if not handler.load(file_path):
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load Phrase bilingual DOCX file."
                )
                return

            # Extract segments
            phrase_segments = handler.extract_source_segments()

            if not phrase_segments:
                QMessageBox.warning(
                    self, "No Segments",
                    "No segments found in the Phrase bilingual DOCX file."
                )
                return

            # Convert to internal Segment format - preserve tags for round-trip
            segments = []
            for i, p_seg in enumerate(phrase_segments):
                segment = Segment(
                    id=i + 1,
                    source=p_seg.source_text,  # Preserve tags like {1}text{1}
                    target=p_seg.target_text if p_seg.target_text else "",
                    status=STATUSES["pretranslated"].key if p_seg.target_text else DEFAULT_STATUS.key,
                    notes=f"Phrase ID: {p_seg.segment_id} | Status: {p_seg.status_code}",
                )
                segments.append(segment)

            # Store the handler and original path for round-trip export
            self.phrase_handler = handler
            self.phrase_source_file = file_path

            # Show language selection dialog (Phrase files may not clearly specify languages)
            from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDialogButtonBox, QGroupBox

            lang_dialog = QDialog(self)
            lang_dialog.setWindowTitle("Select Languages")
            lang_dialog.setMinimumWidth(350)
            lang_layout = QVBoxLayout(lang_dialog)

            # Info text
            info_label = QLabel(
                "Please confirm or select the correct language pair for this project:"
            )
            info_label.setWordWrap(True)
            info_label.setStyleSheet("color: #666; margin-bottom: 10px;")
            lang_layout.addWidget(info_label)

            # Language group
            lang_group = QGroupBox("Language Pair")
            lang_group_layout = QVBoxLayout(lang_group)

            # Source language
            source_row = QHBoxLayout()
            source_row.addWidget(QLabel("Source Language:"))
            source_combo = QComboBox()
            # Full language list (same as New Project dialog)
            available_languages = [
                "Afrikaans", "Albanian", "Arabic", "Armenian", "Basque", "Bengali",
                "Bulgarian", "Catalan", "Chinese (Simplified)", "Chinese (Traditional)",
                "Croatian", "Czech", "Danish", "Dutch", "English", "Estonian",
                "Finnish", "French", "Galician", "Georgian", "German", "Greek",
                "Hebrew", "Hindi", "Hungarian", "Icelandic", "Indonesian", "Irish",
                "Italian", "Japanese", "Korean", "Latvian", "Lithuanian", "Macedonian",
                "Malay", "Norwegian", "Persian", "Polish", "Portuguese", "Romanian",
                "Russian", "Serbian", "Slovak", "Slovenian", "Spanish", "Swahili",
                "Swedish", "Thai", "Turkish", "Ukrainian", "Urdu", "Vietnamese", "Welsh"
            ]
            source_combo.addItems(available_languages)
            # Try to match current UI selection
            current_source = self.source_lang_combo.currentText() if hasattr(self, 'source_lang_combo') else "English"
            source_idx = source_combo.findText(current_source)
            if source_idx >= 0:
                source_combo.setCurrentIndex(source_idx)
            source_row.addWidget(source_combo)
            lang_group_layout.addLayout(source_row)

            # Target language
            target_row = QHBoxLayout()
            target_row.addWidget(QLabel("Target Language:"))
            target_combo = QComboBox()
            target_combo.addItems(available_languages)
            # Try to match current UI selection
            current_target = self.target_lang_combo.currentText() if hasattr(self, 'target_lang_combo') else "Dutch"
            target_idx = target_combo.findText(current_target)
            if target_idx >= 0:
                target_combo.setCurrentIndex(target_idx)
            target_row.addWidget(target_combo)
            lang_group_layout.addLayout(target_row)

            lang_layout.addWidget(lang_group)

            # Buttons
            lang_buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
            lang_buttons.accepted.connect(lang_dialog.accept)
            lang_buttons.rejected.connect(lang_dialog.reject)
            lang_layout.addWidget(lang_buttons)

            if lang_dialog.exec() != QDialog.DialogCode.Accepted:
                self.log("‚úó User cancelled Phrase import during language selection")
                return

            source_lang = source_combo.currentText()
            target_lang = target_combo.currentText()

            # Create new project with user-selected languages
            file_name = Path(file_path).stem
            self.current_project = Project(
                name=file_name,
                segments=segments,
                source_lang=source_lang,
                target_lang=target_lang
            )

            # Store Phrase source path in project for persistence across saves
            self.current_project.phrase_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Auto-resize rows for better initial display
            self.auto_resize_rows()
            
            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)

            # Count segments with tags
            tagged_count = sum(1 for s in phrase_segments if s.source_tags)

            # Log success
            self.log(f"‚úì Imported {len(segments)} segments from Phrase bilingual DOCX: {Path(file_path).name}")
            if tagged_count:
                self.log(f"  {tagged_count} segments contain inline tags")

            QMessageBox.information(
                self, "Import Successful",
                f"Successfully imported {len(segments)} segment(s) from Phrase bilingual DOCX.\n\n"
                f"File: {Path(file_path).name}\n"
                f"Languages: {source_lang} ‚Üí {target_lang}\n"
                f"Segments with tags: {tagged_count}\n\n"
                f"Note: Inline tags (e.g., {{1}}, {{1>text<1}}) are preserved for export.\n"
                f"Export back to Phrase format after translation to maintain compatibility."
            )

        except ImportError as e:
            QMessageBox.critical(
                self, "Missing Dependency",
                f"Required library is missing: {e}\n\n"
                "Install dependencies with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import Phrase bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó Phrase import failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def export_phrase_bilingual(self):
        """Export translations back to Phrase bilingual DOCX format"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "No project is currently loaded.")
            return

        # Check if we have a Phrase source - either from handler or project data
        phrase_source = None

        # First check if handler is already loaded
        if hasattr(self, 'phrase_handler') and self.phrase_handler:
            phrase_source = getattr(self, 'phrase_source_file', None)

        # If not, check if project has the source path saved
        if not phrase_source and hasattr(self.current_project, 'phrase_source_path') and self.current_project.phrase_source_path:
            phrase_source = self.current_project.phrase_source_path

        if not phrase_source:
            # Prompt user to select the original Phrase bilingual file
            reply = QMessageBox.question(
                self, "Select Phrase Source File",
                "To export to Phrase format, please select the original Phrase bilingual DOCX file.\n\n"
                "This is the file you originally imported from Phrase.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original Phrase Bilingual DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )

                if file_path:
                    phrase_source = file_path
                    self.phrase_source_file = file_path
                    # Also save to project for future exports
                    self.current_project.phrase_source_path = file_path
                    self.log(f"‚úì Phrase source file set: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return

        # Check if source file still exists
        if not Path(phrase_source).exists():
            # File not found - give user a chance to locate it
            reply = QMessageBox.question(
                self, "Source File Not Found",
                f"The original Phrase source file cannot be found:\n\n"
                f"{phrase_source}\n\n"
                f"Would you like to browse for the file in its new location?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original Phrase Bilingual DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )

                if file_path:
                    phrase_source = file_path
                    self.phrase_source_file = file_path
                    self.current_project.phrase_source_path = file_path
                    self.log(f"‚úì Phrase source file relocated: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return

        # Reload the handler if needed
        if not hasattr(self, 'phrase_handler') or not self.phrase_handler:
            try:
                from modules.phrase_docx_handler import PhraseDOCXHandler
                self.phrase_handler = PhraseDOCXHandler()
                if not self.phrase_handler.load(phrase_source):
                    QMessageBox.critical(self, "Error", "Failed to reload the Phrase source file.")
                    return
                self.phrase_handler.extract_source_segments()  # Ensure segments are loaded
                self.phrase_source_file = phrase_source
                self.log(f"‚úì Reloaded Phrase source file for export")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reload Phrase source:\n\n{str(e)}")
                return

        # Suggest output filename
        source_path = Path(self.phrase_source_file)
        suggested_name = source_path.stem + "_translated" + source_path.suffix

        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Phrase Bilingual DOCX",
            str(source_path.parent / suggested_name),
            "Word Documents (*.docx);;All Files (*.*)"
        )

        if not file_path:
            return

        try:
            # Collect translations from grid - map by segment ID
            # Extract segment IDs from notes field where we stored them
            translations = {}
            for row in range(self.table.rowCount()):
                target_widget = self.table.cellWidget(row, 3)  # Target column
                notes_widget = self.table.cellWidget(row, 4)  # Notes column

                if target_widget and notes_widget:
                    target_text = target_widget.toPlainText().strip()
                    notes_text = notes_widget.toPlainText().strip()

                    # Extract Phrase segment ID from notes (format: "Phrase ID: xxx:nnn | Status: XX")
                    if "Phrase ID:" in notes_text:
                        import re
                        match = re.search(r'Phrase ID: ([^\s|]+)', notes_text)
                        if match and target_text:
                            segment_id = match.group(1)
                            translations[segment_id] = target_text

            # Update the handler with translations
            updated = self.phrase_handler.update_target_segments(translations)

            # Save to new file
            if self.phrase_handler.save(file_path):
                self.log(f"‚úì Exported {updated} translated segments to Phrase DOCX: {Path(file_path).name}")

                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported {updated} translation(s) to Phrase bilingual DOCX.\n\n"
                    f"File: {Path(file_path).name}\n\n"
                    f"This file can be imported back into Phrase (Memsource).\n"
                    f"Only Column 5 (target text) has been updated."
                )
            else:
                QMessageBox.critical(self, "Export Error", "Failed to save the Phrase bilingual DOCX file.")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export Phrase bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó Phrase export failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def import_dejavu_bilingual(self):
        """Import D√©j√† Vu X3 bilingual RTF file (table format)"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select D√©j√† Vu X3 Bilingual RTF File",
            "",
            "RTF Files (*.rtf);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        # Show info dialog about the D√©j√† Vu workflow
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDialogButtonBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("D√©j√† Vu X3 Bilingual Import")
        dialog.setMinimumWidth(450)
        layout = QVBoxLayout(dialog)
        
        # Info text
        info_label = QLabel(
            "This workflow imports D√©j√† Vu X3 bilingual RTF for round-tripping.\n\n"
            "‚Ä¢ D√©j√† Vu inline tags (e.g., {00108}text{00109}) will be preserved\n"
            "‚Ä¢ The project can be exported back to D√©j√† Vu RTF format\n"
            "‚Ä¢ Column structure: ID | Source | Target | Comments"
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Note about tags
        note_label = QLabel(
            "‚ÑπÔ∏è Note: D√©j√† Vu tags {NNNNN} will be highlighted in the translation grid."
        )
        note_label.setWordWrap(True)
        note_label.setStyleSheet("color: #2196F3; font-size: 10px; margin-top: 10px;")
        layout.addWidget(note_label)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return

        try:
            from modules.dejavurtf_handler import DejaVuRTFHandler
            
            # Load the bilingual RTF
            handler = DejaVuRTFHandler()
            if not handler.load(file_path):
                QMessageBox.critical(
                    self, "Error",
                    "Failed to load the D√©j√† Vu RTF file.\n\nPlease check the file format."
                )
                return
            
            # Extract segments
            segments_data = handler.extract_source_segments()
            
            if not segments_data:
                QMessageBox.warning(self, "Warning", "No segments found in the D√©j√† Vu RTF file.")
                return
            
            # Detect languages from handler
            source_lang = handler.source_lang or "nl"
            target_lang = handler.target_lang or "es"
            
            # Store the handler for later export
            self.dejavu_handler = handler
            self.dejavu_source_file = file_path
            
            # Create project
            project_name = Path(file_path).stem
            self.current_project = Project(
                name=project_name,
                source_lang=source_lang,
                target_lang=target_lang,
                segments=[]
            )
            
            # Store D√©j√† Vu source path in project for persistence
            self.current_project.dejavu_source_path = file_path

            # Sync global language settings with imported project languages
            self.source_language = source_lang
            self.target_language = target_lang

            # Create segments
            for idx, seg_data in enumerate(segments_data):
                segment = Segment(
                    id=idx + 1,
                    source=seg_data.source_text,
                    target=seg_data.target_text or '',
                    status="translated" if seg_data.target_text.strip() else "not_started",
                    type="para",
                    notes=seg_data.comment or '',
                    dejavu_segment_id=seg_data.segment_id,
                    dejavu_row_index=seg_data.row_index,
                )
                self.current_project.segments.append(segment)
            
            # Update UI
            self.project_file_path = None
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            self.initialize_tm_database()
            
            # Auto-resize rows for better initial display
            self.auto_resize_rows()
            
            # Initialize spellcheck for target language
            self._initialize_spellcheck_for_target_language(target_lang)
            
            self.log(f"‚úì Imported D√©j√† Vu X3 bilingual RTF: {len(segments_data)} segments from {Path(file_path).name}")

            # Store current document path for AI Assistant
            self.current_document_path = file_path

            # Refresh AI Assistant context
            if hasattr(self, 'prompt_manager_qt'):
                self.prompt_manager_qt.refresh_context()

            QMessageBox.information(
                self, "Import Successful",
                f"Imported {len(segments_data)} segment(s) from D√©j√† Vu X3 bilingual RTF.\n\n"
                f"File: {Path(file_path).name}\n"
                f"Languages: {source_lang.upper()} ‚Üí {target_lang.upper()}\n\n"
                f"D√©j√† Vu tags have been preserved in the source text."
            )
            
        except ImportError as e:
            QMessageBox.critical(
                self, "Import Error",
                f"Failed to import D√©j√† Vu RTF module:\n\n{str(e)}"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import D√©j√† Vu RTF:\n\n{str(e)}")
            self.log(f"‚úó D√©j√† Vu import failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def export_dejavu_bilingual(self):
        """Export translations back to D√©j√† Vu X3 bilingual RTF format"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "No project is currently loaded.")
            return

        # Check if we have a D√©j√† Vu source
        dejavu_source = None

        # First check if handler is already loaded
        if hasattr(self, 'dejavu_handler') and self.dejavu_handler:
            dejavu_source = getattr(self, 'dejavu_source_file', None)

        # If not, check if project has the source path saved
        if not dejavu_source and hasattr(self.current_project, 'dejavu_source_path') and self.current_project.dejavu_source_path:
            dejavu_source = self.current_project.dejavu_source_path

        if not dejavu_source:
            # Prompt user to select the original D√©j√† Vu bilingual file
            reply = QMessageBox.question(
                self, "Select D√©j√† Vu Source File",
                "To export to D√©j√† Vu format, please select the original D√©j√† Vu bilingual RTF file.\n\n"
                "This is the file you originally exported from D√©j√† Vu X3.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original D√©j√† Vu Bilingual RTF",
                    "",
                    "RTF Files (*.rtf);;All Files (*.*)"
                )

                if file_path:
                    dejavu_source = file_path
                    self.dejavu_source_file = file_path
                    self.current_project.dejavu_source_path = file_path
                    self.log(f"‚úì D√©j√† Vu source file set: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return

        # Check if source file still exists
        if not Path(dejavu_source).exists():
            reply = QMessageBox.question(
                self, "Source File Not Found",
                f"The original D√©j√† Vu source file cannot be found:\n\n"
                f"{dejavu_source}\n\n"
                f"Would you like to browse for the file in its new location?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original D√©j√† Vu Bilingual RTF",
                    "",
                    "RTF Files (*.rtf);;All Files (*.*)"
                )

                if file_path:
                    dejavu_source = file_path
                    self.dejavu_source_file = file_path
                    self.current_project.dejavu_source_path = file_path
                    self.log(f"‚úì D√©j√† Vu source file relocated: {Path(file_path).name}")
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return

        # Reload the handler if needed
        if not hasattr(self, 'dejavu_handler') or not self.dejavu_handler:
            try:
                from modules.dejavurtf_handler import DejaVuRTFHandler
                self.dejavu_handler = DejaVuRTFHandler()
                if not self.dejavu_handler.load(dejavu_source):
                    QMessageBox.critical(self, "Error", "Failed to reload the D√©j√† Vu source file.")
                    return
                self.dejavu_handler.extract_source_segments()
                self.dejavu_source_file = dejavu_source
                self.log(f"‚úì Reloaded D√©j√† Vu source file for export")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to reload D√©j√† Vu source:\n\n{str(e)}")
                return

        # Suggest output filename
        source_path = Path(self.dejavu_source_file)
        suggested_name = source_path.stem + "_translated" + source_path.suffix

        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export D√©j√† Vu Bilingual RTF",
            str(source_path.parent / suggested_name),
            "RTF Files (*.rtf);;All Files (*.*)"
        )

        if not file_path:
            return

        try:
            # First sync grid content to project segments
            self._sync_grid_targets_to_segments(self.current_project.segments)
            
            # Collect translations from project segments
            translations = {}
            for segment in self.current_project.segments:
                # Use row_index if available (most reliable for D√©j√† Vu)
                if segment.dejavu_row_index is not None:
                    if segment.target and segment.target.strip():
                        translations[segment.dejavu_row_index] = segment.target
                # Fallback to segment ID mapping
                elif segment.dejavu_segment_id:
                    if segment.target and segment.target.strip():
                        translations[segment.dejavu_segment_id] = segment.target
            
            self.log(f"Collected {len(translations)} translations from project")

            # Update the handler with translations
            if any(isinstance(k, int) for k in translations.keys()):
                # Use row index method
                row_translations = {k: v for k, v in translations.items() if isinstance(k, int)}
                updated = self.dejavu_handler.update_translations_by_index(row_translations)
            else:
                # Use segment ID method
                updated = self.dejavu_handler.update_translations(translations)

            # Save to new file
            if self.dejavu_handler.save(file_path):
                self.log(f"‚úì Exported {updated} translated segments to D√©j√† Vu RTF: {Path(file_path).name}")

                QMessageBox.information(
                    self, "Export Successful",
                    f"Successfully exported {updated} translation(s) to D√©j√† Vu bilingual RTF.\n\n"
                    f"File: {Path(file_path).name}\n\n"
                    f"This file can be imported back into D√©j√† Vu X3.\n"
                    f"D√©j√† Vu tags have been preserved."
                )
            else:
                QMessageBox.critical(self, "Export Error", "Failed to save the D√©j√† Vu bilingual RTF file.")

        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export D√©j√† Vu bilingual RTF:\n\n{str(e)}")
            self.log(f"‚úó D√©j√† Vu export failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def import_review_table(self):
        """Import a Supervertaler Bilingual Table to update translations in current project.
        
        This allows proofreaders to make changes in the exported DOCX bilingual table
        and have those changes re-imported back into the project.
        """
        import re
        
        # Check if we have a project open
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(
                self, "No Project Open",
                "Please open a project first before importing a bilingual table.\n\n"
                "The bilingual table will update translations in the current project."
            )
            return
        
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Bilingual Table DOCX to Import",
            "",
            "Word Documents (*.docx);;All Files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            from docx import Document
            
            doc = Document(file_path)
            
            # Find the table
            if not doc.tables:
                QMessageBox.warning(
                    self, "Invalid Format",
                    "No table found in the document.\n\n"
                    "Expected a Supervertaler Bilingual Table with columns:\n"
                    "#, Source, Target, Status, Notes"
                )
                return
            
            table = doc.tables[0]
            
            # Check header row
            if len(table.rows) < 2:
                QMessageBox.warning(
                    self, "Invalid Format",
                    "The table appears to be empty or has no data rows."
                )
                return
            
            header_row = table.rows[0]
            headers = [cell.text.strip().lower() for cell in header_row.cells]
            
            # Validate headers
            expected_headers = ['#', 'source', 'target', 'status', 'notes']
            if len(headers) < 3:  # At minimum we need #, source, target
                QMessageBox.warning(
                    self, "Invalid Format",
                    f"Expected columns: #, Source, Target, Status, Notes\n"
                    f"Found: {', '.join(headers)}"
                )
                return
            
            # Parse table rows
            imported_data = []
            parse_errors = []
            
            for row_idx, row in enumerate(table.rows[1:], start=1):
                cells = row.cells
                if len(cells) < 3:
                    continue
                
                try:
                    seg_num_text = cells[0].text.strip()
                    if not seg_num_text:
                        continue
                    seg_num = int(seg_num_text)
                    source_text = cells[1].text.strip()
                    target_text = cells[2].text.strip()
                    
                    # Optional fields
                    status_text = cells[3].text.strip() if len(cells) > 3 else ''
                    notes_text = cells[4].text.strip() if len(cells) > 4 else ''
                    
                    imported_data.append({
                        'segment_num': seg_num,
                        'source': source_text,
                        'target': target_text,
                        'status': status_text,
                        'notes': notes_text,
                        'row_idx': row_idx
                    })
                except ValueError as e:
                    parse_errors.append(f"Row {row_idx}: Could not parse segment number")
            
            if not imported_data:
                QMessageBox.warning(
                    self, "No Data Found",
                    "No valid segment data found in the bilingual table."
                )
                return
            
            # Compare with current project and find changes
            current_segments = list(self.current_project.segments)
            changes = []
            mismatches = []
            
            for data in imported_data:
                seg_num = data['segment_num']
                seg_idx = seg_num - 1  # Convert to 0-based index
                
                if seg_idx < 0 or seg_idx >= len(current_segments):
                    mismatches.append(f"Segment {seg_num}: Not found in project (project has {len(current_segments)} segments)")
                    continue
                
                current_seg = current_segments[seg_idx]
                current_source = current_seg.source if hasattr(current_seg, 'source') else ''
                current_target = current_seg.target if hasattr(current_seg, 'target') else ''
                
                # Check if source matches (sanity check)
                if data['source'] != current_source:
                    # Allow for minor whitespace differences
                    if data['source'].strip() != current_source.strip():
                        mismatches.append(f"Segment {seg_num}: Source text mismatch")
                        continue
                
                # Check if target changed
                if data['target'] != current_target:
                    changes.append({
                        'segment_num': seg_num,
                        'segment_idx': seg_idx,
                        'old_target': current_target,
                        'new_target': data['target'],
                        'notes': data['notes']
                    })
            
            if not changes and not mismatches:
                QMessageBox.information(
                    self, "No Changes",
                    f"Compared {len(imported_data)} segments - no changes detected."
                )
                return
            
            # Show preview dialog for changes
            preview_text = f"Found {len(changes)} change(s) to apply:\n\n"
            
            for i, change in enumerate(changes[:10]):  # Show first 10
                preview_text += f"Segment {change['segment_num']}:\n"
                old_preview = change['old_target'][:50] + ('...' if len(change['old_target']) > 50 else '')
                new_preview = change['new_target'][:50] + ('...' if len(change['new_target']) > 50 else '')
                preview_text += f"  Old: {old_preview}\n"
                preview_text += f"  New: {new_preview}\n\n"
            
            if len(changes) > 10:
                preview_text += f"... and {len(changes) - 10} more changes\n\n"
            
            if mismatches:
                preview_text += f"\n‚ö† {len(mismatches)} segment(s) could not be matched:\n"
                for mismatch in mismatches[:5]:
                    preview_text += f"  ‚Ä¢ {mismatch}\n"
                if len(mismatches) > 5:
                    preview_text += f"  ... and {len(mismatches) - 5} more\n"
            
            preview_text += "\nApply these changes?"
            
            reply = QMessageBox.question(
                self, "Review Changes",
                preview_text,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply != QMessageBox.StandardButton.Yes:
                self.log("Bilingual table import cancelled by user")
                return
            
            # Apply changes
            applied_count = 0
            for change in changes:
                seg_idx = change['segment_idx']
                current_segments[seg_idx].target = change['new_target']
                
                # Reset status to 'not_started' - flags segment for translator review
                # This matches the behavior when manually editing a segment
                if hasattr(current_segments[seg_idx], 'status'):
                    current_segments[seg_idx].status = 'not_started'
                
                # Add note if provided
                if change['notes']:
                    if hasattr(current_segments[seg_idx], 'notes'):
                        existing_notes = current_segments[seg_idx].notes or ''
                        if existing_notes:
                            current_segments[seg_idx].notes = f"{existing_notes}\n[Review: {change['notes']}]"
                        else:
                            current_segments[seg_idx].notes = f"[Review: {change['notes']}]"
                    else:
                        current_segments[seg_idx].notes = f"[Review: {change['notes']}]"
                
                applied_count += 1
            
            # Mark project as modified and refresh UI
            self.project_modified = True
            self.update_window_title()
            self.load_segments_to_grid()
            
            self.log(f"‚úì Applied {applied_count} change(s) from bilingual table: {Path(file_path).name}")
            
            QMessageBox.information(
                self, "Import Complete",
                f"Successfully applied {applied_count} change(s) from the bilingual table.\n\n"
                f"Changed segments set to 'Not Started' for translator review.\n"
                f"Notes from the review have been added to segment notes."
            )
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for bilingual table import.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import bilingual table:\n\n{str(e)}")
            self.log(f"‚úó Bilingual table import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def export_cafetran_bilingual(self):
        """Export to CafeTran bilingual DOCX format with translations"""
        # Check if we have segments
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Data", "No segments to export")
            return
        
        # Check if a CafeTran source file was imported - check both instance var and project
        cafetran_source = None
        if hasattr(self, 'cafetran_source_file') and self.cafetran_source_file:
            cafetran_source = self.cafetran_source_file
        elif hasattr(self.current_project, 'cafetran_source_path') and self.current_project.cafetran_source_path:
            cafetran_source = self.current_project.cafetran_source_path
            # Verify it still exists
            if Path(cafetran_source).exists():
                self.cafetran_source_file = cafetran_source
                self.log(f"‚úì Restored CafeTran source from project: {Path(cafetran_source).name}")
                # Reload the handler
                try:
                    from modules.cafetran_docx_handler import CafeTranDOCXHandler
                    self.cafetran_handler = CafeTranDOCXHandler()
                    if not self.cafetran_handler.load(cafetran_source):
                        QMessageBox.critical(self, "Error", "Failed to reload CafeTran source file")
                        return
                    self.cafetran_handler.extract_source_segments()
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to reload CafeTran file: {str(e)}")
                    return
            else:
                cafetran_source = None
        
        if not cafetran_source:
            # Prompt user to select the original CafeTran bilingual file
            reply = QMessageBox.question(
                self, "Select CafeTran Source File",
                "To export to CafeTran format, please select the original CafeTran bilingual DOCX file.\n\n"
                "This is the file you originally imported from CafeTran.\n\n"
                "Would you like to select it now?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                file_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "Select Original CafeTran Bilingual DOCX",
                    "",
                    "Word Documents (*.docx);;All Files (*.*)"
                )
                
                if file_path:
                    self.cafetran_source_file = file_path
                    self.log(f"‚úì CafeTran source file set: {Path(file_path).name}")
                    
                    # Load the handler
                    try:
                        from modules.cafetran_docx_handler import CafeTranDOCXHandler
                        self.cafetran_handler = CafeTranDOCXHandler()
                        if not self.cafetran_handler.load(file_path):
                            QMessageBox.critical(self, "Error", "Failed to load CafeTran source file")
                            return
                        self.cafetran_handler.extract_source_segments()
                    except Exception as e:
                        QMessageBox.critical(self, "Error", f"Failed to load CafeTran file: {str(e)}")
                        return
                else:
                    self.log("Export cancelled - no source file selected")
                    return
            else:
                self.log("Export cancelled")
                return
        
        try:
            from modules.cafetran_docx_handler import CafeTranDOCXHandler
            
            segments = list(self.current_project.segments)
            translations = [seg.target for seg in segments]
            
            if not translations or all(not t.strip() for t in translations):
                QMessageBox.warning(self, "Warning", "No translations found to export.")
                return
            
            # Update the handler with translations
            if hasattr(self, 'cafetran_handler') and self.cafetran_handler:
                handler = self.cafetran_handler
            else:
                handler = CafeTranDOCXHandler()
                if not handler.load(self.cafetran_source_file):
                    QMessageBox.critical(self, "Error", "Failed to load CafeTran source file")
                    return
                handler.extract_source_segments()
            
            # Update target segments with translations
            handler.update_target_segments(translations)
            
            # Prompt user to save the file
            source_path = Path(self.cafetran_source_file)
            default_name = str(source_path.parent / (source_path.stem + "_translated.docx"))
            save_path, _ = QFileDialog.getSaveFileName(
                self,
                "Save CafeTran Bilingual DOCX",
                default_name,
                "Word Documents (*.docx);;All Files (*.*)"
            )
            
            if save_path:
                if handler.save(save_path):
                    self.log(f"‚úì Exported {len(translations)} translations to CafeTran bilingual DOCX: {Path(save_path).name}")
                    
                    QMessageBox.information(
                        self, "Export Successful",
                        f"Successfully exported {len(translations)} translation(s) to CafeTran bilingual DOCX!\n\n"
                        f"File saved: {Path(save_path).name}\n\n"
                        f"‚úì Pipe symbol formatting preserved\n"
                        f"‚úì Table structure preserved\n\n"
                        f"You can now import this file back into CafeTran."
                    )
                else:
                    QMessageBox.critical(self, "Error", "Failed to save CafeTran bilingual DOCX")
            
        except ImportError:
            QMessageBox.critical(
                self, "Missing Dependency",
                "The 'python-docx' library is required for CafeTran bilingual DOCX export.\n\n"
                "Install it with: pip install python-docx"
            )
        except Exception as e:
            QMessageBox.critical(self, "Export Error", f"Failed to export CafeTran bilingual DOCX:\n\n{str(e)}")
            self.log(f"‚úó CafeTran export failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # ========================================================================
    # GRID MANAGEMENT
    # ========================================================================
    
    def load_segments_to_grid(self):
        """Load segments into the grid with termbase highlighting"""
        self.log(f"üîÑüîÑüîÑ load_segments_to_grid CALLED - this will RELOAD grid from segment data!")
        
        # Clear row color settings cache to ensure fresh settings are loaded
        if hasattr(self, '_row_color_settings_cached'):
            delattr(self, '_row_color_settings_cached')
        
        # DEBUG: Log segment data BEFORE loading to grid
        if self.current_project and self.current_project.segments:
            self.log(f"üîÑ BEFORE LOAD: First 7 segments:")
            for seg in self.current_project.segments[:7]:
                self.log(f"üîÑ   Seg {seg.id} (obj {id(seg)}): target='{seg.target[:30] if seg.target else 'EMPTY'}...', len={len(seg.target)}, status={seg.status}")
        
        if not self.current_project or not self.current_project.segments:
            self.clear_grid()
            return
        
        self.table.setRowCount(len(self.current_project.segments))

        previous_suppression = self._suppress_target_change_handlers
        self._suppress_target_change_handlers = True
        
        # Pre-calculate list numbers for numbered lists
        # Track consecutive <li-o> or <li> items and assign numbers
        list_counter = 0
        last_was_list = False
        list_numbers = {}  # {segment_index: list_number}
        
        for idx, segment in enumerate(self.current_project.segments):
            source_text = segment.source.strip()
            # Support both new tags (<li-o>, <li-b>) and legacy <li> tag
            is_list_item = source_text.startswith('<li-o>') or source_text.startswith('<li-b>') or source_text.startswith('<li>')
            # <li-o> is ordered, <li> (legacy) is treated as ordered for numbering
            is_ordered = source_text.startswith('<li-o>') or (source_text.startswith('<li>') and not source_text.startswith('<li-b>'))
            
            # Check if it's a numbered list item (vs bullet)
            # If text inside <li-o> or <li> starts with a number pattern, extract it
            # Otherwise, if it's part of a consecutive list sequence, count it
            if is_list_item and is_ordered:
                import re
                # Check for number at start: <li-o>1. or <li>1. or <li-o>2) etc
                num_match = re.match(r'^<li(?:-o)?>\s*(\d+)[.)\s]', source_text)
                if num_match:
                    # Has explicit number in text
                    list_numbers[idx] = int(num_match.group(1))
                    list_counter = int(num_match.group(1))
                    last_was_list = True
                elif last_was_list:
                    # Continue numbering from previous
                    list_counter += 1
                    list_numbers[idx] = list_counter
                else:
                    # First item, start at 1
                    list_counter = 1
                    list_numbers[idx] = list_counter
                    last_was_list = True
            else:
                # Not a list item, reset counter
                last_was_list = False
                list_counter = 0

        try:
            for row, segment in enumerate(self.current_project.segments):
                # Clear any previous cell widgets
                self.table.removeCellWidget(row, 2)  # Source
                self.table.removeCellWidget(row, 3)  # Target
                self.table.removeCellWidget(row, 4)  # Match
                self.table.removeCellWidget(row, 5)  # Status
                
                # ID - Segment number (black in light themes, theme text color in dark themes)
                id_item = QTableWidgetItem(str(segment.id))
                id_item.setFlags(id_item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # Read-only
                id_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                # Black for light themes, theme text color for dark themes
                theme = self.theme_manager.current_theme
                segment_num_color = "black" if theme.name in ["Light (Default)", "Soft Gray", "Warm Cream", "Sepia", "High Contrast"] else theme.text
                id_item.setForeground(QColor(segment_num_color))
                id_item.setBackground(QColor())  # Default background from theme
                # Smaller font for segment numbers
                seg_num_font = QFont(self.default_font_family, max(8, self.default_font_size - 2))
                id_item.setFont(seg_num_font)
                self.table.setItem(row, 0, id_item)
                
                # Type - show segment type based on style and content
                # Determine type display from style attribute and segment type
                style = getattr(segment, 'style', 'Normal')
                
                # Check for list items - use stored list_type/list_number if available
                list_type = getattr(segment, 'list_type', '')
                list_number_stored = getattr(segment, 'list_number', None)
                
                # Use pre-calculated list number from our loop above
                list_number_calculated = list_numbers.get(row, None)
                
                # Fallback: detect from source text if list_type not set
                source_text = segment.source.strip()
                is_list_item = bool(list_type) or (
                    source_text.startswith('<li-o>') or  # Tagged ordered list item
                    source_text.startswith('<li-b>') or  # Tagged bullet list item
                    source_text.startswith('<li>') or    # Legacy list tag
                    source_text.lstrip().startswith(('‚Ä¢ ', '- ', '* ', '¬∑ ')) or
                    (len(source_text) > 2 and source_text[0].isdigit() and source_text[1:3] in ('. ', ') '))
                )
                
                # Determine type display
                if 'Title' in style:
                    type_display = "Title"
                elif 'Heading 1' in style or 'Heading1' in style:
                    type_display = "H1"
                elif 'Heading 2' in style or 'Heading2' in style:
                    type_display = "H2"
                elif 'Heading 3' in style or 'Heading3' in style:
                    type_display = "H3"
                elif 'Heading 4' in style or 'Heading4' in style:
                    type_display = "H4"
                elif 'Subtitle' in style:
                    type_display = "Sub"
                elif is_list_item:
                    # Show list number for numbered lists, bullet for unordered
                    # Check for <li-b> tag first (explicit bullet)
                    if '<li-b>' in source_text:
                        type_display = "‚Ä¢"
                    # Check for bullet patterns in text
                    elif source_text.lstrip().startswith(('‚Ä¢ ', '- ', '* ', '¬∑ ')):
                        type_display = "‚Ä¢"
                    elif list_type == "bullet":
                        type_display = "‚Ä¢"
                    elif list_number_stored is not None:
                        type_display = f"#{list_number_stored}"
                    elif list_number_calculated is not None:
                        type_display = f"#{list_number_calculated}"
                    elif '<li-o>' in source_text or '<li>' in source_text:
                        # Ordered list - use calculated number or show #?
                        type_display = f"#{list_numbers.get(row, '?')}"
                    elif list_type == "numbered":
                        type_display = "#?"
                    else:
                        # Fallback: check for number at start of text
                        import re
                        num_match = re.match(r'^(\d+)[.)\s]', source_text)
                        if num_match:
                            type_display = f"#{num_match.group(1)}"
                        elif '<li-o>' in source_text:
                            # Has <li-o> but no number - numbered list
                            type_display = "#?"
                        else:
                            type_display = "li"
                elif segment.type and segment.type != "para":
                    # Handle # type specially - only show #N for actual numbered items
                    if segment.type == "#":
                        # Plain "#" means continuation text within a list, show as paragraph
                        type_display = "¬∂"
                    elif segment.type.startswith("#") and len(segment.type) > 1:
                        # Has a number like "#1", "#2" - keep it
                        type_display = segment.type
                    else:
                        type_display = segment.type.upper()
                else:
                    type_display = "¬∂"  # Paragraph symbol
                
                type_item = QTableWidgetItem(type_display)
                type_item.setFlags(type_item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # Read-only
                type_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)

                # Color-code by type for better visibility
                if type_display in ("H1", "H2", "H3", "H4", "Title"):
                    type_item.setForeground(QColor("#1976D2"))  # Blue for headings (works in both themes)
                elif type_display.startswith("#") or type_display in ("‚Ä¢", "li"):
                    type_item.setForeground(QColor("#388E3C"))  # Green for list items (works in both themes)

                # Smaller font for type symbols
                type_font = QFont(self.default_font_family, max(8, self.default_font_size - 2))
                type_item.setFont(type_font)

                self.table.setItem(row, 1, type_item)
                
                # Source - Use read-only QTextEdit widget for easy text selection
                # Apply invisible character replacements for display only
                source_display_text = self.apply_invisible_replacements(segment.source)
                source_editor = ReadOnlyGridTextEditor(source_display_text, self.table, row)
                
                # Initialize empty termbase matches (will be populated lazily on segment selection or by background worker)
                source_editor.termbase_matches = {}
                
                # Set font to match grid
                font = QFont(self.default_font_family, self.default_font_size)
                source_editor.setFont(font)
                
                # Set as cell widget (allows easy text selection)
                self.table.setCellWidget(row, 2, source_editor)
                
                # Also set a placeholder item for row height calculation
                source_item = QTableWidgetItem()
                source_item.setFlags(Qt.ItemFlag.NoItemFlags)  # No interaction
                self.table.setItem(row, 2, source_item)
                
                # Target - Use editable QTextEdit widget for easy text selection and editing
                # Apply invisible character replacements for display (will be reversed when saving)
                target_display_text = self.apply_invisible_replacements(segment.target)
                target_editor = EditableGridTextEditor(target_display_text, self.table, row, self.table)
                target_editor.setFont(font)
                
                # Connect text changes to update segment
                # Use a factory function to create a proper closure that captures the segment ID
                def make_target_changed_handler(segment_id, editor_widget):
                    # Create debounce timer for expensive operations
                    debounce_timer = None
                    
                    def on_target_text_changed():
                        nonlocal debounce_timer
                        new_text = editor_widget.toPlainText()

                        # Reverse invisible character replacements before saving
                        new_text = self.reverse_invisible_replacements(new_text)

                        # DEBUG: Log EVERY call to catch the culprit (only in debug mode)
                        if self.debug_mode_enabled:
                            self.log(f"üîî textChanged FIRED: segment_id={segment_id}, new_text='{new_text[:20] if new_text else 'EMPTY'}...'")

                        # CRITICAL: Ignore spurious textChanged event from Qt's queued document changes
                        # When signals are unblocked after setPlainText(), Qt delivers queued events
                        # This flag prevents false TM saves during grid load/filter/refresh operations
                        if not editor_widget._initial_load_complete:
                            editor_widget._initial_load_complete = True
                            if self.debug_mode_enabled:
                                self.log(f"üîî textChanged IGNORED (initial load) for segment {segment_id}")
                            return

                        if self._suppress_target_change_handlers:
                            if self.debug_mode_enabled:
                                self.log(f"üîî textChanged SUPPRESSED for segment {segment_id}")
                            return
                        
                        # CRITICAL: Find segment by ID, not by row index!
                        # Row indices can change, but segment IDs are stable
                        target_segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
                        if not target_segment:
                            return
                        
                        # Capture old values for undo
                        old_target = target_segment.target
                        old_status = target_segment.status
                        
                        # Update the target text
                        if self.debug_mode_enabled:
                            self.log(f"üìù BEFORE update: seg {segment_id} target='{target_segment.target[:30] if target_segment.target else 'EMPTY'}...', status={target_segment.status}, obj_id={id(target_segment)}")
                        target_segment.target = new_text
                        
                        # Reset 'confirmed' status to 'translated' when user edits the segment
                        # This prevents auto-saving to TM until user re-confirms the edit
                        new_status = old_status
                        if old_status == 'confirmed' and new_text != old_target:
                            from PyQt6.QtCore import QTimer as QTimerLocal
                            new_status = 'translated'
                            target_segment.status = new_status
                            if self.debug_mode_enabled:
                                self.log(f"üìù Status reset: confirmed ‚Üí translated (segment edited)")
                            # Refresh the status icon in the grid (debounced to avoid UI lag)
                            QTimerLocal.singleShot(0, lambda sid=segment_id: self._refresh_segment_status_by_id(sid))
                        
                        if self.debug_mode_enabled:
                            self.log(f"üìù AFTER update: seg {segment_id} target='{target_segment.target[:30] if target_segment.target else 'EMPTY'}...', status={target_segment.status}, obj_id={id(target_segment)}")
                        
                        # Record undo state with any status change
                        self.record_undo_state(segment_id, old_target, new_text, old_status, new_status)
                        
                        # Mark project as modified
                        self.project_modified = True
                        
                        # DEBOUNCED: Expensive UI/DB operations (only after user stops typing)
                        # Cancel previous timer
                        if debounce_timer:
                            debounce_timer.stop()
                        
                        # Schedule expensive operations after 500ms of inactivity
                        from PyQt6.QtCore import QTimer
                        debounce_timer = QTimer()
                        debounce_timer.setSingleShot(True)
                        # CRITICAL: Use default parameter to capture new_text BY VALUE, not by reference
                        # This prevents the closure from capturing a variable that changes later
                        debounce_timer.timeout.connect(lambda text=new_text: self._handle_target_text_debounced_by_id(
                            segment_id, text
                        ))
                        debounce_timer.start(1000)  # 1000ms delay (increased for better responsiveness)
                            
                    return on_target_text_changed
                
                # Set as cell widget FIRST (before connecting signals)
                self.table.setCellWidget(row, 3, target_editor)
                
                # Also set a placeholder item for row height calculation
                target_item = QTableWidgetItem()
                target_item.setFlags(Qt.ItemFlag.NoItemFlags)  # No interaction
                self.table.setItem(row, 3, target_item)
                
                # CRITICAL: Connect textChanged AFTER widget is in table and setText is done
                # This prevents programmatic setText from triggering TM saves during grid reload
                target_editor.textChanged.connect(make_target_changed_handler(segment.id, target_editor))
                
                # DO NOT unblock signals here - they stay blocked until end of load_segments_to_grid

                # Pre-populate status cell item so gridlines render before widget assignment
                status_placeholder = QTableWidgetItem()
                status_placeholder.setFlags(Qt.ItemFlag.NoItemFlags)
                status_placeholder.setBackground(QColor(get_status(segment.status).color))
                self.table.setItem(row, 4, status_placeholder)

                # Status column (icon + match + comment)
                self._update_status_cell(row, segment)
                
                # Apply alternating row colors to source and target widgets
                self._apply_row_color(row, source_editor, target_editor)
            
            # Apply current font
            self.apply_font_to_grid()
            
            # Auto-resize rows
            self.auto_resize_rows()
            self._enforce_status_row_heights()
            
            self.log(f"‚úì Loaded {len(self.current_project.segments)} segments to grid")
            
            # Apply pagination - show only segments for current page
            self._apply_pagination_to_grid()

            # Apply current tag view mode (WYSIWYG or Tags)
            if hasattr(self, 'show_tags') and self.show_tags:
                # If tags mode is enabled, refresh to show raw tags
                self._refresh_grid_display_mode()

            # Also refresh List view if it exists
            if hasattr(self, 'list_tree'):
                self.refresh_list_view()
        finally:
            self._suppress_target_change_handlers = previous_suppression
            
            # NOW unblock all target editor signals - grid loading is complete
            # This MUST happen after suppression flag is restored to avoid race conditions
            for row in range(self.table.rowCount()):
                target_widget = self.table.cellWidget(row, 3)
                if target_widget:
                    target_widget.blockSignals(False)
            
            # Update progress stats in status bar
            self.update_progress_stats()
            
            # Refresh document preview
            self.refresh_preview()

    # =========================================================================
    # COMPARE PANEL TAB
    # =========================================================================

    def _create_compare_panel(self) -> QWidget:
        """Create the Compare Panel tab with 4 comparison boxes:
        Current Source, Machine Translation, TM Source, TM Target
        With navigation arrows for multiple matches.
        """
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(4)
        
        # Get theme colors
        if hasattr(self, 'theme_manager') and self.theme_manager:
            theme = self.theme_manager.current_theme
            # Check if theme is dark by checking the theme name or a dark attribute
            is_dark = getattr(theme, 'is_dark', 'dark' in theme.name.lower())
            border_color = theme.border
            title_color = theme.text_disabled
            text_color = theme.text
            # Use theme-appropriate colors for boxes
            box1_bg = theme.panel_info if hasattr(theme, 'panel_info') else ("#2d3748" if is_dark else "#e3f2fd")
            box2_bg = theme.panel_warning if hasattr(theme, 'panel_warning') else ("#3d3520" if is_dark else "#fff3cd")
            box3_bg = theme.panel_success if hasattr(theme, 'panel_success') else ("#1e3a2f" if is_dark else "#d4edda")
            box4_bg = theme.panel_neutral if hasattr(theme, 'panel_neutral') else ("#2d2d3d" if is_dark else "#e8e8f0")
        else:
            is_dark = False
            border_color = "#ddd"
            title_color = "#666"
            text_color = "#333"
            box1_bg = "#e3f2fd"
            box2_bg = "#fff3cd"
            box3_bg = "#d4edda"
            box4_bg = "#e8e8f0"
        
        # Header with segment info
        header_layout = QHBoxLayout()
        self.compare_panel_segment_label = QLabel("Segment: -")
        self.compare_panel_segment_label.setStyleSheet(f"font-weight: bold; font-size: 11px; color: {title_color};")
        header_layout.addWidget(self.compare_panel_segment_label)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # Store text edits and navigation state for theme updates
        self.compare_panel_text_edits = []
        self.compare_panel_mt_matches = []  # List of MT matches
        self.compare_panel_tm_matches = []  # List of TM matches
        self.compare_panel_mt_index = 0     # Current MT match index
        self.compare_panel_tm_index = 0     # Current TM match index
        
        # Box 1: Current Source (blue-ish) - no navigation needed
        box1_container, self.compare_panel_current_source, _, _ = self._create_compare_panel_box(
            "üìù Current Source", box1_bg, text_color, border_color, has_navigation=False)
        layout.addWidget(box1_container, 1)
        
        # Box 2: Machine Translation (purple-ish) - with navigation
        box2_container, self.compare_panel_mt, self.compare_panel_mt_nav_label, mt_nav_btns = self._create_compare_panel_box(
            "ü§ñ MT", box4_bg, text_color, border_color, has_navigation=True, shortcut_badge_text="0", shortcut_badge_tooltip="Alt+0")
        if mt_nav_btns:
            mt_nav_btns[0].clicked.connect(lambda: self._compare_panel_nav_mt(-1))
            mt_nav_btns[1].clicked.connect(lambda: self._compare_panel_nav_mt(1))
        layout.addWidget(box2_container, 1)
        
        # Box 3: TM Source (yellow-ish) - with navigation
        box3_container, self.compare_panel_tm_source, self.compare_panel_tm_nav_label, tm_nav_btns = self._create_compare_panel_box(
            "üìö TM Source", box2_bg, text_color, border_color, has_navigation=True)
        if tm_nav_btns:
            tm_nav_btns[0].clicked.connect(lambda: self._compare_panel_nav_tm(-1))
            tm_nav_btns[1].clicked.connect(lambda: self._compare_panel_nav_tm(1))
        layout.addWidget(box3_container, 1)
        
        # Box 4: TM Target (green-ish) - syncs with TM Source navigation
        box4_container, self.compare_panel_tm_target, self.compare_panel_tm_target_label, _ = self._create_compare_panel_box(
            "‚úÖ TM Target", box3_bg, text_color, border_color, has_navigation=False, show_metadata_label=True,
            shortcut_badge_text="00", shortcut_badge_tooltip="Alt+0,0")
        layout.addWidget(box4_container, 1)
        
        return widget
    
    def _create_match_panel(self) -> QWidget:
        """Create Match Panel with Termview + TM Source/Target boxes."""
        widget = QWidget()
        main_layout = QVBoxLayout(widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Initialize compare_panel_text_edits if not exists (needed for _create_compare_panel_box)
        if not hasattr(self, 'compare_panel_text_edits'):
            self.compare_panel_text_edits = []
        
        # Vertical splitter: Termview (top) | TM boxes (bottom)
        splitter = QSplitter(Qt.Orientation.Vertical)
        
        # TOP: Container with header + Termview
        termview_container = QWidget()
        termview_layout = QVBoxLayout(termview_container)
        termview_layout.setContentsMargins(4, 4, 4, 0)
        termview_layout.setSpacing(2)
        
        # Termview header label (theme-aware)
        termview_header = QLabel("üìñ Termview")
        if hasattr(self, 'theme_manager') and self.theme_manager:
            header_color = self.theme_manager.current_theme.text_disabled
        else:
            header_color = "#666"
        termview_header.setStyleSheet(f"font-weight: bold; font-size: 9px; color: {header_color};")
        termview_layout.addWidget(termview_header)
        
        # Third Termview instance for Match Panel
        self.termview_widget_match = TermviewWidget(self, db_manager=self.db_manager, log_callback=self.log, theme_manager=self.theme_manager)
        # Connect Termview signals
        self.termview_widget_match.term_insert_requested.connect(self.insert_termview_text)
        self.termview_widget_match.edit_entry_requested.connect(self._on_termview_edit_entry)
        self.termview_widget_match.delete_entry_requested.connect(self._on_termview_delete_entry)
        # Apply font settings
        font_settings = self.load_general_settings()
        termview_family = font_settings.get('termview_font_family', 'Segoe UI')
        termview_size = font_settings.get('termview_font_size', 10)
        termview_bold = font_settings.get('termview_font_bold', False)
        self.termview_widget_match.set_font_settings(termview_family, termview_size, termview_bold)
        termview_layout.addWidget(self.termview_widget_match)
        
        splitter.addWidget(termview_container)
        
        # BOTTOM: Container for TM Source + TM Target boxes
        tm_container = QWidget()
        tm_layout = QHBoxLayout(tm_container)
        tm_layout.setContentsMargins(0, 0, 0, 0)
        tm_layout.setSpacing(0)

        # Get theme-aware colors for TM boxes (same as Compare Panel)
        if hasattr(self, 'theme_manager') and self.theme_manager:
            theme = self.theme_manager.current_theme
            is_dark = getattr(theme, 'is_dark', 'dark' in theme.name.lower())
            border_color = theme.border
            text_color = theme.text
            # Green background - theme-appropriate shade
            tm_box_bg = theme.panel_success if hasattr(theme, 'panel_success') else ("#1e3a2f" if is_dark else "#d4edda")
        else:
            tm_box_bg = "#d4edda"    # Green (light mode)
            text_color = "#333"
            border_color = "#ddd"
        
        # TM Source box (GREEN, with navigation)
        self.match_panel_tm_matches = []  # Separate match list
        self.match_panel_tm_index = 0     # Separate navigation index
        
        tm_source_container, self.match_panel_tm_source, self.match_panel_tm_nav_label, tm_nav_btns = self._create_compare_panel_box(
            "üìö TM Source", tm_box_bg, text_color, border_color, has_navigation=True)
        if tm_nav_btns:
            tm_nav_btns[0].clicked.connect(lambda: self._match_panel_nav_tm(-1))
            tm_nav_btns[1].clicked.connect(lambda: self._match_panel_nav_tm(1))
        tm_layout.addWidget(tm_source_container, 1)
        
        # TM Target box (GREEN, with metadata and shortcut badge)
        tm_target_container, self.match_panel_tm_target, self.match_panel_tm_target_label, _ = self._create_compare_panel_box(
            "‚úÖ TM Target", tm_box_bg, text_color, border_color, has_navigation=False, show_metadata_label=True,
            shortcut_badge_text="0", shortcut_badge_tooltip="Alt+0")
        tm_layout.addWidget(tm_target_container, 1)
        
        # Force stylesheet on the tm_container itself (the parent widget holding both boxes)
        tm_container.setStyleSheet("background-color: transparent;")
        
        splitter.addWidget(tm_container)
        
        # Set initial splitter sizes (60% Termview, 40% TM boxes)
        splitter.setSizes([600, 400])
        
        main_layout.addWidget(splitter)
        
        return widget
    
    def _match_panel_nav_tm(self, direction: int):
        """Navigate TM matches in Match Panel (-1 = prev, 1 = next)"""
        if not self.match_panel_tm_matches:
            return
        
        new_index = self.match_panel_tm_index + direction
        if 0 <= new_index < len(self.match_panel_tm_matches):
            self.match_panel_tm_index = new_index
            self._update_match_panel_tm_display()
    
    def _update_match_panel_tm_display(self):
        """Update Match Panel TM Source and TM Target display with current match"""
        if not self.match_panel_tm_matches:
            self.match_panel_tm_source.setPlainText("(No TM match)")
            self.match_panel_tm_target.setPlainText("(No TM match)")
            if hasattr(self, 'match_panel_tm_nav_label') and self.match_panel_tm_nav_label:
                self.match_panel_tm_nav_label.setText("(0/0)")
            if hasattr(self, 'match_panel_tm_target_label') and self.match_panel_tm_target_label:
                self.match_panel_tm_target_label.setText("")
            return
        
        match = self.match_panel_tm_matches[self.match_panel_tm_index]
        total = len(self.match_panel_tm_matches)
        idx = self.match_panel_tm_index + 1
        
        # Update navigation label
        if hasattr(self, 'match_panel_tm_nav_label') and self.match_panel_tm_nav_label:
            nav_html = f"(<span style='font-size:8px'>{idx}/{total}</span>)"
            self.match_panel_tm_nav_label.setText(nav_html)
        
        # Update TM Source text with diff highlighting
        tm_source_text = match.get('source', '')
        current_source = getattr(self, 'match_panel_current_source', '')
        if tm_source_text and current_source:
            self._set_compare_panel_text_with_diff(self.match_panel_tm_source, current_source, tm_source_text)
        else:
            self.match_panel_tm_source.setPlainText(tm_source_text or "(No TM match)")
        
        # Update TM Target text (no diff highlighting needed for target)
        # Badge is now in the title bar (QLabel), so just set plain text here
        target_text = match.get('target', '')
        self.match_panel_tm_target.setPlainText(target_text if target_text else "")
        
        # Update metadata label (TM name, percentage)
        if hasattr(self, 'match_panel_tm_target_label') and self.match_panel_tm_target_label:
            tm_name = match.get('tm_name', 'Unknown TM')
            match_pct = match.get('match_pct', 0)
            metadata_html = f"<span style='font-size:10px'>{tm_name}</span> (<span style='font-size:8px'>{match_pct}%</span>)"
            self.match_panel_tm_target_label.setText(metadata_html)
    
    def _create_compare_panel_box(self, label: str, bg_color: str, text_color: str, border_color: str,
                                   has_navigation: bool = False, show_metadata_label: bool = False,
                                   shortcut_badge_text: str = None, shortcut_badge_tooltip: str = None) -> tuple:
        """Create a single comparison box for the Compare Panel
        
        Returns: (container, text_edit, nav_label, nav_buttons) where nav_buttons is [prev_btn, next_btn] or None
        """
        container = QFrame()
        container.setStyleSheet(f"""
            QFrame {{
                background-color: {bg_color};
                border: 1px solid {border_color};
                border-radius: 4px;
            }}
        """)
        
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(6, 4, 6, 6)
        main_layout.setSpacing(2)
        
        # Header row with label, navigation, and metadata
        header_layout = QHBoxLayout()
        header_layout.setSpacing(4)
        
        # Title label
        title_label = QLabel(label)
        title_label.setStyleSheet(f"font-weight: bold; font-size: 9px; color: {text_color}; background: transparent; border: none;")
        header_layout.addWidget(title_label)

        # Optional shortcut badge (TermView-style blue bubble)
        if shortcut_badge_text:
            badge_width = 14 if len(shortcut_badge_text) == 1 else 20
            badge_label = QLabel(shortcut_badge_text)
            badge_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            badge_label.setFixedSize(badge_width, 14)
            badge_label.setStyleSheet("""
                QLabel {
                    background-color: #1976D2;
                    color: white;
                    border-radius: 7px;
                    font-size: 9px;
                    font-weight: bold;
                    padding: 0px;
                }
            """)
            if shortcut_badge_tooltip:
                badge_label.setToolTip(f"Press {shortcut_badge_tooltip} to insert")
            header_layout.addWidget(badge_label)
        
        nav_label = None
        nav_buttons = None

        if has_navigation or show_metadata_label:
            # Navigation: (1/3) ‚óÑ ‚ñ∫ provider_name ‚Ä¢ 95%
            nav_label = QLabel("(0/0)")
            nav_label.setStyleSheet(f"font-size: 8px; color: {text_color}; background: transparent; border: none;")
            # Store color so later rich-text updates can preserve theme color
            nav_label._compare_text_color = text_color
            header_layout.addWidget(nav_label)

        if has_navigation:
            # Detect theme for arrow color
            is_dark_theme = hasattr(self, 'theme_manager') and self.theme_manager and 'dark' in self.theme_manager.current_theme.name.lower()
            arrow_color = "#FFFFFF" if is_dark_theme else "#333333"

            # Create clickable label class with theme update capability
            from PyQt6.QtCore import pyqtSignal

            class ClickableArrow(QLabel):
                clicked = pyqtSignal()

                def __init__(self, arrow_symbol, parent=None):
                    """arrow_symbol: '‚óÄ' or '‚ñ∂'"""
                    self.arrow_symbol = arrow_symbol
                    super().__init__("", parent)
                    self.setCursor(Qt.CursorShape.PointingHandCursor)

                def set_color(self, color):
                    """Update arrow color for current theme"""
                    self.setStyleSheet(f"""
                        QLabel {{
                            color: {color};
                            background: transparent;
                            border: none;
                            font-size: 11px;
                            font-weight: bold;
                        }}
                    """)
                    self.setText(self.arrow_symbol)

                def mousePressEvent(self, event):
                    self.clicked.emit()
                    super().mousePressEvent(event)

            # Prev arrow - using ‚óÄ
            prev_btn = ClickableArrow("‚óÄ")
            prev_btn.set_color(arrow_color)
            prev_btn.setFixedSize(16, 16)
            prev_btn.setAlignment(Qt.AlignmentFlag.AlignCenter)
            header_layout.addWidget(prev_btn)

            # Next arrow - using ‚ñ∂
            next_btn = ClickableArrow("‚ñ∂")
            next_btn.set_color(arrow_color)
            next_btn.setFixedSize(16, 16)
            next_btn.setAlignment(Qt.AlignmentFlag.AlignCenter)
            header_layout.addWidget(next_btn)

            # Store reference for theme updates
            if not hasattr(self, 'theme_aware_arrows'):
                self.theme_aware_arrows = []
            self.theme_aware_arrows.extend([prev_btn, next_btn])

            nav_buttons = [prev_btn, next_btn]
        
        header_layout.addStretch()
        main_layout.addLayout(header_layout)
        
        # Text area
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setStyleSheet(f"""
            QTextEdit {{
                background-color: transparent;
                border: none;
                font-size: 10px;
                padding: 2px;
                color: {text_color};
            }}
        """)
        text_edit.setMinimumHeight(50)
        main_layout.addWidget(text_edit, 1)
        
        # Track for font updates and theming
        self.compare_panel_text_edits.append((text_edit, title_label, container, bg_color))
        
        return container, text_edit, nav_label, nav_buttons
    
    def _compare_panel_nav_mt(self, direction: int):
        """Navigate MT matches in Compare Panel (-1 = prev, 1 = next)"""
        if not self.compare_panel_mt_matches:
            return
        
        new_index = self.compare_panel_mt_index + direction
        if 0 <= new_index < len(self.compare_panel_mt_matches):
            self.compare_panel_mt_index = new_index
            self._update_compare_panel_mt_display()
    
    def _compare_panel_nav_tm(self, direction: int):
        """Navigate TM matches in Compare Panel (-1 = prev, 1 = next)"""
        if not self.compare_panel_tm_matches:
            return
        
        new_index = self.compare_panel_tm_index + direction
        if 0 <= new_index < len(self.compare_panel_tm_matches):
            self.compare_panel_tm_index = new_index
            self._update_compare_panel_tm_display()
    
    def _update_compare_panel_mt_display(self):
        """Update MT section display with current match"""
        if not self.compare_panel_mt_matches:
            self.compare_panel_mt.setPlainText("(No MT available)")
            if hasattr(self, 'compare_panel_mt_nav_label') and self.compare_panel_mt_nav_label:
                self.compare_panel_mt_nav_label.setText("(0/0)")
            return
        
        match = self.compare_panel_mt_matches[self.compare_panel_mt_index]
        total = len(self.compare_panel_mt_matches)
        
        # Update navigation label with emphasis:
        # - Provider name: larger (readability)
        try:
            import html
            provider_escaped = html.escape(str(match.get('provider', 'MT')))
        except Exception:
            provider_escaped = str(match.get('provider', 'MT'))

        idx = self.compare_panel_mt_index + 1
        nav_html = (
            f"(<span style='font-size:8px'>{idx}/{total}</span>) "
            f"<span style='font-size:10px'>{provider_escaped}</span>"
        )

        if hasattr(self, 'compare_panel_mt_nav_label') and self.compare_panel_mt_nav_label:
            # Avoid a fixed font-size stylesheet overriding rich text emphasis, but keep theme color
            label_color = getattr(self.compare_panel_mt_nav_label, '_compare_text_color', None)
            if label_color:
                self.compare_panel_mt_nav_label.setStyleSheet(
                    f"color: {label_color}; background: transparent; border: none;"
                )
            else:
                self.compare_panel_mt_nav_label.setStyleSheet("background: transparent; border: none;")
            self.compare_panel_mt_nav_label.setText(nav_html)
        
        # Update text
        self.compare_panel_mt.setPlainText(match.get('translation', ''))
    
    def _update_compare_panel_tm_display(self):
        """Update TM Source and TM Target display with current match"""
        if not self.compare_panel_tm_matches:
            self.compare_panel_tm_source.setPlainText("(No TM match)")
            self.compare_panel_tm_target.setPlainText("(No TM match)")
            if hasattr(self, 'compare_panel_tm_nav_label') and self.compare_panel_tm_nav_label:
                self.compare_panel_tm_nav_label.setText("(0/0)")
            if hasattr(self, 'compare_panel_tm_target_label') and self.compare_panel_tm_target_label:
                self.compare_panel_tm_target_label.setText("(0/0)")
            return
        
        match = self.compare_panel_tm_matches[self.compare_panel_tm_index]
        total = len(self.compare_panel_tm_matches)
        
        # Get metadata
        tm_name = match.get('tm_name', 'TM')
        match_pct = match.get('match_pct', 0)
        
        # Update metadata labels with emphasis:
        # - TM name: larger
        # - Match %: larger + bold
        try:
            import html
            tm_name_escaped = html.escape(str(tm_name))
        except Exception:
            tm_name_escaped = str(tm_name)

        idx = self.compare_panel_tm_index + 1
        try:
            match_pct_display = int(match_pct)
        except Exception:
            match_pct_display = match_pct

        nav_html = (
            f"(<span style='font-size:8px'>{idx}/{total}</span>) "
            f"<span style='font-size:10px'>{tm_name_escaped}</span> "
            f"<span style='font-size:8px'>‚Ä¢</span> "
            f"<span style='font-size:10px; font-weight:700'>{match_pct_display}%</span>"
        )

        if hasattr(self, 'compare_panel_tm_nav_label') and self.compare_panel_tm_nav_label:
            # Avoid a fixed font-size stylesheet overriding rich text emphasis, but keep theme color
            label_color = getattr(self.compare_panel_tm_nav_label, '_compare_text_color', None)
            if label_color:
                self.compare_panel_tm_nav_label.setStyleSheet(f"color: {label_color}; background: transparent; border: none;")
            else:
                self.compare_panel_tm_nav_label.setStyleSheet("background: transparent; border: none;")
            self.compare_panel_tm_nav_label.setText(nav_html)

        if hasattr(self, 'compare_panel_tm_target_label') and self.compare_panel_tm_target_label:
            label_color = getattr(self.compare_panel_tm_target_label, '_compare_text_color', None)
            if label_color:
                self.compare_panel_tm_target_label.setStyleSheet(f"color: {label_color}; background: transparent; border: none;")
            else:
                self.compare_panel_tm_target_label.setStyleSheet("background: transparent; border: none;")
            self.compare_panel_tm_target_label.setText(nav_html)
        
        # Update TM Source with diff highlighting
        current_source = self.compare_panel_current_source.toPlainText()
        tm_source = match.get('source', '')
        if tm_source and current_source:
            self._set_compare_panel_text_with_diff(self.compare_panel_tm_source, current_source, tm_source)
        else:
            self.compare_panel_tm_source.setPlainText(tm_source or "(No TM match)")
        
        # Update TM Target
        self.compare_panel_tm_target.setPlainText(match.get('target', ''))
    
    def set_compare_panel_matches(self, segment_id: int, current_source: str, 
                                   tm_matches: list = None, mt_matches: list = None):
        """Set all matches for Match Panel (and Compare Panel if it exists)
        
        Args:
            segment_id: Current segment ID
            current_source: The source text of the current segment
            tm_matches: List of dicts with keys: source, target, tm_name, match_pct
            mt_matches: List of dicts with keys: translation, provider
        """
        # Always update Match Panel with TM matches
        self.match_panel_tm_matches = tm_matches or []
        self.match_panel_tm_index = 0
        self.match_panel_current_source = current_source  # Store for diff highlighting
        self._update_match_panel_tm_display()
        
        # Update Compare Panel if it exists (legacy support)
        if hasattr(self, 'compare_panel_current_source') and self.compare_panel_current_source:
            # Update segment label
            if hasattr(self, 'compare_panel_segment_label'):
                self.compare_panel_segment_label.setText(f"Segment {segment_id + 1}")
            
            # Update Current Source
            self.compare_panel_current_source.setPlainText(current_source)
            
            # Store matches and reset indices
            self.compare_panel_tm_matches = tm_matches or []
            self.compare_panel_mt_matches = mt_matches or []
            self.compare_panel_tm_index = 0
            self.compare_panel_mt_index = 0
            
            # Update displays
            self._update_compare_panel_mt_display()
            self._update_compare_panel_tm_display()

    def update_compare_panel(self, segment_id: int, current_source: str, 
                              tm_source: str = "", tm_target: str = "", 
                              mt_translation: str = "", tm_match_percent: int = 0,
                              tm_name: str = "TM", mt_provider: str = "MT"):
        """Update the Match Panel with new data for the current segment (legacy single-match method)
        
        This is the legacy method that accepts single TM/MT matches. For multiple matches,
        use set_compare_panel_matches() instead.
        """
        # Convert to the new format and use set_compare_panel_matches
        tm_matches = []
        mt_matches = []
        
        if tm_source or tm_target:
            tm_matches = [{
                'source': tm_source,
                'target': tm_target,
                'tm_name': tm_name,
                'match_pct': tm_match_percent
            }]
        
        if mt_translation:
            mt_matches = [{
                'translation': mt_translation,
                'provider': mt_provider
            }]
        
        self.set_compare_panel_matches(segment_id, current_source, tm_matches, mt_matches)
    
    def _set_compare_panel_text_with_diff(self, text_edit: QTextEdit, current: str, tm_source: str):
        """
        Set text with diff highlighting using memoQ-style track changes view:
        - Normal text: identical to current
        - Red underline: text added in current (insertion)
        - Red strikethrough: text removed from TM (deletion)
        
        This displays the TM source annotated with tracked changes.
        """
        import difflib
        
        text_edit.clear()
        cursor = text_edit.textCursor()
        
        # Create formatters - memoQ track changes style
        normal_format = QTextCharFormat()
        
        # Red strikethrough for deletions (text in TM but not in current)
        delete_format = QTextCharFormat()
        delete_format.setForeground(QColor("#cc0000"))  # Red text
        delete_format.setFontStrikeOut(True)
        
        # Red underline for insertions (text in current but not in TM)
        add_format = QTextCharFormat()
        add_format.setForeground(QColor("#cc0000"))  # Red text
        add_format.setFontUnderline(True)
        
        # Use SequenceMatcher at word level for better readability
        current_words = current.split()
        tm_words = tm_source.split()
        
        matcher = difflib.SequenceMatcher(None, current_words, tm_words)
        
        result_parts = []
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'equal':
                # Same in both - show normally
                result_parts.append(('normal', ' '.join(tm_words[j1:j2])))
            elif tag == 'replace':
                # Different text - show TM version strikethrough, then current version underlined
                result_parts.append(('delete', ' '.join(tm_words[j1:j2])))
                result_parts.append(('add', ' '.join(current_words[i1:i2])))
            elif tag == 'insert':
                # Text in TM but not in current - strikethrough (it was "deleted" from current's perspective)
                result_parts.append(('delete', ' '.join(tm_words[j1:j2])))
            elif tag == 'delete':
                # Text in current but not in TM - underline (it was "inserted" in current)
                result_parts.append(('add', ' '.join(current_words[i1:i2])))
        
        # Render the parts with proper spacing
        for i, (part_type, text) in enumerate(result_parts):
            if i > 0:
                cursor.insertText(' ', normal_format)  # Space between parts
            
            if part_type == 'normal':
                cursor.insertText(text, normal_format)
            elif part_type == 'delete':
                cursor.insertText(text, delete_format)
            elif part_type == 'add':
                cursor.insertText(text, add_format)
        
        text_edit.setTextCursor(cursor)
    
    def _refresh_compare_panel_theme(self):
        """Refresh Match Panel TM box colors based on current theme"""
        if not hasattr(self, 'compare_panel_text_edits'):
            return
        
        # Get theme colors
        if hasattr(self, 'theme_manager') and self.theme_manager:
            theme = self.theme_manager.current_theme
            # Check if theme is dark by checking the theme name or a dark attribute
            is_dark = getattr(theme, 'is_dark', 'dark' in theme.name.lower())
            border_color = theme.border
            text_color = theme.text
            # Use theme-appropriate colors for Match Panel boxes (both green)
            panel_success = theme.panel_success if hasattr(theme, 'panel_success') else ("#1e3a2f" if is_dark else "#d4edda")
            box_colors = [
                panel_success,  # 0: Match Panel - TM Source (green)
                panel_success,  # 1: Match Panel - TM Target (green)
            ]
        else:
            return
        
        # Update each box
        for i, (text_edit, label_widget, container, _) in enumerate(self.compare_panel_text_edits):
            bg_color = box_colors[i] if i < len(box_colors) else box_colors[-1]
            
            container.setStyleSheet(f"""
                QFrame {{
                    background-color: {bg_color};
                    border: 1px solid {border_color};
                    border-radius: 4px;
                }}
            """)
            
            label_widget.setStyleSheet(f"font-weight: bold; font-size: 9px; color: {text_color}; background: transparent; border: none;")
            
            text_edit.setStyleSheet(f"""
                QTextEdit {{
                    background-color: transparent;
                    border: none;
                    font-size: 10px;
                    padding: 2px;
                    color: {text_color};
                }}
            """)

    # =========================================================================
    # DOCUMENT PREVIEW TAB
    # =========================================================================

    def _create_preview_tab(self) -> QWidget:
        """Create the Preview tab widget with live document preview and click-to-navigate"""
        from PyQt6.QtWidgets import QScrollArea

        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Create scroll area for the preview
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setStyleSheet("border: none;")

        # Create the preview text widget
        preview_text = QTextEdit()
        preview_text.setReadOnly(True)
        preview_text.setStyleSheet("""
            QTextEdit {
                background-color: white;
                border: none;
                padding: 20px 30px;
                font-family: Georgia, 'Times New Roman', serif;
                font-size: 11pt;
                line-height: 1.5;
            }
        """)

        # Enable click handling for navigation
        preview_text.mousePressEvent = lambda event: self._on_preview_click(event, preview_text)
        preview_text.setCursor(Qt.CursorShape.PointingHandCursor)

        scroll_area.setWidget(preview_text)
        layout.addWidget(scroll_area)

        # Store reference for updates
        widget.preview_text = preview_text
        widget.scroll_area = scroll_area

        # Track segment positions for click navigation
        widget.segment_positions = {}  # {(start_pos, end_pos): segment_id}

        # Track current highlighted segment
        widget.current_highlighted_segment_id = None

        # Store reference in instance for easy access
        if not hasattr(self, 'preview_widgets'):
            self.preview_widgets = []
        self.preview_widgets.append(widget)

        return widget

    def _on_preview_click(self, event, preview_text: QTextEdit):
        """Handle click on preview text to navigate to corresponding segment"""
        from PyQt6.QtGui import QMouseEvent

        # Get cursor position from click
        cursor = preview_text.cursorForPosition(event.pos())
        click_pos = cursor.position()

        # Find which segment this position belongs to
        parent_widget = preview_text.parent()
        while parent_widget and not hasattr(parent_widget, 'segment_positions'):
            parent_widget = parent_widget.parent()

        if not parent_widget or not hasattr(parent_widget, 'segment_positions'):
            # Call parent's mousePressEvent for default behavior
            QTextEdit.mousePressEvent(preview_text, event)
            return

        segment_positions = parent_widget.segment_positions

        for (start_pos, end_pos), segment_id in segment_positions.items():
            if start_pos <= click_pos <= end_pos:
                # Navigate to this segment in the grid
                self._navigate_to_segment_in_grid(segment_id)
                break

        # Call parent's mousePressEvent for default behavior
        QTextEdit.mousePressEvent(preview_text, event)

    def _navigate_to_segment_in_grid(self, segment_id: int):
        """Navigate to a specific segment by ID in the grid"""
        if not self.current_project or not hasattr(self, 'table') or not self.table:
            return

        # Find the row for this segment ID
        for row in range(self.table.rowCount()):
            id_item = self.table.item(row, 0)
            if id_item:
                try:
                    row_segment_id = int(id_item.text())
                    if row_segment_id == segment_id:
                        # Switch to Grid tab first
                        if hasattr(self, 'main_tabs'):
                            self.main_tabs.setCurrentIndex(0)  # Grid tab
                        
                        # Handle pagination - switch to correct page if needed
                        if hasattr(self, 'page_size_combo') and self.page_size_combo.currentText() != "All":
                            try:
                                page_size = int(self.page_size_combo.currentText())
                                target_page = (row // page_size) + 1
                                if hasattr(self, 'page_number_input'):
                                    self.page_number_input.setText(str(target_page))
                                    self.go_to_page()
                            except ValueError:
                                pass

                        # Select this row and focus the target cell
                        self.table.setCurrentCell(row, 3)  # Column 3 = Target
                        self.table.scrollToItem(self.table.item(row, 0), QTableWidget.ScrollHint.PositionAtCenter)
                        
                        target_widget = self.table.cellWidget(row, 3)
                        if target_widget:
                            target_widget.setFocus()
                            # Place cursor at end of text
                            if isinstance(target_widget, QTextEdit):
                                cursor = target_widget.textCursor()
                                cursor.movePosition(cursor.MoveOperation.End)
                                target_widget.setTextCursor(cursor)

                        self.log(f"üìÑ Preview: Navigated to segment {segment_id}")
                        return
                except (ValueError, AttributeError):
                    continue

    def _get_current_segment_id(self) -> Optional[int]:
        """Get the ID of the currently selected segment in the grid"""
        if not self.current_project or not hasattr(self, 'table') or not self.table:
            return None
        
        current_row = self.table.currentRow()
        if current_row < 0:
            return None
        
        id_item = self.table.item(current_row, 0)
        if id_item:
            try:
                return int(id_item.text())
            except (ValueError, AttributeError):
                pass
        
        return None

    def _is_preview_tab_active(self) -> bool:
        """Check if the Preview tab is currently selected in the right panel.
        
        Used to optimize performance by skipping heavy lookups when user is
        navigating in Preview mode (they're likely just reading, not translating).
        """
        if not hasattr(self, 'right_tabs') or not self.right_tabs:
            return False
        if not hasattr(self, '_preview_tab_index'):
            return False
        return self.right_tabs.currentIndex() == self._preview_tab_index

    def _scroll_preview_to_segment(self, segment_id: int):
        """Scroll the preview to show the specified segment and highlight it.
        
        ‚ö° PERFORMANCE: Only does work if Preview tab is actually visible.
        This prevents expensive operations (looping through all segments,
        updating char formatting) when user is working in the grid.
        """
        # ‚ö° Skip entirely if Preview tab is not visible - major performance optimization
        if not self._is_preview_tab_active():
            return
        
        if not hasattr(self, 'preview_widgets') or not self.preview_widgets:
            return
        
        for widget in self.preview_widgets:
            if not hasattr(widget, 'segment_positions') or not hasattr(widget, 'preview_text'):
                continue
            
            preview_text = widget.preview_text
            
            # Find the position of the target segment
            target_start = None
            target_end = None
            for (start_pos, end_pos), seg_id in widget.segment_positions.items():
                if seg_id == segment_id:
                    target_start = start_pos
                    target_end = end_pos
                    break
            
            if target_start is None:
                continue
            
            # Update highlighting - need to re-render to show new selection
            # Store the new current segment ID and re-render
            widget.current_highlighted_segment_id = segment_id
            
            # Clear existing formatting and re-apply with new highlight
            cursor = preview_text.textCursor()
            
            # First, remove any existing yellow highlight from ALL segments
            for (start_pos, end_pos), seg_id in widget.segment_positions.items():
                cursor.setPosition(start_pos)
                cursor.setPosition(end_pos, QTextCursor.MoveMode.KeepAnchor)
                fmt = cursor.charFormat()
                # Reset background - use white or status-based color
                if seg_id == segment_id:
                    fmt.setBackground(QColor('#fff9c4'))  # Yellow for current
                else:
                    # Find the segment to get its status
                    seg = next((s for s in self.current_project.segments if s.id == seg_id), None)
                    if seg:
                        if seg.status == 'not_started':
                            fmt.setBackground(QColor('#ffe6e6'))  # Light red
                        elif seg.status in ('translated', 'pretranslated'):
                            fmt.setBackground(QColor('#e6ffe6'))  # Light green
                        elif seg.status in ('confirmed', 'approved', 'proofread'):
                            fmt.setBackground(QColor('#e6f3ff'))  # Light blue
                        else:
                            fmt.setBackground(QColor('white'))
                    else:
                        fmt.setBackground(QColor('white'))
                cursor.mergeCharFormat(fmt)
            
            # Now scroll to the target segment, centered in viewport
            scroll_cursor = preview_text.textCursor()
            scroll_cursor.setPosition(target_start)
            preview_text.setTextCursor(scroll_cursor)
            self._center_cursor_in_preview(preview_text)

    def _center_cursor_in_preview(self, preview_text: QTextEdit):
        """Center the current cursor position in the preview viewport"""
        # Get the cursor rectangle (position in document coordinates)
        cursor_rect = preview_text.cursorRect()
        
        # Get viewport height
        viewport_height = preview_text.viewport().height()
        
        # Calculate scroll position to center the cursor
        # cursor_rect.top() is relative to the viewport, we need document position
        scrollbar = preview_text.verticalScrollBar()
        current_scroll = scrollbar.value()
        
        # The cursor rect top is relative to viewport, so add current scroll to get document position
        cursor_doc_y = current_scroll + cursor_rect.top()
        
        # Calculate target scroll to put cursor in center
        target_scroll = cursor_doc_y - (viewport_height // 2)
        
        # Clamp to valid scroll range
        target_scroll = max(0, min(target_scroll, scrollbar.maximum()))
        
        scrollbar.setValue(target_scroll)

    def refresh_preview(self):
        """Refresh all preview tabs with current document content"""
        if not self.current_project or not self.current_project.segments:
            # Clear previews if no project
            if hasattr(self, 'preview_widgets'):
                for widget in self.preview_widgets:
                    if hasattr(widget, 'preview_text'):
                        widget.preview_text.clear()
                        widget.segment_positions = {}
            return

        if not hasattr(self, 'preview_widgets'):
            return

        for widget in self.preview_widgets:
            self._render_preview(widget)

    def _render_preview(self, widget):
        """Render the document preview with realistic formatting"""
        if not hasattr(widget, 'preview_text'):
            return

        preview_text = widget.preview_text
        preview_text.clear()
        widget.segment_positions = {}

        if not self.current_project or not self.current_project.segments:
            return

        cursor = preview_text.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.Start)

        # Pre-calculate list numbers for numbered list items
        import re
        list_numbers = {}  # {segment_id: list_number}
        list_counter = 0
        
        for seg in self.current_project.segments:
            source_text = seg.source.strip() if seg.source else ""
            
            # Check for list tags (new <li-o>, <li-b> and legacy <li>)
            has_li_ordered = '<li-o>' in source_text or ('<li>' in source_text and '<li-b>' not in source_text)
            has_li_bullet = '<li-b>' in source_text
            
            if has_li_ordered:
                # Check for explicit number in text
                num_match = re.match(r'^<li(?:-o)?>\s*(\d+)[.)\s]', source_text)
                if num_match:
                    list_numbers[seg.id] = int(num_match.group(1))
                    list_counter = int(num_match.group(1))
                else:
                    list_counter += 1
                    list_numbers[seg.id] = list_counter

        # Render all segments
        current_segment_id = self._get_current_segment_id()
        segments = self.current_project.segments
        
        for idx, seg in enumerate(segments):
            style = getattr(seg, 'style', 'Normal') or 'Normal'
            paragraph_id = getattr(seg, 'paragraph_id', 0)
            seg_type = getattr(seg, 'type', 'para') or 'para'
            
            # Normalize type for comparison - grid shows symbols like "¬∂" for para, "Sub" for subtitle
            # Type field values: "para", "heading", "list_item", "table_cell", "Sub", "¬∂", etc.
            seg_type_lower = seg_type.lower() if seg_type else 'para'
            
            # Check if this is a heading/subtitle
            is_heading = ('Heading' in style or 'Title' in style or 'Subtitle' in style 
                          or seg_type_lower in ('heading', 'sub', 'subtitle', 'title'))
            
            # Check if this is a list item
            source_text = seg.source.strip() if seg.source else ""
            is_list_item = ('<li-o>' in source_text or '<li-b>' in source_text or 
                           '<li>' in source_text or seg_type_lower == 'list_item')
            
            # Check if this is a new paragraph (¬∂ symbol or "para" type)
            is_new_paragraph = seg_type == '¬∂' or seg_type_lower == 'para'
            
            # Determine spacing before this segment
            need_double_break = False  # Empty line (for paragraph separation)
            need_single_break = False  # Line break (for headings, list items)
            need_space = False         # Just a space (running text in same paragraph)
            
            if idx > 0:
                prev_seg = segments[idx - 1]
                prev_style = getattr(prev_seg, 'style', 'Normal') or 'Normal'
                prev_paragraph_id = getattr(prev_seg, 'paragraph_id', 0)
                prev_type = getattr(prev_seg, 'type', 'para') or 'para'
                prev_type_lower = prev_type.lower() if prev_type else 'para'
                
                prev_is_heading = ('Heading' in prev_style or 'Title' in prev_style or 
                                   'Subtitle' in prev_style or 
                                   prev_type_lower in ('heading', 'sub', 'subtitle', 'title'))
                prev_is_paragraph = prev_type == '¬∂' or prev_type_lower == 'para'
                prev_is_list = prev_type_lower == 'list_item' or '<li' in (prev_seg.source or '')
                
                # Rules for spacing:
                # 1. After a heading: double break (empty line)
                if prev_is_heading:
                    need_double_break = True
                # 2. Before a heading: double break
                elif is_heading:
                    need_double_break = True
                # 3. New paragraph (different paragraph_id or new ¬∂ type): double break
                elif is_new_paragraph and prev_is_paragraph:
                    # If paragraph_id is being used and changed, it's a new paragraph
                    if paragraph_id != prev_paragraph_id and (paragraph_id != 0 or prev_paragraph_id != 0):
                        need_double_break = True
                    # If both are ¬∂ type, they are separate paragraphs
                    elif prev_type == '¬∂' and seg_type == '¬∂':
                        need_double_break = True
                    else:
                        # Same paragraph, running text
                        need_space = True
                # 4. List items: single break (each on own line)
                elif is_list_item or prev_is_list:
                    need_single_break = True
                # 5. Default: space (running text)
                else:
                    need_space = True
            
            # Insert spacing/breaks
            if need_double_break:
                cursor.insertText("\n\n")  # Empty line between paragraphs
            elif need_single_break:
                cursor.insertText("\n")    # Line break
            elif need_space:
                cursor.insertText(" ")     # Space between sentences
            
            # Set formatting based on style
            char_format = QTextCharFormat()
            char_format.setFontFamily("Georgia")
            
            # Check type field for heading detection as well
            if is_heading and seg_type_lower in ('sub', 'subtitle'):
                # Subtitle style (like "TECHNISCH DOMEIN")
                char_format.setFontPointSize(13)
                char_format.setFontWeight(QFont.Weight.Bold)
                char_format.setForeground(QColor('#1f4068'))
            elif 'Heading 1' in style or 'Heading1' in style or 'Title' in style or seg_type_lower == 'title':
                char_format.setFontPointSize(18)
                char_format.setFontWeight(QFont.Weight.Bold)
                char_format.setForeground(QColor('#1a1a2e'))
            elif 'Heading 2' in style or 'Heading2' in style:
                char_format.setFontPointSize(15)
                char_format.setFontWeight(QFont.Weight.Bold)
                char_format.setForeground(QColor('#16213e'))
            elif 'Heading 3' in style or 'Heading3' in style or seg_type_lower == 'heading':
                char_format.setFontPointSize(13)
                char_format.setFontWeight(QFont.Weight.Bold)
                char_format.setForeground(QColor('#1f4068'))
            else:
                char_format.setFontPointSize(11)
                char_format.setForeground(QColor('#2d2d2d'))

            # Determine what text to display
            if seg.target and seg.target.strip():
                display_text = seg.target
                is_translated = True
            else:
                display_text = seg.source if seg.source else ""
                is_translated = False

            # Set background based on status
            if seg.status == 'not_started':
                char_format.setBackground(QColor('#ffe6e6'))  # Light red
            elif seg.status in ('translated', 'pretranslated'):
                char_format.setBackground(QColor('#e6ffe6'))  # Light green  
            elif seg.status in ('confirmed', 'approved', 'proofread'):
                char_format.setBackground(QColor('#e6f3ff'))  # Light blue
            else:
                char_format.setBackground(QColor('white'))

            # Highlight current segment
            if seg.id == current_segment_id:
                char_format.setBackground(QColor('#fff9c4'))  # Light yellow

            # Gray out untranslated text
            if not is_translated:
                char_format.setForeground(QColor('#888888'))
                char_format.setFontItalic(True)

            # Store position for click navigation
            start_pos = cursor.position()

            # Render text with list formatting
            self._render_formatted_text(cursor, display_text, char_format, 
                                        list_number=list_numbers.get(seg.id))

            end_pos = cursor.position()
            widget.segment_positions[(start_pos, end_pos)] = seg.id
            
            # Track position of current segment for scrolling
            if seg.id == current_segment_id:
                widget.current_segment_start_pos = start_pos

            # Note: Line breaks are now handled at the START of each segment based on context
            # This ensures running text flows naturally while paragraphs are separated

        # Add final newline at end of document
        cursor.insertText("\n")

        # Scroll to current segment if we have one
        if hasattr(widget, 'current_segment_start_pos') and widget.current_segment_start_pos is not None:
            # Create cursor at the current segment position
            scroll_cursor = preview_text.textCursor()
            scroll_cursor.setPosition(widget.current_segment_start_pos)
            preview_text.setTextCursor(scroll_cursor)
            # Center the segment in the viewport
            # Use QTimer to delay centering until after layout is complete
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(0, lambda pt=preview_text: self._center_cursor_in_preview(pt))
        else:
            # Set cursor to beginning if no current segment
            cursor.movePosition(QTextCursor.MoveOperation.Start)
            preview_text.setTextCursor(cursor)

    def _render_formatted_text(self, cursor, text: str, base_format: QTextCharFormat,
                                list_number: Optional[int] = None):
        """Render text with list prefix and inline formatting tags preserved"""
        import re

        # Check for list tags
        has_li_bullet = '<li-b>' in text
        has_li_ordered = '<li-o>' in text or ('<li>' in text and '<li-b>' not in text)

        # Remove list tags from display  
        text = re.sub(r'</?li-b>', '', text)
        text = re.sub(r'</?li-o>', '', text)
        text = re.sub(r'</?li>', '', text)

        # Add list prefix if this is a list item
        if has_li_bullet or has_li_ordered:
            bullet_format = QTextCharFormat(base_format)
            bullet_format.setForeground(QColor('#ff6600'))  # Orange
            bullet_format.setFontWeight(QFont.Weight.Bold)
            bullet_format.setFontItalic(False)

            if has_li_ordered and list_number:
                cursor.insertText(f"{list_number}. ", bullet_format)
            elif has_li_ordered:
                cursor.insertText("‚Ä¢ ", bullet_format)  # Fallback if no number
            else:
                cursor.insertText("‚Ä¢ ", bullet_format)

        # Parse text for inline formatting tags
        tag_pattern = re.compile(r'(</?(?:b|i|u|bi|sub|sup)>)')
        parts = tag_pattern.split(text)

        is_bold = False
        is_italic = False
        is_underline = False
        is_subscript = False
        is_superscript = False

        for part in parts:
            if not part:
                continue

            if part == '<b>':
                is_bold = True
                continue
            elif part == '</b>':
                is_bold = False
                continue
            elif part == '<i>':
                is_italic = True
                continue
            elif part == '</i>':
                is_italic = False
                continue
            elif part == '<u>':
                is_underline = True
                continue
            elif part == '</u>':
                is_underline = False
                continue
            elif part == '<bi>':
                is_bold = True
                is_italic = True
                continue
            elif part == '</bi>':
                is_bold = False
                is_italic = False
                continue
            elif part == '<sub>':
                is_subscript = True
                continue
            elif part == '</sub>':
                is_subscript = False
                continue
            elif part == '<sup>':
                is_superscript = True
                continue
            elif part == '</sup>':
                is_superscript = False
                continue

            # Apply formatting to text
            text_format = QTextCharFormat(base_format)
            
            if is_bold:
                text_format.setFontWeight(QFont.Weight.Bold)
            if is_italic:
                text_format.setFontItalic(True)
            if is_underline:
                text_format.setUnderlineStyle(QTextCharFormat.UnderlineStyle.SingleUnderline)
            if is_subscript:
                text_format.setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignSubScript)
            if is_superscript:
                text_format.setVerticalAlignment(QTextCharFormat.VerticalAlignment.AlignSuperScript)

            cursor.insertText(part, text_format)

    def highlight_preview_segment(self, segment_id: Optional[int] = None):
        """Update the preview to highlight the specified segment (or current if None)"""
        if segment_id is None:
            segment_id = self._get_current_segment_id()
        
        if not segment_id:
            return
            
        # Store for later reference
        self._highlighted_segment_id = segment_id
        
        # Re-render preview to update highlighting
        # (In a full implementation, we'd just update the highlight without full re-render)

    def _create_status_cell_widget(self, segment: Segment) -> QWidget:
        widget = QWidget()
        layout = QHBoxLayout(widget)
        layout.setContentsMargins(4, 2, 4, 2)  # Slightly more vertical padding
        layout.setSpacing(6)
        layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)  # Center content vertically
        # Remove fixed minimum height - let it adapt to row height
        widget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        widget.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)

        # Check if segment has notes
        has_notes = segment.notes and segment.notes.strip()
        
        # Widget background always transparent
        widget.setStyleSheet("background: transparent;")
        if has_notes:
            widget.setToolTip(f"Notes: {segment.notes.strip()}")
            
        status_def = get_status(segment.status)
        status_label = QLabel(status_def.icon)
        status_label.setAlignment(Qt.AlignmentFlag.AlignVCenter | Qt.AlignmentFlag.AlignLeft)
        status_label.setToolTip(status_def.label)
        # Smaller red X for "not_started" to match green checkmark visual size
        font_size = "8px" if segment.status == "not_started" else "13px"
        # Make confirmed checkmark green
        color = "color: #2e7d32;" if segment.status == "confirmed" else ""
        
        # Apply orange background highlight to status icon if segment has notes
        if has_notes:
            status_label.setStyleSheet(f"font-size: {font_size}; {color} padding: 2px 4px; background-color: rgba(255, 152, 0, 0.35); border-radius: 3px;")
        else:
            status_label.setStyleSheet(f"font-size: {font_size}; {color} padding-right: 4px;")
        layout.addWidget(status_label)

        # Only add match label if there's a match percentage
        if segment.match_percent is not None:
            match_text = f"{segment.match_percent}%"
            match_label = QLabel(match_text)
            match_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            match_label.setMinimumWidth(40)
            match_label.setSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Preferred)
            if segment.match_percent >= 101:
                match_label.setStyleSheet("color: #1b5e20; font-weight: bold; padding-left: 4px; padding-right: 4px;")
                match_label.setToolTip("Context match from memoQ (101% or better)")
            elif segment.match_percent >= 100:
                match_label.setStyleSheet("color: #2e7d32; font-weight: bold; padding-left: 4px; padding-right: 4px;")
                match_label.setToolTip("Exact match from memoQ (100%)")
            elif segment.match_percent >= 90:
                match_label.setStyleSheet("color: #1565C0; font-weight: bold; padding-left: 4px; padding-right: 4px;")
                match_label.setToolTip(f"High fuzzy match {segment.match_percent}%")
            else:
                match_label.setStyleSheet("color: #0d47a1; padding-left: 4px; padding-right: 4px;")
                match_label.setToolTip(f"Fuzzy match {segment.match_percent}%")
            layout.addWidget(match_label)

        layout.addStretch(1)

        return widget

    def _update_status_cell(self, row: int, segment: Segment):
        status_widget = self._create_status_cell_widget(segment)
        self.table.setCellWidget(row, 4, status_widget)
        status_item = self.table.item(row, 4)
        if status_item is None:
            status_item = QTableWidgetItem()
            self.table.setItem(row, 4, status_item)
        status_item.setText("")
        status_item.setFlags(Qt.ItemFlag.ItemIsSelectable | Qt.ItemFlag.ItemIsEnabled)
        # Set background color on table item (widget is transparent)
        status_item.setBackground(QColor(get_status(segment.status).color))
        status_item.setData(Qt.ItemDataRole.DisplayRole, "")
        status_widget.updateGeometry()

    def _refresh_segment_status(self, segment: Segment):
        if not self.current_project:
            return
        for row, seg in enumerate(self.current_project.segments):
            if seg.id == segment.id:
                self._update_status_cell(row, seg)
                break

        # Update list view entry in place (if visible)
        if hasattr(self, 'list_tree') and self.list_tree:
            matches = self.list_tree.findItems(str(segment.id), Qt.MatchFlag.MatchExactly, 0)
            for item in matches:
                status_def = get_status(segment.status)
                match_text = f"{segment.match_percent}%" if segment.match_percent is not None else ""
                display = f"{status_def.icon}"
                if match_text:
                    display += f"  {match_text}"
                if segment.notes and segment.notes.strip():
                    display += "  üí¨"
                item.setText(2, display)
                status_tooltip = status_def.label
                if segment.match_percent is not None:
                    status_tooltip += f" | {segment.match_percent}% match"
                if segment.notes and segment.notes.strip():
                    status_tooltip += f"\nComment: {segment.notes.strip()}"
                item.setToolTip(2, status_tooltip)
                item.setBackground(2, QColor(status_def.color))
        self._enforce_status_row_heights()

    def _refresh_segment_status_by_id(self, segment_id: int):
        """Refresh the status display for a segment by its ID."""
        if not self.current_project:
            return
        segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
        if segment:
            self._refresh_segment_status(segment)

    def _enforce_status_row_heights(self):
        """No longer needed - status widgets now adapt to row height."""
        # This method is kept for backward compatibility but does nothing
        pass


    
    def clear_grid(self):
        """Clear all rows from grid"""
        self.table.setRowCount(0)
    
    def toggle_termview_under_grid(self):
        """Show/hide the Termview panel under the grid for maximum vertical space"""
        if not hasattr(self, 'bottom_tabs'):
            return
        
        # Toggle visibility
        is_visible = self.bottom_tabs.isVisible()
        self.bottom_tabs.setVisible(not is_visible)
        
        # Update menu action checkmark
        if hasattr(self, 'termview_visible_action'):
            self.termview_visible_action.setChecked(not is_visible)
        
        # Save state to settings
        settings = self.load_general_settings()
        settings['termview_under_grid_visible'] = not is_visible
        self.save_general_settings(settings)
    
    def auto_resize_rows(self):
        """Auto-resize all rows to fit content - Compact version"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        # Reduce width slightly to account for padding and prevent text cut-off
        width_reduction = 8
        
        # Manually calculate and set row heights for compact display
        for row in range(self.table.rowCount()):
            self._auto_resize_single_row(row, width_reduction)
        
        self.log("‚úì Auto-resized rows to fit content (compact)")
        self._enforce_status_row_heights()
    
    def _auto_resize_single_row(self, row: int, width_reduction: int = 8):
        """Auto-resize a single row to fit its content. Called automatically after text changes."""
        if not hasattr(self, 'table') or not self.table:
            return
        if row < 0 or row >= self.table.rowCount():
            return
        
        max_height = 1
        
        # Check source cell (column 2)
        source_widget = self.table.cellWidget(row, 2)
        if source_widget and isinstance(source_widget, ReadOnlyGridTextEditor):
            doc = source_widget.document()
            if doc:
                col_width = self.table.columnWidth(2) - width_reduction
                if col_width > 0:
                    doc.setTextWidth(col_width)
                    size = doc.size()
                    if size.isValid():
                        height = int(size.height())
                        max_height = max(max_height, height)
        
        # Check target cell (column 3)
        target_widget = self.table.cellWidget(row, 3)
        if target_widget and isinstance(target_widget, EditableGridTextEditor):
            doc = target_widget.document()
            if doc:
                col_width = self.table.columnWidth(3) - width_reduction
                if col_width > 0:
                    doc.setTextWidth(col_width)
                    size = doc.size()
                    if size.isValid():
                        height = int(size.height())
                        max_height = max(max_height, height)
        
        # Set row height with minimal padding
        # Minimum 32px to accommodate status icons (16px) + match text + padding without any cutoff
        compact_height = max(max_height + 2, 32)
        self.table.setRowHeight(row, compact_height)
    
    def apply_font_to_grid(self):
        """Apply selected font to all grid cells"""
        font = QFont(self.default_font_family, self.default_font_size)
        
        self.table.setFont(font)
        
        # Also update header font - same size as grid content, just bold
        header_font = QFont(self.default_font_family, self.default_font_size, QFont.Weight.Bold)
        self.table.horizontalHeader().setFont(header_font)
        
        # Update fonts in QTextEdit widgets (source and target columns)
        if hasattr(self, 'table') and self.table:
            for row in range(self.table.rowCount()):
                # Source column (2) - ReadOnlyGridTextEditor
                source_widget = self.table.cellWidget(row, 2)
                if source_widget and isinstance(source_widget, ReadOnlyGridTextEditor):
                    source_widget.setFont(font)
                
                # Target column (3) - EditableGridTextEditor
                target_widget = self.table.cellWidget(row, 3)
                if target_widget and isinstance(target_widget, EditableGridTextEditor):
                    target_widget.setFont(font)
        
        # Adjust segment number column width based on font size
        self._update_segment_column_width()
    
    def _update_segment_column_width(self):
        """Adjust segment number column width to fit the largest segment number.
        
        Uses font metrics to calculate exact width needed for the highest segment number.
        """
        if not hasattr(self, 'table') or not self.table:
            return
        
        # Get the highest segment number we need to display
        max_segment = self.table.rowCount()
        if max_segment == 0:
            max_segment = 1
        
        # Use font metrics to calculate exact width needed
        font = QFont(self.default_font_family, self.default_font_size)
        fm = QFontMetrics(font)
        
        # Measure the width of the largest number (as string)
        text_width = fm.horizontalAdvance(str(max_segment))
        
        # Add padding (10px on each side = 20px total)
        new_width = text_width + 20
        
        # Ensure minimum width for very small numbers
        new_width = max(30, new_width)
        
        self.table.setColumnWidth(0, new_width)
    
    def set_font_family(self, family_name: str):
        """Set font family from menu"""
        self.default_font_family = family_name
        self.apply_font_to_grid()
        self.auto_resize_rows()
        self.log(f"‚úì Font changed to {family_name}")
    
    def increase_font_size(self):
        """Increase grid font size."""
        self.default_font_size = min(72, self.default_font_size + 1)
        self.apply_font_to_grid()
        self.auto_resize_rows()
        self.log(f"‚úì Font size: {self.default_font_size}")
        # Save font size to preferences
        self.save_current_font_sizes()
    
    def decrease_font_size(self):
        """Decrease grid font size."""
        self.default_font_size = max(7, self.default_font_size - 1)
        self.apply_font_to_grid()
        self.auto_resize_rows()
        self.log(f"‚úì Font size: {self.default_font_size}")
        # Save font size to preferences
        self.save_current_font_sizes()
    
    def refresh_grid_tag_colors(self):
        """Refresh tag highlight colors in all grid cells"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        for row in range(self.table.rowCount()):
            # Source column (2) - ReadOnlyGridTextEditor
            source_widget = self.table.cellWidget(row, 2)
            if source_widget and isinstance(source_widget, ReadOnlyGridTextEditor):
                if hasattr(source_widget, 'highlighter'):
                    source_widget.highlighter.set_tag_color(EditableGridTextEditor.tag_highlight_color)
            
            # Target column (3) - EditableGridTextEditor
            target_widget = self.table.cellWidget(row, 3)
            if target_widget and isinstance(target_widget, EditableGridTextEditor):
                if hasattr(target_widget, 'highlighter'):
                    target_widget.highlighter.set_tag_color(EditableGridTextEditor.tag_highlight_color)

    def _apply_row_color(self, row: int, source_widget, target_widget):
        """Apply alternating row color to source and target widgets for a specific row"""
        # Load settings (with caching to avoid repeated file reads)
        # Cache is keyed by theme name to refresh when theme changes
        theme = self.theme_manager.current_theme
        cache_key = f'_row_color_cache_{theme.name}'

        if not hasattr(self, cache_key):
            settings = self.load_general_settings()
            # Always use current theme colors for row alternation, not saved settings
            # This ensures rows are dark in dark themes and light in light themes
            cached_data = {
                'enabled': settings.get('enable_alternating_row_colors', True),
                'even_color': theme.base,  # Always use theme color
                'odd_color': theme.alternate_bg  # Always use theme color
            }
            setattr(self, cache_key, cached_data)
            # Also update the old cache name for backwards compatibility
            self._row_color_settings_cached = cached_data
        else:
            self._row_color_settings_cached = getattr(self, cache_key)
        
        settings = self._row_color_settings_cached
        
        if not settings['enabled']:
            # Use theme default colors when disabled - remove hardcoded backgrounds
            # The theme system will handle the background colors
            return
        
        # Determine color based on row index (even/odd)
        color = settings['even_color'] if row % 2 == 0 else settings['odd_color']
        row_color = QColor(color)
        
        # Apply to ID column (column 0)
        id_item = self.table.item(row, 0)
        if id_item:
            id_item.setBackground(row_color)
        
        # Apply to Type column (column 1) - but preserve heading/list item colors
        type_item = self.table.item(row, 1)
        if type_item:
            type_text = type_item.text()
            # Only apply row color if it's not a special type (headings/list items have their own colors)
            if type_text not in ("H1", "H2", "H3", "H4", "Title", "li"):
                type_item.setBackground(row_color)
        
        # Apply to source widget
        if hasattr(source_widget, 'set_background_color'):
            source_widget.set_background_color(color)
        
        # Apply to target widget
        if hasattr(target_widget, 'set_background_color'):
            target_widget.set_background_color(color)
    
    def apply_alternating_row_colors(self):
        """Apply alternating row colors to all source and target cells in the grid"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        # Clear cached settings to force reload
        if hasattr(self, '_row_color_settings_cached'):
            delattr(self, '_row_color_settings_cached')
        
        for row in range(self.table.rowCount()):
            source_widget = self.table.cellWidget(row, 2)
            target_widget = self.table.cellWidget(row, 3)
            
            if source_widget and target_widget:
                self._apply_row_color(row, source_widget, target_widget)
        
        self.log("‚úì Alternating row colors applied")
    
    def on_font_changed(self):
        """Handle font change - legacy method for compatibility"""
        self.apply_font_to_grid()
        self.auto_resize_rows()

    
    def zoom_in(self):
        """Increase grid font size (zoom in)."""
        self.increase_font_size()
    
    def zoom_out(self):
        """Decrease grid font size (zoom out)."""
        self.decrease_font_size()
    
    def results_pane_zoom_in(self):
        """Increase font size in translation results pane"""
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                if hasattr(panel, 'zoom_in'):
                    panel.zoom_in()
            # Save font sizes to preferences
            self.save_current_font_sizes()
    
    def results_pane_zoom_out(self):
        """Decrease font size in translation results pane"""
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                if hasattr(panel, 'zoom_out'):
                    panel.zoom_out()
            # Save font sizes to preferences
            self.save_current_font_sizes()
    
    def results_pane_zoom_reset(self):
        """Reset font size in translation results pane to default"""
        if hasattr(self, 'results_panels'):
            for panel in self.results_panels:
                if hasattr(panel, 'reset_zoom'):
                    panel.reset_zoom()
            # Save font sizes to preferences
            self.save_current_font_sizes()
    
    # =========================================================================
    # MATCH PANEL ZOOM METHODS
    # =========================================================================
    
    # Class variable for Match Panel font size (TM Source/Target boxes)
    match_panel_font_size = 10  # Default font size
    
    def match_panel_zoom_in(self):
        """Increase font size in Match Panel TM boxes"""
        SupervertalerQt.match_panel_font_size = min(18, SupervertalerQt.match_panel_font_size + 1)
        self._apply_match_panel_font_size()
        self.save_current_font_sizes()
        self.log(f"Match Panel font size: {SupervertalerQt.match_panel_font_size}pt")
    
    def match_panel_zoom_out(self):
        """Decrease font size in Match Panel TM boxes"""
        SupervertalerQt.match_panel_font_size = max(7, SupervertalerQt.match_panel_font_size - 1)
        self._apply_match_panel_font_size()
        self.save_current_font_sizes()
        self.log(f"Match Panel font size: {SupervertalerQt.match_panel_font_size}pt")
    
    def match_panel_zoom_reset(self):
        """Reset font size in Match Panel TM boxes to default"""
        SupervertalerQt.match_panel_font_size = 10
        self._apply_match_panel_font_size()
        self.save_current_font_sizes()
        self.log("Match Panel font size reset to 10pt")
    
    def _apply_match_panel_font_size(self):
        """Apply current font size to Match Panel TM Source/Target text edits"""
        if not hasattr(self, 'compare_panel_text_edits'):
            return
        
        font_size = SupervertalerQt.match_panel_font_size
        
        for item in self.compare_panel_text_edits:
            text_edit = item[0]  # First element is the QTextEdit
            if text_edit and hasattr(text_edit, 'setStyleSheet'):
                # Preserve existing style but update font size
                current_style = text_edit.styleSheet()
                # Update font-size in the stylesheet
                import re
                new_style = re.sub(r'font-size:\s*\d+px;?', f'font-size: {font_size}px;', current_style)
                if 'font-size' not in new_style:
                    new_style += f" font-size: {font_size}px;"
                text_edit.setStyleSheet(new_style)
    
    def save_current_font_sizes(self):
        """Save current font sizes to preferences"""
        try:
            from modules.translation_results_panel import CompactMatchItem, TranslationResultsPanel
            general_settings = self.load_general_settings()
            general_settings['grid_font_family'] = self.default_font_family
            general_settings['grid_font_size'] = self.default_font_size
            if hasattr(CompactMatchItem, 'font_size_pt'):
                general_settings['results_match_font_size'] = CompactMatchItem.font_size_pt
            if hasattr(TranslationResultsPanel, 'compare_box_font_size'):
                general_settings['results_compare_font_size'] = TranslationResultsPanel.compare_box_font_size
            if hasattr(CompactMatchItem, 'show_tags'):
                general_settings['results_show_tags'] = CompactMatchItem.show_tags
            if hasattr(EditableGridTextEditor, 'tag_highlight_color'):
                general_settings['tag_highlight_color'] = EditableGridTextEditor.tag_highlight_color
            # Save Match Panel font size
            general_settings['match_panel_font_size'] = SupervertalerQt.match_panel_font_size
            # Preserve other settings
            if 'restore_last_project' not in general_settings:
                general_settings['restore_last_project'] = False
            self.save_general_settings(general_settings)
        except Exception as e:
            # Silently fail - don't interrupt user workflow
            pass
    
    def load_general_settings(self) -> Dict[str, Any]:
        """Load general application settings"""
        # Initialize auto-propagation from loaded settings
        settings = self._load_general_settings_from_file()
        if 'auto_propagate_exact_matches' in settings:
            self.auto_propagate_exact_matches = settings['auto_propagate_exact_matches']
        if 'auto_insert_100_percent_matches' in settings:
            self.auto_insert_100_percent_matches = settings['auto_insert_100_percent_matches']
        if 'auto_confirm_100_percent_matches' in settings:
            self.auto_confirm_100_percent_matches = settings['auto_confirm_100_percent_matches']
        if 'auto_confirm_overwrite_existing' in settings:
            self.auto_confirm_overwrite_existing = settings['auto_confirm_overwrite_existing']
        # Load TM/termbase matching setting
        if 'enable_tm_termbase_matching' in settings:
            self.enable_tm_matching = settings['enable_tm_termbase_matching']
            self.enable_termbase_matching = settings['enable_tm_termbase_matching']
        # Load termbase grid highlighting setting
        if 'enable_termbase_grid_highlighting' in settings:
            self.enable_termbase_grid_highlighting = settings['enable_termbase_grid_highlighting']
        # Load auto-markdown setting
        self.auto_generate_markdown = settings.get('auto_generate_markdown', False)
        # Load TM save mode
        self.tm_save_mode = settings.get('tm_save_mode', 'latest')
        # Load debug mode settings
        self.debug_mode_enabled = settings.get('debug_mode_enabled', False)
        self.debug_auto_export = settings.get('debug_auto_export', False)
        # Load LLM matching setting (default: FALSE - too slow!)
        self.enable_llm_matching = settings.get('enable_llm_matching', False)
        # Load precision scroll divisor setting
        self.precision_scroll_divisor = settings.get('precision_scroll_divisor', 3)
        # Load auto-center active segment setting (default True, like memoQ/Trados)
        self.auto_center_active_segment = settings.get('auto_center_active_segment', True)
        # Load termbase display settings
        self.termbase_display_order = settings.get('termbase_display_order', 'appearance')
        self.termbase_hide_shorter_matches = settings.get('termbase_hide_shorter_matches', False)
        # Load invisible character color
        self.invisible_char_color = settings.get('invisible_char_color', '#999999')
        # Load smart word selection setting
        self.enable_smart_word_selection = settings.get('enable_smart_word_selection', True)
        
        # Load alternating row color settings
        self.enable_alternating_row_colors = settings.get('enable_alternating_row_colors', True)
        self.even_row_color = settings.get('even_row_color', '#FFFFFF')
        self.odd_row_color = settings.get('odd_row_color', '#F0F0F0')
        
        # Load termbase highlight style settings
        self.termbase_highlight_style = settings.get('termbase_highlight_style', 'semibold')
        self.termbase_dotted_color = settings.get('termbase_dotted_color', '#808080')
        
        # Load tab position setting
        self.tabs_above_grid = settings.get('tabs_above_grid', False)
        
        # Load panel visibility settings
        self.show_translation_results_pane = settings.get('show_translation_results_pane', False)
        self.show_compare_panel = settings.get('show_compare_panel', True)

        # Load cache kill switch setting (default: False = caches ENABLED for performance)
        self.disable_all_caches = settings.get('disable_all_caches', False)

        # Load LLM provider settings for AI Assistant
        llm_settings = self.load_llm_settings()
        self.current_provider = llm_settings.get('provider', 'openai')
        provider_key = f"{self.current_provider}_model"
        self.current_model = llm_settings.get(provider_key)

        return settings
    
    def _load_general_settings_from_file(self) -> Dict[str, Any]:
        """Load general settings from general_settings.json (global defaults)"""
        settings_file = self.user_data_path / "general_settings.json"
        
        defaults = {
            'restore_last_project': False,
            'auto_propagate_exact_matches': True,
            'auto_center_active_segment': True,  # Default to True (like memoQ/Trados)
            'enable_sound_effects': False,
            'sound_effects_map': {
                'glossary_term_added': 'asterisk',
                'glossary_created': 'asterisk',
                'match_inserted': 'ok',
                'glossary_term_duplicate': 'exclamation',
                'glossary_term_error': 'hand'
            },
            'grid_font_size': 11,
            'results_match_font_size': 9,
            'results_compare_font_size': 9
        }
        
        if not settings_file.exists():
            return defaults
        
        try:
            with open(settings_file, 'r') as f:
                settings = json.load(f)
                # Merge with defaults to ensure all keys exist
                result = defaults.copy()
                result.update(settings)
                return result
        except:
            return defaults
    
    def save_general_settings(self, settings: Dict[str, Any]):
        """Save general settings to general_settings.json (global defaults)"""
        settings_file = self.user_data_path / "general_settings.json"
        
        # Save settings directly (not nested)
        try:
            with open(settings_file, 'w') as f:
                json.dump(settings, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save general settings: {str(e)}")

    def load_dictation_settings(self) -> Dict[str, Any]:
        """Load Supervoice settings"""
        prefs_file = self.user_data_path / "ui_preferences.json"

        defaults = {
            'model': 'base',
            'max_duration': 10,
            'language': 'Auto (use project target language)'
        }

        if not prefs_file.exists():
            return defaults

        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                dictation = prefs.get('dictation_settings', {})
                result = defaults.copy()
                result.update(dictation)
                return result
        except:
            return defaults

    def save_dictation_settings(self, model: str, duration: int, language: str):
        """Save Supervoice settings"""
        prefs_file = self.user_data_path / "ui_preferences.json"

        # Load existing preferences to check if model changed
        old_model = None
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
                    old_model = prefs.get('dictation_settings', {}).get('model')
            except:
                pass

        # Update dictation settings
        prefs['dictation_settings'] = {
            'model': model,
            'max_duration': duration,
            'language': language
        }

        # Model download info
        model_sizes = {
            'tiny': '75 MB',
            'base': '142 MB',
            'small': '466 MB',
            'medium': '1.5 GB',
            'large': '2.9 GB'
        }

        # Save back
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
            self.log(f"‚úì Supervoice settings saved: Model={model}, Duration={duration}s")

            # Build message
            message = (
                f"Supervoice settings saved successfully!\n\n"
                f"Model: {model}\n"
                f"Max Duration: {duration} seconds\n"
                f"Language: {language}"
            )

            # Add download info if model changed
            if old_model != model:
                import os
                cache_path = os.path.expanduser('~/.cache/whisper')
                if os.name == 'nt':  # Windows
                    cache_path = os.path.join(os.environ.get('USERPROFILE', ''), '.cache', 'whisper')

                download_size = model_sizes.get(model, 'unknown size')
                message += (
                    f"\n\nüì• Model Download Info:\n"
                    f"If you haven't used the '{model}' model before, it will be\n"
                    f"downloaded automatically on first use ({download_size}).\n\n"
                    f"Storage location:\n{cache_path}"
                )

            QMessageBox.information(self, "Settings Saved", message)
        except Exception as e:
            self.log(f"‚ö† Could not save Supervoice settings: {str(e)}")
            QMessageBox.warning(self, "Save Error", f"Could not save settings:\n{str(e)}")

    def load_language_settings(self):
        """Load language settings from preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"

        defaults = {
            'source_language': 'English',
            'target_language': 'Dutch'
        }
        
        if not prefs_file.exists():
            return
        
        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                lang_settings = prefs.get('language_settings', {})
                self.source_language = lang_settings.get('source_language', defaults['source_language'])
                self.target_language = lang_settings.get('target_language', defaults['target_language'])
                
                # Load spellcheck settings
                spellcheck_settings = prefs.get('spellcheck_settings', {})
                self.spellcheck_enabled = spellcheck_settings.get('enabled', False)
                TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
                
                # Set spellcheck language based on target language
                if self.spellcheck_manager and self.spellcheck_enabled:
                    if self.spellcheck_manager.set_language(self.target_language):
                        self.log(f"‚úì Spellcheck initialized for {self.target_language}")
                    else:
                        self.log(f"‚ö† Spellcheck dictionary not available for {self.target_language}")
        except:
            pass
    
    def save_language_settings(self, source_lang: str, target_lang: str):
        """Save language settings to preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        # Load existing preferences
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        # Update language settings
        prefs['language_settings'] = {
            'source_language': source_lang,
            'target_language': target_lang
        }
        
        # Save back
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save language settings: {str(e)}")
    
    def _save_language_settings_from_ui(self, source_combo, target_combo):
        """Save language settings from UI"""
        self.source_language = source_combo.currentText()
        self.target_language = target_combo.currentText()
        self.save_language_settings(self.source_language, self.target_language)
        
        self.log(f"‚úì Language settings saved: {self.source_language} ‚Üí {self.target_language}")
        QMessageBox.information(self, "Settings Saved", 
                              f"Language settings have been saved:\n\n"
                              f"Source: {self.source_language}\n"
                              f"Target: {self.target_language}")
    
    def load_font_sizes_from_preferences(self):
        """Load and apply font sizes from preferences on startup"""
        try:
            general_settings = self.load_general_settings()
            
            # Load grid font family
            font_family = general_settings.get('grid_font_family', 'Calibri')
            if font_family:
                self.default_font_family = font_family
            
            # Load grid font size
            grid_size = general_settings.get('grid_font_size', 11)
            if 7 <= grid_size <= 72:
                self.default_font_size = grid_size
            
            # Apply font to grid if it exists
            if hasattr(self, 'table') and self.table is not None:
                self.apply_font_to_grid()
            
            # Load results pane font sizes
            match_size = general_settings.get('results_match_font_size', 9)
            compare_size = general_settings.get('results_compare_font_size', 9)
            show_tags = general_settings.get('results_show_tags', False)
            
            # Apply to all results panels
            if hasattr(self, 'results_panels'):
                if 7 <= match_size <= 16:
                    from modules.translation_results_panel import CompactMatchItem
                    CompactMatchItem.set_font_size(match_size)
                    for panel in self.results_panels:
                        if hasattr(panel, 'set_font_size'):
                            panel.set_font_size(match_size)
                
                if 7 <= compare_size <= 14:
                    from modules.translation_results_panel import TranslationResultsPanel
                    TranslationResultsPanel.compare_box_font_size = compare_size
                    for panel in self.results_panels:
                        if hasattr(panel, 'set_compare_box_font_size'):
                            panel.set_compare_box_font_size(compare_size)
                
                # Apply show_tags setting
                from modules.translation_results_panel import CompactMatchItem
                CompactMatchItem.show_tags = show_tags
                for panel in self.results_panels:
                    if hasattr(panel, 'set_show_tags'):
                        panel.set_show_tags(show_tags)
                
                # Load and apply tag color
                tag_color = general_settings.get('tag_highlight_color', '#7f0001')
                EditableGridTextEditor.tag_highlight_color = tag_color
                ReadOnlyGridTextEditor.tag_highlight_color = tag_color
                CompactMatchItem.tag_highlight_color = tag_color
                for panel in self.results_panels:
                    if hasattr(panel, 'set_tag_color'):
                        panel.set_tag_color(tag_color)
                
                # Load and apply badge text color
                badge_text_color = general_settings.get('badge_text_color', '#333333')
                CompactMatchItem.badge_text_color = badge_text_color
                
                # Load and apply focus border settings
                focus_border_color = general_settings.get('focus_border_color', '#f1b79a')
                focus_border_thickness = general_settings.get('focus_border_thickness', 2)
                EditableGridTextEditor.focus_border_color = focus_border_color
                EditableGridTextEditor.focus_border_thickness = focus_border_thickness
                
            # Load and apply Match Panel font size
            match_panel_size = general_settings.get('match_panel_font_size', 10)
            if 7 <= match_panel_size <= 18:
                SupervertalerQt.match_panel_font_size = match_panel_size
                self._apply_match_panel_font_size()
                
            if hasattr(self, 'results_panels'):
                # Load and apply match limits
                match_limits = general_settings.get('match_limits', {
                    'LLM': 3,
                    'MT': 3,
                    'TM': 5,
                    'Termbases': 10
                })
                for panel in self.results_panels:
                    panel.match_limits = match_limits
                    
        except Exception as e:
            self.log(f"‚ö† Could not load font sizes: {e}")
    
    def restore_last_project_if_enabled(self):
        """Restore the last opened project on startup if the setting is enabled"""
        try:
            # Check if setting is enabled
            general_settings = self.load_general_settings()
            if not general_settings.get('restore_last_project', False):
                return
            
            # Get recent projects
            recent_projects = self.load_recent_projects()
            if not recent_projects:
                return
            
            # Get the most recent project (first in the list)
            # Recent projects are sorted by most recent first
            last_project = recent_projects[0]
            project_path = last_project.get('path') if isinstance(last_project, dict) else last_project
            
            # Verify file exists
            if not project_path or not os.path.exists(project_path):
                self.log(f"‚ö† Last project file not found: {project_path}")
                return
            
            # Load the project
            self.log(f"üîÑ Restoring last project: {Path(project_path).name}")
            self.load_project(project_path)
            
        except Exception as e:
            # Silently fail - don't block startup if restoration fails
            self.log(f"‚ö† Could not restore last project: {e}")
    
    
    def get_status_icon(self, status: str) -> str:
        """Get status icon for display"""
        return get_status(status).icon
    
    def _handle_target_text_debounced_by_id(self, segment_id, new_text):
        """
        Handle expensive target text change operations after user stops typing.
        Called 500ms after last keystroke to avoid UI lag.
        Uses segment ID to find the correct segment (not row index).
        """
        try:
            # Find segment by ID
            segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
            if not segment:
                return
            
            # Find current row for this segment
            row = next((i for i, seg in enumerate(self.current_project.segments) if seg.id == segment_id), None)
            if row is None:
                return
            
            # Note: Status is now set to "not_started" immediately on edit (in on_target_text_changed)
            # User must manually confirm/approve to change status to translated/confirmed
            
            # Update window title
            self.update_window_title()
            
            # Auto-resize only this row (fast, single-row operation)
            self._auto_resize_single_row(row)
            
            # Save to TM ONLY if segment is confirmed (user explicitly approved)
            # Do NOT save for 'translated' status - that's just machine/batch translated
            if segment.status == 'confirmed' and new_text.strip():
                try:
                    self.save_segment_to_activated_tms(segment.source, new_text)
                except Exception as e:
                    self.log(f"Warning: Could not save to TM: {e}")
            
            # Update status bar progress stats (debounced - only after user stops typing)
            self.update_progress_stats()
            
            # üöÄ IDLE PREFETCH: User stopped typing, prefetch next segments for instant Ctrl+Enter
            self._trigger_idle_prefetch(row)
            
        except Exception as e:
            self.log(f"Error in debounced target handler: {e}")
    
    def update_status_icon(self, row: int, status: str):
        """Update status icon for a specific row"""
        if not self.current_project or row >= len(self.current_project.segments):
            return
        segment = self.current_project.segments[row]
        old_status = segment.status
        old_target = segment.target
        segment.status = status
        
        # Record undo state for status change
        self.record_undo_state(segment.id, old_target, segment.target, old_status, status)
        
        self._refresh_segment_status(segment)
        
        # Save to TM ONLY if status changed to confirmed (user explicitly approved)
        # Do NOT save for 'translated' or 'approved' status - user must confirm first
        find_replace_active = getattr(self, 'find_replace_active', False)
        if not find_replace_active and status == 'confirmed' and segment.target.strip():
            try:
                self.save_segment_to_activated_tms(segment.source, segment.target)
            except Exception as e:
                self.log(f"Warning: Could not save to TM: {e}")
    
    def on_cell_changed(self, item: QTableWidgetItem):
        """Handle cell content changes - now mainly for placeholder items"""
        # Target cell changes are handled by the EditableGridTextEditor's textChanged signal
        # This method is kept for compatibility but should rarely be called now
        # Placeholder items (columns 2 and 3) are non-interactive, so this shouldn't trigger
        pass
    
    def on_cell_selected(self, current_row, current_col, previous_row, previous_col):
        """Handle cell selection change"""
        if self.debug_mode_enabled:
            self.log(f"üéØ on_cell_selected called: row {current_row}, col {current_col}")

        # üö´ GUARD: Don't re-run lookups if we're staying on the same row
        # This prevents lookups when user edits text (focus changes within same row)
        if hasattr(self, '_last_selected_row') and self._last_selected_row == current_row:
            if self.debug_mode_enabled:
                self.log(f"‚è≠Ô∏è Skipping lookup - already on row {current_row}")
            return
        self._last_selected_row = current_row

        # ‚ö° FILTER MODE: Skip ALL heavy lookups when text filters are active
        # User is quickly navigating through filtered results - don't slow them down
        is_filtering = getattr(self, 'filtering_active', False)
        if is_filtering:
            # Only do minimal UI update (orange highlight) - no TM/termbase lookups
            self._on_cell_selected_minimal(current_row, previous_row)
            return

        # ‚ö° FAST PATH: Defer heavy lookups for ALL navigation (arrow keys, Ctrl+Enter, AND mouse clicks)
        # This makes segment navigation feel INSTANT - cursor moves first, lookups happen after
        # Reset any navigation flags
        self._arrow_key_navigation = False
        self._ctrl_enter_navigation = False

        # Schedule deferred lookup with short delay - debounce prevents hammering during rapid navigation
        if hasattr(self, '_deferred_lookup_timer') and self._deferred_lookup_timer:
            self._deferred_lookup_timer.stop()
        from PyQt6.QtCore import QTimer
        self._deferred_lookup_timer = QTimer()
        self._deferred_lookup_timer.setSingleShot(True)
        self._deferred_lookup_timer.timeout.connect(
            lambda r=current_row, c=current_col, pr=previous_row, pc=previous_col:
            self._on_cell_selected_full(r, c, pr, pc)
        )
        self._deferred_lookup_timer.start(10)  # 10ms - just enough to batch rapid arrow key holding

        # Do minimal UI update immediately (orange highlight, scroll)
        self._on_cell_selected_minimal(current_row, previous_row)
    
    def _center_row_in_viewport(self, row: int):
        """Center the given row vertically in the visible table viewport.
        
        Uses Qt's built-in scrollTo() with PositionAtCenter hint.
        """
        if row < 0 or row >= self.table.rowCount():
            return
        
        # Get the model index for any cell in this row (use column 0)
        index = self.table.model().index(row, 0)
        if index.isValid():
            # Use Qt's built-in centering - PositionAtCenter puts the item in the center of the viewport
            self.table.scrollTo(index, QAbstractItemView.ScrollHint.PositionAtCenter)
    
    def _on_cell_selected_minimal(self, current_row, previous_row):
        """Minimal UI update for fast arrow key navigation - just highlight and scroll"""
        try:
            # Clear previous highlighting
            if previous_row >= 0 and previous_row < self.table.rowCount():
                prev_id_item = self.table.item(previous_row, 0)
                if prev_id_item:
                    prev_id_item.setBackground(QBrush())
                    theme = self.theme_manager.current_theme
                    segment_num_color = "black" if theme.name in ["Light (Default)", "Soft Gray", "Warm Cream", "Sepia", "High Contrast"] else theme.text
                    prev_id_item.setForeground(QBrush(QColor(segment_num_color)))

            # Highlight current segment number in orange
            if current_row >= 0 and current_row < self.table.rowCount():
                current_id_item = self.table.item(current_row, 0)
                if current_id_item:
                    current_id_item.setBackground(QColor("#FFA500"))
                    current_id_item.setForeground(QColor("white"))
                
                # Auto-center if enabled
                if getattr(self, 'auto_center_active_segment', False) and not getattr(self, 'filtering_active', False):
                    self._center_row_in_viewport(current_row)
        except Exception as e:
            if self.debug_mode_enabled:
                self.log(f"Error in minimal cell selection: {e}")
    
    def _on_cell_selected_full(self, current_row, current_col, previous_row, previous_col):
        """Full cell selection handler with lookups and highlighting"""
        # Clear text selections in previous row's source and target cells
        if previous_row >= 0 and previous_row < self.table.rowCount():
            # Clear source cell selection (column 2)
            source_widget = self.table.cellWidget(previous_row, 2)
            if source_widget and hasattr(source_widget, 'textCursor'):
                cursor = source_widget.textCursor()
                cursor.clearSelection()
                source_widget.setTextCursor(cursor)
            
            # Clear target cell selection (column 3)
            target_widget = self.table.cellWidget(previous_row, 3)
            if target_widget and hasattr(target_widget, 'textCursor'):
                cursor = target_widget.textCursor()
                cursor.clearSelection()
                target_widget.setTextCursor(cursor)
        
        # DEBUG: Also log all connected signals for this table (only in debug mode)
        if self.debug_mode_enabled:
            self.log(f"üîó Table currentCellChanged signal connected: {self.table.currentCellChanged}")
            self.log(f"üîó Table itemClicked signal connected: {self.table.itemClicked}")
            self.log(f"üîó Table itemSelectionChanged signal connected: {self.table.itemSelectionChanged}")
        try:
            # Update segment number highlighting (orange = active)
            if previous_row >= 0 and previous_row < self.table.rowCount():
                prev_id_item = self.table.item(previous_row, 0)
                if prev_id_item:
                    prev_id_item.setBackground(QBrush())
                    theme = self.theme_manager.current_theme
                    segment_num_color = "black" if theme.name in ["Light (Default)", "Soft Gray", "Warm Cream", "Sepia", "High Contrast"] else theme.text
                    prev_id_item.setForeground(QBrush(QColor(segment_num_color)))

            if current_row >= 0 and current_row < self.table.rowCount():
                current_id_item = self.table.item(current_row, 0)
                if current_id_item:
                    current_id_item.setBackground(QColor("#FFA500"))
                    current_id_item.setForeground(QColor("white"))
                
                if getattr(self, 'auto_center_active_segment', False) and not getattr(self, 'filtering_active', False):
                    self._center_row_in_viewport(current_row)
            
            if not self.current_project or current_row < 0:
                return
            
            if current_row < len(self.current_project.segments):
                # CRITICAL: Get segment by ID from the grid, not by row index!
                # The row index might not match the segment's position in the list
                id_item = self.table.item(current_row, 0)
                if not id_item:
                    self.log(f"‚ö†Ô∏è No ID item found at row {current_row}")
                    return
                
                # Get segment ID from the grid cell
                try:
                    segment_id = int(id_item.text())
                except (ValueError, AttributeError):
                    self.log(f"‚ö†Ô∏è Could not parse segment ID from cell at row {current_row}")
                    return
                
                # Find the segment by ID in the project's segment list
                segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
                if not segment:
                    self.log(f"‚ö†Ô∏è Could not find segment with ID {segment_id} in project")
                    return
                
                # Update Preview panel - scroll to and highlight this segment
                self._scroll_preview_to_segment(segment_id)
                
                # Update Translation Results panel header with segment info
                if hasattr(self, 'results_panels'):
                    for panel in self.results_panels:
                        try:
                            panel.set_segment_info(segment.id, segment.source)
                        except Exception as e:
                            self.log(f"Error updating Translation Results panel header: {e}")
                
                # Update toolbar segment info and status
                if hasattr(self, 'tab_seg_info'):
                    try:
                        self.tab_seg_info.setText(f"Segment {segment.id}")
                        
                        # Update status combo if it exists
                        if hasattr(self, 'tab_status_combo'):
                            from modules.statuses import STATUSES
                            idx = -1
                            for i in range(self.tab_status_combo.count()):
                                if self.tab_status_combo.itemData(i) == segment.status:
                                    idx = i
                                    break
                            if idx >= 0:
                                self.tab_status_combo.blockSignals(True)
                                self.tab_status_combo.setCurrentIndex(idx)
                                self.tab_status_combo.blockSignals(False)
                    except Exception as e:
                        self.log(f"Error updating toolbar: {e}")
                
                # Update Translation Results panel notes
                if hasattr(self, 'translation_results_panel') and self.translation_results_panel:
                    try:
                        notes_text = segment.notes if segment.notes else ""
                        self.translation_results_panel.notes_edit.blockSignals(True)
                        self.translation_results_panel.notes_edit.setPlainText(notes_text)
                        self.translation_results_panel.notes_edit.blockSignals(False)
                    except Exception as e:
                        self.log(f"Error updating notes in Translation Results panel: {e}")
                
                # Update bottom Notes tab with segment notes
                self._update_bottom_notes_for_segment(segment)
                
                # Update legacy tabbed panels (if they exist for other views)
                if hasattr(self, 'update_tab_segment_editor'):
                    self.update_tab_segment_editor(
                        segment_id=segment.id,
                        source_text=segment.source,
                        target_text=segment.target,
                        status=segment.status,
                        notes=segment.notes
                    )
                
                # ‚ö° PERFORMANCE: Skip heavy lookups if Preview tab is open
                # User is likely just reading/reviewing, not actively translating
                if self._is_preview_tab_active():
                    if self.debug_mode_enabled:
                        self.log(f"‚è≠Ô∏è Preview tab active - skipping TM/Termbase lookups for segment {segment.id}")
                    return
                
                # Get termbase matches (from cache or search on-demand) - ONLY if enabled
                matches_dict = None  # Initialize at the top level
                cached_matches = None  # Initialize for cache skip path

                # üß™ EXPERIMENTAL: Skip ALL cache checks if cache kill switch is enabled
                if not getattr(self, 'disable_all_caches', False):
                    # üöÄ CHECK PREFETCH CACHE FIRST for instant display (like memoQ)
                    segment_id = segment.id
                    with self.translation_matches_cache_lock:
                        if segment_id in self.translation_matches_cache:
                            cached_matches = self.translation_matches_cache[segment_id]
                            
                            # Count matches in each category
                            tm_count = len(cached_matches.get("TM", []))
                            tb_count = len(cached_matches.get("Termbases", []))
                            mt_count = len(cached_matches.get("MT", []))
                            llm_count = len(cached_matches.get("LLM", []))
                            
                            self.log(f"‚ö° CACHE HIT for segment {segment_id}: TM={tm_count}, TB={tb_count}, MT={mt_count}, LLM={llm_count}")
                else:
                    if self.debug_mode_enabled:
                        self.log(f"üß™ Cache DISABLED - forcing fresh lookup for segment {segment.id}")
                
                # Process cached matches if we have them
                if cached_matches is not None:
                    # Display cached matches immediately
                    if hasattr(self, 'results_panels'):
                        for panel in self.results_panels:
                            try:
                                panel.clear()
                                panel.set_matches(cached_matches)
                            except Exception as e:
                                self.log(f"Error displaying cached matches: {e}")
                    
                    # üîÑ Update TermView with cached termbase matches (always update, even if empty)
                    if hasattr(self, 'termview_widget') and self.current_project:
                        try:
                            # Convert TranslationMatch objects to dict format for termview
                            termbase_matches = [
                                {
                                    'source_term': match.source,
                                    'target_term': match.target,
                                    'termbase_name': match.metadata.get('termbase_name', '') if match.metadata else '',
                                    'ranking': match.metadata.get('ranking', 99) if match.metadata else 99,
                                    'is_project_termbase': match.metadata.get('is_project_termbase', False) if match.metadata else False,
                                    'term_id': match.metadata.get('term_id') if match.metadata else None,
                                    'termbase_id': match.metadata.get('termbase_id') if match.metadata else None,
                                    'notes': match.metadata.get('notes', '') if match.metadata else ''
                                }
                                for match in cached_matches.get("Termbases", [])
                            ]
                            # Also get NT matches (fresh, not cached - they may have changed)
                            nt_matches = self.find_nt_matches_in_source(segment.source)

                            # Get status hint for termbase activation
                            status_hint = self._get_termbase_status_hint()

                            # Update both Termview widgets (left and right)
                            self._update_both_termviews(segment.source, termbase_matches, nt_matches, status_hint)
                        except Exception as e:
                            self.log(f"Error updating termview from cache: {e}")
                    
                    # üéØ AUTO-INSERT 100% TM MATCH from cache (if enabled in settings)
                    tm_count = len(cached_matches.get("TM", []))
                    if self.auto_insert_100_percent_matches and tm_count > 0:
                        # Check if segment target is empty (don't overwrite existing translations)
                        target_empty = not segment.target or len(segment.target.strip()) == 0
                        
                        if target_empty:
                            # Find first 100% match in cached TM results
                            best_match = None
                            for tm_match in cached_matches.get("TM", []):
                                # Use >= 99.5 to handle potential floating point issues
                                if float(tm_match.relevance) >= 99.5:
                                    best_match = tm_match
                                    break
                            
                            if best_match:
                                self.log(f"‚ú® Auto-inserting 100% TM match into segment {segment.id}")
                                self._auto_insert_tm_match(segment, best_match.target, current_row)
                                # Play 100% TM match alert sound
                                self._play_sound_effect('tm_100_percent_match')
                    
                    # üîä Play fuzzy match sound if fuzzy matches found from cache (but not 100%)
                    if tm_count > 0:
                        tm_matches = cached_matches.get("TM", [])
                        has_100_match = any(float(tm.relevance) >= 99.5 for tm in tm_matches)
                        has_fuzzy_match = any(float(tm.relevance) < 99.5 and float(tm.relevance) >= 50 for tm in tm_matches)
                        if has_fuzzy_match and not has_100_match:
                            self._play_sound_effect('tm_fuzzy_match')
                    
                    # Skip the slow TERMBASE lookup below, we already have termbase matches cached
                    # But TM lookup was skipped in prefetch (not thread-safe), so schedule it now
                    matches_dict = cached_matches  # Set for later use

                    # v1.9.182: Schedule TM lookup even on cache hit (prefetch skips TM - not thread-safe)
                    tm_count = len(cached_matches.get("TM", []))
                    if tm_count == 0 and self.enable_tm_matching:
                        find_replace_active = getattr(self, 'find_replace_active', False)
                        if not find_replace_active:
                            # Get termbase matches for the lookup
                            termbase_matches_for_tm = [
                                {
                                    'source_term': match.source,
                                    'target_term': match.target,
                                    'termbase_name': match.metadata.get('termbase_name', '') if match.metadata else '',
                                }
                                for match in cached_matches.get("Termbases", [])
                            ]
                            self._schedule_mt_and_llm_matches(segment, termbase_matches_for_tm)
                
                # Check if TM/Termbase matching is enabled
                if not matches_dict and (not self.enable_tm_matching and not self.enable_termbase_matching):
                    self.log("‚è≠Ô∏è TM/Termbase matching disabled - skipping all lookups")
                elif not matches_dict:  # Only do slow lookup if cache missed
                    try:
                        source_widget = self.table.cellWidget(current_row, 2)  # Source column is column 2

                        # Termbase lookup (if enabled)
                        stored_matches = {}
                        if self.enable_termbase_matching:
                            # üß™ EXPERIMENTAL: Skip termbase cache if cache kill switch is enabled
                            cache_checked = False
                            if not getattr(self, 'disable_all_caches', False):
                                # Check cache first (thread-safe) - uses `in` check to properly handle empty caches
                                with self.termbase_cache_lock:
                                    if segment_id in self.termbase_cache:
                                        stored_matches = self.termbase_cache[segment_id]
                                        cache_checked = True
                            
                            if not cache_checked and source_widget:
                                stored_matches = self.find_termbase_matches_in_source(segment.source)

                                # Store in cache for future access (thread-safe) - EVEN IF EMPTY
                                # BUT skip cache storage if cache kill switch is enabled
                                if not getattr(self, 'disable_all_caches', False):
                                    with self.termbase_cache_lock:
                                        self.termbase_cache[segment_id] = stored_matches
                            
                            # CRITICAL FIX: Always update Termview (even with empty results) - show "No matches" state
                            if hasattr(self, 'termview_widget') and self.current_project:
                                try:
                                    # Convert dict format to list format
                                    termbase_matches = [
                                        {
                                            'source_term': match_data.get('source', ''),
                                            'target_term': match_data.get('translation', ''),
                                            'termbase_name': match_data.get('termbase_name', ''),
                                            'ranking': match_data.get('ranking', 99),
                                            'is_project_termbase': match_data.get('is_project_termbase', False),
                                            'term_id': match_data.get('term_id'),
                                            'termbase_id': match_data.get('termbase_id'),
                                            'notes': match_data.get('notes', '')
                                        }
                                        for match_data in stored_matches.values()
                                    ] if stored_matches else []
                                    # Also get NT matches
                                    nt_matches = self.find_nt_matches_in_source(segment.source)

                                    # Get status hint for termbase activation
                                    status_hint = self._get_termbase_status_hint()

                                    # Update both Termview widgets (left and right)
                                    self._update_both_termviews(segment.source, termbase_matches, nt_matches, status_hint)
                                except Exception as e:
                                    self.log(f"Error refreshing termview: {e}")

                            # Store in widget for backwards compatibility
                            if source_widget and hasattr(source_widget, 'termbase_matches'):
                                source_widget.termbase_matches = stored_matches
                            
                            # Highlight termbase matches and NT matches in source cell (if enabled)
                            if self.enable_termbase_grid_highlighting:
                                self.highlight_source_with_termbase(current_row, segment.source, stored_matches)
                        else:
                            self.log("‚è≠Ô∏è Termbase matching disabled - skipping termbase lookup")

                        if stored_matches:
                            # Convert stored matches to TranslationMatch objects
                            from modules.translation_results_panel import TranslationMatch
                            matches_dict = {
                                "LLM": [],
                                "NT": [],
                                "MT": [],
                                "TM": [],
                                "Termbases": [],
                                "NonTrans": []  # Non-translatables
                            }
                            
                            # Add non-translatable matches
                            if hasattr(self, 'nt_manager') and self.nt_manager:
                                nt_matches = self.find_nt_matches_in_source(segment.source)
                                for nt_match in nt_matches:
                                    nt_obj = TranslationMatch(
                                        source=nt_match.get('text', ''),
                                        target=nt_match.get('text', ''),  # Same as source (not translated)
                                        relevance=100,  # Always 100% match
                                        metadata={
                                            'list_name': nt_match.get('list_name', 'Non-Translatables'),
                                            'is_non_translatable': True
                                        },
                                        match_type='NonTrans',
                                        compare_source=nt_match.get('text', ''),
                                        provider_code='NT'
                                    )
                                    matches_dict["NonTrans"].append(nt_obj)

                            for term_id_key, match_info in stored_matches.items():
                                # Extract all fields from match_info (including source term)
                                if isinstance(match_info, dict):
                                    source_term = match_info.get('source', '')
                                    target_term = match_info.get('translation', '')
                                    priority = match_info.get('priority', 50)
                                    ranking = match_info.get('ranking', None)
                                    forbidden = match_info.get('forbidden', False)
                                    is_project_termbase = match_info.get('is_project_termbase', False)
                                    term_id = match_info.get('term_id')
                                    termbase_id = match_info.get('termbase_id')
                                    termbase_name = match_info.get('termbase_name', 'Unknown')
                                    domain = match_info.get('domain', '')
                                    notes = match_info.get('notes', '')
                                    project = match_info.get('project', '')
                                    client = match_info.get('client', '')
                                else:
                                    # Backward compatibility: if just string (shouldn't happen with new code)
                                    source_term = str(term_id_key)
                                    target_term = match_info
                                    priority = 50
                                    ranking = None
                                    forbidden = False
                                    is_project_termbase = False
                                    term_id = None
                                    termbase_id = None
                                    termbase_name = 'Unknown'
                                    domain = ''
                                    notes = ''
                                    project = ''
                                    client = ''
                                
                                # Get target synonyms from match_info
                                target_synonyms = match_info.get('target_synonyms', []) if isinstance(match_info, dict) else []
                                
                                match_obj = TranslationMatch(
                                    source=source_term,
                                    target=target_term,
                                    relevance=95,  # High relevance for termbase matches
                                    metadata={
                                        'termbase_name': termbase_name,
                                        'ranking': ranking,
                                        'is_project_termbase': is_project_termbase,
                                        'domain': domain,
                                        'notes': notes,
                                        'project': project,
                                        'client': client,
                                        'priority': priority,
                                        'forbidden': forbidden,
                                        'term_id': term_id,
                                        'termbase_id': termbase_id,
                                        'target_synonyms': target_synonyms
                                    },
                                    match_type='Termbase',
                                    compare_source=source_term,
                                    provider_code='TB'
                                )
                                matches_dict["Termbases"].append(match_obj)

                            # Get current project languages for all translation services
                            source_lang = getattr(self.current_project, 'source_lang', None) if self.current_project else None
                            target_lang = getattr(self.current_project, 'target_lang', None) if self.current_project else None

                            # Convert language names to codes if needed
                            if source_lang:
                                source_lang_code = self._convert_language_to_code(source_lang)
                            if target_lang:
                                target_lang_code = self._convert_language_to_code(target_lang)

                            # Clear panels first, then show termbase matches immediately
                            if hasattr(self, 'results_panels'):
                                for panel in self.results_panels:
                                    try:
                                        panel.clear()  # Clear old matches
                                        panel.set_matches(matches_dict)  # Add termbase matches immediately
                                    except Exception as e:
                                        self.log(f"Error updating results panel: {e}")
                        else:
                            # No termbase matches - but still check for NT matches
                            matches_dict = {
                                "LLM": [],
                                "NT": [],
                                "MT": [],
                                "TM": [],
                                "Termbases": [],
                                "NonTrans": []  # Non-translatables
                            }
                            
                            # Add non-translatable matches even without termbase matches
                            if hasattr(self, 'nt_manager') and self.nt_manager:
                                from modules.translation_results_panel import TranslationMatch
                                nt_matches = self.find_nt_matches_in_source(segment.source)
                                for nt_match in nt_matches:
                                    nt_obj = TranslationMatch(
                                        source=nt_match.get('text', ''),
                                        target=nt_match.get('text', ''),  # Same as source (not translated)
                                        relevance=100,  # Always 100% match
                                        metadata={
                                            'list_name': nt_match.get('list_name', 'Non-Translatables'),
                                            'is_non_translatable': True
                                        },
                                        match_type='NonTrans',
                                        compare_source=nt_match.get('text', ''),
                                        provider_code='NT'
                                    )
                                    matches_dict["NonTrans"].append(nt_obj)
                                
                                if matches_dict["NonTrans"]:
                                    self.log(f"üìã Found {len(matches_dict['NonTrans'])} NT matches")
                            
                            if hasattr(self, 'results_panels'):
                                for panel in self.results_panels:
                                    try:
                                        panel.clear()
                                        if matches_dict["NonTrans"]:
                                            panel.set_matches(matches_dict)
                                    except Exception as e:
                                        self.log(f"Error clearing results panel: {e}")
                    except Exception as e:
                        self.log(f"Error retrieving stored termbase matches: {e}")

                    # Schedule expensive searches (TM, MT, LLM) with debouncing to prevent UI blocking
                    # ONLY schedule if:
                    # 1. Cache miss OR cache hit with no TM matches (prefetch doesn't include TM - not thread-safe)
                    # 2. TM matching is enabled
                    # 3. Find/Replace is not active (to avoid slowdowns during navigation)
                    needs_tm_lookup = True
                    with self.translation_matches_cache_lock:
                        if segment_id in self.translation_matches_cache:
                            cached = self.translation_matches_cache[segment_id]
                            # v1.9.182: Check if TM matches exist - prefetch worker skips TM lookups
                            needs_tm_lookup = len(cached.get("TM", [])) == 0

                    find_replace_active = getattr(self, 'find_replace_active', False)

                    if needs_tm_lookup and self.enable_tm_matching and not find_replace_active:
                        # Get termbase matches if they exist (could be None or empty)
                        termbase_matches = matches_dict.get('Termbases', []) if matches_dict else []
                        self._schedule_mt_and_llm_matches(segment, termbase_matches)
                
                # Trigger prefetch for next 20 segments (adaptive background caching)
                # Also trigger PROACTIVE HIGHLIGHTING for already-cached segments
                if self.current_project and current_row >= 0:
                    import json
                    next_segment_ids = []
                    start_idx = current_row + 1
                    end_idx = min(start_idx + 20, len(self.current_project.segments))

                    for seg in self.current_project.segments[start_idx:end_idx]:
                        # Check if already cached
                        with self.translation_matches_cache_lock:
                            is_cached = seg.id in self.translation_matches_cache
                        
                        if not is_cached:
                            next_segment_ids.append(seg.id)
                        else:
                            # PROACTIVE HIGHLIGHTING: Apply highlighting for cached segments
                            # that haven't been highlighted yet
                            try:
                                with self.termbase_cache_lock:
                                    termbase_raw = self.termbase_cache.get(seg.id, {})
                                if termbase_raw:
                                    termbase_json = json.dumps(termbase_raw)
                                    self._apply_proactive_highlighting(seg.id, termbase_json)
                            except Exception:
                                pass  # Silent failure for proactive highlighting

                    if next_segment_ids:
                        self._start_prefetch_worker(next_segment_ids)
                        
        except Exception as e:
            self.log(f"Critical error in on_cell_selected: {e}")
    
    def on_selection_changed(self):
        """Handle selection change for row-based selection mode"""
        try:
            # Get currently selected row
            current_row = self.table.currentRow()
            current_col = self.table.currentColumn()
            
            # ‚ö° FAST PATH: Skip if this is arrow key navigation (already handled by on_cell_selected)
            if getattr(self, '_arrow_key_navigation', False):
                return  # Let on_cell_selected handle it
            
            # üö´ GUARD: Skip if we're on the same row (prevents double-processing)
            if hasattr(self, '_last_selection_row') and self._last_selection_row == current_row:
                return
            self._last_selection_row = current_row
            
            # If we have a valid row selection, trigger the same logic as on_cell_selected
            if current_row >= 0:
                # Call on_cell_selected with appropriate parameters
                self.on_cell_selected(current_row, current_col, -1, -1)
        except Exception as e:
            self.log(f"Error in on_selection_changed: {e}")
    
    def test_cell_selection(self):
        """Test method to manually trigger cell selection for debugging"""
        self.log("üß™ TEST: Manually triggering cell selection for row 0")
        if self.table.rowCount() > 0:
            # Try to programmatically select first row
            self.table.selectRow(0)
            self.table.setCurrentCell(0, 2)  # Select source column
            self.on_cell_selected(0, 2, -1, -1)  # Manually trigger
        else:
            self.log("üß™ TEST: No rows available for testing")
    
    def get_selected_segments_from_grid(self):
        """Get list of selected segments from grid view"""
        if not self.current_project or not hasattr(self, 'table'):
            return []
        
        selected_rows = set()
        for item in self.table.selectedItems():
            selected_rows.add(item.row())
        
        segments = []
        for row in sorted(selected_rows):
            if 0 <= row < len(self.current_project.segments):
                segments.append(self.current_project.segments[row])
        
        return segments
    
    def _preview_combined_prompt_from_grid(self):
        """Preview combined prompt with the currently selected segment from grid"""
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton, QHBoxLayout, QMessageBox
        
        # Check if project is loaded
        if not self.current_project:
            QMessageBox.warning(
                self,
                "No Project",
                "Please load a project first to preview prompts."
            )
            return
        
        # Check if prompt_manager_qt exists
        if not hasattr(self, 'prompt_manager_qt'):
            QMessageBox.warning(
                self,
                "Feature Not Available",
                "Prompt Manager is not available."
            )
            return
        
        # Get current segment from grid
        current_segment = None
        current_segment_id = "Preview"
        
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row >= 0:
                # Map display row to actual segment index (for pagination)
                actual_index = current_row
                if hasattr(self, 'grid_row_to_segment_index') and self.grid_row_to_segment_index:
                    if current_row in self.grid_row_to_segment_index:
                        actual_index = self.grid_row_to_segment_index[current_row]
                
                # Get segment
                if actual_index < len(self.current_project.segments):
                    current_segment = self.current_project.segments[actual_index]
                    current_segment_id = f"Segment {current_segment.id}"
        
        # Fallback to first segment if none selected
        if not current_segment:
            if len(self.current_project.segments) > 0:
                current_segment = self.current_project.segments[0]
                current_segment_id = f"Example: Segment {current_segment.id}"
                QMessageBox.information(
                    self,
                    "No Segment Selected",
                    "No segment is currently selected. Using the first segment as an example.\n\n"
                    "To preview with a specific segment, please select a row in the grid first."
                )
            else:
                QMessageBox.warning(
                    self,
                    "No Segments",
                    "This project has no segments to preview."
                )
                return
        
        # Get languages
        source_lang = getattr(self.current_project, 'source_lang', 'Source Language')
        target_lang = getattr(self.current_project, 'target_lang', 'Target Language')
        
        # Get source text
        source_text = current_segment.source

        # Get glossary terms for AI injection
        glossary_terms = self.get_ai_inject_glossary_terms()

        # Build combined prompt
        combined = self.prompt_manager_qt.build_final_prompt(
            source_text, source_lang, target_lang, glossary_terms=glossary_terms
        )
        
        # Check for figure/image context
        figure_info = ""
        figure_images = []
        if hasattr(self, 'figure_context') and self.figure_context:
            if self.figure_context.has_images():
                # Detect figure references in current segment
                figure_refs = self.figure_context.detect_figure_references(source_text)
                if figure_refs:
                    figure_images = self.figure_context.get_images_for_text(source_text)
                    if figure_images:
                        image_names = [ref for ref, _ in figure_images]
                        figure_info = f"üñºÔ∏è {len(figure_images)} image(s) will be sent with this prompt: {', '.join(f'Figure {ref}' for ref in image_names)}"
                    else:
                        figure_info = f"‚ö†Ô∏è Figure references detected ({', '.join(figure_refs)}) but images not found in loaded context"
                else:
                    total_images = len(self.figure_context.figure_context_map)
                    figure_info = f"‚ÑπÔ∏è {total_images} image(s) loaded but no figure references detected in this segment"
        
        # Build composition info
        composition_parts = []
        composition_parts.append(f"üìç {current_segment_id}")
        composition_parts.append(f"üåê {source_lang} ‚Üí {target_lang}")
        composition_parts.append(f"üìè Total prompt: {len(combined):,} characters")
        
        if self.prompt_manager_qt.library.active_primary_prompt:
            composition_parts.append(f"‚úì Custom prompt attached")
        
        if self.prompt_manager_qt.library.attached_prompts:
            composition_parts.append(f"‚úì {len(self.prompt_manager_qt.library.attached_prompts)} additional prompt(s) attached")

        if glossary_terms:
            composition_parts.append(f"üìö {len(glossary_terms)} glossary term(s) injected")

        if figure_info:
            composition_parts.append(figure_info)
        
        composition_text = "\n".join(composition_parts)
        
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("üß™ Combined Prompt Preview")
        dialog.resize(900, 700)
        
        layout = QVBoxLayout(dialog)
        
        # Info label
        info_label = QLabel(
            "<b>Complete Assembled Prompt</b><br>"
            "This is what will be sent to the AI (System Prompt + Custom Prompts + segment text)<br><br>" +
            composition_text.replace("\n", "<br>")
        )
        info_label.setTextFormat(Qt.TextFormat.RichText)
        info_label.setWordWrap(True)
        info_label.setStyleSheet("padding: 10px; background-color: #e3f2fd; border-radius: 4px; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Additional image context notice if images are being sent
        if figure_images:
            image_notice = QLabel(
                f"üì∏ <b>Visual Context:</b> {len(figure_images)} image(s) will be sent alongside this text prompt as binary data<br>"
                f"<small>Images: {', '.join(f'Figure {ref}' for ref, _ in figure_images)}</small>"
            )
            image_notice.setTextFormat(Qt.TextFormat.RichText)
            image_notice.setWordWrap(True)
            image_notice.setStyleSheet("padding: 10px; border-radius: 4px; margin-bottom: 10px; border-left: 4px solid #ff9800;")
            layout.addWidget(image_notice)
        
        # Text editor for preview with syntax highlighting
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        text_edit.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        text_edit.setStyleSheet("font-family: 'Consolas', 'Courier New', monospace; font-size: 9pt;")

        # Format the prompt with color highlighting
        import html
        import re

        # Escape HTML entities first
        formatted_html = html.escape(combined)

        # Replace newlines with <br> for HTML
        formatted_html = formatted_html.replace('\n', '<br>')

        # Make "# SYSTEM PROMPT" bold and red
        formatted_html = re.sub(
            r'(#\s*SYSTEM\s*PROMPT)',
            r'<span style="color: #d32f2f; font-weight: bold; font-size: 11pt;">\1</span>',
            formatted_html,
            flags=re.IGNORECASE
        )

        # Make "# CUSTOM PROMPT" bold and red
        formatted_html = re.sub(
            r'(#\s*CUSTOM\s*PROMPT)',
            r'<span style="color: #d32f2f; font-weight: bold; font-size: 11pt;">\1</span>',
            formatted_html,
            flags=re.IGNORECASE
        )

        # Make "# GLOSSARY" bold and orange
        formatted_html = re.sub(
            r'(#\s*GLOSSARY)',
            r'<span style="color: #FF9800; font-weight: bold; font-size: 11pt;">\1</span>',
            formatted_html,
            flags=re.IGNORECASE
        )

        # Make source text section blue (pattern: "XX text:<br>..." until double line break or # header)
        # Match language code + " text:" followed by content until "# " or end
        formatted_html = re.sub(
            r'(\w{2,5}\s+text:)(<br>)(.*?)(<br><br>(?:#|\*\*YOUR TRANSLATION)|$)',
            r'<span style="color: #1565c0; font-weight: bold;">\1</span>\2<span style="color: #1565c0;">\3</span>\4',
            formatted_html,
            flags=re.DOTALL
        )

        # Wrap in pre-like styling div
        formatted_html = f'<div style="font-family: Consolas, Courier New, monospace; white-space: pre-wrap;">{formatted_html}</div>'

        text_edit.setHtml(formatted_html)
        layout.addWidget(text_edit, 1)
        
        # Close button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        close_btn.setStyleSheet("padding: 8px 20px; font-weight: bold;")
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)
        
        dialog.exec()

    
    def show_grid_context_menu(self, position):
        """Show context menu for grid view with bulk operations"""
        selected_segments = self.get_selected_segments_from_grid()

        if not selected_segments:
            return

        menu = QMenu(self)

        # Confirm selected segments action
        if len(selected_segments) >= 1:
            confirm_action = menu.addAction(f"‚úÖ Confirm {len(selected_segments)} Segment(s)")
            confirm_action.setToolTip(f"Confirm {len(selected_segments)} selected segment(s)")
            confirm_action.triggered.connect(self.confirm_selected_segments)

        # Change Status submenu
        from modules.statuses import get_status
        status_menu = menu.addMenu(f"üè∑Ô∏è Change Status ({len(selected_segments)})")
        # Common user-settable statuses (excluding TM-specific ones like pm, cm, tm_100, etc.)
        user_statuses = [
            ("not_started", "‚ùå Not started"),
            ("pretranslated", "ü§ñ Pre-translated"),
            ("translated", "‚úèÔ∏è Translated"),
            ("confirmed", "‚úî Confirmed"),
            ("tr_confirmed", "üåü TR confirmed"),
            ("proofread", "üü™ Proofread"),
            ("approved", "‚≠ê Approved"),
            ("rejected", "üö´ Rejected"),
        ]
        for status_key, label in user_statuses:
            action = status_menu.addAction(label)
            action.triggered.connect(lambda checked, s=status_key: self.change_status_selected(s))

        # Clear translations action
        clear_action = menu.addAction("üóëÔ∏è Clear Translations")
        clear_action.setToolTip(f"Clear translations for {len(selected_segments)} selected segment(s)")
        clear_action.triggered.connect(lambda: self.clear_selected_translations(selected_segments, 'grid'))

        menu.addSeparator()

        # Clear proofreading notes (if any selected segment has proofreading notes)
        has_proofreading = any(seg.notes and "‚ö†Ô∏è PROOFREAD:" in seg.notes for seg in selected_segments)
        if has_proofreading:
            clear_proofread_action = menu.addAction("‚úÖ Clear Proofreading Notes")
            clear_proofread_action.setToolTip("Remove proofreading issues from selected segment(s)")
            clear_proofread_action.triggered.connect(lambda: self._clear_proofreading_from_selected(selected_segments))
            menu.addSeparator()

        # Select all action
        select_all_action = menu.addAction("üìã Select All (Ctrl+A)")
        select_all_action.triggered.connect(lambda: self.table.selectAll())

        menu.exec(self.table.viewport().mapToGlobal(position))
    
    def _clear_proofreading_from_selected(self, segments):
        """Clear proofreading notes from selected segments"""
        cleared_count = 0
        for segment in segments:
            if segment.notes and "‚ö†Ô∏è PROOFREAD:" in segment.notes:
                # Remove proofreading section
                parts = segment.notes.split("‚ö†Ô∏è PROOFREAD:")
                if len(parts) > 1:
                    remaining = parts[1].split("---", 1)
                    if len(remaining) > 1:
                        # Has other notes after separator
                        segment.notes = remaining[1].strip()
                    else:
                        # No other notes
                        segment.notes = ""
                cleared_count += 1
        
        if cleared_count > 0:
            self.project_modified = True
            self.load_segments_to_grid()  # Refresh grid
            self.update_window_title()
            self.log(f"‚úì Cleared proofreading notes from {cleared_count} segment{'s' if cleared_count != 1 else ''}")
    
    def _bulk_clear_proofreading_notes(self):
        """Clear all proofreading notes from entire project (preserves user notes)"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.information(self, "No Project", "Please open or create a project first.")
            return
        
        # Count segments with proofreading notes
        segments_with_proofread = [seg for seg in self.current_project.segments 
                                   if seg.notes and "‚ö†Ô∏è PROOFREAD:" in seg.notes]
        
        if not segments_with_proofread:
            QMessageBox.information(self, "No Proofreading Notes", 
                                   "No proofreading notes found in the current project.")
            return
        
        # Confirm with user
        reply = QMessageBox.question(
            self,
            "Clear All Proofreading Notes",
            f"<b>Clear proofreading notes from {len(segments_with_proofread)} segment(s)?</b><br><br>"
            "This will remove all AI-generated proofreading notes (marked with ‚ö†Ô∏è PROOFREAD:) "
            "while preserving your personal notes.<br><br>"
            "This action cannot be undone.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Clear proofreading notes
        cleared_count = 0
        for segment in segments_with_proofread:
            # Remove proofreading section while preserving other notes
            if "‚ö†Ô∏è PROOFREAD:" in segment.notes:
                parts = segment.notes.split("‚ö†Ô∏è PROOFREAD:")
                before_proofread = parts[0].strip()
                
                # Check if there are notes after the proofreading section
                after_sep = ""
                if len(parts) > 1:
                    remaining = parts[1].split("---", 1)
                    if len(remaining) > 1:
                        after_sep = remaining[1].strip()
                
                # Reconstruct notes without proofreading
                new_notes = ""
                if before_proofread:
                    new_notes = before_proofread
                if after_sep:
                    new_notes = (new_notes + "\n" + after_sep).strip() if new_notes else after_sep
                
                segment.notes = new_notes
                cleared_count += 1
        
        if cleared_count > 0:
            self.project_modified = True
            self.load_segments_to_grid()  # Refresh grid to remove orange indicators
            self.update_window_title()
            QMessageBox.information(self, "Success", 
                                   f"‚úì Cleared proofreading notes from {cleared_count} segment{'s' if cleared_count != 1 else ''}.")
            self.log(f"‚úì Bulk cleared proofreading notes from {cleared_count} segments")

    

    
    def clear_selected_translations(self, segments, view_type='grid'):
        """Clear translations for selected segments"""
        if not segments:
            return
        
        count = len(segments)
        cleared_count = 0
        
        for segment in segments:
            if segment.target:  # Only clear if there's something to clear
                segment.target = ""
                if segment.status != 'untranslated':
                    segment.status = 'untranslated'
                cleared_count += 1
        
        if cleared_count > 0:
            self.project_modified = True
            self.update_window_title()
            
            # Refresh the appropriate view
            if view_type == 'grid':
                self.load_segments_to_grid()
            elif view_type == 'list':
                self.refresh_list_view()
            
            self.log(f"‚úì Cleared translations for {cleared_count} segment(s)")
        else:
            self.log(f"‚Ñπ No translations to clear for selected segments")
    
    def clear_selected_translations_from_menu(self):
        """Clear translations for selected segments (called from Edit menu)"""
        # Only available in Grid view
        if self.current_project and hasattr(self, 'table') and self.table:
            selected_segments = self.get_selected_segments_from_grid()
            if selected_segments:
                self.clear_selected_translations(selected_segments, 'grid')
            else:
                QMessageBox.information(self, "No Selection", "Please select one or more segments to clear translations.")
        else:
            QMessageBox.information(self, "Not Available", "Please load a project first.")
    
    def copy_source_to_target_bulk(self):
        """Copy source text to target for selected or filtered segments (Edit > Bulk Operations)"""
        if not self.current_project or not hasattr(self, 'table') or not self.table:
            QMessageBox.information(self, "Not Available", "Please load a project first.")
            return
        
        # First check if there's a selection
        selected_segments = self.get_selected_segments_from_grid()
        
        # If no selection, check for visible (filtered) rows
        if not selected_segments:
            # Get all visible rows (not hidden by filter)
            visible_rows = []
            for row in range(self.table.rowCount()):
                if not self.table.isRowHidden(row):
                    visible_rows.append(row)
            
            # If there's a filter active (some rows hidden), use visible rows
            total_rows = self.table.rowCount()
            if len(visible_rows) < total_rows and len(visible_rows) > 0:
                # Filter is active - ask user if they want to copy for filtered segments
                reply = QMessageBox.question(
                    self, 
                    "Copy Source to Target",
                    f"No segments selected.\n\nDo you want to copy source to target for all {len(visible_rows)} filtered (visible) segments?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply != QMessageBox.StandardButton.Yes:
                    return
                
                # Get segments for visible rows
                for row in visible_rows:
                    if row < len(self.current_project.segments):
                        selected_segments.append(self.current_project.segments[row])
            else:
                QMessageBox.information(self, "No Selection", "Please select one or more segments, or apply a filter first.")
                return
        
        # Confirm operation
        count = len(selected_segments)
        if count > 1:
            reply = QMessageBox.question(
                self,
                "Confirm Copy",
                f"Copy source to target for {count} segment(s)?\n\nThis will overwrite existing translations.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply != QMessageBox.StandardButton.Yes:
                return
        
        # Perform the copy
        copied_count = 0
        for segment in selected_segments:
            row = self._find_row_for_segment(segment.id)
            if row >= 0:
                # Get source text from source widget
                source_widget = self.table.cellWidget(row, 2)
                if source_widget:
                    source_text = source_widget.toPlainText()
                    
                    # Update segment object
                    segment.target = source_text
                    
                    # Update target widget
                    target_widget = self.table.cellWidget(row, 3)
                    if target_widget:
                        target_widget.blockSignals(True)
                        target_widget.setPlainText(source_text)
                        target_widget.blockSignals(False)
                    
                    copied_count += 1
        
        # Auto-resize rows to fit new content
        self.auto_resize_rows()
        self.update_progress_stats()
        
        self.log(f"‚úì Copied source to target for {copied_count} segment(s)")
        QMessageBox.information(self, "Copy Complete", f"Copied source to target for {copied_count} segment(s).")

    def show_clean_tags_dialog(self):
        """Show dialog to clean formatting tags from project segments"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "Please load a project with segments first.")
            return
        
        # Import dialog class from TMX editor module
        try:
            from modules.tmx_editor_qt import TmxTagCleanerDialog
        except ImportError:
            QMessageBox.warning(self, "Module Error", "Could not load tag cleaner dialog.")
            return
        
        segment_count = len(self.current_project.segments)
        dialog = TmxTagCleanerDialog(self, tu_count=segment_count)
        dialog.setWindowTitle("üßπ Clean Tags from Project")
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.clean_project_tags(dialog)
    
    def clean_project_tags(self, dialog):
        """Clean tags from project segments based on dialog settings"""
        import re
        
        # Get selected tag patterns
        patterns = []
        for name, cb in dialog.tag_checkboxes.items():
            if cb.isChecked():
                patterns.append(cb.tag_pattern)
        
        if not patterns:
            QMessageBox.information(self, "No Tags Selected", "Please select at least one tag type to clean.")
            return
        
        # Get replacement string
        replacement = " " if dialog.replace_space.isChecked() else ""
        
        # Get scope
        clean_source = dialog.scope_both.isChecked() or dialog.scope_source.isChecked()
        clean_target = dialog.scope_both.isChecked() or dialog.scope_target.isChecked()
        
        # Create patterns for both literal and XML-escaped versions
        # Files may store tags as literal <b> or escaped &lt;b&gt;
        expanded_patterns = []
        for p in patterns:
            expanded_patterns.append(p)  # Original pattern for literal tags
            # Create escaped version: < becomes &lt; and > becomes &gt;
            escaped_p = p.replace('<', '&lt;').replace('>', '&gt;')
            if escaped_p != p:
                expanded_patterns.append(escaped_p)
        
        # Compile combined pattern
        combined_pattern = "|".join(f"({p})" for p in expanded_patterns)
        regex = re.compile(combined_pattern)
        
        # Process segments
        modified_count = 0
        tags_removed = 0
        
        progress = QProgressDialog("Cleaning tags...", "Cancel", 0, len(self.current_project.segments), self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(0)
        
        for i, segment in enumerate(self.current_project.segments):
            if progress.wasCanceled():
                break
            
            progress.setValue(i)
            QApplication.processEvents()
            
            segment_modified = False
            
            if clean_source and segment.source:
                new_source, count = regex.subn(replacement, segment.source)
                if count > 0:
                    segment.source = new_source.strip() if replacement == "" else new_source
                    tags_removed += count
                    segment_modified = True
            
            if clean_target and segment.target:
                new_target, count = regex.subn(replacement, segment.target)
                if count > 0:
                    segment.target = new_target.strip() if replacement == "" else new_target
                    tags_removed += count
                    segment_modified = True
            
            if segment_modified:
                modified_count += 1
        
        progress.setValue(len(self.current_project.segments))
        
        # Refresh grid
        if modified_count > 0:
            self.project_modified = True
            self.load_segments_to_grid()
            self.update_window_title()
        
        # Show results
        scope_text = "both source and target" if (clean_source and clean_target) else ("source" if clean_source else "target")
        QMessageBox.information(
            self, "Tag Cleaning Complete",
            f"‚úÖ Cleaned {modified_count:,} segment(s)\n"
            f"üè∑Ô∏è Removed {tags_removed:,} tag(s)\n"
            f"üìã Scope: {scope_text}"
        )
        
        self.log(f"üßπ Tag cleaning: {modified_count} segments modified, {tags_removed} tags removed")
    
    # ========================================================================
    # PROOFREADING SYSTEM
    # ========================================================================
    
    def show_proofread_dialog(self):
        """Show dialog to configure and start proofreading"""
        if not self.current_project:
            QMessageBox.information(self, "No Project", "Please open or create a project first.")
            return
        
        # Count segments for each option
        confirmed_count = sum(1 for seg in self.current_project.segments if seg.status == 'confirmed')
        translated_count = sum(1 for seg in self.current_project.segments if seg.status in ['translated', 'confirmed'])
        
        # Count selected rows (not cells)
        selected_count = 0
        if hasattr(self, 'table'):
            selected_rows = set(item.row() for item in self.table.selectedItems())
            selected_count = len(selected_rows)
        
        all_count = len(self.current_project.segments)
        
        dialog = QDialog(self)
        dialog.setWindowTitle("‚úÖ Proofread Translation")
        dialog.setModal(True)
        dialog.setMinimumWidth(600)
        
        layout = QVBoxLayout(dialog)
        
        # Header
        header = QLabel("<h3>‚úÖ AI-Enhanced Translation Proofreading</h3>")
        layout.addWidget(header)
        
        info_label = QLabel(
            "Use AI to verify translation accuracy, completeness, terminology, and style.\n"
            "Results will be stored in the Notes field with a ‚ö†Ô∏è PROOFREAD prefix."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; padding: 10px 0;")
        layout.addWidget(info_label)
        
        layout.addSpacing(10)
        
        # Segment selection
        segment_group = QGroupBox("Segments to Proofread")
        segment_layout = QVBoxLayout()
        
        confirmed_radio = CheckmarkRadioButton(f"‚úÖ Confirmed only ({confirmed_count} segments)")
        confirmed_radio.setChecked(True)
        segment_layout.addWidget(confirmed_radio)
        
        translated_radio = CheckmarkRadioButton(f"üìù Translated + Confirmed ({translated_count} segments)")
        segment_layout.addWidget(translated_radio)
        
        selected_radio = CheckmarkRadioButton(f"üîπ Selected ({selected_count} segments)")
        selected_radio.setEnabled(selected_count > 0)
        if selected_count == 0:
            selected_radio.setToolTip("Select one or more rows in the grid to enable this option")
        segment_layout.addWidget(selected_radio)
        
        all_radio = CheckmarkRadioButton(f"üåê All segments ({all_count} segments)")
        segment_layout.addWidget(all_radio)
        
        segment_group.setLayout(segment_layout)
        layout.addWidget(segment_group)
        
        layout.addSpacing(10)
        
        # LLM provider info
        settings = self.load_llm_settings()
        llm_provider = settings.get('provider', 'openai')
        model_key = f'{llm_provider}_model'
        llm_model = settings.get(model_key, 'gpt-4o')
        
        llm_info = QLabel(f"üìä Using: {llm_provider.title()} ({llm_model})")
        llm_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px 0;")
        layout.addWidget(llm_info)
        
        layout.addSpacing(10)
        
        # Custom prompt override
        prompt_group = QGroupBox("Proofreading Prompt (Optional)")
        prompt_layout = QVBoxLayout()
        
        prompt_text = QTextEdit()
        prompt_text.setPlaceholderText(
            "Leave empty to use default prompt, or customize here...\n\n"
            "Default checks:\n"
            "1. Accuracy ‚Äì Does target correctly convey source meaning?\n"
            "2. Completeness ‚Äì Is anything missing or added?\n"
            "3. Terminology ‚Äì Are technical terms correct and consistent?\n"
            "4. Grammar & Style ‚Äì Is the text natural and error-free?"
        )
        prompt_text.setMaximumHeight(120)
        prompt_layout.addWidget(prompt_text)
        
        prompt_group.setLayout(prompt_layout)
        layout.addWidget(prompt_group)
        
        layout.addSpacing(20)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_btn)
        
        start_btn = QPushButton("Start Proofreading")
        start_btn.setDefault(True)
        start_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        start_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(start_btn)
        
        layout.addLayout(button_layout)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Determine which segments to proofread
        segments_to_check = []
        if confirmed_radio.isChecked():
            segments_to_check = [(i, seg) for i, seg in enumerate(self.current_project.segments) if seg.status == 'confirmed']
        elif translated_radio.isChecked():
            segments_to_check = [(i, seg) for i, seg in enumerate(self.current_project.segments) if seg.status in ['translated', 'confirmed']]
        elif selected_radio.isChecked():
            selected_rows = set(item.row() for item in self.table.selectedItems())
            segments_to_check = [(i, seg) for i, seg in enumerate(self.current_project.segments) if i in selected_rows]
        else:  # all_radio
            segments_to_check = list(enumerate(self.current_project.segments))
        
        if not segments_to_check:
            QMessageBox.information(self, "No Segments", "No segments match the selected criteria.")
            return
        
        custom_prompt = prompt_text.toPlainText().strip()
        
        # Start proofreading
        self._run_proofreading(segments_to_check, llm_provider, llm_model, custom_prompt)
    
    def _run_proofreading(self, segments_to_check, provider, model, custom_prompt=""):
        """Run proofreading on selected segments"""
        # Create progress dialog
        progress_dialog = QDialog(self)
        progress_dialog.setWindowTitle("Proofreading in Progress")
        progress_dialog.setModal(True)
        progress_dialog.setMinimumWidth(600)
        progress_dialog.setMinimumHeight(300)
        
        dialog_layout = QVBoxLayout(progress_dialog)
        
        current_label = QLabel("Initializing...")
        dialog_layout.addWidget(current_label)
        
        progress_bar = QProgressBar()
        progress_bar.setMaximum(len(segments_to_check))
        progress_bar.setValue(0)
        dialog_layout.addWidget(progress_bar)
        
        stats_label = QLabel("Checked: 0 | Issues Found: 0 | OK: 0")
        dialog_layout.addWidget(stats_label)
        
        close_btn = QPushButton("Close")
        close_btn.setEnabled(False)
        close_btn.clicked.connect(progress_dialog.accept)
        dialog_layout.addWidget(close_btn)
        
        progress_dialog.show()
        QApplication.processEvents()
        
        # Default prompt with language-specific instructions
        if not custom_prompt:
            # Add language-specific checks
            lang_specific = ""
            if self.current_project.target_lang.lower() in ['dutch', 'nl', 'nl-nl', 'nl-be', 'nederlands']:
                lang_specific = """
5. Dutch Compound Words ‚Äì Verify correct spelling of compound words (e.g., "persoonsgegevens" NOT "persoongegevens", "bedrijfsnaam" NOT "bedrijfnaam"). Pay special attention to connecting letters like 's', 'e', 'en'.
6. Dutch Spelling ‚Äì Check for common Dutch spelling errors including de/het articles, dt-errors, and capitalization."""
            elif self.current_project.target_lang.lower() in ['german', 'de', 'de-de', 'deutsch']:
                lang_specific = """
5. German Compound Words ‚Äì Verify correct compound noun formation and capitalization of all nouns.
6. German Cases ‚Äì Check correct use of cases (Nominativ, Akkusativ, Dativ, Genitiv)."""
            elif self.current_project.target_lang.lower() in ['french', 'fr', 'fr-fr', 'fran√ßais']:
                lang_specific = """
5. French Accents ‚Äì Verify correct use of accents (√©, √®, √™, √†, √π, √¥, etc.).
6. French Agreement ‚Äì Check gender/number agreement between nouns, adjectives, and articles."""
            
            custom_prompt = f"""You are a translation proofreader. Your task is to analyze translations for errors.

DO NOT translate anything. DO NOT provide corrected translations unless specifically requested.
ONLY identify errors using the exact format specified below.

Task: Proofread this translation from {self.current_project.source_lang} to {self.current_project.target_lang}.

For each segment, verify:
1. Accuracy ‚Äì Does the translation correctly convey the source meaning?
2. Completeness ‚Äì Is anything missing or added?
3. Terminology ‚Äì Are technical terms translated correctly and consistently?
4. Grammar & Style ‚Äì Is the text natural and error-free?{lang_specific}

CRITICAL OUTPUT FORMAT (FOLLOW EXACTLY):
- If segment is OK: [SEGMENT XXXX] ‚úì
- If segment has issues: [SEGMENT XXXX] ‚ö†
  Issue: <brief description>
  Suggestion: <recommended fix>

OUTPUT ONLY THE SEGMENT MARKERS. DO NOT ADD EXPLANATIONS BEFORE OR AFTER."""
        
        # Initialize LLM client
        api_keys = self.load_api_keys()
        llm_client = None
        
        try:
            from modules.llm_clients import LLMClient
            
            # Get appropriate API key for provider
            # Note: api_keys is normalized so both 'gemini' and 'google' exist if either is set
            if provider == 'openai':
                api_key = api_keys.get('openai', '')
            elif provider == 'claude':
                api_key = api_keys.get('claude', '')
            elif provider == 'gemini':
                api_key = api_keys.get('gemini', '')
            elif provider == 'ollama':
                api_key = ''  # Ollama doesn't need an API key
            else:
                api_key = ''
            
            llm_client = LLMClient(api_key=api_key, provider=provider, model=model)
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to initialize LLM client:\n{str(e)}")
            return
        
        # Process in batches of 20 segments
        batch_size = 20
        checked_count = 0
        issues_count = 0
        ok_count = 0
        
        for batch_start in range(0, len(segments_to_check), batch_size):
            batch_end = min(batch_start + batch_size, len(segments_to_check))
            batch = segments_to_check[batch_start:batch_end]
            
            # Format batch for API
            batch_text = ""
            for row_idx, segment in batch:
                segment_num = f"{row_idx + 1:04d}"
                batch_text += f"[SEGMENT {segment_num}]\n{self.current_project.source_lang}: {segment.source}\n{self.current_project.target_lang}: {segment.target}\n\n"
            
            current_label.setText(f"Proofreading segments {batch_start + 1}-{batch_end}...")
            QApplication.processEvents()
            
            # Send to LLM
            try:
                # Build full prompt with instructions and segments
                full_prompt = f"{custom_prompt}\n\n{batch_text}"
                
                # Log the prompt being sent (first 500 chars)
                self.log(f"üì§ Sending proofreading request for {len(batch)} segments...")
                self.log(f"üìù Prompt preview: {full_prompt[:500]}...")
                
                # Use translate() method but with a proofreading context
                # We're not actually translating, just using the LLM to analyze
                response = llm_client.translate(
                    text="",  # Empty text since we're including everything in custom_prompt
                    source_lang=self.current_project.source_lang,
                    target_lang=self.current_project.target_lang,
                    custom_prompt=full_prompt
                )
                
                # Log the response
                self.log(f"üì• Received response ({len(response)} chars)")
                self.log(f"üìÑ Response (full): {response}")
                
                # Parse response
                for row_idx, segment in batch:
                    segment_num = f"{row_idx + 1:04d}"
                    
                    # Look for [SEGMENT XXXX] markers
                    pattern_ok = f"\\[SEGMENT {segment_num}\\]\\s*‚úì"
                    pattern_issue = f"\\[SEGMENT {segment_num}\\]\\s*‚ö†"
                    
                    if re.search(pattern_ok, response, re.IGNORECASE):
                        # Segment is OK
                        ok_count += 1
                    elif re.search(pattern_issue, response, re.IGNORECASE):
                        # Segment has issues - extract details
                        issue_pattern = f"\\[SEGMENT {segment_num}\\]\\s*‚ö†\\s*\\n(.+?)(?=\\[SEGMENT|$)"
                        issue_match = re.search(issue_pattern, response, re.DOTALL)
                        
                        if issue_match:
                            issue_text = issue_match.group(1).strip()
                            
                            # Add to notes with prefix
                            existing_notes = segment.notes or ""
                            if existing_notes:
                                segment.notes = f"‚ö†Ô∏è PROOFREAD:\n{issue_text}\n\n---\n{existing_notes}"
                            else:
                                segment.notes = f"‚ö†Ô∏è PROOFREAD:\n{issue_text}"
                            
                            issues_count += 1
                            self.project_modified = True
                    
                    checked_count += 1
                    progress_bar.setValue(checked_count)
                    stats_label.setText(f"Checked: {checked_count} | Issues Found: {issues_count} | OK: {ok_count}")
                    QApplication.processEvents()
            
            except Exception as e:
                self.log(f"‚ö†Ô∏è Proofreading error for batch {batch_start}-{batch_end}: {e}")
        
        # Complete
        current_label.setText(f"‚úì Proofreading Complete!")
        close_btn.setEnabled(True)
        self.load_segments_to_grid()  # Refresh grid to show orange indicators
        self.update_window_title()
        
        self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        self.log(f"‚úì Proofreading Complete")
        self.log(f"   Checked: {checked_count} | Issues: {issues_count} | OK: {ok_count}")
        self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    
    def show_proofreading_results_dialog(self):
        """Show dialog with all proofreading results"""
        if not self.current_project:
            QMessageBox.information(self, "No Project", "Please open or create a project first.")
            return
        
        # Find segments with proofreading notes
        proofread_segments = []
        for i, segment in enumerate(self.current_project.segments):
            if segment.notes and "‚ö†Ô∏è PROOFREAD:" in segment.notes:
                proofread_segments.append((i, segment))
        
        if not proofread_segments:
            QMessageBox.information(
                self,
                "No Proofreading Results",
                "No segments have proofreading issues.\n\n"
                "Run Edit ‚Üí Bulk Operations ‚Üí ‚úÖ Proofread Translation to analyze your translation."
            )
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("‚úÖ Proofreading Results")
        dialog.setModal(False)
        dialog.setMinimumWidth(900)
        dialog.setMinimumHeight(600)
        
        layout = QVBoxLayout(dialog)
        
        # Header
        header = QLabel(f"<h3>‚ö†Ô∏è {len(proofread_segments)} Segment{'s' if len(proofread_segments) != 1 else ''} with Proofreading Issues</h3>")
        layout.addWidget(header)
        
        info_label = QLabel("Click any row to navigate to that segment in the grid.")
        info_label.setStyleSheet("color: #666; padding: 5px 0;")
        layout.addWidget(info_label)
        
        # Results table
        table = QTableWidget()
        table.setColumnCount(4)
        table.setHorizontalHeaderLabels(["Seg #", "Source", "Target", "Issue"])
        table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        table.horizontalHeader().setStretchLastSection(True)
        table.setColumnWidth(0, 60)
        table.setColumnWidth(1, 200)
        table.setColumnWidth(2, 200)
        
        for row_idx, segment in proofread_segments:
            table_row = table.rowCount()
            table.insertRow(table_row)
            
            # Segment number
            table.setItem(table_row, 0, QTableWidgetItem(str(row_idx + 1)))
            
            # Source (truncated)
            source_text = segment.source[:80] + "..." if len(segment.source) > 80 else segment.source
            table.setItem(table_row, 1, QTableWidgetItem(source_text))
            
            # Target (truncated)
            target_text = segment.target[:80] + "..." if len(segment.target) > 80 else segment.target
            table.setItem(table_row, 2, QTableWidgetItem(target_text))
            
            # Issue (extract from notes)
            notes = segment.notes or ""
            issue_text = notes.split("‚ö†Ô∏è PROOFREAD:")[1].split("---")[0].strip() if "‚ö†Ô∏è PROOFREAD:" in notes else notes
            issue_text = issue_text[:100] + "..." if len(issue_text) > 100 else issue_text
            table.setItem(table_row, 3, QTableWidgetItem(issue_text))
            
            # Store segment index in row data
            table.item(table_row, 0).setData(Qt.ItemDataRole.UserRole, row_idx)
        
        # Double-click to navigate
        def on_row_double_clicked(row):
            segment_idx = table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.jump_to_segment(segment_idx)
            dialog.lower()  # Send dialog to back so grid is visible
        
        table.cellDoubleClicked.connect(lambda row, col: on_row_double_clicked(row))
        
        layout.addWidget(table)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        clear_all_btn = QPushButton("üóëÔ∏è Clear All Proofreading Notes")
        clear_all_btn.clicked.connect(lambda: self._clear_all_proofreading_notes(dialog))
        button_layout.addWidget(clear_all_btn)
        
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        dialog.show()
    
    def _clear_all_proofreading_notes(self, parent_dialog):
        """Clear all proofreading notes from all segments"""
        reply = QMessageBox.question(
            self,
            "Clear All Proofreading Notes",
            "Are you sure you want to clear all proofreading notes from all segments?\n\n"
            "This will remove the ‚ö†Ô∏è PROOFREAD prefix and associated issues,\n"
            "but will preserve any other notes.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        cleared_count = 0
        for segment in self.current_project.segments:
            if segment.notes and "‚ö†Ô∏è PROOFREAD:" in segment.notes:
                # Remove proofreading section
                parts = segment.notes.split("‚ö†Ô∏è PROOFREAD:")
                if len(parts) > 1:
                    remaining = parts[1].split("---", 1)
                    if len(remaining) > 1:
                        # Has other notes after separator
                        segment.notes = remaining[1].strip()
                    else:
                        # No other notes
                        segment.notes = ""
                cleared_count += 1
        
        if cleared_count > 0:
            self.project_modified = True
            self.load_segments_to_grid()  # Refresh grid
            self.update_window_title()
            parent_dialog.accept()  # Close the results dialog
            QMessageBox.information(self, "Cleared", f"Cleared proofreading notes from {cleared_count} segment{'s' if cleared_count != 1 else ''}.")
            self.log(f"‚úì Cleared proofreading notes from {cleared_count} segments")
    
    def send_segments_to_tm_dialog(self):
        """
        Show dialog to send segments to TM (similar to memoQ's Confirm and Update).
        Allows user to select scope and status filters, then sends matching segments 
        to the writable TM(s).
        """
        if not self.current_project or not self.current_project.segments:
            QMessageBox.warning(self, "No Project", "Please load a project first.")
            return
        
        if not hasattr(self, 'tm_metadata_mgr') or not self.tm_metadata_mgr:
            QMessageBox.warning(self, "No TM Manager", "Translation Memory system is not initialized.")
            return
        
        # Get available TMs
        all_tms = self.tm_metadata_mgr.get_all_tms()
        if not all_tms:
            QMessageBox.warning(self, "No TMs", 
                "No Translation Memories found.\n\nPlease create or import a TM in Resources ‚Üí Translation Memories.")
            return
        
        # Get writable TMs (those with Write enabled)
        writable_tms = [tm for tm in all_tms if not tm.get('read_only', True)]
        if not writable_tms:
            QMessageBox.warning(self, "No Writable TMs", 
                "No writable Translation Memories found.\n\n"
                "Please enable Write (‚úì) for at least one TM in Resources ‚Üí Translation Memories ‚Üí TM List.")
            return
        
        # Create dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Send Segments to TM")
        dialog.setMinimumWidth(500)
        dialog.setMinimumHeight(400)
        layout = QVBoxLayout(dialog)
        
        # Info text
        info_label = QLabel(
            "Send translated segments to a Translation Memory.\n"
            "Only segments matching the selected criteria will be sent."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("color: #666; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Scope group
        scope_group = QGroupBox("Scope")
        scope_layout = QVBoxLayout(scope_group)
        
        scope_project = CheckmarkCheckBox("Entire project")
        scope_project.setChecked(True)
        scope_selected = CheckmarkCheckBox("Selected segments only")
        scope_selected.setEnabled(False)  # Will enable if selection exists
        scope_selected.setChecked(False)
        
        # Check if we have a selection
        selected_segments = self.get_selected_segments_from_grid() if hasattr(self, 'get_selected_segments_from_grid') else []
        if selected_segments:
            scope_selected.setEnabled(True)
            scope_selected.setText(f"Selected segments only ({len(selected_segments)} selected)")
        
        # Make scope checkboxes mutually exclusive
        def on_scope_project_changed(checked):
            if checked:
                scope_selected.setChecked(False)
        
        def on_scope_selected_changed(checked):
            if checked:
                scope_project.setChecked(False)
        
        scope_project.toggled.connect(on_scope_project_changed)
        scope_selected.toggled.connect(on_scope_selected_changed)
        
        scope_layout.addWidget(scope_project)
        scope_layout.addWidget(scope_selected)
        layout.addWidget(scope_group)
        
        # Status filter group
        status_group = QGroupBox("Status of segments to send")
        status_layout = QGridLayout(status_group)
        
        # Import status definitions
        from modules.statuses import STATUSES
        
        # Create checkboxes for each status
        status_checkboxes = {}
        statuses_to_show = [
            ("confirmed", "Confirmed", True),       # Default checked
            ("tr_confirmed", "TR Confirmed", True), # Default checked
            ("translated", "Translated", False),
            ("proofread", "Proofread", True),       # Default checked
            ("approved", "Approved", True),         # Default checked
            ("pretranslated", "Pre-translated", False),
        ]
        
        row = 0
        col = 0
        for status_key, status_label, default_checked in statuses_to_show:
            status_def = STATUSES.get(status_key)
            if status_def:
                cb = CheckmarkCheckBox(f"{status_def.icon} {status_label}")
                cb.setChecked(default_checked)
                status_checkboxes[status_key] = cb
                status_layout.addWidget(cb, row, col)
                col += 1
                if col >= 2:
                    col = 0
                    row += 1
        
        # Add "All statuses" checkbox
        all_statuses_cb = CheckmarkCheckBox("All statuses (with translation)")
        all_statuses_cb.setChecked(False)
        
        def on_all_statuses_changed(checked):
            for cb in status_checkboxes.values():
                cb.setEnabled(not checked)
        
        all_statuses_cb.toggled.connect(on_all_statuses_changed)
        status_layout.addWidget(all_statuses_cb, row + 1, 0, 1, 2)
        
        layout.addWidget(status_group)
        
        # Target TM group
        tm_group = QGroupBox("Target Translation Memory")
        tm_layout = QVBoxLayout(tm_group)
        
        tm_combo = QComboBox()
        for tm in writable_tms:
            entry_count = tm.get('entry_count', 0)
            tm_combo.addItem(f"{tm['name']} ({entry_count} entries)", tm['id'])
        
        tm_layout.addWidget(tm_combo)
        
        # Note about multiple writable TMs
        if len(writable_tms) > 1:
            multi_note = QLabel(
                f"‚ÑπÔ∏è {len(writable_tms)} writable TMs available. Select which one to send segments to."
            )
            multi_note.setStyleSheet("color: #2196F3; font-size: 10px;")
            tm_layout.addWidget(multi_note)
        
        layout.addWidget(tm_group)
        
        # Options group
        options_group = QGroupBox("Options")
        options_layout = QVBoxLayout(options_group)
        
        overwrite_cb = CheckmarkCheckBox("Update existing entries (overwrite if source matches)")
        overwrite_cb.setChecked(True)
        overwrite_cb.setToolTip("If a segment with the same source text exists, update its target.")
        options_layout.addWidget(overwrite_cb)
        
        skip_empty_cb = CheckmarkCheckBox("Skip segments with empty translations")
        skip_empty_cb.setChecked(True)
        options_layout.addWidget(skip_empty_cb)
        
        layout.addWidget(options_group)
        
        # Preview section
        preview_group = QGroupBox("Preview")
        preview_layout = QVBoxLayout(preview_group)
        preview_label = QLabel("Click 'Preview' to see how many segments will be sent.")
        preview_label.setStyleSheet("color: #888;")
        preview_layout.addWidget(preview_label)
        
        def update_preview():
            # Count matching segments
            segments_to_check = selected_segments if scope_selected.isChecked() else self.current_project.segments
            
            matching = 0
            for seg in segments_to_check:
                # Check if has translation
                if skip_empty_cb.isChecked() and not seg.target.strip():
                    continue
                
                # Check status
                if all_statuses_cb.isChecked():
                    if seg.target.strip():  # Has any translation
                        matching += 1
                else:
                    for status_key, cb in status_checkboxes.items():
                        if cb.isChecked() and seg.status == status_key:
                            matching += 1
                            break
            
            preview_label.setText(f"‚úì {matching} segment(s) will be sent to TM")
            preview_label.setStyleSheet("color: #2e7d32; font-weight: bold;")
        
        preview_btn = QPushButton("Preview")
        preview_btn.clicked.connect(update_preview)
        preview_layout.addWidget(preview_btn)
        
        layout.addWidget(preview_group)
        
        # Buttons
        layout.addStretch()
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        buttons.button(QDialogButtonBox.StandardButton.Ok).setText("Send to TM")
        buttons.accepted.connect(dialog.accept)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)
        
        if dialog.exec() != QDialog.DialogCode.Accepted:
            return
        
        # Perform the operation
        target_tm_id = tm_combo.currentData()
        target_tm_name = tm_combo.currentText()
        
        segments_to_check = selected_segments if scope_selected.isChecked() else self.current_project.segments
        
        sent_count = 0
        skipped_count = 0
        error_count = 0
        
        # Get language codes
        source_lang = self.current_project.source_lang or "en"
        target_lang = self.current_project.target_lang or "nl"
        
        self.status_bar.showMessage(f"Sending segments to TM '{target_tm_name}'...")
        QApplication.processEvents()
        
        for seg in segments_to_check:
            try:
                # Check if has translation
                if skip_empty_cb.isChecked() and not seg.target.strip():
                    skipped_count += 1
                    continue
                
                # Check status
                should_send = False
                if all_statuses_cb.isChecked():
                    if seg.target.strip():
                        should_send = True
                else:
                    for status_key, cb in status_checkboxes.items():
                        if cb.isChecked() and seg.status == status_key:
                            should_send = True
                            break
                
                if not should_send:
                    skipped_count += 1
                    continue
                
                # Strip formatting tags for TM (store clean text)
                source_clean = strip_formatting_tags(seg.source) if has_formatting_tags(seg.source) else seg.source
                target_clean = strip_formatting_tags(seg.target) if has_formatting_tags(seg.target) else seg.target
                
                # Add to TM using the correct method
                try:
                    self.tm_database.add_entry(
                        source=source_clean,
                        target=target_clean,
                        tm_id=target_tm_id
                    )
                    sent_count += 1
                except Exception as add_error:
                    self.log(f"‚ö† Failed to add segment {seg.id}: {add_error}")
                    error_count += 1
                    
            except Exception as e:
                error_count += 1
                self.log(f"‚ö† Error sending segment {seg.id} to TM: {e}")
        
        # Update TM entry count in metadata
        if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr:
            try:
                self.tm_metadata_mgr.update_entry_count(target_tm_id)
            except Exception as e:
                self.log(f"‚ö† Could not update TM entry count: {e}")
        
        # Refresh TM list if visible
        if hasattr(self, 'refresh_tm_list'):
            try:
                self.refresh_tm_list()
            except:
                pass
        
        # Report results
        self.log(f"‚úì Sent {sent_count} segments to TM '{target_tm_name}'")
        if skipped_count > 0:
            self.log(f"  Skipped: {skipped_count} (empty or non-matching status)")
        if error_count > 0:
            self.log(f"  Errors: {error_count}")
        
        self.status_bar.showMessage(f"‚úì Sent {sent_count} segments to TM", 5000)
        
        QMessageBox.information(
            self, "Send to TM Complete",
            f"Sent {sent_count} segment(s) to TM '{target_tm_name}'.\n\n"
            f"Skipped: {skipped_count}\n"
            f"Errors: {error_count}"
        )
    
    def _restore_active_prompt(self, prompt_type: str, prompt_name: str):
        """Restore an active prompt by name"""
        if not hasattr(self, 'prompt_manager_qt') or not self.prompt_manager_qt:
            return
        
        try:
            if prompt_type == 'translate':
                # Find and activate domain prompt
                for i in range(self.prompt_manager_qt.domain_tree.topLevelItemCount()):
                    item = self.prompt_manager_qt.domain_tree.topLevelItem(i)
                    filename = item.data(0, Qt.ItemDataRole.UserRole)
                    if filename:
                        prompt_data = self.prompt_manager_qt.prompt_library.get_prompt(filename)
                        if prompt_data and prompt_data.get('name') == prompt_name:
                            self.prompt_manager_qt.domain_tree.setCurrentItem(item)
                            self.prompt_manager_qt._activate_domain_expertise('translate')
                            break
            elif prompt_type == 'proofread':
                # Find and activate domain prompt
                for i in range(self.prompt_manager_qt.domain_tree.topLevelItemCount()):
                    item = self.prompt_manager_qt.domain_tree.topLevelItem(i)
                    filename = item.data(0, Qt.ItemDataRole.UserRole)
                    if filename:
                        prompt_data = self.prompt_manager_qt.prompt_library.get_prompt(filename)
                        if prompt_data and prompt_data.get('name') == prompt_name:
                            self.prompt_manager_qt.domain_tree.setCurrentItem(item)
                            self.prompt_manager_qt._activate_domain_expertise('proofread')
                            break
            elif prompt_type == 'project':
                # Find and activate project prompt
                for i in range(self.prompt_manager_qt.project_tree.topLevelItemCount()):
                    item = self.prompt_manager_qt.project_tree.topLevelItem(i)
                    filename = item.data(0, Qt.ItemDataRole.UserRole)
                    if filename:
                        prompt_data = self.prompt_manager_qt.prompt_library.get_prompt(filename)
                        if prompt_data and prompt_data.get('name') == prompt_name:
                            self.prompt_manager_qt.project_tree.setCurrentItem(item)
                            self.prompt_manager_qt._activate_project_guideline()
                            break
        except Exception as e:
            self.log(f"‚ö† Could not restore {prompt_type} prompt '{prompt_name}': {e}")
    
    def _restore_active_style_guide(self, guide_name: str, language: str):
        """Restore an active style guide by name and language
        
        NOTE: Temporarily disabled for unified prompt library migration.
        TODO: Implement session restoration for unified library (save/restore active prompts)
        """
        if not hasattr(self, 'prompt_manager_qt') or not self.prompt_manager_qt:
            return
        
        # TODO: Adapt this for unified prompt library
        # The new system uses multi-attach, so we'd need to:
        # 1. Find the style guide in library.prompts
        # 2. Attach it using library.attach_prompt(path)
        # For now, skip restoration - user can re-select prompts
        self.log(f"‚ö† Style guide restoration not yet implemented in unified library: '{guide_name}' ({language})")
    
    def _schedule_delayed_lookup(self, segment, current_row):
        """Schedule TM and termbase lookup with delay (cancel if user moves to another segment)"""
        self.log(f"üöÄ _schedule_delayed_lookup called for segment {current_row + 1}: '{segment.source[:50]}...'")
        
        # Cancel any pending lookup
        if self.lookup_timer:
            self.lookup_timer.stop()
            self.lookup_timer = None
        
        # Store current segment ID for checking if user moved away
        segment_id = id(segment)
        self.current_lookup_segment_id = segment_id
        
        # If matching is disabled, skip
        self.log(f"üîß SCHEDULING CHECK: TM enabled={self.enable_tm_matching}, Termbase enabled={self.enable_termbase_matching}")
        if not (self.enable_tm_matching or self.enable_termbase_matching):
            self.log(f"üîß SCHEDULING BLOCKED: Both TM and termbase matching are disabled")
            return
        self.log(f"üîß SCHEDULING OK: At least one matching type is enabled")
        
        # Get user-configured delay (default 1.5 seconds)
        general_prefs = self.load_general_settings()
        lookup_delay = general_prefs.get('lookup_delay', 1500)
        
        # Schedule lookup after user-configured delay (allows user to navigate quickly without triggering searches)
        from PyQt6.QtCore import QTimer
        self.lookup_timer = QTimer()
        self.lookup_timer.setSingleShot(True)
        # CRITICAL: Capture variables by value using default parameters to avoid closure bugs
        self.lookup_timer.timeout.connect(lambda seg=segment, row=current_row, seg_id=segment_id: self._perform_delayed_lookup(seg, row, seg_id))
        self.lookup_timer.start(lookup_delay)
        self.log(f"üöÄ _schedule_delayed_lookup: Will search segment {current_row + 1} in {lookup_delay}ms")
    
    def _perform_delayed_lookup(self, segment, current_row, expected_segment_id):
        """Perform TM and termbase lookup after delay (only if user is still on same segment)"""
        self.log(f"ÔøΩ DELAYED LOOKUP STARTED for segment {current_row + 1}: '{segment.source[:50]}...'")
        self.log(f"üö® DELAYED LOOKUP: expected_id={expected_segment_id}, current_id={self.current_lookup_segment_id}")
        
        # Check if user moved to another segment
        if self.current_lookup_segment_id != expected_segment_id:
            self.log(f"ÔøΩ DELAYED LOOKUP CANCELLED: User moved to different segment")
            return  # User moved away, cancel lookup
            
        self.log(f"üö® DELAYED LOOKUP CONTINUING: User still on same segment")
        
        # Check if still on the same row
        if current_row < 0 or current_row >= self.table.rowCount():
            return
        
        current_segment = self.table.item(current_row, 2)  # Source column
        if not current_segment or current_segment.text() != segment.source:
            return  # Segment changed
        
        try:
            # Update TM matches (if enabled)
            if self.enable_tm_matching:
                try:
                    self.search_and_display_tm_matches(segment.source)
                except Exception as e:
                    self.log(f"Error searching TM: {e}")
            
            # Update TranslationResultsPanel if available
            if hasattr(self, 'assistance_widget') and hasattr(self.assistance_widget, 'set_segment_info'):
                try:
                    # Generate matches dictionary for the panel
                    from modules.translation_results_panel import TranslationMatch
                    
                    matches_dict = {
                        "LLM": [],     # LLM Translation (appears first)
                        "NT": [],      # No Translation
                        "MT": [],      # Machine Translation
                        "TM": [],      # Translation Memory
                        "Termbases": [], # Terminology
                        "NonTrans": []  # Non-translatables
                    }
                    
                    # Generate TM matches from database if available (and enabled)
                    self.log(f"ÔøΩ DEBUG: Reached TM search section in _perform_delayed_lookup")
                    self.log(f"ÔøΩüîç TM SEARCH CHECK: TM enabled={self.enable_tm_matching}, has_db_manager={hasattr(self, 'db_manager')}, db_manager_valid={self.db_manager is not None if hasattr(self, 'db_manager') else False}")
                    if self.enable_tm_matching and hasattr(self, 'db_manager') and self.db_manager:
                        try:
                            self.log(f"üü¢ TM SEARCH: Searching for matches for '{segment.source[:50]}...'")
                            
                            # Get current project languages
                            source_lang = getattr(self.current_project, 'source_lang', None) if self.current_project else None
                            target_lang = getattr(self.current_project, 'target_lang', None) if self.current_project else None
                            
                            # Convert language names to codes if needed
                            if source_lang:
                                source_lang = self._convert_language_to_code(source_lang)
                            if target_lang:
                                target_lang = self._convert_language_to_code(target_lang)
                            
                            self.log(f"üü¢ TM SEARCH: Project languages: {source_lang} ‚Üí {target_lang}")
                            
                            # Search in primary direction (current project direction)
                            tm_matches = self.db_manager.search_all(segment.source, max_results=10)
                            
                            # Also search in reverse direction (bidirectional TM matching)
                            # This is crucial for reusing TM in opposite direction
                            reverse_matches = []
                            if source_lang and target_lang and source_lang != target_lang:
                                try:
                                    # Search for segment.source as target text in reverse direction
                                    reverse_query = """
                                        SELECT source_text, target_text, source_lang, target_lang, tm_id, usage_count
                                        FROM translation_units 
                                        WHERE target_text = ? AND source_lang = ? AND target_lang = ?
                                        ORDER BY usage_count DESC
                                        LIMIT 5
                                    """
                                    self.db_manager.cursor.execute(reverse_query, (segment.source, target_lang, source_lang))
                                    reverse_rows = self.db_manager.cursor.fetchall()
                                    
                                    for row in reverse_rows:
                                        reverse_matches.append({
                                            'source': row['target_text'],  # Swap source/target for reverse match
                                            'target': row['source_text'],
                                            'match_pct': 95,  # High relevance for reverse exact match
                                            'tm_name': f"{row['tm_id'].replace('_', ' ').title()} (Reverse)",
                                            'tm_id': row['tm_id']
                                        })
                                    
                                    self.log(f"üü¢ TM SEARCH: Found {len(reverse_matches)} reverse matches")
                                except Exception as e:
                                    self.log(f"Error in reverse TM search: {e}")
                            
                            # Combine primary and reverse matches
                            all_tm_matches = tm_matches + reverse_matches
                            
                            self.log(f"üü¢ TM SEARCH: Total matches found: {len(all_tm_matches)} ({len(tm_matches)} primary + {len(reverse_matches)} reverse)")
                            
                            for match in all_tm_matches:
                                match_obj = TranslationMatch(
                                    source=match.get('source', ''),
                                    target=match.get('target', ''),
                                    relevance=match.get('match_pct', 0),
                                    metadata={
                                        'context': match.get('context', ''),
                                        'tm_name': match.get('tm_name', ''),
                                        'timestamp': match.get('created_at', ''),
                                        'direction': 'reverse' if 'Reverse' in match.get('tm_name', '') else 'primary'
                                    },
                                    match_type='TM',
                                    compare_source=match.get('source', ''),
                                    provider_code='TM'
                                )
                                matches_dict["TM"].append(match_obj)
                        except Exception as e:
                            self.log(f"Error loading TM matches: {e}")
                    
                    # Add termbase matches to the results panel (if enabled)
                    if self.enable_termbase_matching:
                        try:
                            if hasattr(self, 'db_manager') and self.db_manager:
                                # Search termbases directly to get full information including termbase_id
                                source_lang = getattr(self.current_project, 'source_lang', None) if self.current_project else 'en'  # Default to English
                                target_lang = getattr(self.current_project, 'target_lang', None) if self.current_project else 'nl'  # Default to Dutch
                                
                                # Debug logging
                                self.log(f"üîç Termbase matching: segment='{segment.source}', langs={source_lang}->{target_lang}, project={self.current_project is not None}")
                                self.log(f"üîç TM matching enabled: {self.enable_tm_matching}, TM database: {hasattr(self, 'tm_database') and self.tm_database is not None}")
                                project_id_raw = getattr(self.current_project, 'id', None) if (self.current_project and hasattr(self.current_project, 'id')) else None
                                
                                # Convert project_id to string if needed (database stores as TEXT)
                                project_id = str(project_id_raw) if project_id_raw is not None else None
                                
                                # Search for all terms in the source text
                                if segment.source:
                                    # First try exact phrase match, then fall back to word-by-word
                                    termbase_results_by_term = {}
                                    
                                    # Try exact phrase match first (whole source text)
                                    try:
                                        self.log("üü¢ TERMBASE CALL: From delayed lookup (_delayed_lookup)")
                                        self.log(f"üîç Searching termbases for exact phrase: '{segment.source.strip()}'")
                                        exact_results = self.db_manager.search_termbases(
                                            segment.source.strip(),
                                            source_lang=source_lang,
                                            target_lang=target_lang,
                                            project_id=project_id,
                                            min_length=len(segment.source.strip())
                                        )
                                        self.log(f"üîç Exact phrase results: {len(exact_results)} matches")
                                        for tb_match in exact_results:
                                            source_term = tb_match.get('source_term', '').strip()
                                            target_term = tb_match.get('target_term', '').strip()
                                            termbase_id_raw = tb_match.get('termbase_id')
                                            
                                            try:
                                                termbase_id = int(termbase_id_raw) if termbase_id_raw else None
                                            except (ValueError, TypeError):
                                                termbase_id = termbase_id_raw
                                            
                                            if source_term and target_term and termbase_id:
                                                key = (source_term, target_term, termbase_id)
                                                if key not in termbase_results_by_term:
                                                    termbase_results_by_term[key] = tb_match
                                    except Exception as exact_error:
                                        self.log(f"Error in exact phrase search: {exact_error}")
                                    
                                    # Then search word-by-word for partial matches
                                    words = segment.source.split()
                                    for word in words:
                                        clean_word = word.strip('.,!?;:')
                                        if len(clean_word) < 2:
                                            continue
                                        
                                        try:
                                            tb_results = self.db_manager.search_termbases(
                                                clean_word,
                                                source_lang=source_lang,
                                                target_lang=target_lang,
                                                project_id=project_id,
                                                min_length=2
                                            )
                                            
                                            for tb_match in tb_results:
                                                source_term = tb_match.get('source_term', '').strip()
                                                target_term = tb_match.get('target_term', '').strip()
                                                termbase_id_raw = tb_match.get('termbase_id')
                                                
                                                # Convert termbase_id to int if it's stored as string
                                                try:
                                                    termbase_id = int(termbase_id_raw) if termbase_id_raw else None
                                                except (ValueError, TypeError):
                                                    termbase_id = termbase_id_raw  # Keep as-is if conversion fails
                                                
                                                if source_term and target_term and termbase_id:
                                                    # Store with termbase_id as key to avoid duplicates
                                                    key = (source_term, target_term, termbase_id)
                                                    if key not in termbase_results_by_term:
                                                        termbase_results_by_term[key] = tb_match
                                        except Exception as search_error:
                                            self.log(f"Error searching termbases for '{clean_word}': {search_error}")
                                            continue
                                    
                                    # Get termbase names for IDs found
                                    termbase_code_map = self.get_termbase_code_map()
                                    
                                    # Create TranslationMatch objects
                                    for (source_term, target_term, termbase_id), tb_match in termbase_results_by_term.items():
                                        try:
                                            # Get termbase code (or generate from name)
                                            termbase_code = self.get_termbase_code(termbase_id, termbase_code_map)
                                            
                                            # Get termbase ranking and is_project_termbase
                                            termbase_ranking = tb_match.get('ranking', None)  # From JOIN
                                            is_project_termbase = tb_match.get('is_project_termbase', False)
                                            
                                            match_obj = TranslationMatch(
                                                source=source_term,
                                                target=target_term,
                                                relevance=95,  # High relevance for termbase matches
                                                metadata={
                                                    'term_id': tb_match.get('id'),  # Term entry ID for editing
                                                    'termbase_id': termbase_id,
                                                    'termbase_name': tb_match.get('termbase_name', 'Unknown'),
                                                    'ranking': termbase_ranking,  # NEW: Termbase-level ranking for color shading
                                                    'priority': tb_match.get('priority', 99),  # Keep for backward compatibility
                                                    'is_project_termbase': is_project_termbase,  # Project termbase flag
                                                    'domain': tb_match.get('domain', ''),
                                                    'notes': tb_match.get('notes', ''),
                                                    'project': tb_match.get('project', ''),
                                                    'client': tb_match.get('client', ''),
                                                    'forbidden': tb_match.get('forbidden', False),
                                                    'target_synonyms': tb_match.get('target_synonyms', [])
                                                },
                                                match_type='Termbase',
                                                compare_source=source_term,
                                                provider_code=termbase_code
                                            )
                                            matches_dict["Termbases"].append(match_obj)
                                        except Exception as match_error:
                                            import traceback
                                            self.log(f"‚ùå Error creating termbase match: {match_error}")
                                            self.log(f"Traceback: {traceback.format_exc()}")
                                            continue
                                    
                                    if termbase_results_by_term:
                                        num_created = len(matches_dict["Termbases"])
                                        self.log(f"‚úì Found {len(termbase_results_by_term)} termbase matches, created {num_created} TranslationMatch objects")
                                    else:
                                        self.log(f"‚ÑπÔ∏è No termbase matches found for segment: '{segment.source[:50]}...'")
                                else:
                                    self.log("‚ö†Ô∏è No source text in segment for termbase search")
                        
                            self.log("üéØ CHECKPOINT: Termbase search completed, about to continue to set_matches...")
                        except Exception as e:
                            import traceback
                            self.log(f"‚ùå Error adding termbase matches: {e}")
                            self.log(f"Traceback: {traceback.format_exc()}")
                    
                    self.log("üéØ CHECKPOINT: About to fetch LLM and MT, then call set_matches...")
                    
                    # Fetch LLM translation for current segment (async, updates panel when ready)
                    self._fetch_llm_translation_async(segment.source, segment, current_row)
                    
                    # Fetch MT translation for current segment (async, updates panel when ready)
                    self._fetch_mt_translation_async(segment.source, segment, current_row)
                    
                    # Display matches (LLM and MT will be added when ready)
                    total_matches = sum(len(matches) for matches in matches_dict.values())
                    self.log(f"üîç Calling set_matches() with {total_matches} total matches:")
                    for match_type, matches in matches_dict.items():
                        if matches:
                            self.log(f"  {match_type}: {len(matches)} matches")
                            if match_type == "Termbases" and matches:
                                for i, match in enumerate(matches[:3]):  # Show first 3 for debugging
                                    self.log(f"    [{i}] {match.source} ‚Üí {match.target} (relevance: {match.relevance})")
                    
                    # Update all tabbed results panels
                    if hasattr(self, 'results_panels') and self.results_panels:
                        self.log(f"‚úÖ Updating {len(self.results_panels)} results panels")
                        for panel in self.results_panels:
                            try:
                                panel.set_matches(matches_dict)
                            except Exception as e:
                                self.log(f"Error updating panel: {e}")
                        self.log(f"‚úÖ All panels updated successfully")
                    else:
                        self.log(f"‚ùå results_panels missing or empty: {getattr(self, 'results_panels', 'NOT_SET')}")
                except Exception as e:
                    self.log(f"Error updating TranslationResultsPanel: {e}")
        except Exception as e:
            self.log(f"Error in delayed lookup: {e}")
    
    def toggle_tm_termbase_matching(self, enabled: bool):
        """Toggle TM and termbase matching on/off"""
        self.enable_tm_matching = enabled
        self.enable_termbase_matching = enabled

        # Update checkbox in settings if it exists (prevents circular updates)
        if hasattr(self, 'tm_matching_checkbox') and self.tm_matching_checkbox:
            # Temporarily disconnect to prevent signal loop
            self.tm_matching_checkbox.blockSignals(True)
            self.tm_matching_checkbox.setChecked(enabled)
            self.tm_matching_checkbox.blockSignals(False)

        # Update all segment editor toggle buttons (Grid, List, Document views)
        if hasattr(self, 'tabbed_panels') and self.tabbed_panels:
            for tabs in self.tabbed_panels:
                if hasattr(tabs, 'editor_widget') and hasattr(tabs.editor_widget, 'tm_toggle_btn'):
                    btn = tabs.editor_widget.tm_toggle_btn
                    btn.blockSignals(True)
                    btn.setChecked(enabled)
                    btn.setText("üîç TM/Glossary ON" if enabled else "üö´ TM/Glossary OFF")
                    btn.blockSignals(False)

        if enabled:
            self.log("‚úì TM and Glossary matching enabled")
            # If a segment is currently selected, trigger lookup
            if hasattr(self, 'table') and self.table and hasattr(self, 'current_project') and self.current_project:
                current_row = self.table.currentRow()
                if current_row >= 0 and current_row < len(self.current_project.segments):
                    segment = self.current_project.segments[current_row]
                    self._schedule_delayed_lookup(segment, current_row)
        else:
            self.log("‚ö† TM and Glossary matching disabled")
            # Cancel any pending lookup
            if self.lookup_timer:
                self.lookup_timer.stop()
                self.lookup_timer = None
    
    
    def on_cell_clicked(self, item: QTableWidgetItem):
        """Handle cell click - Status column clicks are disabled (use Segment Editor instead)"""
        self.log(f"üñ±Ô∏è on_cell_clicked called: row {item.row()}, col {item.column()}")
        if not self.current_project:
            return

        row = item.row()
        col = item.column()
        
        # Reset selection anchor on normal click (so next Shift+PageUp/Down starts fresh)
        # Note: We set it to the clicked row, so Shift+Page will extend from here
        self._selection_anchor_row = row

        # Status column (4) - clicks disabled, use Segment Editor to change status
        # This prevents visual issues and unwanted status changes
        if col == 4:
            self.log(f"Status column click ignored - use Segment Editor to change status")
            return

    def on_cell_double_clicked(self, row: int, col: int):
        """Handle double-click on a cell - remove highlight widget and start editing if needed"""
        self.log(f"üñ±Ô∏è on_cell_double_clicked called: row {row}, col {col}")

        # Check if this cell has a highlight widget (ClickableHighlightLabel)
        cell_widget = self.table.cellWidget(row, col)
        if cell_widget and isinstance(cell_widget, ClickableHighlightLabel):
            self.log(f"üñ±Ô∏è Removing highlight widget and starting edit for row {row}, col {col}")

            # Get the plain text stored in the widget
            plain_text = cell_widget.plain_text

            # Get or create the underlying QTableWidgetItem
            item = self.table.item(row, col)
            if item is None:
                item = QTableWidgetItem(plain_text)
                item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)
                self.table.setItem(row, col, item)
            else:
                # Restore the plain text and ensure it's editable
                item.setText(plain_text)
                item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)

            # Remove the cell widget
            self.table.removeCellWidget(row, col)

            # Start editing
            self.table.setCurrentCell(row, col)
            self.table.editItem(item)

    # ========================================================================
    # TRANSLATION MEMORY
    # ========================================================================
    
    def initialize_tm_database(self):
        """Initialize TM database when project is loaded"""
        if not self.current_project:
            return
        
        try:
            # Update TM database languages for the current project
            # (tm_database is already initialized at startup)
            if self.tm_database:
                self.tm_database.set_tm_languages(
                    self.current_project.source_lang,
                    self.current_project.target_lang
                )
            
            # Update Superlookup tab with TM database
            if hasattr(self, 'lookup_tab') and self.lookup_tab:
                self.lookup_tab.set_tm_database(self.tm_database)
            
            self.log(f"TM database configured ({self.current_project.source_lang} ‚Üí {self.current_project.target_lang})")
        except Exception as e:
            self.log(f"Warning: Could not configure TM database: {e}")
            self.tm_database = None
    
    def _initialize_spellcheck_for_target_language(self, target_lang: str):
        """Initialize spellcheck for the given target language after import/load"""
        if not target_lang:
            return
        
        try:
            if hasattr(self, 'spellcheck_manager') and self.spellcheck_manager:
                if self.spellcheck_manager.set_language(target_lang):
                    self.log(f"‚úì Spellcheck initialized for target language: {target_lang}")
                else:
                    self.log(f"‚ö† Spellcheck dictionary not available for {target_lang}")
        except Exception as e:
            self.log(f"‚ö† Could not initialize spellcheck: {e}")
    
    def _deactivate_all_resources_for_new_project(self):
        """Deactivate all TMs, termbases, and NT lists for a freshly imported project.
        This ensures new projects start with clean slate - user explicitly activates what they need."""
        if not self.current_project or not hasattr(self.current_project, 'id'):
            return
        
        project_id = self.current_project.id
        if not project_id:
            return
        
        # Deactivate all TMs for this project
        if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr:
            all_tms = self.tm_metadata_mgr.get_all_tms()
            for tm in all_tms:
                self.tm_metadata_mgr.deactivate_tm(tm['id'], project_id)
        
        # Deactivate all termbases for this project
        if hasattr(self, 'termbase_mgr') and self.termbase_mgr:
            all_termbases = self.termbase_mgr.get_all_termbases()
            for tb in all_termbases:
                self.termbase_mgr.deactivate_termbase(tb['id'], project_id)
        
        # Deactivate all NT lists
        if hasattr(self, 'nt_manager') and self.nt_manager:
            for list_name in list(self.nt_manager.lists.keys()):
                self.nt_manager.set_list_active(list_name, False)
        
        self.log("üìã New project: All TMs, glossaries, and NT lists deactivated (start clean)")
        self.log("üí° Tip: Go to Resources tab to activate TMs and glossaries for this project")

    def search_and_display_tm_matches(self, source_text: str):
        """Search TM and Termbases and display matches with visual diff for fuzzy matches"""
        self.log(f"üö® search_and_display_tm_matches called with source_text: '{source_text[:50]}...'")
        if not source_text or not source_text.strip():
            if hasattr(self, 'tm_display'):
                self.tm_display.clear()
            return
        
        # Initialize TM if not already done
        if not self.tm_database and self.current_project:
            self.initialize_tm_database()
        
        if not self.tm_database:
            if hasattr(self, 'tm_display'):
                self.tm_display.setHtml(
                    "<p style='color: #999;'><i>Translation Memory not available</i></p>"
                )
            return
        
        try:
            # Get activated TM IDs for current project
            tm_ids = None
            no_tms_activated = False
            tms_wrong_language = False
            if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                if project_id:
                    tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                    # Check if no TMs are activated for this project
                    if tm_ids is not None and len(tm_ids) == 0:
                        no_tms_activated = True
                    elif tm_ids and len(tm_ids) > 0:
                        # Check if any activated TMs match the project's language pair
                        project_source = (self.current_project.source_lang or '').lower()
                        project_target = (self.current_project.target_lang or '').lower()
                        all_tms = self.tm_metadata_mgr.get_all_tms()
                        has_matching_language = False
                        for tm in all_tms:
                            if tm['id'] in tm_ids:
                                tm_source = (tm.get('source_lang') or '').lower()
                                tm_target = (tm.get('target_lang') or '').lower()
                                # Match if languages align (bidirectional) or TM has no language set
                                if (not tm_source and not tm_target) or \
                                   (tm_source == project_source and tm_target == project_target) or \
                                   (tm_source == project_target and tm_target == project_source):
                                    has_matching_language = True
                                    break
                        if not has_matching_language:
                            tms_wrong_language = True

            # Search for matches (using activated TMs if available)
            matches = self.tm_database.search_all(source_text, tm_ids=tm_ids, max_matches=5)
            
            # Auto-propagate exact match if enabled (check both settings)
            general_prefs = self.load_general_settings()
            auto_propagate_100 = general_prefs.get('auto_propagate_100', True)
            auto_propagate_enabled = self.auto_propagate_exact_matches or auto_propagate_100
            
            if matches and auto_propagate_enabled:
                first_match = matches[0]
                match_pct = first_match.get('match_pct', 0)
                
                # Check if we have a 100% match
                if match_pct == 100:
                    # Check if current segment is empty/untranslated
                    if hasattr(self, 'table') and hasattr(self, 'current_project'):
                        current_row = self.table.currentRow()
                        if current_row >= 0 and current_row < len(self.current_project.segments):
                            segment = self.current_project.segments[current_row]
                            
                            # Only auto-propagate if segment is empty or untranslated
                            if (not segment.target or not segment.target.strip() or 
                                segment.status in ["untranslated", "not_started", ""]):
                                
                                # Fill the segment
                                segment.target = first_match.get('target', '')
                                segment.status = "translated"
                                segment.modified = True
                                self.project_modified = True
                                
                                # Update grid (using cell widget)
                                target_widget = self.table.cellWidget(current_row, 3)
                                if target_widget and isinstance(target_widget, EditableGridTextEditor):
                                    target_widget.setPlainText(segment.target)
                                
                                # Update status column
                                status_item = self.table.item(current_row, 1)
                                if status_item:
                                    status_item.setText("Translated")
                                    status_item.setBackground(QColor("#d1fae5"))  # Light green for translated
                                
                                # Update project modified status (progress is handled by status bar)
                                self.log(f"‚ú® Auto-propagated 100% TM match for segment #{current_row + 1}")
            
            if not matches:
                if hasattr(self, 'tm_display'):
                    if no_tms_activated:
                        # Show helpful message when no TMs are activated
                        self.tm_display.setHtml(
                            f"<p style='color: #666;'><b>Source:</b> {source_text}</p>"
                            f"<p style='color: #E65100;'><i>No TMs activated for this project.</i></p>"
                            f"<p style='color: #999; font-size: 9pt;'>Go to <b>Resources ‚Üí TM</b> to activate translation memories.</p>"
                        )
                    elif tms_wrong_language:
                        # Show message when TMs are activated but don't match project language pair
                        project_lang_pair = f"{self.current_project.source_lang} ‚Üí {self.current_project.target_lang}" if self.current_project else ""
                        self.tm_display.setHtml(
                            f"<p style='color: #666;'><b>Source:</b> {source_text}</p>"
                            f"<p style='color: #E65100;'><i>Activated TMs don't match project language ({project_lang_pair}).</i></p>"
                            f"<p style='color: #999; font-size: 9pt;'>Go to <b>Resources ‚Üí TM</b> to activate TMs for this language pair.</p>"
                        )
                    else:
                        self.tm_display.setHtml(
                            f"<p style='color: #666;'><b>Source:</b> {source_text}</p>"
                            f"<p style='color: #999;'><i>No translation memory matches found</i></p>"
                        )
                return
            
            # If using TranslationResultsPanel, populate it with TM and Termbase results
            if hasattr(self.assistance_widget, 'set_matches'):
                try:
                    from modules.translation_results_panel import TranslationMatch
                    
                    # Convert TM matches with full TM metadata
                    tm_matches = []
                    for match in matches:
                        # Get full TM metadata from tm_metadata_mgr if available
                        tm_metadata = {
                            'tm_name': match.get('tm_name', 'Unknown TM'),
                            'tm_id': match.get('tm_id', ''),
                            'context': match.get('context', '')
                        }
                        
                        # Fetch full TM details if tm_metadata_mgr is available
                        if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr:
                            tm_id_str = match.get('tm_id', '')
                            if tm_id_str:
                                # Find TM by tm_id string (not database ID)
                                all_tms = self.tm_metadata_mgr.get_all_tms()
                                for tm in all_tms:
                                    if tm['tm_id'] == tm_id_str:
                                        tm_metadata.update({
                                            'source_lang': tm.get('source_lang', ''),
                                            'target_lang': tm.get('target_lang', ''),
                                            'entry_count': tm.get('entry_count', 0),
                                            'modified_date': tm.get('modified_date', ''),
                                            'description': tm.get('description', '')
                                        })
                                        break
                        
                        tm_match = TranslationMatch(
                            source=match.get('source', ''),
                            target=match.get('target', ''),
                            relevance=int(match.get('match_pct', 0)),
                            metadata=tm_metadata,
                            match_type='TM',
                            compare_source=match.get('source', '')
                        )
                        tm_matches.append(tm_match)
                    
                    # Search for termbase matches
                    termbase_matches = []
                    try:
                        if hasattr(self, 'db_manager') and self.db_manager:
                            # Get current project language pair
                            source_lang = None
                            target_lang = None
                            project_id = None
                            
                            if self.current_project:
                                # current_project is a Project object, not a dict
                                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                                source_lang = self.current_project.source_lang if hasattr(self.current_project, 'source_lang') else None
                                target_lang = self.current_project.target_lang if hasattr(self.current_project, 'target_lang') else None
                            
                            # Search for individual words in the source text
                            words = source_text.split()
                            searched_terms = set()  # Track what we've already searched
                            
                            for word in words:
                                # Remove punctuation
                                clean_word = word.strip('.,!?;:')
                                if len(clean_word) < 2 or clean_word in searched_terms:
                                    continue
                                
                                searched_terms.add(clean_word)
                                
                                # Search termbases for this word
                                tb_results = self.db_manager.search_termbases(
                                    clean_word,
                                    source_lang=source_lang,
                                    target_lang=target_lang,
                                    project_id=project_id,
                                    min_length=2
                                )
                                
                                # Convert termbase results to TranslationMatch objects
                                source_text_lower = source_text.lower()
                                import re
                                for tb_match in tb_results:
                                    source_term_full = tb_match.get('source_term', '')
                                    target_term_full = tb_match.get('target_term', '')
                                    if not source_term_full or not target_term_full:
                                        continue
                                    # Require full phrase presence in segment (word-boundary)
                                    pattern = re.compile(r"\b" + re.escape(source_term_full.lower()) + r"\b")
                                    if not pattern.search(source_text_lower):
                                        continue
                                    # Deduplicate by term_id
                                    term_id = tb_match.get('id')
                                    if any(m.metadata.get('term_id') == term_id for m in termbase_matches):
                                        continue
                                    termbase_match = TranslationMatch(
                                        source=source_term_full,
                                        target=target_term_full,
                                        relevance=100 - tb_match.get('priority', 99),
                                        metadata={
                                            'term_id': term_id,
                                            'termbase_id': tb_match.get('termbase_id'),
                                            'termbase_name': tb_match.get('termbase_name', ''),
                                            'ranking': tb_match.get('ranking', None),
                                            'priority': tb_match.get('priority', 99),
                                            'domain': tb_match.get('domain', ''),
                                            'notes': tb_match.get('notes', ''),
                                            'project': tb_match.get('project', ''),
                                            'client': tb_match.get('client', ''),
                                            'forbidden': tb_match.get('forbidden', False),
                                            'is_project_termbase': tb_match.get('is_project_termbase', False),
                                            'target_synonyms': tb_match.get('target_synonyms', [])
                                        },
                                        match_type='Termbase',
                                        compare_source=source_term_full
                                    )
                                    termbase_matches.append(termbase_match)
                    except Exception as e:
                        self.log(f"Error searching termbases: {e}")

                    
                    # Update the panel with both TM and Termbase matches
                    matches_dict = {}
                    if tm_matches:
                        matches_dict['TM'] = tm_matches
                    if termbase_matches:
                        matches_dict['Termbases'] = termbase_matches
                    
                    if matches_dict and hasattr(self, 'results_panels'):
                        for panel in self.results_panels:
                            try:
                                panel.set_matches(matches_dict)
                            except Exception as e:
                                self.log(f"Error updating panel: {e}")
                    return
                except Exception as e:
                    self.log(f"Error populating TranslationResultsPanel: {e}")
            
            # Fallback: display in tm_display if it exists
            if not hasattr(self, 'tm_display'):
                return
            
            # Build HTML display with diff highlighting
            html = f"<div style='font-family: {self.default_font_family}; font-size: {self.default_font_size}pt;'>"
            html += f"<p style='color: #666; margin-bottom: 10px;'><b>üîç Searching for:</b><br>{source_text}</p>"
            html += "<hr style='border: 1px solid #ddd;'>"
            
            for idx, match in enumerate(matches, start=1):
                match_pct = match.get('match_pct', 0)
                tm_name = match.get('tm_name', 'Unknown TM')
                source_match = match.get('source', '')
                target_match = match.get('target', '')
                
                # Color based on match percentage
                if match_pct == 100:
                    color = "#22c55e"  # Green for exact match
                    badge_style = "background-color: #22c55e; color: white;"
                elif match_pct >= 95:
                    color = "#3b82f6"  # Blue for high match
                    badge_style = "background-color: #3b82f6; color: white;"
                elif match_pct >= 85:
                    color = "#f59e0b"  # Orange for medium match
                    badge_style = "background-color: #f59e0b; color: white;"
                else:
                    color = "#ef4444"  # Red for low match
                    badge_style = "background-color: #ef4444; color: white;"
                
                html += f"<div style='margin: 10px 0; padding: 10px; background-color: #f9fafb; border-left: 4px solid {color}; border-radius: 4px;'>"
                html += f"<div style='margin-bottom: 5px;'>"
                html += f"<span style='padding: 2px 8px; border-radius: 3px; font-weight: bold; font-size: 10pt; {badge_style}'>{match_pct}%</span> "
                html += f"<span style='color: #666; font-size: 9pt;'>{tm_name}</span>"
                html += "</div>"
                
                # Display source with diff if not 100% match
                if match_pct < 100:
                    diff_html = self.create_diff_html(source_text, source_match)
                    html += f"<p style='margin: 5px 0; color: #444;'><b>TM Source:</b><br>{diff_html}</p>"
                else:
                    html += f"<p style='margin: 5px 0; color: #444;'><b>TM Source:</b><br>{source_match}</p>"
                
                # Display target (clickable to insert)
                html += f"<p style='margin: 5px 0; color: #059669; font-weight: bold;'><b>TM Target:</b><br>"
                html += f"<span style='cursor: pointer; text-decoration: underline;' "
                html += f"onclick='alert(\"{target_match}\")'>{target_match}</span></p>"
                html += "</div>"
            
            html += "</div>"
            self.tm_display.setHtml(html)
            
        except Exception as e:
            self.log(f"Error searching TM: {e}")
            if hasattr(self, 'tm_display'):
                self.tm_display.setHtml(
                    f"<p style='color: #ef4444;'><b>Error:</b> {e}</p>"
                )
    
    def create_diff_html(self, current_text: str, tm_text: str) -> str:
        """Create HTML with visual diff highlighting between current and TM source
        
        Shows changes inline like memoQ:
        - Red strikethrough for deleted text (in TM but not in current)
        - Green underline + bold for added text (in current but not in TM)
        - Sequential display: deletions then additions in order
        """
        from difflib import SequenceMatcher
        
        s = SequenceMatcher(None, tm_text, current_text)
        html_parts = []
        
        for tag, i1, i2, j1, j2 in s.get_opcodes():
            tm_chunk = tm_text[i1:i2]
            current_chunk = current_text[j1:j2]
            
            if tag == 'equal':
                # Matching text - show normally
                html_parts.append(tm_chunk)
            elif tag == 'delete':
                # Text removed from TM - show with red strikethrough (like memoQ deletion)
                html_parts.append(f'<span style="color: #dc2626; text-decoration: line-through;">{tm_chunk}</span>')
            elif tag == 'insert':
                # Text added in current - show with green underline + bold (like memoQ insertion)
                html_parts.append(f'<span style="color: #22c55e; text-decoration: underline; font-weight: bold;">{current_chunk}</span>')
            elif tag == 'replace':
                # Text changed - show deletion (strikethrough) followed by insertion (underline)
                # This matches memoQ's behavior: old text strikethrough, new text underlined
                html_parts.append(f'<span style="color: #dc2626; text-decoration: line-through;">{tm_chunk}</span>')
                html_parts.append(' ')  # Add space between deletion and insertion
                html_parts.append(f'<span style="color: #22c55e; text-decoration: underline; font-weight: bold;">{current_chunk}</span>')
        
        return ''.join(html_parts)
    
    # ========================================================================
    # TERMBASE HIGHLIGHTING & MATCHING
    # ========================================================================
    
    def get_termbase_code_map(self) -> Dict[int, str]:
        """Get mapping of termbase_id to custom codes (from user preferences)"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        if not prefs_file.exists():
            return {}
        
        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                return prefs.get('termbase_code_map', {})  # {termbase_id: "CODE"}
        except:
            return {}
    
    def save_termbase_code_map(self, code_map: Dict[int, str]):
        """Save termbase code mappings to user preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        # Load existing preferences
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        # Update termbase code map
        prefs['termbase_code_map'] = code_map
        
        # Save back
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save termbase code map: {str(e)}")
    
    def get_termbase_code(self, termbase_id: int, code_map: Optional[Dict[int, str]] = None) -> str:
        """
        Get code for a termbase (custom code or auto-generated from name)
        
        Args:
            termbase_id: The termbase ID
            code_map: Optional pre-loaded code map (for performance)
            
        Returns:
            Code string (e.g., "MED", "LEG", "TECH") or empty string
        """
        if code_map is None:
            code_map = self.get_termbase_code_map()
        
        # Check if user has set a custom code
        if termbase_id in code_map:
            return code_map[termbase_id]
        
        # Auto-generate code from termbase name
        try:
            termbase_name = None
            
            if hasattr(self, 'termbase_mgr') and self.termbase_mgr:
                termbase = self.termbase_mgr.get_termbase(termbase_id)
                if termbase:
                    termbase_name = termbase.get('name', '') if isinstance(termbase, dict) else getattr(termbase, 'name', '')
            
            # Fallback: query database directly
            if not termbase_name and hasattr(self, 'db_manager') and self.db_manager:
                cursor = self.db_manager.cursor
                cursor.execute("SELECT name FROM termbases WHERE id = ?", (termbase_id,))
                row = cursor.fetchone()
                if row:
                    termbase_name = row[0]
            
            if not termbase_name:
                return ""
            
            # Generate code from name: take first 3-4 uppercase letters
            # Examples: "Medical Dictionary" -> "MED", "Legal Terms" -> "LEG", "Technical Glossary" -> "TECH"
            words = termbase_name.split()
            if len(words) >= 2:
                # Take first letter of first two words, then add more if needed
                code = (words[0][0] + words[1][0]).upper()
                if len(code) < 3 and len(words[0]) >= 2:
                    code = words[0][:3].upper()
            else:
                # Single word: take first 3 uppercase letters
                code = termbase_name[:3].upper()
            
            # Ensure code is 2-4 characters
            if len(code) > 4:
                code = code[:4]
            
            return code
        except Exception as e:
            self.log(f"Error generating termbase code: {e}")
            return ""
    
    def _convert_language_to_code(self, language: str) -> str:
        """Convert full language name to language code for termbase search"""
        language_map = {
            'Dutch': 'nl',
            'English': 'en', 
            'French': 'fr',
            'German': 'de',
            'Spanish': 'es',
            'Italian': 'it',
            'Portuguese': 'pt',
            'Russian': 'ru',
            'Chinese': 'zh',
            'Japanese': 'ja',
            'Korean': 'ko',
            'Arabic': 'ar'
        }
        return language_map.get(language, language.lower() if language else None)

    def find_termbase_matches_in_source(self, source_text: str) -> Dict[str, str]:
        """
        Find all termbase matches in source text
        Returns dict of {term: translation} for all matches found

        v1.9.182: Uses in-memory index for instant lookup when available.
        Falls back to per-word database queries if index not built.
        """
        if not source_text or not hasattr(self, 'db_manager') or not self.db_manager:
            return {}

        try:
            # v1.9.182: Use in-memory index for instant lookup (1000x faster)
            # The index is built on project load by _build_termbase_index()
            with self.termbase_index_lock:
                has_index = bool(self.termbase_index)

            if has_index:
                # Fast path: use pre-built in-memory index
                return self._search_termbase_in_memory(source_text)

            # Fallback: original per-word database query approach
            # (only used if index not yet built, e.g., during startup)
            source_lang = self.current_project.source_lang if self.current_project else None
            target_lang = self.current_project.target_lang if self.current_project else None

            # Convert language names to codes for termbase search
            source_lang_code = self._convert_language_to_code(source_lang) if source_lang else None
            target_lang_code = self._convert_language_to_code(target_lang) if target_lang else None

            # Strip HTML/XML/CAT tool tags from source text before word splitting
            # This handles <b>, </b>, <i>, memoQ {1}, [2}, Trados <1>, D√©j√† Vu {00001}, etc.
            import re
            clean_source_text = re.sub(r'</?(?:b|i|u|bi|sub|sup|li-[ob]|\d+)/?>', '', source_text)  # HTML/XML tags
            clean_source_text = re.sub(r'[\[{]\d+[}\]]', '', clean_source_text)  # memoQ/Phrase numeric tags: {1}, [2}, {3]
            clean_source_text = re.sub(r'\{\d{5}\}', '', clean_source_text)  # D√©j√† Vu tags: {00001}
            # memoQ content tags: [uicontrol id="..."}  or  {uicontrol]  or  [tagname ...}  or  {tagname]
            clean_source_text = re.sub(r'\[[^\[\]]*\}', '', clean_source_text)  # Opening: [anything}
            clean_source_text = re.sub(r'\{[^\{\}]*\]', '', clean_source_text)  # Closing: {anything]

            # Search termbases for all terms that appear in the source text
            # Split source text into words and search for each one
            words = clean_source_text.split()
            matches = {}
            # Use the ORIGINAL source text (with tags) for position matching later
            source_text_lower = source_text.lower()
            # Also create a tag-stripped lowercase version for pattern matching
            clean_source_lower = clean_source_text.lower()
            # Only log word count, not individual words (too verbose)
            
            # Comprehensive set of quote and punctuation characters to strip
            # Includes: straight quotes, curly quotes (left/right), German quotes, guillemets, single quotes
            # ALSO includes parentheses, brackets, and braces for terms like "(typisch)" or "[example]"
            # Using explicit characters to avoid encoding issues
            PUNCT_CHARS = '.,!?;:\"\'\u201C\u201D\u201E\u00AB\u00BB\u2018\u2019\u201A\u2039\u203A()[]{}' 
            
            for word in words:
                # Remove punctuation including quotes (preserve internal punctuation like "gew.%")
                # First strip trailing punctuation
                clean_word = word.rstrip(PUNCT_CHARS)
                # Then strip leading punctuation
                clean_word = clean_word.lstrip(PUNCT_CHARS)
                
                if len(clean_word) < 2:  # Skip short words
                    continue
                
                # Get project ID for termbase priority lookup
                project_id = self.current_project.id if self.current_project and hasattr(self.current_project, 'id') else None
                
                # CRITICAL FIX: Search for BOTH the cleaned word AND the original word with punctuation
                # This allows glossary entries like "ca." to match source text "ca." where
                # the tokenized/cleaned version is "ca" but the glossary entry has the period
                words_to_search = [clean_word]
                # Also try searching with trailing punctuation (for entries like "ca.", "gew.%")
                original_word_stripped_leading = word.lstrip(PUNCT_CHARS)
                if original_word_stripped_leading != clean_word and len(original_word_stripped_leading) >= 2:
                    words_to_search.append(original_word_stripped_leading)
                
                termbase_results = []
                for search_word in words_to_search:
                    results = self.db_manager.search_termbases(
                        search_word,
                        source_lang=source_lang_code,
                        target_lang=target_lang_code,
                        project_id=project_id,
                        min_length=2
                    )
                    if results:
                        termbase_results.extend(results)
                
                if termbase_results:
                    for result in termbase_results:
                        source_term = result.get('source_term', '').strip()
                        target_term = result.get('target_term', '').strip()
                        priority = result.get('priority', 50)
                        ranking = result.get('ranking', None)  # NEW: termbase ranking (1, 2, 3...)
                        forbidden = result.get('forbidden', False)
                        is_project_termbase = result.get('is_project_termbase', False)
                        term_id = result.get('id')
                        termbase_id = result.get('termbase_id')
                        termbase_name = result.get('termbase_name', 'Unknown')
                        domain = result.get('domain', '')
                        notes = result.get('notes', '')
                        project = result.get('project', '')
                        client = result.get('client', '')
                        if not source_term or not target_term:
                            continue
                        # FILTER: Only keep if full source term appears in source text (case-insensitive)
                        # Use lookaround word boundaries to handle terms with punctuation like "gew.%"
                        import re
                        # Normalize source text: replace ALL quote variants with spaces
                        # This ensures word boundaries work correctly for terms in quotes
                        # Using Unicode escapes to avoid encoding issues
                        normalized_source = clean_source_lower
                        for quote_char in '\"\'\u201C\u201D\u201E\u00AB\u00BB\u2018\u2019\u201A\u2039\u203A':
                            normalized_source = normalized_source.replace(quote_char, ' ')
                        
                        # CRITICAL FIX: Strip trailing punctuation from glossary term before matching
                        # This allows entries like "De huidige uitvinding...problemen." (with period)
                        # to match source text "...problemen." where tokenization strips the period
                        # Strip from both ends to handle quotes and trailing punctuation
                        normalized_term = source_term.lower().rstrip(PUNCT_CHARS).lstrip(PUNCT_CHARS)
                        
                        # Check if term has punctuation - use different pattern
                        if any(char in normalized_term for char in ['.', '%', ',', '-', '/']):
                            pattern = re.compile(r'(?<!\w)' + re.escape(normalized_term) + r'(?!\w)')
                        else:
                            pattern = re.compile(r"\b" + re.escape(normalized_term) + r"\b")
                        
                        # Try matching on normalized (tag-stripped, quote-stripped) text first, 
                        # then tag-stripped, then original with tags
                        if not pattern.search(normalized_source) and not pattern.search(clean_source_lower) and not pattern.search(source_text_lower):
                            # Skip terms whose full phrase isn't in the segment
                            continue
                        # CRITICAL FIX: Use term_id as dict key instead of source_term
                        # This allows multiple translations for the same source term to coexist
                        # Example: "inrichting ‚Üí device" AND "inrichting ‚Üí apparatus" both displayed
                        # Old code: matches[source_term] = {...} - only kept one translation
                        # New code: matches[term_id] = {...} - keeps all translations
                        matches[term_id] = {
                            'source': source_term,  # Add source field for display
                            'translation': target_term,
                            'priority': priority,  # Legacy field from term itself
                            'ranking': ranking,  # NEW: termbase ranking (None if not activated)
                            'forbidden': forbidden,
                            'is_project_termbase': is_project_termbase,
                            'term_id': term_id,
                            'termbase_id': termbase_id,
                            'termbase_name': termbase_name,
                            'domain': domain,
                            'notes': notes,
                            'project': project,
                            'client': client,
                            'target_synonyms': result.get('target_synonyms', [])  # Include synonyms
                        }
            
            # Filter duplicates: if same source‚Üítarget exists in multiple glossaries,
            # only keep the one with highest priority (lowest ranking number)
            filtered_matches = {}
            seen_pairs = {}  # (source_lower, target_lower) -> (term_id, ranking)
            
            for term_id, match_info in matches.items():
                source_lower = match_info['source'].lower()
                target_lower = match_info['translation'].lower()
                pair_key = (source_lower, target_lower)
                ranking = match_info.get('ranking', 99)
                
                if pair_key in seen_pairs:
                    # Duplicate found - keep only the higher priority (lower number)
                    existing_term_id, existing_ranking = seen_pairs[pair_key]
                    if ranking < existing_ranking:
                        # This one has higher priority, replace the existing one
                        del filtered_matches[existing_term_id]
                        filtered_matches[term_id] = match_info
                        seen_pairs[pair_key] = (term_id, ranking)
                else:
                    # First occurrence of this pair
                    filtered_matches[term_id] = match_info
                    seen_pairs[pair_key] = (term_id, ranking)
            
            # Only log if matches were found (reduce noise)
            if filtered_matches:
                self.log(f"üîç Found {len(filtered_matches)} termbase matches (duplicates filtered)")
            return filtered_matches
            
        except Exception as e:
            self.log(f"‚ùå Error finding termbase matches: {e}")
            import traceback
            self.log(f"Traceback: {traceback.format_exc()}")
            return {}
    
    def find_nt_matches_in_source(self, source_text: str) -> list:
        """
        Find non-translatable matches in source text from all active NT lists.
        
        Args:
            source_text: Source text to search in
            
        Returns:
            List of match dicts with 'text', 'start', 'end', 'list_name' keys
        """
        if not hasattr(self, 'nt_manager') or not self.nt_manager:
            return []
        
        try:
            return self.nt_manager.find_all_matches(source_text)
        except Exception as e:
            self.log(f"Error finding NT matches: {e}")
            return []
    
    def highlight_source_with_termbase(self, row: int, source_text: str, termbase_matches: Optional[Dict] = None):
        """
        Highlight termbase matches in the source column using text formatting.
        Does NOT replace the widget - just adds background colors to existing ReadOnlyGridTextEditor.
        
        Args:
            row: Row number in table
            source_text: Source text to highlight
            termbase_matches: Optional pre-computed matches dict (to avoid duplicate searches)
        """
        if not self.table or row < 0:
            return
        
        try:
            # Use provided matches or find them
            if termbase_matches is None:
                termbase_matches = self.find_termbase_matches_in_source(source_text)
            
            # Get the existing source widget (ReadOnlyGridTextEditor)
            source_widget = self.table.cellWidget(row, 2)
            if not source_widget or not hasattr(source_widget, 'highlight_termbase_matches'):
                return
            
            # Apply termbase highlighting first
            if termbase_matches:
                source_widget.highlight_termbase_matches(termbase_matches)
            
            # Also highlight non-translatables (pastel yellow)
            if hasattr(self, 'nt_manager') and self.nt_manager:
                nt_matches = self.find_nt_matches_in_source(source_text)
                if nt_matches and hasattr(source_widget, 'highlight_non_translatables'):
                    source_widget.highlight_non_translatables(nt_matches)
            
        except Exception as e:
            self.log(f"Error highlighting termbase matches: {e}")
            import traceback
            self.log(f"Traceback: {traceback.format_exc()}")
    
    def _apply_proactive_highlighting(self, segment_id: int, termbase_matches_json: str):
        """
        Apply termbase highlighting proactively to a segment that was prefetched.
        Called on main thread via signal from prefetch worker.
        
        This enables "see-ahead" highlighting: while you're working on segment N,
        segments N+1, N+2, N+3 already show their glossary matches highlighted.
        
        Args:
            segment_id: The segment ID to highlight
            termbase_matches_json: JSON-encoded termbase matches dict (thread-safe transfer)
        """
        import json

        if not self.current_project or not self.table:
            return

        try:
            # Decode the matches from JSON
            termbase_matches = json.loads(termbase_matches_json) if termbase_matches_json else {}

            if not termbase_matches:
                return  # Nothing to highlight

            # Find the row for this segment ID
            row = -1
            for r in range(self.table.rowCount()):
                id_item = self.table.item(r, 0)
                if id_item:
                    try:
                        row_seg_id = int(id_item.text())
                        if row_seg_id == segment_id:
                            row = r
                            break
                    except ValueError:
                        continue

            if row < 0:
                return  # Segment not visible in current page

            # Get segment source text
            segment = None
            for seg in self.current_project.segments:
                if seg.id == segment_id:
                    segment = seg
                    break

            if not segment:
                return

            # Apply highlighting (this updates the source cell widget)
            self.highlight_source_with_termbase(row, segment.source, termbase_matches)

        except Exception:
            pass  # Silent failure for proactive highlighting
    
    def insert_term_translation(self, row: int, translation: str):
        """
        Double-click handler: insert termbase translation into target cell
        """
        if not self.table or row < 0 or row >= len(self.current_project.segments):
            return
        
        try:
            # Get the target cell
            target_item = self.table.item(row, 3)
            if not target_item:
                return
            
            # Insert translation (using cell widget)
            segment = self.current_project.segments[row]
            segment.target = translation
            target_widget = self.table.cellWidget(row, 3)
            if target_widget and isinstance(target_widget, EditableGridTextEditor):
                target_widget.setPlainText(translation)
            
            # Update status
            if segment.status in (DEFAULT_STATUS.key, 'pretranslated', 'rejected'):
                segment.status = 'translated'
                self.update_status_icon(row, 'translated')
            else:
                self._refresh_segment_status(segment)
            
            self.project_modified = True
            self.update_window_title()
            self.log(f"‚úì Term translation inserted in segment {row + 1}")
            
        except Exception as e:
            self.log(f"Error inserting term translation: {e}")
    
    # ========================================================================
    # NAVIGATION & SEARCH
    # ========================================================================
    
    def show_find_replace_dialog(self):
        """Show unified Find & Replace dialog (Ctrl+F and Ctrl+H both open same dialog)
        Features:
        - History dropdowns for recent search/replace terms (last 20)
        - F&R Sets panel for batch operations
        - Pre-fills selected text from source (Find) or target (Replace)
        - Filters grid to show only matching segments
        """
        if not self.current_project or not self.current_project.segments:
            QMessageBox.information(self, "No Project", "Please open a project first.")
            return
        
        from PyQt6.QtWidgets import QCheckBox, QGroupBox, QToolButton, QFrame, QSplitter
        
        # Get selected text from source or target cells to pre-fill the Find field
        # Selected text always goes to Find What, never to Replace With
        prefill_find = ""
        
        current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
        if current_row >= 0:
            # Check target cell first (most common case - user is editing target)
            target_widget = self.table.cellWidget(current_row, 3)
            if target_widget and hasattr(target_widget, 'textCursor'):
                target_selection = target_widget.textCursor().selectedText().strip()
                if target_selection:
                    prefill_find = target_selection
                    self.log(f"üîç Pre-filling Find with target selection: '{target_selection}'")
            
            # If no target selection, check source cell
            if not prefill_find:
                source_widget = self.table.cellWidget(current_row, 2)
                if source_widget and hasattr(source_widget, 'textCursor'):
                    source_selection = source_widget.textCursor().selectedText().strip()
                    if source_selection:
                        prefill_find = source_selection
                        self.log(f"üîç Pre-filling Find with source selection: '{source_selection}'")
        
        # Disable background lookups while find/replace is active
        self.find_replace_active = True
        self.log("üîç Find/Replace active - background lookups disabled")
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Find and Replace")
        dialog.setMinimumWidth(700)
        
        # Re-enable lookups when dialog closes
        def on_dialog_closed():
            self.find_replace_active = False
            self.log("‚úì Find/Replace closed - background lookups re-enabled")
        
        dialog.finished.connect(on_dialog_closed)
        
        # Main vertical layout 
        main_v_layout = QVBoxLayout(dialog)
        main_v_layout.setSpacing(8)
        
        # Row 1: Find what (with history dropdown)
        find_layout = QHBoxLayout()
        find_label = QLabel("Find what:")
        find_label.setFixedWidth(75)
        find_layout.addWidget(find_label)
        self.find_input = HistoryComboBox()
        self.find_input.set_history(self.fr_history.find_history)
        self.find_input.setText(prefill_find)
        find_layout.addWidget(self.find_input, stretch=1)
        main_v_layout.addLayout(find_layout)
        
        # Row 2: Replace with (with history dropdown)
        replace_layout = QHBoxLayout()
        replace_label = QLabel("Replace with:")
        replace_label.setFixedWidth(75)
        replace_layout.addWidget(replace_label)
        self.replace_input = HistoryComboBox()
        self.replace_input.set_history(self.fr_history.replace_history)
        # Replace field always starts empty - user fills in what they want to replace with
        replace_layout.addWidget(self.replace_input, stretch=1)
        main_v_layout.addLayout(replace_layout)
        
        # Row 3: Options - all inline in one horizontal row
        options_layout = QHBoxLayout()
        options_layout.setSpacing(15)
        
        # Search in label + checkboxes
        options_layout.addWidget(QLabel("Search in:"))
        self.search_source_cb = CheckmarkCheckBox("Source")
        self.search_target_cb = CheckmarkCheckBox("Target")
        self.search_target_cb.setChecked(True)  # Default to target
        options_layout.addWidget(self.search_source_cb)
        options_layout.addWidget(self.search_target_cb)
        
        # Separator
        sep1 = QFrame()
        sep1.setFrameShape(QFrame.Shape.VLine)
        sep1.setFrameShadow(QFrame.Shadow.Sunken)
        options_layout.addWidget(sep1)
        
        # Match label + radio buttons
        options_layout.addWidget(QLabel("Match:"))
        self.match_group = QButtonGroup(dialog)
        match_anything = CheckmarkRadioButton("Anything")
        match_anything.setChecked(True)
        match_whole_words = CheckmarkRadioButton("Whole words")
        match_entire = CheckmarkRadioButton("Entire segment")
        
        self.match_group.addButton(match_anything, 0)
        self.match_group.addButton(match_whole_words, 1)
        self.match_group.addButton(match_entire, 2)
        
        options_layout.addWidget(match_anything)
        options_layout.addWidget(match_whole_words)
        options_layout.addWidget(match_entire)
        
        # Separator
        sep2 = QFrame()
        sep2.setFrameShape(QFrame.Shape.VLine)
        sep2.setFrameShadow(QFrame.Shadow.Sunken)
        options_layout.addWidget(sep2)
        
        # Case sensitive checkbox
        self.case_sensitive_cb = CheckmarkCheckBox("Case sensitive")
        options_layout.addWidget(self.case_sensitive_cb)
        
        options_layout.addStretch()
        main_v_layout.addLayout(options_layout)
        
        # Row 4: Action buttons - horizontal row
        buttons_layout = QHBoxLayout()
        buttons_layout.setSpacing(8)
        
        find_next_btn = QPushButton("Find next")
        find_next_btn.clicked.connect(lambda: self._fr_find_next())
        buttons_layout.addWidget(find_next_btn)
        
        find_all_btn = QPushButton("Find all")
        find_all_btn.clicked.connect(lambda: self._fr_find_all())
        buttons_layout.addWidget(find_all_btn)
        
        replace_this_btn = QPushButton("Replace this")
        replace_this_btn.clicked.connect(lambda: self.replace_current_match())
        buttons_layout.addWidget(replace_this_btn)
        
        replace_all_btn = QPushButton("Replace all")
        replace_all_btn.clicked.connect(lambda: self._fr_replace_all())
        buttons_layout.addWidget(replace_all_btn)
        
        highlight_all_btn = QPushButton("Highlight all")
        highlight_all_btn.clicked.connect(lambda: self.highlight_all_matches())
        buttons_layout.addWidget(highlight_all_btn)
        
        clear_highlight_btn = QPushButton("Clear highlights")
        clear_highlight_btn.clicked.connect(lambda: self.clear_search_highlights())
        buttons_layout.addWidget(clear_highlight_btn)
        
        buttons_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.close)
        buttons_layout.addWidget(close_btn)
        
        main_v_layout.addLayout(buttons_layout)
        
        # Horizontal separator line
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        main_v_layout.addWidget(separator)
        
        # F&R Sets collapsible panel
        fr_sets_frame = QFrame()
        fr_sets_layout = QVBoxLayout(fr_sets_frame)
        fr_sets_layout.setContentsMargins(0, 5, 0, 0)
        
        # Toggle button for collapsible panel
        toggle_layout = QHBoxLayout()
        self.fr_sets_toggle = QToolButton()
        self.fr_sets_toggle.setArrowType(Qt.ArrowType.RightArrow)
        self.fr_sets_toggle.setCheckable(True)
        self.fr_sets_toggle.setText("  F&R Sets: Save and Run Multiple Find and Replace Operations")
        self.fr_sets_toggle.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextBesideIcon)
        self.fr_sets_toggle.setStyleSheet("QToolButton { font-weight: bold; border: none; }")
        toggle_layout.addWidget(self.fr_sets_toggle)
        
        # Add Current to Set button (always visible)
        add_to_set_btn = QPushButton("+ Add Current to Set")
        add_to_set_btn.setToolTip("Add current Find/Replace to the selected set")
        add_to_set_btn.clicked.connect(lambda: self._fr_add_to_set())
        toggle_layout.addWidget(add_to_set_btn)
        
        toggle_layout.addStretch()
        fr_sets_layout.addLayout(toggle_layout)
        
        # F&R Sets Manager widget (collapsible content)
        self.fr_sets_manager = FindReplaceSetsManager(str(self.user_data_path), parent=dialog)
        self.fr_sets_manager.setVisible(False)  # Collapsed by default
        self.fr_sets_manager.operation_selected.connect(self._fr_load_operation)
        self.fr_sets_manager.set_selected.connect(self._fr_run_set_batch)
        fr_sets_layout.addWidget(self.fr_sets_manager)
        
        # Toggle visibility
        def toggle_sets_panel(checked):
            self.fr_sets_manager.setVisible(checked)
            self.fr_sets_toggle.setArrowType(
                Qt.ArrowType.DownArrow if checked else Qt.ArrowType.RightArrow
            )
            # Resize dialog to fit content
            if checked:
                dialog.setMinimumHeight(500)
            else:
                dialog.setMinimumHeight(0)
                dialog.adjustSize()
        
        self.fr_sets_toggle.toggled.connect(toggle_sets_panel)
        
        main_v_layout.addWidget(fr_sets_frame)
        
        # Store dialog reference and show
        self.find_replace_dialog = dialog
        self.current_match_index = -1
        self.find_matches = []
        
        dialog.show()
    
    def _fr_find_next(self):
        """Wrapper for find_next_match that saves to history."""
        find_text = self.find_input.text()
        if find_text:
            self.fr_history.add_find(find_text)
            self.find_input.set_history(self.fr_history.find_history)
        self.find_next_match()
    
    def _fr_find_all(self):
        """Wrapper for find_all_matches that saves to history."""
        find_text = self.find_input.text()
        if find_text:
            self.fr_history.add_find(find_text)
            self.find_input.set_history(self.fr_history.find_history)
        self.find_all_matches()
    
    def _fr_replace_all(self):
        """Wrapper for replace_all_matches that saves to history."""
        find_text = self.find_input.text()
        replace_text = self.replace_input.text()
        if find_text:
            self.fr_history.add_operation(find_text, replace_text)
            self.find_input.set_history(self.fr_history.find_history)
            self.replace_input.set_history(self.fr_history.replace_history)
        self.replace_all_matches()
    
    def _fr_add_to_set(self):
        """Add current Find/Replace values to the selected F&R Set."""
        find_text = self.find_input.text()
        replace_text = self.replace_input.text()
        
        if not find_text:
            QMessageBox.information(self.find_replace_dialog, "Add to Set", "Please enter a Find term first.")
            return
        
        # Build operation from current dialog settings
        search_in = "both" if (self.search_source_cb.isChecked() and self.search_target_cb.isChecked()) else (
            "source" if self.search_source_cb.isChecked() else "target"
        )
        
        op = FindReplaceOperation(
            find_text=find_text,
            replace_text=replace_text,
            search_in=search_in,
            match_mode=self.match_group.checkedId(),
            case_sensitive=self.case_sensitive_cb.isChecked(),
            enabled=True
        )
        
        self.fr_sets_manager.add_current_operation_to_set(op)
        self.log(f"‚úÖ Added F&R operation to set: '{find_text}' ‚Üí '{replace_text}'")
    
    def _fr_load_operation(self, op: FindReplaceOperation):
        """Load an operation from a set into the dialog fields."""
        self.find_input.setText(op.find_text)
        self.replace_input.setText(op.replace_text)
        
        # Set search options
        if op.search_in == "both":
            self.search_source_cb.setChecked(True)
            self.search_target_cb.setChecked(True)
        elif op.search_in == "source":
            self.search_source_cb.setChecked(True)
            self.search_target_cb.setChecked(False)
        else:  # target
            self.search_source_cb.setChecked(False)
            self.search_target_cb.setChecked(True)
        
        # Set match mode
        btn = self.match_group.button(op.match_mode)
        if btn:
            btn.setChecked(True)
        
        self.case_sensitive_cb.setChecked(op.case_sensitive)
    
    def _fr_run_set_batch(self, fr_set: FindReplaceSet):
        """Run all enabled operations in a F&R Set as a batch (optimized for speed)."""
        enabled_ops = [op for op in fr_set.operations if op.enabled and op.find_text]
        
        if not enabled_ops:
            QMessageBox.information(self.find_replace_dialog, "Run All", "No enabled operations with find text.")
            return
        
        # Confirm
        reply = QMessageBox.question(
            self.find_replace_dialog,
            "Run Batch Replace",
            f"Run {len(enabled_ops)} replace operation(s) from '{fr_set.name}'?\n\n"
            "This will replace all occurrences in target segments.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # OPTIMIZATION: Disable UI updates during batch processing
        self.table.setUpdatesEnabled(False)
        
        try:
            # Run each operation
            total_replaced = 0
            for op in enabled_ops:
                count = self._execute_single_fr_operation(op)
                total_replaced += count
                self.log(f"  '{op.find_text}' ‚Üí '{op.replace_text}': {count} replacement(s)")
            
            self.project_modified = True
            self.update_window_title()
            
        finally:
            # OPTIMIZATION: Re-enable UI updates and refresh only target column cells
            self.table.setUpdatesEnabled(True)
            # Update all target cells in-place (batch operations can affect many segments)
            for row in range(len(self.current_project.segments)):
                segment = self.current_project.segments[row]
                target_widget = self.table.cellWidget(row, 3)
                if target_widget and hasattr(target_widget, 'setPlainText'):
                    target_widget.blockSignals(True)
                    target_widget.setPlainText(segment.target)
                    target_widget.blockSignals(False)
            self.table.viewport().update()
        
        QMessageBox.information(
            self.find_replace_dialog,
            "Batch Complete",
            f"Completed {len(enabled_ops)} operation(s).\nTotal replacements: {total_replaced}"
        )
    
    def _execute_single_fr_operation(self, op: FindReplaceOperation) -> int:
        """Execute a single F&R operation on all segments (optimized). Returns replacement count."""
        import re
        count = 0
        
        # OPTIMIZATION: Pre-filter segments - only check segments that might contain the text
        # Quick case-insensitive check to skip segments that definitely don't match
        search_text_lower = op.find_text.lower() if not op.case_sensitive else None
        
        for segment in self.current_project.segments:
            texts_to_check = []
            
            # Pre-filter: skip segments that can't possibly match
            if not op.case_sensitive:
                # Quick check: does the segment contain the search text at all?
                skip_segment = True
                if op.search_in in ("source", "both") and self.allow_replace_in_source:
                    if search_text_lower in segment.source.lower():
                        skip_segment = False
                if op.search_in in ("target", "both"):
                    if search_text_lower in segment.target.lower():
                        skip_segment = False
                if skip_segment:
                    continue
            
            if op.search_in in ("source", "both") and self.allow_replace_in_source:
                texts_to_check.append(("source", segment.source))
            if op.search_in in ("target", "both"):
                texts_to_check.append(("target", segment.target))
            
            for field_name, old_text in texts_to_check:
                if op.match_mode == 2:  # Entire segment
                    if op.case_sensitive:
                        if old_text == op.find_text:
                            new_text = op.replace_text
                        else:
                            new_text = old_text
                    else:
                        if old_text.lower() == op.find_text.lower():
                            new_text = op.replace_text
                        else:
                            new_text = old_text
                elif op.match_mode == 1:  # Whole words
                    pattern = r'\b' + re.escape(op.find_text) + r'\b'
                    flags = 0 if op.case_sensitive else re.IGNORECASE
                    new_text = re.sub(pattern, op.replace_text, old_text, flags=flags)
                else:  # Anything
                    if op.case_sensitive:
                        new_text = old_text.replace(op.find_text, op.replace_text)
                    else:
                        pattern = re.escape(op.find_text)
                        new_text = re.sub(pattern, op.replace_text, old_text, flags=re.IGNORECASE)
                
                if new_text != old_text:
                    count += 1
                    if field_name == "source":
                        segment.source = new_text
                    else:
                        segment.target = new_text
        
        return count
    
    def find_next_match(self):
        """Find next occurrence of search term, filtering grid to show only matching rows"""
        find_text = self.find_input.text()
        if not find_text:
            return
        
        search_source = self.search_source_cb.isChecked()
        search_target = self.search_target_cb.isChecked()
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        # Find all matches if not already done
        if not self.find_matches:
            self.find_all_matches_internal(find_text, search_source, search_target, case_sensitive, match_mode)
            
            if self.find_matches:
                # First search - reload grid and filter rows
                self.load_segments_to_grid()
                
                # Get unique rows that have matches
                matching_rows = set(row for row, col in self.find_matches)
                
                # Hide all non-matching rows
                for row in range(len(self.current_project.segments)):
                    self.table.setRowHidden(row, row not in matching_rows)
        
        if not self.find_matches:
            QMessageBox.information(self.find_replace_dialog, "Find", "No matches found.")
            return
        
        # Move to next match
        self.current_match_index = (self.current_match_index + 1) % len(self.find_matches)
        row, col = self.find_matches[self.current_match_index]
        
        # Highlight the current match
        segment = self.current_project.segments[row]
        text = segment.source if col == 2 else segment.target
        self.highlight_search_term(row, col, text, find_text)
        
        # Navigate to the match
        self.table.setCurrentCell(row, col)
        self.table.scrollToItem(self.table.item(row, col))
        self.log(f"Match {self.current_match_index + 1} of {len(self.find_matches)}")
    
    def find_all_matches(self):
        """Find and highlight all matches, filtering grid to show only matching rows"""
        find_text = self.find_input.text()
        if not find_text:
            return
        
        search_source = self.search_source_cb.isChecked()
        search_target = self.search_target_cb.isChecked()
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        self.find_all_matches_internal(find_text, search_source, search_target, case_sensitive, match_mode)
        
        if self.find_matches:
            # First, reload grid to clear previous highlights
            self.load_segments_to_grid()
            
            # Process events to ensure grid is fully loaded
            QApplication.processEvents()
            
            # Get unique rows that have matches
            matching_rows = set(row for row, col in self.find_matches)
            
            # Hide all non-matching rows (like filter boxes do)
            for row in range(len(self.current_project.segments)):
                self.table.setRowHidden(row, row not in matching_rows)
            
            # Highlight all matches with yellow (after grid is loaded)
            for row, col in self.find_matches:
                segment = self.current_project.segments[row]
                text = segment.source if col == 2 else segment.target
                self.highlight_search_term(row, col, text, find_text)
            
            # Jump to first match
            first_row, first_col = self.find_matches[0]
            self.table.setCurrentCell(first_row, first_col)
            self.table.scrollToItem(self.table.item(first_row, first_col))
            self.current_match_index = 0
            
            self.log(f"Found {len(self.find_matches)} match(es) in {len(matching_rows)} segment(s)")
        else:
            QMessageBox.information(self.find_replace_dialog, "Find", "No matches found.")
    
    def find_all_matches_internal(self, find_text, search_source, search_target, case_sensitive, match_mode):
        """Internal method to find all matches"""
        import re
        
        self.find_matches = []
        
        for row, segment in enumerate(self.current_project.segments):
            texts_to_search = []
            if search_source:
                texts_to_search.append((segment.source, 2))
            if search_target:
                texts_to_search.append((segment.target, 3))
            
            for text, col in texts_to_search:
                if self.text_matches(text, find_text, case_sensitive, match_mode):
                    self.find_matches.append((row, col))
    
    def text_matches(self, text, find_text, case_sensitive, match_mode):
        """Check if text matches search criteria"""
        import re
        
        if match_mode == 2:  # Entire segment
            if case_sensitive:
                return text == find_text
            else:
                return text.lower() == find_text.lower()
        
        elif match_mode == 1:  # Whole words
            if case_sensitive:
                pattern = r'\b' + re.escape(find_text) + r'\b'
                return bool(re.search(pattern, text))
            else:
                pattern = r'\b' + re.escape(find_text) + r'\b'
                return bool(re.search(pattern, text, re.IGNORECASE))
        
        else:  # Anything (0)
            if case_sensitive:
                return find_text in text
            else:
                return find_text.lower() in text.lower()
    
    def highlight_search_term(self, row, col, text, find_text):
        """Highlight only the search term within the cell with yellow background.
        Uses the same system as filter highlighting - directly highlights within QTextEdit widget."""
        import re
        from PyQt6.QtGui import QTextCursor, QTextCharFormat, QColor
        
        if not text or not find_text:
            return
        
        # Get the cell widget (QTextEdit)
        widget = self.table.cellWidget(row, col)
        if not widget or not hasattr(widget, 'document'):
            return
        
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        # Clear any existing highlights first
        cursor = widget.textCursor()
        cursor.select(QTextCursor.SelectionType.Document)
        clear_format = QTextCharFormat()
        cursor.setCharFormat(clear_format)
        cursor.clearSelection()
        
        # Create yellow highlight format
        highlight_format = QTextCharFormat()
        highlight_format.setBackground(QColor("#FFFF00"))  # Yellow background
        
        # Get document text
        document = widget.document()
        cursor = QTextCursor(document)
        full_text = document.toPlainText()
        
        if match_mode == 2:  # Entire segment
            # Highlight entire text
            cursor.select(QTextCursor.SelectionType.Document)
            cursor.mergeCharFormat(highlight_format)
        elif match_mode == 1:  # Whole words
            # Find whole word matches using regex
            if case_sensitive:
                pattern = r'\b' + re.escape(find_text) + r'\b'
                matches = re.finditer(pattern, full_text)
            else:
                pattern = r'\b' + re.escape(find_text) + r'\b'
                matches = re.finditer(pattern, full_text, re.IGNORECASE)
            
            for match in matches:
                cursor.setPosition(match.start())
                cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, len(match.group()))
                cursor.mergeCharFormat(highlight_format)
        else:  # Anything (0)
            # Find all occurrences
            if case_sensitive:
                search_text = find_text
                text_to_search = full_text
            else:
                search_text = find_text.lower()
                text_to_search = full_text.lower()
            
            pos = 0
            while True:
                pos = text_to_search.find(search_text, pos)
                if pos == -1:
                    break
                
                cursor.setPosition(pos)
                cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, len(find_text))
                cursor.mergeCharFormat(highlight_format)
                pos += len(find_text)
    
    def replace_current_match(self):
        """Replace the currently selected match"""
        if self.current_match_index < 0 or self.current_match_index >= len(self.find_matches):
            QMessageBox.information(self.find_replace_dialog, "Replace", "No match selected. Use 'Find next' first.")
            return
        
        find_text = self.find_input.text()
        replace_text = self.replace_input.text()
        row, col = self.find_matches[self.current_match_index]
        
        # Safety check: prevent replacing in source if disabled
        if col == 2 and not self.allow_replace_in_source:  # Source column
            QMessageBox.warning(
                self.find_replace_dialog,
                "Replace in Source Disabled",
                "Replacing in source text is disabled for safety.\n\n"
                "To enable this feature, go to Settings > General and check 'Allow Replace in Source Text'."
            )
            return
        
        segment = self.current_project.segments[row]
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        # Determine which field to update
        if col == 2:  # Source column
            field_text = segment.source
        else:  # col == 3, Target column
            field_text = segment.target
        
        if match_mode == 2:  # Entire segment
            new_text = replace_text
        else:
            # Replace using the appropriate method
            if case_sensitive:
                new_text = field_text.replace(find_text, replace_text, 1)
            else:
                import re
                pattern = re.escape(find_text)
                new_text = re.sub(pattern, replace_text, field_text, count=1, flags=re.IGNORECASE)
        
        # Update the appropriate field
        if col == 2:
            segment.source = new_text
        else:
            segment.target = new_text
        
        # Update table
        item = self.table.item(row, col)
        if item:
            item.setText(segment.target)
        
        self.project_modified = True
        self.update_window_title()
        
        # Refresh matches
        self.find_matches = []
        self.find_next_match()
    
    def replace_all_matches(self):
        """Replace all matches in target segments (optimized for speed)"""
        find_text = self.find_input.text()
        replace_text = self.replace_input.text()
        
        if not find_text:
            return
        
        search_source = self.search_source_cb.isChecked()
        search_target = self.search_target_cb.isChecked()
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        # Safety check: warn if trying to replace in source when disabled
        if search_source and not self.allow_replace_in_source:
            reply = QMessageBox.warning(
                self.find_replace_dialog,
                "Replace in Source Disabled",
                "Replacing in source text is disabled for safety.\n\n"
                "Only target text will be replaced.\n\n"
                "To enable replacing in source, go to Settings > General and check 'Allow Replace in Source Text'.",
                QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel
            )
            if reply == QMessageBox.StandardButton.Cancel:
                return
            # Continue with target only
            search_source = False
            if not search_target:
                return
        
        # Find all matches
        self.find_all_matches_internal(find_text, search_source, search_target, case_sensitive, match_mode)
        
        if not self.find_matches:
            QMessageBox.information(self.find_replace_dialog, "Replace All", "No matches found.")
            return
        
        # Count matches by column
        source_count = sum(1 for _, col in self.find_matches if col == 2)
        target_count = sum(1 for _, col in self.find_matches if col == 3)
        
        # Filter out source matches if not allowed
        if not self.allow_replace_in_source:
            self.find_matches = [(row, col) for row, col in self.find_matches if col == 3]
            if not self.find_matches:
                QMessageBox.information(self.find_replace_dialog, "Replace All", "No matches found in Target column.")
                return
        
        # Build confirmation message
        msg_parts = []
        if source_count > 0 and self.allow_replace_in_source:
            msg_parts.append(f"{source_count} in source")
        if target_count > 0:
            msg_parts.append(f"{target_count} in target")
        
        confirmation_msg = f"Replace {len(self.find_matches)} occurrence(s) of '{find_text}' with '{replace_text}'?\n\n"
        if msg_parts:
            confirmation_msg += f"({', '.join(msg_parts)})"
        
        # Extra warning if replacing in source
        if source_count > 0 and self.allow_replace_in_source:
            confirmation_msg += "\n\n‚ö†Ô∏è WARNING: This will modify source text!"
        
        # Confirm
        reply = QMessageBox.question(
            self.find_replace_dialog,
            "Replace All",
            confirmation_msg,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # OPTIMIZATION: Disable UI updates during batch replacement
        self.table.setUpdatesEnabled(False)
        
        try:
            # Perform replacements
            import re
            replaced_count = 0
            updated_rows = set()  # Track which rows need UI updates
            
            for row, col in self.find_matches:
                segment = self.current_project.segments[row]
                
                # Get the appropriate field
                if col == 2:  # Source
                    old_text = segment.source
                else:  # col == 3, Target
                    old_text = segment.target
                
                # Perform replacement
                if match_mode == 2:  # Entire segment
                    new_text = replace_text
                else:
                    if case_sensitive:
                        new_text = old_text.replace(find_text, replace_text)
                    else:
                        pattern = re.escape(find_text)
                        new_text = re.sub(pattern, replace_text, old_text, flags=re.IGNORECASE)
                
                if new_text != old_text:
                    replaced_count += 1
                    updated_rows.add(row)
                    
                    # Update the appropriate field
                    if col == 2:
                        segment.source = new_text
                    else:
                        old_target = segment.target
                        old_status = segment.status
                        segment.target = new_text
                        # Record undo state for find/replace operation
                        self.record_undo_state(segment.id, old_target, new_text, old_status, old_status)
                    
                    # OPTIMIZATION: Update only the affected cell widget in-place
                    cell_widget = self.table.cellWidget(row, col)
                    if cell_widget and hasattr(cell_widget, 'setPlainText'):
                        cell_widget.blockSignals(True)
                        cell_widget.setPlainText(new_text)
                        cell_widget.blockSignals(False)
            
            self.project_modified = True
            self.update_window_title()
            
            # Clear matches
            self.find_matches = []
            
        finally:
            # OPTIMIZATION: Re-enable UI updates without full grid reload
            self.table.setUpdatesEnabled(True)
            # Trigger a repaint of updated rows only
            for row in updated_rows:
                self.table.viewport().update()
        
        QMessageBox.information(self.find_replace_dialog, "Replace All", f"Replaced {replaced_count} occurrence(s).")
        self.log(f"‚úì Replaced {replaced_count} occurrence(s) of '{find_text}'")
    
    def highlight_all_matches(self):
        """Highlight all matches in the grid (without filtering rows)"""
        find_text = self.find_input.text()
        if not find_text:
            return
        
        search_source = self.search_source_cb.isChecked()
        search_target = self.search_target_cb.isChecked()
        case_sensitive = self.case_sensitive_cb.isChecked()
        match_mode = self.match_group.checkedId()
        
        # Find all matches first
        self.find_all_matches_internal(find_text, search_source, search_target, case_sensitive, match_mode)
        
        if self.find_matches:
            # Highlight all matches with yellow (without hiding rows)
            for row, col in self.find_matches:
                segment = self.current_project.segments[row]
                text = segment.source if col == 2 else segment.target
                self.highlight_search_term(row, col, text, find_text)
            
            self.log(f"Highlighted {len(self.find_matches)} match(es)")
        else:
            QMessageBox.information(self.find_replace_dialog, "Highlight All", "No matches found.")
    
    def clear_search_highlights(self):
        """Clear all search highlights and unhide all rows (for Find & Replace dialog)"""
        self.load_segments_to_grid()
        
        # Unhide all rows
        for row in range(self.table.rowCount()):
            self.table.setRowHidden(row, False)
        
        self.find_matches = []
        self.current_match_index = -1
        self.log("Search highlights cleared")
    
    def force_refresh_matches(self):
        """Force refresh all glossary and TM matches for current segment (F5)
        
        Clears all caches and performs a fresh search on:
        - All connected glossaries/termbases
        - All translation memories
        """
        if not self.current_project:
            self.statusBar().showMessage("No project open", 3000)
            return
        
        # Get current segment
        current_row = self.table.currentRow()
        if current_row < 0:
            self.statusBar().showMessage("No segment selected", 3000)
            return
        
        # Get segment ID from the grid cell
        id_item = self.table.item(current_row, 0)
        if not id_item:
            self.statusBar().showMessage("Could not find segment", 3000)
            return
        
        try:
            segment_id = int(id_item.text())
        except (ValueError, AttributeError):
            self.statusBar().showMessage("Invalid segment ID", 3000)
            return
        
        # Find the segment
        segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
        if not segment:
            self.statusBar().showMessage(f"Segment {segment_id} not found", 3000)
            return
        
        self.log(f"üîÑ Force refresh: Clearing all caches for segment {segment_id}...")
        
        # 1. Clear termbase cache for this segment (and all segments to be safe)
        with self.termbase_cache_lock:
            self.termbase_cache.clear()
            self.log("   ‚úì Termbase cache cleared")
        
        # 2. Clear translation matches cache for this segment
        with self.translation_matches_cache_lock:
            if segment_id in self.translation_matches_cache:
                del self.translation_matches_cache[segment_id]
            self.log("   ‚úì Translation matches cache cleared for this segment")
        
        # 3. Force fresh termbase search
        self.log("   üîç Searching termbases...")
        termbase_matches = self.find_termbase_matches_in_source(segment.source)
        tb_count = len(termbase_matches) if termbase_matches else 0
        self.log(f"   ‚úì Found {tb_count} termbase matches")
        
        # 4. Force fresh TM search
        self.log("   üîç Searching translation memories...")
        tm_matches = []
        if hasattr(self, 'tm_manager') and self.tm_manager:
            try:
                # Get enabled TMs
                tm_settings = getattr(self.current_project, 'tm_settings', {})
                enabled_tms = tm_settings.get('tms', [])
                activated_tm_ids = [tm['tm_id'] for tm in enabled_tms if tm.get('read', False)]
                
                if activated_tm_ids:
                    source_lang = self.current_project.source_lang if self.current_project else None
                    target_lang = self.current_project.target_lang if self.current_project else None
                    
                    tm_matches = self.tm_manager.search_fuzzy(
                        segment.source,
                        source_lang=source_lang,
                        target_lang=target_lang,
                        tm_ids=activated_tm_ids,
                        max_results=self.general_settings.get('match_limit_TM', 10),
                        min_similarity=0.3
                    )
            except Exception as e:
                self.log(f"   ‚ö†Ô∏è TM search error: {e}")
        
        tm_count = len(tm_matches) if tm_matches else 0
        self.log(f"   ‚úì Found {tm_count} TM matches")
        
        # 5. Get NT matches (fresh)
        nt_matches = self.find_nt_matches_in_source(segment.source)
        nt_count = len(nt_matches) if nt_matches else 0
        
        # 6. Update TermView with fresh results
        if hasattr(self, 'termview_widget') and self.termview_widget:
            try:
                # Convert termbase matches dict to list format for termview
                tb_list = []
                for term_id, match_info in termbase_matches.items():
                    tb_list.append({
                        'source_term': match_info.get('source', ''),
                        'target_term': match_info.get('translation', ''),
                        'termbase_name': match_info.get('termbase_name', ''),
                        'ranking': match_info.get('ranking', 99),
                        'is_project_termbase': match_info.get('is_project_termbase', False),
                        'target_synonyms': match_info.get('target_synonyms', []),
                        'term_id': term_id,
                        'termbase_id': match_info.get('termbase_id'),
                        'notes': match_info.get('notes', '')
                    })
                # Get status hint for termbase activation
                status_hint = self._get_termbase_status_hint()

                # Update both Termview widgets
                self._update_both_termviews(segment.source, tb_list, nt_matches, status_hint)
                self.log("   ‚úì TermView updated")
            except Exception as e:
                self.log(f"   ‚ö†Ô∏è TermView update error: {e}")
        
        # 7. Update Translation Results panel with fresh results
        if hasattr(self, 'results_panels'):
            from modules.translation_results_panel import TranslationMatch
            
            # Build matches dict for panel
            matches = {
                "TM": [],
                "Termbases": [],
                "MT": [],
                "LLM": []
            }
            
            # Add TM matches
            for tm_match in tm_matches:
                matches["TM"].append(TranslationMatch(
                    source=tm_match.get('source', ''),
                    target=tm_match.get('target', ''),
                    relevance=tm_match.get('similarity', 0) * 100,
                    match_type="TM",
                    metadata={
                        'tm_name': tm_match.get('tm_name', 'Unknown TM'),
                    }
                ))
            
            # Add termbase matches
            for term_id, match_info in termbase_matches.items():
                matches["Termbases"].append(TranslationMatch(
                    source=match_info.get('source', ''),
                    target=match_info.get('translation', ''),
                    relevance=100,  # Termbase matches are always exact
                    match_type="Termbase",
                    metadata={
                        'termbase_name': match_info.get('termbase_name', ''),
                        'ranking': match_info.get('ranking', 99),
                        'is_project_termbase': match_info.get('is_project_termbase', False),
                        'notes': match_info.get('notes', ''),
                        'term_id': term_id,
                        'termbase_id': match_info.get('termbase_id')
                    }
                ))
            
            for panel in self.results_panels:
                try:
                    panel.clear()
                    panel.set_matches(matches)
                except Exception as e:
                    self.log(f"   ‚ö†Ô∏è Panel update error: {e}")
            self.log("   ‚úì Translation Results panel updated")
        
        # 7b. Update Match Panel with TM matches (must use TranslationMatch objects for correct display)
        from modules.translation_results_panel import TranslationMatch
        tm_matches_for_panel = []
        for tm_match in tm_matches:
            tm_matches_for_panel.append(TranslationMatch(
                source=tm_match.get('source', ''),
                target=tm_match.get('target', ''),
                relevance=int(tm_match.get('similarity', 0) * 100),
                metadata={
                    'tm_name': tm_match.get('tm_name', 'TM'),
                },
                match_type='TM',
                compare_source=tm_match.get('source', ''),
                provider_code='TM'
            ))
        self.set_compare_panel_matches(segment_id, segment.source, tm_matches_for_panel, [])
        self.log("   ‚úì Match Panel updated")
        
        # 8. Re-apply termbase highlighting in the grid source cell
        try:
            source_widget = self.table.cellWidget(current_row, 2)
            if source_widget and hasattr(source_widget, 'highlight_termbase_matches'):
                source_widget.highlight_termbase_matches(termbase_matches)
                self.log("   ‚úì Grid highlighting updated")
            else:
                self.log("   ‚ö†Ô∏è Could not find source widget for highlighting")
        except Exception as e:
            self.log(f"   ‚ö†Ô∏è Highlighting error: {e}")
        
        # Show status
        total_matches = tb_count + tm_count + nt_count
        self.statusBar().showMessage(f"üîÑ Refreshed: {tb_count} glossary, {tm_count} TM, {nt_count} NT matches", 5000)
        self.log(f"üîÑ Force refresh complete: {total_matches} total matches for segment {segment_id}")

    def show_goto_dialog(self):
        """Show minimal dialog to jump to a specific segment - just type and press Enter"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.information(self, "No Project", "Please open a project first.")
            return
        
        max_segment = len(self.current_project.segments)
        
        # Create a minimal dialog
        from PyQt6.QtWidgets import QDialog, QLineEdit, QHBoxLayout
        from PyQt6.QtCore import Qt
        from PyQt6.QtGui import QIntValidator
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Go to Segment")
        dialog.setFixedWidth(250)
        dialog.setWindowFlags(dialog.windowFlags() & ~Qt.WindowType.WindowContextHelpButtonHint)
        
        layout = QHBoxLayout(dialog)
        layout.setContentsMargins(12, 12, 12, 12)
        
        label = QLabel(f"Segment (1-{max_segment}):")
        layout.addWidget(label)
        
        input_field = QLineEdit()
        input_field.setValidator(QIntValidator(1, max_segment))
        input_field.setPlaceholderText(str(self.table.currentRow() + 1))
        input_field.setFixedWidth(80)
        input_field.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(input_field)
        
        # Store reference for the handler
        self._goto_dialog = dialog
        self._goto_input = input_field
        self._goto_max = max_segment
        
        # Press Enter to jump directly
        def on_return_pressed():
            text = self._goto_input.text().strip()
            if text:
                try:
                    segment_num = int(text)
                    if 1 <= segment_num <= self._goto_max:
                        self._goto_dialog.accept()
                except ValueError:
                    pass
        
        input_field.returnPressed.connect(on_return_pressed)
        
        # Focus the input field
        input_field.setFocus()
        
        # Show dialog and handle result
        if dialog.exec() == QDialog.DialogCode.Accepted:
            text = input_field.text().strip()
            if text:
                try:
                    segment_num = int(text)
                    row = segment_num - 1
                    
                    # If pagination is active, switch to the correct page first
                    if hasattr(self, 'page_size_combo') and self.page_size_combo.currentText() != "All":
                        page_size = int(self.page_size_combo.currentText())
                        target_page = (row // page_size) + 1
                        # Set the page input and trigger navigation
                        if hasattr(self, 'page_number_input'):
                            self.page_number_input.setText(str(target_page))
                            self.go_to_page()
                    
                    # Select the cell
                    self.table.setCurrentCell(row, 3)  # Jump to Target column
                    self.table.scrollToItem(self.table.item(row, 0), QTableWidget.ScrollHint.PositionAtCenter)
                    
                    # Focus the target cell widget and place cursor inside
                    target_widget = self.table.cellWidget(row, 3)
                    if target_widget and isinstance(target_widget, QTextEdit):
                        target_widget.setFocus()
                        cursor = target_widget.textCursor()
                        cursor.movePosition(cursor.MoveOperation.End)
                        target_widget.setTextCursor(cursor)
                    
                    self.log(f"Jumped to segment {segment_num}")
                except ValueError:
                    pass
    
    def show_project_info_dialog(self):
        """Show comprehensive project information dialog"""
        if not self.current_project:
            QMessageBox.information(self, "No Project", "Please open or create a project first.")
            return
        
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QGroupBox, QScrollArea, QFrame
        from PyQt6.QtCore import Qt
        from datetime import datetime
        
        proj = self.current_project
        
        # Calculate statistics
        total_segments = len(proj.segments) if proj.segments else 0
        translated = sum(1 for s in proj.segments if s.target and s.target.strip()) if proj.segments else 0
        confirmed = sum(1 for s in proj.segments if s.status == "Confirmed") if proj.segments else 0
        draft = sum(1 for s in proj.segments if s.status == "Translated") if proj.segments else 0
        not_started = sum(1 for s in proj.segments if s.status in ("Not Started", "")) if proj.segments else 0
        
        # Word counts
        source_words = sum(len(s.source.split()) for s in proj.segments if s.source) if proj.segments else 0
        target_words = sum(len(s.target.split()) for s in proj.segments if s.target) if proj.segments else 0
        
        # Character counts
        source_chars = sum(len(s.source) for s in proj.segments if s.source) if proj.segments else 0
        target_chars = sum(len(s.target) for s in proj.segments if s.target) if proj.segments else 0
        
        dialog = QDialog(self)
        dialog.setWindowTitle("üìã Project Information")
        dialog.resize(700, 750)  # Start with a good default size
        dialog.setMinimumWidth(600)
        dialog.setMinimumHeight(600)
        
        main_layout = QVBoxLayout(dialog)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 20)
        
        # Scrollable content
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.NoFrame)
        
        content = QWidget()
        layout = QVBoxLayout(content)
        layout.setSpacing(12)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Project Overview ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        overview_group = QGroupBox("üìã Project Overview")
        overview_layout = QVBoxLayout(overview_group)
        
        # Project name and file
        overview_layout.addWidget(QLabel(f"<b>Name:</b> {proj.name}"))
        if hasattr(self, 'current_project_path') and self.current_project_path:
            overview_layout.addWidget(QLabel(f"<b>File:</b> <span style='color: #666;'>{self.current_project_path}</span>"))
        
        # Languages
        overview_layout.addWidget(QLabel(f"<b>Languages:</b> {proj.source_lang} ‚Üí {proj.target_lang}"))
        
        # Dates
        try:
            created_dt = datetime.fromisoformat(proj.created) if proj.created else None
            created_str = created_dt.strftime("%Y-%m-%d %H:%M") if created_dt else "Unknown"
        except:
            created_str = proj.created or "Unknown"
        
        try:
            modified_dt = datetime.fromisoformat(proj.modified) if proj.modified else None
            modified_str = modified_dt.strftime("%Y-%m-%d %H:%M") if modified_dt else "Unknown"
        except:
            modified_str = proj.modified or "Unknown"
        
        overview_layout.addWidget(QLabel(f"<b>Created:</b> {created_str}"))
        overview_layout.addWidget(QLabel(f"<b>Modified:</b> {modified_str}"))
        
        if proj.id:
            overview_layout.addWidget(QLabel(f"<b>Project ID:</b> <span style='color: #999;'>{proj.id}</span>"))
        
        layout.addWidget(overview_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Statistics ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        stats_group = QGroupBox("üìä Statistics")
        stats_main_layout = QHBoxLayout(stats_group)
        
        # Left column: Segment counts
        left_col = QVBoxLayout()
        progress_pct = (translated / total_segments * 100) if total_segments > 0 else 0
        left_col.addWidget(QLabel(f"<b>Total Segments:</b> {total_segments:,}"))
        left_col.addWidget(QLabel(f"<b>Translated:</b> {translated:,} ({progress_pct:.1f}%)"))
        left_col.addWidget(QLabel(f"<b>Confirmed:</b> {confirmed:,}"))
        left_col.addWidget(QLabel(f"<b>Draft:</b> {draft:,}"))
        left_col.addWidget(QLabel(f"<b>Not Started:</b> {not_started:,}"))
        left_col.addStretch()
        
        # Right column: Word/Character counts
        right_col = QVBoxLayout()
        right_col.addWidget(QLabel(f"<b>Source Words:</b> {source_words:,}"))
        right_col.addWidget(QLabel(f"<b>Target Words:</b> {target_words:,}"))
        right_col.addWidget(QLabel(f"<b>Source Characters:</b> {source_chars:,}"))
        right_col.addWidget(QLabel(f"<b>Target Characters:</b> {target_chars:,}"))
        right_col.addStretch()
        
        stats_main_layout.addLayout(left_col)
        stats_main_layout.addLayout(right_col)
        
        layout.addWidget(stats_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Source Files ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        has_sources = any([
            proj.original_docx_path, proj.memoq_source_path, proj.cafetran_source_path,
            proj.trados_source_path, proj.sdlppx_source_path, proj.original_txt_path,
            proj.is_multifile
        ])
        
        if has_sources:
            source_group = QGroupBox("üìÅ Source Files")
            source_layout = QVBoxLayout(source_group)
            
            if proj.is_multifile and proj.files:
                source_layout.addWidget(QLabel(f"<b>Multi-file Project:</b> {len(proj.files)} files"))
                for f in proj.files[:5]:  # Show first 5
                    source_layout.addWidget(QLabel(f"  ‚Ä¢ {f.get('name', 'Unknown')}"))
                if len(proj.files) > 5:
                    source_layout.addWidget(QLabel(f"  <i>... and {len(proj.files) - 5} more</i>"))
            else:
                if proj.original_docx_path:
                    source_layout.addWidget(QLabel(f"<b>DOCX:</b> {proj.original_docx_path}"))
                if proj.memoq_source_path:
                    source_layout.addWidget(QLabel(f"<b>memoQ:</b> {proj.memoq_source_path}"))
                if proj.cafetran_source_path:
                    source_layout.addWidget(QLabel(f"<b>CafeTran:</b> {proj.cafetran_source_path}"))
                if proj.trados_source_path:
                    source_layout.addWidget(QLabel(f"<b>Trados DOCX:</b> {proj.trados_source_path}"))
                if proj.sdlppx_source_path:
                    source_layout.addWidget(QLabel(f"<b>Trados Package:</b> {proj.sdlppx_source_path}"))
                if proj.original_txt_path:
                    source_layout.addWidget(QLabel(f"<b>Text File:</b> {proj.original_txt_path}"))
            
            layout.addWidget(source_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê AI & Prompts ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        ai_group = QGroupBox("ü§ñ AI & Prompts")
        ai_layout = QVBoxLayout(ai_group)
        
        # Primary Prompt - get from live prompt manager
        primary_prompt_text = "None"
        attached_count = 0
        if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
            library = self.prompt_manager_qt.library
            if library.active_primary_prompt_path:
                # Extract just the filename/name from path
                prompt_path = library.active_primary_prompt_path
                if prompt_path.startswith("[EXTERNAL]"):
                    import os
                    primary_prompt_text = f"üìÅ {os.path.basename(prompt_path.replace('[EXTERNAL] ', ''))}"
                else:
                    primary_prompt_text = f"‚úÖ {prompt_path}"
            attached_count = len(library.attached_prompt_paths) if library.attached_prompt_paths else 0
        
        ai_layout.addWidget(QLabel(f"<b>Custom Prompt:</b> {primary_prompt_text}"))
        if attached_count > 0:
            ai_layout.addWidget(QLabel(f"<b>Attached Prompts:</b> {attached_count}"))
        
        layout.addWidget(ai_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Translation Memories ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        tm_group = QGroupBox("üìö Translation Memories")
        tm_layout = QVBoxLayout(tm_group)
        
        # Get active TMs using tm_metadata_mgr
        active_tm_info = []
        if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr:
            try:
                all_tms = self.tm_metadata_mgr.get_all_tms()
                for tm in all_tms:
                    # Check if TM is active for this project (or global if proj.id is 0)
                    if self.tm_metadata_mgr.is_tm_active(tm['id'], proj.id):
                        active_tm_info.append((tm['name'], tm.get('entry_count', 0)))
            except Exception as e:
                self.log(f"Error getting TM info: {e}")
        
        if active_tm_info:
            for tm_name, tu_count in active_tm_info:
                tm_layout.addWidget(QLabel(f"‚úÖ <b>{tm_name}</b> ({tu_count:,} TUs)"))
        else:
            tm_layout.addWidget(QLabel("<span style='color: #999;'>No TMs activated</span>"))
        
        layout.addWidget(tm_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Glossaries ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        gloss_group = QGroupBox("üìñ Glossaries")
        gloss_layout = QVBoxLayout(gloss_group)
        
        # Get active glossaries using termbase_mgr
        active_tb_info = []
        if hasattr(self, 'termbase_mgr') and self.termbase_mgr:
            try:
                all_termbases = self.termbase_mgr.get_all_termbases()
                for tb in all_termbases:
                    # Check if termbase is active for this project
                    if self.termbase_mgr.is_termbase_active(tb['id'], proj.id):
                        active_tb_info.append((tb['name'], tb.get('term_count', 0)))
            except Exception as e:
                self.log(f"Error getting glossary info: {e}")
        
        if active_tb_info:
            for tb_name, term_count in active_tb_info:
                gloss_layout.addWidget(QLabel(f"‚úÖ <b>{tb_name}</b> ({term_count:,} terms)"))
        else:
            gloss_layout.addWidget(QLabel("<span style='color: #999;'>No glossaries activated</span>"))
        
        layout.addWidget(gloss_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Image Context ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        image_group = QGroupBox("üñºÔ∏è Image Context")
        image_layout = QVBoxLayout(image_group)
        
        # Get from live figure_context
        if hasattr(self, 'figure_context') and self.figure_context and self.figure_context.has_images():
            count = self.figure_context.get_image_count()
            folder = self.figure_context.get_folder_name() or "Unknown folder"
            image_layout.addWidget(QLabel(f"‚úÖ <b>{count} image{'s' if count != 1 else ''}</b> loaded from: {folder}"))
        else:
            image_layout.addWidget(QLabel("<span style='color: #999;'>No images loaded</span>"))
        
        layout.addWidget(image_group)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Other Settings ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        settings_group = QGroupBox("‚öôÔ∏è Other Settings")
        settings_layout = QVBoxLayout(settings_group)
        
        # Spellcheck
        if hasattr(self, 'spellcheck_manager') and self.spellcheck_manager:
            sp_enabled = self.spellcheck_manager.enabled
            sp_lang = self.spellcheck_manager._current_language or "Not set"
            sp_status = f"‚úÖ Enabled ({sp_lang})" if sp_enabled else "‚ùå Disabled"
            settings_layout.addWidget(QLabel(f"<b>Spellcheck:</b> {sp_status}"))
        else:
            settings_layout.addWidget(QLabel(f"<b>Spellcheck:</b> Not available"))
        
        layout.addWidget(settings_group)
        
        layout.addStretch()
        
        scroll.setWidget(content)
        main_layout.addWidget(scroll)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OK Button ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        ok_btn = QPushButton("OK")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(ok_btn)
        main_layout.addLayout(button_layout)
        
        dialog.exec()
    
    def show_search_dialog(self):
        """Show enhanced search dialog with source/target options"""
        if not self.current_project or not self.current_project.segments:
            QMessageBox.information(self, "No Project", "Please open a project first.")
            return
        
        from PyQt6.QtWidgets import QDialog, QLineEdit, QRadioButton, QButtonGroup, QDialogButtonBox
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Find in Segments")
        dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(dialog)
        
        # Search text input
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Search for:"))
        search_input = QLineEdit()
        search_layout.addWidget(search_input)
        layout.addLayout(search_layout)
        
        # Search scope options
        scope_label = QLabel("Search in:")
        layout.addWidget(scope_label)
        
        radio_layout = QHBoxLayout()
        search_scope_group = QButtonGroup(dialog)
        
        both_radio = CheckmarkRadioButton("Both Source and Target")
        both_radio.setChecked(True)
        source_radio = CheckmarkRadioButton("Source only")
        target_radio = CheckmarkRadioButton("Target only")
        
        search_scope_group.addButton(both_radio, 0)
        search_scope_group.addButton(source_radio, 1)
        search_scope_group.addButton(target_radio, 2)
        
        radio_layout.addWidget(both_radio)
        radio_layout.addWidget(source_radio)
        radio_layout.addWidget(target_radio)
        layout.addLayout(radio_layout)
        
        # Dialog buttons
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)
        
        # Show dialog and process
        if dialog.exec() == QDialog.DialogCode.Accepted:
            search_text = search_input.text()
            if search_text:
                scope = search_scope_group.checkedId()
                self.search_segments(search_text, scope)
    
    def search_segments(self, search_text: str, scope: int = 0):
        """Search for text in segments and highlight ONLY the exact search term
        
        Args:
            search_text: Text to search for
            scope: 0=both, 1=source only, 2=target only
        """
        if not self.current_project:
            return
        
        self._ensure_primary_filters_ready()

        # Populate filter boxes based on scope
        if scope == 0:  # Both
            self.source_filter.setText(search_text)
            self.target_filter.setText(search_text)
        elif scope == 1:  # Source only
            self.source_filter.setText(search_text)
            self.target_filter.clear()
        elif scope == 2:  # Target only
            self.source_filter.clear()
            self.target_filter.setText(search_text)
        
        # The filter boxes will trigger apply_filters() automatically
        # which handles highlighting and hiding
        
        # Find first match and jump to it
        search_lower = search_text.lower()
        for row, segment in enumerate(self.current_project.segments):
            source_match = scope != 2 and search_lower in segment.source.lower()
            target_match = scope != 1 and search_lower in segment.target.lower()
            
            if source_match or target_match:
                self.table.setCurrentCell(row, 3)
                self.table.scrollToItem(self.table.item(row, 3))
                break
    
    def _highlight_text_in_widget(self, row: int, col: int, search_term: str):
        """Highlight search term within a QTextEdit cell widget.
        
        Since source/target cells use setCellWidget() with QTextEdit editors,
        the delegate's paint() method is bypassed. We must highlight the text
        directly within the widget using QTextCursor and QTextCharFormat.
        
        NOTE: This method only ADDS yellow highlights - it does not clear existing
        formatting. Use _clear_filter_highlights_in_widget() to remove highlights.
        """
        widget = self.table.cellWidget(row, col)
        if not widget or not hasattr(widget, 'document'):
            return
        
        # Create yellow highlight format
        highlight_format = QTextCharFormat()
        highlight_format.setBackground(QColor("#FFFF00"))  # Yellow background
        
        # Find and highlight all occurrences (case-insensitive)
        document = widget.document()
        cursor = QTextCursor(document)
        
        search_term_lower = search_term.lower()
        text = document.toPlainText()
        text_lower = text.lower()
        
        # Find all occurrences
        pos = 0
        while True:
            pos = text_lower.find(search_term_lower, pos)
            if pos == -1:
                break
            
            # Select the match and apply highlight
            cursor.setPosition(pos)
            cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.KeepAnchor, len(search_term))
            cursor.mergeCharFormat(highlight_format)
            
            pos += len(search_term)
    
    def _clear_filter_highlights_in_widget(self, row: int, col: int):
        """Remove yellow filter highlights from a QTextEdit widget while preserving other formatting.
        
        This is more efficient than reloading the entire grid just to clear highlights.
        """
        widget = self.table.cellWidget(row, col)
        if not widget or not hasattr(widget, 'document'):
            return
        
        # Iterate through the document and clear only yellow backgrounds
        document = widget.document()
        cursor = QTextCursor(document)
        cursor.movePosition(QTextCursor.MoveOperation.Start)
        
        # Select the entire document
        cursor.movePosition(QTextCursor.MoveOperation.End, QTextCursor.MoveMode.KeepAnchor)
        
        # Get current block and iterate character by character
        # For efficiency, we'll just clear all backgrounds that are yellow
        # This preserves termbase highlights (which are green shades) and tag colors
        block = document.begin()
        while block.isValid():
            it = block.begin()
            while not it.atEnd():
                fragment = it.fragment()
                if fragment.isValid():
                    fmt = fragment.charFormat()
                    bg = fmt.background().color()
                    # Check if it's a yellow highlight (filter highlight)
                    if bg.name().upper() == "#FFFF00":
                        # Clear this specific range
                        cursor.setPosition(fragment.position())
                        cursor.setPosition(fragment.position() + fragment.length(), QTextCursor.MoveMode.KeepAnchor)
                        clear_fmt = QTextCharFormat()
                        clear_fmt.setBackground(QColor(Qt.GlobalColor.transparent))
                        cursor.mergeCharFormat(clear_fmt)
                it += 1
            block = block.next()
    
    def apply_filters(self):
        """Apply source and target filters to show/hide rows and highlight matches.
        
        OPTIMIZED: No longer reloads the entire grid. Instead:
        1. Clears only filter highlights (preserves termbase/tag formatting)
        2. Shows/hides rows in place
        3. Applies new highlights to matching text
        """
        if not self.current_project:
            return
        
        # Safety check: ensure table and filter widgets exist
        if not hasattr(self, 'table') or self.table is None:
            return
        has_source = self._widget_is_alive(getattr(self, 'source_filter', None))
        has_target = self._widget_is_alive(getattr(self, 'target_filter', None))
        if not has_source and not has_target:
            return

        source_filter_text = self._get_line_edit_text('source_filter').strip()
        target_filter_text = self._get_line_edit_text('target_filter').strip()
        
        # If both empty, clear everything
        if not source_filter_text and not target_filter_text:
            self.clear_filters()
            return
        
        # Set flag to disable auto-center scrolling during filtering
        self.filtering_active = True

        # Track which rows match the active text filters so pagination can respect filtering
        matching_rows: set[int] = set()
        
        # Batch UI updates for performance
        self.table.setUpdatesEnabled(False)
        
        try:
            visible_count = 0
            segments = self.current_project.segments
            total_segments = len(segments)
            
            # Pre-compute lowercase filter texts
            source_filter_lower = source_filter_text.lower() if source_filter_text else None
            target_filter_lower = target_filter_text.lower() if target_filter_text else None
            
            # IMPORTANT: Always search through ALL segments, not just visible rows
            # Pagination state should not affect which segments we search
            for row in range(total_segments):
                if row >= total_segments:
                    break
                    
                segment = segments[row]
                source_lower = segment.source.lower()
                target_lower = segment.target.lower()
                
                source_match = not source_filter_lower or source_filter_lower in source_lower
                target_match = not target_filter_lower or target_filter_lower in target_lower
                
                show_row = source_match and target_match

                if show_row:
                    matching_rows.add(row)
                
                if show_row:
                    visible_count += 1
                    
                    # Clear previous filter highlights first (only yellow, preserves other formatting)
                    self._clear_filter_highlights_in_widget(row, 2)
                    self._clear_filter_highlights_in_widget(row, 3)
                    
                    # Highlight matching terms in the QTextEdit widgets
                    if source_filter_lower and source_filter_lower in source_lower:
                        self._highlight_text_in_widget(row, 2, source_filter_text)
                    
                    if target_filter_lower and target_filter_lower in target_lower:
                        self._highlight_text_in_widget(row, 3, target_filter_text)
                else:
                    # Clear highlights from hidden rows too (for when they become visible again)
                    self._clear_filter_highlights_in_widget(row, 2)
                    self._clear_filter_highlights_in_widget(row, 3)
        finally:
            # Re-enable UI updates
            self.table.setUpdatesEnabled(True)

        # Persist allowlist and apply combined pagination+filter visibility
        self._active_text_filter_rows = matching_rows
        if hasattr(self, '_apply_pagination_to_grid'):
            self._apply_pagination_to_grid()

        # Update status
        if source_filter_text or target_filter_text:
            self.log(f"Filter applied: showing {visible_count} of {len(self.current_project.segments)} segments")

    def clear_filters(self):
        """Clear all filter boxes, highlighting, and show all rows.
        
        OPTIMIZED: No longer reloads the entire grid. Instead:
        1. Clears only yellow filter highlights (preserves termbase/tag formatting)
        2. Shows all rows in place
        3. Much faster than reloading all widgets
        """
        source_widget = getattr(self, 'source_filter', None)
        target_widget = getattr(self, 'target_filter', None)
        has_source = self._widget_is_alive(source_widget)
        has_target = self._widget_is_alive(target_widget)
        if not has_source and not has_target:
            return

        # Clear delegate highlights and global search terms
        if hasattr(self, 'table') and self.table is not None:
            delegate = self.table.itemDelegate()
            if delegate:
                if hasattr(delegate, 'clear_all_highlights'):
                    delegate.clear_all_highlights()
                # Clear global search terms
                delegate.global_search_term = None
                delegate.global_source_search_term = None

        # Remember which segment was selected before clearing
        selected_segment_id = None
        current_column = 3  # Default to target column
        if self.current_project and hasattr(self, 'table') and self.table is not None:
            current_row = self.table.currentRow()
            current_column = self.table.currentColumn()
            
            if current_row >= 0:
                # Get segment ID directly from the ID cell (column 0)
                id_item = self.table.item(current_row, 0)
                if id_item:
                    try:
                        selected_segment_id = int(id_item.text())
                    except (ValueError, AttributeError):
                        pass

        if has_source:
            source_widget.blockSignals(True)
            source_widget.clear()
            source_widget.blockSignals(False)
        else:
            self.source_filter = None

        if has_target:
            target_widget.blockSignals(True)
            target_widget.clear()
            target_widget.blockSignals(False)
        else:
            self.target_filter = None

        # Clear any active text-filter allowlist so pagination can show rows normally
        self._active_text_filter_rows = None
        
        # OPTIMIZED: Clear highlights and show rows WITHOUT reloading grid
        if self.current_project:
            # Safety check: ensure table exists
            if not hasattr(self, 'table') or self.table is None:
                return
            
            # Batch UI updates for performance
            self.table.setUpdatesEnabled(False)
            
            try:
                row_count = self.table.rowCount()
                
                for row in range(row_count):
                    # Clear yellow filter highlights (preserves other formatting)
                    self._clear_filter_highlights_in_widget(row, 2)  # Source
                    self._clear_filter_highlights_in_widget(row, 3)  # Target
                    
                    # Show all rows
                    self.table.setRowHidden(row, False)
            finally:
                # Re-enable UI updates
                self.table.setUpdatesEnabled(True)
            
            # Clear filtering flag to re-enable auto-center
            self.filtering_active = False
            
            # Re-apply pagination after clearing filters
            if hasattr(self, '_apply_pagination_to_grid'):
                self._apply_pagination_to_grid()
            
            # Restore selection to the previously selected segment
            if selected_segment_id is not None:
                for row, segment in enumerate(self.current_project.segments):
                    if segment.id == selected_segment_id:
                        self.table.setCurrentCell(row, current_column)
                        # Scroll to the row
                        self.table.scrollToItem(
                            self.table.item(row, 0), 
                            QTableWidget.ScrollHint.PositionAtCenter
                        )
                        break
        
        # Reset file filter to "All Files"
        if hasattr(self, 'file_filter_combo') and self.file_filter_combo:
            self.file_filter_combo.blockSignals(True)
            self.file_filter_combo.setCurrentIndex(0)
            self.file_filter_combo.blockSignals(False)
        
        self.log("Filters cleared")
    
    def _on_file_filter_changed(self, index):
        """Handle file filter dropdown change for multi-file projects."""
        if not self.current_project or not hasattr(self, 'file_filter_combo'):
            return
        
        file_id = self.file_filter_combo.currentData()
        
        if file_id is None:
            # "All Files" selected - show all rows
            if hasattr(self, 'table') and self.table:
                for row in range(self.table.rowCount()):
                    self.table.setRowHidden(row, False)
            self.log("File filter: showing all files")
            return
        
        # Filter to show only segments from the selected file
        if not hasattr(self, 'table') or not self.table:
            return
        
        visible_count = 0
        for row, segment in enumerate(self.current_project.segments):
            if row >= self.table.rowCount():
                break
            
            segment_file_id = getattr(segment, 'file_id', None)
            show_row = segment_file_id == file_id
            
            self.table.setRowHidden(row, not show_row)
            if show_row:
                visible_count += 1
        
        # Get file name for logging
        file_name = "Unknown"
        files = getattr(self.current_project, 'files', [])
        for f in files:
            if f['id'] == file_id:
                file_name = f['name']
                break
        
        self.log(f"File filter: showing {visible_count} segments from '{file_name}'")
    
    def _update_file_filter_combo(self):
        """Update the file filter dropdown with files from the current project."""
        if not hasattr(self, 'file_filter_combo') or not self.file_filter_combo:
            return
        
        # Clear existing items
        self.file_filter_combo.blockSignals(True)
        self.file_filter_combo.clear()
        self.file_filter_combo.addItem("üìÅ All Files", None)
        
        # Check if this is a multi-file project
        is_multifile = getattr(self.current_project, 'is_multifile', False) if self.current_project else False
        files = getattr(self.current_project, 'files', []) if self.current_project else []
        
        if is_multifile and files:
            # Add each file to the dropdown
            for file_info in files:
                file_id = file_info['id']
                file_name = file_info['name']
                seg_count = file_info.get('segment_count', 0)
                self.file_filter_combo.addItem(f"üìÑ {file_name} ({seg_count} seg)", file_id)
            
            self.file_filter_combo.show()
        else:
            self.file_filter_combo.hide()
        
        self.file_filter_combo.blockSignals(False)

    def toggle_invisible_display(self, char_type):
        """Toggle display of specific invisible character type"""
        if not hasattr(self, 'invisible_display_settings'):
            self.invisible_display_settings = {
                'spaces': False,
                'tabs': False,
                'nbsp': False,
                'linebreaks': False
            }

        # Toggle the setting
        self.invisible_display_settings[char_type] = not self.invisible_display_settings[char_type]

        # Refresh the grid to show/hide invisibles
        self.refresh_grid_invisibles()

        # Log the change
        status = "enabled" if self.invisible_display_settings[char_type] else "disabled"
        char_names = {
            'spaces': 'Spaces',
            'tabs': 'Tabs',
            'nbsp': 'Non-breaking Spaces',
            'linebreaks': 'Line Breaks'
        }
        self.log(f"Show invisibles: {char_names[char_type]} {status}")

    def toggle_all_invisibles(self):
        """Toggle all invisible characters on or off"""
        if not hasattr(self, 'invisible_display_settings'):
            self.invisible_display_settings = {
                'spaces': False,
                'tabs': False,
                'nbsp': False,
                'linebreaks': False
            }

        # Check if any are currently on
        any_on = any(self.invisible_display_settings.values())

        # Toggle all to opposite state
        new_state = not any_on
        self.invisible_display_settings = {
            'spaces': new_state,
            'tabs': new_state,
            'nbsp': new_state,
            'linebreaks': new_state
        }

        # Update menu checkboxes
        if hasattr(self, 'show_spaces_action'):
            self.show_spaces_action.setChecked(new_state)
        if hasattr(self, 'show_tabs_action'):
            self.show_tabs_action.setChecked(new_state)
        if hasattr(self, 'show_nbsp_action'):
            self.show_nbsp_action.setChecked(new_state)
        if hasattr(self, 'show_linebreaks_action'):
            self.show_linebreaks_action.setChecked(new_state)

        # Refresh the grid
        self.refresh_grid_invisibles()

        status = "enabled" if new_state else "disabled"
        self.log(f"Show invisibles: All {status}")

    def refresh_grid_invisibles(self):
        """Refresh the grid to show/hide invisible characters"""
        if not hasattr(self, 'table') or not self.table:
            return

        if not hasattr(self, 'invisible_display_settings'):
            return

        # Check if spaces are being shown (which affects word wrapping)
        self.showing_invisible_spaces = self.invisible_display_settings.get('spaces', False)

        # Simply reload the grid - the apply_invisible_replacements will be called
        # during load_segments_to_grid when creating cell widgets
        self.load_segments_to_grid()

    def apply_invisible_replacements(self, text):
        """Apply invisible character replacements to text based on settings"""
        if not hasattr(self, 'invisible_display_settings'):
            return text

        result = text

        # Replace spaces with middle dot (¬∑) followed by zero-width space for word-wrap capability
        # The zero-width space (U+200B) provides a line-break opportunity
        if self.invisible_display_settings.get('spaces', False):
            result = result.replace(' ', '¬∑\u200B')

        # Replace tabs with right arrow (‚Üí) followed by zero-width space
        if self.invisible_display_settings.get('tabs', False):
            result = result.replace('\t', '‚Üí\u200B')

        # Replace non-breaking spaces with degree symbol (¬∞)
        # Note: We don't add zero-width space here since NBSP should NOT break
        if self.invisible_display_settings.get('nbsp', False):
            result = result.replace('\u00A0', '¬∞')  # Unicode NBSP
            result = result.replace('\u202F', '¬∞')  # Narrow NBSP

        # Replace line breaks with pilcrow (¬∂)
        if self.invisible_display_settings.get('linebreaks', False):
            result = result.replace('\n', '¬∂\n')
            result = result.replace('\r', '¬∂')

        return result

    def reverse_invisible_replacements(self, text):
        """Reverse invisible character replacements to get original text"""
        if not hasattr(self, 'invisible_display_settings'):
            return text

        result = text

        # Reverse spaces (middle dot + zero-width space ‚Üí space)
        if self.invisible_display_settings.get('spaces', False):
            result = result.replace('¬∑\u200B', ' ')
            result = result.replace('¬∑', ' ')  # Fallback for any without zero-width space

        # Reverse tabs (right arrow + zero-width space ‚Üí tab)
        if self.invisible_display_settings.get('tabs', False):
            result = result.replace('‚Üí\u200B', '\t')
            result = result.replace('‚Üí', '\t')  # Fallback

        # Reverse non-breaking spaces (degree symbol ‚Üí NBSP)
        if self.invisible_display_settings.get('nbsp', False):
            # We can't distinguish between \u00A0 and \u202F after replacement,
            # so we default to the more common \u00A0
            result = result.replace('¬∞', '\u00A0')

        # Reverse line breaks (pilcrow ‚Üí line break)
        if self.invisible_display_settings.get('linebreaks', False):
            result = result.replace('¬∂\n', '\n')
            result = result.replace('¬∂', '\r')

        return result

    # ========================================================================
    # SPELLCHECK METHODS
    # ========================================================================

    def _update_spellcheck_button_style(self):
        """Update spellcheck button style based on enabled state"""
        if hasattr(self, 'spellcheck_btn'):
            if self.spellcheck_enabled:
                self.spellcheck_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
            else:
                self.spellcheck_btn.setStyleSheet("background-color: #9E9E9E; color: white; font-weight: bold;")

    def _toggle_spellcheck(self, checked=None):
        """Toggle spellcheck on/off"""
        self.spellcheck_enabled = not self.spellcheck_enabled
        TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
        
        # Update UI
        self._update_spellcheck_button_style()
        if hasattr(self, 'spellcheck_btn'):
            self.spellcheck_btn.setChecked(self.spellcheck_enabled)
        if hasattr(self, 'spellcheck_toggle_action'):
            self.spellcheck_toggle_action.setChecked(self.spellcheck_enabled)
        
        # Use project's target language if available, otherwise fall back to app preference
        spellcheck_lang = self.current_project.target_lang if self.current_project else self.target_language
        
        # Initialize spellcheck for target language if enabling
        if self.spellcheck_enabled:
            if self.spellcheck_manager.set_language(spellcheck_lang):
                self.log(f"‚úì Spellcheck enabled for {spellcheck_lang} (backend: {self.spellcheck_manager.get_backend_info()})")
            else:
                self.log(f"‚ö† Spellcheck dictionary not available for {spellcheck_lang}")
                # Disable spellcheck since we couldn't initialize
                self.spellcheck_enabled = False
                TagHighlighter.set_spellcheck_enabled(False)
                self._update_spellcheck_button_style()
                if hasattr(self, 'spellcheck_btn'):
                    self.spellcheck_btn.setChecked(False)
                if hasattr(self, 'spellcheck_toggle_action'):
                    self.spellcheck_toggle_action.setChecked(False)
                # Show warning with diagnostics
                diag = self.spellcheck_manager.get_diagnostics()
                QMessageBox.warning(
                    self, "Spellcheck Unavailable",
                    f"Could not initialize spellcheck for '{spellcheck_lang}'.\n\n"
                    f"Backends:\n"
                    f"‚Ä¢ Hunspell: {'Available' if diag['hunspell_available'] else 'Not installed'}\n"
                    f"‚Ä¢ pyspellchecker: {'Available' if diag['pyspellchecker_available'] else 'Not installed'}\n\n"
                    f"Try opening Spellcheck Info (right-click menu) for more details."
                )
        else:
            self.log("‚úó Spellcheck disabled")
        
        # Save setting
        self._save_spellcheck_settings()
        
        # Refresh grid to show/hide underlines
        self._refresh_all_highlighters()

    def _toggle_spellcheck_from_button(self, checked):
        """Handle button click (separate from menu action to avoid double-toggle)"""
        # The button click already toggles the checked state, so we need to sync
        self.spellcheck_enabled = checked
        TagHighlighter.set_spellcheck_enabled(self.spellcheck_enabled)
        
        # Update menu action
        if hasattr(self, 'spellcheck_toggle_action'):
            self.spellcheck_toggle_action.setChecked(self.spellcheck_enabled)
        
        # Same logic as _toggle_spellcheck
        self._update_spellcheck_button_style()
        
        # Use project's target language if available, otherwise fall back to app preference
        spellcheck_lang = self.current_project.target_lang if self.current_project else self.target_language
        
        if self.spellcheck_enabled:
            if self.spellcheck_manager.set_language(spellcheck_lang):
                self.log(f"‚úì Spellcheck enabled for {spellcheck_lang} (backend: {self.spellcheck_manager.get_backend_info()})")
            else:
                self.log(f"‚ö† Spellcheck could not be initialized for {spellcheck_lang}")
                # Disable spellcheck since we couldn't initialize
                self.spellcheck_enabled = False
                TagHighlighter.set_spellcheck_enabled(False)
                self._update_spellcheck_button_style()
                if hasattr(self, 'spellcheck_btn'):
                    self.spellcheck_btn.setChecked(False)
                if hasattr(self, 'spellcheck_toggle_action'):
                    self.spellcheck_toggle_action.setChecked(False)
                # Show warning
                diag = self.spellcheck_manager.get_diagnostics()
                QMessageBox.warning(
                    self, "Spellcheck Unavailable",
                    f"Could not initialize spellcheck for '{spellcheck_lang}'.\n\n"
                    f"Backends:\n"
                    f"‚Ä¢ Hunspell: {'Available' if diag['hunspell_available'] else 'Not installed'}\n"
                    f"‚Ä¢ pyspellchecker: {'Available' if diag['pyspellchecker_available'] else 'Not installed'}\n\n"
                    f"Try opening Spellcheck Info for more details."
                )
        else:
            self.log("‚úó Spellcheck disabled")
        
        self._save_spellcheck_settings()
        self._refresh_all_highlighters()

    def _save_spellcheck_settings(self):
        """Save spellcheck settings to preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        prefs['spellcheck_settings'] = {
            'enabled': self.spellcheck_enabled
        }
        
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save spellcheck settings: {e}")

    def _load_spellcheck_settings(self):
        """Load spellcheck settings from preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
                settings = prefs.get('spellcheck_settings', {})
                return settings.get('enabled', False)
            except:
                pass
        return False

    def _refresh_all_highlighters(self):
        """Refresh syntax highlighters in VISIBLE rows only (performance optimization)
        
        Instead of refreshing all 3000+ rows, we only refresh the rows currently
        visible in the viewport. This makes add-to-dictionary/ignore instant.
        Other rows will get updated when they become visible (on navigation).
        """
        if not hasattr(self, 'table') or not self.table:
            return
        
        # Get visible row range from viewport
        viewport = self.table.viewport()
        if not viewport:
            return
            
        # Find first and last visible rows
        first_visible_row = self.table.rowAt(0)
        last_visible_row = self.table.rowAt(viewport.height())
        
        # Handle edge cases
        if first_visible_row < 0:
            first_visible_row = 0
        if last_visible_row < 0 or last_visible_row >= self.table.rowCount():
            last_visible_row = self.table.rowCount() - 1
            
        # Add small buffer for smoother experience
        first_visible_row = max(0, first_visible_row - 2)
        last_visible_row = min(self.table.rowCount() - 1, last_visible_row + 2)
        
        # Only refresh visible rows
        for row in range(first_visible_row, last_visible_row + 1):
            # Target column (3) has editable text editor with spellcheck
            target_widget = self.table.cellWidget(row, 3)
            if target_widget and hasattr(target_widget, 'highlighter'):
                target_widget.highlighter.rehighlight()

    def _open_custom_dictionary_dialog(self):
        """Open dialog to manage custom dictionary words"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Custom Dictionary")
        dialog.setMinimumSize(400, 500)
        
        layout = QVBoxLayout(dialog)
        
        # Info label
        info_label = QLabel(
            "Words added to the custom dictionary will not be marked as spelling errors.\n"
            "One word per line. Changes are saved automatically."
        )
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Word list editor
        self.custom_dict_editor = QPlainTextEdit()
        self.custom_dict_editor.setPlaceholderText("Enter custom words here, one per line...")
        
        # Load current words
        words = self.spellcheck_manager.get_custom_words()
        self.custom_dict_editor.setPlainText('\n'.join(words))
        
        layout.addWidget(self.custom_dict_editor)
        
        # Word count label
        self.word_count_label = QLabel(f"{len(words)} words in dictionary")
        layout.addWidget(self.word_count_label)
        
        # Update count when text changes
        def update_word_count():
            text = self.custom_dict_editor.toPlainText()
            count = len([w for w in text.split('\n') if w.strip()])
            self.word_count_label.setText(f"{count} words in dictionary")
        
        self.custom_dict_editor.textChanged.connect(update_word_count)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        save_btn = QPushButton("üíæ Save")
        save_btn.clicked.connect(lambda: self._save_custom_dictionary(dialog))
        button_layout.addWidget(save_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_btn)
        
        layout.addLayout(button_layout)
        
        dialog.exec()

    def _save_custom_dictionary(self, dialog):
        """Save custom dictionary from dialog"""
        text = self.custom_dict_editor.toPlainText()
        words = [w.strip().lower() for w in text.split('\n') if w.strip()]
        
        # Clear and re-add all words
        current_words = self.spellcheck_manager.get_custom_words()
        for word in current_words:
            self.spellcheck_manager.remove_from_dictionary(word)
        
        for word in words:
            self.spellcheck_manager.add_to_dictionary(word)
        
        self.log(f"‚úì Custom dictionary saved with {len(words)} words")
        
        # Refresh highlighters
        self._refresh_all_highlighters()
        
        dialog.accept()

    def _show_spellcheck_info(self):
        """Show information about spellcheck configuration with clickable links"""
        backend = self.spellcheck_manager.get_backend_info()
        language = self.spellcheck_manager.get_current_language() or "Not set"
        available_languages = self.spellcheck_manager.get_available_languages()
        available = ', '.join(available_languages) or "None"
        custom_count = len(self.spellcheck_manager.get_custom_words())
        dict_path = str(self.spellcheck_manager.dictionaries_path)
        diag = self.spellcheck_manager.get_diagnostics()
        is_hunspell = "Hunspell" in backend
        
        # Create dialog with two-column horizontal layout
        dialog = QDialog(self)
        dialog.setWindowTitle("Spellcheck Info")
        dialog.setMinimumWidth(700)
        dialog.setMaximumHeight(520)
        
        main_layout = QVBoxLayout(dialog)
        main_layout.setSpacing(10)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Top Row: Status + Language + Backend ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        top_row = QHBoxLayout()
        
        status_text = "‚úì Enabled" if self.spellcheck_enabled else "‚úó Disabled"
        status_color = "green" if self.spellcheck_enabled else "red"
        status_label = QLabel(f"<b style='color: {status_color};'>{status_text}</b>")
        top_row.addWidget(status_label)
        top_row.addSpacing(20)
        
        top_row.addWidget(QLabel("Language:"))
        lang_combo = QComboBox()
        lang_combo.setMinimumWidth(100)
        lang_combo.addItems(available_languages)
        if language in available_languages:
            lang_combo.setCurrentText(language)
        top_row.addWidget(lang_combo)
        top_row.addSpacing(20)
        
        backend_icon = "üìö" if is_hunspell else "üêç"
        backend_label = QLabel(f"{backend_icon} {backend}")
        top_row.addWidget(backend_label)
        top_row.addStretch()
        main_layout.addLayout(top_row)
        
        def on_language_changed(new_lang):
            if self.spellcheck_manager.set_language(new_lang):
                self.log(f"‚úì Spellcheck language changed to: {new_lang}")
                new_backend = self.spellcheck_manager.get_backend_info()
                is_hunspell_new = "Hunspell" in new_backend
                backend_icon_new = "üìö" if is_hunspell_new else "üêç"
                backend_label.setText(f"{backend_icon_new} {new_backend}")
                if self.spellcheck_enabled:
                    self._refresh_all_highlighters()
            else:
                self.log(f"‚ö† Could not set spellcheck language to: {new_lang}")
        lang_combo.currentTextChanged.connect(on_language_changed)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Two-Column Layout ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        columns = QHBoxLayout()
        columns.setSpacing(15)
        
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ LEFT COLUMN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        left_col = QVBoxLayout()
        left_col.setSpacing(8)
        
        # How It Works - determine which backend is active
        backend_lower = backend.lower()
        is_spylls = 'spylls' in backend_lower
        is_pyspellchecker = 'pyspellchecker' in backend_lower or 'built-in' in backend_lower
        
        # How It Works
        how_group = QGroupBox("How Spellcheck Works")
        how_layout = QVBoxLayout(how_group)
        how_layout.setSpacing(4)
        
        # Build the explanation with active backend highlighted
        spylls_style = "background-color: #90EE90; padding: 2px;" if is_spylls else ""
        pyspell_style = "background-color: #90EE90; padding: 2px;" if is_pyspellchecker else ""
        hunspell_style = "background-color: #90EE90; padding: 2px;" if is_hunspell and not is_spylls else ""
        
        how_label = QLabel(
            f"<div style='{pyspell_style}'>"
            "üêç <b>Built-in (pyspellchecker)</b><br>"
            "&nbsp;&nbsp;&nbsp;EN, NL, DE, FR, ES, PT, IT, RU<br>"
            "&nbsp;&nbsp;&nbsp;<i>Works out of the box!</i></div><br>"
            f"<div style='{spylls_style}'>"
            "üìó <b>Spylls (pure Python Hunspell)</b><br>"
            "&nbsp;&nbsp;&nbsp;Bundled: EN, RU, SV<br>"
            "&nbsp;&nbsp;&nbsp;+ Any .dic/.aff files you add</div><br>"
            f"<div style='{hunspell_style}'>"
            "üìö <b>Hunspell (native C library)</b><br>"
            "&nbsp;&nbsp;&nbsp;Any language with .dic/.aff files<br>"
            "&nbsp;&nbsp;&nbsp;<i>Requires cyhunspell (Linux/Mac)</i></div><br>"
            "<b>‚ö° Auto-switching:</b> Best available backend<br>"
            "is used automatically based on dictionaries."
        )
        how_label.setWordWrap(True)
        how_layout.addWidget(how_label)
        left_col.addWidget(how_group)
        
        # Available Languages
        lang_group = QGroupBox("Available Languages")
        lang_layout = QVBoxLayout(lang_group)
        lang_list = QLabel(available)
        lang_list.setWordWrap(True)
        lang_layout.addWidget(lang_list)
        left_col.addWidget(lang_group)
        
        # Custom Dictionary
        custom_group = QGroupBox("Custom Dictionary")
        custom_layout = QVBoxLayout(custom_group)
        custom_layout.setSpacing(4)
        custom_layout.addWidget(QLabel(f"<b>{custom_count}</b> words in custom_words.txt"))
        custom_folder = str(self.spellcheck_manager.dictionaries_path)
        custom_btn = QPushButton("üìÅ Open Folder")
        custom_btn.clicked.connect(lambda: self._open_folder_in_explorer(custom_folder))
        custom_layout.addWidget(custom_btn)
        left_col.addWidget(custom_group)
        
        left_col.addStretch()
        columns.addLayout(left_col)
        
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RIGHT COLUMN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        right_col = QVBoxLayout()
        right_col.setSpacing(8)
        
        # Add More Dictionaries
        hunspell_group = QGroupBox("Add More Dictionaries")
        hunspell_layout = QVBoxLayout(hunspell_group)
        hunspell_layout.setSpacing(4)
        
        hunspell_layout.addWidget(QLabel("<b>To add more languages:</b>"))
        hunspell_layout.addWidget(QLabel("1. Download .dic + .aff files for your language"))
        hunspell_layout.addWidget(QLabel("2. Place them in the dictionaries folder"))
        hunspell_layout.addWidget(QLabel("3. Restart Supervertaler"))
        
        hunspell_layout.addWidget(QLabel(""))
        hunspell_layout.addWidget(QLabel("<b>Download sources:</b>"))
        
        memoq_label = QLabel('üåê <a href="https://hunspell.memoq.com/">hunspell.memoq.com</a> ‚Äî 70+ languages')
        memoq_label.setOpenExternalLinks(True)
        hunspell_layout.addWidget(memoq_label)
        
        github_label = QLabel('üåê <a href="https://github.com/wooorm/dictionaries/tree/main/dictionaries">GitHub: wooorm/dictionaries</a> ‚Äî 92+ languages')
        github_label.setOpenExternalLinks(True)
        hunspell_layout.addWidget(github_label)
        
        libreoffice_label = QLabel('üåê <a href="https://extensions.libreoffice.org/?Tags%5B%5D=50">LibreOffice Extensions</a> ‚Äî .oxt ‚Üí .zip')
        libreoffice_label.setOpenExternalLinks(True)
        hunspell_layout.addWidget(libreoffice_label)
        
        dict_btn = QPushButton("üìÅ Open Dictionaries Folder")
        dict_btn.clicked.connect(lambda: self._open_folder_in_explorer(dict_path))
        hunspell_layout.addWidget(dict_btn)
        
        # Note about Spylls bundled dictionaries location
        spylls_note = QLabel(
            "<small><i>üí° Spylls bundled dicts are in its pip package.<br>"
            "Add your own .dic/.aff files to the folder above.</i></small>"
        )
        spylls_note.setWordWrap(True)
        hunspell_layout.addWidget(spylls_note)
        
        right_col.addWidget(hunspell_group)
        
        # Diagnostics
        diag_group = QGroupBox("üîß Diagnostics")
        diag_layout = QVBoxLayout(diag_group)
        diag_layout.setSpacing(2)
        
        diag_text = (
            f"<table cellspacing='2'>"
            f"<tr><td>Hunspell:</td><td>{'‚úì' if diag.get('hunspell_available') else '‚úó'} avail, {'‚úì' if diag.get('hunspell_initialized') else '‚úó'} init</td></tr>"
            f"<tr><td>Spylls:</td><td>{'‚úì' if diag.get('spylls_available') else '‚úó'} avail, {'‚úì' if diag.get('spylls_initialized') else '‚úó'} init</td></tr>"
            f"<tr><td>pyspellchecker:</td><td>{'‚úì' if diag.get('pyspellchecker_available') else '‚úó'} avail, {'‚úì' if diag.get('pyspellchecker_initialized') else '‚úó'} init</td></tr>"
            f"<tr><td>Custom words:</td><td>{diag.get('custom_words_count', 0)}</td></tr>"
            f"<tr><td>Session ignored:</td><td>{diag.get('ignored_words_count', 0)}</td></tr>"
            f"<tr><td>Cache size:</td><td>{diag.get('cache_size', 0)}</td></tr>"
        )
        if diag.get('pyspellchecker_word_count'):
            diag_text += f"<tr><td>Dict words:</td><td>{diag['pyspellchecker_word_count']:,}</td></tr>"
        diag_text += "</table>"
        
        diag_label = QLabel(diag_text)
        diag_label.setTextFormat(Qt.TextFormat.RichText)
        diag_layout.addWidget(diag_label)
        
        # Show warning only if NO backend is initialized
        any_initialized = diag.get('hunspell_initialized') or diag.get('spylls_initialized') or diag.get('pyspellchecker_initialized')
        if not any_initialized:
            warn_label = QLabel("<span style='color: orange;'>‚ö†Ô∏è Not initialized - try changing language</span>")
            diag_layout.addWidget(warn_label)
        
        right_col.addWidget(diag_group)
        
        # Project Links (for technical users)
        links_group = QGroupBox("üìñ Project Links")
        links_layout = QVBoxLayout(links_group)
        links_layout.setSpacing(2)
        
        pyspell_link = QLabel('<a href="https://github.com/barrust/pyspellchecker">pyspellchecker</a> ‚Äî Built-in word frequency spellcheck')
        pyspell_link.setOpenExternalLinks(True)
        links_layout.addWidget(pyspell_link)
        
        spylls_link = QLabel('<a href="https://github.com/zverok/spylls">spylls</a> ‚Äî Pure Python Hunspell implementation')
        spylls_link.setOpenExternalLinks(True)
        links_layout.addWidget(spylls_link)
        
        hunspell_link = QLabel('<a href="http://hunspell.github.io/">Hunspell</a> ‚Äî Original C/C++ spellcheck library')
        hunspell_link.setOpenExternalLinks(True)
        links_layout.addWidget(hunspell_link)
        
        right_col.addWidget(links_group)
        
        right_col.addStretch()
        columns.addLayout(right_col)
        
        main_layout.addLayout(columns, stretch=1)
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê OK Button ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        ok_btn = QPushButton("OK")
        ok_btn.clicked.connect(dialog.accept)
        ok_btn.setDefault(True)
        button_layout.addWidget(ok_btn)
        main_layout.addLayout(button_layout)
        
        dialog.exec()

    def _open_folder_in_explorer(self, path: str):
        """Open a folder or file location in the system file explorer"""
        import os
        import subprocess
        from pathlib import Path
        
        path_obj = Path(path)
        
        # If it's a file, open the containing folder
        if path_obj.is_file():
            folder = path_obj.parent
        else:
            folder = path_obj
        
        # Create folder if it doesn't exist
        folder.mkdir(parents=True, exist_ok=True)
        
        # Open in explorer
        if sys.platform == 'win32':
            os.startfile(str(folder))
        elif sys.platform == 'darwin':
            subprocess.run(['open', str(folder)])
        else:
            subprocess.run(['xdg-open', str(folder)])

    def filter_empty_segments(self):
        """Quick filter to show only segments with empty target"""
        if not self.current_project:
            return
        
        # Safety check: ensure table exists
        if not hasattr(self, 'table') or self.table is None:
            return
        
        # Clear filter boxes first
        source_widget = getattr(self, 'source_filter', None)
        target_widget = getattr(self, 'target_filter', None)
        if self._widget_is_alive(source_widget):
            source_widget.blockSignals(True)
            source_widget.clear()
            source_widget.blockSignals(False)
        if self._widget_is_alive(target_widget):
            target_widget.blockSignals(True)
            target_widget.clear()
            target_widget.blockSignals(False)
        
        # OPTIMIZED: Batch UI updates and don't reload grid
        self.table.setUpdatesEnabled(False)
        try:
            # Clear any yellow text filter highlights (but preserve termbase/tag formatting)
            self._clear_all_filter_highlights()
            
            # Hide rows with non-empty target
            visible_count = 0
            for row, segment in enumerate(self.current_project.segments):
                if row >= self.table.rowCount():
                    break
                
                has_empty_target = not segment.target or not segment.target.strip()
                self.table.setRowHidden(row, not has_empty_target)
                
                if has_empty_target:
                    visible_count += 1
        finally:
            self.table.setUpdatesEnabled(True)
        
        self.log(f"üîç Empty segments filter: showing {visible_count} of {len(self.current_project.segments)} segments")
    
    def _clear_all_filter_highlights(self):
        """Clear yellow filter highlights from all cells without reloading grid"""
        if not hasattr(self, 'table') or self.table is None:
            return
        
        for row in range(self.table.rowCount()):
            # Clear source column (2)
            self._clear_filter_highlights_in_widget(row, 2)
            
            # Clear target column (3)
            self._clear_filter_highlights_in_widget(row, 3)

    def apply_quick_filter(self, filter_type: str):
        """Apply quick filter based on type - OPTIMIZED for speed"""
        if not self.current_project:
            return
        
        if not hasattr(self, 'table') or self.table is None:
            return
        
        # Clear filter boxes first
        source_widget = getattr(self, 'source_filter', None)
        target_widget = getattr(self, 'target_filter', None)
        if self._widget_is_alive(source_widget):
            source_widget.blockSignals(True)
            source_widget.clear()
            source_widget.blockSignals(False)
        if self._widget_is_alive(target_widget):
            target_widget.blockSignals(True)
            target_widget.clear()
            target_widget.blockSignals(False)
        
        # OPTIMIZED: Batch UI updates and don't reload grid
        self.table.setUpdatesEnabled(False)
        try:
            # Clear any yellow text filter highlights (but preserve termbase/tag formatting)
            self._clear_all_filter_highlights()
            
            # Apply filter based on type
            visible_count = 0
            for row, segment in enumerate(self.current_project.segments):
                if row >= self.table.rowCount():
                    break
                
                show_row = False
                
                if filter_type == "empty":
                    show_row = not segment.target or not segment.target.strip()
                elif filter_type == "not_translated":
                    show_row = segment.status in ["not_started", "draft"]
                elif filter_type == "confirmed":
                    show_row = segment.status == "confirmed"
                elif filter_type == "locked":
                    # TODO: Implement locked status
                    show_row = getattr(segment, 'locked', False)
                elif filter_type == "not_locked":
                    # TODO: Implement locked status
                    show_row = not getattr(segment, 'locked', False)
                elif filter_type == "commented":
                    show_row = bool(segment.notes and segment.notes.strip())
                
                self.table.setRowHidden(row, not show_row)
                
                if show_row:
                    visible_count += 1
        finally:
            self.table.setUpdatesEnabled(True)
        
        filter_names = {
            "empty": "Empty segments",
            "not_translated": "Not translated",
            "confirmed": "Confirmed",
            "locked": "Locked",
            "not_locked": "Not locked",
            "commented": "Commented"
        }
        self.log(f"üîç {filter_names.get(filter_type, 'Quick')} filter: showing {visible_count} of {len(self.current_project.segments)} segments")
    
    def show_advanced_filters_dialog(self):
        """Show advanced filters dialog with detailed filtering options"""
        if not self.current_project:
            QMessageBox.information(self, "No Project", "Please open or create a project first.")
            return
        
        dialog = AdvancedFiltersDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            filters = dialog.get_filters()
            self.apply_advanced_filters(filters)
    
    def apply_advanced_filters(self, filters: dict):
        """Apply advanced filters to grid - OPTIMIZED for speed"""
        if not self.current_project or not hasattr(self, 'table') or self.table is None:
            return
        
        # Clear text filter boxes
        source_widget = getattr(self, 'source_filter', None)
        target_widget = getattr(self, 'target_filter', None)
        if self._widget_is_alive(source_widget):
            source_widget.blockSignals(True)
            source_widget.clear()
            source_widget.blockSignals(False)
        if self._widget_is_alive(target_widget):
            target_widget.blockSignals(True)
            target_widget.clear()
            target_widget.blockSignals(False)
        
        # OPTIMIZED: Batch UI updates and don't reload grid
        self.table.setUpdatesEnabled(False)
        try:
            # Clear any yellow text filter highlights (but preserve termbase/tag formatting)
            self._clear_all_filter_highlights()
            
            visible_count = 0
            for row, segment in enumerate(self.current_project.segments):
                if row >= self.table.rowCount():
                    break
                
                show_row = True
                
                # Match rate filter
                if filters.get('match_rate_enabled'):
                    match_percent = getattr(segment, 'match_percent', 0) or 0
                    min_rate = filters.get('match_rate_min', 0)
                    max_rate = filters.get('match_rate_max', 100)
                    if not (min_rate <= match_percent <= max_rate):
                        show_row = False
                
                # Row status filters
                status_filters = filters.get('row_status', [])
                if status_filters:
                    if segment.status not in status_filters:
                        show_row = False
                
                # Locked/unlocked filter
                if filters.get('locked_filter'):
                    locked_value = getattr(segment, 'locked', False)
                    if filters['locked_filter'] == 'locked' and not locked_value:
                        show_row = False
                    elif filters['locked_filter'] == 'unlocked' and locked_value:
                        show_row = False
                
                # Other properties
                if filters.get('has_comments'):
                    if not (segment.notes and segment.notes.strip()):
                        show_row = False
                
                if filters.get('has_proofreading'):
                    if not (segment.notes and "‚ö†Ô∏è PROOFREAD:" in segment.notes):
                        show_row = False
                
                if filters.get('repetitions_only'):
                    # TODO: Implement repetition detection
                    pass
                
                self.table.setRowHidden(row, not show_row)
                
                if show_row:
                    visible_count += 1
        finally:
            self.table.setUpdatesEnabled(True)
        
        self.log(f"üîç Advanced filters: showing {visible_count} of {len(self.current_project.segments)} segments")

    def apply_sort(self, sort_type: str = None):
        """Sort segments by various criteria (similar to memoQ)"""
        if not self.current_project or not hasattr(self, 'table') or self.table is None:
            return

        if not self.current_project.segments:
            return

        # Store original document order if not already stored
        if not hasattr(self, '_original_segment_order'):
            self._original_segment_order = self.current_project.segments.copy()

        # Update current sort state
        self.current_sort = sort_type

        # If sort_type is None, restore document order
        if sort_type is None:
            self.current_project.segments = self._original_segment_order.copy()
            self.load_segments_to_grid()
            self.log("‚Ü©Ô∏è Restored document order")
            return

        # Helper function to get text without tags for more accurate sorting
        def strip_tags(text: str) -> str:
            """Remove HTML/XML tags from text for sorting"""
            import re
            return re.sub(r'<[^>]+>', '', text).strip()

        # Calculate frequency maps if needed
        frequency_cache = {}
        if 'freq' in sort_type:
            from collections import Counter
            if 'source' in sort_type:
                counter = Counter(strip_tags(seg.source).lower() for seg in self.current_project.segments)
                frequency_cache = {strip_tags(seg.source).lower(): counter[strip_tags(seg.source).lower()]
                                 for seg in self.current_project.segments}
            else:  # target frequency
                counter = Counter(strip_tags(seg.target).lower() for seg in self.current_project.segments if seg.target)
                frequency_cache = {strip_tags(seg.target).lower(): counter[strip_tags(seg.target).lower()]
                                 for seg in self.current_project.segments if seg.target}

        # Sort based on selected criterion
        try:
            if sort_type == 'source_asc':
                self.current_project.segments.sort(key=lambda s: strip_tags(s.source).lower())
                sort_name = "Source A ‚Üí Z"
            elif sort_type == 'source_desc':
                self.current_project.segments.sort(key=lambda s: strip_tags(s.source).lower(), reverse=True)
                sort_name = "Source Z ‚Üí A"
            elif sort_type == 'target_asc':
                self.current_project.segments.sort(key=lambda s: strip_tags(s.target).lower() if s.target else "")
                sort_name = "Target A ‚Üí Z"
            elif sort_type == 'target_desc':
                self.current_project.segments.sort(key=lambda s: strip_tags(s.target).lower() if s.target else "", reverse=True)
                sort_name = "Target Z ‚Üí A"
            elif sort_type == 'source_length_asc':
                self.current_project.segments.sort(key=lambda s: len(strip_tags(s.source)))
                sort_name = "Source (shorter first)"
            elif sort_type == 'source_length_desc':
                self.current_project.segments.sort(key=lambda s: len(strip_tags(s.source)), reverse=True)
                sort_name = "Source (longer first)"
            elif sort_type == 'target_length_asc':
                self.current_project.segments.sort(key=lambda s: len(strip_tags(s.target)) if s.target else 0)
                sort_name = "Target (shorter first)"
            elif sort_type == 'target_length_desc':
                self.current_project.segments.sort(key=lambda s: len(strip_tags(s.target)) if s.target else 0, reverse=True)
                sort_name = "Target (longer first)"
            elif sort_type == 'match_asc':
                self.current_project.segments.sort(key=lambda s: getattr(s, 'match_percent', 0) or 0)
                sort_name = "Match Rate (lower first)"
            elif sort_type == 'match_desc':
                self.current_project.segments.sort(key=lambda s: getattr(s, 'match_percent', 0) or 0, reverse=True)
                sort_name = "Match Rate (higher first)"
            elif sort_type == 'source_freq_asc':
                self.current_project.segments.sort(key=lambda s: frequency_cache.get(strip_tags(s.source).lower(), 0))
                sort_name = "Source Frequency (lower first)"
            elif sort_type == 'source_freq_desc':
                self.current_project.segments.sort(key=lambda s: frequency_cache.get(strip_tags(s.source).lower(), 0), reverse=True)
                sort_name = "Source Frequency (higher first)"
            elif sort_type == 'target_freq_asc':
                self.current_project.segments.sort(key=lambda s: frequency_cache.get(strip_tags(s.target).lower(), 0) if s.target else 0)
                sort_name = "Target Frequency (lower first)"
            elif sort_type == 'target_freq_desc':
                self.current_project.segments.sort(key=lambda s: frequency_cache.get(strip_tags(s.target).lower(), 0) if s.target else 0, reverse=True)
                sort_name = "Target Frequency (higher first)"
            elif sort_type == 'modified_asc':
                self.current_project.segments.sort(key=lambda s: s.modified_at if s.modified_at else "")
                sort_name = "Last Changed (oldest first)"
            elif sort_type == 'modified_desc':
                self.current_project.segments.sort(key=lambda s: s.modified_at if s.modified_at else "", reverse=True)
                sort_name = "Last Changed (newest first)"
            elif sort_type == 'status':
                # Sort by status in a logical order: not_started, draft, translated, confirmed
                status_order = {'not_started': 0, 'draft': 1, 'translated': 2, 'confirmed': 3}
                self.current_project.segments.sort(key=lambda s: status_order.get(s.status, 99))
                sort_name = "Row Status"
            else:
                self.log(f"‚ö†Ô∏è Unknown sort type: {sort_type}")
                return

            # Reload grid to reflect new order
            self.load_segments_to_grid()
            self.log(f"‚áÖ Sorted by: {sort_name}")

        except Exception as e:
            self.log(f"‚ùå Error sorting segments: {e}")
            import traceback
            traceback.print_exc()

    # ========================================================================
    # TABBED SEGMENT EDITOR METHODS (for Grid view)
    # ========================================================================
    
    def on_tab_target_change(self):
        """Handle target text change in tab editor - updates all panels"""
        if not hasattr(self, 'tab_current_segment_id') or not self.tab_current_segment_id:
            return
        
        # Get the new text from whichever panel triggered this
        new_text = None
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    if hasattr(panel, 'editor_widget') and hasattr(panel.editor_widget, 'target_editor'):
                        new_text = panel.editor_widget.target_editor.toPlainText()
                        break  # Use text from first panel found
                except:
                    continue
        
        if new_text is None:
            return
        
        # Auto-save to current_project data structure
        if self.current_project and hasattr(self.current_project, 'segments'):
            for seg in self.current_project.segments:
                if seg.id == self.tab_current_segment_id:
                    # Check if text actually changed
                    old_target = seg.target
                    old_status = seg.status
                    
                    # IMMEDIATE: Update segment data
                    seg.target = new_text
                    self.project_modified = True
                    
                    # Reset 'confirmed' status to 'translated' when user edits the segment
                    # This prevents auto-saving to TM until user re-confirms the edit
                    if old_status == 'confirmed' and new_text != old_target:
                        seg.status = 'translated'
                        if self.debug_mode_enabled:
                            self.log(f"üìù Tab editor: Status reset confirmed ‚Üí translated (segment edited)")
                        # Refresh status in all views
                        self._refresh_segment_status(seg)
                    
                    # Update all other panels to keep them in sync
                    if hasattr(self, 'tabbed_panels'):
                        for panel in self.tabbed_panels:
                            try:
                                if hasattr(panel, 'editor_widget') and hasattr(panel.editor_widget, 'target_editor'):
                                    # Temporarily disconnect to avoid infinite loop
                                    panel.editor_widget.target_editor.blockSignals(True)
                                    panel.editor_widget.target_editor.setPlainText(new_text)
                                    panel.editor_widget.target_editor.blockSignals(False)
                            except:
                                pass
                    
                    # DEBOUNCED: Save to TM (expensive operation)
                    # Cancel previous timer
                    if hasattr(self, '_tab_target_debounce_timer'):
                        self._tab_target_debounce_timer.stop()
                    
                    # Schedule TM save after 500ms of inactivity
                    from PyQt6.QtCore import QTimer
                    self._tab_target_debounce_timer = QTimer()
                    self._tab_target_debounce_timer.setSingleShot(True)
                    # CRITICAL: Capture variables by value using default parameters to avoid closure bugs
                    self._tab_target_debounce_timer.timeout.connect(lambda segment=seg, text=new_text: self._save_tab_target_to_tm(segment, text))
                    self._tab_target_debounce_timer.start(500)
                    
                    break
    
    def _save_tab_target_to_tm(self, segment, text):
        """Save tab target text to TM after debounce delay"""
        try:
            # Only save to TM if segment is confirmed (user explicitly approved)
            if segment.status == 'confirmed' and text.strip():
                self.save_segment_to_activated_tms(segment.source, text)
        except Exception as e:
            self.log(f"Warning: Could not save to TM: {e}")
    
    def on_tab_status_combo_changed(self, index: int):
        combo = self.sender()
        if isinstance(combo, QComboBox) and index >= 0:
            status_key = combo.itemData(index)
            if status_key:
                self.on_tab_segment_status_change(status_key)

    def on_tab_segment_status_change(self, status_key: str):
        """Handle status change in tab editor - updates all panels"""
        if not hasattr(self, 'tab_current_segment_id') or not self.tab_current_segment_id:
            return

        status_key = status_key or DEFAULT_STATUS.key
        status_def = get_status(status_key)

        if self.current_project and hasattr(self.current_project, 'segments'):
            for seg in self.current_project.segments:
                if seg.id == self.tab_current_segment_id:
                    seg.status = status_key
                    self.project_modified = True
                    self.log(f"‚úì Status changed to: {status_def.label}")

                    # Update all panels to keep them in sync
                    if hasattr(self, 'tabbed_panels'):
                        for panel in self.tabbed_panels:
                            try:
                                if hasattr(panel, 'editor_widget') and hasattr(panel.editor_widget, 'status_combo'):
                                    combo = panel.editor_widget.status_combo
                                    combo.blockSignals(True)
                                    idx = combo.findData(status_key)
                                    if idx >= 0:
                                        combo.setCurrentIndex(idx)
                                    combo.blockSignals(False)
                            except Exception as e:
                                self.log(f"Error syncing status combo: {e}")
                    self._refresh_segment_status(seg)
                    
                    # Save to TM ONLY if status changed to confirmed (user explicitly approved)
                    if status_key == 'confirmed' and seg.target.strip():
                        try:
                            self.save_segment_to_activated_tms(seg.source, seg.target)
                            self.log(f"‚úì Saved to TM: {seg.source[:30]}... ‚Üí {seg.target[:30]}...")
                        except Exception as e:
                            self.log(f"Warning: Could not save to TM: {e}")
                    
                    break
    
    def on_tab_notes_change(self):
        """Handle comments change in tab editor - updates all panels"""
        if not hasattr(self, 'tab_current_segment_id') or not self.tab_current_segment_id:
            return
        
        # Get the new comments from whichever panel triggered this
        new_notes = None
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    if hasattr(panel, 'notes_widget') and hasattr(panel.notes_widget, 'notes_editor'):
                        new_notes = panel.notes_widget.notes_editor.toPlainText()
                        break
                except:
                    continue
        
        if new_notes is None:
            return
        
        if self.current_project and hasattr(self.current_project, 'segments'):
            for seg in self.current_project.segments:
                if seg.id == self.tab_current_segment_id:
                    seg.notes = new_notes
                    self.project_modified = True
                    
                    # Update all other panels to keep them in sync
                    if hasattr(self, 'tabbed_panels'):
                        for panel in self.tabbed_panels:
                            try:
                                if hasattr(panel, 'notes_widget') and hasattr(panel.notes_widget, 'notes_editor'):
                                    panel.notes_widget.notes_editor.blockSignals(True)
                                    panel.notes_widget.notes_editor.setPlainText(new_notes)
                                    panel.notes_widget.notes_editor.blockSignals(False)
                            except:
                                pass
                    self._refresh_segment_status(seg)
                    break
    
    def _on_results_panel_notes_changed(self):
        """Handle notes change in Translation Results panel - saves to current segment"""
        if not self.current_project:
            return
        
        # Get current segment from grid selection
        current_row = self.table.currentRow()
        if current_row < 0:
            return
        
        id_item = self.table.item(current_row, 0)
        if not id_item:
            return
        
        try:
            segment_id = int(id_item.text())
        except (ValueError, AttributeError):
            return
        
        # Find segment and update notes
        for seg in self.current_project.segments:
            if seg.id == segment_id:
                new_notes = self.translation_results_panel.notes_edit.toPlainText()
                seg.notes = new_notes
                self.project_modified = True
                # Sync with bottom notes panel
                if hasattr(self, 'bottom_notes_edit') and self.bottom_notes_edit:
                    self.bottom_notes_edit.blockSignals(True)
                    self.bottom_notes_edit.setPlainText(new_notes)
                    self.bottom_notes_edit.blockSignals(False)
                # Refresh the status cell to update the notes indicator
                self._refresh_segment_status(seg)
                break
    
    def _on_bottom_notes_changed(self):
        """Handle notes change in bottom Notes tab - saves to current segment and syncs with Translation Results panel"""
        if not self.current_project:
            return
        
        # Get current segment from grid selection
        current_row = self.table.currentRow()
        if current_row < 0:
            return
        
        id_item = self.table.item(current_row, 0)
        if not id_item:
            return
        
        try:
            segment_id = int(id_item.text())
        except (ValueError, AttributeError):
            return
        
        # Find segment and update notes
        for seg in self.current_project.segments:
            if seg.id == segment_id:
                new_notes = self.bottom_notes_edit.toPlainText()
                seg.notes = new_notes
                self.project_modified = True
                # Sync with Translation Results panel notes
                if hasattr(self, 'translation_results_panel') and self.translation_results_panel:
                    if hasattr(self.translation_results_panel, 'notes_edit') and self.translation_results_panel.notes_edit:
                        self.translation_results_panel.notes_edit.blockSignals(True)
                        self.translation_results_panel.notes_edit.setPlainText(new_notes)
                        self.translation_results_panel.notes_edit.blockSignals(False)
                # Refresh the status cell to update the notes indicator
                self._refresh_segment_status(seg)
                break
    
    def _on_scratchpad_changed(self):
        """Handle scratchpad change - saves to current project (not segment-level)"""
        if not self.current_project:
            return
        
        new_notes = self.scratchpad_edit.toPlainText()
        self.current_project.scratchpad_notes = new_notes
        self.current_project.modified = datetime.now().isoformat()
        self.project_modified = True
    
    def _update_scratchpad_for_project(self):
        """Update the Scratchpad tab with the current project's scratchpad notes"""
        if not hasattr(self, 'scratchpad_edit') or not self.scratchpad_edit:
            return
        
        self.scratchpad_edit.blockSignals(True)
        if self.current_project and hasattr(self.current_project, 'scratchpad_notes'):
            self.scratchpad_edit.setPlainText(self.current_project.scratchpad_notes or '')
        else:
            self.scratchpad_edit.clear()
        self.scratchpad_edit.blockSignals(False)
    
    def _update_bottom_notes_for_segment(self, segment):
        """Update the bottom Notes tab with the current segment's notes"""
        if not hasattr(self, 'bottom_notes_edit') or not self.bottom_notes_edit:
            return
        
        self.bottom_notes_edit.blockSignals(True)
        if segment and hasattr(segment, 'notes'):
            self.bottom_notes_edit.setPlainText(segment.notes or '')
        else:
            self.bottom_notes_edit.setPlainText('')
        self.bottom_notes_edit.blockSignals(False)
    
    def copy_source_to_tab_target(self):
        """Copy source to target in tab editor - works with all panels"""
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    if hasattr(panel, 'editor_widget'):
                        source_text = panel.editor_widget.source_editor.toPlainText()
                        panel.editor_widget.target_editor.setPlainText(source_text)
                except:
                    pass
    
    def clear_tab_target(self):
        """Clear target in tab editor - works with all panels"""
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    if hasattr(panel, 'editor_widget'):
                        panel.editor_widget.target_editor.clear()
                except:
                    pass

    def start_voice_dictation(self):
        """Start or stop voice dictation (toggle behavior)
        
        If always-on mode is active, F9 stops it.
        Otherwise, F9 starts push-to-talk recording.
        """
        # Check if always-on mode is active - if so, toggle it off
        if self.voice_listener and self.voice_listener.is_listening:
            self._toggle_alwayson_listening()
            return
        
        # Debug: Check thread state
        has_thread = hasattr(self, 'dictation_thread')
        thread_exists = has_thread and self.dictation_thread is not None
        thread_running = thread_exists and self.dictation_thread.isRunning()
        is_recording = thread_exists and getattr(self.dictation_thread, 'is_recording', False)

        self.log(f"üîç DEBUG: has_thread={has_thread}, thread_exists={thread_exists}, thread_running={thread_running}, is_recording={is_recording}")

        # Check if already recording - if so, stop it
        if thread_running:
            if is_recording:
                # Stop recording early
                self.dictation_thread.stop_recording()
                self.log("‚èπÔ∏è Stopping recording early...")
                return
            else:
                # Thread is running but not recording (probably transcribing/loading model)
                self.log("‚ö†Ô∏è Thread is running but not recording - waiting for it to finish...")
                return

        try:
            # Load dictation settings
            dictation_settings = self.load_dictation_settings()
            model_name = dictation_settings.get('model', 'base')
            max_duration = dictation_settings.get('max_duration', 10)
            lang_setting = dictation_settings.get('language', 'Auto (use project target language)')

            # Recognition engine: local vs OpenAI API
            use_api = dictation_settings.get('recognition_engine', 'local') == 'api'
            api_key = None
            if use_api:
                api_keys = self.load_api_keys()
                api_key = api_keys.get('openai') or api_keys.get('openai_api_key')
                if not api_key:
                    QMessageBox.warning(
                        self, "OpenAI API Key Required",
                        "To use OpenAI Whisper API, please set your OpenAI API key in:\n\n"
                        "Settings ‚Üí AI Settings ‚Üí OpenAI API Key"
                    )
                    return

            # Determine language
            if lang_setting == 'Auto (use project target language)':
                # Use project's target language
                target_lang = getattr(self, 'target_language', 'English')
            else:
                # Use override language from settings
                target_lang = lang_setting

            # Map language names to Whisper codes
            lang_map = {
                'English': 'en',
                'Dutch': 'nl',
                'German': 'de',
                'French': 'fr',
                'Spanish': 'es',
                'Italian': 'it',
                'Portuguese': 'pt',
                'Polish': 'pl',
                'Russian': 'ru',
                'Chinese': 'zh',
                'Japanese': 'ja',
                'Korean': 'ko'
            }
            lang_code = lang_map.get(target_lang, 'auto')

            # Create dictation thread with user settings
            self.dictation_thread = QuickDictationThread(
                model_name=model_name,
                language=lang_code,
                duration=max_duration,
                use_api=use_api,
                api_key=api_key
            )

            # Connect signals
            self.dictation_thread.transcription_ready.connect(self.on_dictation_complete)
            self.dictation_thread.status_update.connect(self.on_dictation_status)
            self.dictation_thread.error_occurred.connect(self.on_dictation_error)
            self.dictation_thread.finished.connect(self.on_dictation_finished)
            self.dictation_thread.model_loading_started.connect(self.on_model_loading_started)
            self.dictation_thread.model_loading_finished.connect(self.on_model_loading_finished)

            # Change button appearance
            self._set_dictation_button_recording(True)

            # Start recording
            if use_api:
                self.log(f"‚ñ∂Ô∏è Starting dictation thread (OpenAI Whisper API, language={lang_code}, duration={max_duration}s)...")
            else:
                self.log(f"‚ñ∂Ô∏è Starting dictation thread (local Whisper model={model_name}, language={lang_code}, duration={max_duration}s)...")
            self.dictation_thread.start()

        except Exception as e:
            self._set_dictation_button_recording(False)
            import traceback
            error_details = traceback.format_exc()
            self.log(f"")
            self.log(f"‚ùå ERROR starting dictation:")
            self.log(f"   {str(e)}")
            self.log(f"")
            self.log(f"Full traceback:")
            self.log(error_details)
            self.log(f"")
            QMessageBox.critical(self, "Dictation Error", f"Failed to start dictation:\n\n{str(e)}\n\nCheck the Log tab for full details.")

    def on_dictation_complete(self, text):
        """Handle completed dictation - check for voice commands first"""
        # Load voice command settings
        dictation_settings = self.load_dictation_settings()
        voice_commands_enabled = dictation_settings.get('voice_commands_enabled', True)
        
        # Check for voice commands first (if enabled)
        if voice_commands_enabled and hasattr(self, 'voice_command_manager'):
            was_command, result = self.voice_command_manager.process_spoken_text(text)
            if was_command:
                # It was a command - show result and don't insert as text
                self.log(f"üé§ Voice command: {text} ‚Üí {result}")
                self.status_bar.showMessage(f"üé§ {result}", 3000)
                return
        
        # Not a command - insert as text (dictation mode)
        focused_widget = QApplication.focusWidget()

        # Check if focused widget is a grid target cell
        if isinstance(focused_widget, EditableGridTextEditor):
            current_text = focused_widget.toPlainText()
            if current_text:
                focused_widget.setPlainText(current_text + " " + text)
            else:
                focused_widget.setPlainText(text)
            # Move cursor to end
            cursor = focused_widget.textCursor()
            cursor.movePosition(cursor.MoveOperation.End)
            focused_widget.setTextCursor(cursor)
        # Otherwise insert into segment editor below grid
        elif hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    if hasattr(panel, 'editor_widget'):
                        current_text = panel.editor_widget.target_editor.toPlainText()
                        if current_text:
                            panel.editor_widget.target_editor.setPlainText(current_text + " " + text)
                        else:
                            panel.editor_widget.target_editor.setPlainText(text)
                        cursor = panel.editor_widget.target_editor.textCursor()
                        cursor.movePosition(cursor.MoveOperation.End)
                        panel.editor_widget.target_editor.setTextCursor(cursor)
                except:
                    pass

        # Show notification
        self.status_bar.showMessage(f"‚úÖ Dictation: {text[:50]}...", 3000)

    def on_dictation_status(self, message):
        """Show dictation status"""
        self.log(message)  # Also log to Log tab
        self.status_bar.showMessage(message, 2000)

    def on_dictation_error(self, error_msg):
        """Handle dictation error"""
        self._set_dictation_button_recording(False)

        # Log the full error to Log tab
        self.log("")
        self.log("‚ùå SUPERVOICE ERROR:")
        self.log(error_msg)
        self.log("")

        self.status_bar.showMessage(f"‚ùå Voice dictation error", 3000)

        # Show detailed error dialog for FFmpeg issues
        if "FFmpeg" in error_msg or "ffmpeg" in error_msg:
            QMessageBox.warning(self, "FFmpeg Required", error_msg)

    def on_dictation_finished(self):
        """Handle dictation thread finishing"""
        self.log("‚úì Dictation thread finished")
        self._set_dictation_button_recording(False)

    def on_model_loading_started(self, model_name):
        """Handle Whisper model loading/download starting"""
        self.is_loading_model = True
        self.loading_model_name = model_name
        model_sizes = {
            'tiny': '75 MB',
            'base': '142 MB',
            'small': '466 MB',
            'medium': '1.5 GB',
            'large': '2.9 GB'
        }
        size = model_sizes.get(model_name, 'unknown size')

        # Check if model exists
        import os
        cache_dir = self._get_whisper_cache_path()
        model_files = [
            f"{model_name}.pt",
            f"{model_name}.en.pt",
            f"{model_name}-v3.pt"
        ]
        model_exists = any(os.path.exists(os.path.join(cache_dir, f)) for f in model_files)

        if model_exists:
            self.status_bar.showMessage(f"üé§ Supervoice: Loading '{model_name}' model...", 10000)
            self.log(f"‚è≥ Loading Whisper model '{model_name}' from cache...")
        else:
            self.status_bar.showMessage(f"üì• Supervoice: Downloading '{model_name}' model ({size})...", 60000)
            self.log(f"")
            self.log(f"üì• DOWNLOADING Whisper model '{model_name}' ({size})...")
            self.log(f"   This is a one-time download. Please be patient!")
            self.log(f"   ‚ö†Ô∏è DO NOT CLOSE SUPERVERTALER until download completes!")
            self.log(f"   Location: {cache_dir}")
            self.log(f"")

    def on_model_loading_finished(self):
        """Handle Whisper model loading/download finishing"""
        model_name = self.loading_model_name  # Save before clearing
        self.is_loading_model = False
        self.loading_model_name = None
        self.status_bar.showMessage(f"üé§ Supervoice: '{model_name}' model ready", 3000)
        self.log(f"‚úÖ Model '{model_name}' loaded successfully")

    def _set_dictation_button_recording(self, is_recording):
        """Change dictate button appearance based on recording state"""
        # Update grid view dictate button
        if hasattr(self, 'tab_dictate_btn'):
            button = self.tab_dictate_btn
            if is_recording:
                button.setText("‚èπÔ∏è Stop (F9)")
                button.setStyleSheet("background-color: #D32F2F; color: white; font-weight: bold;")
            else:
                button.setText("üé§ Dictate (F9)")
                button.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
        
        # Update list view dictate button (legacy, for backwards compatibility)
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    # Use stored reference to dictate button
                    if hasattr(panel, 'editor_widget') and hasattr(panel.editor_widget, 'dictate_btn'):
                        button = panel.editor_widget.dictate_btn
                        if is_recording:
                            button.setText("‚èπÔ∏è Stop (F9)")
                            button.setStyleSheet("background-color: #D32F2F; color: white; font-weight: bold;")
                        else:
                            button.setText("üé§ Dictate (F9)")
                            button.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold;")
                except:
                    pass

    def save_tab_segment(self):
        """Save current segment in tab editor"""
        if not hasattr(self, 'tab_current_segment_id') or not self.tab_current_segment_id:
            return
        
        # Find segment and save to TM if appropriate
        if self.current_project and hasattr(self.current_project, 'segments'):
            for seg in self.current_project.segments:
                if seg.id == self.tab_current_segment_id:
                    # Save to TM ONLY if status is confirmed (user explicitly approved)
                    if seg.status == 'confirmed' and seg.target.strip():
                        try:
                            self.save_segment_to_activated_tms(seg.source, seg.target)
                            self.log(f"‚úì Saved segment {self.tab_current_segment_id} to TM")
                        except Exception as e:
                            self.log(f"‚úì Saved segment {self.tab_current_segment_id} (TM save failed: {e})")
                    else:
                        self.log(f"‚úì Saved segment {self.tab_current_segment_id}")
                    break
        else:
            self.log(f"‚úì Saved segment {self.tab_current_segment_id}")
    
    def save_tab_segment_and_next(self):
        """Save current segment and move to next in tab editor"""
        self.save_tab_segment()
        
        # Move to next segment in grid view
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row < self.table.rowCount() - 1:
                self.table.setCurrentCell(current_row + 1, self.table.currentColumn())
    
    # ========================================================================
    # GRID-BASED EDITING HANDLERS (for toolbar below grid)
    # ========================================================================
    
    def filter_on_selected_text(self):
        """Filter based on currently selected text in source or target column.
        
        Toggle behavior: If filters are already active, pressing Ctrl+Shift+F 
        will clear the filters. Otherwise, filter on selected text.
        """
        from PyQt6.QtWidgets import QApplication
        
        # Check if filters are currently active FIRST (for toggle behavior)
        source_filter_text = self._get_line_edit_text('source_filter').strip() if hasattr(self, 'source_filter') else ""
        target_filter_text = self._get_line_edit_text('target_filter').strip() if hasattr(self, 'target_filter') else ""
        filters_active = bool(source_filter_text or target_filter_text)
        
        # Toggle: if filters are active, clear them and return
        if filters_active:
            self.clear_filters()
            self.log("üîç Filters cleared (Ctrl+Shift+F toggle)")
            return
        
        # No filters active - try to filter on selected text
        focused_widget = QApplication.focusWidget()
        
        selected_text = ""
        is_source = False
        is_target = False
        
        # Check if it's a text editor widget (source or target)
        if focused_widget and isinstance(focused_widget, (EditableGridTextEditor, ReadOnlyGridTextEditor)):
            cursor = focused_widget.textCursor()
            selected_text = cursor.selectedText().strip()
            
            # Determine if it's source or target by checking which column it's in
            if hasattr(self, 'table') and self.table:
                for row in range(self.table.rowCount()):
                    # Check source column (index 2)
                    source_widget = self.table.cellWidget(row, 2)
                    if source_widget == focused_widget:
                        is_source = True
                        break
                    # Check target column (index 3)
                    target_widget = self.table.cellWidget(row, 3)
                    if target_widget == focused_widget:
                        is_target = True
                        break
        
        if not selected_text:
            self.log("‚ö†Ô∏è No text selected. Select text in source or target column first.")
            return
        
        # Put selected text in appropriate filter box and apply filter
        if is_source and hasattr(self, 'source_filter') and self.source_filter:
            self.source_filter.setText(selected_text)
            self.apply_filters()
            self.log(f"üîç Filtering source on: '{selected_text}'")
        elif is_target and hasattr(self, 'target_filter') and self.target_filter:
            self.target_filter.setText(selected_text)
            self.apply_filters()
            self.log(f"üîç Filtering target on: '{selected_text}'")
    
    def copy_source_to_grid_target(self):
        """Copy source to target in currently selected grid row"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        current_row = self.table.currentRow()
        if current_row < 0 or not self.current_project or current_row >= len(self.current_project.segments):
            return
        
        segment = self.current_project.segments[current_row]
        segment.target = segment.source
        
        # Update grid cell - target is column 3 (ID=0, Status=1, Source=2, Target=3)
        target_widget = self.table.cellWidget(current_row, 3)
        if target_widget and isinstance(target_widget, EditableGridTextEditor):
            target_widget.setPlainText(segment.source)
        
        self.project_modified = True
        self.log(f"üìã Copied source to target in segment {segment.id}")
    
    def clear_grid_target(self):
        """Clear target in currently selected grid row"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        current_row = self.table.currentRow()
        if current_row < 0 or not self.current_project or current_row >= len(self.current_project.segments):
            return
        
        segment = self.current_project.segments[current_row]
        segment.target = ""
        
        # Update grid cell - target is column 3 (ID=0, Status=1, Source=2, Target=3)
        target_widget = self.table.cellWidget(current_row, 3)
        if target_widget and isinstance(target_widget, EditableGridTextEditor):
            target_widget.clear()
        
        self.project_modified = True
        self.log(f"üóëÔ∏è Cleared target in segment {segment.id}")
    
    def save_grid_segment(self):
        """Save current segment from grid"""
        if not hasattr(self, 'table') or not self.table:
            return
        
        current_row = self.table.currentRow()
        if current_row < 0 or current_row >= len(self.current_project.segments):
            return
        
        segment = self.current_project.segments[current_row]
        
        # Save to TM ONLY if status is confirmed (user explicitly approved)
        if segment.status == 'confirmed' and segment.target.strip():
            try:
                self.save_segment_to_activated_tms(segment.source, segment.target)
                self.log(f"üíæ Saved segment {segment.id} to TM")
            except Exception as e:
                self.log(f"üíæ Saved segment {segment.id} (TM save failed: {e})")
        else:
            self.log(f"üíæ Saved segment {segment.id}")
    
    def save_grid_segment_and_next(self):
        """Save current segment and move to next in grid"""
        self.save_grid_segment()
        
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row < self.table.rowCount() - 1:
                next_row = current_row + 1
                
                # ‚ö° INSTANT NAVIGATION
                self._ctrl_enter_navigation = True
                
                self.table.setCurrentCell(next_row, 3)  # Column 3 = Target (widget column)
                # Get the target cell widget and set focus to it
                target_widget = self.table.cellWidget(next_row, 3)
                if target_widget:
                    target_widget.setFocus()
                    # Move cursor to end of text
                    target_widget.moveCursor(QTextCursor.MoveOperation.End)
    
    # ========================================================================
    # KEYBOARD NAVIGATION SHORTCUTS
    # ========================================================================
    
    def select_previous_match(self):
        """Cycle to previous match (Ctrl+Up)

        Context-aware behavior:
        - If Compare Panel tab is active: navigate MT/TM list depending on focused box
        - If Translation Results tab is active: delegate to visible results panel
        - Otherwise: do nothing (avoid acting on hidden panels)
        """
        mode = self._get_active_match_shortcut_mode()
        if mode == 'compare':
            self._compare_panel_nav_active_box(-1)
            return
        if mode == 'results':
            for panel in self._iter_visible_results_panels():
                try:
                    if hasattr(panel, 'select_previous_match'):
                        panel.select_previous_match()
                        break
                except Exception as e:
                    self.log(f"Error selecting previous match: {e}")
            return
    
    def select_next_match(self):
        """Cycle to next match (Ctrl+Down)

        Context-aware behavior:
        - If Compare Panel tab is active: navigate MT/TM list depending on focused box
        - If Translation Results tab is active: delegate to visible results panel
        - Otherwise: do nothing (avoid acting on hidden panels)
        """
        mode = self._get_active_match_shortcut_mode()
        if mode == 'compare':
            self._compare_panel_nav_active_box(1)
            return
        if mode == 'results':
            for panel in self._iter_visible_results_panels():
                try:
                    if hasattr(panel, 'select_next_match'):
                        panel.select_next_match()
                        break
                except Exception as e:
                    self.log(f"Error selecting next match: {e}")
            return
    
    def insert_match_by_number(self, match_number: int):
        """Insert match by number (Ctrl+1-9)

        Context-aware behavior:
        - If Compare Panel tab is active: insert from Compare Panel MT/TM list depending on focused box
        - If Translation Results tab is active: delegate to visible results panel
        - Otherwise: do nothing (avoid acting on hidden panels)
        """
        mode = self._get_active_match_shortcut_mode()
        if mode == 'compare':
            try:
                self._insert_compare_panel_match_by_number(match_number)
            except Exception as e:
                self.log(f"Error inserting Compare Panel match #{match_number}: {e}")
            return
        if mode == 'results':
            for panel in self._iter_visible_results_panels():
                try:
                    if hasattr(panel, 'insert_match_by_number'):
                        if panel.insert_match_by_number(match_number):
                            break
                except Exception as e:
                    self.log(f"Error inserting match #{match_number}: {e}")
            return
    
    def _handle_termview_shortcut(self, key_num: int):
        """Handle TermView shortcut with double-tap detection for terms 11-20
        
        TermView numbering starts at 1 (Alt+1..Alt+9). Alt+0 is reserved for the Compare Panel.
        
        Single tap (Alt+N): Insert term N (1-9)
        Double tap (Alt+N,N within 300ms): Undo first insert, then insert term N+10 (11, 22, ..., 99)
        """
        import time

        # Alt+0 is reserved for the Compare Panel.
        if key_num == 0:
            return

        current_time = time.time()
        double_tap_threshold = 0.3  # 300ms window for double-tap
        
        # Check if this is a double-tap (same key within threshold)
        if (hasattr(self, '_termview_last_key') and 
            self._termview_last_key == key_num and 
            hasattr(self, '_termview_last_time') and
            (current_time - self._termview_last_time) < double_tap_threshold):
            # Double-tap detected! 
            # First, undo the single-tap insertion
            current_widget = self._get_current_target_widget()
            if current_widget and hasattr(current_widget, 'undo'):
                current_widget.undo()
            
            # Now insert term 10-19 (displayed as 00, 11, ..., 99)
            term_index = key_num + 10
            self._termview_last_key = None  # Reset to prevent triple-tap
            self._termview_last_time = 0
            self.insert_termview_term_by_number(term_index)
        else:
            # Single tap - insert term 1-9
            self._termview_last_key = key_num
            self._termview_last_time = current_time
            self.insert_termview_term_by_number(key_num)
    
    def _get_current_target_widget(self):
        """Get the current target cell text widget"""
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row >= 0:
                return self.table.cellWidget(current_row, 3)  # Column 3 = Target
        return None
    
    def insert_termview_term_by_number(self, term_number: int):
        """Insert term from TermView by number (0-19)"""
        if hasattr(self, 'termview_widget') and self.termview_widget:
            try:
                if hasattr(self.termview_widget, 'insert_term_by_number'):
                    self.termview_widget.insert_term_by_number(term_number)
            except Exception as e:
                self.log(f"Error inserting TermView term #{term_number}: {e}")
    
    def insert_selected_match(self):
        """Insert currently selected match (Ctrl+Space)

        Context-aware behavior:
        - If Compare Panel tab is active: insert current MT translation or TM target depending on focused box
        - If Translation Results tab is active: delegate to visible results panel
        - Otherwise: do nothing (avoid acting on hidden panels)
        """
        mode = self._get_active_match_shortcut_mode()
        if mode == 'compare':
            try:
                self._insert_compare_panel_current_match()
            except Exception as e:
                self.log(f"Error inserting Compare Panel selected match: {e}")
            return
        if mode == 'results':
            for panel in self._iter_visible_results_panels():
                try:
                    if hasattr(panel, 'insert_selected_match'):
                        if panel.insert_selected_match():
                            break
                except Exception as e:
                    self.log(f"Error inserting selected match: {e}")
            return

    def _get_active_match_shortcut_mode(self) -> str:
        """Return active shortcut context for match shortcuts.

        Returns:
            'match' if Match Panel tab is active,
            'results' if Translation Results tab is active,
            '' otherwise.
        """
        if hasattr(self, 'right_tabs') and self._widget_is_alive(self.right_tabs):
            try:
                current = self.right_tabs.currentWidget()
            except Exception:
                current = None
            if current is not None:
                if hasattr(self, 'match_panel_widget') and self.match_panel_widget and current is self.match_panel_widget:
                    return 'match'
                if hasattr(self, 'translation_results_panel') and self.translation_results_panel and current is self.translation_results_panel:
                    return 'results'
        return ''

    def _iter_visible_results_panels(self):
        """Yield results panels that are visible to the user (tab-selected)."""
        if not hasattr(self, 'results_panels') or not self.results_panels:
            return
        for panel in self.results_panels:
            try:
                if panel and hasattr(panel, 'isVisible') and panel.isVisible():
                    yield panel
            except Exception:
                continue

    def _compare_panel_nav_active_box(self, direction: int):
        """Navigate Compare Panel matches based on which box is focused."""
        if not hasattr(self, 'compare_panel') or not self.compare_panel:
            return
        if not hasattr(self, 'right_tabs') or not self._widget_is_alive(self.right_tabs):
            return
        if self.right_tabs.currentWidget() is not self.compare_panel:
            return

        focus_widget = QApplication.focusWidget()
        if hasattr(self, 'compare_panel_mt') and focus_widget is self.compare_panel_mt:
            self._compare_panel_nav_mt(direction)
            return
        if hasattr(self, 'compare_panel_tm_source') and focus_widget is self.compare_panel_tm_source:
            self._compare_panel_nav_tm(direction)
            return
        if hasattr(self, 'compare_panel_tm_target') and focus_widget is self.compare_panel_tm_target:
            self._compare_panel_nav_tm(direction)
            return

        # Default: TM navigation (more "match-like" than MT)
        self._compare_panel_nav_tm(direction)

    def _insert_compare_panel_current_match(self):
        """Insert currently shown Compare Panel text based on focused box."""
        if not hasattr(self, 'compare_panel') or not self.compare_panel:
            return
        if not hasattr(self, 'right_tabs') or not self._widget_is_alive(self.right_tabs):
            return
        if self.right_tabs.currentWidget() is not self.compare_panel:
            return

        focus_widget = QApplication.focusWidget()
        if hasattr(self, 'compare_panel_mt') and focus_widget is self.compare_panel_mt:
            text = self.compare_panel_mt.toPlainText().strip()
            if text and not text.startswith('('):
                self.on_match_inserted(text)
            return

        # Default to inserting TM target
        if hasattr(self, 'compare_panel_tm_target'):
            text = self.compare_panel_tm_target.toPlainText().strip()
            if text and not text.startswith('('):
                self.on_match_inserted(text)

    def _handle_compare_panel_alt0_shortcut(self):
        """Handle Alt+0 insertion from Match Panel or Compare Panel.

        Match Panel (mode='match'):
        - Single tap Alt+0: insert TM Target from Match Panel

        Compare Panel (mode='compare' - not currently used):
        - Single tap (Alt+0): insert MT
        - Double tap (Alt+0,0 within 300ms): undo first insert, then insert TM Target
        """
        mode = self._get_active_match_shortcut_mode()

        # Handle Match Panel: Alt+0 inserts TM Target directly
        if mode == 'match':
            if hasattr(self, 'match_panel_tm_target'):
                text = self.match_panel_tm_target.toPlainText().strip()
                if text and not text.startswith('('):
                    self._replace_current_target_segment_text(text, source_label='TM Target (Match Panel)')
            return

        # Handle Compare Panel (legacy - currently not reached since mode never equals 'compare')
        if mode != 'compare':
            return

        import time
        current_time = time.time()
        double_tap_threshold = 0.3  # 300ms window
        key_num = 0

        if (hasattr(self, '_compare_panel_last_key') and
            self._compare_panel_last_key == key_num and
            hasattr(self, '_compare_panel_last_time') and
            (current_time - self._compare_panel_last_time) < double_tap_threshold):
            # Double-tap: undo MT insert, then insert TM Target
            current_widget = self._get_current_target_widget()
            if current_widget and hasattr(current_widget, 'undo'):
                current_widget.undo()
            self._compare_panel_last_key = None
            self._compare_panel_last_time = 0
            if hasattr(self, 'compare_panel_tm_target'):
                text = self.compare_panel_tm_target.toPlainText().strip()
                if text and not text.startswith('('):
                    self._replace_current_target_segment_text(text, source_label='TM Target (Compare Panel)')
            return

        # Single tap: insert MT
        self._compare_panel_last_key = key_num
        self._compare_panel_last_time = current_time
        if hasattr(self, 'compare_panel_mt'):
            text = self.compare_panel_mt.toPlainText().strip()
            if text and not text.startswith('('):
                self._replace_current_target_segment_text(text, source_label='MT (Compare Panel)')

    def _replace_current_target_segment_text(self, new_text: str, source_label: str = ""):
        """Replace the entire current target segment text (single undo step).

        This is used for Compare Panel quick-insert shortcuts like Alt+0 / Alt+0,0,
        where the user expects a full replacement (not insertion at cursor).
        """
        try:
            if not self.current_project or not self.table:
                return

            row = self.table.currentRow()
            if row < 0:
                return

            id_item = self.table.item(row, 0)
            if not id_item:
                self.log(f"‚ö†Ô∏è No segment ID found at row {row}")
                return

            try:
                segment_id = int(id_item.text())
            except (ValueError, AttributeError):
                self.log(f"‚ö†Ô∏è Could not parse segment ID from row {row}")
                return

            segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
            if not segment:
                self.log(f"‚ö†Ô∏è Could not find segment with ID {segment_id}")
                return

            target_widget = self.table.cellWidget(row, 3)
            if target_widget and isinstance(target_widget, QTextEdit):
                from PyQt6.QtGui import QTextCursor

                cursor = target_widget.textCursor()
                cursor.beginEditBlock()
                cursor.select(QTextCursor.SelectionType.Document)
                cursor.insertText(new_text)
                cursor.endEditBlock()

                segment.target = target_widget.toPlainText()
                target_widget.setFocus()
                target_widget.moveCursor(QTextCursor.MoveOperation.End)

                label = f" ({source_label})" if source_label else ""
                self.log(f"‚úì Replaced target text in segment {segment.id}{label}")
                self._play_sound_effect('match_inserted')
                return

            # Fallback: no editor widget, update data and (if possible) update cell
            segment.target = new_text
            if target_widget and hasattr(target_widget, 'setPlainText'):
                target_widget.setPlainText(new_text)
            label = f" ({source_label})" if source_label else ""
            self.log(f"‚úì Replaced target text in segment {segment_id}{label}")
            self._play_sound_effect('match_inserted')

        except Exception as e:
            self.log(f"Error replacing target text: {e}")
            import traceback
            traceback.print_exc()

    def _play_sound_effect(self, event: str):
        """Play a minimalist UI sound effect (currently uses OS beep).

        Event is informational for future expansion.
        """
        try:
            # Prefer cached in-memory value if available (avoids repeated file reads)
            enabled = getattr(self, 'enable_sound_effects', None)
            if enabled is None:
                settings = self.load_general_settings() if hasattr(self, 'load_general_settings') else {}
                enabled = settings.get('enable_sound_effects', False)

            if not enabled:
                return

            # Per-event mapping (defaults provided by general settings defaults)
            sound_map = getattr(self, 'sound_effects_map', None)
            if sound_map is None:
                settings = self.load_general_settings() if hasattr(self, 'load_general_settings') else {}
                sound_map = settings.get('sound_effects_map', {}) if isinstance(settings, dict) else {}

            sound_key = None
            if isinstance(sound_map, dict):
                sound_key = sound_map.get(event)

            # Windows: MessageBeep tends to be more audible than QApplication.beep()
            if os.name == 'nt':
                try:
                    import winsound

                    if sound_key == 'none':
                        return

                    wav_key_to_path = {
                        'windows_proximity_wav': r"C:\\Windows\\Media\\Windows Proximity Notification.wav",
                        'windows_restore_wav': r"C:\\Windows\\Media\\Windows Restore.wav",
                        'windows_navigation_start_wav': r"C:\\Windows\\Media\\Windows Navigation Start.wav",
                        'speech_disambiguation_wav': r"C:\\Windows\\Media\\Speech Disambiguation.wav",
                        'windows_startup_wav': r"C:\\Windows\\Media\\Windows Startup.wav",
                    }
                    if sound_key in wav_key_to_path:
                        wav_path = wav_key_to_path.get(sound_key)
                        try:
                            if wav_path and os.path.exists(wav_path):
                                winsound.PlaySound(wav_path, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_NODEFAULT)
                                return
                        except Exception:
                            # Fall back to a beep below
                            pass

                    sound_to_mb = {
                        None: winsound.MB_OK,
                        'ok': winsound.MB_OK,
                        'asterisk': winsound.MB_ICONASTERISK,
                        'exclamation': winsound.MB_ICONEXCLAMATION,
                        'hand': winsound.MB_ICONHAND,
                        'question': winsound.MB_ICONQUESTION,
                    }
                    winsound.MessageBeep(sound_to_mb.get(sound_key, winsound.MB_OK))
                    return
                except Exception:
                    pass

            QApplication.beep()
        except Exception:
            # Never allow sound effects to break normal workflows
            return

    def _queue_tm_save_log(self, msg: str):
        """Collapse repeated TM-save log messages into a single '(xN)' line.

        This prevents session log spam when confirming many segments.
        Thread-safe: flushes via a background timer and relies on self.log() being thread-safe.
        """
        import threading

        if not hasattr(self, '_tm_save_log_lock'):
            self._tm_save_log_lock = threading.Lock()
            self._tm_save_log_msg = None
            self._tm_save_log_count = 0
            self._tm_save_log_timer = None

        flush_now_msg = None
        flush_now_count = 0

        with self._tm_save_log_lock:
            # If we're switching to a different message, flush the previous one immediately.
            if self._tm_save_log_msg and self._tm_save_log_msg != msg and self._tm_save_log_count:
                flush_now_msg = self._tm_save_log_msg
                flush_now_count = self._tm_save_log_count
                self._tm_save_log_msg = None
                self._tm_save_log_count = 0

            # Accumulate the new message
            if self._tm_save_log_msg == msg:
                self._tm_save_log_count += 1
            else:
                self._tm_save_log_msg = msg
                self._tm_save_log_count = 1

            # Reset flush timer (debounce)
            if self._tm_save_log_timer is not None:
                try:
                    self._tm_save_log_timer.cancel()
                except Exception:
                    pass
                self._tm_save_log_timer = None

            self._tm_save_log_timer = threading.Timer(0.8, self._flush_tm_save_log_threadsafe)
            self._tm_save_log_timer.daemon = True
            self._tm_save_log_timer.start()

        # Flush outside lock
        if flush_now_msg and flush_now_count:
            suffix = f" (x{flush_now_count})" if flush_now_count > 1 else ""
            self.log(f"{flush_now_msg}{suffix}")

    def _flush_tm_save_log_threadsafe(self):
        import threading

        if not hasattr(self, '_tm_save_log_lock'):
            return

        msg = None
        count = 0
        with self._tm_save_log_lock:
            msg = getattr(self, '_tm_save_log_msg', None)
            count = int(getattr(self, '_tm_save_log_count', 0) or 0)
            self._tm_save_log_msg = None
            self._tm_save_log_count = 0
            self._tm_save_log_timer = None

        if msg and count:
            suffix = f" (x{count})" if count > 1 else ""
            self.log(f"{msg}{suffix}")

    def insert_compare_panel_mt(self):
        """Insert the currently shown Compare Panel MT translation (default: Alt+M)."""
        if self._get_active_match_shortcut_mode() != 'compare':
            return
        self._insert_compare_panel_mt_current()

    def insert_compare_panel_tm_target(self):
        """Insert the currently shown Compare Panel TM target (default: Alt+T)."""
        if self._get_active_match_shortcut_mode() != 'compare':
            return
        self._insert_compare_panel_tm_target_current()

    def _insert_compare_panel_mt_current(self):
        if not hasattr(self, 'compare_panel_mt'):
            return
        text = self.compare_panel_mt.toPlainText().strip()
        if text and not text.startswith('('):
            self.on_match_inserted(text)

    def _insert_compare_panel_tm_target_current(self):
        if not hasattr(self, 'compare_panel_tm_target'):
            return
        text = self.compare_panel_tm_target.toPlainText().strip()
        if text and not text.startswith('('):
            self.on_match_inserted(text)

    def _insert_compare_panel_match_by_number(self, match_number: int):
        """Insert Compare Panel content by number (Ctrl+1-9 while Compare Panel is active).

        Only two of these make sense for the Compare Panel:
        - 1 = MT (current)
        - 2 = TM Target (current)
        """
        if match_number not in (1, 2):
            return
        if not hasattr(self, 'compare_panel') or not self.compare_panel:
            return
        if not hasattr(self, 'right_tabs') or not self._widget_is_alive(self.right_tabs):
            return
        if self.right_tabs.currentWidget() is not self.compare_panel:
            return

        if match_number == 1:
            self._insert_compare_panel_mt_current()
            return
        if match_number == 2:
            self._insert_compare_panel_tm_target_current()
            return
    
    def go_to_previous_segment(self, target_column: int = None, to_last_line: bool = False):
        """Navigate to previous segment (Alt+Up)
        
        Args:
            target_column: If provided, position cursor at this column (for arrow key nav)
            to_last_line: If True with target_column, go to last line at that column
        """
        from PyQt6.QtGui import QTextCursor
        
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row > 0:
                new_row = current_row - 1
                self.table.clearSelection()
                self.table.setCurrentCell(new_row, 3)  # Column 3 = Target (widget column)
                # Get the target cell widget and set focus to it
                target_widget = self.table.cellWidget(new_row, 3)
                if target_widget:
                    target_widget.setFocus()
                    if target_column is not None and to_last_line:
                        # Position at target column on VISUAL last line (for Up arrow navigation)
                        cursor = target_widget.textCursor()
                        doc = target_widget.document()
                        last_block = doc.lastBlock()
                        layout = last_block.layout()
                        
                        if layout and layout.lineCount() > 0:
                            # Get the last VISUAL line within this block
                            last_visual_line = layout.lineAt(layout.lineCount() - 1)
                            line_start_in_block = int(last_visual_line.textStart())
                            line_length = int(last_visual_line.textLength())
                            target_pos_in_line = min(target_column, max(0, line_length - 1))
                            absolute_pos = last_block.position() + line_start_in_block + target_pos_in_line
                            cursor.setPosition(absolute_pos)
                        else:
                            # Fallback: position at target column from block start
                            cursor.setPosition(last_block.position())
                            line_length = last_block.length() - 1
                            target_pos = min(target_column, max(0, line_length))
                            cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.MoveAnchor, target_pos)
                        
                        target_widget.setTextCursor(cursor)
                    else:
                        # Default: move cursor to end of text
                        target_widget.moveCursor(QTextCursor.MoveOperation.End)
    
    def go_to_next_segment(self, target_column: int = None, to_first_line: bool = False):
        """Navigate to next segment (Alt+Down)
        
        Args:
            target_column: If provided, position cursor at this column (for arrow key nav)
            to_first_line: If True with target_column, go to first line at that column
        """
        from PyQt6.QtGui import QTextCursor
        
        if hasattr(self, 'table') and self.table:
            current_row = self.table.currentRow()
            if current_row < self.table.rowCount() - 1:
                new_row = current_row + 1
                self.table.clearSelection()
                self.table.setCurrentCell(new_row, 3)  # Column 3 = Target (widget column)
                # Get the target cell widget and set focus to it
                target_widget = self.table.cellWidget(new_row, 3)
                if target_widget:
                    target_widget.setFocus()
                    if target_column is not None and to_first_line:
                        # Position at target column on VISUAL first line (for Down arrow navigation)
                        cursor = target_widget.textCursor()
                        doc = target_widget.document()
                        first_block = doc.firstBlock()
                        layout = first_block.layout()
                        
                        if layout and layout.lineCount() > 0:
                            # Get the first VISUAL line within this block
                            first_visual_line = layout.lineAt(0)
                            line_length = int(first_visual_line.textLength())
                            target_pos_in_line = min(target_column, max(0, line_length - 1))
                            absolute_pos = first_block.position() + target_pos_in_line
                            cursor.setPosition(absolute_pos)
                        else:
                            # Fallback: position at target column from block start
                            cursor.setPosition(first_block.position())
                            line_length = first_block.length() - 1
                            target_pos = min(target_column, max(0, line_length))
                            cursor.movePosition(QTextCursor.MoveOperation.Right, QTextCursor.MoveMode.MoveAnchor, target_pos)
                        
                        target_widget.setTextCursor(cursor)
                    else:
                        # Default: move cursor to end of text
                        target_widget.moveCursor(QTextCursor.MoveOperation.End)
    
    def go_to_first_segment(self):
        """Navigate to first segment (Ctrl+Home).

        Pagination/filters may hide row 0, so switch to the first page and then
        move to the first visible row.
        """
        if not hasattr(self, 'table') or not self.table or self.table.rowCount() <= 0:
            return

        # If pagination is enabled, ensure we're on the first page so row 0 is visible.
        if hasattr(self, 'go_to_first_page'):
            self.go_to_first_page()

        target_row = 0
        if self.table.isRowHidden(target_row):
            # Filters can also hide rows; pick the first visible row.
            target_row = next((r for r in range(self.table.rowCount()) if not self.table.isRowHidden(r)), 0)

        self.table.setCurrentCell(target_row, 3)  # Column 3 = Target (widget column)
        id_item = self.table.item(target_row, 0)
        if id_item is not None:
            self.table.scrollToItem(id_item)
        self.log("‚è´ Moved to first segment")

        target_widget = self.table.cellWidget(target_row, 3)
        if target_widget:
            target_widget.setFocus()
            target_widget.moveCursor(QTextCursor.MoveOperation.Start)
    
    def go_to_last_segment(self):
        """Navigate to last segment (Ctrl+End).

        Pagination/filters may hide the last row, so switch to the last page and then
        move to the last visible row.
        """
        if not hasattr(self, 'table') or not self.table or self.table.rowCount() <= 0:
            return

        # If pagination is enabled, ensure we're on the last page so the last row is visible.
        if hasattr(self, 'go_to_last_page'):
            self.go_to_last_page()

        target_row = self.table.rowCount() - 1
        if self.table.isRowHidden(target_row):
            target_row = next((r for r in range(self.table.rowCount() - 1, -1, -1) if not self.table.isRowHidden(r)), target_row)

        self.table.setCurrentCell(target_row, 3)  # Column 3 = Target (widget column)
        id_item = self.table.item(target_row, 0)
        if id_item is not None:
            self.table.scrollToItem(id_item)
        self.log(f"‚è¨ Moved to last segment ({target_row + 1})")

        target_widget = self.table.cellWidget(target_row, 3)
        if target_widget:
            target_widget.setFocus()
            target_widget.moveCursor(QTextCursor.MoveOperation.End)
    
    def confirm_and_next_unconfirmed(self):
        """Set current segment to confirmed and move to next unconfirmed segment (Ctrl+Enter)."""
        if not hasattr(self, 'table') or not self.table or not self.current_project:
            self.log("‚ö†Ô∏è Ctrl+Enter: Missing table or project")
            return
        
        current_row = self.table.currentRow()
        if current_row < 0:
            self.log("‚ö†Ô∏è Ctrl+Enter: No row selected")
            return

        # If text filters are active, Ctrl+Enter should advance through the filtered/visible rows,
        # not "next unconfirmed". This avoids selecting hidden rows and prevents pagination from
        # accidentally unhiding rows.
        if self._is_text_filter_active():
            self._confirm_current_row_segment()
            # Re-apply filters in case the target text changed and affects matching
            self.apply_filters()
            self._move_to_next_visible_row(current_row)
            return
        
        # CRITICAL: Ensure the target widget has focus before reading from it
        # This fixes the issue where Ctrl+Enter doesn't work without mouse interaction
        target_widget_current = self.table.cellWidget(current_row, 3)
        if target_widget_current and not target_widget_current.hasFocus():
            target_widget_current.setFocus()
            # Give Qt event loop time to process the focus change
            QApplication.processEvents()
        
        # Confirm current row (shared implementation)
        self._confirm_current_row_segment()
        
        # Find next unconfirmed segment
        for row in range(current_row + 1, self.table.rowCount()):
            if row < len(self.current_project.segments):
                seg = self.current_project.segments[row]
                if seg.status not in ['confirmed', 'approved']:
                    # Check if row is hidden due to pagination
                    if self.table.isRowHidden(row):
                        # Calculate which page this row is on and switch to it
                        if hasattr(self, 'grid_page_size') and hasattr(self, 'grid_current_page'):
                            target_page = row // self.grid_page_size
                            if target_page != self.grid_current_page:
                                self.grid_current_page = target_page
                                self._update_pagination_ui()
                                self._apply_pagination_to_grid()
                    
                    # ‚ö° INSTANT NAVIGATION: Set flag so on_cell_selected uses fast path
                    # This makes Ctrl+Enter feel instant - cursor moves first, lookups happen after
                    self._ctrl_enter_navigation = True
                    
                    self.table.clearSelection()
                    self.table.setCurrentCell(row, 3)  # Column 3 = Target (widget column)
                    self.table.selectRow(row)  # v1.9.182: Ensure row is visually selected
                    # Ensure the row is visible by scrolling to it
                    self.table.scrollToItem(self.table.item(row, 0), QTableWidget.ScrollHint.PositionAtCenter)
                    self.log(f"‚è≠Ô∏è Moved to next unconfirmed segment {seg.id}")

                    # v1.9.182: Explicitly update termview (don't rely on deferred signal)
                    self._update_termview_for_segment(seg)

                    # v1.9.182: Explicitly schedule TM lookup (don't rely on deferred signal)
                    if self.enable_tm_matching:
                        find_replace_active = getattr(self, 'find_replace_active', False)
                        if not find_replace_active:
                            self._schedule_mt_and_llm_matches(seg, [])

                    # Get the target cell widget and set focus to it IMMEDIATELY
                    # (moved BEFORE auto-confirm check for instant responsiveness)
                    target_widget = self.table.cellWidget(row, 3)
                    if target_widget:
                        target_widget.setFocus()
                        # Move cursor to end of text
                        target_widget.moveCursor(QTextCursor.MoveOperation.End)

                    # v1.9.182: Defer auto-confirm check to not block navigation
                    # The TM lookup is slow - do it asynchronously after navigation completes
                    if self.auto_confirm_100_percent_matches:
                        QTimer.singleShot(50, lambda r=row, s=seg: self._check_auto_confirm_100_percent(r, s))
                    return
        
        # No more unconfirmed segments, just go to next
        if current_row < self.table.rowCount() - 1:
            next_row = current_row + 1
            
            # Check if row is hidden due to pagination
            if self.table.isRowHidden(next_row):
                # Calculate which page this row is on and switch to it
                if hasattr(self, 'grid_page_size') and hasattr(self, 'grid_current_page'):
                    target_page = next_row // self.grid_page_size
                    if target_page != self.grid_current_page:
                        self.grid_current_page = target_page
                        self._update_pagination_ui()
                        self._apply_pagination_to_grid()
            
            # ‚ö° INSTANT NAVIGATION
            self._ctrl_enter_navigation = True
            
            self.table.clearSelection()
            self.table.setCurrentCell(next_row, 3)  # Column 3 = Target (widget column)
            self.table.selectRow(next_row)  # v1.9.182: Ensure row is visually selected
            # Ensure the row is visible by scrolling to it
            self.table.scrollToItem(self.table.item(next_row, 0), QTableWidget.ScrollHint.PositionAtCenter)
            self.log(f"‚è≠Ô∏è Moved to next segment (all remaining confirmed)")

            # v1.9.182: Explicitly update termview (don't rely on deferred signal)
            if next_row < len(self.current_project.segments):
                next_seg = self.current_project.segments[next_row]
                self._update_termview_for_segment(next_seg)

                # v1.9.182: Explicitly schedule TM lookup (don't rely on deferred signal)
                if self.enable_tm_matching:
                    find_replace_active = getattr(self, 'find_replace_active', False)
                    if not find_replace_active:
                        self._schedule_mt_and_llm_matches(next_seg, [])

            # Get the target cell widget and set focus to it
            target_widget = self.table.cellWidget(next_row, 3)
            if target_widget:
                target_widget.setFocus()
                # Move cursor to end of text
                target_widget.moveCursor(QTextCursor.MoveOperation.End)

    def _check_auto_confirm_100_percent(self, row: int, seg):
        """
        v1.9.182: Deferred auto-confirm check for 100% TM matches.

        This is called asynchronously after Ctrl+Enter navigation to avoid blocking
        the UI thread with slow TM database queries.
        """
        try:
            # Verify we're still on the same segment (user may have navigated away)
            current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
            if current_row != row:
                return  # User has moved - don't auto-confirm wrong segment

            if not self.enable_tm_matching or not hasattr(self, 'db_manager') or not self.db_manager:
                return

            # Get activated TM IDs from project settings
            activated_tm_ids = []
            if hasattr(self.current_project, 'tm_settings') and self.current_project.tm_settings:
                activated_tm_ids = self.current_project.tm_settings.get('activated_tm_ids', [])

            if not activated_tm_ids:
                return

            # Use get_exact_match for 100% matches
            source_lang = self.current_project.source_lang if hasattr(self.current_project, 'source_lang') else None
            target_lang = self.current_project.target_lang if hasattr(self.current_project, 'target_lang') else None
            exact_match = self.db_manager.get_exact_match(
                seg.source,
                tm_ids=activated_tm_ids,
                source_lang=source_lang,
                target_lang=target_lang
            )

            if not exact_match:
                return

            # Check if there's a 100% match and (target is empty OR overwrite is enabled)
            target_is_empty = not seg.target.strip()
            can_auto_confirm = target_is_empty or self.auto_confirm_overwrite_existing

            if not can_auto_confirm:
                return

            # Verify AGAIN that we're still on the same segment (TM query may have taken time)
            current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
            if current_row != row:
                return  # User has moved during TM lookup

            match_target = exact_match.get('target_text', '')
            if not match_target:
                return

            overwrite_note = " (overwriting existing)" if not target_is_empty else " (empty target)"
            self.log(f"üéØ Auto-confirm: Found 100% TM match for segment {seg.id}{overwrite_note}")

            # Insert the match into the target cell
            target_widget = self.table.cellWidget(row, 3)
            if target_widget:
                target_widget.setPlainText(match_target)
                seg.target = match_target
                seg.status = 'confirmed'
                self.update_status_icon(row, 'confirmed')
                self.project_modified = True

                # Save to TM
                try:
                    self.save_segment_to_activated_tms(seg.source, seg.target)
                    self.log(f"üíæ Auto-confirmed and saved segment {seg.id} to TM")
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Error saving auto-confirmed segment to TM: {e}")

                # Continue to the NEXT unconfirmed segment (skip this one)
                self.confirm_and_next_unconfirmed()
        except Exception as e:
            self.log(f"‚ö†Ô∏è Error in auto-confirm check: {e}")

    def confirm_selected_or_next(self):
        """Smart confirm: if multiple segments selected, confirm all; otherwise confirm and go to next.
        
        This is the handler for Ctrl+Enter:
        - Multiple segments selected: confirm all selected segments
        - Single segment: confirm current and go to next unconfirmed
        """
        selected_segments = self.get_selected_segments_from_grid()
        
        if len(selected_segments) > 1:
            # Multiple segments selected - confirm all
            self.confirm_selected_segments()
        else:
            # Single segment - if text filters are active, advance through the filtered rows
            # (handled inside confirm_and_next_unconfirmed for centralization).
            self.confirm_and_next_unconfirmed()

    def _is_text_filter_active(self) -> bool:
        """Return True if the Filter Source/Target boxes currently contain text."""
        source_text = self._get_line_edit_text('source_filter').strip()
        target_text = self._get_line_edit_text('target_filter').strip()
        return bool(source_text or target_text)

    def _confirm_current_row_segment(self) -> Optional[int]:
        """Confirm the current row's segment and sync target text from the grid.

        Returns the confirmed segment ID on success, else None.
        """
        if not hasattr(self, 'table') or not self.table or not self.current_project:
            return None

        current_row = self.table.currentRow()
        if current_row < 0:
            return None

        # Ensure the target widget has focus before reading from it
        target_widget_current = self.table.cellWidget(current_row, 3)
        if target_widget_current and not target_widget_current.hasFocus():
            target_widget_current.setFocus()
            QApplication.processEvents()

        id_item = self.table.item(current_row, 0)
        if not id_item:
            self.log(f"‚ö†Ô∏è Ctrl+Enter: No ID item at row {current_row}")
            return None

        try:
            segment_id = int(id_item.text())
        except (ValueError, AttributeError):
            self.log(f"‚ö†Ô∏è Ctrl+Enter: Could not parse segment ID from row {current_row}")
            return None

        segment = next((seg for seg in self.current_project.segments if seg.id == segment_id), None)
        if not segment:
            self.log(f"‚ö†Ô∏è Ctrl+Enter: Could not find segment with ID {segment_id}")
            return None

        self.log(f"üîç Ctrl+Enter: Row {current_row}, Segment ID {segment.id}")

        old_target = segment.target
        old_status = segment.status

        target_widget = self.table.cellWidget(current_row, 3)
        if target_widget:
            current_text = target_widget.toPlainText().strip()
            segment.target = current_text

        segment.status = 'confirmed'

        # Record undo state for Ctrl+Enter confirmation
        self.record_undo_state(segment_id, old_target, segment.target, old_status, 'confirmed')
        self.update_status_icon(current_row, 'confirmed')
        self.project_modified = True
        self.log(f"‚úÖ Segment {segment.id} confirmed")

        self.update_progress_stats()

        # Play sound effect for segment confirmation
        self._play_sound_effect('segment_confirmed')

        if segment.target and segment.target.strip():
            try:
                self.save_segment_to_activated_tms(segment.source, segment.target)
                self.log(f"üíæ Saved segment {segment.id} to TM: '{segment.target[:50]}...'")
            except Exception as e:
                self.log(f"‚ö†Ô∏è Error saving to TM: {e}")

        return segment_id

    def _move_to_next_visible_row(self, current_row: int) -> None:
        """Move focus to the next visible row after current_row (respects filters + pagination)."""
        if not hasattr(self, 'table') or not self.table or not self.current_project:
            return

        row_count = self.table.rowCount()
        if row_count <= 0:
            return

        page_size = getattr(self, 'grid_page_size', 50)
        has_pagination = isinstance(page_size, int) and page_size < 999999 and page_size > 0

        last_page_applied = getattr(self, 'grid_current_page', 0)

        for row in range(current_row + 1, row_count):
            if has_pagination:
                target_page = row // page_size
                if target_page != last_page_applied:
                    self.grid_current_page = target_page
                    last_page_applied = target_page
                    self._apply_pagination_to_grid()

            if not self.table.isRowHidden(row):
                self.table.clearSelection()
                self.table.setCurrentCell(row, 3)
                id_item = self.table.item(row, 0)
                if id_item is not None:
                    self.table.scrollToItem(id_item)

                target_widget = self.table.cellWidget(row, 3)
                if target_widget:
                    target_widget.setFocus()
                    target_widget.moveCursor(QTextCursor.MoveOperation.End)
                return

        # No more visible rows
        self.log("‚úÖ No more filtered segments")
    
    def confirm_selected_segments(self):
        """Confirm all selected segments in the grid.
        
        Sets status to 'confirmed' for all selected segments and saves them to TM.
        """
        if not self.current_project:
            self.log("‚ö†Ô∏è No project loaded")
            return
        
        selected_segments = self.get_selected_segments_from_grid()
        
        if not selected_segments:
            self.log("‚ö†Ô∏è No segments selected")
            return
        
        # Sync all target text from grid widgets first
        self._sync_grid_targets_to_segments(selected_segments)
        
        confirmed_count = 0
        tm_saved_count = 0
        
        for segment in selected_segments:
            # Skip already confirmed segments
            if segment.status == 'confirmed':
                continue
            
            old_status = segment.status
            segment.status = 'confirmed'
            confirmed_count += 1
            
            # Update grid status icon
            row = self._find_row_for_segment(segment.id)
            if row >= 0:
                self.update_status_icon(row, 'confirmed')
            
            # Save to TM if target has content
            if segment.target and segment.target.strip():
                try:
                    self.save_segment_to_activated_tms(segment.source, segment.target)
                    tm_saved_count += 1
                except Exception as e:
                    self.log(f"‚ö†Ô∏è Error saving segment {segment.id} to TM: {e}")
        
        if confirmed_count > 0:
            self.project_modified = True
            self.update_window_title()
            self.log(f"‚úÖ Confirmed {confirmed_count} segment(s), saved {tm_saved_count} to TM")
            # Update status bar progress stats
            self.update_progress_stats()
        else:
            self.log(f"‚ÑπÔ∏è All {len(selected_segments)} selected segment(s) were already confirmed")
    
    def confirm_selected_segments_from_menu(self):
        """Confirm selected segments (called from Edit > Bulk Operations menu)"""
        if not self.current_project:
            QMessageBox.information(self, "Not Available", "Please load a project first.")
            return

        if not hasattr(self, 'table') or not self.table:
            QMessageBox.information(self, "Not Available", "Grid view is not available.")
            return

        selected_segments = self.get_selected_segments_from_grid()
        if selected_segments:
            self.confirm_selected_segments()
        else:
            QMessageBox.information(self, "No Selection", "Please select one or more segments to confirm.")

    def change_status_selected(self, new_status: str, from_menu: bool = False):
        """Change status of all selected segments to the specified status.

        Args:
            new_status: The status key to set (e.g., 'translated', 'pretranslated')
            from_menu: If True, show message boxes for errors (called from menu)
        """
        if not self.current_project:
            if from_menu:
                QMessageBox.information(self, "Not Available", "Please load a project first.")
            else:
                self.log("‚ö†Ô∏è No project loaded")
            return

        if not hasattr(self, 'table') or not self.table:
            if from_menu:
                QMessageBox.information(self, "Not Available", "Grid view is not available.")
            return

        selected_segments = self.get_selected_segments_from_grid()

        if not selected_segments:
            if from_menu:
                QMessageBox.information(self, "No Selection", "Please select one or more segments to change.")
            else:
                self.log("‚ö†Ô∏è No segments selected")
            return

        # Sync all target text from grid widgets first
        self._sync_grid_targets_to_segments(selected_segments)

        # Get status definition for logging
        from modules.statuses import get_status
        status_def = get_status(new_status)

        changed_count = 0
        for segment in selected_segments:
            # Skip if already has this status
            if segment.status == new_status:
                continue

            segment.status = new_status
            changed_count += 1

            # Update grid status icon
            row = self._find_row_for_segment(segment.id)
            if row >= 0:
                self.update_status_icon(row, new_status)

        if changed_count > 0:
            self.project_modified = True
            self.update_window_title()
            self.log(f"‚úÖ Changed {changed_count} segment(s) to '{status_def.label}'")
            # Update status bar progress stats
            self.update_progress_stats()
        else:
            self.log(f"‚ÑπÔ∏è All {len(selected_segments)} selected segment(s) already have status '{status_def.label}'")

    def _sync_grid_targets_to_segments(self, segments):
        """Sync target text from grid widgets to segment objects.
        
        This ensures any edits in the grid are captured before confirming.
        """
        for segment in segments:
            row = self._find_row_for_segment(segment.id)
            if row >= 0:
                target_widget = self.table.cellWidget(row, 3)
                if target_widget:
                    segment.target = target_widget.toPlainText().strip()
    
    def _find_row_for_segment(self, segment_id: int) -> int:
        """Find the grid row index for a segment by ID."""
        if not hasattr(self, 'table') or not self.table:
            return -1
        
        for row in range(self.table.rowCount()):
            id_item = self.table.item(row, 0)
            if id_item:
                try:
                    if int(id_item.text()) == segment_id:
                        return row
                except (ValueError, AttributeError):
                    continue
        return -1

    def insert_termview_text(self, text: str):
        """Insert text from Termview into the currently active target field"""
        try:
            # Find the active target editor
            current_row = self.table.currentRow()
            if current_row >= 0:
                target_widget = self.table.cellWidget(current_row, 3)
                if target_widget and hasattr(target_widget, 'textCursor'):
                    # Insert at current cursor position
                    cursor = target_widget.textCursor()
                    cursor.insertText(text)
                    target_widget.setFocus()
                    self.log(f"‚úì Inserted term: {text}")
                    return
            
            # Fallback: try tab editor panels
            if hasattr(self, 'tabbed_panels'):
                for panel in self.tabbed_panels:
                    if hasattr(panel, 'editor_widget'):
                        editor = panel.editor_widget
                        if editor.target_editor.hasFocus() or True:  # Insert into first available
                            cursor = editor.target_editor.textCursor()
                            cursor.insertText(text)
                            editor.target_editor.setFocus()
                            self.log(f"‚úì Inserted term: {text}")
                            return
            
            self.log("‚ö†Ô∏è No active target field found for insertion")
        except Exception as e:
            self.log(f"‚úó Error inserting termview text: {e}")
    
    def _on_termview_edit_entry(self, term_id: int, termbase_id: int):
        """Handle edit glossary entry request from Termview"""
        try:
            from modules.termbase_entry_editor import TermbaseEntryEditor
            
            dialog = TermbaseEntryEditor(
                parent=self,
                db_manager=self.db_manager,
                termbase_id=termbase_id,
                term_id=term_id
            )
            
            if dialog.exec():
                # Entry was edited, refresh termview and translation results
                self.log(f"‚úì Glossary entry {term_id} updated")
                self._refresh_current_segment_matches()
        except Exception as e:
            self.log(f"‚úó Error editing glossary entry: {e}")
    
    def _on_termview_delete_entry(self, term_id: int, termbase_id: int, source_term: str, target_term: str):
        """Handle delete glossary entry request from Termview"""
        from PyQt6.QtWidgets import QMessageBox
        
        try:
            # Confirm deletion
            reply = QMessageBox.question(
                self,
                "Confirm Deletion",
                f"Delete glossary entry?\n\nSource: {source_term}\nTarget: {target_term}\n\nThis action cannot be undone.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                if self.termbase_mgr:
                    try:
                        if self.termbase_mgr.delete_term(term_id):
                            self.log(f"‚úì Deleted glossary entry: {source_term} ‚Üí {target_term}")
                            
                            # Refresh termview and translation results
                            self._refresh_current_segment_matches()
                        else:
                            self.log(f"‚úó Failed to delete glossary entry")
                    except Exception as e:
                        self.log(f"‚úó Error deleting glossary entry from database: {e}")
        except Exception as e:
            self.log(f"‚úó Error deleting glossary entry: {e}")
    
    def _refresh_current_segment_matches(self):
        """Refresh termbase matches for the current segment (after edit/delete)"""
        try:
            # Use the targeted refresh method that doesn't trigger TM search
            self._refresh_termbase_display_for_current_segment()
        except Exception as e:
            self.log(f"‚úó Error refreshing segment matches: {e}")
    
    def save_tab_notes(self):
        """Save comments in tab editor"""
        if not hasattr(self, 'tab_current_segment_id') or not self.tab_current_segment_id:
            return
        self.log(f"‚úì Saved comments for segment {self.tab_current_segment_id}")

    def toggle_tm_from_editor(self, checked: bool, button: QPushButton):
        """Toggle TM/Termbase lookups from segment editor button"""
        # Call the existing toggle method
        self.toggle_tm_termbase_matching(checked)

        # Update button text and style
        if checked:
            button.setText("üîç TM/Glossary ON")
            self.log("‚úì TM/Glossary lookups ENABLED from segment editor")
        else:
            button.setText("üö´ TM/Glossary OFF")
            self.log("‚ö†Ô∏è TM/Glossary lookups DISABLED from segment editor (faster editing)")

    def _toggle_tag_view_via_shortcut(self):
        """Toggle tag view using keyboard shortcut (Ctrl+Alt+T)"""
        if hasattr(self, 'wysiwyg_btn') and hasattr(self, 'tags_btn'):
            # Toggle between the two modes
            new_state = not self.show_tags
            self.toggle_tag_view(new_state, None)

    def _enable_tag_view_after_import(self):
        """Auto-enable Tag View after importing a document with formatting tags"""
        if hasattr(self, 'tags_btn'):
            self.toggle_tag_view(True, None)
            self.log("üè∑Ô∏è Tag View auto-enabled (formatting tags detected in import)")

    def toggle_tag_view(self, checked: bool, button: QPushButton = None):
        """Toggle between Tag View (showing raw tags) and WYSIWYG View (formatted display)"""
        self.show_tags = checked

        # Update segmented control buttons if they exist
        if hasattr(self, 'wysiwyg_btn') and hasattr(self, 'tags_btn'):
            if checked:
                self.tags_btn.setChecked(True)
            else:
                self.wysiwyg_btn.setChecked(True)

        self.log(f"{'üè∑Ô∏è Tag View ENABLED - showing raw tags' if checked else '‚ú® WYSIWYG View ENABLED - showing formatted text'}")

        # Refresh the grid to update display
        if hasattr(self, 'table') and self.current_project:
            self._refresh_grid_display_mode()
    
    def _refresh_grid_display_mode(self):
        """Refresh all visible cells to reflect current tag view mode"""
        if not hasattr(self, 'table') or not self.current_project:
            return
        
        # Get current visible rows
        for row in range(self.table.rowCount()):
            # Get segment for this row
            if row >= len(self.current_project.segments):
                continue
            
            segment = self.current_project.segments[row]
            
            # Update source cell (column 2)
            source_widget = self.table.cellWidget(row, 2)
            if source_widget and hasattr(source_widget, 'update_display_mode'):
                source_widget.update_display_mode(segment.source, self.show_tags)
            
            # Update target cell (column 3)
            target_widget = self.table.cellWidget(row, 3)
            if target_widget and hasattr(target_widget, 'update_display_mode'):
                target_widget.update_display_mode(segment.target, self.show_tags)

    def update_tab_segment_editor(self, segment_id: int, source_text: str, target_text: str, 
                                   status: str = "untranslated", notes: str = ""):
        """Update the tab segment editor with current segment data"""
        # CRITICAL FIX: Update segment ID BEFORE setting text to prevent cross-contamination
        # When setPlainText() triggers textChanged, it needs to update the CORRECT segment
        self.tab_current_segment_id = segment_id
        
        # Update ALL tabbed panels (grid view and list view)
        if hasattr(self, 'tabbed_panels'):
            for panel in self.tabbed_panels:
                try:
                    # Update segment editor tab
                    if hasattr(panel, 'editor_widget'):
                        editor = panel.editor_widget
                        editor.seg_info_label.setText(f"Segment {segment_id}")
                        editor.source_editor.setPlainText(source_text)
                        editor.target_editor.setPlainText(target_text)
                        idx = editor.status_combo.findData(status)
                        if idx >= 0:
                            editor.status_combo.blockSignals(True)
                            editor.status_combo.setCurrentIndex(idx)
                            editor.status_combo.blockSignals(False)
                    
                    # Update notes tab
                    if hasattr(panel, 'notes_widget'):
                        panel.notes_widget.notes_editor.setPlainText(notes)
                except Exception as e:
                    self.log(f"Error updating tabbed panel: {e}")
        
        # NOTE: Termview is updated AFTER termbase search completes in _on_cell_selected_full
        # Do NOT update Termview here - the cache may not be populated yet
    
    # ========================================================================
    # UTILITY
    # ========================================================================
    
    def update_window_title(self):
        """Update window title with project name and modified state"""
        title = f"Supervertaler v{__version__}"
        if ENABLE_PRIVATE_FEATURES:
            title += " [üõ†Ô∏è DEV MODE]"
        if self.current_project:
            title += f" - {self.current_project.name}"
            if self.project_modified:
                title += " *"
        self.setWindowTitle(title)
    
    def log(self, message: str):
        """Log message to status bar and session log (thread-safe)"""
        # Always safe to print to console
        print(f"[LOG] {message}")
        
        # Check if we're in the main thread - Qt widgets can only be modified from main thread
        import threading
        
        is_main_thread = threading.current_thread() == threading.main_thread()
        
        if not is_main_thread:
            # If we're in a background thread, emit signal which will be handled on main thread
            # pyqtSignal with default connection is thread-safe and queues to main event loop
            try:
                self._log_signal.emit(message)
            except Exception:
                pass  # Silently fail if signal emission fails
            return
        
        # Main thread - safe to access widgets directly
        self._log_to_ui(message)
    
    def _log_to_ui(self, message: str):
        """Internal method to log to UI widgets - must be called from main thread only"""
        if hasattr(self, 'status_bar'):
            self.status_bar.showMessage(message)
        
        # Add to debug buffer if debug mode is enabled
        if hasattr(self, 'debug_mode_enabled') and self.debug_mode_enabled:
            if not hasattr(self, 'debug_log_buffer'):
                self.debug_log_buffer = []
            from datetime import datetime
            timestamp = datetime.now().strftime("%H:%M:%S")
            self.debug_log_buffer.append(f"[{timestamp}] {message}")
            # Keep buffer size reasonable (max 10,000 entries)
            if len(self.debug_log_buffer) > 10000:
                self.debug_log_buffer = self.debug_log_buffer[-10000:]

        # Also append to session log tab if it exists
        if hasattr(self, 'session_log_text') and self.session_log_text:
            from datetime import datetime
            from PyQt6.QtGui import QTextCursor
            timestamp = datetime.now().strftime("%H:%M:%S")
            formatted_message = f"[{timestamp}] {message}"
            try:
                # Append without newline (appendPlainText adds it automatically)
                self.session_log_text.appendPlainText(formatted_message)
                # Force scroll to bottom by moving cursor to end
                self.session_log_text.moveCursor(QTextCursor.MoveOperation.End)
                self.session_log_text.ensureCursorVisible()
            except Exception:
                pass  # Silently fail if widget not ready

        # Also append to Settings tab session log if it exists (separate widget)
        if hasattr(self, 'session_log') and self.session_log:
            from datetime import datetime
            from PyQt6.QtGui import QTextCursor
            timestamp = datetime.now().strftime("%H:%M:%S")
            formatted_message = f"[{timestamp}] {message}"
            try:
                self.session_log.appendPlainText(formatted_message)
                self.session_log.moveCursor(QTextCursor.MoveOperation.End)
                self.session_log.ensureCursorVisible()
            except Exception:
                pass  # Silently fail if widget not ready

        # Also send to detached log windows
        if hasattr(self, 'detached_log_windows'):
            from datetime import datetime
            from PyQt6.QtGui import QTextCursor
            timestamp = datetime.now().strftime("%H:%M:%S")
            formatted_message = f"[{timestamp}] {message}"
            for window in self.detached_log_windows[:]:  # Copy list to avoid modification during iteration
                try:
                    if window and not window.isHidden():
                        window.log_display.appendPlainText(formatted_message)
                        # Force scroll to bottom by moving cursor to end
                        window.log_display.moveCursor(QTextCursor.MoveOperation.End)
                        window.log_display.ensureCursorVisible()
                    else:
                        # Remove closed windows
                        self.detached_log_windows.remove(window)
                except:
                    # Remove invalid windows
                    try:
                        self.detached_log_windows.remove(window)
                    except:
                        pass
    
    def show_options_dialog(self):
        """Show application options dialog - DEPRECATED: Redirects to Settings tab for backwards compatibility"""
        # Redirect to Settings tab instead of showing dialog
        self._go_to_settings_tab()
    
    def open_api_keys_file(self):
        """Open API keys file in system text editor"""
        api_keys_file = self.user_data_path / "api_keys.txt"
        
        # Create file if it doesn't exist
        if not api_keys_file.exists():
            try:
                # Copy from example file
                example_file = self.user_data_path / "api_keys.example.txt"
                if example_file.exists():
                    import shutil
                    shutil.copy(example_file, api_keys_file)
                    self.log(f"‚úì Created api_keys.txt from example")
                else:
                    # Create basic file
                    with open(api_keys_file, 'w') as f:
                        f.write("# Add your API keys here\n")
                        f.write("# openai=sk-your-key\n")
                        f.write("# claude=sk-ant-your-key\n")
                        f.write("# gemini=your-key\n")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not create api_keys.txt: {str(e)}")
                return
        
        # Open in system editor
        try:
            import subprocess
            import platform
            if platform.system() == 'Windows':
                os.startfile(api_keys_file)  # type: ignore
            elif platform.system() == 'Darwin':  # macOS
                subprocess.run(['open', str(api_keys_file)])
            else:  # Linux
                subprocess.run(['xdg-open', str(api_keys_file)])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open api_keys.txt: {str(e)}")
    
    def _go_to_settings_tab(self, subtab_name: str = None):
        """Navigate to Settings tab (from menu), optionally to a specific sub-tab
        
        Args:
            subtab_name: Name of the sub-tab to navigate to (e.g., "AI Settings")
        """
        if hasattr(self, 'main_tabs'):
            # Main tabs: Grid=0, Resources=1, QuickMenu=2, Tools=3, Settings=4
            self.main_tabs.setCurrentIndex(4)
            
            # Navigate to specific sub-tab if requested
            if subtab_name and hasattr(self, 'settings_tabs'):
                for i in range(self.settings_tabs.count()):
                    if subtab_name.lower() in self.settings_tabs.tabText(i).lower():
                        self.settings_tabs.setCurrentIndex(i)
                        
                        # If navigating to AI Settings, scroll to bottom (API keys section)
                        if "ai settings" in subtab_name.lower() and hasattr(self, 'ai_settings_scroll'):
                            # Use QTimer to ensure the tab is fully rendered before scrolling
                            from PyQt6.QtCore import QTimer
                            QTimer.singleShot(100, lambda: self.ai_settings_scroll.verticalScrollBar().setValue(
                                self.ai_settings_scroll.verticalScrollBar().maximum()
                            ))
                        break
    
    def _go_to_superlookup(self):
        """Navigate to Superlookup in Tools tab"""
        if hasattr(self, 'main_tabs'):
            # Main tabs: Grid=0, Resources=1, QuickMenu=2, Tools=3, Settings=4
            self.main_tabs.setCurrentIndex(3)  # Switch to Tools tab
            # Then switch to Superlookup sub-tab
            if hasattr(self, 'modules_tabs'):
                # Find Superlookup index in modules tabs
                for i in range(self.modules_tabs.count()):
                    if "Superlookup" in self.modules_tabs.tabText(i):
                        self.modules_tabs.setCurrentIndex(i)
                        break
    
    def _navigate_to_tool(self, tool_name: str):
        """Navigate to a specific tool in the Tools tab"""
        if hasattr(self, 'main_tabs'):
            # Main tabs: Grid=0, Resources=1, QuickMenu=2, Tools=3, Settings=4
            self.main_tabs.setCurrentIndex(3)  # Switch to Tools tab
            # Then switch to the specific tool sub-tab
            if hasattr(self, 'modules_tabs'):
                for i in range(self.modules_tabs.count()):
                    if tool_name in self.modules_tabs.tabText(i):
                        self.modules_tabs.setCurrentIndex(i)
                        break
    
    def open_api_keys_file(self):
        """Open API keys file in system text editor"""
        api_keys_file = self.user_data_path / "api_keys.txt"
        
        # Create file if it doesn't exist
        if not api_keys_file.exists():
            try:
                # Copy from example file
                example_file = self.user_data_path / "api_keys.example.txt"
                if example_file.exists():
                    import shutil
                    shutil.copy(example_file, api_keys_file)
                    self.log(f"‚úì Created api_keys.txt from example")
                else:
                    # Create basic file
                    with open(api_keys_file, 'w') as f:
                        f.write("# Add your API keys here\n")
                        f.write("# openai=sk-your-key\n")
                        f.write("# claude=sk-ant-your-key\n")
                        f.write("# gemini=your-key\n")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not create api_keys.txt: {str(e)}")
                return
        
        # Open in system editor
        try:
            import subprocess
            import platform
            
            if platform.system() == 'Windows':
                os.startfile(api_keys_file)
            elif platform.system() == 'Darwin':  # macOS
                subprocess.call(['open', api_keys_file])
            else:  # Linux
                subprocess.call(['xdg-open', api_keys_file])
                
            self.log(f"‚úì Opened {api_keys_file}")
        except Exception as e:
            QMessageBox.information(
                self, "API Keys File",
                f"Please edit this file manually:\n\n{api_keys_file}"
            )
    
    def load_llm_settings(self) -> Dict[str, str]:
        """Load LLM settings from user preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        if not prefs_file.exists():
            return {
                'provider': 'openai',
                'openai_model': 'gpt-4o',
                'claude_model': 'claude-sonnet-4-5-20250929',
                'gemini_model': 'gemini-2.5-flash',
                'ollama_model': 'qwen2.5:7b'
            }
        
        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                return prefs.get('llm_settings', {
                    'provider': 'openai',
                    'openai_model': 'gpt-4o',
                    'claude_model': 'claude-sonnet-4-5-20250929',
                    'gemini_model': 'gemini-2.5-flash',
                    'ollama_model': 'qwen2.5:7b'
                })
        except:
            return {
                'provider': 'openai',
                'openai_model': 'gpt-4o',
                'claude_model': 'claude-sonnet-4-5-20250929',
                'gemini_model': 'gemini-2.5-flash',
                'ollama_model': 'qwen2.5:7b'
            }
    
    def save_llm_settings(self, settings: Dict[str, str]):
        """Save LLM settings to user preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        # Load existing preferences
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        # Update LLM settings
        prefs['llm_settings'] = settings
        
        # Save back
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save LLM settings: {str(e)}")
    
    def load_provider_enabled_states(self) -> Dict[str, bool]:
        """Load provider enable/disable states from user preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        if not prefs_file.exists():
            # Default: all providers enabled
            return {
                'llm_openai': True,
                'llm_claude': True,
                'llm_gemini': True,
                'llm_ollama': True,
                'mt_google_translate': True,
                'mt_deepl': True,
                'mt_microsoft': True,
                'mt_amazon': True,
                'mt_modernmt': True,
                'mt_mymemory': True
            }
        
        try:
            with open(prefs_file, 'r') as f:
                prefs = json.load(f)
                return prefs.get('provider_enabled_states', {
                    'llm_openai': True,
                    'llm_claude': True,
                    'llm_gemini': True,
                    'llm_ollama': True,
                    'mt_google_translate': True,
                    'mt_deepl': True,
                    'mt_microsoft': True,
                    'mt_amazon': True,
                    'mt_modernmt': True,
                    'mt_mymemory': True
                })
        except:
            # Default: all providers enabled
            return {
                'llm_openai': True,
                'llm_claude': True,
                'llm_gemini': True,
                'llm_ollama': True,
                'mt_google_translate': True,
                'mt_deepl': True,
                'mt_microsoft': True,
                'mt_amazon': True,
                'mt_modernmt': True,
                'mt_mymemory': True
            }
    
    def save_provider_enabled_states(self, states: Dict[str, bool]):
        """Save provider enable/disable states to user preferences"""
        prefs_file = self.user_data_path / "ui_preferences.json"
        
        # Load existing preferences
        prefs = {}
        if prefs_file.exists():
            try:
                with open(prefs_file, 'r') as f:
                    prefs = json.load(f)
            except:
                pass
        
        # Update provider enabled states
        prefs['provider_enabled_states'] = states
        
        # Save back
        try:
            with open(prefs_file, 'w') as f:
                json.dump(prefs, f, indent=2)
        except Exception as e:
            self.log(f"‚ö† Could not save provider enabled states: {str(e)}")
    
    def update_warning_banner(self):
        """Show/hide warning banner based on allow_replace_in_source setting"""
        if not hasattr(self, 'warning_banners'):
            return

        stale_keys = []
        for key, banner in self.warning_banners.items():
            if not self._widget_is_alive(banner):
                stale_keys.append(key)
                continue
            if self.allow_replace_in_source:
                banner.show()
            else:
                banner.hide()

        for key in stale_keys:
            self.warning_banners.pop(key, None)
        
        # Update the grid delegate to reflect the new setting
        self.update_grid_delegate()
    
    def update_grid_delegate(self):
        """Update the grid's item delegate to reflect current settings"""
        if hasattr(self, 'table') and self._widget_is_alive(self.table):
            # Recreate the delegate with updated settings
            self.table.setItemDelegate(WordWrapDelegate(None, self.table, self.allow_replace_in_source))
    
    def show_about(self):
        import_layout = QVBoxLayout(import_tab)
        
        import_label = QLabel("<h3>Import TMX File</h3>")
        import_layout.addWidget(import_label)
        
        import_info = QLabel(
            "Import translation memories from TMX files. "
            "Entries will be added to the database for the current language pair."
        )
        import_info.setWordWrap(True)
        import_layout.addWidget(import_info)
        
        # File selection
        file_group = QGroupBox("TMX File")
        file_layout = QHBoxLayout()
        
        file_path_label = QLabel("No file selected")
        file_path_label.setStyleSheet("color: #6b7280;")
        file_layout.addWidget(file_path_label, 1)
        
        selected_file = [None]  # Use list to make it mutable in nested function
        
        def browse_tmx():
            file_path, _ = QFileDialog.getOpenFileName(
                dialog,
                "Select TMX File",
                str(self.user_data_path / "resources"),
                "TMX Files (*.tmx);;All Files (*.*)"
            )
            if file_path:
                selected_file[0] = file_path
                file_path_label.setText(file_path)
                file_path_label.setStyleSheet("color: #22c55e;")
        
        browse_btn = QPushButton("üìÅ Browse...")
        browse_btn.clicked.connect(browse_tmx)
        file_layout.addWidget(browse_btn)
        
        file_group.setLayout(file_layout)
        import_layout.addWidget(file_group)
        
        # Import button
        def import_tmx():
            if not selected_file[0]:
                QMessageBox.warning(dialog, "No File", "Please select a TMX file first.")
                return
            
            if not self.tm_database:
                QMessageBox.warning(dialog, "No Database", "TM database not initialized.")
                return
            
            try:
                # Import TMX file
                tm_id, count = self.tm_database.load_tmx_file(
                    selected_file[0],
                    self.current_project.source_lang,
                    self.current_project.target_lang
                )
                
                QMessageBox.information(
                    dialog,
                    "Import Successful",
                    f"Imported {count} translation entries from TMX file!"
                )
                self.log(f"Imported {count} entries from {selected_file[0]}")
                
                # Clear selection
                selected_file[0] = None
                file_path_label.setText("No file selected")
                file_path_label.setStyleSheet("color: #6b7280;")
                
            except Exception as e:
                QMessageBox.critical(dialog, "Import Error", f"Failed to import TMX file:\n{e}")
        
        import_btn = QPushButton("üì• Import TMX File")
        import_btn.clicked.connect(import_tmx)
        import_btn.setStyleSheet("background-color: #3b82f6; color: white; padding: 10px; font-weight: bold; border: none; outline: none;")
        import_layout.addWidget(import_btn)
        
        import_layout.addStretch()
        tabs.addTab(import_tab, "üì• Import TMX")
        
        # ===== Tab 4: Browse Entries =====
        browse_tab = QWidget()
        browse_layout = QVBoxLayout(browse_tab)
        
        browse_label = QLabel("<h3>Browse TM Entries</h3>")
        browse_layout.addWidget(browse_label)
        
        # Search box
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("üîç Search:"))
        search_input = QLineEdit()
        search_input.setPlaceholderText("Enter search term...")
        search_layout.addWidget(search_input, 1)
        browse_layout.addLayout(search_layout)
        
        # Results table
        results_table = QTableWidget()
        results_table.setColumnCount(3)
        results_table.setHorizontalHeaderLabels(["Source", "Target", "Match %"])
        results_table.horizontalHeader().setStretchLastSection(False)
        results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        results_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        results_table.setColumnWidth(2, 80)
        results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        browse_layout.addWidget(results_table)
        
        def search_tm():
            search_term = search_input.text().strip()
            if not search_term or not self.tm_database:
                results_table.setRowCount(0)
                return
            
            # Get activated TM IDs for current project
            tm_ids = None
            if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                if project_id:
                    tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
            
            try:
                matches = self.tm_database.search_all(search_term, tm_ids=tm_ids, max_matches=50)
                
                results_table.setRowCount(len(matches))
                for i, match in enumerate(matches):
                    source_item = QTableWidgetItem(match.get('source', ''))
                    target_item = QTableWidgetItem(match.get('target', ''))
                    match_pct_item = QTableWidgetItem(f"{match.get('match_pct', 0)}%")
                    
                    # Color code by match percentage
                    match_pct = match.get('match_pct', 0)
                    if match_pct == 100:
                        color = "#22c55e"
                    elif match_pct >= 95:
                        color = "#3b82f6"
                    elif match_pct >= 85:
                        color = "#f59e0b"
                    else:
                        color = "#ef4444"
                    
                    match_pct_item.setForeground(QColor(color))
                    match_pct_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                    
                    results_table.setItem(i, 0, source_item)
                    results_table.setItem(i, 1, target_item)
                    results_table.setItem(i, 2, match_pct_item)
                
            except Exception as e:
                QMessageBox.critical(dialog, "Search Error", f"Failed to search TM: {e}")
        
        search_input.returnPressed.connect(search_tm)
        search_btn = QPushButton("üîç Search")
        search_btn.clicked.connect(search_tm)
        search_layout.addWidget(search_btn)
        
        browse_layout.addWidget(QLabel("<i>Tip: Press Enter to search</i>"))
        
        tabs.addTab(browse_tab, "üîç Browse")
        
        # Add tabs to dialog
        layout.addWidget(tabs)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def _open_url(self, url):
        """Open a URL in system default browser"""
        import webbrowser
        try:
            webbrowser.open(url)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open URL: {e}")

    def _open_superdocs_tab(self):
        """Open the online Supervertaler Help in the user's browser."""
        try:
            # Prefer opening the published online docs
            self._open_url("https://supervertaler.gitbook.io/superdocs/")
        except Exception:
            QMessageBox.information(
                self,
                "Supervertaler Help",
                "Supervertaler Help is available online at https://supervertaler.gitbook.io/superdocs/"
            )

    def check_for_updates(self):
        """Check GitHub for the latest Supervertaler release and report whether the user is up to date."""
        # Temporary simplified behavior: QtNetwork HTTPS update checks can fail/hang on some Windows
        # environments (seen as QNetworkReply "Unknown error"). Until this is revisited, open the
        # GitHub releases page directly.
        try:
            self._open_url("https://github.com/michaelbeijer/Supervertaler/releases/latest")
        except Exception as e:
            QMessageBox.warning(self, "Check for Updates", f"Could not open releases page: {e}")
        return

        if getattr(self, "_update_check_in_progress", False):
            QMessageBox.information(self, "Check for Updates", "An update check is already in progress.")
            return

        self._update_check_in_progress = True
        self._update_check_user_canceled = False
        self._update_check_last_stage = "start"
        self._update_check_any_message_shown = False
        self._update_check_python_fallback_started = False

        def _log_update(msg: str):
            # Always emit something to the terminal in dev mode.
            try:
                print(f"[UPDATE] {msg}", flush=True)
            except Exception:
                pass
            # Also use the app log if available.
            try:
                self.log(f"[Update] {msg}")
            except Exception:
                pass

        _log_update("Checking for updates...")

        progress = QProgressDialog("Checking for updates...", "Cancel", 0, 0, self)
        progress.setWindowTitle("Check for Updates")
        progress.setWindowModality(Qt.WindowModality.ApplicationModal)
        progress.setMinimumDuration(0)
        # Prevent the dialog from auto-disappearing when range is (0, 0)
        progress.setAutoClose(False)
        progress.setAutoReset(False)
        progress.show()

        try:
            progress.destroyed.connect(lambda *_: _log_update("Progress dialog destroyed"))
        except Exception:
            pass

        # Keep references so Qt objects aren't GC'd mid-request
        self._update_check_progress = progress

        if not hasattr(self, "_update_check_net_mgr") or self._update_check_net_mgr is None:
            self._update_check_net_mgr = QNetworkAccessManager(self)

        api_url = QUrl("https://api.github.com/repos/michaelbeijer/Supervertaler/releases/latest")
        fallback_url = QUrl("https://github.com/michaelbeijer/Supervertaler/releases/latest")
        timeout_ms = 15000

        self._update_check_fallback_attempted = False
        # Monotonic request id so stale replies/timeouts can't close/delete the active attempt.
        self._update_check_request_id = int(getattr(self, "_update_check_request_id", 0)) + 1
        active_request_id = self._update_check_request_id

        def is_active_request() -> bool:
            try:
                return bool(getattr(self, "_update_check_in_progress", False)) and int(getattr(self, "_update_check_request_id", 0)) == active_request_id
            except Exception:
                return False

        def abort_current_reply():
            try:
                r = getattr(self, "_update_check_reply", None)
                if r and not r.isFinished():
                    r.abort()
            except Exception:
                pass

        def start_request(kind: str):
            """Start either the API or fallback request."""
            if kind not in {"api", "fallback"}:
                kind = "api"

            self._update_check_last_stage = f"request:{kind}"
            _log_update(f"Starting {kind} request")

            abort_current_reply()

            if kind == "fallback":
                try:
                    progress.setLabelText("Checking for updates (fallback)...")
                except Exception:
                    pass
                url = fallback_url
            else:
                try:
                    progress.setLabelText("Checking for updates...")
                except Exception:
                    pass
                url = api_url

            request = QNetworkRequest(url)
            request.setRawHeader(b"User-Agent", f"Supervertaler/{__version__}".encode("utf-8", errors="ignore"))
            if kind == "api":
                request.setRawHeader(b"Accept", b"application/vnd.github+json")

            r = self._update_check_net_mgr.get(request)
            r.setProperty("sv_update_check_kind", kind)
            r.setProperty("sv_update_check_request_id", active_request_id)
            self._update_check_reply = r

            # Helpful when QtNetwork TLS is misconfigured on Windows.
            try:
                r.sslErrors.connect(
                    lambda errs, rr=r: _log_update(
                        "SSL errors: " + "; ".join(getattr(e, "errorString", lambda: str(e))() for e in errs)
                    )
                )
            except Exception:
                pass

            # Restart timeout for each attempt
            try:
                if hasattr(self, "_update_check_timer") and self._update_check_timer:
                    self._update_check_timer.stop()
            except Exception:
                pass
            timeout_timer.start(timeout_ms)

            r.finished.connect(lambda rr=r: on_finished(rr))

        def finish():
            try:
                try:
                    if hasattr(self, "_update_check_timer") and self._update_check_timer:
                        self._update_check_timer.stop()
                except Exception:
                    pass
                try:
                    progress.close()
                except Exception:
                    pass
            finally:
                # If we got here without showing *any* result/error dialog and the user didn't cancel,
                # surface a minimal explanation so it never feels like a no-op.
                try:
                    unexpected = (not bool(getattr(self, "_update_check_user_canceled", False))) and (not bool(getattr(self, "_update_check_any_message_shown", False)))
                    if unexpected:
                        stage = str(getattr(self, "_update_check_last_stage", "(unknown)"))
                        QMessageBox.warning(
                            self,
                            "Check for Updates",
                            "The update check ended unexpectedly.\n\n"
                            f"Stage: {stage}\n\n"
                            "This is usually caused by a network/SSL issue or a blocked request.",
                        )
                except Exception:
                    pass

                self._update_check_in_progress = False
                try:
                    self._update_check_user_canceled = False
                except Exception:
                    pass
                try:
                    if hasattr(self, "_update_check_reply") and self._update_check_reply:
                        self._update_check_reply.deleteLater()
                except Exception:
                    pass
                self._update_check_reply = None
                self._update_check_timer = None
                self._update_check_progress = None

                try:
                    self._update_check_python_fallback_started = False
                except Exception:
                    pass

                try:
                    self._update_check_fallback_attempted = False
                except Exception:
                    pass

                try:
                    self._update_check_last_stage = "finished"
                except Exception:
                    pass

        def show_offline_error(details: str):
            try:
                self._update_check_any_message_shown = True
                self._update_check_last_stage = "offline_error"
            except Exception:
                pass
            msg = (
                "Could not check for updates (offline or GitHub is unavailable).\n\n"
                f"Details: {details}\n\n"
                "Open the releases page in your browser?"
            )
            choice = QMessageBox.question(
                self,
                "Check for Updates",
                msg,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.Yes,
            )
            if choice == QMessageBox.StandardButton.Yes:
                self._open_url("https://github.com/michaelbeijer/Supervertaler/releases")

        def start_python_fallback(reason: str = ""):
            """Fallback that uses Python's HTTPS stack (urllib) instead of QtNetwork."""
            try:
                if bool(getattr(self, "_update_check_python_fallback_started", False)):
                    _log_update("Python fallback already started; ignoring")
                    return
                self._update_check_python_fallback_started = True
            except Exception:
                pass

            # Stop Qt timeout timer now that we're using Python's stack.
            try:
                if hasattr(self, "_update_check_timer") and self._update_check_timer:
                    self._update_check_timer.stop()
            except Exception:
                pass

            # Abort any in-flight Qt request to avoid late signals.
            abort_current_reply()

            try:
                self._update_check_last_stage = "python_fallback"
            except Exception:
                pass

            reason = (reason or "").strip()
            if reason:
                _log_update(f"Trying Python fallback ({reason})")
            else:
                _log_update("Trying Python fallback")

            try:
                progress.setLabelText("Checking for updates (Python fallback)...")
            except Exception:
                pass

            import threading

            def worker():
                try:
                    info = self._fetch_latest_release_info_from_github(timeout_seconds=6)
                    version = (info.get("version") or "") if isinstance(info, dict) else ""
                    url = (info.get("url") or "") if isinstance(info, dict) else ""

                    def on_ok():
                        if not is_active_request():
                            return
                        if bool(getattr(self, "_update_check_user_canceled", False)):
                            finish()
                            return
                        handle_latest(version, url)
                        finish()

                    QTimer.singleShot(0, on_ok)
                except Exception as e:

                    def on_err():
                        if not is_active_request():
                            return
                        if bool(getattr(self, "_update_check_user_canceled", False)):
                            finish()
                            return
                        show_offline_error(str(e))
                        finish()

                    QTimer.singleShot(0, on_err)

            threading.Thread(target=worker, daemon=True).start()

        def on_timeout():
            # Ignore stale timers from previous attempts.
            try:
                if int(getattr(self, "_update_check_request_id", 0)) != active_request_id:
                    return
            except Exception:
                return

            # If Python fallback is already running, don't start anything else.
            try:
                if bool(getattr(self, "_update_check_python_fallback_started", False)):
                    return
            except Exception:
                return

            kind = "api"
            try:
                r = getattr(self, "_update_check_reply", None)
                if r:
                    k = r.property("sv_update_check_kind")
                    kind = str(k) if k else "api"
            except Exception:
                kind = "api"

            if kind == "api" and not getattr(self, "_update_check_fallback_attempted", False):
                self._update_check_fallback_attempted = True
                start_request("fallback")
                return

            try:
                abort_current_reply()
            finally:
                try:
                    self._update_check_last_stage = "timeout"
                except Exception:
                    pass
                # Try Python fallback first; if it fails it will show the offline dialog.
                start_python_fallback(f"timeout after {timeout_ms // 1000}s")

        timeout_timer = QTimer(self)
        timeout_timer.setSingleShot(True)
        timeout_timer.timeout.connect(on_timeout)
        timeout_timer.start(timeout_ms)
        self._update_check_timer = timeout_timer

        def on_cancel():
            try:
                self._update_check_user_canceled = True
            except Exception:
                pass
            try:
                self._update_check_last_stage = "canceled"
            except Exception:
                pass
            _log_update("User canceled update check")
            abort_current_reply()
            finish()

        progress.canceled.connect(on_cancel)

        def handle_latest(latest_version_text: str, latest_url: str):
            try:
                self._update_check_any_message_shown = True
                self._update_check_last_stage = "result"
            except Exception:
                pass
            latest_version_text = (latest_version_text or "").strip()
            latest_url = (latest_url or "").strip() or "https://github.com/michaelbeijer/Supervertaler/releases"

            current = self._normalize_version_tuple(__version__)
            latest = self._normalize_version_tuple(latest_version_text)

            if not latest:
                QMessageBox.information(
                    self,
                    "Check for Updates",
                    "Could not determine the latest version.\n\nYou can check releases on GitHub.",
                )
                self._open_url(latest_url)
                return

            current_text = self._format_version_for_display(__version__)
            latest_text = self._format_version_for_display(latest_version_text)

            if current < latest:
                msg = (
                    f"You are running {current_text}.\n"
                    f"The latest version is {latest_text}.\n\n"
                    "Open the latest release page?"
                )
                choice = QMessageBox.question(
                    self,
                    "Update Available",
                    msg,
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes,
                )
                if choice == QMessageBox.StandardButton.Yes:
                    self._open_url(latest_url)
            elif current == latest:
                QMessageBox.information(
                    self,
                    "Up to Date",
                    f"You are up to date.\n\nCurrent: {current_text}\nLatest: {latest_text}",
                )
            else:
                QMessageBox.information(
                    self,
                    "Newer Than Latest",
                    f"You are running {current_text}, which is newer than the latest published release ({latest_text}).",
                )

        def on_finished(reply_obj):
            should_finish = True
            # Stale reply (e.g., API reply finishing after we already started fallback).
            try:
                rid = reply_obj.property("sv_update_check_request_id")
                if rid is not None and int(rid) != active_request_id:
                    try:
                        reply_obj.deleteLater()
                    except Exception:
                        pass
                    return
            except Exception:
                # If we can't read the property, play it safe: only proceed if it's the active reply.
                pass

            try:
                if reply_obj is not getattr(self, "_update_check_reply", None):
                    try:
                        reply_obj.deleteLater()
                    except Exception:
                        pass
                    return
            except Exception:
                pass

            try:
                kind = "api"
                try:
                    k = reply_obj.property("sv_update_check_kind")
                    kind = str(k) if k else "api"
                except Exception:
                    kind = "api"

                # If aborted/cancelled/errored, show a useful message
                if reply_obj.error():
                    err = reply_obj.errorString() or "Network error"
                    try:
                        err_code = int(reply_obj.error())
                    except Exception:
                        err_code = -1
                    # Only treat real user cancel/abort as silent. Unexpected aborts should be surfaced.
                    if reply_obj.error() == QNetworkReply.NetworkError.OperationCanceledError:
                        _log_update("Network request aborted (OperationCanceledError)")
                        if not bool(getattr(self, "_update_check_user_canceled", False)):
                            show_offline_error("Update check was aborted unexpectedly.")
                        return

                    _log_update(f"Network error ({kind}) [{err_code}]: {err}")

                    # API can be blocked on some networks; fall back to github.com
                    if kind == "api" and not getattr(self, "_update_check_fallback_attempted", False):
                        self._update_check_fallback_attempted = True
                        # Do not finish here; the fallback attempt becomes the active request.
                        start_request("fallback")
                        should_finish = False
                        return

                    # QtNetwork HTTPS can fail on some systems (often reported as "Unknown error").
                    # Try Python's HTTPS stack before giving up.
                    start_python_fallback(f"qt_network_error {err_code}")
                    should_finish = False
                    return

                if kind == "fallback":
                    # Try to read the redirect location (preferred) because /releases/latest usually 302's.
                    latest_url_text = "https://github.com/michaelbeijer/Supervertaler/releases"
                    latest_version_text = ""

                    try:
                        status = reply_obj.attribute(QNetworkRequest.Attribute.HttpStatusCodeAttribute)
                        status_code = int(status) if status is not None else 0
                    except Exception:
                        status_code = 0

                    try:
                        location = bytes(reply_obj.rawHeader(b"Location")).decode("utf-8", errors="replace").strip()
                    except Exception:
                        location = ""

                    if status_code in {301, 302, 303, 307, 308} and location:
                        if location.startswith("/"):
                            latest_url_text = "https://github.com" + location
                        else:
                            latest_url_text = location

                        m = re.search(r"v?\d+(?:\.\d+)+", location)
                        if m:
                            latest_version_text = m.group(0)
                    else:
                        # No redirect header; fall back to parsing the HTML.
                        raw = bytes(reply_obj.readAll()).decode("utf-8", errors="replace")
                        m = re.search(r"Release\s+v?(\d+(?:\.\d+)+)", raw, re.IGNORECASE)
                        if m:
                            latest_version_text = m.group(1)

                    handle_latest(latest_version_text, latest_url_text)
                    return

                # API JSON path
                raw = bytes(reply_obj.readAll())
                data = json.loads(raw.decode("utf-8", errors="replace"))
                tag = (data.get("tag_name") or "").strip()
                name = (data.get("name") or "").strip()
                latest_version_text = tag or name
                latest_url = (data.get("html_url") or "").strip() or "https://github.com/michaelbeijer/Supervertaler/releases"

                handle_latest(latest_version_text, latest_url)
            except Exception as e:
                _log_update(f"Exception while parsing update info: {e}")
                show_offline_error(str(e))
            finally:
                if should_finish:
                    finish()

        start_request("api")

    def _fetch_latest_release_info_from_github(self, timeout_seconds: int = 6) -> dict:
        """Return {version, url} for the latest GitHub release, best-effort.

        Uses the public GitHub API. No auth required.
        """
        import urllib.request

        api_url = "https://api.github.com/repos/michaelbeijer/Supervertaler/releases/latest"
        req = urllib.request.Request(
            api_url,
            headers={
                "Accept": "application/vnd.github+json",
                "User-Agent": f"Supervertaler/{__version__}",
            },
        )

        with urllib.request.urlopen(req, timeout=timeout_seconds) as response:
            data = json.loads(response.read().decode("utf-8", errors="replace"))

        tag = (data.get("tag_name") or "").strip()
        name = (data.get("name") or "").strip()
        version = tag or name
        url = (data.get("html_url") or "").strip() or "https://github.com/michaelbeijer/Supervertaler/releases"

        return {"version": version, "url": url}

    def _normalize_version_tuple(self, version_text: str) -> tuple:
        """Convert a version like 'v1.9.100' to a comparable tuple of ints."""
        if not version_text:
            return ()
        text = str(version_text).strip()
        if text.lower().startswith("v"):
            text = text[1:]

        parts = [int(p) for p in re.findall(r"\d+", text)]
        return tuple(parts)

    def _format_version_for_display(self, version_text: str) -> str:
        """Return a user-friendly version string like 'v1.9.100'."""
        if not version_text:
            return "(unknown)"
        text = str(version_text).strip()
        if not text.lower().startswith("v"):
            return f"v{text}"
        return text

    def _build_version_info_text(self) -> str:
        """Build a support-friendly version/system info block for clipboard."""
        import platform
        from PyQt6.QtCore import QT_VERSION_STR, PYQT_VERSION_STR

        lines = []
        lines.append(f"Supervertaler {self._format_version_for_display(__version__)}")
        try:
            lines.append(f"Release date: {__release_date__}")
        except Exception:
            pass
        try:
            lines.append(f"Edition: {__edition__} (phase {__phase__})")
        except Exception:
            pass

        lines.append("")
        lines.append(f"OS: {platform.platform()}")
        lines.append(f"Architecture: {platform.machine()}")
        lines.append(f"Python: {platform.python_version()} ({platform.python_implementation()})")
        lines.append(f"Qt: {QT_VERSION_STR}")
        lines.append(f"PyQt: {PYQT_VERSION_STR}")
        lines.append(f"Frozen (PyInstaller): {bool(getattr(sys, 'frozen', False))}")
        lines.append(f"Executable: {sys.executable}")

        return "\n".join(lines)

    def copy_version_info_to_clipboard(self):
        """Copy version info to clipboard for easy sharing in support requests."""
        try:
            text = self._build_version_info_text()
            clipboard = QApplication.clipboard()
            clipboard.setText(text)
            QMessageBox.information(
                self,
                "Version Info Copied",
                "Version info has been copied to your clipboard.\n\n"
                "Tip: Paste it into an email or GitHub issue.",
            )
        except Exception as e:
            QMessageBox.warning(self, "Copy Failed", f"Could not copy version info: {e}")
    
    def _show_ahk_setup_from_menu(self):
        """Show AutoHotkey setup dialog from Help menu"""
        if hasattr(self, 'lookup_tab') and self.lookup_tab:
            self.lookup_tab._show_autohotkey_setup_dialog()
        else:
            QMessageBox.warning(
                self,
                "Superlookup Not Available",
                "Superlookup tab is not available. Please restart the application."
            )

    def show_about(self):
        """Show about dialog with clickable website link"""
        dialog = QDialog(self)
        dialog.setWindowTitle("About Supervertaler")
        dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(10)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Title
        title = QLabel(f"<h2>Supervertaler v{__version__}</h2>")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        # Description
        desc = QLabel("<p><b>AI-enhanced tool for translators & writers</b></p>")
        desc.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(desc)

        # Links section
        links_label = QLabel(
            '<p style="text-align: center;">'
            '<b>Project:</b> <a href="https://supervertaler.com/" style="color: #1976D2; text-decoration: none;">supervertaler.com</a><br>'
            '<b>Author:</b> <a href="https://michaelbeijer.co.uk/" style="color: #1976D2; text-decoration: none;">michaelbeijer.co.uk</a>'
            '</p>'
        )
        links_label.setOpenExternalLinks(True)
        links_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(links_label)

        # Additional info
        info = QLabel(
            "<p style='text-align: center;'><b>License:</b> MIT</p>"
            "<hr>"
            "<p style='text-align: center; color: #666; font-size: 9pt;'>"
            "Built with PyQt6 ‚Ä¢ Supports OpenAI, Claude, Gemini & Ollama"
            "</p>"
        )
        info.setWordWrap(True)
        layout.addWidget(info)

        # Buttons
        btn_row = QHBoxLayout()
        copy_btn = QPushButton("üìã Copy Version Info")
        copy_btn.setToolTip("Copy version and system info to clipboard")
        copy_btn.clicked.connect(self.copy_version_info_to_clipboard)
        btn_row.addWidget(copy_btn)

        update_btn = QPushButton("üîÑ Check for Updates...")
        update_btn.setToolTip("Check whether you are running the latest Supervertaler release")
        update_btn.clicked.connect(self.check_for_updates)
        btn_row.addWidget(update_btn)

        btn_row.addStretch(1)

        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        btn_row.addWidget(close_btn)

        layout.addLayout(btn_row)

        dialog.exec()
    
    def closeEvent(self, event):
        """Handle window close event"""
        # Check if Whisper model is downloading
        if self.is_loading_model:
            model_sizes = {
                'tiny': '75 MB',
                'base': '142 MB',
                'small': '466 MB',
                'medium': '1.5 GB',
                'large': '2.9 GB'
            }
            size = model_sizes.get(self.loading_model_name, 'unknown size')

            reply = QMessageBox.warning(
                self,
                "‚ö†Ô∏è Supervoice Model Downloading",
                f"Supervoice is currently downloading the '{self.loading_model_name}' model ({size}).\n\n"
                f"If you close now, the download will be interrupted and the model\n"
                f"file may become corrupted. You would need to delete the incomplete\n"
                f"file manually and re-download.\n\n"
                f"Download location:\n"
                f"{self._get_whisper_cache_path()}\n\n"
                f"Do you want to force quit anyway?",
                QMessageBox.StandardButton.No | QMessageBox.StandardButton.Yes,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.No:
                event.ignore()
                return

        # Check for unsaved project changes
        if self.project_modified:
            reply = QMessageBox.question(
                self,
                "Unsaved Changes",
                "You have unsaved changes. Do you want to save before closing?",
                QMessageBox.StandardButton.Save |
                QMessageBox.StandardButton.Discard |
                QMessageBox.StandardButton.Cancel
            )

            if reply == QMessageBox.StandardButton.Save:
                self.save_project()
                self._cleanup_web_views()
                self._close_detached_log_windows()
                event.accept()
            elif reply == QMessageBox.StandardButton.Discard:
                self._cleanup_web_views()
                self._close_detached_log_windows()
                event.accept()
            else:
                event.ignore()
        else:
            self._cleanup_web_views()
            self._close_detached_log_windows()
            event.accept()
    
    def _cleanup_web_views(self):
        """Clean up WebEngine views - DISABLED to prevent crash"""
        # WebEngine cleanup has been disabled because it was causing Python crashes
        # on program exit. Qt will handle WebEngine cleanup automatically, though
        # you may see a "Release of profile requested" warning which is harmless.
        print("[WebEngine Cleanup] Skipping manual cleanup - letting Qt handle it")
        pass
    
    def _close_detached_log_windows(self):
        """Close all detached log windows when main window closes"""
        try:
            if hasattr(self, 'detached_log_windows'):
                for log_window in list(self.detached_log_windows):
                    try:
                        log_window.close()
                    except:
                        pass
                self.detached_log_windows.clear()
        except:
            pass

    def _get_whisper_cache_path(self):
        """Get the Whisper model cache directory path"""
        import os
        if os.name == 'nt':  # Windows
            return os.path.join(os.environ.get('USERPROFILE', ''), '.cache', 'whisper')
        else:  # Linux/Mac
            return os.path.expanduser('~/.cache/whisper')
    
    # =========================================================================
    # LLM TRANSLATION INTEGRATION
    # =========================================================================
    
    def translate_current_segment(self):
        """Translate currently selected segment using LLM (Ctrl+T)"""
        current_row = self.table.currentRow()
        if current_row < 0 or not self.current_project:
            QMessageBox.warning(self, "No Selection", "Please select a segment to translate.")
            return
        
        segment = self.current_project.segments[current_row]
        
        if not segment.source.strip():
            QMessageBox.warning(self, "Empty Source", "Cannot translate empty source text.")
            return
        
        # Load LLM settings first to check provider
        settings = self.load_llm_settings()
        provider = settings.get('provider', 'openai')
        
        # Get model based on provider
        model_key = f'{provider}_model'
        model = settings.get(model_key, 'gpt-4o')
        
        # Ollama doesn't need API keys - it's local
        if provider == 'ollama':
            api_keys = {'ollama': 'not-needed'}  # Placeholder - Ollama doesn't use API keys
        else:
            # Load API keys for cloud providers
            api_keys = self.load_api_keys()
            if not api_keys:
                reply = QMessageBox.question(
                    self, "API Keys Missing",
                    "No API keys found. Would you like to configure them now?\n\n"
                    f"Keys should be in: {self.user_data_path / 'api_keys.txt'}",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self._go_to_settings_tab("AI Settings")
                return
            
            # Check if API key exists for selected provider
            # Note: 'gemini' and 'google' are aliases for the same API key
            has_api_key = provider in api_keys or (provider == 'gemini' and 'google' in api_keys)
            if not has_api_key:
                reply = QMessageBox.question(
                    self, f"{provider.title()} API Key Missing",
                    f"{provider.title()} API key not found in api_keys.txt\n\n"
                    f"Would you like to configure it now?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if reply == QMessageBox.StandardButton.Yes:
                    self._go_to_settings_tab()
                return
        
        try:
            self.status_bar.showMessage(f"Translating segment #{segment.id} with {provider} ({model})...")
            QApplication.processEvents()  # Update UI
            
            # For Ollama (local LLM), show a progress dialog since it can take a while
            progress_dialog = None
            elapsed_timer = None
            start_time = None
            
            if provider == 'ollama':
                from PyQt6.QtCore import QTimer, QElapsedTimer
                import time
                
                progress_dialog = QDialog(self)
                progress_dialog.setWindowTitle("Local LLM Translation")
                progress_dialog.setModal(False)  # Non-modal so we can update it
                progress_dialog.setMinimumWidth(400)
                progress_layout = QVBoxLayout(progress_dialog)
                
                progress_header = QLabel(f"<h3>üñ•Ô∏è Translating with Local LLM</h3>")
                progress_layout.addWidget(progress_header)
                
                progress_info = QLabel(
                    f"<b>Model:</b> {model}<br>"
                    f"<b>Segment:</b> #{segment.id}<br><br>"
                    f"<i>Local LLM translation may take 10-60 seconds depending on your hardware...</i>"
                )
                progress_info.setWordWrap(True)
                progress_layout.addWidget(progress_info)
                
                # Animated progress bar (indeterminate)
                progress_bar = QProgressBar()
                progress_bar.setRange(0, 0)  # Indeterminate mode
                progress_bar.setTextVisible(False)
                progress_layout.addWidget(progress_bar)
                
                # Elapsed time label
                elapsed_label = QLabel("‚è±Ô∏è Elapsed: 0 seconds")
                elapsed_label.setStyleSheet("color: #333; font-weight: bold; padding: 5px 0;")
                progress_layout.addWidget(elapsed_label)
                
                progress_status = QLabel("‚è≥ Processing... (CPU usage is normal)")
                progress_status.setStyleSheet("color: #666; padding: 5px 0;")
                progress_layout.addWidget(progress_status)
                
                # Store references
                progress_dialog.status_label = progress_status
                progress_dialog.elapsed_label = elapsed_label
                
                # Setup elapsed time counter
                start_time = time.time()
                
                def update_elapsed():
                    if start_time and hasattr(progress_dialog, 'elapsed_label'):
                        elapsed = int(time.time() - start_time)
                        progress_dialog.elapsed_label.setText(f"‚è±Ô∏è Elapsed: {elapsed} seconds")
                        QApplication.processEvents()
                
                elapsed_timer = QTimer()
                elapsed_timer.timeout.connect(update_elapsed)
                elapsed_timer.start(1000)  # Update every second
                
                progress_dialog.show()
                QApplication.processEvents()
            
            # Use modular LLM client with user's settings
            from modules.llm_clients import LLMClient
            
            # Get API key (handle gemini/google alias)
            api_key = api_keys.get(provider) or (api_keys.get('google') if provider == 'gemini' else None)
            client = LLMClient(
                api_key=api_key,
                provider=provider,
                model=model
            )
            
            # Check TM before API call if enabled
            general_prefs = self.load_general_settings()
            check_tm_before_api = general_prefs.get('check_tm_before_api', True)
            check_tm_exact_only = general_prefs.get('check_tm_exact_only', False)
            tm_match = None
            
            if check_tm_before_api and self.tm_database:
                # Get activated TM IDs for current project
                tm_ids = None
                if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                    project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                    if project_id:
                        tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                
                try:
                    if check_tm_exact_only:
                        # Use exact match only (faster - O(1) hash lookup)
                        exact_match = self.tm_database.get_exact_match(segment.source, tm_ids=tm_ids)
                        if exact_match:
                            tm_match = exact_match.get('target_text', '')
                            self.log(f"‚úì Found 100% TM match (exact) for segment #{segment.id}")
                    else:
                        # Use fuzzy search (includes 100% matches)
                        matches = self.tm_database.search_all(segment.source, tm_ids=tm_ids, enabled_only=False, max_matches=1)
                        if matches and matches[0].get('match_pct', 0) == 100:
                            tm_match = matches[0].get('target', '')
                            self.log(f"‚úì Found 100% TM match for segment #{segment.id}")
                except Exception as e:
                    self.log(f"‚ö† TM check error: {e}")
            
            # If we have a 100% match and auto-insert is enabled, use it
            auto_insert_100 = general_prefs.get('auto_insert_100', False)
            if tm_match and auto_insert_100:
                # Auto-insert the TM match
                segment.target = tm_match
                segment.status = "translated"
                self.project_modified = True
                self.update_window_title()
                
                # Update grid (using cell widget)
                target_widget = self.table.cellWidget(current_row, 3)
                if target_widget and isinstance(target_widget, EditableGridTextEditor):
                    target_widget.setPlainText(tm_match)
                else:
                    # Fallback if widget doesn't exist
                    self.table.setItem(current_row, 3, QTableWidgetItem(tm_match))
                self.update_status_icon(current_row, "translated")
                
                # Auto-resize the row to fit the new content
                self._auto_resize_single_row(current_row)
                
                # Add to TM if not already there
                if self.tm_database:
                    try:
                        self.tm_database.add_to_project_tm(segment.source, tm_match)
                    except:
                        pass
                
                self.log(f"‚úì Auto-inserted 100% TM match for segment #{segment.id}")
                self.status_bar.showMessage(f"‚úì Segment #{segment.id} translated from TM (100% match)", 3000)
                return
            
            # Build prompt - use optimized prompt for local LLM (Ollama)
            custom_prompt = None
            
            if provider == 'ollama':
                # Use a focused but context-aware prompt for local LLMs
                source_lang = self.current_project.source_lang
                target_lang = self.current_project.target_lang
                
                # Get 2-3 surrounding segments for context (not 5+ like cloud LLMs)
                context_lines = []
                surrounding_count = 2  # Fewer segments for faster inference
                
                try:
                    start_idx = max(0, current_row - surrounding_count)
                    end_idx = min(len(self.current_project.segments), current_row + surrounding_count + 1)
                    
                    for i in range(start_idx, end_idx):
                        seg = self.current_project.segments[i]
                        if i == current_row:
                            continue  # Skip current segment
                        if seg.target and seg.target.strip():
                            # Show already translated segments as reference
                            context_lines.append(f"‚Ä¢ {seg.source[:80]}{'...' if len(seg.source) > 80 else ''}")
                            context_lines.append(f"  ‚Üí {seg.target[:80]}{'...' if len(seg.target) > 80 else ''}")
                except:
                    pass
                
                # Build optimized prompt
                prompt_parts = [f"You are a professional translator ({source_lang} ‚Üí {target_lang})."]
                
                
                # Add surrounding segment context
                if context_lines:
                    context_section = "\n".join(context_lines)
                    prompt_parts.append("")
                    prompt_parts.append("Context from surrounding segments:")
                    prompt_parts.append(context_section)
                
                # Add the segment to translate
                prompt_parts.append("")
                prompt_parts.append("Translate this segment accurately. Output ONLY the translation:")
                prompt_parts.append(segment.source)
                prompt_parts.append("")
                prompt_parts.append("Translation:")
                
                custom_prompt = "\n".join(prompt_parts)
                
                self.log(f"  Using optimized Ollama prompt ({len(custom_prompt)} chars, {len(context_lines)//2} context segs)")
            
            elif hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt:
                try:
                    # Get surrounding segments if enabled
                    surrounding_segments = general_prefs.get('surrounding_segments', 5)
                    surrounding_context = ""
                    
                    if surrounding_segments > 0:
                        try:
                            current_idx = current_row
                            start_idx = max(0, current_idx - surrounding_segments)
                            end_idx = min(len(self.current_project.segments), current_idx + surrounding_segments + 1)
                            surrounding = self.current_project.segments[start_idx:end_idx]
                            
                            if len(surrounding) > 1:  # Only add if we have surrounding segments
                                context_parts = []
                                for i, seg in enumerate(surrounding):
                                    actual_idx = start_idx + i
                                    if actual_idx == current_idx:
                                        context_parts.append(f">>> {seg.id}. {seg.source} <<<  [TRANSLATE THIS]")
                                    else:
                                        context_parts.append(f"{seg.id}. {seg.source}")
                                        if seg.target:
                                            context_parts.append(f"    ‚Üí {seg.target}")
                                
                                surrounding_context = "\n\n**SURROUNDING SEGMENTS FOR CONTEXT:**\n"
                                surrounding_context += "(The segment marked with >>> <<< is the one to translate)\n\n"
                                surrounding_context += "\n".join(context_parts)
                                self.log(f"  Including {len(surrounding)} surrounding segments ({surrounding_segments} before/after)")
                        except Exception as e:
                            self.log(f"‚ö† Could not add surrounding segments: {e}")
                    
                    # Get glossary terms for AI injection
                    glossary_terms = self.get_ai_inject_glossary_terms()

                    custom_prompt = self.prompt_manager_qt.build_final_prompt(
                        source_text=segment.source,
                        source_lang=self.current_project.source_lang,
                        target_lang=self.current_project.target_lang,
                        mode="single",
                        glossary_terms=glossary_terms
                    )

                    # Add surrounding context before the translation delimiter
                    if surrounding_context:
                        # Insert before the "YOUR TRANSLATION" delimiter
                        if "**YOUR TRANSLATION" in custom_prompt:
                            custom_prompt = custom_prompt.replace(
                                "**YOUR TRANSLATION",
                                surrounding_context + "\n\n**YOUR TRANSLATION"
                            )
                        else:
                            custom_prompt += surrounding_context
                            
                except Exception as e:
                    self.log(f"‚ö† Could not build prompt from manager: {e}")
            
            # Check for figure references and prepare images if available
            images = None
            if self.figure_context and self.figure_context.has_images():
                try:
                    # Detect figure references in source text
                    figure_refs = self.figure_context.detect_figure_references(segment.source)
                    if figure_refs:
                        self.log(f"  üñºÔ∏è Detected figure references in segment #{segment.id}: {', '.join(figure_refs)}")
                        # Get images for detected figures
                        images_for_text = self.figure_context.get_images_for_text(segment.source)
                        if images_for_text:
                            # Check if model supports vision
                            if LLMClient.model_supports_vision(provider, model):
                                # Convert PIL images to appropriate format for provider
                                if provider == "gemini":
                                    # Gemini uses PIL.Image directly
                                    images = images_for_text
                                else:
                                    # OpenAI and Claude use base64 PNG
                                    images = [
                                        (ref, self.figure_context.pil_image_to_base64_png(img))
                                        for ref, img in images_for_text
                                    ]
                                self.log(f"  ‚úÖ Including {len(images)} figure images: {', '.join(figure_refs)}")
                            else:
                                self.log(f"  ‚ö†Ô∏è Figures detected ({', '.join(figure_refs)}) but model '{model}' doesn't support vision")
                        else:
                            self.log(f"  ‚ö†Ô∏è Figure references detected but no matching images found in loaded folder")
                except Exception as e:
                    self.log(f"  ‚ö†Ô∏è Could not load figures: {e}")
            
            # Translate using the module
            translation = client.translate(
                text=segment.source,
                source_lang=self.current_project.source_lang,
                target_lang=self.current_project.target_lang,
                custom_prompt=custom_prompt,
                images=images
            )
            
            if translation:
                # Update segment
                segment.target = translation
                segment.status = "translated"
                
                # Update grid - Column 3 is Target (using cell widget)
                target_widget = self.table.cellWidget(current_row, 3)
                if target_widget and isinstance(target_widget, EditableGridTextEditor):
                    target_widget.setPlainText(translation)
                else:
                    # Fallback: create new widget if none exists
                    self.table.setItem(current_row, 3, QTableWidgetItem(translation))
                self.update_status_icon(current_row, "translated")
                
                # Auto-resize the row to fit the new content
                self._auto_resize_single_row(current_row)
                
                # Add to Translation Memory
                if self.tm_database:
                    try:
                        self.tm_database.add_to_project_tm(segment.source, translation)
                        self.log(f"‚úì Added to TM: {segment.source[:30]}... ‚Üí {translation[:30]}...")
                    except Exception as tm_error:
                        self.log(f"‚ö† Could not add to TM: {str(tm_error)}")
                
                # Mark project as modified
                self.project_modified = True
                self.update_window_title()
                
                self.log(f"‚úì Segment #{segment.id} translated with {provider}/{model}")
                self.status_bar.showMessage(f"‚úì Segment #{segment.id} translated", 3000)
                
                # Stop elapsed timer and close progress dialog
                if elapsed_timer:
                    elapsed_timer.stop()
                if progress_dialog:
                    progress_dialog.close()
            else:
                self.log(f"‚úó Translation failed for segment #{segment.id}")
                # Stop elapsed timer and close progress dialog
                if elapsed_timer:
                    elapsed_timer.stop()
                if progress_dialog:
                    progress_dialog.close()
                QMessageBox.warning(self, "Translation Failed", "No translation received from LLM.")
                
        except Exception as e:
            # Stop elapsed timer and close progress dialog
            if 'elapsed_timer' in locals() and elapsed_timer:
                elapsed_timer.stop()
            if 'progress_dialog' in locals() and progress_dialog:
                progress_dialog.close()
            self.log(f"‚úó Translation error: {str(e)}")
            QMessageBox.critical(self, "Translation Error", f"Failed to translate segment:\n\n{str(e)}")
            self.status_bar.showMessage("Translation failed", 3000)

    # =========================================================================
    # GRID QUICKMENU
    # =========================================================================

    def _quickmenu_get_selection_text(self, widget: QTextEdit) -> str:
        """Get selected text (or full text) from a QTextEdit, normalized for LLMs."""
        cursor = widget.textCursor()
        text = cursor.selectedText() if cursor.hasSelection() else widget.toPlainText()
        text = (text or "").replace('\u2029', '\n')

        # Reverse invisible-character display markers if present
        try:
            if hasattr(self, 'reverse_invisible_replacements'):
                text = self.reverse_invisible_replacements(text)
        except Exception:
            pass

        return text.strip()

    def _quickmenu_build_custom_prompt(self, prompt_relative_path: str, source_text: str, source_lang: str, target_lang: str) -> str:
        """Build a prompt for QuickMenu using the selected prompt as instructions.
        
        This is a GENERIC prompt builder (not translation-specific) that allows QuickMenu prompts
        to do anything: explain, define, search, translate, analyze, etc.
        
        Supports placeholders:
        - {{SELECTION}} or {{SOURCE_TEXT}} - The selected text
        - {{SOURCE_LANGUAGE}} - Source language name
        - {{TARGET_LANGUAGE}} - Target language name
        - {{SOURCE+TARGET_CONTEXT}} - Project segments with both source and target (for proofreading)
        - {{SOURCE_CONTEXT}} - Project segments with source only (for translation questions)
        - {{TARGET_CONTEXT}} - Project segments with target only (for consistency/style analysis)
        """
        if not hasattr(self, 'prompt_manager_qt') or not self.prompt_manager_qt:
            raise RuntimeError("Prompt manager not available")

        pm = self.prompt_manager_qt
        lib = getattr(pm, 'library', None)
        if not lib:
            raise RuntimeError("Prompt library not available")

        prompt_data = lib.prompts.get(prompt_relative_path)
        if not prompt_data:
            raise RuntimeError(f"Prompt not found: {prompt_relative_path}")

        prompt_content = (prompt_data.get('content') or "").strip()
        if not prompt_content:
            raise RuntimeError("Prompt content is empty")

        # Build document context if requested (three variants)
        source_target_context = ""
        source_only_context = ""
        target_only_context = ""
        
        has_source_target = "{{SOURCE+TARGET_CONTEXT}}" in prompt_content
        has_source_only = "{{SOURCE_CONTEXT}}" in prompt_content
        has_target_only = "{{TARGET_CONTEXT}}" in prompt_content
        
        if (has_source_target or has_source_only or has_target_only) and hasattr(self, 'current_project') and self.current_project:
            if has_source_target:
                source_target_context = self._build_quickmenu_document_context(mode="both")
                self.log(f"üîç QuickMenu: Built SOURCE+TARGET context ({len(source_target_context)} chars)")
            if has_source_only:
                source_only_context = self._build_quickmenu_document_context(mode="source")
                self.log(f"üîç QuickMenu: Built SOURCE_ONLY context ({len(source_only_context)} chars)")
            if has_target_only:
                target_only_context = self._build_quickmenu_document_context(mode="target")
                self.log(f"üîç QuickMenu: Built TARGET_ONLY context ({len(target_only_context)} chars)")
        else:
            if has_source_target:
                self.log("‚ö†Ô∏è QuickMenu: {{SOURCE+TARGET_CONTEXT}} requested but no project loaded")
            if has_source_only:
                self.log("‚ö†Ô∏è QuickMenu: {{SOURCE_CONTEXT}} requested but no project loaded")
            if has_target_only:
                self.log("‚ö†Ô∏è QuickMenu: {{TARGET_CONTEXT}} requested but no project loaded")

        # Replace placeholders in the prompt content
        prompt_content = prompt_content.replace("{{SOURCE_LANGUAGE}}", source_lang)
        prompt_content = prompt_content.replace("{{TARGET_LANGUAGE}}", target_lang)
        prompt_content = prompt_content.replace("{{SOURCE_TEXT}}", source_text)
        prompt_content = prompt_content.replace("{{SELECTION}}", source_text)  # Alternative placeholder
        prompt_content = prompt_content.replace("{{SOURCE+TARGET_CONTEXT}}", source_target_context)
        prompt_content = prompt_content.replace("{{SOURCE_CONTEXT}}", source_only_context)
        prompt_content = prompt_content.replace("{{TARGET_CONTEXT}}", target_only_context)
        
        # Debug: Log the final prompt being sent
        self.log(f"üìù QuickMenu: Final prompt ({len(prompt_content)} chars):")
        self.log("‚îÄ" * 80)
        self.log(prompt_content[:500] + ("..." if len(prompt_content) > 500 else ""))
        self.log("‚îÄ" * 80)
        
        # If the prompt doesn't contain the selection/text, append it
        if "{{SOURCE_TEXT}}" not in prompt_data.get('content', '') and "{{SELECTION}}" not in prompt_data.get('content', ''):
            prompt_content += f"\n\nText:\n{source_text}"
        
        return prompt_content
    
    def _build_quickmenu_document_context(self, mode: str = "both") -> str:
        """Build document context for QuickMenu prompts.
        
        Args:
            mode: One of:
                - "both": Include both source and target text (for proofreading)
                - "source": Include only source text (for translation/terminology questions)
                - "target": Include only target text (for consistency/style analysis)
        
        Returns a formatted string with segments from the project for context.
        Uses the 'quickmenu_context_segments' setting (default: 50% of total segments).
        """
        if not hasattr(self, 'current_project') or not self.current_project or not self.current_project.segments:
            return "(No project context available)"
        
        try:
            # Get settings
            general_prefs = self.load_general_settings()
            context_percent = general_prefs.get('quickmenu_context_percent', 50)  # Default: 50%
            max_context_segments = general_prefs.get('quickmenu_context_max', 100)  # Safety limit
            
            # Calculate how many segments to include
            total_segments = len(self.current_project.segments)
            num_segments = min(
                int(total_segments * context_percent / 100),
                max_context_segments
            )
            
            if num_segments == 0:
                return "(Document context disabled)"
            
            # Get segments (from start of document)
            context_segments = self.current_project.segments[:num_segments]
            
            # Format segments based on mode
            context_parts = []
            mode_labels = {"both": "SOURCE + TARGET", "source": "SOURCE ONLY", "target": "TARGET ONLY"}
            context_parts.append(f"=== DOCUMENT CONTEXT ({mode_labels.get(mode, 'UNKNOWN')}) ===")
            context_parts.append(f"(Showing {num_segments} of {total_segments} segments - {context_percent}%)")
            context_parts.append("")
            
            for seg in context_segments:
                if mode == "both":
                    # Source + Target
                    context_parts.append(f"[{seg.id}] {seg.source}")
                    if seg.target and seg.target.strip():
                        context_parts.append(f"    ‚Üí {seg.target}")
                elif mode == "source":
                    # Source only
                    context_parts.append(f"[{seg.id}] {seg.source}")
                elif mode == "target":
                    # Target only (skip empty targets)
                    if seg.target and seg.target.strip():
                        context_parts.append(f"[{seg.id}] {seg.target}")
                context_parts.append("")  # Blank line between segments
            
            return "\n".join(context_parts)
            
        except Exception as e:
            return f"(Error building document context: {e})"

    def _quickmenu_show_result_dialog(self, title: str, output_text: str, apply_callback=None):
        from PyQt6.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QDialogButtonBox, QPushButton, QApplication

        dlg = QDialog(self)
        dlg.setWindowTitle(title)
        dlg.setMinimumSize(700, 450)
        layout = QVBoxLayout(dlg)

        out = QTextEdit()
        out.setReadOnly(True)
        out.setPlainText(output_text or "")
        layout.addWidget(out)

        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        btn_copy = QPushButton("Copy")
        buttons.addButton(btn_copy, QDialogButtonBox.ButtonRole.ActionRole)
        btn_copy.clicked.connect(lambda: QApplication.clipboard().setText(output_text or ""))

        if apply_callback is not None:
            btn_apply = QPushButton("Replace")
            buttons.addButton(btn_apply, QDialogButtonBox.ButtonRole.AcceptRole)
            btn_apply.clicked.connect(lambda: (apply_callback(), dlg.accept()))

        buttons.rejected.connect(dlg.reject)
        layout.addWidget(buttons)
        dlg.exec()

    def run_grid_quickmenu_prompt(self, prompt_relative_path: str, origin_widget: QTextEdit, behavior: str = "show"):
        """Run a QuickMenu prompt on the current selection and either show the result or replace selection/target."""
        from PyQt6.QtWidgets import QMessageBox, QApplication
        from modules.llm_clients import LLMClient

        if not origin_widget:
            return

        input_text = self._quickmenu_get_selection_text(origin_widget)
        if not input_text:
            QMessageBox.information(self, "QuickMenu", "Please select some text first (or click inside a non-empty cell).")
            return

        # Determine project languages
        source_lang = "English"
        target_lang = "Dutch"
        if hasattr(self, 'current_project') and self.current_project:
            source_lang = getattr(self.current_project, 'source_lang', source_lang) or source_lang
            target_lang = getattr(self.current_project, 'target_lang', target_lang) or target_lang

        # Determine provider/model
        settings = self.load_llm_settings()
        provider = settings.get('provider', 'openai')
        model_key = f'{provider}_model'
        model = settings.get(model_key)

        # Load API keys (unless Ollama)
        if provider == 'ollama':
            api_key = ""
        else:
            api_keys = self.load_api_keys()
            if not api_keys:
                QMessageBox.warning(self, "QuickMenu", "No API keys found. Configure them in Settings first.")
                return
            api_key = api_keys.get(provider) or (api_keys.get('google') if provider == 'gemini' else None)
            if not api_key:
                QMessageBox.warning(self, "QuickMenu", f"No API key found for provider '{provider}'.")
                return

        try:
            self.status_bar.showMessage(f"‚ö° QuickMenu: running '{prompt_relative_path}'‚Ä¶")
            QApplication.processEvents()

            custom_prompt = self._quickmenu_build_custom_prompt(
                prompt_relative_path=prompt_relative_path,
                source_text=input_text,
                source_lang=source_lang,
                target_lang=target_lang
            )

            client = LLMClient(api_key=api_key, provider=provider, model=model)
            
            # Use translate() with empty text and custom_prompt for generic AI completion
            # This allows QuickMenu prompts to do anything (explain, define, search, etc.)
            # not just translation. Same pattern as AI Assistant.
            output_text = client.translate(
                text="",  # Empty - we're using custom_prompt for everything
                source_lang="en",  # Dummy values
                target_lang="en",
                custom_prompt=custom_prompt
            )

            if not output_text:
                QMessageBox.warning(self, "QuickMenu", "No response received from the LLM.")
                return

        except Exception as e:
            QMessageBox.critical(self, "QuickMenu", f"QuickMenu failed:\n\n{e}")
            return
        finally:
            try:
                self.status_bar.clearMessage()
            except Exception:
                pass

        # Decide where to apply replacements
        target_widget = None
        row = getattr(origin_widget, 'row', -1)
        table = getattr(origin_widget, 'table', None) or getattr(origin_widget, 'table_ref', None)

        # If originating from target editor, replace in-place. If from source editor, target is column 3.
        if isinstance(origin_widget, EditableGridTextEditor):
            target_widget = origin_widget
        elif table is not None and row is not None and row >= 0:
            try:
                target_widget = table.cellWidget(row, 3)
            except Exception:
                target_widget = None

        def apply_replacement():
            if not target_widget or not isinstance(target_widget, QTextEdit):
                return
            cursor = target_widget.textCursor()
            cursor.beginEditBlock()
            try:
                if cursor.hasSelection():
                    cursor.insertText(output_text)
                else:
                    cursor.select(cursor.SelectionType.Document)
                    cursor.insertText(output_text)
                target_widget.setTextCursor(cursor)
            finally:
                cursor.endEditBlock()

        if behavior == "replace":
            if not target_widget or not isinstance(target_widget, QTextEdit):
                self._quickmenu_show_result_dialog("‚ö° QuickMenu result", output_text)
                return

            apply_replacement()
            return

        # Default: show dialog (with optional Replace button)
        can_apply = target_widget is not None and isinstance(target_widget, QTextEdit)
        title = "‚ö° QuickMenu result"
        self._quickmenu_show_result_dialog(title, output_text, apply_callback=apply_replacement if can_apply else None)
    
    def translate_multiple_segments(self, scope: str):
        """Translate segments by scope (selected, status-based, or all)."""
        if not self.current_project:
            QMessageBox.warning(self, "No Project", "Please load or create a project first.")
            return

        segments_with_rows: List[Tuple[int, Segment]] = []
        description = ""

        if scope == "selected_not_started":
            selected = self._get_selected_segments_with_rows()
            if not selected:
                QMessageBox.information(
                    self,
                    "No Selection",
                    "Please select one or more segments in the grid or list view first."
                )
                return
            target_statuses = {"not_started"}
            segments_with_rows = [(idx, seg) for idx, seg in selected if seg.status in target_statuses]
            if not segments_with_rows:
                QMessageBox.information(
                    self,
                    "Nothing to Translate",
                    "The selected segments are not marked as 'Not started'."
                )
                return
            description = "selected not-started segment(s)"
        elif scope == "all_not_started":
            target_statuses = {"not_started"}
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
                if seg.status in target_statuses
            ]
            description = "not-started segment(s)"
        elif scope == "all_pretranslated":
            target_statuses = {"pretranslated"}
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
                if seg.status in target_statuses
            ]
            description = "pre-translated segment(s)"
        elif scope == "all_not_started_pretranslated":
            target_statuses = {"not_started", "pretranslated"}
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
                if seg.status in target_statuses
            ]
            description = "not-started and pre-translated segment(s)"
        elif scope == "all_translatable":
            target_statuses = TRANSLATABLE_STATUSES
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
                if seg.status in target_statuses
            ]
            labels = ", ".join(sorted({get_status(s).label for s in target_statuses}))
            description = f"{labels} segment(s)"
        elif scope == "all_segments":
            segments_with_rows = list(enumerate(self.current_project.segments))
            description = "segment(s)"
        elif scope == "all_empty":
            # NEW: Translate only segments with empty target (useful after partial batch translation)
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
                if not seg.target or not seg.target.strip()
            ]
            description = "empty segment(s)"
        elif scope == "filtered_segments":
            # NEW: Translate only currently filtered/visible segments
            segments_with_rows = self._get_filtered_segments_with_rows()
            if not segments_with_rows:
                QMessageBox.information(
                    self,
                    "No Filtered Segments",
                    "No segments are currently visible after filtering.\nClear filters or adjust your filter criteria."
                )
                return
            description = "filtered segment(s)"
        else:
            return

        if not segments_with_rows:
            QMessageBox.information(
                self,
                "Nothing to Translate",
                f"No {description} available for translation."
            )
            return

        segments_with_rows = sorted(segments_with_rows, key=lambda item: item[0])
        self.translate_batch(segments_with_rows=segments_with_rows, scope_description=description)

    def _get_selected_segments_with_rows(self) -> List[Tuple[int, Segment]]:
        """Return selected segments across active views as (row_index, segment)."""
        if not self.current_project:
            return []

        selected_ids = set()

        try:
            for seg in self.get_selected_segments_from_grid():
                if hasattr(seg, 'id'):
                    selected_ids.add(seg.id)
        except Exception:
            pass

        try:
            for seg in self.get_selected_segments_from_list():
                if hasattr(seg, 'id'):
                    selected_ids.add(seg.id)
        except Exception:
            pass

        if not selected_ids:
            return []

        segments_with_rows: List[Tuple[int, Segment]] = []
        for idx, seg in enumerate(self.current_project.segments):
            if seg.id in selected_ids:
                segments_with_rows.append((idx, seg))

        return segments_with_rows

    def _get_filtered_segments_with_rows(self) -> List[Tuple[int, Segment]]:
        """Return currently visible/filtered segments as (row_index, segment)."""
        if not self.current_project:
            return []

        # Check if table is currently filtered
        if not hasattr(self, 'table') or self.table.rowCount() == 0:
            return []

        visible_segments: List[Tuple[int, Segment]] = []
        
        # Iterate through visible rows in the table
        for visual_row in range(self.table.rowCount()):
            if not self.table.isRowHidden(visual_row):
                # Get the segment from this row
                # The visual row index corresponds to the segment index in the project
                if visual_row < len(self.current_project.segments):
                    seg = self.current_project.segments[visual_row]
                    visible_segments.append((visual_row, seg))

        return visible_segments

    def translate_batch(self, segments_with_rows: Optional[List[Tuple[int, Segment]]] = None, scope_description: Optional[str] = None):
        """
        Translate ALL segments in the project using LLM provider.
        
        CRITICAL REQUIREMENTS for memoQ bilingual files:
        - Column 2 (source): Source text to translate
        - Column 3 (target): MUST BE COMPLETELY EMPTY (no pre-translations!)
        - Column 5 (status): Completely ignored by system
        
        The system will translate EVERY segment in the file.
        Users MUST ensure target column is 100% empty before export.
        """
        if not self.current_project:
            QMessageBox.warning(self, "No Project", "Please load or create a project first.")
            return

        if segments_with_rows is None:
            # Translate ALL segments in the project
            # Users must ensure memoQ export has completely empty target column
            segments_with_rows = [
                (idx, seg) for idx, seg in enumerate(self.current_project.segments)
            ]
            scope_description = scope_description or "segment(s)"
        else:
            valid_segments: List[Tuple[int, Segment]] = []
            for row_index, segment in segments_with_rows:
                if 0 <= row_index < len(self.current_project.segments):
                    valid_segments.append((row_index, segment))
            segments_with_rows = valid_segments
            scope_description = scope_description or "segment(s)"

        if not segments_with_rows:
            QMessageBox.information(
                self,
                "Nothing to Translate",
                f"No {scope_description} available for translation."
            )
            return

        segments_to_translate = sorted(segments_with_rows, key=lambda item: item[0])
        total_segments = len(segments_to_translate)
        
        # Log what we found
        self.log(f"üìä Project has {total_segments} segments ‚Üí Will translate ALL of them")
        
        # VALIDATION: Check if any segments already have target text
        segments_with_target = [(idx, seg) for idx, seg in segments_to_translate if seg.target and seg.target.strip()]
        
        if segments_with_target:
            # Show examples of problematic segments
            examples = segments_with_target[:3]
            example_text = "\n".join([
                f"‚Ä¢ Segment {seg.id}: \"{seg.target[:50]}{'...' if len(seg.target) > 50 else ''}\""
                for idx, seg in examples
            ])
            
            warning_msg = (
                f"‚ö†Ô∏è CRITICAL ERROR: {len(segments_with_target)} of {total_segments} segments have target text!\n\n"
                f"Examples:\n{example_text}\n\n"
                f"‚ùå This file is NOT ready for batch translation!\n\n"
                f"REQUIRED: Target column (column 3) must be 100% EMPTY:\n"
                f"  ‚Ä¢ No pre-translations\n"
                f"  ‚Ä¢ No confirmed segments\n"
                f"  ‚Ä¢ No partial translations\n"
                f"  ‚Ä¢ Completely blank target cells\n\n"
                f"The system will translate ALL {total_segments} segments.\n"
                f"Existing translations will cause MAJOR synchronization problems!\n\n"
                f"üí° TIP: You can clear all targets without re-importing:\n"
                f"   1. Right-click in the grid ‚Üí Select All\n"
                f"   2. Right-click again ‚Üí Clear Target (Selected)\n\n"
                f"Or: Cancel ‚Üí Clean target column in memoQ ‚Üí Re-export\n\n"
                f"Proceed anyway? (STRONGLY NOT recommended - will cause errors!)"
            )
            reply = QMessageBox.warning(
                self,
                "Target Text Detected",
                warning_msg,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No  # Default to No for safety
            )
            if reply != QMessageBox.StandardButton.Yes:
                self.log("‚úì Batch translation cancelled - user chose to clean file first")
                return
            else:
                self.log("‚ö†Ô∏è User proceeded with batch translation despite existing target text")

        # Check if this is a retry pass (skip dialog if so)
        is_retry_pass = hasattr(self, '_batch_retry_pass') and self._batch_retry_pass > 0
        
        if is_retry_pass:
            # Use stored settings from previous pass - skip dialog entirely
            translation_provider_type = getattr(self, '_batch_provider_type', 'LLM')
            translation_provider_name = getattr(self, '_batch_provider_name', 'openai')
            model = getattr(self, '_batch_model', 'gpt-4o')
            tm_exact_only = getattr(self, '_batch_tm_exact_only', False)  # Retrieve TM exact-only setting
            api_keys = self.load_api_keys()
            settings = self.load_llm_settings()
            llm_provider = settings.get('provider', 'openai')
            llm_model = model
        else:
            # Show provider selection dialog (only on first pass)
            provider_dialog = QDialog(self)
            provider_dialog.setWindowTitle("Select Translation Provider")
            provider_dialog.setModal(True)
            provider_dialog.setMinimumWidth(500)

            dialog_layout = QVBoxLayout(provider_dialog)

            # Header
            header = QLabel(f"<h3>üöÄ Batch Translate {total_segments} Segment{'s' if total_segments != 1 else ''}</h3>")
            dialog_layout.addWidget(header)

            info_label = QLabel(
                "Choose which translation provider to use for batch translation.\n"
                "This may take several minutes and consume API credits."
            )
            info_label.setWordWrap(True)
            info_label.setStyleSheet("color: #666; padding: 10px 0;")
            dialog_layout.addWidget(info_label)

            dialog_layout.addSpacing(10)

            # Provider selection checkboxes (mutually exclusive)
            provider_group = QGroupBox("Translation Provider")
            provider_layout = QVBoxLayout()

            # Translation Memory option
            tm_checkbox = CheckmarkCheckBox("üìñ TM (Translation Memory) - Pre-translate from activated TMs")
            tm_checkbox.setChecked(False)
            provider_layout.addWidget(tm_checkbox)
            
            # TM Exact Matches Only sub-option (indented to show it's related to TM)
            tm_exact_only_checkbox = CheckmarkCheckBox("       ‚ö° Exact matches only (faster - skips fuzzy matching)")
            tm_exact_only_checkbox.setEnabled(False)  # Disabled until TM is selected
            tm_exact_only_checkbox.setToolTip(
                "Only search for 100% exact matches using fast hash lookup.\n"
                "Skips fuzzy matching which can take several seconds per segment.\n"
                "Recommended for large documents when you have a good TM."
            )
            # Add left margin to create visual hierarchy
            tm_exact_only_checkbox.setStyleSheet("QCheckBox { margin-left: 20px; }")
            provider_layout.addWidget(tm_exact_only_checkbox)
            
            # Enable/disable exact-only option based on TM selection
            def on_tm_selection_changed(checked):
                tm_exact_only_checkbox.setEnabled(checked)
                if not checked:
                    tm_exact_only_checkbox.setChecked(False)
            
            tm_checkbox.toggled.connect(on_tm_selection_changed)

            llm_checkbox = CheckmarkCheckBox("ü§ñ LLM (AI) - Use configured LLM provider (GPT, Claude, Gemini)")
            llm_checkbox.setChecked(True)  # Default to LLM
            provider_layout.addWidget(llm_checkbox)

            # Load API keys to check what's available
            api_keys = self.load_api_keys()
            enabled_providers = self.load_provider_enabled_states()

            # Show available MT providers
            mt_providers_available = []
            if enabled_providers.get('mt_google_translate', True) and api_keys.get('google_translate'):
                mt_providers_available.append('Google Translate')
            if enabled_providers.get('mt_deepl', True) and api_keys.get('deepl'):
                mt_providers_available.append('DeepL')
            if enabled_providers.get('mt_microsoft', True) and (api_keys.get('microsoft_translate') or api_keys.get('azure_translate')):
                mt_providers_available.append('Microsoft Translator')
            if enabled_providers.get('mt_amazon', True) and (api_keys.get('amazon_translate') or api_keys.get('aws_translate')):
                mt_providers_available.append('Amazon Translate')
            if enabled_providers.get('mt_modernmt', True) and api_keys.get('modernmt'):
                mt_providers_available.append('ModernMT')
            if enabled_providers.get('mt_mymemory', True):
                mt_providers_available.append('MyMemory')

            mt_label_text = "üåê MT (Machine Translation)"
            if mt_providers_available:
                mt_label_text += f" - {', '.join(mt_providers_available)}"
            else:
                mt_label_text += " - No MT providers configured"

            mt_checkbox = CheckmarkCheckBox(mt_label_text)
            mt_checkbox.setEnabled(len(mt_providers_available) > 0)
            provider_layout.addWidget(mt_checkbox)

            # Make checkboxes mutually exclusive
            def on_tm_toggled(checked):
                if checked:
                    llm_checkbox.setChecked(False)
                    mt_checkbox.setChecked(False)
        
            def on_llm_toggled(checked):
                if checked:
                    tm_checkbox.setChecked(False)
                    mt_checkbox.setChecked(False)

            def on_mt_toggled(checked):
                if checked:
                    tm_checkbox.setChecked(False)
                    llm_checkbox.setChecked(False)

            tm_checkbox.toggled.connect(on_tm_toggled)
            llm_checkbox.toggled.connect(on_llm_toggled)
            mt_checkbox.toggled.connect(on_mt_toggled)

            if not mt_providers_available:
                mt_warning = QLabel("‚ö†Ô∏è Configure MT API keys in Settings ‚Üí MT Settings to enable")
                mt_warning.setStyleSheet("color: #ff6b6b; font-size: 9pt; padding-left: 25px;")
                provider_layout.addWidget(mt_warning)

            provider_group.setLayout(provider_layout)
            dialog_layout.addWidget(provider_group)

            dialog_layout.addSpacing(10)

            # Show current LLM settings
            settings = self.load_llm_settings()
            llm_provider = settings.get('provider', 'openai')
            model_key = f'{llm_provider}_model'
            llm_model = settings.get(model_key, 'gpt-4o')

            llm_info = QLabel(f"üìä Current LLM: {llm_provider.title()} ({llm_model})")
            llm_info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px 0;")
            dialog_layout.addWidget(llm_info)

            dialog_layout.addSpacing(10)
        
            # Options group
            options_group = QGroupBox("Options")
            options_layout = QVBoxLayout()
        
            # Retry until complete option
            retry_checkbox = CheckmarkCheckBox("üîÑ Retry until all segments are translated (recommended)")
            retry_checkbox.setToolTip(
                "If some segments fail or are empty after the first pass,\n"
                "automatically retry translating just those segments.\n"
                "This continues until all segments have translations\n"
                "or a maximum of 5 retries is reached."
            )
            retry_checkbox.setChecked(True)  # Default to enabled
            options_layout.addWidget(retry_checkbox)
        
            options_group.setLayout(options_layout)
            dialog_layout.addWidget(options_group)

            dialog_layout.addSpacing(20)

            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()

            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(provider_dialog.reject)
            button_layout.addWidget(cancel_btn)

            ok_btn = QPushButton("Start Translation")
            ok_btn.setDefault(True)
            ok_btn.clicked.connect(provider_dialog.accept)
            button_layout.addWidget(ok_btn)

            dialog_layout.addLayout(button_layout)

            # Show dialog
            if provider_dialog.exec() != QDialog.DialogCode.Accepted:
                return

            # Determine which provider was selected
            use_tm = tm_checkbox.isChecked()
            use_mt = mt_checkbox.isChecked()
            retry_until_complete = retry_checkbox.isChecked()
            tm_exact_only = tm_exact_only_checkbox.isChecked()  # NEW: Get exact-only setting
        
            # Store retry setting for recursive calls
            self._batch_retry_enabled = retry_until_complete
            self._batch_tm_exact_only = tm_exact_only  # Store for retry passes
            
            # Initialize model variable (will be set to actual model if LLM is selected)
            model = None

            if use_tm:
                # Use Translation Memory
                translation_provider_type = 'TM'
                translation_provider_name = 'Translation Memory'
            
                # Check if TM database is available
                if not self.tm_database:
                    QMessageBox.critical(
                        self, "No TM Database",
                        "Translation Memory database is not initialized. Please load a project first."
                    )
                    return
            
                mode_str = " (Exact matches only)" if tm_exact_only else " (with fuzzy matching)"
                self.log(f"üìñ Using Translation Memory for batch pre-translation{mode_str}")
            
            elif use_mt:
                # Use MT provider
                translation_provider_type = 'MT'
                translation_provider_name = mt_providers_available[0] if mt_providers_available else None
                if not translation_provider_name:
                    QMessageBox.critical(
                        self, "No MT Provider",
                        "No Machine Translation provider available. Please configure MT API keys in Settings."
                    )
                    return
            else:
                # Use LLM provider
                translation_provider_type = 'LLM'
            
                # Ollama doesn't need API keys - it's local
                if llm_provider == 'ollama':
                    api_keys = {'ollama': 'not-needed'}  # Placeholder - Ollama doesn't use API keys
                elif not api_keys:
                    QMessageBox.critical(
                        self, "API Keys Missing",
                        "Please configure your API keys in Settings first."
                    )
                    return
                # Note: 'gemini' and 'google' are aliases for the same API key
                elif llm_provider not in api_keys and not (llm_provider == 'gemini' and 'google' in api_keys):
                    QMessageBox.critical(
                        self, f"{llm_provider.title()} API Key Missing",
                        f"Please configure your {llm_provider.title()} API key in Settings."
                    )
                    return

                translation_provider_name = llm_provider
                model = llm_model
            
                # Store settings for potential retry passes
                self._batch_provider_type = translation_provider_type
                self._batch_provider_name = translation_provider_name
                self._batch_model = model

        # All segments go to translation - TM pre-translation should be done separately
        # via "Edit ‚Üí Batch Operations ‚Üí Pre-translate from TM" before AI translation
        segments_needing_translation = segments_to_translate

        # Create provider info string for dialog
        if translation_provider_type == 'MT':
            provider_info = f"Provider: {translation_provider_name} (Machine Translation)"
        elif translation_provider_type == 'TM':
            mode = "Exact matches only" if tm_exact_only else "with fuzzy matching"
            provider_info = f"Provider: Translation Memory ({mode})"
        else:
            provider_info = f"Provider: {translation_provider_name.title()} | Model: {model}"

        # Get retry settings
        retry_pass = getattr(self, '_batch_retry_pass', 0)
        retry_enabled = getattr(self, '_batch_retry_enabled', False)
        
        # =====================================================================
        # TM PRE-TRANSLATION - Run on main thread (no SQLite threading issues)
        # Uses the same database methods as the Compare Panel
        # =====================================================================
        if translation_provider_type == 'TM':
            # Get activated TM IDs for TM pre-translation
            tm_ids = None
            if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                if project_id:
                    tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
            
            if not tm_ids:
                QMessageBox.warning(
                    self, "No TMs Activated",
                    "No Translation Memories are activated for reading.\n\n"
                    "Please go to Project Resources ‚Üí Translation Memories and enable "
                    "the 'Read' checkbox for the TMs you want to use."
                )
                return
            
            self.log(f"üìñ Pre-translate from TM: Using activated TMs: {tm_ids}")
            
            # Create progress dialog for TM pre-translation
            import time
            start_time = time.time()
            total_segments = len(segments_needing_translation)

            progress = QProgressDialog(
                f"Pre-translating {total_segments} segments from TM...",
                "Cancel", 0, total_segments, self
            )
            progress.setWindowTitle("üîç TM Pre-Translation")
            progress.setWindowModality(Qt.WindowModality.WindowModal)
            progress.setMinimumDuration(0)  # Show immediately
            progress.setMinimumWidth(450)  # Wider dialog for more info
            progress.show()
            QApplication.processEvents()

            success_count = 0
            no_match_count = 0

            for idx, (row_index, segment) in enumerate(segments_needing_translation):
                if progress.wasCanceled():
                    break

                progress.setValue(idx)

                # Build informative progress label
                elapsed = time.time() - start_time
                elapsed_str = f"{int(elapsed // 60)}:{int(elapsed % 60):02d}"
                source_preview = segment.source[:50] + "..." if len(segment.source) > 50 else segment.source
                label_text = (
                    f"Searching TM for segment {idx + 1} of {total_segments}...\n\n"
                    f"Current: \"{source_preview}\"\n"
                    f"Matches found: {success_count}  |  Elapsed: {elapsed_str}\n\n"
                    f"‚ÑπÔ∏è This may take a while for large documents."
                )
                progress.setLabelText(label_text)
                QApplication.processEvents()
                
                try:
                    match = None
                    
                    if tm_exact_only:
                        # Exact match only - use hash lookup (fast)
                        match = self.tm_database.get_exact_match(segment.source, tm_ids=tm_ids)
                        print(f"DEBUG get_exact_match returned: type={type(match)}, value={match}")
                        if match and isinstance(match, dict):
                            segment.target = match.get('target_text', '')
                            segment.status = "Translated"
                            success_count += 1
                            self.log(f"   ‚úì Segment {row_index + 1}: 100% exact match found")
                        else:
                            no_match_count += 1
                    else:
                        # Fuzzy matching enabled - get best match ‚â•75%
                        matches = self.tm_database.search_all(
                            segment.source,
                            tm_ids=tm_ids,
                            enabled_only=False,
                            max_matches=1
                        )
                        if matches and len(matches) > 0:
                            best_match = matches[0]
                            match_pct = best_match.get('match_pct', 0)
                            if match_pct >= 75:
                                segment.target = best_match.get('target', '')
                                segment.status = "Translated"
                                success_count += 1
                                self.log(f"   ‚úì Segment {row_index + 1}: {match_pct}% match found")
                            else:
                                no_match_count += 1
                        else:
                            no_match_count += 1
                    
                    # Update grid immediately
                    if segment.target:
                        target_widget = self.table.cellWidget(row_index, 3)
                        if target_widget and isinstance(target_widget, EditableGridTextEditor):
                            target_widget.setPlainText(segment.target)
                        self.update_status_icon(row_index, segment.status)
                        QApplication.processEvents()
                        
                except Exception as e:
                    self.log(f"   ‚úó Segment {row_index + 1}: Error - {str(e)}")
                    no_match_count += 1
            
            progress.setValue(len(segments_needing_translation))
            progress.close()
            
            # Show completion message
            self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            self.log(f"‚úì TM Pre-Translation Complete")
            self.log(f"   Translated: {success_count} | No match: {no_match_count}")
            self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            
            QMessageBox.information(
                self, "TM Pre-Translation Complete",
                f"Pre-translation from TM complete.\n\n"
                f"‚úì Translated: {success_count}\n"
                f"‚äò No match: {no_match_count}"
            )
            
            self.project_modified = True
            self.update_window_title()
            self.auto_resize_rows()
            self.update_progress_stats()
            return  # Exit - TM pre-translation is complete
        
        # =====================================================================
        # LLM/MT TRANSLATION - Uses background worker thread
        # =====================================================================
        
        # Create worker and dialog
        # Note: TM pre-translation is now handled on main thread above,
        # so we don't pass tm_ids to the worker anymore
        worker = PreTranslationWorker(
            self, 
            segments_needing_translation,  # Use filtered segments after TM pre-check
            translation_provider_type, 
            translation_provider_name, 
            model if translation_provider_type == 'LLM' else None,
            tm_exact_only=tm_exact_only,
            prompt_manager=self.prompt_manager_qt if hasattr(self, 'prompt_manager_qt') else None,
            retry_enabled=retry_enabled,
            retry_pass=retry_pass,
            tm_ids=None  # TM pre-translation now on main thread
        )
        dialog = LiveProgressDialog(self, len(segments_needing_translation), provider_info)
        
        # Track success/error counts for dialog updates
        success_count = 0
        error_count = 0
        
        # Connect signals
        def handle_progress_update(current, total, message, success, elapsed_time):
            nonlocal success_count, error_count
            if success:
                success_count += 1
            else:
                error_count += 1
            dialog.add_console_line(message, success)
            dialog.update_progress(current, total, elapsed_time, success_count, error_count)
            
            # Update grid immediately for successful translations
            if success and current <= len(segments_needing_translation):
                row_index, segment = segments_needing_translation[current - 1]
                if row_index < self.table.rowCount():
                    target_widget = self.table.cellWidget(row_index, 3)
                    if target_widget and isinstance(target_widget, EditableGridTextEditor):
                        target_widget.setPlainText(segment.target)
                    else:
                        self.table.setItem(row_index, 3, QTableWidgetItem(segment.target))
                    self.update_status_icon(row_index, segment.status)
        
        def handle_translation_complete(final_success_count, final_error_count):
            dialog.show_completion_message(final_success_count, final_error_count)
            self.project_modified = True
            self.update_window_title()
            self.auto_resize_rows()
            self.update_progress_stats()
            
            # Check if this is the final pass (no retry pending)
            if not hasattr(self, '_pending_retry'):
                # Log completion
                self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                self.log(f"‚úì Batch Translation Complete")
                self.log(f"   Translated: {final_success_count} | Failed: {final_error_count}")
                self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                
                # Clear retry settings
                if hasattr(self, '_batch_retry_pass'):
                    delattr(self, '_batch_retry_pass')
                if hasattr(self, '_batch_retry_enabled'):
                    delattr(self, '_batch_retry_enabled')
        
        def handle_retry_needed(empty_segments_after):
            retry_count = len(empty_segments_after)
            current_pass = worker.retry_pass
            next_pass = current_pass + 2  # +2 because pass 0 is "first pass", so pass 1 is "retry 2"
            
            # Log retry
            self.log(f"üîÑ Retry pass {next_pass}: {retry_count} segment(s) still empty, retrying...")
            
            # Update retry pass counter
            self._batch_retry_pass = current_pass + 1
            self._pending_retry = True  # Flag to prevent completion message
            
            # Close current dialog
            dialog.accept()
            
            # Recursively call translate_batch with only empty segments
            # Clear the pending flag before recursion
            if hasattr(self, '_pending_retry'):
                delattr(self, '_pending_retry')
            
            self.translate_batch(
                segments_with_rows=empty_segments_after,
                scope_description=f"empty segment(s) (retry {next_pass})"
            )
        
        worker.progress_update.connect(handle_progress_update)
        worker.translation_complete.connect(handle_translation_complete)
        worker.retry_needed.connect(handle_retry_needed)
        
        # Connect cancel button
        dialog.rejected.connect(worker.cancel)
        
        # Start worker and show dialog
        worker.start()
        dialog.exec()
        
        # Wait for worker to finish
        worker.wait()
        
        return  # Exit - new implementation replaces all the code below

        # ===== OLD BLOCKING IMPLEMENTATION BELOW (DISABLED) =====
        # Create progress dialog
        progress = QDialog(self)
        progress.setWindowTitle("Batch Translation Progress")
        progress.setMinimumWidth(600)
        progress.setMinimumHeight(250)
        progress.setModal(True)

        layout = QVBoxLayout(progress)

        # Header
        header_label = QLabel(f"<h3>üöÄ Translating {total_segments} segment{'s' if total_segments != 1 else ''}</h3>")
        layout.addWidget(header_label)

        # Provider info
        if translation_provider_type == 'MT':
            info_label = QLabel(f"<b>Provider:</b> {translation_provider_name} (Machine Translation)")
        elif translation_provider_type == 'TM':
            info_label = QLabel(f"<b>Provider:</b> {translation_provider_name}")
        else:
            info_label = QLabel(f"<b>Provider:</b> {translation_provider_name.title()} | <b>Model:</b> {model}")
        layout.addWidget(info_label)

        # Progress bar
        progress_bar = QProgressBar()
        progress_bar.setMaximum(total_segments)
        progress_bar.setValue(0)
        layout.addWidget(progress_bar)

        # Current segment label
        current_label = QLabel("Starting...")
        layout.addWidget(current_label)

        # Statistics
        stats_label = QLabel(f"Translated: 0 | Failed: 0 | Remaining: {total_segments}")
        layout.addWidget(stats_label)

        # Close button (initially disabled)
        close_btn = QPushButton("Close")
        close_btn.setEnabled(False)
        close_btn.clicked.connect(progress.accept)
        layout.addWidget(close_btn)

        # Show progress dialog
        progress.show()
        QApplication.processEvents()

        translated_count = 0
        failed_count = 0
        segment_idx = 0

        try:
            source_lang = getattr(self.current_project, 'source_lang', 'en')
            target_lang = getattr(self.current_project, 'target_lang', 'nl')

            self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            self.log(f"üöÄ Starting Batch Translation")
            self.log(f"   Provider Type: {translation_provider_type}")
            if translation_provider_type == 'MT':
                self.log(f"   MT Provider: {translation_provider_name}")
            elif translation_provider_type == 'TM':
                self.log(f"   TM Provider: {translation_provider_name}")
            else:
                self.log(f"   LLM Provider: {translation_provider_name} ({model})")
            self.log(f"   Source ‚Üí Target: {source_lang} ‚Üí {target_lang}")
            self.log(f"   Total segments: {total_segments}")
            if segments_with_target:
                self.log(f"   ‚ö†Ô∏è Warning: {len(segments_with_target)} segments have existing target text")
            self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

            # Check TM before API calls if enabled (can save significant API costs!)
            general_prefs = self.load_general_settings()
            check_tm_before_api = general_prefs.get('check_tm_before_api', True)
            check_tm_exact_only = general_prefs.get('check_tm_exact_only', False)
            tm_matches_found = 0
            segments_needing_translation = []
            
            if check_tm_before_api and self.tm_database:
                self.log(f"üîç Pre-checking TM for 100% matches before API calls...")
                if check_tm_exact_only:
                    self.log(f"   Using EXACT match mode (faster - hash lookup)")
                else:
                    self.log(f"   Using FUZZY match mode (includes 100% matches)")
                
                # Get activated TM IDs for current project
                tm_ids = None
                if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                    project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                    if project_id:
                        tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                        if tm_ids:
                            self.log(f"   Using activated TMs: {tm_ids}")
                        else:
                            self.log(f"   ‚ö† No TMs activated - skipping TM pre-check")
                
                # Skip TM pre-check if no TMs are activated
                if tm_ids is None or (isinstance(tm_ids, list) and len(tm_ids) == 0):
                    self.log(f"   Skipping TM pre-check (no activated TMs)")
                    segments_needing_translation = segments_to_translate
                else:
                    # Check each segment against TM
                    for row_index, segment in segments_to_translate:
                        try:
                            if check_tm_exact_only:
                                # Use exact match only (faster - O(1) hash lookup)
                                exact_match = self.tm_database.get_exact_match(segment.source, tm_ids=tm_ids)
                                if exact_match:
                                    # Found 100% exact match - auto-insert it
                                    tm_match = exact_match.get('target_text', '')
                                    segment.target = tm_match
                                    segment.status = "translated"
                                    tm_matches_found += 1
                                    
                                    # Update grid immediately
                                    if row_index < self.table.rowCount():
                                        target_widget = self.table.cellWidget(row_index, 3)
                                        if target_widget and isinstance(target_widget, EditableGridTextEditor):
                                            target_widget.setPlainText(tm_match)
                                        else:
                                            self.table.setItem(row_index, 3, QTableWidgetItem(tm_match))
                                        self.update_status_icon(row_index, "translated")
                                    
                                    translated_count += 1
                                    self.log(f"   ‚úì TM 100%: Segment #{segment.id}")
                                else:
                                    # No exact match - needs translation
                                    segments_needing_translation.append((row_index, segment))
                            else:
                                # Use fuzzy search (includes 100% matches)
                                matches = self.tm_database.search_all(segment.source, tm_ids=tm_ids, enabled_only=False, max_matches=1)
                                if matches and matches[0].get('match_pct', 0) == 100:
                                    # Found 100% match - auto-insert it
                                    tm_match = matches[0].get('target', '')
                                    segment.target = tm_match
                                    segment.status = "translated"
                                    tm_matches_found += 1
                                    
                                    # Update grid immediately
                                    if row_index < self.table.rowCount():
                                        target_widget = self.table.cellWidget(row_index, 3)
                                        if target_widget and isinstance(target_widget, EditableGridTextEditor):
                                            target_widget.setPlainText(tm_match)
                                        else:
                                            self.table.setItem(row_index, 3, QTableWidgetItem(tm_match))
                                        self.update_status_icon(row_index, "translated")
                                    
                                    translated_count += 1
                                    self.log(f"   ‚úì TM 100%: Segment #{segment.id}")
                                else:
                                    # No 100% match - needs translation
                                    segments_needing_translation.append((row_index, segment))
                        except Exception as e:
                            # TM check failed - add to translation queue
                            segments_needing_translation.append((row_index, segment))
                            self.log(f"   ‚ö† TM check error for segment #{segment.id}: {e}")
                
                self.log(f"‚úì TM pre-check complete: {tm_matches_found} 100% matches found, {len(segments_needing_translation)} segments need translation")
                self.log(f"   API calls saved: {tm_matches_found} (cost savings!)")
                
                # Update progress to reflect TM matches
                progress_bar.setValue(tm_matches_found)
                stats_label.setText(f"Translated: {translated_count} | Failed: {failed_count} | Remaining: {len(segments_needing_translation)}")
                QApplication.processEvents()
                
                # Replace segments_to_translate with only those needing translation
                if segments_needing_translation:
                    segments_to_translate = segments_needing_translation
                    total_segments = len(segments_to_translate)
                    segment_idx = tm_matches_found  # Start counting from TM matches
                else:
                    # All segments matched in TM - we're done!
                    self.log(f"üéâ All segments found in TM - no API calls needed!")
                    self.project_modified = True
                    self.update_window_title()
                    progress_bar.setValue(translated_count)
                    current_label.setText(f"‚úì Complete! All {translated_count} segments translated from TM")
                    close_btn.setEnabled(True)
                    self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                    self.log(f"‚úì Batch Translation Complete (100% from TM)")
                    self.log(f"   Translated: {translated_count} | Failed: {failed_count}")
                    self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                    # Auto-resize rows to fit inserted translations
                    self.auto_resize_rows()
                    self.update_progress_stats()
                    return
            else:
                if not check_tm_before_api:
                    self.log(f"‚ÑπÔ∏è TM pre-check disabled in settings")
                elif not self.tm_database:
                    self.log(f"‚ÑπÔ∏è No TM database available")
                segments_needing_translation = segments_to_translate

            # TM-only mode: Skip API initialization and translate from TM only
            if translation_provider_type == 'TM':
                self.log(f"üìñ TM-Only mode: Translating {len(segments_needing_translation)} segments from Translation Memory")
                
                # Get activated TM IDs for current project
                tm_ids = None
                if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                    project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                    if project_id:
                        tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                        if tm_ids:
                            self.log(f"   Using activated TMs: {tm_ids}")
                
                # Translate each segment from TM
                for row_index, segment in segments_needing_translation:
                    try:
                        # Search TM for best match
                        matches = self.tm_database.search_all(segment.source, tm_ids=tm_ids, enabled_only=False, max_matches=1)
                        
                        if matches and len(matches) > 0:
                            match = matches[0]
                            match_pct = match.get('match_pct', 0)
                            tm_match = match.get('target', '')
                            
                            if match_pct >= 75:  # Accept matches 75% and above
                                segment.target = tm_match
                                segment.status = "pretranslated"
                                translated_count += 1
                                
                                # Update grid immediately
                                if row_index < self.table.rowCount():
                                    target_widget = self.table.cellWidget(row_index, 3)
                                    if target_widget and isinstance(target_widget, EditableGridTextEditor):
                                        target_widget.setPlainText(tm_match)
                                    else:
                                        self.table.setItem(row_index, 3, QTableWidgetItem(tm_match))
                                    self.update_status_icon(row_index, segment.status)
                                
                                self.log(f"   ‚úì TM {match_pct}%: Segment #{segment.id}")
                            else:
                                # Match below threshold - skip
                                failed_count += 1
                                self.log(f"   ‚äò TM {match_pct}% (below 70%): Segment #{segment.id} - skipped")
                        else:
                            # No match found
                            failed_count += 1
                            self.log(f"   ‚äò No TM match: Segment #{segment.id} - skipped")
                        
                        segment_idx += 1
                        progress_bar.setValue(segment_idx)
                        stats_label.setText(f"Translated: {translated_count} | Skipped: {failed_count} | Remaining: {len(segments_needing_translation) - segment_idx}")
                        QApplication.processEvents()
                        
                    except Exception as e:
                        failed_count += 1
                        self.log(f"   ‚úó Error translating segment #{segment.id}: {e}")
                        segment_idx += 1
                        progress_bar.setValue(segment_idx)
                        QApplication.processEvents()
                
                # TM-only translation complete
                self.project_modified = True
                self.update_window_title()
                current_label.setText(f"‚úì Complete! {translated_count} segments translated from TM, {failed_count} skipped (no match/low match)")
                close_btn.setEnabled(True)
                self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                self.log(f"‚úì TM-Only Batch Translation Complete")
                self.log(f"   Translated: {translated_count} | Skipped: {failed_count}")
                self.log(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
                # Auto-resize rows to fit inserted translations
                self.auto_resize_rows()
                self.update_progress_stats()
                return
            
            # Initialize client based on provider type (LLM, MT, or TM)
            client = None
            mt_api_key = None
            mt_provider_code = None

            if translation_provider_type == 'LLM':
                from modules.llm_clients import LLMClient
                # Handle gemini/google alias
                api_key = api_keys.get(translation_provider_name) or (api_keys.get('google') if translation_provider_name == 'gemini' else None)
                client = LLMClient(
                    api_key=api_key,
                    provider=translation_provider_name,
                    model=model
                )
            elif translation_provider_type == 'MT':
                # MT provider - get API key
                provider_map = {
                    'Google Translate': 'google_translate',
                    'DeepL': 'deepl',
                    'Microsoft Translator': ('microsoft_translate', 'azure_translate'),
                    'Amazon Translate': ('amazon_translate', 'aws_translate'),
                    'ModernMT': 'modernmt',
                    'MyMemory': 'mymemory'
                }

                key_name = provider_map.get(translation_provider_name)
                if isinstance(key_name, tuple):
                    # Try multiple possible key names
                    for kn in key_name:
                        if api_keys.get(kn):
                            mt_api_key = api_keys[kn]
                            break
                else:
                    mt_api_key = api_keys.get(key_name)

                # Store provider code for MT calls
                mt_provider_code = translation_provider_name.lower().replace(' ', '_')

            batch_size = general_prefs.get('batch_size', 20)
            total_batches = (total_segments + batch_size - 1) // batch_size

            for batch_num in range(total_batches):
                batch_start = batch_num * batch_size
                batch_end = min(batch_start + batch_size, total_segments)
                batch_segments = segments_needing_translation[batch_start:batch_end]

                current_label.setText(f"Translating batch {batch_num + 1}/{total_batches} ({len(batch_segments)} segments)...")
                progress_bar.setValue(segment_idx)
                QApplication.processEvents()

                try:
                    # TM provider - get matches from translation memory
                    if translation_provider_type == 'TM':
                        current_label.setText(f"Translating batch {batch_num + 1}/{total_batches} ({len(batch_segments)} segments)...")
                        progress_bar.setValue(segment_idx)
                        QApplication.processEvents()

                        # Translate each segment using TM
                        for row_index, segment in batch_segments:
                            try:
                                # Query TM for 100% match
                                tm_match = self.tm_database.query_tm(segment.source, threshold=100)

                                if tm_match and len(tm_match) > 0:
                                    translation = tm_match[0]['target']
                                    segment.target = translation
                                    segment.status = 'pretranslated'
                                    translated_count += 1
                                    self.log(f"  ‚úì Segment {segment.id}: {segment.source[:40]}... ‚Üí {translation[:40]}... (TM 100%)")
                                else:
                                    failed_count += 1
                                    self.log(f"  ‚úó Segment {segment.id}: No 100% TM match found")

                                segment_idx += 1
                                progress_bar.setValue(segment_idx)
                                stats_label.setText(f"Translated: {translated_count} | Failed: {failed_count} | Remaining: {total_segments - segment_idx}")
                                QApplication.processEvents()

                            except Exception as e:
                                failed_count += 1
                                self.log(f"  ‚úó Segment {segment.id}: Error - {e}")
                                segment_idx += 1

                        continue  # Skip to next batch

                    # MT provider - simpler segment-by-segment translation
                    elif translation_provider_type == 'MT':
                        current_label.setText(f"Translating batch {batch_num + 1}/{total_batches} ({len(batch_segments)} segments)...")
                        progress_bar.setValue(segment_idx)
                        QApplication.processEvents()

                        # Translate each segment individually with MT
                        for row_index, segment in batch_segments:
                            try:
                                translation = None

                                # Call appropriate MT service
                                if translation_provider_name == 'Google Translate':
                                    translation = self.call_google_translate(segment.source, source_lang, target_lang, mt_api_key)
                                elif translation_provider_name == 'DeepL':
                                    translation = self.call_deepl(segment.source, source_lang, target_lang, mt_api_key)
                                elif translation_provider_name == 'Microsoft Translator':
                                    translation = self.call_microsoft_translate(segment.source, source_lang, target_lang, mt_api_key)
                                elif translation_provider_name == 'Amazon Translate':
                                    region = api_keys.get('amazon_translate_region', 'us-east-1')
                                    translation = self.call_amazon_translate(segment.source, source_lang, target_lang, mt_api_key, region)
                                elif translation_provider_name == 'ModernMT':
                                    translation = self.call_modernmt(segment.source, source_lang, target_lang, mt_api_key)
                                elif translation_provider_name == 'MyMemory':
                                    translation = self.call_mymemory(segment.source, source_lang, target_lang, mt_api_key)

                                if translation and not translation.startswith('['):  # Skip error messages
                                    segment.target = translation
                                    segment.status = 'pretranslated'
                                    translated_count += 1
                                    self.log(f"  ‚úì Segment {segment.id}: {segment.source[:40]}... ‚Üí {translation[:40]}...")
                                else:
                                    failed_count += 1
                                    self.log(f"  ‚úó Segment {segment.id}: Translation failed - {translation}")

                                segment_idx += 1
                                progress_bar.setValue(segment_idx)
                                stats_label.setText(f"Translated: {translated_count} | Failed: {failed_count} | Remaining: {total_segments - segment_idx}")
                                QApplication.processEvents()

                            except Exception as e:
                                failed_count += 1
                                self.log(f"  ‚úó Segment {segment.id}: Error - {e}")
                                segment_idx += 1

                        continue  # Skip to next batch

                    # LLM provider - batch translation with context
                    batch_prompt_parts = []

                    base_prompt = None
                    if hasattr(self, 'prompt_manager_qt') and self.prompt_manager_qt and batch_segments:
                        try:
                            first_segment = batch_segments[0][1]
                            # Get glossary terms for AI injection
                            glossary_terms = self.get_ai_inject_glossary_terms()
                            base_prompt = self.prompt_manager_qt.build_final_prompt(
                                source_text=first_segment.source,
                                source_lang=source_lang,
                                target_lang=target_lang,
                                mode="single",
                                glossary_terms=glossary_terms
                            )
                            if "**SOURCE TEXT:**" in base_prompt:
                                base_prompt = base_prompt.split("**SOURCE TEXT:**")[0].strip()
                            elif "Translate the following" in base_prompt:
                                base_prompt = base_prompt.split("Translate the following")[0].strip()
                        except Exception:
                            base_prompt = None

                    if base_prompt:
                        batch_prompt_parts.append(base_prompt)
                    else:
                        batch_prompt_parts.append(f"Translate the following text segments from {source_lang} to {target_lang}.")

                    use_full_context = general_prefs.get('use_full_context', True)
                    if use_full_context and self.current_project:
                        try:
                            # Get first and last segment IDs in this batch for context window
                            first_batch_seg_id = batch_segments[0][1].id if batch_segments else 0
                            last_batch_seg_id = batch_segments[-1][1].id if batch_segments else 0
                            
                            # Use user-configurable context window size (default 50)
                            # This prevents massive prompts that cause timeouts with large documents
                            context_window_size = general_prefs.get('context_window_size', 50)
                            context_start_id = max(1, first_batch_seg_id - context_window_size)
                            context_end_id = min(len(self.current_project.segments), last_batch_seg_id + context_window_size)
                            
                            context_parts = []
                            for seg in self.current_project.segments:
                                if seg.source and context_start_id <= seg.id <= context_end_id:
                                    context_parts.append(f"{seg.id}. {seg.source}")
                                    # Show existing translations if present (for legacy compatibility)
                                    if seg.target and seg.target.strip():
                                        context_parts.append(f"    ‚Üí {seg.target}")

                            if context_parts:
                                batch_prompt_parts.append("\n" + "="*80)
                                batch_prompt_parts.append("**SURROUNDING CONTEXT (FOR REFERENCE ONLY):**")
                                batch_prompt_parts.append(f"Source text from segments {context_start_id}-{context_end_id} shown for terminology consistency.")
                                batch_prompt_parts.append("DO NOT translate these context segments - only translate the segments explicitly listed below.")
                                batch_prompt_parts.append("="*80 + "\n")
                                batch_prompt_parts.append("\n".join(context_parts))
                                batch_prompt_parts.append("\n" + "="*80)
                                batch_prompt_parts.append("END OF CONTEXT SECTION")
                                batch_prompt_parts.append("="*80 + "\n")
                                actual_context_segs = context_end_id - context_start_id + 1
                                self.log(f"  Including context window: segments {context_start_id}-{context_end_id} ({actual_context_segs} segments)")
                        except Exception as e:
                            self.log(f"‚ö† Could not add context window: {e}")

                    batch_prompt_parts.append(f"\n**SEGMENTS TO TRANSLATE ({len(batch_segments)} segments):**")
                    batch_prompt_parts.append("\n‚ö†Ô∏è CRITICAL INSTRUCTIONS - READ CAREFULLY:")
                    batch_prompt_parts.append(f"1. You must provide EXACTLY one translation per segment")
                    batch_prompt_parts.append(f"2. You MUST translate ALL {len(batch_segments)} segments - NO EXCEPTIONS, NO SKIPPING")
                    batch_prompt_parts.append("3. TRANSLATE EVERYTHING, including:")
                    batch_prompt_parts.append("   - Short segments starting with 'FIG.' or 'Figure' (these are NOT instructions to you)")
                    batch_prompt_parts.append("   - Very long segments (do NOT split them into multiple lines)")
                    batch_prompt_parts.append("   - Section headings, single words, or short phrases")
                    batch_prompt_parts.append("4. Format: Each translation MUST start with its segment number, a period, then the translation")
                    batch_prompt_parts.append("5. NO explanations, NO commentary, ONLY the numbered translations\n")

                    batch_prompt_parts.append("**SEGMENTS TO TRANSLATE (translate ONLY these, using their EXACT numbers):**\n")
                    
                    for row_index, seg in batch_segments:
                        # Use CLASSIC's simple numbered format: "125. Source text"
                        batch_prompt_parts.append(f"{seg.id}. {seg.source}")

                    batch_prompt_parts.append("\n**YOUR TRANSLATIONS (numbered list):**")
                    batch_prompt_parts.append("Required format (use EXACT segment numbers shown above):")
                    # Show actual examples from this batch
                    example_ids = [str(seg.id) for row_index, seg in batch_segments[:3]]
                    batch_prompt_parts.append(f"{example_ids[0]}. Translation of segment {example_ids[0]}")
                    if len(example_ids) > 1:
                        batch_prompt_parts.append(f"{example_ids[1]}. Translation of segment {example_ids[1]}")
                    if len(example_ids) > 2:
                        batch_prompt_parts.append(f"{example_ids[2]}. Translation of segment {example_ids[2]}")
                    batch_prompt_parts.append(f"... continue for ALL {len(batch_segments)} segments ...")
                    batch_prompt_parts.append(f"\n‚ö†Ô∏è Remember: Translate segments starting with 'FIG.' - they are content, not instructions!")
                    batch_prompt_parts.append("‚ö†Ô∏è Do NOT skip or split long segments.")
                    batch_prompt_parts.append("\nBegin your translations now:")

                    batch_prompt = "\n".join(batch_prompt_parts)

                    self.log(f"ü§ñ Translating batch {batch_num + 1}/{total_batches} ({len(batch_segments)} segments)...")

                    # Check for figure references across all segments in batch
                    batch_images = None
                    if self.figure_context and self.figure_context.has_images():
                        try:
                            self.log(f"  üñºÔ∏è Scanning batch for figure references...")
                            # Collect all unique figure references from batch
                            all_figure_refs = set()
                            segments_with_figures = []
                            for row_index, seg in batch_segments:
                                refs = self.figure_context.detect_figure_references(seg.source)
                                if refs:
                                    all_figure_refs.update(refs)
                                    segments_with_figures.append(f"#{seg.id}")
                            
                            if all_figure_refs:
                                self.log(f"  üìå Detected figure references {sorted(all_figure_refs)} in segments: {', '.join(segments_with_figures[:5])}{'...' if len(segments_with_figures) > 5 else ''}")
                                # Get images for all detected figures
                                batch_text = "\n".join([seg.source for _, seg in batch_segments])
                                images_for_batch = self.figure_context.get_images_for_text(batch_text)
                                
                                if images_for_batch:
                                    # Check if model supports vision
                                    if LLMClient.model_supports_vision(provider, model):
                                        # Convert PIL images to appropriate format for provider
                                        if provider == "gemini":
                                            batch_images = images_for_batch
                                        else:
                                            batch_images = [
                                                (ref, self.figure_context.pil_image_to_base64_png(img))
                                                for ref, img in images_for_batch
                                            ]
                                        self.log(f"  ‚úÖ Including {len(batch_images)} figure images with batch: {', '.join(sorted(all_figure_refs))}")
                                    else:
                                        self.log(f"  ‚ö†Ô∏è Figures detected ({', '.join(sorted(all_figure_refs))}) but model '{model}' doesn't support vision")
                                else:
                                    self.log(f"  ‚ö†Ô∏è Figure references detected but no matching images found in loaded folder")
                            else:
                                self.log(f"  ‚ÑπÔ∏è No figure references detected in this batch")
                        except Exception as e:
                            self.log(f"  ‚ö†Ô∏è Could not load batch figures: {e}")

                    first_segment_text = batch_segments[0][1].source if batch_segments else ""
                    batch_response = client.translate(
                        text=first_segment_text,
                        source_lang=source_lang,
                        target_lang=target_lang,
                        custom_prompt=batch_prompt,
                        images=batch_images
                    )

                    import re
                    
                    # Create a dictionary to map segment IDs to translations
                    segment_translations = {}
                    expected_ids = [seg.id for _, seg in batch_segments]
                    
                    # Parse using CLASSIC's proven numbered format: "125. Translation here"
                    for line in batch_response.strip().split('\n'):
                        line = line.strip()
                        if not line:
                            continue
                        
                        # Match numbered translations: "125. Translation text"
                        match = re.match(r'^\s*(\d+)\.\s*(.*)', line)
                        if match:
                            seg_id = int(match.group(1))
                            translation = match.group(2).strip()
                            
                            # Only accept translations for segments we requested
                            if seg_id in expected_ids:
                                segment_translations[seg_id] = translation
                    
                    self.log(f"  ‚úì Parsed {len(segment_translations)} translations from response")
                    self.log(f"  ‚úì Expected IDs: {expected_ids[:5]}{'...' if len(expected_ids) > 5 else ''}")
                    self.log(f"  ‚úì Received IDs: {sorted(segment_translations.keys())[:5]}{'...' if len(segment_translations) > 5 else ''}")

                    # Validate we got translations for all segments
                    missing_segments = []
                    fig_missing = []
                    long_missing = []
                    
                    for row_index, seg in batch_segments:
                        if seg.id not in segment_translations:
                            missing_segments.append(seg.id)
                            # Check if it's a FIG segment
                            if seg.source.strip().upper().startswith('FIG'):
                                fig_missing.append(seg.id)
                            # Check if it's a very long segment
                            if len(seg.source) > 500:
                                long_missing.append(seg.id)
                    
                    if missing_segments:
                        self.log(f"‚ùå WARNING: Missing translations for {len(missing_segments)} segments: {missing_segments}")
                        if fig_missing:
                            self.log(f"  ‚ö†Ô∏è {len(fig_missing)} missing segments start with 'FIG': {fig_missing}")
                        if long_missing:
                            self.log(f"  ‚ö†Ô∏è {len(long_missing)} missing segments are very long (>500 chars): {long_missing}")
                        
                        # Check for LLM refusal patterns
                        refusal_patterns = [
                            "I'm sorry", "I can't assist", "I cannot assist", 
                            "I'm not able to", "I cannot help", "I can't help",
                            "against my guidelines", "policy", "unable to"
                        ]
                        response_lower = batch_response.lower()
                        is_refusal = any(pattern.lower() in response_lower for pattern in refusal_patterns)
                        
                        if is_refusal:
                            self.log(f"  üö´ LLM REFUSAL DETECTED: The AI provider refused to translate this content.")
                            self.log(f"  üí° TRY: Switch to Claude or Gemini in Settings - they may be less restrictive.")
                            self.log(f"  üí° TRY: Use a different model (e.g., gpt-4-turbo instead of gpt-4o).")
                        self.log(f"  Expected {len(batch_segments)} translations, got {len(segment_translations)}")
                        
                        response_preview = batch_response[:800].replace('\n', ' ')
                        self.log(f"  Response preview: {response_preview}...")

                    for i, (row_index, segment) in enumerate(batch_segments):
                        translation = segment_translations.get(segment.id, "")

                        if translation:
                            # Sanity check: if source is very long and translation is very short, flag it
                            source_len = len(segment.source)
                            trans_len = len(translation)
                            if source_len > 300 and trans_len < source_len * 0.3:
                                self.log(f"‚ö† Segment #{segment.id}: Suspiciously short translation ({trans_len} chars for {source_len} char source)")
                            
                            # Check if translation seems to be from wrong segment (contains wrong numbering)
                            source_starts_with_num = re.match(r'^(\d+)\.', segment.source.strip())
                            trans_starts_with_num = re.match(r'^(\d+)\.', translation.strip())
                            if source_starts_with_num and trans_starts_with_num:
                                if source_starts_with_num.group(1) != trans_starts_with_num.group(1):
                                    self.log(f"‚ö† Segment #{segment.id}: Number mismatch! Source starts with {source_starts_with_num.group(1)}, translation with {trans_starts_with_num.group(1)}")
                        
                        if translation:
                            segment.target = translation
                            segment.status = "translated"  # Set to 'translated' like single translation mode

                            if row_index < self.table.rowCount():
                                target_widget = self.table.cellWidget(row_index, 3)
                                if target_widget and isinstance(target_widget, EditableGridTextEditor):
                                    target_widget.setPlainText(translation)
                                else:
                                    self.table.setItem(row_index, 3, QTableWidgetItem(translation))
                                    self.update_status_icon(row_index, "translated")

                            if self.tm_database:
                                try:
                                    self.tm_database.add_to_project_tm(segment.source, translation)
                                except Exception:
                                    pass

                            translated_count += 1
                            self.log(f"‚úì Batch: Segment #{segment.id} translated")
                        else:
                            failed_count += 1
                            self.log(f"‚úó Batch: Segment #{segment.id} - empty translation")

                        segment_idx += 1
                        progress_bar.setValue(segment_idx)
                        remaining = total_segments - segment_idx
                        stats_label.setText(
                            f"Translated: {translated_count} | Failed: {failed_count} | Remaining: {remaining}"
                        )
                        QApplication.processEvents()

                except Exception as e:
                    for row_index, segment in batch_segments:
                        failed_count += 1
                        segment_idx += 1
                        self.log(f"‚úó Batch: Segment #{segment.id} - {str(e)}")
                        progress_bar.setValue(segment_idx)
                        remaining = total_segments - segment_idx
                        stats_label.setText(
                            f"Translated: {translated_count} | Failed: {failed_count} | Remaining: {remaining}"
                        )
                        QApplication.processEvents()

            if translated_count > 0:
                self.project_modified = True
                self.update_window_title()

            progress_bar.setValue(total_segments)
            
            # Check if retry is needed (for LLM mode with retry option enabled)
            retry_pass = getattr(self, '_batch_retry_pass', 0)
            max_retries = 5
            retry_enabled = getattr(self, '_batch_retry_enabled', False)
            
            # Count segments that are still empty after this pass
            empty_segments_after = []
            if retry_enabled and translation_provider_type == 'LLM' and retry_pass < max_retries:
                for row_index, seg in segments_to_translate:
                    if not seg.target or not seg.target.strip():
                        empty_segments_after.append((row_index, seg))
            
            if empty_segments_after and retry_pass < max_retries:
                # There are still empty segments - offer to retry
                self._batch_retry_pass = retry_pass + 1
                retry_count = len(empty_segments_after)
                
                current_label.setText(
                    f"<b>Pass {retry_pass + 1} complete</b><br>"
                    f"Translated: {translated_count}<br>"
                    f"Still empty: {retry_count}<br><br>"
                    f"<b>üîÑ Starting retry pass {retry_pass + 2} for {retry_count} segments...</b>"
                )
                QApplication.processEvents()
                
                self.log(f"üîÑ Retry pass {retry_pass + 2}: {retry_count} segments still empty, retrying...")
                
                # Close current progress dialog
                progress.accept()
                
                # Recursively call translate_batch with only empty segments
                self.translate_batch(
                    segments_with_rows=empty_segments_after,
                    scope_description=f"empty segment(s) (retry {retry_pass + 2})"
                )
                return  # Don't show completion message yet
            
            # Clear retry counter and stored settings
            if hasattr(self, '_batch_retry_pass'):
                delattr(self, '_batch_retry_pass')
            if hasattr(self, '_batch_retry_enabled'):
                delattr(self, '_batch_retry_enabled')
            if hasattr(self, '_batch_provider_type'):
                delattr(self, '_batch_provider_type')
            if hasattr(self, '_batch_provider_name'):
                delattr(self, '_batch_provider_name')
            if hasattr(self, '_batch_model'):
                delattr(self, '_batch_model')
            
            # Show final completion message
            if retry_enabled and translation_provider_type == 'LLM':
                # Check final state
                final_empty = sum(1 for _, seg in segments_to_translate if not seg.target or not seg.target.strip())
                if final_empty > 0:
                    current_label.setText(
                        f"<b>‚úì Batch translation complete!</b><br>"
                        f"Successfully translated: {translated_count}<br>"
                        f"Failed: {failed_count}<br>"
                        f"Still empty: {final_empty}<br><br>"
                        f"<i>Max retries ({max_retries}) reached.</i>"
                    )
                else:
                    current_label.setText(
                        f"<b>‚úì Batch translation complete!</b><br>"
                        f"Successfully translated: {translated_count}<br>"
                        f"All segments now have translations! üéâ"
                    )
            else:
                current_label.setText(
                    f"<b>‚úì Batch translation complete!</b><br>"
                    f"Successfully translated: {translated_count}<br>"
                    f"Failed: {failed_count}"
                )

            close_btn.setEnabled(True)

            self.log(f"‚úì Batch translation complete: {translated_count} translated, {failed_count} failed")
            
            # Auto-resize all rows to fit new translations
            self.auto_resize_rows()
            
            # Update status bar progress stats
            self.update_progress_stats()

        except Exception as e:
            QMessageBox.critical(
                progress,
                "Batch Translation Error",
                f"Batch translation failed:\n\n{str(e)}"
            )
            self.log(f"‚úó Batch translation error: {str(e)}")
            close_btn.setEnabled(True)

        progress.exec()
    
    def _fetch_llm_translation_async(self, source_text: str, segment, row_index: int):
        """Fetch LLM translation asynchronously and add to results panel"""
        if not source_text or not source_text.strip():
            return
        
        # Check if we have API keys and LLM settings configured
        api_keys = self.load_api_keys()
        if not api_keys:
            return  # No API keys configured, skip LLM

        settings = self.load_llm_settings()
        provider = settings.get('provider', 'openai')
        
        # Check if provider is enabled
        enabled_providers = self.load_provider_enabled_states()
        provider_enabled_map = {
            "openai": "llm_openai",
            "claude": "llm_claude",
            "gemini": "llm_gemini"
        }
        enabled_key = provider_enabled_map.get(provider)
        if not enabled_providers.get(enabled_key, True):
            return  # Provider is disabled, skip LLM
        
        provider_key_map = {
            "openai": "openai",
            "claude": "claude",
            "gemini": "gemini"
        }
        api_key_name = provider_key_map.get(provider)
        # Handle gemini/google alias
        api_key_value = api_keys.get(api_key_name) or (api_keys.get('google') if provider == 'gemini' else None)
        if not api_key_value:
            return  # No API key for selected provider
        
        # Get model based on provider
        model_map = {
            "openai": settings.get('openai_model', 'gpt-4o'),
            "claude": settings.get('claude_model', 'claude-sonnet-4-5-20250929'),
            "gemini": settings.get('gemini_model', 'gemini-2.5-flash')
        }
        model = model_map.get(provider, 'gpt-4o')
        
        # Get languages
        source_lang = getattr(self.current_project, 'source_lang', 'en')
        target_lang = getattr(self.current_project, 'target_lang', 'nl')
        
        # Use QTimer to run in background (non-blocking)
        def fetch_and_update():
            try:
                from modules.llm_clients import LLMClient
                from modules.translation_results_panel import TranslationMatch
                
                client = LLMClient(
                    api_key=api_key_value,
                    provider=provider,
                    model=model
                )
                
                # Build full prompt using prompt manager
                custom_prompt = None
                try:
                    # Access parent through closure
                    parent = self
                    if hasattr(parent, 'prompt_manager_qt') and parent.prompt_manager_qt:
                        # Get glossary terms for AI injection
                        glossary_terms = parent.get_ai_inject_glossary_terms() if hasattr(parent, 'get_ai_inject_glossary_terms') else []
                        custom_prompt = parent.prompt_manager_qt.build_final_prompt(
                            source_text=source_text,
                            source_lang=source_lang,
                            target_lang=target_lang,
                            mode="single",
                            glossary_terms=glossary_terms
                        )
                except Exception as e:
                    self.log(f"‚ö† Could not build LLM prompt from manager: {e}")
                
                translation = client.translate(
                    text=source_text,
                    source_lang=source_lang,
                    target_lang=target_lang,
                    custom_prompt=custom_prompt
                )
                
                if translation and hasattr(self, 'assistance_widget') and self.assistance_widget:
                    # Check if this segment is still selected
                    current_row = self.table.currentRow()
                    if current_row == row_index:
                        # Map provider to code
                        provider_code_map = {
                            'openai': 'GPT',
                            'claude': 'CL',
                            'gemini': 'GEM'
                        }
                        provider_code = provider_code_map.get(provider, 'LLM')
                        
                        # Create LLM match
                        llm_match = TranslationMatch(
                            source=source_text,
                            target=translation,
                            relevance=98,  # High relevance for LLM
                            metadata={
                                'model': model,
                                'provider': provider,
                                'timestamp': datetime.now().isoformat()
                            },
                            match_type='LLM',
                            compare_source=source_text,
                            provider_code=provider_code
                        )
                        
                        # Update all results panels with LLM match
                        if hasattr(self, 'results_panels'):
                            current_matches = {"LLM": [llm_match]}
                            for panel in self.results_panels:
                                try:
                                    # Get current matches and add LLM
                                    if hasattr(panel, 'matches_by_type'):
                                        existing_matches = panel.matches_by_type.copy()
                                        existing_matches["LLM"] = [llm_match]
                                        panel.set_matches(existing_matches)
                                    else:
                                        panel.set_matches(current_matches)
                                except Exception as e:
                                    self.log(f"Error updating panel with LLM: {e}")
                        self.log(f"‚úì LLM translation added to results pane")
            except Exception as e:
                # Silently fail - don't interrupt workflow
                self.log(f"LLM translation failed (silent): {str(e)}")
        
        # Use QTimer to run async (small delay to avoid blocking)
        QTimer.singleShot(100, fetch_and_update)
    
    def _fetch_mt_translation_async(self, source_text: str, segment, row_index: int):
        """Fetch Machine Translation asynchronously and add to results panel"""
        if not source_text or not source_text.strip():
            return
        
        # Check if we have MT API keys configured
        api_keys = self.load_api_keys()
        if not api_keys:
            return  # No API keys configured, skip MT
        
        # Check enabled providers
        enabled_providers = self.load_provider_enabled_states()
        
        # Try MT providers in priority order (first available and enabled wins)
        # Priority: Google Translate > DeepL > Microsoft > Amazon > ModernMT > MyMemory
        mt_provider = None
        mt_api_key = None
        
        if enabled_providers.get('mt_google_translate', True) and api_keys.get('google_translate'):
            mt_provider = 'google_translate'
            mt_api_key = api_keys['google_translate']
        elif enabled_providers.get('mt_deepl', True) and api_keys.get('deepl'):
            mt_provider = 'deepl'
            mt_api_key = api_keys['deepl']
        elif enabled_providers.get('mt_microsoft', True) and (api_keys.get('microsoft_translate') or api_keys.get('azure_translate')):
            mt_provider = 'microsoft'
            mt_api_key = api_keys.get('microsoft_translate') or api_keys.get('azure_translate')
        elif enabled_providers.get('mt_amazon', True) and (api_keys.get('amazon_translate') or api_keys.get('aws_translate')):
            mt_provider = 'amazon'
            mt_api_key = api_keys.get('amazon_translate') or api_keys.get('aws_translate')
        elif enabled_providers.get('mt_modernmt', True) and api_keys.get('modernmt'):
            mt_provider = 'modernmt'
            mt_api_key = api_keys['modernmt']
        elif enabled_providers.get('mt_mymemory', True) and api_keys.get('mymemory'):
            mt_provider = 'mymemory'
            mt_api_key = api_keys.get('mymemory')  # Optional, MyMemory works without key
        # Note: MyMemory can work without a key, but we only use it if explicitly configured
        else:
            return  # No MT API keys available or all providers disabled
        
        # Get languages
        source_lang = getattr(self.current_project, 'source_lang', 'en')
        target_lang = getattr(self.current_project, 'target_lang', 'nl')
        
        # Use QTimer to run in background (non-blocking)
        def fetch_and_update():
            try:
                from modules.translation_results_panel import TranslationMatch
                
                # Call appropriate MT service
                if mt_provider == 'google_translate':
                    translation = self.call_google_translate(source_text, source_lang, target_lang, mt_api_key)
                    provider_name = 'Google Translate'
                elif mt_provider == 'deepl':
                    translation = self.call_deepl(source_text, source_lang, target_lang, mt_api_key)
                    provider_name = 'DeepL'
                elif mt_provider == 'microsoft':
                    translation = self.call_microsoft_translate(source_text, source_lang, target_lang, mt_api_key)
                    provider_name = 'Microsoft Translator'
                elif mt_provider == 'amazon':
                    # Amazon requires region, check for amazon_translate_region or use default
                    region = api_keys.get('amazon_translate_region', 'us-east-1')
                    translation = self.call_amazon_translate(source_text, source_lang, target_lang, mt_api_key, region)
                    provider_name = 'Amazon Translate'
                elif mt_provider == 'modernmt':
                    translation = self.call_modernmt(source_text, source_lang, target_lang, mt_api_key)
                    provider_name = 'ModernMT'
                elif mt_provider == 'mymemory':
                    translation = self.call_mymemory(source_text, source_lang, target_lang, mt_api_key)
                    provider_name = 'MyMemory'
                else:
                    return
                
                if translation and not translation.startswith('['):  # Skip error messages
                    if hasattr(self, 'assistance_widget') and self.assistance_widget:
                        # Check if this segment is still selected
                        current_row = self.table.currentRow()
                        if current_row == row_index:
                            # Map provider to code
                            provider_code_map = {
                                'Google Translate': 'GT',
                                'DeepL': 'DL',
                                'Microsoft Translator': 'MS',
                                'Amazon Translate': 'AT',
                                'ModernMT': 'MMT',
                                'MyMemory': 'MM'
                            }
                            provider_code = provider_code_map.get(provider_name, 'MT')
                            
                            # Create MT match
                            mt_match = TranslationMatch(
                                source=source_text,
                                target=translation,
                                relevance=95,  # High relevance for MT
                                metadata={
                                    'provider': provider_name,
                                    'timestamp': datetime.now().isoformat()
                                },
                                match_type='MT',
                                compare_source=source_text,
                                provider_code=provider_code
                            )
                            
                            # Update all results panels with MT match
                            if hasattr(self, 'results_panels'):
                                current_matches = {"MT": [mt_match]}
                                for panel in self.results_panels:
                                    try:
                                        # Get current matches and add MT
                                        if hasattr(panel, 'matches_by_type'):
                                            existing_matches = panel.matches_by_type.copy()
                                            existing_matches["MT"] = [mt_match]
                                            panel.set_matches(existing_matches)
                                        else:
                                            panel.set_matches(current_matches)
                                    except Exception as e:
                                        self.log(f"Error updating panel with MT: {e}")
                            self.log(f"‚úì MT translation ({provider_name}) added to results pane")
            except Exception as e:
                # Silently fail - don't interrupt workflow
                self.log(f"MT translation failed (silent): {str(e)}")
        
        # Use QTimer to run async (small delay to avoid blocking, slightly after LLM)
        QTimer.singleShot(150, fetch_and_update)
    
    def call_google_translate(self, text: str, source_lang: str, target_lang: str, api_key: str = None) -> str:
        """Call Google Cloud Translation API using REST API"""
        try:
            import requests
            import html
            
            if not api_key:
                api_keys = self.load_api_keys()
                api_key = api_keys.get("google_translate")
            
            if not api_key:
                return "[Google Cloud Translation requires API key]"
            
            # Map full language names to ISO codes
            lang_name_to_code = {
                'english': 'en', 'dutch': 'nl', 'german': 'de', 'french': 'fr',
                'spanish': 'es', 'italian': 'it', 'portuguese': 'pt', 'russian': 'ru',
                'chinese': 'zh', 'japanese': 'ja', 'korean': 'ko', 'arabic': 'ar',
                'polish': 'pl', 'swedish': 'sv', 'norwegian': 'no', 'danish': 'da',
                'finnish': 'fi', 'greek': 'el', 'turkish': 'tr', 'czech': 'cs',
                'hungarian': 'hu', 'romanian': 'ro', 'bulgarian': 'bg', 'ukrainian': 'uk',
                'hebrew': 'he', 'thai': 'th', 'vietnamese': 'vi', 'indonesian': 'id',
                'malay': 'ms', 'hindi': 'hi', 'bengali': 'bn', 'tamil': 'ta',
            }
            
            # Convert language - try name mapping first, then code extraction
            src_lower = source_lang.lower().strip()
            tgt_lower = target_lang.lower().strip()
            
            src_code = lang_name_to_code.get(src_lower, src_lower.split('-')[0].split('_')[0])
            tgt_code = lang_name_to_code.get(tgt_lower, tgt_lower.split('-')[0].split('_')[0])
            
            # Call REST API directly
            url = "https://translation.googleapis.com/language/translate/v2"
            params = {
                'key': api_key,
                'q': text,
                'source': src_code,
                'target': tgt_code,
                'format': 'text'
            }
            
            response = requests.post(url, params=params, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            translated_text = result['data']['translations'][0]['translatedText']
            # Unescape HTML entities like &quot; &amp; etc.
            return html.unescape(translated_text)
            
        except ImportError:
            return "[Google Translate requires: pip install requests]"
        except Exception as e:
            return f"[Google Translate error: {str(e)}]"
    
    def call_deepl(self, text: str, source_lang: str, target_lang: str, api_key: str = None) -> str:
        """Call DeepL API"""
        try:
            import deepl
            
            if not api_key:
                api_keys = self.load_api_keys()
                api_key = api_keys.get("deepl")
            
            if not api_key:
                return "[DeepL requires API key]"
            
            translator = deepl.Translator(api_key)
            
            # Convert language codes (DeepL uses uppercase)
            src_code = source_lang.split('-')[0].split('_')[0].upper()
            tgt_code = target_lang.split('-')[0].split('_')[0].upper()
            
            result = translator.translate_text(text, source_lang=src_code, target_lang=tgt_code)
            return result.text
            
        except ImportError:
            return "[DeepL requires: pip install deepl]"
        except Exception as e:
            return f"[DeepL error: {str(e)}]"
    
    def call_microsoft_translate(self, text: str, source_lang: str, target_lang: str, api_key: str = None, region: str = None) -> str:
        """Call Microsoft Azure Translator API"""
        try:
            import requests
            
            api_keys = self.load_api_keys()
            if not api_key:
                api_key = api_keys.get("microsoft_translate") or api_keys.get("azure_translate")
            if not region:
                region = api_keys.get("microsoft_translate_region") or api_keys.get("azure_region") or "global"
            
            if not api_key:
                return "[Microsoft Translator requires API key]"
            
            # Convert language codes (Azure uses standard codes)
            src_code = source_lang.split('-')[0].split('_')[0].lower()
            tgt_code = target_lang.split('-')[0].split('_')[0].lower()
            
            # Microsoft Translator API v3.0
            endpoint = f"https://api.cognitive.microsofttranslator.com/translate"
            params = {
                'api-version': '3.0',
                'from': src_code,
                'to': tgt_code
            }
            headers = {
                'Ocp-Apim-Subscription-Key': api_key,
                'Ocp-Apim-Subscription-Region': region,
                'Content-Type': 'application/json'
            }
            body = [{'text': text}]
            
            response = requests.post(endpoint, params=params, headers=headers, json=body, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            return result[0]['translations'][0]['text']
            
        except ImportError:
            return "[Microsoft Translator requires: pip install requests]"
        except Exception as e:
            return f"[Microsoft Translator error: {str(e)}]"
    
    def call_amazon_translate(self, text: str, source_lang: str, target_lang: str, api_key: str = None, region: str = 'us-east-1') -> str:
        """Call Amazon Translate API (AWS)"""
        try:
            import boto3
            from botocore.exceptions import ClientError
            
            api_keys = self.load_api_keys()
            if not api_key:
                api_key = api_keys.get("amazon_translate") or api_keys.get("aws_translate")
            
            # AWS also needs secret key
            secret_key = api_keys.get("amazon_translate_secret") or api_keys.get("aws_secret_key")
            
            if not api_key or not secret_key:
                return "[Amazon Translate requires API key and secret key]"
            
            # Get region from settings if not provided
            if not region or region == 'us-east-1':
                region = api_keys.get("amazon_translate_region", "us-east-1")
            
            # Map full language names to ISO codes
            lang_name_to_code = {
                'english': 'en', 'dutch': 'nl', 'german': 'de', 'french': 'fr',
                'spanish': 'es', 'italian': 'it', 'portuguese': 'pt', 'russian': 'ru',
                'chinese': 'zh', 'japanese': 'ja', 'korean': 'ko', 'arabic': 'ar',
                'polish': 'pl', 'swedish': 'sv', 'norwegian': 'no', 'danish': 'da',
                'finnish': 'fi', 'greek': 'el', 'turkish': 'tr', 'czech': 'cs',
                'hungarian': 'hu', 'romanian': 'ro', 'bulgarian': 'bg', 'ukrainian': 'uk',
            }
            
            # Convert language - try name mapping first, then code extraction
            src_lower = source_lang.lower().strip()
            tgt_lower = target_lang.lower().strip()
            
            src_code = lang_name_to_code.get(src_lower, src_lower.split('-')[0].split('_')[0])
            tgt_code = lang_name_to_code.get(tgt_lower, tgt_lower.split('-')[0].split('_')[0])
            
            translate_client = boto3.client(
                'translate',
                aws_access_key_id=api_key,
                aws_secret_access_key=secret_key,
                region_name=region
            )
            
            result = translate_client.translate_text(
                Text=text,
                SourceLanguageCode=src_code,
                TargetLanguageCode=tgt_code
            )
            
            return result['TranslatedText']
            
        except ImportError:
            return "[Amazon Translate requires: pip install boto3]"
        except Exception as e:
            return f"[Amazon Translate error: {str(e)}]"
    
    def call_modernmt(self, text: str, source_lang: str, target_lang: str, api_key: str = None) -> str:
        """Call ModernMT API"""
        try:
            import requests
            
            api_keys = self.load_api_keys()
            if not api_key:
                api_key = api_keys.get("modernmt")
            
            if not api_key:
                return "[ModernMT requires API key]"
            
            # Convert language codes
            src_code = source_lang.split('-')[0].split('_')[0]
            tgt_code = target_lang.split('-')[0].split('_')[0]
            
            # ModernMT API endpoint
            url = "https://api.modernmt.com/translate"
            headers = {
                'MMT-ApiKey': api_key,
                'Content-Type': 'application/json'
            }
            data = {
                'q': text,
                'source': src_code,
                'target': tgt_code
            }
            
            response = requests.post(url, headers=headers, json=data, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            return result['data']['translation']
            
        except ImportError:
            return "[ModernMT requires: pip install requests]"
        except Exception as e:
            return f"[ModernMT error: {str(e)}]"
    
    def call_mymemory(self, text: str, source_lang: str, target_lang: str, api_key: str = None) -> str:
        """Call MyMemory Translation API (free tier available, simple REST API)"""
        try:
            import requests
            
            # MyMemory is free, but API key provides higher limits
            api_keys = self.load_api_keys()
            api_key = api_key or api_keys.get("mymemory")  # Optional, works without key
            
            # Convert language codes (MyMemory uses 2-letter codes)
            src_code = source_lang.split('-')[0].split('_')[0].lower()
            tgt_code = target_lang.split('-')[0].split('_')[0].lower()
            
            # MyMemory API endpoint
            url = "https://api.mymemory.translated.net/get"
            params = {
                'q': text,
                'langpair': f"{src_code}|{tgt_code}"
            }
            if api_key:
                params['key'] = api_key
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            result = response.json()
            if result.get('responseStatus') == 200:
                return result['responseData']['translatedText']
            else:
                return f"[MyMemory error: {result.get('responseDetails', 'Unknown error')}]"
            
        except ImportError:
            return "[MyMemory requires: pip install requests]"
        except Exception as e:
            return f"[MyMemory error: {str(e)}]"
    
    def load_api_keys(self) -> Dict[str, str]:
        """Load API keys with dev-first priority
        
        Priority order:
        1. user_data_private/api_keys.txt (dev mode, gitignored)
        2. user_data/api_keys.txt (user mode, shipped with app)
        """
        api_keys = {}
        
        # Priority 1: Dev mode (gitignored, never shipped)
        dev_file = Path("user_data_private") / "api_keys.txt"
        
        # Priority 2: User mode (ships with app)
        user_file = self.user_data_path / "api_keys.txt"
        
        # Check dev first, then user
        if dev_file.exists():
            api_keys_file = dev_file
        elif user_file.exists():
            api_keys_file = user_file
        else:
            return api_keys
        
        try:
            with open(api_keys_file, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and '=' in line and not line.startswith('#'):
                        key, value = line.split('=', 1)
                        api_keys[key.strip().lower()] = value.strip()
        except Exception as e:
            self.log(f"‚ö† Error loading API keys: {str(e)}")
        
        # Normalize gemini/google aliases - users can use either name
        # This allows downstream code to just use api_keys.get('gemini') directly
        if api_keys.get('google') and not api_keys.get('gemini'):
            api_keys['gemini'] = api_keys['google']
        elif api_keys.get('gemini') and not api_keys.get('google'):
            api_keys['google'] = api_keys['gemini']
        
        return api_keys

    def get_ai_inject_glossary_terms(self) -> list:
        """Get glossary terms from AI-inject-enabled termbases for the current project.

        Returns:
            List of term dictionaries with source_term, target_term, forbidden keys
        """
        if not hasattr(self, 'termbase_mgr') or not self.termbase_mgr:
            return []

        project_id = None
        if hasattr(self, 'current_project') and self.current_project:
            project_id = getattr(self.current_project, 'id', None)

        return self.termbase_mgr.get_ai_inject_terms(project_id)

    def ensure_example_api_keys(self):
        """Create example API keys file on first launch for new users"""
        example_file = self.user_data_path / "api_keys.example.txt"
        
        # Only create if it doesn't exist
        if example_file.exists():
            return
        
        example_content = """# Supervertaler API Keys Configuration
# =======================================
# 
# Add your API keys below. Remove the # to activate a key.
# Never commit this file with real keys to version control!
#
# For actual use:
# 1. Copy this file to "api_keys.txt" in the same folder
# 2. Add your real API keys (remove the # from the lines you use)
# 3. Save the file
#
# Available providers:

# OpenAI (GPT-4, GPT-4o, GPT-5, o1, o3 models)
# Get your key at: https://platform.openai.com/api-keys
#openai = YOUR_OPENAI_KEY_HERE

# Anthropic Claude (Claude Sonnet 4.5, Haiku 4.5, Opus 4.1)
# Get your key at: https://console.anthropic.com/settings/keys
#claude = YOUR_CLAUDE_KEY_HERE

# Google Gemini (Gemini 2.0 Flash, Pro models)
# Get your key at: https://aistudio.google.com/app/apikey
#google = YOUR_GOOGLE_GEMINI_KEY_HERE

# ===== Machine Translation APIs (for MT preview) =====

# Supervertaler will use MT providers in this priority order (first available):
# 1. Google Translate
# 2. DeepL
# 3. Microsoft Translator
# 4. Amazon Translate
# 5. ModernMT
# 6. MyMemory (free fallback, works without key)

# Google Cloud Translation API (Priority: Highest)
# Get your key at: https://console.cloud.google.com/apis/credentials
# Enable "Cloud Translation API" first, then create API key
#google_translate = YOUR_GOOGLE_CLOUD_TRANSLATE_API_KEY

# DeepL API Pro
# Get your key at: https://www.deepl.com/pro-api
# Note: Free DeepL web version keys don't work, you need API Pro
#deepl = YOUR_DEEPL_API_PRO_KEY

# Microsoft Azure Translator
# Get your key at: https://azure.microsoft.com/en-us/services/cognitive-services/translator/
# Requires Azure subscription
#microsoft_translate = YOUR_AZURE_TRANSLATOR_KEY
#microsoft_translate_region = global
# (Region examples: "global", "eastus", "westus")

# Amazon Translate (AWS)
# Get your keys at: https://aws.amazon.com/translate/
# Requires AWS account
#amazon_translate = YOUR_AWS_ACCESS_KEY_ID
#amazon_translate_secret = YOUR_AWS_SECRET_ACCESS_KEY
#amazon_translate_region = us-east-1
# (AWS region examples: "us-east-1", "eu-west-1", etc.)

# ModernMT
# Get your key at: https://www.modernmt.com/api
#modernmt = YOUR_MODERNMT_API_KEY

# MyMemory Translation (Free tier available, no key required)
# Get API key (optional, for higher limits): https://mymemory.translated.net/
# Works without key but with lower rate limits
#mymemory = YOUR_MYMEMORY_KEY

# ===== NOTES =====

# Temperature settings for reasoning models:
# - GPT-5, o1, o3: Temperature parameter OMITTED (not supported by these models)
# - Standard models: Use temperature=0.3 (automatically applied)

# TROUBLESHOOTING:
# ---------------
# If you see "API Key Missing" errors:
# 1. Check that your file is named "api_keys.txt" (not "api_keys.example.txt")
# 2. Make sure the # is removed from the beginning of the line
# 3. Verify there are no extra spaces around the = sign
# 4. Confirm your key is valid (test at the provider's website)
#
# If keys still don't work:
# 1. Check console output to see which file was loaded
# 2. Look for errors: "Error reading api_keys.txt"
# 3. Restart Supervertaler after editing api_keys.txt
#
# DeepL Authorization Error:
# - Your key must be for "DeepL API Pro" (not free web version)
# - Get API key from: https://www.deepl.com/pro-api
#
# Google Translate Error:
# - Enable "Cloud Translation API" in Google Cloud Console
# - Create API key at: https://console.cloud.google.com/apis/credentials
"""
        
        try:
            with open(example_file, 'w', encoding='utf-8') as f:
                f.write(example_content)
            self.log(f"‚úì Created example API keys file: {example_file}")
        except Exception as e:
            self.log(f"‚ö† Could not create example API keys file: {str(e)}")
    
    def show_autofingers(self):
        """Show AutoFingers by switching to the AutoFingers tab"""
        # Find the AutoFingers tab index and activate it
        # AutoFingers is in Tools tab (main_tabs index 3)
        if hasattr(self, 'main_tabs'):
            self.main_tabs.setCurrentIndex(3)  # Switch to Tools tab
            # Then switch to AutoFingers sub-tab
            if hasattr(self, 'modules_tabs'):
                for i in range(self.modules_tabs.count()):
                    if "AutoFingers" in self.modules_tabs.tabText(i):
                        self.modules_tabs.setCurrentIndex(i)
                        break
    
    def show_image_extractor_from_tools(self):
        """Show Image Extractor by switching to the Image Context tab in Project resources"""
        # Switch to Project resources tab (main_tabs index 1)
        if hasattr(self, 'main_tabs'):
            self.main_tabs.setCurrentIndex(1)  # Switch to Project resources tab
            # Then switch to Image Context sub-tab
            if hasattr(self, 'resources_tabs'):
                for i in range(self.resources_tabs.count()):
                    if "Image Context" in self.resources_tabs.tabText(i):
                        self.resources_tabs.setCurrentIndex(i)
                        break
    
    def show_scratchpad(self):
        """Show Scratchpad dialog for private translator notes.
        
        Notes are saved with the project (.svproj) and never exported to CAT tools.
        """
        if not hasattr(self, 'current_project') or self.current_project is None:
            QMessageBox.warning(
                self,
                "No Project Open",
                "Please open or create a project first before using the Scratchpad."
            )
            return
        
        # Get current notes from project
        current_notes = getattr(self.current_project, 'scratchpad_notes', '') or ''
        
        dialog = ScratchpadDialog(self, current_notes)
        if dialog.exec():
            # Save the notes back to the project
            new_notes = dialog.get_notes()
            self.current_project.scratchpad_notes = new_notes
            
            # Mark project as modified so it will be saved
            self.current_project.modified = datetime.now().isoformat()
            
            # Update status bar / log
            if new_notes:
                note_preview = new_notes[:50] + "..." if len(new_notes) > 50 else new_notes
                self.log(f"üìù Scratchpad notes updated: {note_preview.replace(chr(10), ' ')}")
            else:
                self.log("üìù Scratchpad notes cleared")
    
    def show_theme_editor(self):
        """Show Theme Editor dialog"""
        dialog = ThemeEditorDialog(self, self.theme_manager)
        if dialog.exec():
            # Theme may have been changed, reapply
            self.theme_manager.apply_theme(QApplication.instance())
            # Refresh all theme-dependent UI elements
            self.refresh_theme_colors()

    def refresh_theme_colors(self):
        """Refresh all theme-dependent UI elements when theme changes"""
        theme = self.theme_manager.current_theme
        print(f"üé® refresh_theme_colors() called, theme={theme.name}", flush=True)
        with open("theme_debug.txt", "a") as f:
            f.write(f"refresh_theme_colors() called, theme={theme.name}\n")
        
        # Clear row color cache to force refresh with new theme colors
        # Remove all theme-specific caches
        for attr in list(vars(self).keys()):
            if attr.startswith('_row_color_cache_'):
                delattr(self, attr)
        
        # Reapply alternating row colors with new theme
        if hasattr(self, 'apply_alternating_row_colors'):
            self.apply_alternating_row_colors()

        # Update navigation arrow colors based on theme
        if hasattr(self, 'theme_aware_arrows'):
            is_dark = theme.name == "Dark"
            arrow_color = "#FFFFFF" if is_dark else "#333333"
            for arrow in self.theme_aware_arrows:
                if hasattr(arrow, 'set_color'):
                    arrow.set_color(arrow_color)

        # Refresh segment numbers color
        if hasattr(self, 'table') and self.table:
            # Determine segment number color based on theme
            is_dark_theme = theme.name == "Dark"
            segment_num_color = theme.text if is_dark_theme else "black"
            
            for row in range(self.table.rowCount()):
                id_item = self.table.item(row, 0)
                if id_item:
                    # Don't change currently highlighted row (orange background)
                    if id_item.background().color().name() != "#ffa500":
                        id_item.setForeground(QColor(segment_num_color))
        
        # Refresh TranslationResultsPanel
        if hasattr(self, 'translation_results_panel') and self.translation_results_panel:
            if hasattr(self.translation_results_panel, 'apply_theme'):
                print(f"üé® refresh_theme_colors: calling apply_theme on translation_results_panel", flush=True)
                with open("theme_debug.txt", "a") as f:
                    f.write(f"refresh_theme_colors: calling apply_theme on translation_results_panel\n")
                    f.write(f"  compare_text_edits count: {len(self.translation_results_panel.compare_text_edits)}\n")
                self.translation_results_panel.apply_theme()
        
        # Refresh Compare Panel colors
        if hasattr(self, 'compare_panel_text_edits') and self.compare_panel_text_edits:
            try:
                self._refresh_compare_panel_theme()
            except Exception as e:
                print(f"Error refreshing Compare Panel theme: {e}")
                import traceback
                traceback.print_exc()
        
        # Refresh TermviewWidget
        if hasattr(self, 'termview_widget') and self.termview_widget:
            if hasattr(self.termview_widget, 'apply_theme'):
                self.termview_widget.apply_theme()

        # Also refresh Match Panel TermView (right panel)
        if hasattr(self, 'termview_widget_match') and self.termview_widget_match:
            if hasattr(self.termview_widget_match, 'apply_theme'):
                self.termview_widget_match.apply_theme()

    def show_file_progress_dialog(self):
        """Show File Progress dialog for multi-file projects.
        
        Displays translation progress for each file in a multi-file project,
        including segment counts, word counts, and completion percentages.
        """
        from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel, 
                                      QTableWidget, QTableWidgetItem, QHeaderView,
                                      QPushButton, QProgressBar, QGroupBox)
        
        if not self.current_project:
            QMessageBox.information(self, "No Project", "Please open a project first.")
            return
        
        # Check if this is a multi-file project
        is_multifile = getattr(self.current_project, 'is_multifile', False)
        files = getattr(self.current_project, 'files', [])
        
        dialog = QDialog(self)
        dialog.setWindowTitle("üìÅ File Progress")
        dialog.setMinimumWidth(800)
        dialog.setMinimumHeight(500)
        
        layout = QVBoxLayout(dialog)
        
        if not is_multifile or not files:
            # Single-file project - show basic info
            info_label = QLabel(
                "<b>Single-File Project</b><br><br>"
                "This is a single-file project. Multi-file progress tracking is available "
                "when you import a folder using:<br>"
                "<i>File ‚Üí Import ‚Üí Folder (Multiple Files)...</i>"
            )
            info_label.setWordWrap(True)
            info_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(info_label)
            
            layout.addSpacing(20)
            
            # Show overall progress for single file
            self._add_overall_progress_section(layout)
            
        else:
            # Multi-file project - show per-file progress
            info_label = QLabel(
                f"<b>Multi-File Project: {len(files)} files</b><br>"
                f"Project: {self.current_project.name}"
            )
            info_label.setTextFormat(Qt.TextFormat.RichText)
            layout.addWidget(info_label)
            
            layout.addSpacing(10)
            
            # Overall progress section
            self._add_overall_progress_section(layout)
            
            layout.addSpacing(10)
            
            # Per-file progress table
            files_group = QGroupBox("Per-File Progress")
            files_layout = QVBoxLayout(files_group)
            
            table = QTableWidget()
            table.setColumnCount(7)
            table.setHorizontalHeaderLabels([
                "File", "Segments", "Words", "Translated", "Confirmed", "Progress", "Status"
            ])
            table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
            table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeMode.Fixed)
            table.setColumnWidth(5, 120)
            table.setRowCount(len(files))
            table.setAlternatingRowColors(True)
            table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
            table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
            
            # Calculate stats for each file
            segments = self.current_project.segments
            confirmed_statuses = {'confirmed', 'tr_confirmed', 'proofread', 'approved'}
            
            for row, file_info in enumerate(files):
                file_id = file_info['id']
                file_name = file_info['name']
                
                # Get segments for this file
                file_segments = [s for s in segments if getattr(s, 'file_id', None) == file_id]
                total_segs = len(file_segments)
                
                # Calculate stats
                total_words = sum(len(s.source.split()) for s in file_segments if s.source)
                translated_segs = sum(1 for s in file_segments if s.target and s.target.strip())
                translated_words = sum(len(s.source.split()) for s in file_segments if s.target and s.target.strip())
                confirmed_segs = sum(1 for s in file_segments if s.status in confirmed_statuses)
                
                trans_percent = (translated_segs / total_segs * 100) if total_segs > 0 else 0
                conf_percent = (confirmed_segs / total_segs * 100) if total_segs > 0 else 0
                
                # Determine status
                if conf_percent == 100:
                    status = "‚úÖ Complete"
                    status_color = "#4CAF50"
                elif trans_percent == 100:
                    status = "üìù Translated"
                    status_color = "#2196F3"
                elif trans_percent > 0:
                    status = "üîÑ In Progress"
                    status_color = "#FF9800"
                else:
                    status = "‚¨ú Not Started"
                    status_color = "#9E9E9E"
                
                # Add items to table
                table.setItem(row, 0, QTableWidgetItem(file_name))
                table.setItem(row, 1, QTableWidgetItem(str(total_segs)))
                table.setItem(row, 2, QTableWidgetItem(str(total_words)))
                table.setItem(row, 3, QTableWidgetItem(f"{translated_segs}/{total_segs} ({trans_percent:.0f}%)"))
                table.setItem(row, 4, QTableWidgetItem(f"{confirmed_segs}/{total_segs} ({conf_percent:.0f}%)"))
                
                # Progress bar
                progress_bar = QProgressBar()
                progress_bar.setMinimum(0)
                progress_bar.setMaximum(100)
                progress_bar.setValue(int(conf_percent))
                progress_bar.setTextVisible(True)
                progress_bar.setFormat(f"{conf_percent:.0f}%")
                table.setCellWidget(row, 5, progress_bar)
                
                status_item = QTableWidgetItem(status)
                status_item.setForeground(QColor(status_color))
                table.setItem(row, 6, status_item)
                
                # Color coding for translated column
                trans_item = table.item(row, 3)
                if trans_percent == 100:
                    trans_item.setForeground(QColor("#4CAF50"))
                elif trans_percent > 0:
                    trans_item.setForeground(QColor("#FF9800"))
            
            files_layout.addWidget(table)
            
            # Double-click to filter/navigate
            def on_file_double_click(row, col):
                file_info = files[row]
                file_id = file_info['id']
                file_name = file_info['name']
                
                # Filter to show only this file's segments
                if hasattr(self, 'source_filter_input'):
                    # Use file name as filter
                    reply = QMessageBox.question(
                        dialog,
                        "Navigate to File",
                        f"Go to the first segment of:\n{file_name}?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                    if reply == QMessageBox.StandardButton.Yes:
                        # Find first segment of this file
                        for seg in segments:
                            if getattr(seg, 'file_id', None) == file_id:
                                # Navigate to this segment
                                self.go_to_segment(seg.id)
                                dialog.accept()
                                return
            
            table.cellDoubleClicked.connect(on_file_double_click)
            
            layout.addWidget(files_group)
        
        # Close button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(close_btn)
        layout.addLayout(button_layout)
        
        dialog.exec()
    
    def _add_overall_progress_section(self, layout):
        """Add overall progress section to a layout (for File Progress dialog)."""
        from PyQt6.QtWidgets import QGroupBox, QGridLayout, QLabel, QProgressBar
        
        progress_group = QGroupBox("Overall Progress")
        grid = QGridLayout(progress_group)
        
        if not self.current_project or not self.current_project.segments:
            grid.addWidget(QLabel("No segments in project"), 0, 0)
            layout.addWidget(progress_group)
            return
        
        segments = self.current_project.segments
        total_segs = len(segments)
        
        # Calculate stats
        total_words = sum(len(s.source.split()) for s in segments if s.source)
        translated_segs = sum(1 for s in segments if s.target and s.target.strip())
        translated_words = sum(len(s.source.split()) for s in segments if s.target and s.target.strip())
        
        confirmed_statuses = {'confirmed', 'tr_confirmed', 'proofread', 'approved'}
        confirmed_segs = sum(1 for s in segments if s.status in confirmed_statuses)
        
        trans_percent = (translated_segs / total_segs * 100) if total_segs > 0 else 0
        conf_percent = (confirmed_segs / total_segs * 100) if total_segs > 0 else 0
        word_percent = (translated_words / total_words * 100) if total_words > 0 else 0
        
        # Row 1: Segments
        grid.addWidget(QLabel("<b>Segments:</b>"), 0, 0)
        grid.addWidget(QLabel(f"{translated_segs} / {total_segs} translated ({trans_percent:.1f}%)"), 0, 1)
        
        seg_progress = QProgressBar()
        seg_progress.setValue(int(trans_percent))
        grid.addWidget(seg_progress, 0, 2)
        
        # Row 2: Words
        grid.addWidget(QLabel("<b>Words:</b>"), 1, 0)
        grid.addWidget(QLabel(f"{translated_words} / {total_words} ({word_percent:.1f}%)"), 1, 1)
        
        word_progress = QProgressBar()
        word_progress.setValue(int(word_percent))
        grid.addWidget(word_progress, 1, 2)
        
        # Row 3: Confirmed
        grid.addWidget(QLabel("<b>Confirmed:</b>"), 2, 0)
        grid.addWidget(QLabel(f"{confirmed_segs} / {total_segs} ({conf_percent:.1f}%)"), 2, 1)
        
        conf_progress = QProgressBar()
        conf_progress.setValue(int(conf_percent))
        conf_progress.setStyleSheet("QProgressBar::chunk { background-color: #4CAF50; }")
        grid.addWidget(conf_progress, 2, 2)
        
        layout.addWidget(progress_group)

    def get_themed_button_style(self, button_type: str, extra_styles: str = "") -> str:
        """
        Get a theme-aware button style.

        Args:
            button_type: Type of button - 'success', 'info', 'warning', 'danger', 'neutral', 'purple'
            extra_styles: Additional CSS styles to append (e.g., "padding: 10px;")

        Returns:
            CSS stylesheet string for the button
        """
        theme = self.theme_manager.current_theme

        # Map button type to theme color
        color_map = {
            'success': theme.button_success,
            'info': theme.button_info,
            'warning': theme.button_warning,
            'danger': theme.button_danger,
            'neutral': theme.button_neutral,
            'purple': theme.button_purple,
        }

        bg_color = color_map.get(button_type, theme.button)
        return f"background-color: {bg_color}; color: white; font-weight: bold; {extra_styles}"

    def get_themed_panel_style(self, panel_type: str, extra_styles: str = "") -> str:
        """
        Get a theme-aware panel/info box style.

        Args:
            panel_type: Type of panel - 'info', 'warning', 'neutral', 'preview', 'accent'
            extra_styles: Additional CSS styles to append

        Returns:
            CSS stylesheet string for the panel
        """
        theme = self.theme_manager.current_theme

        # Map panel type to theme color
        color_map = {
            'info': theme.panel_info,
            'warning': theme.panel_warning,
            'neutral': theme.panel_neutral,
            'preview': theme.panel_preview,
            'accent': theme.panel_accent,
        }

        bg_color = color_map.get(panel_type, theme.window_bg)
        # Use appropriate text color based on panel type
        text_color = theme.text if panel_type != 'warning' else theme.text

        return f"background-color: {bg_color}; color: {text_color}; {extra_styles}"

    def _schedule_mt_and_llm_matches(self, segment, termbase_matches=None):
        """Schedule MT and LLM matches with debouncing - only call APIs when user stops clicking"""
        try:
            # Cancel any previous MT/LLM requests
            if hasattr(self, '_mt_llm_timer'):
                self._mt_llm_timer.stop()
            
            # Store segment and termbase matches for delayed lookup
            self._pending_mt_llm_segment = segment
            self._pending_termbase_matches = termbase_matches or []
            
            # Start debounced timer - only call APIs after user stops navigating
            from PyQt6.QtCore import QTimer
            self._mt_llm_timer = QTimer()
            self._mt_llm_timer.setSingleShot(True)
            self._mt_llm_timer.timeout.connect(lambda: self._execute_mt_llm_lookup())
            self._mt_llm_timer.start(150)  # Wait 150ms of inactivity before external API calls
                
        except Exception as e:
            self.log(f"Error scheduling MT/LLM search: {e}")
    
    def _execute_mt_llm_lookup(self):
        """Execute the actual MT/LLM lookup after debounce delay"""
        try:
            if not hasattr(self, '_pending_mt_llm_segment'):
                return
                
            segment = self._pending_mt_llm_segment
            
            # Call the actual lookup method (now includes TM, MT, and LLM)
            self._search_mt_and_llm_matches(segment)
                
        except Exception as e:
            self.log(f"Error executing MT/LLM lookup: {e}")
            import traceback
            self.log(f"Delayed lookup error traceback: {traceback.format_exc()}")
    
    def _search_mt_and_llm_matches(self, segment):
        """Search for TM, MT and LLM matches - called only after debounce delay"""
        try:
            from modules.translation_results_panel import TranslationMatch

            # v1.9.182: Validate we're still on the same segment before displaying results
            # This prevents stale results from showing when user navigates quickly
            current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
            if current_row >= 0:
                id_item = self.table.item(current_row, 0)
                if id_item:
                    try:
                        current_segment_id = int(id_item.text())
                        if current_segment_id != segment.id:
                            # User has moved to a different segment - abort this lookup
                            return
                    except (ValueError, AttributeError):
                        pass

            # Get current project languages for all translation services
            source_lang = getattr(self.current_project, 'source_lang', None) if self.current_project else None
            target_lang = getattr(self.current_project, 'target_lang', None) if self.current_project else None
            
            # Convert language names to codes if needed
            source_lang_code = None
            target_lang_code = None
            if source_lang:
                source_lang_code = self._convert_language_to_code(source_lang)
            if target_lang:
                target_lang_code = self._convert_language_to_code(target_lang)
            
            # Initialize Compare Panel data
            self._compare_panel_tm_source = ''
            self._compare_panel_tm_target = ''
            self._compare_panel_tm_percent = 0
            self._compare_panel_mt = ''
            self._compare_panel_tm_matches = []  # Reset TM matches list for navigation
            self._compare_panel_mt_matches = []  # Reset MT matches list for navigation
            
            # Update Match Panel with current source immediately (before TM/MT lookup)
            self.set_compare_panel_matches(segment.id, segment.source, [], [])
            
            # Prepare matches dict - use the stored termbase matches from immediate display
            matches_dict = {
                "LLM": [],
                "NT": [],
                "MT": [],
                "TM": [],
                "Termbases": getattr(self, '_pending_termbase_matches', [])
            }
            
            # üî• DELAYED TM SEARCH: Search TM database using new TMDatabase with activated TMs
            if self.enable_tm_matching and hasattr(self, 'tm_database') and self.tm_database:
                try:
                    # Get activated TM IDs for current project
                    tm_ids = None
                    if hasattr(self, 'tm_metadata_mgr') and self.tm_metadata_mgr and self.current_project:
                        project_id = self.current_project.id if hasattr(self.current_project, 'id') else None
                        if project_id:
                            tm_ids = self.tm_metadata_mgr.get_active_tm_ids(project_id)
                    
                    # Skip TM search if no TMs are activated
                    if tm_ids is not None and isinstance(tm_ids, list) and len(tm_ids) == 0:
                        all_tm_matches = []
                    else:
                        # Search using TMDatabase (includes bidirectional + base language matching)
                        all_tm_matches = self.tm_database.search_all(segment.source, tm_ids=tm_ids, enabled_only=False, max_matches=10)
                    
                    # Single consolidated log message for TM search results
                    if all_tm_matches:
                        self.log(f"üîç TM: Found {len(all_tm_matches)} matches for segment {segment.id}")
                    
                    for match in all_tm_matches:
                        match_obj = TranslationMatch(
                            source=match.get('source', ''),
                            target=match.get('target', ''),
                            relevance=match.get('match_pct', 0),
                            metadata={
                                'context': match.get('context', ''),
                                'tm_name': match.get('tm_name', ''),
                                'timestamp': match.get('created_at', ''),
                                'direction': 'reverse' if 'Reverse' in match.get('tm_name', '') else 'primary'
                            },
                            match_type='TM',
                            compare_source=match.get('source', ''),
                            provider_code='TM'
                        )
                        matches_dict["TM"].append(match_obj)
                    
                    # Show TM matches immediately (progressive loading)
                    if matches_dict["TM"]:
                        # v1.9.182: Re-validate we're still on same segment before displaying
                        current_row = self.table.currentRow() if hasattr(self, 'table') and self.table else -1
                        if current_row >= 0:
                            id_item = self.table.item(current_row, 0)
                            if id_item:
                                try:
                                    current_segment_id = int(id_item.text())
                                    if current_segment_id != segment.id:
                                        # User moved - still cache results but don't display
                                        with self.translation_matches_cache_lock:
                                            if segment.id in self.translation_matches_cache:
                                                self.translation_matches_cache[segment.id]["TM"] = matches_dict["TM"]
                                        return  # Don't display stale results
                                except (ValueError, AttributeError):
                                    pass

                        tm_only = {"TM": matches_dict["TM"]}
                        if hasattr(self, 'results_panels') and self.results_panels:
                            for panel in self.results_panels:
                                try:
                                    panel.add_matches(tm_only)
                                except Exception as e:
                                    self.log(f"Error adding TM matches: {e}")
                        
                        # üîÑ Update Match Panel with all TM matches (for navigation)
                        # Convert TranslationMatch objects to dict format for Match Panel
                        tm_matches_for_panel = []
                        for tm in matches_dict["TM"]:
                            tm_name = tm.metadata.get('tm_name', 'TM') if tm.metadata else 'TM'
                            tm_matches_for_panel.append({
                                'source': tm.compare_source or tm.source,
                                'target': tm.target,
                                'tm_name': tm_name,
                                'match_pct': int(tm.relevance)
                            })
                        # Store for later (MT will be added when available)
                        self._compare_panel_tm_matches = tm_matches_for_panel
                        # Update panel with TM data only (MT empty for now)
                        self.set_compare_panel_matches(
                            segment.id,
                            segment.source,
                            tm_matches=tm_matches_for_panel,
                            mt_matches=getattr(self, '_compare_panel_mt_matches', [])
                        )
                        
                        # üéØ AUTO-INSERT 100% TM MATCH (if enabled in settings)
                        if self.auto_insert_100_percent_matches:
                            # Check if segment target is empty (don't overwrite existing translations)
                            target_empty = not segment.target or len(segment.target.strip()) == 0
                            
                            if target_empty and matches_dict["TM"]:
                                # Find first 100% match
                                best_match = None
                                for tm_match in matches_dict["TM"]:
                                    # Use >= 99.5 to handle floating point precision
                                    if float(tm_match.relevance) >= 99.5:
                                        best_match = tm_match
                                        break
                                
                                if best_match:
                                    self._auto_insert_tm_match(segment, best_match.target, None)  # Let function find row
                                    # Play 100% TM match alert sound
                                    self._play_sound_effect('tm_100_percent_match')
                        
                        # üîä Play fuzzy match sound if fuzzy matches found (but not 100%)
                        has_100_match = any(float(tm.relevance) >= 99.5 for tm in matches_dict["TM"])
                        has_fuzzy_match = any(float(tm.relevance) < 99.5 and float(tm.relevance) >= 50 for tm in matches_dict["TM"])
                        if has_fuzzy_match and not has_100_match:
                            self._play_sound_effect('tm_fuzzy_match')

                    # v1.9.182: Update cache with TM results so subsequent visits are instant
                    if matches_dict["TM"]:
                        with self.translation_matches_cache_lock:
                            if segment.id in self.translation_matches_cache:
                                # Merge TM results into existing cache entry
                                self.translation_matches_cache[segment.id]["TM"] = matches_dict["TM"]
                            else:
                                # Create new cache entry with TM results
                                self.translation_matches_cache[segment.id] = matches_dict
                except Exception as e:
                    self.log(f"Error in delayed TM search: {e}")
            
            # Add MT and LLM matches progressively
            self._add_mt_and_llm_matches_progressive(segment, source_lang, target_lang, source_lang_code, target_lang_code)
                
        except Exception as e:
            self.log(f"Error in MT/LLM search: {e}")
    
    def _auto_insert_tm_match(self, segment, target_text, row=None):
        """
        Auto-insert a 100% TM match into the target field.
        Works for both grid and tab views.
        
        Args:
            segment: The segment object to update
            target_text: The translation text to insert
            row: The grid row number (if known), or None to search
        """
        try:
            self.log(f"üîß Auto-insert: Starting for segment {segment.id} at row {row}, target='{target_text[:50]}...'")
            self.log(f"üîß Auto-insert: BEFORE - segment.id={segment.id}, segment object ID={id(segment)}, old_target='{segment.target[:30] if segment.target else 'EMPTY'}'")
            
            # CRITICAL: Update segment data directly
            # The segment parameter IS a reference to the object in self.current_project.segments
            # No need to look it up - just modify it directly!
            segment.target = target_text
            segment.status = 'translated'  # Mark as translated
            self.project_modified = True
            self.log(f"üîß Auto-insert: AFTER - segment.id={segment.id}, segment object ID={id(segment)}, new_target='{segment.target[:30] if segment.target else 'EMPTY'}'")
            self.log(f"üîß Auto-insert: Updated segment.target, status=translated")
            
            # Update grid view if visible
            if hasattr(self, 'table') and self.table:
                # If row is provided, use it directly
                if row is not None and 0 <= row < self.table.rowCount():
                    self.log(f"üîß Auto-insert: Using provided row {row}")
                    target_row = row
                else:
                    # Search for the row by segment ID (stored as text in column 0)
                    self.log(f"üîß Auto-insert: Searching {self.table.rowCount()} rows for segment {segment.id}")
                    target_row = None
                    for r in range(self.table.rowCount()):
                        row_item = self.table.item(r, 0)
                        if row_item and row_item.text() == str(segment.id):
                            target_row = r
                            self.log(f"üîß Auto-insert: Found segment at row {r}")
                            break
                
                if target_row is not None:
                    # Update target editor widget
                    target_widget = self.table.cellWidget(target_row, 3)
                    if target_widget:
                        self.log(f"üîß Auto-insert: Got target widget, type={type(target_widget).__name__}")
                        if hasattr(target_widget, 'setPlainText'):
                            # CRITICAL: Do NOT block signals - we need textChanged to update segment.target
                            # The segment was already updated above (line ~13855), but the widget needs to trigger
                            # the handler so they stay in sync
                            target_widget.setPlainText(target_text)
                            self.log(f"üîß Auto-insert: Set widget text to '{target_text[:50]}...'")
                        else:
                            self.log(f"‚ö†Ô∏è Auto-insert: Widget has no setPlainText method!")
                    else:
                        self.log(f"‚ö†Ô∏è Auto-insert: No target widget found at row {target_row}, col 3")
                    
                    # Update status icon
                    self.update_status_icon(target_row, 'translated')
                    self.log(f"üîß Auto-insert: Updated status icon to 'translated'")
                    
                    # Auto-resize the row to fit the new content
                    self._auto_resize_single_row(target_row)
                else:
                    self.log(f"‚ö†Ô∏è Auto-insert: Could not find row for segment {segment.id}!")
            else:
                self.log(f"‚ö†Ô∏è Auto-insert: No table attribute or table is None")
            
            self.log(f"‚úÖ Auto-inserted 100% TM match into segment {segment.id}")
            
        except Exception as e:
            self.log(f"‚ö† Error auto-inserting TM match: {e}")
    
    def _add_mt_and_llm_matches_progressive(self, segment, source_lang, target_lang, source_lang_code, target_lang_code):
        """Add MT and LLM matches progressively - show each as it completes"""
        from modules.translation_results_panel import TranslationMatch
        
        # MT matches (usually fast ~0.5s each)
        if self.enable_mt_matching:
            api_keys = self.load_api_keys()
            enabled_providers = self.load_provider_enabled_states()
            
            # 1. Google Translate
            if enabled_providers.get('mt_google_translate', True) and api_keys.get('google_translate'):
                try:
                    from modules.llm_clients import get_google_translation
                    
                    google_result = get_google_translation(
                        segment.source, 
                        source_lang_code or 'auto',
                        target_lang_code or 'en'
                    )
                    
                    if google_result and google_result.get('translation'):
                        match = TranslationMatch(
                            source=segment.source,
                            target=google_result['translation'],
                            relevance=95,
                            metadata=google_result.get('metadata', {}),
                            match_type="MT",
                            compare_source=segment.source,
                            provider_code='GT'
                        )
                        # Show MT match immediately (deduplicated by panel)
                        mt_dict = {"MT": [match]}
                        if hasattr(self, 'results_panels') and self.results_panels:
                            for panel in self.results_panels:
                                try:
                                    panel.add_matches(mt_dict)
                                except Exception as e:
                                    self.log(f"Error adding Google Translate match: {e}")
                        
                        # üîÑ Update Compare Panel with MT result
                        if hasattr(self, 'compare_panel_mt'):
                            # Add to MT matches list for navigation
                            if not hasattr(self, '_compare_panel_mt_matches'):
                                self._compare_panel_mt_matches = []
                            self._compare_panel_mt_matches.append({
                                'translation': google_result['translation'],
                                'provider': 'Google Translate'
                            })
                            self.set_compare_panel_matches(
                                segment.id,
                                segment.source,
                                tm_matches=getattr(self, '_compare_panel_tm_matches', []),
                                mt_matches=self._compare_panel_mt_matches
                            )
                except Exception as e:
                    self.log(f"‚ö† Error getting Google Translate: {e}")
            
            # 2. DeepL
            if enabled_providers.get('mt_deepl', True) and api_keys.get('deepl'):
                try:
                    translation = self.call_deepl(segment.source, source_lang, target_lang, api_keys.get('deepl'))
                    if translation and not translation.startswith('['):  # Skip error messages
                        match = TranslationMatch(
                            source=segment.source,
                            target=translation,
                            relevance=94,
                            metadata={'provider': 'DeepL'},
                            match_type="MT",
                            compare_source=segment.source,
                            provider_code='DL'
                        )
                        mt_dict = {"MT": [match]}
                        if hasattr(self, 'results_panels') and self.results_panels:
                            for panel in self.results_panels:
                                try:
                                    panel.add_matches(mt_dict)
                                except Exception as e:
                                    self.log(f"Error adding DeepL match: {e}")
                        
                        # Add to Compare Panel MT matches
                        if hasattr(self, 'compare_panel_mt'):
                            if not hasattr(self, '_compare_panel_mt_matches'):
                                self._compare_panel_mt_matches = []
                            self._compare_panel_mt_matches.append({
                                'translation': translation,
                                'provider': 'DeepL'
                            })
                            self.set_compare_panel_matches(
                                segment.id,
                                segment.source,
                                tm_matches=getattr(self, '_compare_panel_tm_matches', []),
                                mt_matches=self._compare_panel_mt_matches
                            )
                except Exception as e:
                    self.log(f"‚ö† Error getting DeepL: {e}")
            
            # 3. Amazon Translate
            if enabled_providers.get('mt_amazon', True) and api_keys.get('amazon_translate'):
                try:
                    region = api_keys.get('amazon_translate_region', 'us-east-1')
                    translation = self.call_amazon_translate(segment.source, source_lang, target_lang, api_keys.get('amazon_translate'), region)
                    if translation and not translation.startswith('['):  # Skip error messages
                        match = TranslationMatch(
                            source=segment.source,
                            target=translation,
                            relevance=93,
                            metadata={'provider': 'Amazon Translate'},
                            match_type="MT",
                            compare_source=segment.source,
                            provider_code='AT'
                        )
                        mt_dict = {"MT": [match]}
                        if hasattr(self, 'results_panels') and self.results_panels:
                            for panel in self.results_panels:
                                try:
                                    panel.add_matches(mt_dict)
                                except Exception as e:
                                    self.log(f"Error adding Amazon Translate match: {e}")
                        
                        # Add to Compare Panel MT matches
                        if hasattr(self, 'compare_panel_mt'):
                            if not hasattr(self, '_compare_panel_mt_matches'):
                                self._compare_panel_mt_matches = []
                            self._compare_panel_mt_matches.append({
                                'translation': translation,
                                'provider': 'Amazon Translate'
                            })
                            self.set_compare_panel_matches(
                                segment.id,
                                segment.source,
                                tm_matches=getattr(self, '_compare_panel_tm_matches', []),
                                mt_matches=self._compare_panel_mt_matches
                            )
                except Exception as e:
                    self.log(f"‚ö† Error getting Amazon Translate: {e}")
            
            # 4. MyMemory (free, works without API key or with email as key)
            if enabled_providers.get('mt_mymemory', True):
                try:
                    mymemory_key = api_keys.get('mymemory', '')
                    # MyMemory works without a key, key is optional (email for more requests)
                    translation = self.call_mymemory(segment.source, source_lang, target_lang, mymemory_key if mymemory_key and mymemory_key != 'xxx' else None)
                    if translation and not translation.startswith('['):  # Skip error messages
                        match = TranslationMatch(
                            source=segment.source,
                            target=translation,
                            relevance=85,
                            metadata={'provider': 'MyMemory (Free)'},
                            match_type="MT",
                            compare_source=segment.source,
                            provider_code='MM'
                        )
                        mt_dict = {"MT": [match]}
                        if hasattr(self, 'results_panels') and self.results_panels:
                            for panel in self.results_panels:
                                try:
                                    panel.add_matches(mt_dict)
                                except Exception as e:
                                    self.log(f"Error adding MyMemory match: {e}")
                        
                        # Add to Compare Panel MT matches
                        if hasattr(self, 'compare_panel_mt'):
                            if not hasattr(self, '_compare_panel_mt_matches'):
                                self._compare_panel_mt_matches = []
                            self._compare_panel_mt_matches.append({
                                'translation': translation,
                                'provider': 'MyMemory'
                            })
                            self.set_compare_panel_matches(
                                segment.id,
                                segment.source,
                                tm_matches=getattr(self, '_compare_panel_tm_matches', []),
                                mt_matches=self._compare_panel_mt_matches
                            )
                except Exception as e:
                    self.log(f"‚ö† Error getting MyMemory: {e}")
        
        # LLM matches (slower ~1-3s each)
        if self.enable_llm_matching:
            try:
                api_keys = self.load_api_keys()
                if not api_keys:
                    return
                
                settings = self.load_llm_settings()
                
                # OpenAI
                if 'openai' in api_keys:
                    try:
                        self.log("üß† PROGRESSIVE LLM: Attempting OpenAI translation...")
                        from modules.llm_clients import LLMClient
                        
                        openai_model = settings.get('openai_model', 'gpt-4o')
                        client = LLMClient(
                            api_key=api_keys['openai'],
                            provider='openai',
                            model=openai_model
                        )
                        
                        translation = client.translate(
                            text=segment.source,
                            source_lang=source_lang_code or 'nl',
                            target_lang=target_lang_code or 'en'
                        )
                        
                        if translation and translation.strip():
                            match = TranslationMatch(
                                source=segment.source,
                                target=translation.strip(),
                                relevance=88,
                                metadata={'model': openai_model, 'provider': 'OpenAI'},
                                match_type="LLM",
                                compare_source=segment.source,
                                provider_code='OA'
                            )
                            # Show OpenAI match immediately
                            llm_dict = {"LLM": [match]}
                            self.log(f"üß† PROGRESSIVE LLM: Showing OpenAI match")
                            if hasattr(self, 'results_panels') and self.results_panels:
                                for panel in self.results_panels:
                                    try:
                                        panel.add_matches(llm_dict)
                                    except Exception as e:
                                        self.log(f"Error adding OpenAI match: {e}")
                    except Exception as e:
                        self.log(f"‚ö† Error getting OpenAI translation: {e}")
                
                # Claude
                if 'anthropic' in api_keys:
                    try:
                        self.log("üß† PROGRESSIVE LLM: Attempting Claude translation...")
                        from modules.llm_clients import LLMClient
                        
                        claude_model = settings.get('anthropic_model', 'claude-3-5-sonnet-20241022')
                        client = LLMClient(
                            api_key=api_keys['anthropic'],
                            provider='anthropic',
                            model=claude_model
                        )
                        
                        translation = client.translate(
                            text=segment.source,
                            source_lang=source_lang_code or 'nl',
                            target_lang=target_lang_code or 'en'
                        )
                        
                        if translation and translation.strip():
                            match = TranslationMatch(
                                source=segment.source,
                                target=translation.strip(),
                                relevance=88,
                                metadata={'model': claude_model, 'provider': 'Claude'},
                                match_type="LLM",
                                compare_source=segment.source,
                                provider_code='CL'
                            )
                            # Show Claude match immediately
                            llm_dict = {"LLM": [match]}
                            self.log(f"üß† PROGRESSIVE LLM: Showing Claude match")
                            if hasattr(self, 'results_panels') and self.results_panels:
                                for panel in self.results_panels:
                                    try:
                                        panel.add_matches(llm_dict)
                                    except Exception as e:
                                        self.log(f"Error adding Claude match: {e}")
                    except Exception as e:
                        self.log(f"‚ö† Error getting Claude translation: {e}")
                        
            except Exception as e:
                self.log(f"‚ö† Error in LLM matching: {e}")
    
    def _add_mt_and_llm_matches(self, segment, matches_dict, source_lang, target_lang, source_lang_code, target_lang_code):
        """Add MT and LLM matches to the matches dictionary"""
        from modules.translation_results_panel import TranslationMatch
        
        # ü§ñ DIRECT MT SEARCH: Machine Translation matches
        if self.enable_mt_matching:
            try:
                self.log(f"ü§ñ DIRECT MT SEARCH: Getting machine translation for '{segment.source[:50]}...'")
                
                # Use Google Translate via the wrapper function
                from modules.llm_clients import get_google_translation
                
                self.log(f"ü§ñ DIRECT MT SEARCH: Calling get_google_translation with source_lang='{source_lang_code or 'auto'}', target_lang='{target_lang_code or 'en'}'")
                
                google_result = get_google_translation(
                    segment.source, 
                    source_lang_code or 'auto',  # Auto-detect if no source lang 
                    target_lang_code or 'en'     # Default to English if no target lang
                )
                
                self.log(f"ü§ñ DIRECT MT SEARCH: Google Translate result: {google_result}")
                
                if google_result and google_result.get('translation'):
                    match = TranslationMatch(
                        source=segment.source,
                        target=google_result['translation'],
                        relevance=95,  # High confidence for MT
                        metadata=google_result.get('metadata', {}),
                        match_type="MT",
                        compare_source=segment.source,
                        provider_code='GT'
                    )
                    matches_dict["MT"].append(match)
                    self.log(f"‚úì Added Google Translate match: {google_result['translation'][:50]}...")
                elif google_result and google_result.get('error'):
                    self.log(f"‚ö† Google Translate error: {google_result.get('error')}")
                else:
                    self.log(f"‚ö† Google Translate returned no translation")
                    
            except Exception as e:
                self.log(f"‚ö† Error getting Google Translate: {e}")
                import traceback
                self.log(f"‚ö† Traceback: {traceback.format_exc()}")
        
        # üß† DIRECT LLM SEARCH: Large Language Model matches  
        if self.enable_llm_matching:
            try:
                self.log(f"üß† DIRECT LLM SEARCH: Getting LLM translations for '{segment.source[:50]}...'")
                self.log(f"üß† DIRECT LLM SEARCH: LLM matching is enabled: {self.enable_llm_matching}")
                
                # Import LLM wrapper functions
                from modules.llm_clients import get_openai_translation, get_claude_translation
                self.log("üß† DIRECT LLM SEARCH: Successfully imported LLM wrapper functions")
                
                # Use existing LLM infrastructure from Prompt Manager
                api_keys = self.load_api_keys()
                self.log(f"üß† DIRECT LLM SEARCH: Loaded API keys: {list(api_keys.keys()) if api_keys else 'None'}")
                if not api_keys:
                    self.log("‚ö† No API keys found for LLM translation")
                    return
                
                settings = self.load_llm_settings()
                
                # Check if we should use prompts for grid translations (configurable)
                use_prompts_in_grid = settings.get('use_prompts_in_grid', False)  # Default: simple translations
                self.log(f"üß† LLM Grid Translations - Use Prompts: {use_prompts_in_grid}")
                
                # Get OpenAI translation using existing infrastructure
                if 'openai' in api_keys:
                    try:
                        self.log("üß† DIRECT LLM SEARCH: Attempting OpenAI translation...")
                        from modules.llm_clients import LLMClient
                        self.log("üß† DIRECT LLM SEARCH: LLMClient imported for OpenAI")
                        
                        openai_model = settings.get('openai_model', 'gpt-4o')
                        self.log(f"üß† DIRECT LLM SEARCH: Using OpenAI model: {openai_model}")
                        client = LLMClient(
                            api_key=api_keys['openai'],
                            provider='openai',
                            model=openai_model
                        )
                        self.log("üß† DIRECT LLM SEARCH: LLMClient initialized for OpenAI")
                        
                        translation = client.translate(
                            text=segment.source,
                            source_lang=source_lang_code or 'nl',
                            target_lang=target_lang_code or 'en'
                        )
                        self.log(f"üß† DIRECT LLM SEARCH: OpenAI translation result: {translation[:100] if translation else 'None'}...")
                        
                        if translation and translation.strip():
                            match = TranslationMatch(
                                source=segment.source,
                                target=translation.strip(),
                                relevance=88,  # Good confidence for LLM
                                metadata={'model': openai_model, 'provider': 'OpenAI'},
                                match_type="LLM",
                                compare_source=segment.source,
                                provider_code='OA'
                            )
                            matches_dict["LLM"].append(match)
                            self.log(f"‚úì Added OpenAI match: {translation[:50]}...")
                        else:
                            self.log("‚ö† OpenAI translation was empty or None")
                            
                    except Exception as e:
                        self.log(f"‚ö† Error getting OpenAI translation: {e}")
                        import traceback
                        self.log(f"‚ö† OpenAI error traceback: {traceback.format_exc()}")
                
                # Get Claude translation using existing infrastructure
                if 'claude' in api_keys:
                    try:
                        from modules.llm_clients import LLMClient
                        
                        claude_model = settings.get('claude_model', 'claude-sonnet-4-5-20250929')
                        client = LLMClient(
                            api_key=api_keys['claude'],
                            provider='claude',
                            model=claude_model
                        )
                        
                        translation = client.translate(
                            text=segment.source,
                            source_lang=source_lang_code or 'nl',
                            target_lang=target_lang_code or 'en'
                        )
                        
                        if translation and translation.strip():
                            match = TranslationMatch(
                                source=segment.source,
                                target=translation.strip(),
                                relevance=90,  # High confidence for Claude
                                metadata={'model': claude_model, 'provider': 'Claude'},
                                match_type="LLM",
                                compare_source=segment.source,
                                provider_code='CL'
                            )
                            matches_dict["LLM"].append(match)
                            self.log(f"‚úì Added Claude match: {translation[:50]}...")
                            
                    except Exception as e:
                        self.log(f"‚ö† Error getting Claude translation: {e}")
                
                # Get Gemini translation using existing infrastructure
                # Check for both 'gemini' and 'google' keys for backward compatibility
                gemini_api_key = api_keys.get('gemini') or api_keys.get('google')
                if gemini_api_key:
                    try:
                        self.log("üß† DIRECT LLM SEARCH: Attempting Gemini translation...")
                        from modules.llm_clients import LLMClient
                        self.log("üß† DIRECT LLM SEARCH: LLMClient imported for Gemini")
                        
                        gemini_model = settings.get('gemini_model', 'gemini-2.5-flash')
                        self.log(f"üß† DIRECT LLM SEARCH: Using Gemini model: {gemini_model}")
                        client = LLMClient(
                            api_key=gemini_api_key,
                            provider='gemini',
                            model=gemini_model
                        )
                        self.log("üß† DIRECT LLM SEARCH: LLMClient initialized for Gemini")
                        
                        translation = client.translate(
                            text=segment.source,
                            source_lang=source_lang_code or 'nl',
                            target_lang=target_lang_code or 'en'
                        )
                        
                        if translation and translation.strip():
                            match = TranslationMatch(
                                source=segment.source,
                                target=translation.strip(),
                                relevance=85,  # Good confidence for Gemini
                                metadata={'model': gemini_model, 'provider': 'Gemini'},
                                match_type="LLM",
                                compare_source=segment.source,
                                provider_code='GM'
                            )
                            matches_dict["LLM"].append(match)
                            self.log(f"‚úì Added Gemini match: {translation[:50]}...")
                            
                    except Exception as e:
                        self.log(f"‚ö† Error getting Gemini translation: {e}")
                    
            except Exception as e:
                self.log(f"‚ö† Error in LLM translation process: {e}")
    
    def _clean_provider_prefix(self, translation):
        """Remove provider prefixes like [OpenAI], [Claude], etc. from translations"""
        import re
        # Remove patterns like [OpenAI], [Claude], [ChatGPT], [Anthropic] at the start
        cleaned = re.sub(r'^\[(?:OpenAI|Claude|ChatGPT|Anthropic|GPT-\d+)\]\s*', '', translation.strip())
        return cleaned


# ============================================================================
# SUPERLOOKUP TAB
# ============================================================================

class SuperlookupTab(QWidget):
    """
    Superlookup - System-wide translation lookup
    Works anywhere on your computer: in CAT tools, browsers, Word, any text box
    """
    
    def __init__(self, parent=None, user_data_path=None):
        super().__init__(parent)
        self.main_window = parent  # Store reference to main window for database access
        self.user_data_path = user_data_path  # Store user data path for web cache
        
        print("[Superlookup] SuperlookupTab.__init__ called")
        
        # Get theme manager from main window (try parent first, then parent's parent for dialogs)
        self.theme_manager = getattr(parent, 'theme_manager', None)
        if self.theme_manager is None and parent is not None:
            # Try parent's parent (for when parent is a dialog window)
            parent_parent = getattr(parent, 'parent', lambda: None)()
            if parent_parent:
                self.theme_manager = getattr(parent_parent, 'theme_manager', None)
        print(f"[Superlookup] theme_manager: {self.theme_manager is not None}")
        
        # Import lookup engine
        try:
            from modules.superlookup import SuperlookupEngine, LookupResult
            self.SuperlookupEngine = SuperlookupEngine
            self.LookupResult = LookupResult
            print("[Superlookup] Successfully imported SuperlookupEngine")
        except ImportError as e:
            print(f"[Superlookup] IMPORT ERROR: {e}")
            QMessageBox.critical(
                self,
                "Missing Module",
                "Could not import superlookup module.\nPlease ensure modules/superlookup.py exists."
            )
            self.SuperlookupEngine = None
            self.LookupResult = None
            # Don't return - still set up hotkey even if engine import fails
        
        # Initialize engine
        self.engine = None
        self.tm_database = None
        self.termbase_mgr = None
        self.db_manager = None
        self.hotkey_registered = False
        
        # Resource selection tracking (which resources to search)
        self.enabled_tms = []  # List of TM IDs to search
        self.enabled_termbases = []  # List of termbase IDs to search
        self.search_tm_enabled = True  # Search TMs by default
        self.search_termbase_enabled = True  # Search termbases by default
        self.search_mt_enabled = False  # MT not implemented yet
        self.search_web_enabled = False  # Web resources not implemented yet
        
        # Initialize checkbox lists (even if Settings tab is removed)
        self.tm_checkboxes = []
        self.tb_checkboxes = []
        
        # Track if languages have been populated
        self._languages_populated = False
        
        # Initialize search history
        self._init_search_history()
        
        # UI setup
        self.init_ui()
        
        # Register global hotkey
        self.register_global_hotkey()
    
    def keyPressEvent(self, event):
        """Handle key presses - Escape returns to Grid"""
        if event.key() == Qt.Key.Key_Escape:
            # Navigate back to Grid (tab index 0)
            if self.main_window and hasattr(self.main_window, 'main_tabs'):
                self.main_window.main_tabs.setCurrentIndex(0)  # Grid
                # Focus the target cell if a segment is selected
                if hasattr(self.main_window, 'table') and self.main_window.table:
                    current_row = self.main_window.table.currentRow()
                    if current_row >= 0:
                        target_widget = self.main_window.table.cellWidget(current_row, 3)
                        if target_widget:
                            target_widget.setFocus()
            event.accept()
        else:
            super().keyPressEvent(event)
    
    def showEvent(self, event):
        """Called when the widget becomes visible - populate languages on first show"""
        super().showEvent(event)
        if not self._languages_populated:
            # Use a short delay to ensure main window databases are ready
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(100, self._delayed_language_population)
    
    def _delayed_language_population(self):
        """Populate language dropdowns after a short delay"""
        if self._languages_populated:
            return
        
        # Get database connections from main window
        if self.main_window:
            if hasattr(self.main_window, 'db_manager') and self.main_window.db_manager:
                self.db_manager = self.main_window.db_manager
            if hasattr(self.main_window, 'termbase_mgr') and self.main_window.termbase_mgr:
                self.termbase_mgr = self.main_window.termbase_mgr
        
        # Populate if we have database access
        if self.db_manager or self.termbase_mgr:
            self.populate_language_dropdowns()
            self._languages_populated = True
            print("[Superlookup] Languages populated on first show")
    
    def init_ui(self):
        """Initialize the UI"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)  # Reduced from 10 to 5 for consistency
        
        # Header
        header = QLabel("üîç Superlookup")
        header.setStyleSheet("font-size: 16pt; font-weight: bold; color: #1976D2;")
        layout.addWidget(header, 0)  # 0 = no stretch, stays compact
        
        # Description
        if os.name == 'nt':
            # Windows - full functionality
            description_text = (
                "Look up translations anywhere on your computer.\n"
                "Press Ctrl+Alt+L or paste text manually to search your TMs and Termbases.\n"
                "Perfect for translating in other CAT tools while accessing Supervertaler resources!"
            )
        else:
            # Mac/Linux - manual mode only
            description_text = (
                "Look up translations in your TMs and Termbases.\n"
                "‚ö†Ô∏è Global hotkey not available on this platform. Paste text manually to search."
            )
        
        description = QLabel(description_text)
        description.setWordWrap(True)
        description.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(description, 0)  # 0 = no stretch, stays compact
        
        # Search input area - compact single-line layout with search box and controls
        search_row = QHBoxLayout()
        
        # Search label and input
        search_label = QLabel("üîç")
        search_label.setStyleSheet("font-size: 12pt;")
        search_row.addWidget(search_label)
        
        # Use HistoryComboBox for search with history dropdown
        self.source_text = HistoryComboBox()
        self.source_text.setEditable(True)
        self.source_text.lineEdit().setPlaceholderText("Enter search term or paste text...")
        self.source_text.setMinimumHeight(30)
        self.source_text.setMaximumHeight(35)
        self.source_text.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        # Load history into dropdown
        if hasattr(self, 'search_history') and self.search_history:
            self.source_text.set_history(self.search_history)
        # Handle Enter key to trigger search
        self.source_text.lineEdit().returnPressed.connect(self.perform_lookup)
        search_row.addWidget(self.source_text, stretch=1)
        
        # Search button
        search_btn = QPushButton("üîç Search")
        search_btn.setStyleSheet("font-weight: bold; background-color: #2196F3; color: white; padding: 6px 12px; outline: none;")
        search_btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        search_btn.clicked.connect(self.perform_lookup)
        search_row.addWidget(search_btn)
        
        # Clear button
        clear_btn = QPushButton("üóëÔ∏è Clear")
        clear_btn.setStyleSheet("padding: 6px 8px;")
        clear_btn.clicked.connect(self.clear_all)
        search_row.addWidget(clear_btn)
        
        layout.addLayout(search_row)
        
        # Options row (language filters only) - compact single line
        options_layout = QHBoxLayout()
        options_layout.setSpacing(8)
        
        # Language filter dropdowns
        from_label = QLabel("From:")
        from_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        options_layout.addWidget(from_label)
        
        self.lang_from_combo = QComboBox()
        self.lang_from_combo.setMinimumWidth(90)
        self.lang_from_combo.setToolTip("Filter by source language (leave as 'Any' for all)")
        self.lang_from_combo.currentIndexChanged.connect(self._on_language_changed)
        options_layout.addWidget(self.lang_from_combo)
        
        # Swap button
        swap_btn = QPushButton("‚Üî")
        swap_btn.setFixedWidth(28)
        swap_btn.setToolTip("Swap source and target languages")
        swap_btn.clicked.connect(self.swap_language_filters)
        options_layout.addWidget(swap_btn)
        
        to_label = QLabel("To:")
        to_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        options_layout.addWidget(to_label)
        
        self.lang_to_combo = QComboBox()
        self.lang_to_combo.setMinimumWidth(90)
        self.lang_to_combo.setToolTip("Filter by target language (leave as 'Any' for all)")
        self.lang_to_combo.currentIndexChanged.connect(self._on_language_changed)
        options_layout.addWidget(self.lang_to_combo)
        
        options_layout.addStretch()
        layout.addLayout(options_layout)
        
        # Initialize language dropdowns with "Any" option
        self.lang_from_combo.addItem("Any", None)
        self.lang_to_combo.addItem("Any", None)
        
        # Results area (with tabs for TM, termbase, MT)
        self.results_tabs = QTabWidget()
        self.results_tabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.results_tabs.tabBar().setDrawBase(False)
        self.results_tabs.setStyleSheet("QTabBar::tab { outline: 0; } QTabBar::tab:focus { outline: none; } QTabBar::tab:selected { border-bottom: 1px solid #2196F3; background-color: rgba(33, 150, 243, 0.08); }")
        
        # TM Results tab
        tm_tab = self.create_tm_results_tab()
        self.results_tabs.addTab(tm_tab, "üìñ TMs")
        
        # Termbase Results tab
        termbase_tab = self.create_termbase_results_tab()
        self.results_tabs.addTab(termbase_tab, "üìö Glossaries")
        
        # MT Results tab
        mt_tab = self.create_mt_results_tab()
        self.results_tabs.addTab(mt_tab, "ü§ñ Machine Translation")
        
        # Web Resources tab
        web_tab = self.create_web_resources_tab()
        self.results_tabs.addTab(web_tab, "üåê Web Resources")
        
        # Settings tab
        settings_tab = self.create_settings_tab()
        self.results_tabs.addTab(settings_tab, "‚öôÔ∏è Settings")
        
        # Connect tab change for Settings refresh
        self.results_tabs.currentChanged.connect(self.on_results_tab_changed)
        
        layout.addWidget(self.results_tabs, stretch=1)
        
        # Status bar
        self.status_label = QLabel("Ready. Select a mode and capture text to begin.")
        self.status_label.setStyleSheet("padding: 5px; border-radius: 3px;")
        layout.addWidget(self.status_label, 0)  # 0 = no stretch, stays compact
    
    def create_tm_results_tab(self):
        """Create the TM results tab with horizontal/vertical view toggle"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # View mode toggle at the top
        view_toggle_layout = QHBoxLayout()
        view_toggle_layout.addWidget(QLabel("View:"))
        
        self.tm_view_horizontal_radio = CheckmarkRadioButton("Horizontal (Table)")
        self.tm_view_horizontal_radio.setChecked(True)  # Default to horizontal
        self.tm_view_horizontal_radio.setToolTip("Source and Target side-by-side in columns")
        self.tm_view_horizontal_radio.toggled.connect(self.toggle_tm_view_mode)
        view_toggle_layout.addWidget(self.tm_view_horizontal_radio)
        
        self.tm_view_vertical_radio = CheckmarkRadioButton("Vertical (List)")
        self.tm_view_vertical_radio.setToolTip("Source above Target, like traditional concordance")
        view_toggle_layout.addWidget(self.tm_view_vertical_radio)
        
        view_toggle_layout.addStretch()
        layout.addLayout(view_toggle_layout)
        
        # Stacked widget to hold both views
        self.tm_view_stack = QStackedWidget()
        
        # === Horizontal View (Table) ===
        horizontal_widget = QWidget()
        horizontal_layout = QVBoxLayout(horizontal_widget)
        horizontal_layout.setContentsMargins(0, 0, 0, 0)
        
        self.tm_results_table = QTableWidget()
        self.tm_results_table.setColumnCount(5)
        self.tm_results_table.setHorizontalHeaderLabels(["Match %", "Source", "Target", "TM", "Type"])
        self.tm_results_table.horizontalHeader().setStretchLastSection(False)
        self.tm_results_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Fixed)
        self.tm_results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.tm_results_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        self.tm_results_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeMode.Fixed)
        self.tm_results_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.Fixed)
        self.tm_results_table.setColumnWidth(0, 60)  # Match % column
        self.tm_results_table.setColumnWidth(3, 150)  # TM name column
        self.tm_results_table.setColumnWidth(4, 80)  # Type column
        self.tm_results_table.verticalHeader().setVisible(False)  # Hide row numbers
        self.tm_results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.tm_results_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.tm_results_table.doubleClicked.connect(self.on_tm_result_double_click)
        horizontal_layout.addWidget(self.tm_results_table)
        
        self.tm_view_stack.addWidget(horizontal_widget)
        
        # === Vertical View (List - like Concordance dialog) ===
        vertical_widget = QWidget()
        vertical_layout = QVBoxLayout(vertical_widget)
        vertical_layout.setContentsMargins(0, 0, 0, 0)
        
        self.tm_results_vertical = QTextEdit()
        self.tm_results_vertical.setReadOnly(True)
        self.tm_results_vertical.setFont(QFont("Segoe UI", 10))
        self.tm_results_vertical.setStyleSheet("border: 1px solid #ddd; border-radius: 4px;")
        vertical_layout.addWidget(self.tm_results_vertical)
        
        self.tm_view_stack.addWidget(vertical_widget)
        
        layout.addWidget(self.tm_view_stack)
        
        # Action buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        copy_btn = QPushButton("üìã Copy Target")
        copy_btn.clicked.connect(self.copy_selected_tm_target)
        button_layout.addWidget(copy_btn)
        
        insert_btn = QPushButton("üì• Insert Target")
        insert_btn.setToolTip("Insert selected translation (Ctrl+V)")
        insert_btn.clicked.connect(self.insert_selected_tm_target)
        button_layout.addWidget(insert_btn)
        
        layout.addLayout(button_layout)
        
        return tab
    
    def create_termbase_results_tab(self):
        """Create the termbase results tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Results table with expanded columns
        self.termbase_results_table = QTableWidget()
        self.termbase_results_table.setColumnCount(5)
        self.termbase_results_table.setHorizontalHeaderLabels(["Source", "Target", "Termbase", "Domain", "Notes"])
        # Make all columns resizable (Interactive) with stretch for Source/Target
        header = self.termbase_results_table.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)  # All columns resizable
        header.setStretchLastSection(False)  # Don't auto-stretch last column
        # Set initial column widths
        self.termbase_results_table.setColumnWidth(0, 200)  # Source
        self.termbase_results_table.setColumnWidth(1, 200)  # Target
        self.termbase_results_table.setColumnWidth(2, 100)  # Termbase column
        self.termbase_results_table.setColumnWidth(3, 80)   # Domain column
        self.termbase_results_table.setColumnWidth(4, 100)  # Notes column
        self.termbase_results_table.verticalHeader().setVisible(False)  # Hide row numbers
        self.termbase_results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.termbase_results_table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.termbase_results_table.doubleClicked.connect(lambda: self.copy_selected_termbase_target())
        
        # Right-click context menu for termbase results
        self.termbase_results_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.termbase_results_table.customContextMenuRequested.connect(self._show_termbase_result_context_menu)
        
        layout.addWidget(self.termbase_results_table)
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        add_term_btn = QPushButton("‚ûï Add to Glossary")
        add_term_btn.setToolTip("Add source text and selected translation as new term")
        add_term_btn.setStyleSheet("background-color: #4CAF50; color: white; padding: 5px; border: none; outline: none;")
        add_term_btn.clicked.connect(self.add_to_termbase)
        button_layout.addWidget(add_term_btn)
        
        button_layout.addStretch()
        
        copy_target_btn = QPushButton("üìã Copy Translation")
        copy_target_btn.clicked.connect(self.copy_selected_termbase_target)
        button_layout.addWidget(copy_target_btn)
        
        layout.addLayout(button_layout)
        
        # Info label
        info = QLabel("üí° Tip: Double-click a term to copy translation to clipboard")
        info.setStyleSheet("color: #666; font-size: 9pt; padding: 5px;")
        layout.addWidget(info)
        
        return tab
    
    def search_supermemory(self, query: str):
        """Search Supermemory for semantic matches. Returns count of results.
        
        NOTE: Supermemory was removed in v1.9.105. This method now returns 0
        to maintain backward compatibility with existing code.
        """
        # Supermemory functionality removed - return 0 to indicate no results
        return 0
    
    def create_mt_results_tab(self):
        """Create the MT results tab with provider status and results"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(5, 5, 5, 5)
        
        # === Provider Status Summary ===
        status_frame = QFrame()
        status_frame.setFrameStyle(QFrame.Shape.StyledPanel)
        status_frame.setStyleSheet("QFrame { background-color: #f5f5f5; border-radius: 4px; padding: 5px; }")
        status_layout = QVBoxLayout(status_frame)
        status_layout.setContentsMargins(10, 10, 10, 10)
        
        # Header row with title and settings link
        header_row = QHBoxLayout()
        
        status_title = QLabel("ü§ñ MT Providers")
        status_title.setStyleSheet("font-weight: bold; font-size: 11pt;")
        header_row.addWidget(status_title)
        
        header_row.addStretch()
        
        # Link to Settings
        settings_link = QPushButton("‚öôÔ∏è Configure in Settings")
        settings_link.setStyleSheet("""
            QPushButton {
                background: transparent;
                color: #1976D2;
                border: none;
                font-size: 10pt;
                text-decoration: underline;
            }
            QPushButton:hover {
                color: #1565C0;
            }
        """)
        settings_link.setCursor(Qt.CursorShape.PointingHandCursor)
        settings_link.clicked.connect(self._open_mt_settings)
        header_row.addWidget(settings_link)
        
        status_layout.addLayout(header_row)
        
        # Provider status label (shows which are active)
        self.mt_provider_status_label = QLabel()
        self.mt_provider_status_label.setWordWrap(True)
        self.mt_provider_status_label.setStyleSheet("color: #666; font-size: 9pt; padding: 5px 0;")
        status_layout.addWidget(self.mt_provider_status_label)
        
        # Update the status display
        self._update_mt_provider_status()
        
        layout.addWidget(status_frame)
        
        # === MT Results Section ===
        results_group = QGroupBox("üìù Translation Results")
        results_layout = QVBoxLayout(results_group)
        
        # Results table
        self.mt_results_table = QTableWidget()
        self.mt_results_table.setColumnCount(3)
        self.mt_results_table.setHorizontalHeaderLabels(["Provider", "Translation", ""])
        self.mt_results_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.mt_results_table.setColumnWidth(0, 120)
        self.mt_results_table.setColumnWidth(2, 60)
        self.mt_results_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.mt_results_table.verticalHeader().setVisible(False)
        self.mt_results_table.doubleClicked.connect(self.on_mt_result_double_click)
        
        results_layout.addWidget(self.mt_results_table)
        
        # Status
        self.mt_status_label = QLabel("Enter text and click Search to get MT translations")
        self.mt_status_label.setStyleSheet("color: #666; font-style: italic; padding: 5px;")
        results_layout.addWidget(self.mt_status_label)
        
        layout.addWidget(results_group, stretch=1)
        
        return tab
    
    def _open_mt_settings(self):
        """Navigate to Settings ‚Üí MT Settings tab"""
        if self.main_window:
            # Go to main Settings tab (index 3)
            if hasattr(self.main_window, 'main_tabs'):
                self.main_window.main_tabs.setCurrentIndex(3)
            # Go to MT Settings sub-tab (index 3: General=0, AI=1, Language=2, MT=3)
            if hasattr(self.main_window, 'settings_tabs'):
                self.main_window.settings_tabs.setCurrentIndex(3)
    
    def _update_mt_provider_status(self):
        """Update the MT provider status display"""
        # Get API keys and enabled states from main window
        api_keys = {}
        enabled_providers = {}
        
        if self.main_window:
            if hasattr(self.main_window, 'load_api_keys'):
                api_keys = self.main_window.load_api_keys()
            if hasattr(self.main_window, 'load_provider_enabled_states'):
                enabled_providers = self.main_window.load_provider_enabled_states()
        
        # Define all MT providers
        providers = [
            ("DeepL", "mt_deepl", "deepl"),
            ("Google Translate", "mt_google_translate", "google_translate"),
            ("Microsoft Translator", "mt_microsoft", "microsoft_translate"),
            ("Amazon Translate", "mt_amazon", "amazon_translate"),
            ("ModernMT", "mt_modernmt", "modernmt"),
            ("MyMemory", "mt_mymemory", None),
        ]
        
        ready_providers = []
        disabled_providers = []
        missing_key_providers = []
        
        for name, enabled_key, api_key_name in providers:
            is_enabled = enabled_providers.get(enabled_key, True)
            has_key = api_key_name is None or bool(api_keys.get(api_key_name))
            
            if has_key and is_enabled:
                ready_providers.append(name)
            elif has_key and not is_enabled:
                disabled_providers.append(name)
            else:
                missing_key_providers.append(name)
        
        # Build status text
        status_parts = []
        if ready_providers:
            status_parts.append(f"‚úÖ Active: {', '.join(ready_providers)}")
        if disabled_providers:
            status_parts.append(f"‚è∏Ô∏è Disabled: {', '.join(disabled_providers)}")
        if missing_key_providers:
            status_parts.append(f"‚ùå No API key: {', '.join(missing_key_providers)}")
        
        if not status_parts:
            status_text = "No MT providers configured"
        else:
            status_text = "\n".join(status_parts)
        
        self.mt_provider_status_label.setText(status_text)
    
    def _perform_mt_lookup(self, text: str, source_lang: str = None, target_lang: str = None):
        """Call enabled MT providers and return results"""
        results = []
        
        if not self.main_window:
            return results
        
        # Get languages from main window if not provided
        if not source_lang:
            source_lang = getattr(self.main_window, 'source_language', 'en')
        if not target_lang:
            target_lang = getattr(self.main_window, 'target_language', 'nl')
        
        # Get API keys and enabled providers from Settings
        api_keys = {}
        enabled_providers = {}
        if hasattr(self.main_window, 'load_api_keys'):
            api_keys = self.main_window.load_api_keys()
        if hasattr(self.main_window, 'load_provider_enabled_states'):
            enabled_providers = self.main_window.load_provider_enabled_states()
        
        # Define MT providers with their settings keys and API key names
        providers = [
            ("DeepL", "mt_deepl", "deepl"),
            ("Google Translate", "mt_google_translate", "google_translate"),
            ("Microsoft Translator", "mt_microsoft", "microsoft_translate"),
            ("Amazon Translate", "mt_amazon", "amazon_translate"),
            ("ModernMT", "mt_modernmt", "modernmt"),
            ("MyMemory", "mt_mymemory", None),
        ]
        
        for provider_name, enabled_key, api_key_name in providers:
            # Check if provider is enabled in Settings
            is_enabled = enabled_providers.get(enabled_key, True)
            has_key = api_key_name is None or bool(api_keys.get(api_key_name))
            
            if not is_enabled or not has_key:
                continue
            
            try:
                translation = None
                
                if provider_name == "DeepL" and hasattr(self.main_window, 'call_deepl'):
                    translation = self.main_window.call_deepl(text, source_lang, target_lang, api_keys.get('deepl'))
                
                elif provider_name == "Google Translate" and hasattr(self.main_window, 'call_google_translate'):
                    translation = self.main_window.call_google_translate(text, source_lang, target_lang, api_keys.get('google_translate'))
                
                elif provider_name == "Microsoft Translator" and hasattr(self.main_window, 'call_microsoft_translate'):
                    translation = self.main_window.call_microsoft_translate(text, source_lang, target_lang, api_keys.get('microsoft_translate'))
                
                elif provider_name == "Amazon Translate" and hasattr(self.main_window, 'call_amazon_translate'):
                    region = api_keys.get('amazon_translate_region', 'us-east-1')
                    translation = self.main_window.call_amazon_translate(text, source_lang, target_lang, api_keys.get('amazon_translate'), region)
                
                elif provider_name == "ModernMT" and hasattr(self.main_window, 'call_modernmt'):
                    translation = self.main_window.call_modernmt(text, source_lang, target_lang, api_keys.get('modernmt'))
                
                elif provider_name == "MyMemory":
                    # MyMemory is free, call directly
                    translation = self._call_mymemory(text, source_lang, target_lang)
                
                if translation:
                    is_error = translation.startswith('[')
                    results.append({
                        'provider': provider_name,
                        'translation': translation,
                        'is_error': is_error
                    })
                    
            except Exception as e:
                print(f"[Superlookup] MT error ({provider_name}): {e}")
                results.append({
                    'provider': provider_name,
                    'translation': f"[Error: {str(e)}]",
                    'is_error': True
                })
        
        return results
    
    def _call_mymemory(self, text: str, source_lang: str, target_lang: str) -> str:
        """Call MyMemory free translation API"""
        try:
            import requests
            
            # Map full language names to ISO codes
            lang_name_to_code = {
                'english': 'en', 'dutch': 'nl', 'german': 'de', 'french': 'fr',
                'spanish': 'es', 'italian': 'it', 'portuguese': 'pt', 'russian': 'ru',
                'chinese': 'zh', 'japanese': 'ja', 'korean': 'ko', 'arabic': 'ar',
                'polish': 'pl', 'swedish': 'sv', 'norwegian': 'no', 'danish': 'da',
                'finnish': 'fi', 'greek': 'el', 'turkish': 'tr', 'czech': 'cs',
                'hungarian': 'hu', 'romanian': 'ro', 'bulgarian': 'bg', 'ukrainian': 'uk',
            }
            
            # Convert language - try name mapping first, then code extraction
            src_lower = source_lang.lower().strip()
            tgt_lower = target_lang.lower().strip()
            
            src = lang_name_to_code.get(src_lower, src_lower.split('-')[0].split('_')[0])
            tgt = lang_name_to_code.get(tgt_lower, tgt_lower.split('-')[0].split('_')[0])
            
            url = "https://api.mymemory.translated.net/get"
            params = {
                'q': text,
                'langpair': f"{src}|{tgt}"
            }
            
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            if data.get('responseStatus') == 200:
                return data['responseData']['translatedText']
            else:
                return f"[MyMemory error: {data.get('responseStatus')}]"
                
        except Exception as e:
            return f"[MyMemory error: {e}]"

    def create_web_resources_tab(self):
        """Create the Web Resources tab with vertical sidebar for different web resources"""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Try to import QWebEngineView for embedded browser with persistent storage
        self.web_engine_available = False
        self.web_profile = None
        self.SilentWebPage = None  # Custom page class that suppresses JS console spam
        try:
            from PyQt6.QtWebEngineWidgets import QWebEngineView
            from PyQt6.QtWebEngineCore import QWebEnginePage, QWebEngineProfile
            
            # Create a custom page class that silences JavaScript console messages
            class SilentWebEnginePage(QWebEnginePage):
                """Custom QWebEnginePage that suppresses JavaScript console output.
                
                External websites (IATE, Juremy, Google Patents, etc.) emit tons of
                noisy console messages about CSP violations, mixed content, etc.
                These are not relevant to Supervertaler and clutter the terminal.
                """
                def javaScriptConsoleMessage(self, level, message, lineNumber, sourceID):
                    # Silently ignore all JS console messages from web pages
                    pass
            
            self.SilentWebPage = SilentWebEnginePage
            self.QWebEngineView = QWebEngineView
            self.QWebEngineProfile = QWebEngineProfile
            self.web_engine_available = True
            
            # Create persistent profile for login/cookie storage
            if self.user_data_path:
                storage_path = os.path.join(str(self.user_data_path), 'web_cache')
            else:
                # Fallback to script directory if user_data_path not provided
                storage_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'user_data', 'web_cache')
            os.makedirs(storage_path, exist_ok=True)
            self.web_profile = QWebEngineProfile("SuperlookupProfile", self)
            self.web_profile.setPersistentStoragePath(storage_path)
            self.web_profile.setPersistentCookiesPolicy(QWebEngineProfile.PersistentCookiesPolicy.ForcePersistentCookies)
            print(f"[Superlookup] QWebEngineView available - embedded browser enabled with persistent storage at {storage_path}")
        except ImportError:
            print("[Superlookup] QWebEngineView not available - external browser only")
            self.QWebEngineView = None
            self.QWebEngineProfile = None
        
        # Setting for browser mode (embedded vs external)
        self.web_browser_mode = 'embedded' if self.web_engine_available else 'external'
        
        # === Web Resources Definitions ===
        # Each resource has: name, icon, url_template with {query}, {sl} (source lang), {tl} (target lang)
        # Language codes vary per service - we'll map them in _get_web_lang_code()
        self.web_resources = [
            {
                'id': 'iate',
                'name': 'IATE',
                'icon': 'üá™üá∫',
                'description': 'EU terminology database',
                'url_template': 'https://iate.europa.eu/search/byUrl?term={query}&sl={sl}&tl={tl}',
                'lang_format': 'iso2',  # en, nl, de, fr
                'bidirectional': False,  # respects source/target direction
            },
            {
                'id': 'linguee',
                'name': 'Linguee',
                'icon': 'üìó',
                'description': 'Bilingual dictionary with context',
                'url_template': 'https://www.linguee.com/{sl_full}-{tl_full}/search?source=auto&query={query}',
                'lang_format': 'full_lower',  # dutch, english, german
                'bidirectional': True,  # searches both directions
            },
            {
                'id': 'proz',
                'name': 'ProZ.com',
                'icon': 'üí¨',
                'description': 'Translator terminology database',
                'url_template': 'https://www.proz.com/search/?term={query}&from={sl}&to={tl}&results_per_page=25&es=1',
                'lang_format': 'iso3',  # dut, eng, ger
                'bidirectional': False,
            },
            {
                'id': 'reverso',
                'name': 'Reverso Context',
                'icon': 'üîÑ',
                'description': 'Context-based translations',
                'url_template': 'https://context.reverso.net/translation/{sl_full}-{tl_full}/{query}',
                'lang_format': 'full_lower',  # dutch, english
                'bidirectional': False,
            },
            {
                'id': 'google',
                'name': 'Google Search',
                'icon': 'üîç',
                'description': 'General web search',
                'url_template': 'https://www.google.com/search?q={query}',
                'lang_format': None,  # No language needed
                'bidirectional': True,
            },
            {
                'id': 'google_patents',
                'name': 'Google Patents',
                'icon': 'üìú',
                'description': 'Patent search',
                'url_template': 'https://patents.google.com/?q="{query}"',
                'lang_format': None,
                'bidirectional': True,
            },
            {
                'id': 'wikipedia_source',
                'name': 'Wikipedia (Source)',
                'icon': 'üìñ',
                'description': 'Wikipedia in source language',
                'url_template': 'https://{sl}.wikipedia.org/w/index.php?search={query}',
                'lang_format': 'iso2',  # nl, en, de
                'bidirectional': True,
            },
            {
                'id': 'wikipedia_target',
                'name': 'Wikipedia (Target)',
                'icon': 'üìñ',
                'description': 'Wikipedia in target language',
                'url_template': 'https://{tl}.wikipedia.org/w/index.php?search={query}',
                'lang_format': 'iso2',
                'bidirectional': True,
            },
            {
                'id': 'juremy',
                'name': 'Juremy',
                'icon': '‚öñÔ∏è',
                'description': 'Legal terminology database',
                'url_template': 'https://juremy.com/search?src={sl}&dst={tl}&q={query}&opts=ia&tool=iws',
                'lang_format': 'iso639_3',  # nld, eng, deu (ISO 639-3 codes)
                'bidirectional': False,
            },
            {
                'id': 'beijerterm',
                'name': 'Beijerterm',
                'icon': 'üìö',
                'description': 'Dutch-English terminology database (500k+ terms)',
                'url_template': 'https://beijerterm.com/?q={query}',
                'lang_format': None,
                'bidirectional': True,
            },
            {
                'id': 'acronymfinder',
                'name': 'AcronymFinder',
                'icon': 'üî§',
                'description': 'Acronym and abbreviation dictionary',
                'url_template': 'https://www.acronymfinder.com/~/search/af.aspx?string=exact&Acronym={query}',
                'lang_format': None,
                'bidirectional': True,
            },
            {
                'id': 'babelnet',
                'name': 'BabelNet',
                'icon': 'üåê',
                'description': 'Multilingual encyclopedic dictionary',
                'url_template': 'https://babelnet.org/search?word={query}&lang={sl_upper}&transLang={tl_upper}',
                'lang_format': 'iso2_upper',  # NL, EN, DE
                'bidirectional': False,
            },
            {
                'id': 'wiktionary_source',
                'name': 'Wiktionary (Source)',
                'icon': 'üìì',
                'description': 'Wiktionary in source language',
                'url_template': 'https://{sl}.wiktionary.org/wiki/{query}',
                'lang_format': 'iso2',
                'bidirectional': True,
            },
            {
                'id': 'wiktionary_target',
                'name': 'Wiktionary (Target)',
                'icon': 'üìì',
                'description': 'Wiktionary in target language',
                'url_template': 'https://{tl}.wiktionary.org/wiki/{query}',
                'lang_format': 'iso2',
                'bidirectional': True,
            },
            {
                'id': 'github_code',
                'name': 'GitHub Code (all)',
                'icon': 'üíª',
                'description': 'Search code across all GitHub repositories',
                'url_template': 'https://github.com/search?q={query}&type=code',
                'lang_format': None,
                'bidirectional': True,
            },
            {
                'id': 'github_beijerterm',
                'name': 'GitHub Code (Beijerterm)',
                'icon': 'üíª',
                'description': 'Search Beijerterm terminology repo on GitHub',
                'url_template': 'https://github.com/search?q={query}+repo%3Amichaelbeijer%2Fbeijerterm&type=code',
                'lang_format': None,
                'bidirectional': True,
            },
            {
                'id': 'opus_corpus',
                'name': 'OPUS Corpus',
                'icon': 'üìö',
                'description': 'Search 58B parallel sentences from OPUS parallel corpora',
                'url_template': 'https://opus.nlpl.eu/bin/opuscqp.pl?corpus={opus_corpus};lang={sl};cqp={query};align={tl}',
                'lang_format': 'iso2',
                'bidirectional': False,
                'has_corpus_selector': True,  # Special flag for OPUS
            },
        ]
        
        # OPUS corpus options for the selector
        self.opus_corpora = [
            ('DGT', 'DGT - EU Translation Memory (1.1B pairs)'),
            ('Europarl', 'Europarl - EU Parliament (186M pairs)'),
            ('OpenSubtitles', 'OpenSubtitles - Movies/TV (20B pairs)'),
            ('EMEA', 'EMEA - Medicines Agency (243M pairs)'),
            ('EUbookshop', 'EUbookshop - EU Publications (279M pairs)'),
            ('JRC-Acquis', 'JRC-Acquis - EU Legislation (147M pairs)'),
            ('ECB', 'ECB - Central Bank (15M pairs)'),
            ('TED2020', 'TED2020 - TED Talks (143M pairs)'),
            ('WikiMatrix', 'WikiMatrix - Wikipedia (127M pairs)'),
            ('GlobalVoices', 'GlobalVoices - News (7.3M pairs)'),
            ('Tatoeba', 'Tatoeba - Example Sentences (8.7M pairs)'),
        ]
        self.current_opus_corpus = 'DGT'  # Default corpus
        
        # === Use QSplitter for resizable sidebar ===
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # === Left sidebar with vertical tabs ===
        sidebar = QWidget()
        sidebar.setMinimumWidth(120)
        sidebar.setMaximumWidth(250)
        sidebar.setStyleSheet("""
            QWidget {
                background-color: #f5f5f5;
                border-right: 1px solid #ddd;
            }
        """)
        sidebar_layout = QVBoxLayout(sidebar)
        sidebar_layout.setContentsMargins(5, 10, 5, 10)
        sidebar_layout.setSpacing(2)
        
        # Sidebar header
        sidebar_header = QLabel("üåê Resources")
        sidebar_header.setStyleSheet("font-weight: bold; font-size: 10pt; padding: 5px; color: #1976D2;")
        sidebar_layout.addWidget(sidebar_header)
        
        # Resource buttons list
        self.web_resource_buttons = []
        self.web_resource_button_group = QButtonGroup(self)
        self.web_resource_button_group.setExclusive(True)
        
        for i, resource in enumerate(self.web_resources):
            btn = QPushButton(f"{resource['icon']} {resource['name']}")
            btn.setCheckable(True)
            btn.setToolTip(resource['description'])
            btn.setStyleSheet("""
                QPushButton {
                    text-align: left;
                    padding: 8px 10px;
                    border: none;
                    border-radius: 4px;
                    background-color: transparent;
                    font-size: 9pt;
                    outline: none;
                }
                QPushButton:hover {
                    background-color: #e3e3e3;
                }
                QPushButton:checked {
                    background-color: #2196F3;
                    color: white;
                    font-weight: bold;
                }
                QPushButton:focus {
                    outline: none;
                    border: none;
                }
            """)
            btn.clicked.connect(lambda checked, idx=i: self._on_web_resource_selected(idx))
            self.web_resource_button_group.addButton(btn, i)
            self.web_resource_buttons.append(btn)
            sidebar_layout.addWidget(btn)
        
        sidebar_layout.addStretch()
        
        # "Search All" button - pre-loads all resources
        search_all_btn = QPushButton("üîé Search All")
        search_all_btn.setToolTip("Search all web resources at once (embedded mode)")
        search_all_btn.setStyleSheet("""
            QPushButton {
                padding: 8px;
                background-color: #FF9800;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 9pt;
                outline: none;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
        """)
        search_all_btn.clicked.connect(lambda: self._perform_web_search(search_all=True))
        sidebar_layout.addWidget(search_all_btn)
        
        # Browser mode toggle
        mode_label = QLabel("Mode:")
        mode_label.setStyleSheet("font-size: 8pt; color: #666; padding-top: 5px;")
        sidebar_layout.addWidget(mode_label)
        
        self.web_mode_embedded_radio = CheckmarkRadioButton("Embedded")
        self.web_mode_embedded_radio.setToolTip("Show results inside Supervertaler")
        self.web_mode_embedded_radio.setChecked(self.web_browser_mode == 'embedded')
        self.web_mode_embedded_radio.setEnabled(self.web_engine_available)
        self.web_mode_embedded_radio.toggled.connect(self._on_web_mode_changed)
        sidebar_layout.addWidget(self.web_mode_embedded_radio)
        
        self.web_mode_external_radio = CheckmarkRadioButton("External")
        self.web_mode_external_radio.setToolTip("Open results in default browser")
        self.web_mode_external_radio.setChecked(self.web_browser_mode == 'external')
        self.web_mode_external_radio.toggled.connect(self._on_web_mode_changed)
        sidebar_layout.addWidget(self.web_mode_external_radio)
        
        # "Open in Browser" button at bottom of sidebar
        self.web_open_external_btn = QPushButton("üåç Open in Browser")
        self.web_open_external_btn.setToolTip("Open current page in your default web browser")
        self.web_open_external_btn.setStyleSheet("""
            QPushButton {
                padding: 8px;
                min-height: 20px;
                background-color: #4CAF50;
                color: white;
                border: none;
                border-radius: 4px;
                font-size: 9pt;
                margin-top: 5px;
                outline: none;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
            QPushButton:focus {
                outline: none;
                border: none;
            }
        """)
        self.web_open_external_btn.clicked.connect(self._open_web_resource_external)
        sidebar_layout.addWidget(self.web_open_external_btn)
        
        splitter.addWidget(sidebar)
        
        # === Main content area ===
        content_widget = QWidget()
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(10, 10, 10, 10)
        content_layout.setSpacing(5)
        
        # Info label showing current language direction (no separate search bar - uses main Superlookup search)
        self.web_lang_info_label = QLabel("Languages: Any ‚Üí Any  ‚Ä¢  Click Search above or select a resource")
        self.web_lang_info_label.setStyleSheet("color: #666; font-size: 9pt; padding: 3px 0;")
        content_layout.addWidget(self.web_lang_info_label)
        
        # OPUS corpus selector (hidden by default, shown when OPUS is selected)
        self.opus_selector_widget = QWidget()
        opus_selector_layout = QHBoxLayout(self.opus_selector_widget)
        opus_selector_layout.setContentsMargins(0, 5, 0, 5)
        opus_selector_layout.setSpacing(8)
        
        opus_label = QLabel("üìö Corpus:")
        opus_label.setStyleSheet("font-weight: bold; color: #1976D2;")
        opus_selector_layout.addWidget(opus_label)
        
        self.opus_corpus_combo = QComboBox()
        self.opus_corpus_combo.setMinimumWidth(280)
        self.opus_corpus_combo.setStyleSheet("""
            QComboBox {
                padding: 5px 10px;
                border: 1px solid #1976D2;
                border-radius: 4px;
                background: white;
            }
            QComboBox:hover {
                border-color: #1565C0;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 8px;
            }
        """)
        for corpus_id, corpus_name in self.opus_corpora:
            self.opus_corpus_combo.addItem(corpus_name, corpus_id)
        self.opus_corpus_combo.currentIndexChanged.connect(self._on_opus_corpus_changed)
        opus_selector_layout.addWidget(self.opus_corpus_combo)
        
        opus_selector_layout.addStretch()
        self.opus_selector_widget.hide()  # Hidden by default
        content_layout.addWidget(self.opus_selector_widget)
        
        # Web view container - stacked widget for embedded views per resource
        self.web_view_stack = QStackedWidget()
        
        # LAZY LOADING: Don't create all web views upfront - create them on demand
        # This dramatically improves startup performance and memory usage
        # Each QWebEngineView spawns a Chromium process, so 14 views = 14 processes
        self.web_views = {}  # Will be populated lazily when resources are selected
        
        # Fallback view for external mode or when web engine not available
        self.web_results_view = QTextEdit()
        self.web_results_view.setReadOnly(True)
        self.web_results_view.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 10px;
                font-size: 11pt;
            }
        """)
        self._show_web_welcome_message()
        self.web_view_stack.addWidget(self.web_results_view)
        
        content_layout.addWidget(self.web_view_stack, stretch=1)
        
        splitter.addWidget(content_widget)
        splitter.setStretchFactor(0, 0)  # Sidebar doesn't stretch
        splitter.setStretchFactor(1, 1)  # Content area stretches
        splitter.setSizes([150, 600])    # Initial sizes
        
        layout.addWidget(splitter, stretch=1)
        
        # Track current resource and last search URL
        self.current_web_resource_index = 0
        self.last_web_search_url = None
        self.last_web_search_query = None
        
        # Select first resource by default
        if self.web_resource_buttons:
            self.web_resource_buttons[0].setChecked(True)
        
        # Show correct view based on mode
        self._update_web_view_for_mode()
        
        # Update enabled state based on settings
        self.search_web_enabled = True  # Now implemented!
        
        return tab
    
    def _show_web_welcome_message(self):
        """Show welcome message in the web results view"""
        mode_info = "embedded browser" if self.web_browser_mode == 'embedded' else "your default web browser"
        self.web_results_view.setHtml(f"""
            <div style="text-align: center; padding: 40px; color: #999;">
                <h2>üåê Web Resources</h2>
                <p>Select a resource from the sidebar and enter a search term.</p>
                <p>Results will open in <b>{mode_info}</b>.</p>
                <p style="font-size: 10pt; margin-top: 20px;">
                    <b>Tip:</b> The search respects the language direction from the From/To dropdowns above.
                </p>
                <p style="font-size: 9pt; color: #aaa; margin-top: 10px;">
                    Use the mode toggle in the sidebar to switch between embedded and external browser.
                </p>
            </div>
        """)
    
    def _create_web_view_for_resource(self, resource):
        """Lazily create a web view for a specific resource (on-demand creation)
        
        This improves performance by not creating all 14+ QWebEngineView instances at startup.
        Each QWebEngineView spawns its own Chromium process, so lazy loading saves significant
        memory and startup time.
        """
        if not self.web_engine_available:
            return
            
        if resource['id'] in self.web_views:
            return  # Already created
            
        web_view = self.QWebEngineView()
        
        # Use persistent profile with silent page (suppresses JS console spam)
        if self.web_profile and self.SilentWebPage:
            page = self.SilentWebPage(self.web_profile, web_view)
            web_view.setPage(page)
        
        web_view.setUrl(QUrl("about:blank"))
        
        # Add to stack - we'll use indexOf() to find it later instead of tracking indices
        self.web_view_stack.addWidget(web_view)
        self.web_views[resource['id']] = web_view
        
        print(f"[Superlookup] Created web view for {resource['name']} (lazy load)")
    
    def _get_web_view_index(self, resource_id):
        """Get the stack index for a web view by resource ID"""
        if resource_id in self.web_views:
            return self.web_view_stack.indexOf(self.web_views[resource_id])
        return -1
    
    def _on_web_mode_changed(self, checked):
        """Handle browser mode toggle"""
        if self.web_mode_embedded_radio.isChecked():
            self.web_browser_mode = 'embedded'
        else:
            self.web_browser_mode = 'external'
        
        self._update_web_view_for_mode()
        self._show_web_welcome_message()
        print(f"[Superlookup] Web browser mode changed to: {self.web_browser_mode}")
    
    def _update_web_view_for_mode(self):
        """Update the view stack based on current mode"""
        if self.web_browser_mode == 'embedded' and self.web_engine_available:
            # Show embedded view for current resource (create lazily if needed)
            resource = self.web_resources[self.current_web_resource_index]
            if resource['id'] not in self.web_views:
                self._create_web_view_for_resource(resource)
            idx = self._get_web_view_index(resource['id'])
            if idx >= 0:
                self.web_view_stack.setCurrentIndex(idx)
        else:
            # Show text view (for external mode or fallback)
            self.web_view_stack.setCurrentIndex(self.web_view_stack.indexOf(self.web_results_view))
    
    def _on_web_resource_selected(self, index):
        """Handle web resource selection from sidebar"""
        self.current_web_resource_index = index
        resource = self.web_resources[index]
        
        # Show/hide OPUS corpus selector based on selected resource
        if hasattr(self, 'opus_selector_widget'):
            if resource.get('has_corpus_selector'):
                self.opus_selector_widget.show()
            else:
                self.opus_selector_widget.hide()
        
        # Update view based on mode
        if self.web_browser_mode == 'embedded' and self.web_engine_available:
            # LAZY LOADING: Create web view for this resource if it doesn't exist yet
            if resource['id'] not in self.web_views:
                self._create_web_view_for_resource(resource)
            
            # Switch to this resource's embedded web view
            idx = self._get_web_view_index(resource['id'])
            if idx >= 0:
                self.web_view_stack.setCurrentIndex(idx)
                
                # If we have a cached search query, perform search for this resource
                if self.last_web_search_query:
                    url = self._build_web_search_url(resource, self.last_web_search_query)
                    if url:
                        self.web_views[resource['id']].setUrl(QUrl(url))
        else:
            # External mode - show info
            self.web_results_view.setHtml(f"""
                <div style="text-align: center; padding: 40px;">
                    <h2>{resource['icon']} {resource['name']}</h2>
                    <p style="color: #666;">{resource['description']}</p>
                    <p style="margin-top: 20px;">Enter a search term above and press Search.</p>
                    <p style="font-size: 9pt; color: #aaa;">Results will open in your default browser.</p>
                </div>
            """)
        
        # Update language info
        self._update_web_lang_info()
    
    def _update_web_lang_info(self):
        """Update the language direction info label for web resources"""
        from_lang = self.lang_from_combo.currentData() if hasattr(self, 'lang_from_combo') else None
        to_lang = self.lang_to_combo.currentData() if hasattr(self, 'lang_to_combo') else None
        
        from_display = self.lang_from_combo.currentText() if from_lang else "Any"
        to_display = self.lang_to_combo.currentText() if to_lang else "Any"
        
        if hasattr(self, 'web_lang_info_label'):
            self.web_lang_info_label.setText(f"Languages: {from_display} ‚Üí {to_display}")
    
    def _perform_web_search(self, search_all: bool = False):
        """Perform web search with the selected resource(s)
        
        Args:
            search_all: If True, search all enabled resources (for embedded mode)
        """
        # Use the main Superlookup source text field
        query = self.source_text.currentText().strip()
        if not query:
            self.status_label.setText("Please enter a search term in the Source Text field above")
            return
        
        # Cache the query for when user switches between resources
        self.last_web_search_query = query
        
        if self.web_browser_mode == 'embedded' and self.web_engine_available:
            # Embedded mode - load in web views
            if search_all:
                # Search all resources - create views lazily as needed
                for resource in self.web_resources:
                    url = self._build_web_search_url(resource, query)
                    if url:
                        if resource['id'] not in self.web_views:
                            self._create_web_view_for_resource(resource)
                        if resource['id'] in self.web_views:
                            self.web_views[resource['id']].setUrl(QUrl(url))
                self.status_label.setText(f"Searching all web resources for '{query}'")
            else:
                # Search current resource only
                resource = self.web_resources[self.current_web_resource_index]
                url = self._build_web_search_url(resource, query)
                if url:
                    self.last_web_search_url = url
                    # Create view lazily if needed
                    if resource['id'] not in self.web_views:
                        self._create_web_view_for_resource(resource)
                    if resource['id'] in self.web_views:
                        self.web_views[resource['id']].setUrl(QUrl(url))
                        # Show this resource's view
                        idx = self._get_web_view_index(resource['id'])
                        if idx >= 0:
                            self.web_view_stack.setCurrentIndex(idx)
                    self.status_label.setText(f"Loaded {resource['name']} search")
        else:
            # External mode - open in browser
            resource = self.web_resources[self.current_web_resource_index]
            url = self._build_web_search_url(resource, query)
            
            if url:
                self.last_web_search_url = url
                
                # Show the URL that will be opened
                self.web_results_view.setHtml(f"""
                    <div style="padding: 20px;">
                        <h3>{resource['icon']} {resource['name']}</h3>
                        <p><b>Search term:</b> {query}</p>
                        <p><b>Opening URL:</b></p>
                        <p style="word-wrap: break-word; color: #1976D2;">
                            <a href="{url}">{url}</a>
                        </p>
                        <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
                        <p style="color: #666; font-size: 10pt;">
                            Click "Open in Browser" to open again, or select another resource.
                        </p>
                    </div>
                """)
                
                # Open in default browser
                QDesktopServices.openUrl(QUrl(url))
                self.status_label.setText(f"Opened {resource['name']} search in browser")
    
    def search_all_web_resources(self, query: str):
        """Search all web resources with the given query (called from Superlookup integration)
        
        Note: This method now uses the source_text field directly, so the query param
        should match what's already in source_text.
        """
        if query:
            # Source text should already be set, just trigger the search
            self._perform_web_search(search_all=True)
    
    def _build_web_search_url(self, resource, query):
        """Build the search URL for a web resource with proper language codes"""
        import urllib.parse
        
        # Get language settings (may be a list of variants)
        from_lang = self.lang_from_combo.currentData() if hasattr(self, 'lang_from_combo') else None
        to_lang = self.lang_to_combo.currentData() if hasattr(self, 'lang_to_combo') else None
        
        # If we got a list of variants, use the first one for web URLs
        if isinstance(from_lang, list) and from_lang:
            from_lang = from_lang[0]
        if isinstance(to_lang, list) and to_lang:
            to_lang = to_lang[0]
        
        # Default to English-Dutch if not specified
        if not from_lang:
            from_lang = 'en'
        if not to_lang:
            to_lang = 'nl'
        
        # URL-encode the query
        encoded_query = urllib.parse.quote(query)
        
        # Get language codes in the format needed by this resource
        lang_format = resource.get('lang_format')
        sl = self._get_web_lang_code(from_lang, lang_format)
        tl = self._get_web_lang_code(to_lang, lang_format)
        sl_full = self._get_web_lang_code(from_lang, 'full_lower')
        tl_full = self._get_web_lang_code(to_lang, 'full_lower')
        sl_upper = self._get_web_lang_code(from_lang, 'iso2').upper()
        tl_upper = self._get_web_lang_code(to_lang, 'iso2').upper()
        
        # Build URL from template
        url = resource['url_template']
        url = url.replace('{query}', encoded_query)
        url = url.replace('{sl}', sl)
        url = url.replace('{tl}', tl)
        url = url.replace('{sl_full}', sl_full)
        url = url.replace('{tl_full}', tl_full)
        url = url.replace('{sl_upper}', sl_upper)
        url = url.replace('{tl_upper}', tl_upper)
        
        # Handle OPUS corpus placeholder
        if '{opus_corpus}' in url and hasattr(self, 'current_opus_corpus'):
            url = url.replace('{opus_corpus}', self.current_opus_corpus)
        
        return url
    
    def _on_opus_corpus_changed(self, index):
        """Handle OPUS corpus selection change"""
        if hasattr(self, 'opus_corpus_combo'):
            self.current_opus_corpus = self.opus_corpus_combo.currentData()
            # If we have a search query, refresh the OPUS view
            if self.last_web_search_query and hasattr(self, 'web_views'):
                resource = self.web_resources[self.current_web_resource_index]
                if resource.get('has_corpus_selector') and resource['id'] in self.web_views:
                    url = self._build_web_search_url(resource, self.last_web_search_query)
                    self.web_views[resource['id']].setUrl(QUrl(url))
    
    def _get_web_lang_code(self, lang_code, format_type):
        """Convert language code to the format needed by different web services"""
        if not lang_code or not format_type:
            return ''
        
        # Normalize input - handle full language names or codes
        lang_lower = lang_code.lower()
        
        # Language code mappings
        # ISO-2 codes (2-letter): en, nl, de, fr, es, etc.
        iso2_map = {
            'english': 'en', 'en': 'en', 'en-us': 'en', 'en-gb': 'en', 'en-au': 'en',
            'dutch': 'nl', 'nl': 'nl', 'nl-nl': 'nl', 'nl-be': 'nl', 'nederlands': 'nl',
            'german': 'de', 'de': 'de', 'de-de': 'de', 'de-at': 'de', 'de-ch': 'de', 'deutsch': 'de',
            'french': 'fr', 'fr': 'fr', 'fr-fr': 'fr', 'fr-be': 'fr', 'fr-ca': 'fr', 'fran√ßais': 'fr',
            'spanish': 'es', 'es': 'es', 'es-es': 'es', 'es-mx': 'es', 'espa√±ol': 'es',
            'italian': 'it', 'it': 'it', 'it-it': 'it', 'italiano': 'it',
            'portuguese': 'pt', 'pt': 'pt', 'pt-pt': 'pt', 'pt-br': 'pt', 'portugu√™s': 'pt',
            'polish': 'pl', 'pl': 'pl', 'polski': 'pl',
            'russian': 'ru', 'ru': 'ru', '—Ä—É—Å—Å–∫–∏–π': 'ru',
            'chinese': 'zh', 'zh': 'zh', 'zh-cn': 'zh', 'zh-tw': 'zh', '‰∏≠Êñá': 'zh',
            'japanese': 'ja', 'ja': 'ja', 'Êó•Êú¨Ë™û': 'ja',
            'korean': 'ko', 'ko': 'ko', 'ÌïúÍµ≠Ïñ¥': 'ko',
            'arabic': 'ar', 'ar': 'ar', 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©': 'ar',
            'swedish': 'sv', 'sv': 'sv', 'svenska': 'sv',
            'danish': 'da', 'da': 'da', 'dansk': 'da',
            'norwegian': 'no', 'no': 'no', 'nb': 'no', 'nn': 'no', 'norsk': 'no',
            'finnish': 'fi', 'fi': 'fi', 'suomi': 'fi',
            'czech': 'cs', 'cs': 'cs', 'ƒçe≈°tina': 'cs',
            'hungarian': 'hu', 'hu': 'hu', 'magyar': 'hu',
            'romanian': 'ro', 'ro': 'ro', 'rom√¢nƒÉ': 'ro',
            'greek': 'el', 'el': 'el', 'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨': 'el',
            'turkish': 'tr', 'tr': 'tr', 't√ºrk√ße': 'tr',
            'ukrainian': 'uk', 'uk': 'uk', '—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞': 'uk',
            'bulgarian': 'bg', 'bg': 'bg', '–±—ä–ª–≥–∞—Ä—Å–∫–∏': 'bg',
        }
        
        # ISO-3 codes (3-letter for ProZ): dut, eng, ger, fre, spa, etc. (ISO 639-2/B bibliographic)
        iso3_map = {
            'english': 'eng', 'en': 'eng', 'en-us': 'eng', 'en-gb': 'eng',
            'dutch': 'dut', 'nl': 'dut', 'nl-nl': 'dut', 'nl-be': 'dut', 'nederlands': 'dut',
            'german': 'ger', 'de': 'ger', 'de-de': 'ger', 'deutsch': 'ger',
            'french': 'fre', 'fr': 'fre', 'fr-fr': 'fre', 'fran√ßais': 'fre',
            'spanish': 'spa', 'es': 'spa', 'es-es': 'spa', 'espa√±ol': 'spa',
            'italian': 'ita', 'it': 'ita', 'it-it': 'ita', 'italiano': 'ita',
            'portuguese': 'por', 'pt': 'por', 'pt-pt': 'por', 'portugu√™s': 'por',
            'polish': 'pol', 'pl': 'pol', 'polski': 'pol',
            'russian': 'rus', 'ru': 'rus', '—Ä—É—Å—Å–∫–∏–π': 'rus',
            'chinese': 'chi', 'zh': 'chi', 'zh-cn': 'chi', '‰∏≠Êñá': 'chi',
            'japanese': 'jpn', 'ja': 'jpn', 'Êó•Êú¨Ë™û': 'jpn',
            'korean': 'kor', 'ko': 'kor', 'ÌïúÍµ≠Ïñ¥': 'kor',
            'arabic': 'ara', 'ar': 'ara', 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©': 'ara',
            'swedish': 'swe', 'sv': 'swe', 'svenska': 'swe',
            'danish': 'dan', 'da': 'dan', 'dansk': 'dan',
            'norwegian': 'nor', 'no': 'nor', 'norsk': 'nor',
            'finnish': 'fin', 'fi': 'fin', 'suomi': 'fin',
            'czech': 'cze', 'cs': 'cze', 'ƒçe≈°tina': 'cze',
            'hungarian': 'hun', 'hu': 'hun', 'magyar': 'hun',
            'romanian': 'rum', 'ro': 'rum', 'rom√¢nƒÉ': 'rum',
            'greek': 'gre', 'el': 'gre', 'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨': 'gre',
            'turkish': 'tur', 'tr': 'tur', 't√ºrk√ße': 'tur',
            'ukrainian': 'ukr', 'uk': 'ukr', '—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞': 'ukr',
            'bulgarian': 'bul', 'bg': 'bul', '–±—ä–ª–≥–∞—Ä—Å–∫–∏': 'bul',
        }
        
        # ISO 639-3 codes (for Juremy): nld, eng, deu, fra, spa, etc.
        iso639_3_map = {
            'english': 'eng', 'en': 'eng', 'en-us': 'eng', 'en-gb': 'eng',
            'dutch': 'nld', 'nl': 'nld', 'nl-nl': 'nld', 'nl-be': 'nld', 'nederlands': 'nld',
            'german': 'deu', 'de': 'deu', 'de-de': 'deu', 'deutsch': 'deu',
            'french': 'fra', 'fr': 'fra', 'fr-fr': 'fra', 'fran√ßais': 'fra',
            'spanish': 'spa', 'es': 'spa', 'es-es': 'spa', 'espa√±ol': 'spa',
            'italian': 'ita', 'it': 'ita', 'it-it': 'ita', 'italiano': 'ita',
            'portuguese': 'por', 'pt': 'por', 'pt-pt': 'por', 'portugu√™s': 'por',
            'polish': 'pol', 'pl': 'pol', 'polski': 'pol',
            'russian': 'rus', 'ru': 'rus', '—Ä—É—Å—Å–∫–∏–π': 'rus',
        }
        
        # Full language names (lowercase for URL slugs)
        full_lower_map = {
            'english': 'english', 'en': 'english', 'en-us': 'english', 'en-gb': 'english',
            'dutch': 'dutch', 'nl': 'dutch', 'nl-nl': 'dutch', 'nl-be': 'dutch', 'nederlands': 'dutch',
            'german': 'german', 'de': 'german', 'de-de': 'german', 'deutsch': 'german',
            'french': 'french', 'fr': 'french', 'fr-fr': 'french', 'fran√ßais': 'french',
            'spanish': 'spanish', 'es': 'spanish', 'es-es': 'spanish', 'espa√±ol': 'spanish',
            'italian': 'italian', 'it': 'italian', 'it-it': 'italian', 'italiano': 'italian',
            'portuguese': 'portuguese', 'pt': 'portuguese', 'pt-pt': 'portuguese', 'portugu√™s': 'portuguese',
            'polish': 'polish', 'pl': 'polish', 'polski': 'polish',
            'russian': 'russian', 'ru': 'russian', '—Ä—É—Å—Å–∫–∏–π': 'russian',
            'chinese': 'chinese', 'zh': 'chinese', 'zh-cn': 'chinese', '‰∏≠Êñá': 'chinese',
            'japanese': 'japanese', 'ja': 'japanese', 'Êó•Êú¨Ë™û': 'japanese',
            'korean': 'korean', 'ko': 'korean', 'ÌïúÍµ≠Ïñ¥': 'korean',
            'arabic': 'arabic', 'ar': 'arabic', 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©': 'arabic',
            'swedish': 'swedish', 'sv': 'swedish', 'svenska': 'swedish',
            'danish': 'danish', 'da': 'danish', 'dansk': 'danish',
            'norwegian': 'norwegian', 'no': 'norwegian', 'norsk': 'norwegian',
            'finnish': 'finnish', 'fi': 'finnish', 'suomi': 'finnish',
            'czech': 'czech', 'cs': 'czech', 'ƒçe≈°tina': 'czech',
            'hungarian': 'hungarian', 'hu': 'hungarian', 'magyar': 'hungarian',
            'romanian': 'romanian', 'ro': 'romanian', 'rom√¢nƒÉ': 'romanian',
            'greek': 'greek', 'el': 'greek', 'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨': 'greek',
            'turkish': 'turkish', 'tr': 'turkish', 't√ºrk√ße': 'turkish',
            'ukrainian': 'ukrainian', 'uk': 'ukrainian', '—É–∫—Ä–∞—ó–Ω—Å—å–∫–∞': 'ukrainian',
            'bulgarian': 'bulgarian', 'bg': 'bulgarian', '–±—ä–ª–≥–∞—Ä—Å–∫–∏': 'bulgarian',
        }
        
        # Select the appropriate mapping
        if format_type == 'iso2':
            return iso2_map.get(lang_lower, lang_lower[:2] if len(lang_lower) >= 2 else 'en')
        elif format_type == 'iso3':
            return iso3_map.get(lang_lower, 'eng')
        elif format_type == 'iso639_3':
            return iso639_3_map.get(lang_lower, 'eng')
        elif format_type == 'full_lower':
            return full_lower_map.get(lang_lower, 'english')
        else:
            return lang_lower
    
    def _open_web_resource_external(self):
        """Open the last search URL in the default browser"""
        if self.last_web_search_url:
            QDesktopServices.openUrl(QUrl(self.last_web_search_url))
        else:
            # If no search has been performed, build URL with current input from source_text
            query = self.source_text.currentText().strip()
            if query:
                self._perform_web_search()
            else:
                self.status_label.setText("Enter a search term in the Source Text field first")
    
    def create_settings_tab(self):
        """Create the Settings tab with sub-tabs for each resource type"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)
        
        # Header
        header = QLabel("‚öôÔ∏è Search Resources Configuration")
        header.setStyleSheet("font-size: 14pt; font-weight: bold; color: #1976D2;")
        layout.addWidget(header, 0)
        
        # Description
        desc = QLabel(
            "Configure which resources to search. Each resource type has its own tab below."
        )
        desc.setWordWrap(True)
        desc.setStyleSheet("color: #666; padding: 5px 0;")
        layout.addWidget(desc, 0)
        
        # Create sub-tabs for each resource type
        self.settings_subtabs = QTabWidget()
        self.settings_subtabs.tabBar().setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.settings_subtabs.tabBar().setDrawBase(False)
        
        # TM Settings sub-tab
        tm_settings_tab = self.create_tm_settings_subtab()
        self.settings_subtabs.addTab(tm_settings_tab, "üìñ Translation Memories")
        
        # Termbase Settings sub-tab
        tb_settings_tab = self.create_termbase_settings_subtab()
        self.settings_subtabs.addTab(tb_settings_tab, "üìö Glossaries")
        
        # Note: MT Settings removed - now in main Settings ‚Üí MT Settings
        
        # Web Settings sub-tab
        web_settings_tab = self.create_web_settings_subtab()
        self.settings_subtabs.addTab(web_settings_tab, "üåê Web Resources")
        
        layout.addWidget(self.settings_subtabs, stretch=1)
        
        return tab
    
    def create_tm_settings_subtab(self):
        """Create TM settings sub-tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # Info section
        info = QLabel(
            "Select which Translation Memories to search in Superlookup.\n"
            "You can search specific TMs or all available TMs."
        )
        info.setWordWrap(True)
        info.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(info, 0)
        
        # Enable/disable TM search
        self.tm_search_checkbox = CheckmarkCheckBox("‚úì Enable TM search in Superlookup")
        self.tm_search_checkbox.setChecked(self.search_tm_enabled)
        self.tm_search_checkbox.setStyleSheet("font-weight: bold; font-size: 11pt; color: #2196F3; padding: 10px 0;")
        self.tm_search_checkbox.stateChanged.connect(self.on_tm_search_toggled)
        layout.addWidget(self.tm_search_checkbox, 0)
        
        # TM selection label
        list_label = QLabel("Select Translation Memories:")
        list_label.setStyleSheet("font-weight: bold; padding-top: 10px;")
        layout.addWidget(list_label, 0)
        
        # TM selection scroll area with checkboxes
        self.tm_scroll_area = QScrollArea()
        self.tm_scroll_area.setWidgetResizable(True)
        self.tm_scroll_area.setFrameShape(QFrame.Shape.StyledPanel)
        
        self.tm_scroll_widget = QWidget()
        self.tm_scroll_layout = QVBoxLayout(self.tm_scroll_widget)
        self.tm_scroll_layout.setContentsMargins(5, 5, 5, 5)
        self.tm_scroll_layout.setSpacing(3)
        self.tm_scroll_layout.addStretch()
        
        self.tm_scroll_area.setWidget(self.tm_scroll_widget)
        layout.addWidget(self.tm_scroll_area, stretch=1)  # Takes all available space
        
        # Store checkboxes for easy access
        self.tm_checkboxes = []
        
        # Info label
        tm_info = QLabel("üí° Tip: If no TMs are selected, all available TMs will be searched")
        tm_info.setStyleSheet("color: #666; font-size: 9pt; font-style: italic; padding: 5px 0;")
        layout.addWidget(tm_info, 0)
        
        # TM buttons
        tm_btn_layout = QHBoxLayout()
        select_all_tm_btn = QPushButton("Select All")
        select_all_tm_btn.clicked.connect(self.check_all_tms)
        tm_btn_layout.addWidget(select_all_tm_btn)
        
        clear_all_tm_btn = QPushButton("Clear All")
        clear_all_tm_btn.clicked.connect(self.uncheck_all_tms)
        tm_btn_layout.addWidget(clear_all_tm_btn)
        
        refresh_tm_btn = QPushButton("üîÑ Refresh List")
        refresh_tm_btn.clicked.connect(self.refresh_tm_list)
        tm_btn_layout.addWidget(refresh_tm_btn)
        tm_btn_layout.addStretch()
        
        layout.addLayout(tm_btn_layout, 0)
        
        return tab
    
    def create_termbase_settings_subtab(self):
        """Create Termbase settings sub-tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # Info section
        info = QLabel(
            "Select which Glossaries to search in Superlookup.\n"
            "You can search specific glossaries or all available glossaries."
        )
        info.setWordWrap(True)
        info.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(info, 0)
        
        # Enable/disable glossary search
        self.tb_search_checkbox = CheckmarkCheckBox("‚úì Enable Glossary search in Superlookup")
        self.tb_search_checkbox.setChecked(self.search_termbase_enabled)
        self.tb_search_checkbox.setStyleSheet("font-weight: bold; font-size: 11pt; color: #2196F3; padding: 10px 0;")
        self.tb_search_checkbox.stateChanged.connect(self.on_termbase_search_toggled)
        layout.addWidget(self.tb_search_checkbox, 0)
        
        # Glossary selection label
        list_label = QLabel("Select Glossaries:")
        list_label.setStyleSheet("font-weight: bold; padding-top: 10px;")
        layout.addWidget(list_label, 0)
        
        # Termbase selection scroll area with checkboxes
        self.tb_scroll_area = QScrollArea()
        self.tb_scroll_area.setWidgetResizable(True)
        self.tb_scroll_area.setFrameShape(QFrame.Shape.StyledPanel)
        
        self.tb_scroll_widget = QWidget()
        self.tb_scroll_layout = QVBoxLayout(self.tb_scroll_widget)
        self.tb_scroll_layout.setContentsMargins(5, 5, 5, 5)
        self.tb_scroll_layout.setSpacing(3)
        self.tb_scroll_layout.addStretch()
        
        self.tb_scroll_area.setWidget(self.tb_scroll_widget)
        layout.addWidget(self.tb_scroll_area, stretch=1)  # Takes all available space
        
        # Store checkboxes for easy access
        self.tb_checkboxes = []
        
        # Info label
        tb_info = QLabel("üí° Tip: If no glossaries are selected, all available glossaries will be searched")
        tb_info.setStyleSheet("color: #666; font-size: 9pt; font-style: italic; padding: 5px 0;")
        layout.addWidget(tb_info, 0)
        
        # Termbase buttons
        tb_btn_layout = QHBoxLayout()
        select_all_tb_btn = QPushButton("Select All")
        select_all_tb_btn.clicked.connect(self.check_all_tbs)
        tb_btn_layout.addWidget(select_all_tb_btn)
        
        clear_all_tb_btn = QPushButton("Clear All")
        clear_all_tb_btn.clicked.connect(self.uncheck_all_tbs)
        tb_btn_layout.addWidget(clear_all_tb_btn)
        
        refresh_tb_btn = QPushButton("üîÑ Refresh List")
        refresh_tb_btn.clicked.connect(self.refresh_termbase_list)
        tb_btn_layout.addWidget(refresh_tb_btn)
        tb_btn_layout.addStretch()
        
        layout.addLayout(tb_btn_layout, 0)
        
        return tab
    
    def create_mt_settings_subtab(self):
        """Create MT settings sub-tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # Info section
        info = QLabel(
            "Machine Translation integration is coming soon.\n"
            "This will allow Superlookup to query DeepL, Google Translate, and other MT services."
        )
        info.setWordWrap(True)
        info.setStyleSheet("padding: 5px; border-radius: 3px;")
        layout.addWidget(info, 0)
        
        # Enable checkbox (disabled for now)
        self.mt_search_checkbox = CheckmarkCheckBox("‚úì Enable Machine Translation (Coming Soon)")
        self.mt_search_checkbox.setChecked(False)
        self.mt_search_checkbox.setEnabled(False)
        self.mt_search_checkbox.setStyleSheet("font-weight: bold; font-size: 11pt; color: #999; padding: 10px 0;")
        layout.addWidget(self.mt_search_checkbox, 0)
        
        # Placeholder content
        placeholder = QLabel("üöß Under Construction\n\nComing soon:\n‚Ä¢ DeepL integration\n‚Ä¢ Google Translate\n‚Ä¢ Microsoft Translator\n‚Ä¢ Amazon Translate\n‚Ä¢ ModernMT")
        placeholder.setAlignment(Qt.AlignmentFlag.AlignCenter)
        placeholder.setStyleSheet("color: #999; padding: 40px; font-size: 11pt;")
        layout.addWidget(placeholder, stretch=1)
        
        return tab
    
    def create_web_settings_subtab(self):
        """Create Web Resources settings sub-tab"""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        layout.setContentsMargins(15, 15, 15, 15)
        layout.setSpacing(10)
        
        # Info section
        info = QLabel(
            "Configure which web resources to show in the Web Resources tab.\n"
            "Search results will open in your default web browser."
        )
        info.setWordWrap(True)
        info.setStyleSheet("color: #666; padding: 5px; background-color: #E8F5E9; border-radius: 3px;")
        layout.addWidget(info, 0)
        
        # Enable checkbox
        self.web_search_checkbox = CheckmarkCheckBox("‚úì Enable Web Resources in Superlookup")
        self.web_search_checkbox.setChecked(True)
        self.web_search_checkbox.setStyleSheet("font-weight: bold; font-size: 11pt; color: #4CAF50; padding: 10px 0;")
        layout.addWidget(self.web_search_checkbox, 0)
        
        # Available resources list
        resources_label = QLabel("Available Web Resources:")
        resources_label.setStyleSheet("font-weight: bold; padding-top: 10px;")
        layout.addWidget(resources_label, 0)
        
        # Scroll area for resource checkboxes
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.StyledPanel)
        
        scroll_widget = QWidget()
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setContentsMargins(10, 10, 10, 10)
        scroll_layout.setSpacing(5)
        
        # Add checkboxes for each resource (all enabled by default)
        self.web_resource_checkboxes = []
        default_resources = [
            ('üá™üá∫ IATE', 'EU terminology database - supports language direction'),
            ('üìó Linguee', 'Bilingual dictionary with context sentences'),
            ('üí¨ ProZ.com', 'Translator terminology database - supports language direction'),
            ('üîÑ Reverso Context', 'Context-based translations with examples'),
            ('üîç Google Search', 'General web search'),
            ('üìú Google Patents', 'Search patents for terminology'),
            ('üìñ Wikipedia (Source)', 'Wikipedia in source language'),
            ('üìñ Wikipedia (Target)', 'Wikipedia in target language'),
            ('‚öñÔ∏è Juremy', 'Legal terminology database'),
            ('üìö michaelbeijer.co.uk', 'Personal terminology wiki'),
            ('üî§ AcronymFinder', 'Acronym and abbreviation dictionary'),
            ('üåê BabelNet', 'Multilingual encyclopedic dictionary'),
            ('üìì Wiktionary (Source)', 'Wiktionary in source language'),
            ('üìì Wiktionary (Target)', 'Wiktionary in target language'),
        ]
        
        for i, (name, desc) in enumerate(default_resources):
            cb = CheckmarkCheckBox(name)
            cb.setChecked(True)
            cb.setToolTip(desc)
            # Connect to update sidebar visibility when checkbox changes
            cb.stateChanged.connect(lambda state, idx=i: self._on_web_resource_checkbox_changed(idx, state))
            scroll_layout.addWidget(cb)
            self.web_resource_checkboxes.append(cb)
        
        scroll_layout.addStretch()
        scroll.setWidget(scroll_widget)
        layout.addWidget(scroll, stretch=1)
        
        # Future: Add custom URL section
        future_label = QLabel("üí° Tip: More web resources can be added in future updates")
        future_label.setStyleSheet("color: #666; font-size: 9pt; font-style: italic; padding: 5px 0;")
        layout.addWidget(future_label, 0)
        
        return tab
    
    def on_results_tab_changed(self, index):
        """Handle results tab change - initialize Supermemory and refresh Settings when viewed"""
        # Supermemory tab is at index 2 (TM=0, Termbase=1, Supermemory=2, MT=3, Web=4, Settings=5)
        if index == 2:
            # Initialize Supermemory when tab is first viewed
            if not self.supermemory_engine:
                print("[Superlookup] Supermemory tab viewed - initializing engine")
                self.init_supermemory()
        # Settings tab is at index 5
        elif index == 5:
            print("[Superlookup] Settings tab viewed - refreshing resource lists")
            self.refresh_tm_list()
            self.refresh_termbase_list()
            self.populate_language_dropdowns()
    
    def on_tm_search_toggled(self, state):
        """Handle TM search checkbox toggle"""
        self.search_tm_enabled = (state == Qt.CheckState.Checked.value)
        print(f"[Superlookup] TM search {'enabled' if self.search_tm_enabled else 'disabled'}")
    
    def on_termbase_search_toggled(self, state):
        """Handle termbase search checkbox toggle"""
        self.search_termbase_enabled = (state == Qt.CheckState.Checked.value)
        print(f"[Superlookup] Termbase search {'enabled' if self.search_termbase_enabled else 'disabled'}")
    
    def _on_web_resource_checkbox_changed(self, index: int, state: int):
        """Handle web resource checkbox change - show/hide corresponding sidebar button"""
        is_checked = (state == Qt.CheckState.Checked.value)
        if hasattr(self, 'web_resource_buttons') and index < len(self.web_resource_buttons):
            self.web_resource_buttons[index].setVisible(is_checked)
            print(f"[Superlookup] Web resource {index} {'shown' if is_checked else 'hidden'}")
            
            # If the hidden resource was selected, select the first visible one
            if not is_checked and hasattr(self, 'current_web_resource_index') and self.current_web_resource_index == index:
                for i, btn in enumerate(self.web_resource_buttons):
                    if btn.isVisible():
                        self._on_web_resource_selected(i)
                        btn.setChecked(True)
                        break
    
    def refresh_tm_list(self):
        """Refresh the list of available TMs"""
        # Clear existing checkboxes
        for checkbox in self.tm_checkboxes:
            self.tm_scroll_layout.removeWidget(checkbox)
            checkbox.deleteLater()
        self.tm_checkboxes.clear()
        
        print(f"[Superlookup] refresh_tm_list called")
        print(f"[Superlookup]   main_window exists: {self.main_window is not None}")
        
        # Get TMs from main window's database
        if self.main_window and hasattr(self.main_window, 'db_manager') and self.main_window.db_manager:
            try:
                print(f"[Superlookup]   db_manager found, querying TMs...")
                cursor = self.main_window.db_manager.cursor
                cursor.execute("SELECT id, name, tm_id FROM translation_memories ORDER BY name")
                tms = cursor.fetchall()
                
                print(f"[Superlookup]   Query returned {len(tms)} TMs")
                
                for db_id, tm_name, tm_id_str in tms:
                    checkbox = CheckmarkCheckBox(f"{tm_name} (ID: {db_id})")
                    checkbox.setChecked(True)  # Check all by default
                    checkbox.setProperty("tm_id", tm_id_str)  # Store tm_id string for search
                    checkbox.setProperty("db_id", db_id)  # Store db_id for reference
                    self.tm_checkboxes.append(checkbox)
                    # Insert before the stretch at the end
                    self.tm_scroll_layout.insertWidget(len(self.tm_checkboxes) - 1, checkbox)
                
                print(f"[Superlookup] ‚úì Loaded {len(tms)} TMs")
            except Exception as e:
                print(f"[Superlookup] ‚úó Error loading TMs: {e}")
                import traceback
                traceback.print_exc()
        else:
            print(f"[Superlookup]   db_manager not available")
            # Add placeholder label
            placeholder = QLabel("No database connection - TMs unavailable")
            placeholder.setStyleSheet("color: #999; font-style: italic;")
            self.tm_scroll_layout.insertWidget(0, placeholder)
    
    def refresh_termbase_list(self):
        """Refresh the list of available termbases"""
        # Clear existing checkboxes
        for checkbox in self.tb_checkboxes:
            self.tb_scroll_layout.removeWidget(checkbox)
            checkbox.deleteLater()
        self.tb_checkboxes.clear()
        
        print(f"[Superlookup] refresh_termbase_list called")
        print(f"[Superlookup]   main_window exists: {self.main_window is not None}")
        
        # Try termbase_mgr first (preferred method)
        if self.main_window and hasattr(self.main_window, 'termbase_mgr') and self.main_window.termbase_mgr:
            try:
                print(f"[Superlookup]   termbase_mgr found, querying termbases...")
                termbases = self.main_window.termbase_mgr.get_all_termbases()
                
                print(f"[Superlookup]   get_all_termbases() returned {len(termbases)} termbases")
                
                for tb in termbases:
                    tb_id = tb.get('id')
                    tb_name = tb.get('name', 'Unnamed')
                    checkbox = CheckmarkCheckBox(f"{tb_name} (ID: {tb_id})")
                    checkbox.setChecked(True)  # Check all by default
                    checkbox.setProperty("tb_id", tb_id)
                    self.tb_checkboxes.append(checkbox)
                    # Insert before the stretch at the end
                    self.tb_scroll_layout.insertWidget(len(self.tb_checkboxes) - 1, checkbox)
                
                print(f"[Superlookup] ‚úì Loaded {len(termbases)} termbases via termbase_mgr")
                return
            except Exception as e:
                print(f"[Superlookup] ‚úó Error loading termbases via termbase_mgr: {e}")
                import traceback
                traceback.print_exc()
        
        # Fallback to direct database query
        if self.main_window and hasattr(self.main_window, 'db_manager') and self.main_window.db_manager:
            try:
                print(f"[Superlookup]   db_manager found, querying termbases...")
                cursor = self.main_window.db_manager.cursor
                cursor.execute("SELECT id, name FROM termbases ORDER BY name")
                termbases = cursor.fetchall()
                
                print(f"[Superlookup]   Query returned {len(termbases)} termbases")
                
                for tb_id, tb_name in termbases:
                    checkbox = CheckmarkCheckBox(f"{tb_name} (ID: {tb_id})")
                    checkbox.setChecked(True)  # Check all by default
                    checkbox.setProperty("tb_id", tb_id)
                    self.tb_checkboxes.append(checkbox)
                    # Insert before the stretch at the end
                    self.tb_scroll_layout.insertWidget(len(self.tb_checkboxes) - 1, checkbox)
                
                print(f"[Superlookup] ‚úì Loaded {len(termbases)} termbases via db_manager")
            except Exception as e:
                print(f"[Superlookup] ‚úó Error loading termbases via db_manager: {e}")
                import traceback
                traceback.print_exc()
        else:
            print(f"[Superlookup]   Neither termbase_mgr nor db_manager available")
            # Add placeholder label
            placeholder = QLabel("No database connection - Glossaries unavailable")
            placeholder.setStyleSheet("color: #999; font-style: italic;")
            self.tb_scroll_layout.insertWidget(0, placeholder)
    
    def get_selected_tm_ids(self):
        """Get list of checked TM IDs"""
        selected_ids = []
        for checkbox in self.tm_checkboxes:
            if checkbox.isChecked():
                tm_id = checkbox.property("tm_id")
                if tm_id is not None:
                    selected_ids.append(tm_id)
        return selected_ids
    
    def get_search_direction(self):
        """Get the current search direction setting.
        
        Always returns 'both' for maximum search coverage.
        Smart language swapping ensures results are always shown in correct order.
        """
        return 'both'
    
    def _on_language_changed(self):
        """Handle language dropdown change - update Web Resources info"""
        # Update the web resources language info label
        self._update_web_lang_info()
    
    def get_language_filters(self):
        """Get the current language filter settings.
        
        Returns:
            tuple: (from_lang, to_lang) - None means 'Any'
        """
        from_lang = None
        to_lang = None
        
        if hasattr(self, 'lang_from_combo'):
            from_lang = self.lang_from_combo.currentData()
        if hasattr(self, 'lang_to_combo'):
            to_lang = self.lang_to_combo.currentData()
        
        return (from_lang, to_lang)
    
    def swap_language_filters(self):
        """Swap the From and To language selections"""
        if hasattr(self, 'lang_from_combo') and hasattr(self, 'lang_to_combo'):
            from_idx = self.lang_from_combo.currentIndex()
            to_idx = self.lang_to_combo.currentIndex()
            self.lang_from_combo.setCurrentIndex(to_idx)
            self.lang_to_combo.setCurrentIndex(from_idx)
    
    def populate_language_dropdowns(self):
        """Populate language dropdowns with BASE languages only (not variants).
        
        Groups all variants (en, en-US, en-GB, English, etc.) into a single "English" entry.
        When searching, all variants will be matched.
        """
        all_languages = set()  # All language codes/names found in database
        
        # Ensure we have db_manager from main window
        db_manager = self.db_manager
        if not db_manager and self.main_window and hasattr(self.main_window, 'db_manager'):
            db_manager = self.main_window.db_manager
        
        # Ensure we have termbase_mgr from main window
        termbase_mgr = self.termbase_mgr
        if not termbase_mgr and self.main_window and hasattr(self.main_window, 'termbase_mgr'):
            termbase_mgr = self.main_window.termbase_mgr
        
        # Get languages from TMs via database
        if db_manager:
            try:
                db_manager.cursor.execute("""
                    SELECT DISTINCT source_lang FROM translation_units WHERE source_lang IS NOT NULL AND source_lang != ''
                    UNION
                    SELECT DISTINCT target_lang FROM translation_units WHERE target_lang IS NOT NULL AND target_lang != ''
                """)
                for row in db_manager.cursor.fetchall():
                    if row[0]:
                        all_languages.add(row[0])
            except Exception:
                pass  # Silent failure for language population
        
        # Get languages from termbases
        if termbase_mgr:
            try:
                all_termbases = termbase_mgr.get_all_termbases()
                for tb in all_termbases:
                    if tb.get('source_lang'):
                        all_languages.add(tb['source_lang'])
                    if tb.get('target_lang'):
                        all_languages.add(tb['target_lang'])
            except Exception:
                pass  # Silent failure for language population
        
        # Group languages by their base language name
        # E.g., "en", "en-US", "en-GB", "English" all map to "English"
        base_lang_variants = {}  # base_name -> set of all variant codes
        
        for lang in all_languages:
            base_name = self._get_base_language_name(lang)
            if base_name not in base_lang_variants:
                base_lang_variants[base_name] = set()
            base_lang_variants[base_name].add(lang)
        
        # Store the mapping for use in searches
        self._language_variants_map = base_lang_variants
        
        # Sort base languages alphabetically
        sorted_base_langs = sorted(base_lang_variants.keys(), key=str.lower)
        
        # Clear existing items except "Any"
        while self.lang_from_combo.count() > 1:
            self.lang_from_combo.removeItem(1)
        while self.lang_to_combo.count() > 1:
            self.lang_to_combo.removeItem(1)
        
        # Add base languages only (store list of all variants as data)
        for base_name in sorted_base_langs:
            variants = list(base_lang_variants[base_name])
            # Store variants list as the data for this item
            self.lang_from_combo.addItem(base_name, variants)
            self.lang_to_combo.addItem(base_name, variants)
    
    def _get_base_language_name(self, lang_code):
        """Extract the base language name from any language code or name.
        
        Maps all variants to a single base name:
        - "en", "en-US", "en-GB", "English", "english" ‚Üí "English"
        - "nl", "nl-NL", "nl-BE", "Dutch", "Nederlands" ‚Üí "Dutch"
        """
        # Base language names mapping
        base_names = {
            'en': 'English', 'english': 'English',
            'nl': 'Dutch', 'dutch': 'Dutch', 'nederlands': 'Dutch',
            'de': 'German', 'german': 'German', 'deutsch': 'German',
            'fr': 'French', 'french': 'French', 'fran√ßais': 'French', 'francais': 'French',
            'es': 'Spanish', 'spanish': 'Spanish', 'espa√±ol': 'Spanish', 'espanol': 'Spanish',
            'it': 'Italian', 'italian': 'Italian', 'italiano': 'Italian',
            'pt': 'Portuguese', 'portuguese': 'Portuguese', 'portugu√™s': 'Portuguese', 'portugues': 'Portuguese',
            'zh': 'Chinese', 'chinese': 'Chinese',
            'ja': 'Japanese', 'japanese': 'Japanese',
            'ko': 'Korean', 'korean': 'Korean',
            'ru': 'Russian', 'russian': 'Russian',
            'pl': 'Polish', 'polish': 'Polish', 'polski': 'Polish',
            'cs': 'Czech', 'czech': 'Czech',
            'da': 'Danish', 'danish': 'Danish', 'dansk': 'Danish',
            'sv': 'Swedish', 'swedish': 'Swedish', 'svenska': 'Swedish',
            'no': 'Norwegian', 'nb': 'Norwegian', 'nn': 'Norwegian', 'norwegian': 'Norwegian', 'norsk': 'Norwegian',
            'fi': 'Finnish', 'finnish': 'Finnish', 'suomi': 'Finnish',
            'ar': 'Arabic', 'arabic': 'Arabic',
            'he': 'Hebrew', 'hebrew': 'Hebrew',
            'tr': 'Turkish', 'turkish': 'Turkish',
            'el': 'Greek', 'greek': 'Greek',
            'hu': 'Hungarian', 'hungarian': 'Hungarian', 'magyar': 'Hungarian',
            'ro': 'Romanian', 'romanian': 'Romanian',
            'bg': 'Bulgarian', 'bulgarian': 'Bulgarian',
            'uk': 'Ukrainian', 'ukrainian': 'Ukrainian',
            'vi': 'Vietnamese', 'vietnamese': 'Vietnamese',
            'th': 'Thai', 'thai': 'Thai',
            'id': 'Indonesian', 'indonesian': 'Indonesian',
            'ms': 'Malay', 'malay': 'Malay',
            'sk': 'Slovak', 'slovak': 'Slovak',
            'sl': 'Slovenian', 'slovenian': 'Slovenian',
            'hr': 'Croatian', 'croatian': 'Croatian',
            'sr': 'Serbian', 'serbian': 'Serbian',
            'et': 'Estonian', 'estonian': 'Estonian',
            'lv': 'Latvian', 'latvian': 'Latvian',
            'lt': 'Lithuanian', 'lithuanian': 'Lithuanian',
            'ca': 'Catalan', 'catalan': 'Catalan',
            'ga': 'Irish', 'irish': 'Irish',
            'mt': 'Maltese', 'maltese': 'Maltese',
        }
        
        if not lang_code:
            return 'Unknown'
        
        # Normalize: lowercase for lookup
        lang_lower = lang_code.lower().strip()
        
        # Get base code (before hyphen or underscore)
        # Handles: en-US, en_GB, nl-NL, etc.
        base_code = lang_lower.split('-')[0].split('_')[0]
        
        # First try exact match
        if lang_lower in base_names:
            return base_names[lang_lower]
        
        # Then try base code
        if base_code in base_names:
            return base_names[base_code]
        
        # Unknown language - capitalize first letter
        return lang_code.capitalize() if lang_code else 'Unknown'
    
    def get_selected_termbase_ids(self):
        """Get list of checked termbase IDs"""
        selected_ids = []
        for checkbox in self.tb_checkboxes:
            if checkbox.isChecked():
                tb_id = checkbox.property("tb_id")
                if tb_id is not None:
                    selected_ids.append(tb_id)
        return selected_ids
    
    def check_all_tms(self):
        """Check all TM checkboxes"""
        for checkbox in self.tm_checkboxes:
            checkbox.setChecked(True)
    
    def uncheck_all_tms(self):
        """Uncheck all TM checkboxes"""
        for checkbox in self.tm_checkboxes:
            checkbox.setChecked(False)
    
    def check_all_tbs(self):
        """Check all termbase checkboxes"""
        for checkbox in self.tb_checkboxes:
            checkbox.setChecked(True)
    
    def uncheck_all_tbs(self):
        """Uncheck all termbase checkboxes"""
        for checkbox in self.tb_checkboxes:
            checkbox.setChecked(False)
    
    def __del__(self):
        """Destructor - cleanup AHK process when widget is destroyed"""
        try:
            self.unregister_global_hotkey()
        except:
            pass
    
    def capture_text(self):
        """
        Capture text from the active application (triggered by global hotkey).
        """
        if not self.SuperlookupEngine:
            return
        
        # Initialize engine if needed
        if not self.engine:
            self.engine = self.SuperlookupEngine(mode='universal')
            
            # Set TM database if available
            if self.tm_database:
                self.engine.set_tm_database(self.tm_database)
        
        self.status_label.setText("‚è≥ Capturing text...")
        QApplication.processEvents()
        
        # Capture text
        text = self.engine.capture_text()
        
        if text:
            self.source_text.setCurrentText(text)
            self.status_label.setText(f"‚úì Captured {len(text)} characters. Searching...")
            # Auto-search after capture
            self.perform_lookup()
        else:
            self.status_label.setText("‚úó No text captured. Try again.")
    
    def perform_lookup(self):
        """Perform lookup on the source text.
        
        Uses Superlookup's OWN checkbox selections (independent from Resources tab).
        """
        # Write to file for reliable debugging
        with open('superlookup_debug.txt', 'a') as f:
            f.write(f"\n=== perform_lookup() CALLED at {__import__('datetime').datetime.now()} ===\n")
        print(f"[DEBUG] perform_lookup() CALLED!", flush=True)
        text = self.source_text.currentText().strip()
        print(f"[DEBUG] perform_lookup() text='{text[:50] if text else '(empty)'}...'", flush=True)
        
        if not text:
            self.status_label.setText("‚ö†Ô∏è No text to search. Enter or capture text first.")
            return
        
        # Add to search history
        self._add_to_search_history(text)
        
        # Always ensure we have the latest databases from main window
        if self.main_window:
            if hasattr(self.main_window, 'tm_database') and self.main_window.tm_database:
                self.tm_database = self.main_window.tm_database
            if hasattr(self.main_window, 'termbase_mgr') and self.main_window.termbase_mgr:
                self.termbase_mgr = self.main_window.termbase_mgr
            if hasattr(self.main_window, 'db_manager') and self.main_window.db_manager:
                self.db_manager = self.main_window.db_manager
        
        # Populate language dropdowns if not yet populated (fallback)
        if not self._languages_populated and self.db_manager:
            self.populate_language_dropdowns()
            self._languages_populated = True
        
        if not self.engine:
            # Initialize engine
            self.engine = SuperlookupEngine(mode='universal')
        
        # Always update the engine with current tm_database
        if self.tm_database and self.engine:
            self.engine.set_tm_database(self.tm_database)
        
        self.status_label.setText("üîç Searching...")
        QApplication.processEvents()
        
        # Set enabled TM IDs from Superlookup's own checkboxes (independent selection)
        selected_tm_ids = self.get_selected_tm_ids()
        search_direction = self.get_search_direction()
        from_lang, to_lang = self.get_language_filters()

        if self.engine:
            self.engine.set_enabled_tm_ids(selected_tm_ids if selected_tm_ids else None)
        
        # Perform TM lookup with direction and language filters
        tm_results = []
        if self.tm_database:
            tm_results = self.engine.search_tm(text, direction=search_direction,
                                                source_lang=from_lang, target_lang=to_lang)

        # Perform termbase lookup (search Supervertaler termbases directly)
        try:
            termbase_results = self.search_termbases(text, source_lang=from_lang, target_lang=to_lang)
        except Exception:
            termbase_results = []
        
        # Perform Supermemory semantic search
        supermemory_count = self.search_supermemory(text)
        
        # Perform MT lookup with selected providers
        mt_results = self._perform_mt_lookup(text, from_lang, to_lang)
        
        # Display results
        self.display_tm_results(tm_results)
        self.display_termbase_results(termbase_results)
        self.display_mt_results(mt_results)
        
        # Build detailed status message showing breakdown (full names for clarity)
        status_parts = []
        if tm_results:
            status_parts.append(f"TM: {len(tm_results)}")
        if termbase_results:
            status_parts.append(f"Termbase: {len(termbase_results)}")
        if supermemory_count:
            status_parts.append(f"Supermemory: {supermemory_count}")
        if mt_results:
            status_parts.append(f"MT: {len(mt_results)}")
        
        # Also trigger web resource searches
        if hasattr(self, 'web_browser_mode'):
            if self.web_browser_mode == 'embedded' and hasattr(self, 'web_engine_available') and self.web_engine_available:
                # Embedded mode - search all resources in background
                self._perform_web_search(search_all=True)
                status_parts.append("Web Resources")
            elif self.web_browser_mode == 'external':
                # External mode - open current selected resource in browser
                self._perform_web_search(search_all=False)
                status_parts.append("Web (external)")
        
        total_results = len(tm_results) + len(termbase_results) + (supermemory_count or 0) + len(mt_results)
        
        if status_parts:
            self.status_label.setText(f"‚úì Found {total_results} results ({', '.join(status_parts)})")
        else:
            self.status_label.setText("No results found")
    
    def search_with_query(self, query: str, switch_to_vertical: bool = True, 
                          source_lang: str = None, target_lang: str = None):
        """
        Public method to trigger a search from outside (e.g., from Ctrl+K).
        
        Args:
            query: Text to search for
            switch_to_vertical: If True, switches to vertical (list) view mode
            source_lang: Optional source language code to set
            target_lang: Optional target language code to set
        """
        # Set the query text (this is used by all tabs including Web Resources)
        self.source_text.setCurrentText(query)
        
        # Reset language dropdowns to "Any" (index 0) for unrestricted search by default
        # This ensures we always start with "From Any to Any"
        if hasattr(self, 'lang_from_combo'):
            self.lang_from_combo.setCurrentIndex(0)  # "Any"
        if hasattr(self, 'lang_to_combo'):
            self.lang_to_combo.setCurrentIndex(0)  # "Any"
        
        # Optionally switch to vertical view (traditional concordance layout)
        if switch_to_vertical and hasattr(self, 'tm_view_vertical_radio'):
            self.tm_view_vertical_radio.setChecked(True)
        
        # Switch to TM Matches tab
        if hasattr(self, 'results_tabs'):
            self.results_tabs.setCurrentIndex(0)  # TM Matches is first tab
        
        # Perform the lookup (TM, Termbase, Supermemory, MT)
        self.perform_lookup()
        
        # Pre-load all web resources in embedded mode
        if hasattr(self, 'web_browser_mode') and self.web_browser_mode == 'embedded':
            if hasattr(self, 'search_all_web_resources'):
                self.search_all_web_resources(query)
    
    def set_project_languages(self, source_lang: str = None, target_lang: str = None):
        """
        Set the language dropdowns to match the project's source and target languages.
        Called when a project is loaded to auto-configure Superlookup.
        
        Args:
            source_lang: Source language name or code (e.g., "Dutch", "nl")
            target_lang: Target language name or code (e.g., "English", "en")
        """
        # Make sure language dropdowns are populated first
        if not self._languages_populated:
            self.populate_language_dropdowns()
            self._languages_populated = True
        
        # Set the source language (From dropdown)
        if source_lang and hasattr(self, 'lang_from_combo'):
            self._set_language_combo(self.lang_from_combo, source_lang)
        
        # Set the target language (To dropdown)
        if target_lang and hasattr(self, 'lang_to_combo'):
            self._set_language_combo(self.lang_to_combo, target_lang)
        
        # Update web resources language info label if available
        if hasattr(self, '_on_language_changed'):
            self._on_language_changed()
    
    def _set_language_combo(self, combo, lang_code):
        """Set a language combo box to a specific language code"""
        if not combo or not lang_code:
            return
        
        # Try to find the language in the combo
        lang_lower = lang_code.lower()
        for i in range(combo.count()):
            item_data = combo.itemData(i)  # This is now a list of variants
            item_text = combo.itemText(i).lower()
            
            # Match by data (list of language variants) or text (display name)
            if item_data and isinstance(item_data, list):
                # Check if the lang_code matches any variant in the list
                if any(variant.lower() == lang_lower for variant in item_data):
                    combo.setCurrentIndex(i)
                    return
            elif item_data and isinstance(item_data, str) and item_data.lower() == lang_lower:
                # Legacy support for string data
                combo.setCurrentIndex(i)
                return
            if lang_lower in item_text:
                combo.setCurrentIndex(i)
                return
    
    def toggle_tm_view_mode(self, checked):
        """Toggle between horizontal (table) and vertical (list) view modes"""
        if self.tm_view_horizontal_radio.isChecked():
            self.tm_view_stack.setCurrentIndex(0)  # Horizontal/Table view
        else:
            self.tm_view_stack.setCurrentIndex(1)  # Vertical/List view
        
        # Re-display results if we have any stored
        if hasattr(self, '_current_tm_results') and self._current_tm_results:
            self.display_tm_results(self._current_tm_results)
    
    def display_tm_results(self, results):
        """Display TM results in both horizontal (table) and vertical (list) views"""
        # Store results for view toggling
        self._current_tm_results = results
        
        # Get search term for highlighting
        search_text = self.source_text.currentText().strip().lower()
        
        # Get language names from main window
        source_lang_name = "Dutch"
        target_lang_name = "English"
        if self.main_window:
            source_lang_name = getattr(self.main_window, 'source_language', 'Source')
            target_lang_name = getattr(self.main_window, 'target_language', 'Target')
        
        # === Update Horizontal View (Table) ===
        self.tm_results_table.setRowCount(0)
        
        for result in results:
            row = self.tm_results_table.rowCount()
            self.tm_results_table.insertRow(row)
            
            # Match percentage
            match_item = QTableWidgetItem(f"{result.match_percent}%")
            if result.match_percent == 100:
                match_item.setBackground(QColor("#C8E6C9"))  # Green for exact
            elif result.match_percent >= 95:
                match_item.setBackground(QColor("#FFF9C4"))  # Yellow for high
            self.tm_results_table.setItem(row, 0, match_item)
            
            # Source - store plain text in the item (for copy/selection) and show rich label
            source_item = QTableWidgetItem(result.source)
            source_item.setToolTip(result.source)
            self.tm_results_table.setItem(row, 1, source_item)

            # Source - with highlighted search term
            source_html = self._highlight_search_term(result.source, search_text)
            source_label = QLabel(source_html)
            source_label.setTextFormat(Qt.TextFormat.RichText)
            source_label.setWordWrap(True)
            source_label.setStyleSheet("padding: 2px 4px; background: transparent;")
            source_label.setToolTip(result.source)  # Full text on hover
            self.tm_results_table.setCellWidget(row, 1, source_label)
            
            # Target - store plain text in the item (for copy/selection) and show rich label
            target_item = QTableWidgetItem(result.target)
            target_item.setToolTip(result.target)
            self.tm_results_table.setItem(row, 2, target_item)

            # Target - with highlighted search term
            target_html = self._highlight_search_term(result.target, search_text)
            target_label = QLabel(target_html)
            target_label.setTextFormat(Qt.TextFormat.RichText)
            target_label.setWordWrap(True)
            target_label.setStyleSheet("padding: 2px 4px; background: transparent;")
            target_label.setToolTip(result.target)  # Full text on hover
            self.tm_results_table.setCellWidget(row, 2, target_label)
            
            # TM name
            tm_name = result.metadata.get('tm_name', 'Unknown')
            tm_item = QTableWidgetItem(tm_name)
            tm_item.setToolTip(tm_name)  # Full name on hover
            self.tm_results_table.setItem(row, 3, tm_item)
            
            # Type
            match_type = result.metadata.get('match_type', 'unknown')
            self.tm_results_table.setItem(row, 4, QTableWidgetItem(match_type))
        
        # Resize rows to fit content but with reasonable limits
        self.tm_results_table.resizeRowsToContents()
        for row in range(self.tm_results_table.rowCount()):
            if self.tm_results_table.rowHeight(row) > 60:
                self.tm_results_table.setRowHeight(row, 60)
        
        # === Update Vertical View (List) ===
        # Use theme colors for HTML content (with fallback for missing theme_manager)
        if self.theme_manager:
            theme = self.theme_manager.current_theme
            text_color = theme.text
            # Use darker backgrounds for TM results to improve readability
            bg_even = theme.window_bg  # Darker than base
            bg_odd = theme.alternate_bg
            border_color = theme.border
            source_label_color = theme.tm_source_label
            target_label_color = theme.tm_target_label
        else:
            # Fallback colors for light theme
            text_color = "#000000"
            bg_even = "#FFFFFF"
            bg_odd = "#EBEBEB"
            border_color = "#CCCCCC"
            source_label_color = "#0066CC"
            target_label_color = "#006600"

        html = f"<h3 style='color: {text_color}; margin-bottom: 15px;'>Found {len(results)} TM matches for '<span style='color: {source_label_color};'>{search_text}</span>'</h3>"

        for idx, result in enumerate(results, 1):
            source = result.source
            target = result.target
            tm_name = result.metadata.get('tm_name', 'Unknown')
            match_type = result.metadata.get('match_type', 'concordance')

            # Highlight search term
            highlighted_source = self._highlight_search_term(source, search_text)
            highlighted_target = self._highlight_search_term(target, search_text)

            # Alternating background colors from theme (using darker colors)
            bg_color = bg_even if idx % 2 == 0 else bg_odd

            html += f"""
            <div style='background-color: {bg_color}; padding: 10px 8px; margin: 0; color: {text_color};'>
                <div style='color: {text_color}; font-size: 11px; margin-bottom: 6px;'>
                    #{idx} - TM: <b>{tm_name}</b> - Type: {match_type}
                </div>
                <div style='margin-bottom: 4px; color: {text_color};'>
                    <b style='color: {source_label_color};'>{source_lang_name}:</b> {highlighted_source}
                </div>
                <div style='color: {text_color};'>
                    <b style='color: {target_label_color};'>{target_lang_name}:</b> {highlighted_target}
                </div>
            </div>
            <hr style='border: none; border-top: 1px solid {border_color}; margin: 0;'>
            """
        
        self.tm_results_vertical.setHtml(html)
    
    def _highlight_search_term(self, text, search_term):
        """Highlight search term in text with theme-aware background.

        Case-insensitive highlighting that preserves original case.
        """
        import re
        if not search_term or not text:
            return text

        # Escape HTML special characters first
        html_text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Use theme colors for highlight (with fallback for missing theme_manager)
        if self.theme_manager:
            theme = self.theme_manager.current_theme
            highlight_bg = theme.tm_highlight_bg
            highlight_text = theme.tm_highlight_text
        else:
            # Fallback colors - yellow highlight
            highlight_bg = "#FFFF00"
            highlight_text = "#000000"

        # Case-insensitive replacement with theme-aware highlight
        # Use regex to preserve original case
        pattern = re.compile(re.escape(search_term), re.IGNORECASE)
        highlighted = pattern.sub(
            lambda m: f'<span style="background-color: {highlight_bg}; color: {highlight_text}; padding: 1px 2px;">{m.group(0)}</span>',
            html_text
        )
        
        return highlighted
    
    def display_termbase_results(self, results):
        """Display termbase results with search term highlighting and metadata"""
        self.termbase_results_table.setRowCount(0)
        
        # Get search term for highlighting
        search_text = self.source_text.currentText().strip().lower()
        
        # Filter duplicates: if same source‚Üítarget exists in multiple glossaries,
        # only keep the one with highest priority (lowest number)
        filtered_results = []
        seen_pairs = {}  # (source_lower, target_lower) -> (result, priority)
        
        for result in results:
            source_lower = result.source.lower()
            target_lower = result.target.lower()
            pair_key = (source_lower, target_lower)
            
            # Get priority from metadata (default to 99 if not specified)
            metadata = result.metadata or {}
            priority = metadata.get('priority', 99)
            
            if pair_key in seen_pairs:
                # Duplicate found - keep only the higher priority (lower number)
                existing_result, existing_priority = seen_pairs[pair_key]
                if priority < existing_priority:
                    # This one has higher priority, replace the existing one
                    seen_pairs[pair_key] = (result, priority)
            else:
                # First occurrence of this pair
                seen_pairs[pair_key] = (result, priority)
        
        # Convert filtered dict back to list
        filtered_results = [result for result, priority in seen_pairs.values()]
        
        for result in filtered_results:
            row = self.termbase_results_table.rowCount()
            self.termbase_results_table.insertRow(row)
            
            # Get metadata
            metadata = result.metadata or {}
            termbase_name = metadata.get('termbase', '')
            domain = metadata.get('domain', '')
            notes = metadata.get('notes', '')
            
            # Source term - store plain text in the item (for copy/selection) and show rich label
            source_item = QTableWidgetItem(result.source)
            source_item.setToolTip(result.source)
            self.termbase_results_table.setItem(row, 0, source_item)

            # Source term - with highlighted search term
            source_html = self._highlight_search_term(result.source, search_text)
            source_label = QLabel(source_html)
            source_label.setTextFormat(Qt.TextFormat.RichText)
            source_label.setWordWrap(True)
            source_label.setStyleSheet("padding: 2px 4px; background: transparent;")
            source_label.setToolTip(result.source)  # Full text on hover
            self.termbase_results_table.setCellWidget(row, 0, source_label)
            
            # Target term - store plain text in the item (for copy/selection) and show rich label
            target_item = QTableWidgetItem(result.target)
            target_item.setToolTip(result.target)
            self.termbase_results_table.setItem(row, 1, target_item)

            # Target term - with highlighted search term
            target_html = self._highlight_search_term(result.target, search_text)
            target_label = QLabel(target_html)
            target_label.setTextFormat(Qt.TextFormat.RichText)
            target_label.setWordWrap(True)
            target_label.setStyleSheet("padding: 2px 4px; background: transparent;")
            target_label.setToolTip(result.target)  # Full text on hover
            self.termbase_results_table.setCellWidget(row, 1, target_label)
            
            # Termbase name
            tb_item = QTableWidgetItem(termbase_name)
            tb_item.setToolTip(termbase_name)
            self.termbase_results_table.setItem(row, 2, tb_item)
            
            # Domain
            domain_item = QTableWidgetItem(domain)
            domain_item.setToolTip(domain)
            self.termbase_results_table.setItem(row, 3, domain_item)
            
            # Notes (truncated display)
            notes_display = notes[:30] + '...' if len(notes) > 30 else notes
            notes_item = QTableWidgetItem(notes_display)
            notes_item.setToolTip(notes)  # Full notes on hover
            self.termbase_results_table.setItem(row, 4, notes_item)
            
            # Store metadata in first column item for right-click navigation
            source_label.setProperty('termbase_id', metadata.get('termbase_id'))
            source_label.setProperty('source_term', result.source)
            source_label.setProperty('termbase_name', termbase_name)
        
        # Resize rows to fit content with height cap
        self.termbase_results_table.resizeRowsToContents()
        for row in range(self.termbase_results_table.rowCount()):
            if self.termbase_results_table.rowHeight(row) > 50:
                self.termbase_results_table.setRowHeight(row, 50)
    
    def _show_termbase_result_context_menu(self, position):
        """Show context menu for termbase results with option to navigate to term"""
        # Get the row at click position
        row = self.termbase_results_table.rowAt(position.y())
        if row < 0:
            return
        
        # Get the source label widget which has the metadata
        source_widget = self.termbase_results_table.cellWidget(row, 0)
        if not source_widget:
            return
        
        termbase_id = source_widget.property('termbase_id')
        source_term = source_widget.property('source_term')
        termbase_name = source_widget.property('termbase_name')
        
        # Create context menu
        menu = QMenu(self.termbase_results_table)
        
        # Copy actions
        copy_target_action = menu.addAction("üìã Copy Translation")
        copy_source_action = menu.addAction("üìã Copy Source Term")
        
        menu.addSeparator()
        
        # Navigate to glossary action
        if termbase_id and termbase_name:
            edit_action = menu.addAction(f"‚úèÔ∏è Edit in Glossary: {termbase_name}")
            edit_action.setData({'termbase_id': termbase_id, 'source_term': source_term, 'termbase_name': termbase_name})
        else:
            edit_action = None
        
        # Show menu and handle selection
        action = menu.exec(self.termbase_results_table.mapToGlobal(position))
        
        if action == copy_target_action:
            self.copy_selected_termbase_target()
        elif action == copy_source_action:
            if source_term:
                QApplication.clipboard().setText(source_term)
                self.status_label.setText(f"Copied source term: {source_term}")
        elif action == edit_action and edit_action:
            data = action.data()
            self._navigate_to_termbase_entry(data['termbase_id'], data['source_term'])
    
    def _navigate_to_termbase_entry(self, termbase_id, source_term):
        """Navigate to a specific termbase entry in Project resources > Glossaries tab"""
        try:
            # Navigate to Project resources > Glossaries
            if hasattr(self, 'main_window') and self.main_window:
                main = self.main_window
                
                # Switch to Project resources tab (index 1)
                if hasattr(main, 'main_tabs'):
                    main.main_tabs.setCurrentIndex(1)
                
                # Switch to Glossaries sub-tab within Project resources
                if hasattr(main, 'resources_tabs'):
                    # Find the Glossaries tab index
                    for i in range(main.resources_tabs.count()):
                        if 'Glossar' in main.resources_tabs.tabText(i):
                            main.resources_tabs.setCurrentIndex(i)
                            break
                
                # Find and select the termbase in the list
                if hasattr(main, 'termbase_table'):
                    for row in range(main.termbase_table.rowCount()):
                        name_item = main.termbase_table.item(row, 1)  # Name column stores ID in UserRole
                        if name_item and name_item.data(Qt.ItemDataRole.UserRole) == termbase_id:
                            main.termbase_table.selectRow(row)
                            # Trigger loading of terms for this termbase
                            if hasattr(main, '_on_termbase_selected'):
                                main._on_termbase_selected()
                            break
                
                # Use the filter box to find the specific term (works with pagination)
                if hasattr(main, 'terms_search_box') and source_term:
                    from PyQt6.QtCore import QTimer
                    def set_filter_and_select():
                        # Set the filter to the source term - this will trigger server-side search
                        main.terms_search_box.setText(source_term)
                        # After filter is applied, select the first matching row
                        QTimer.singleShot(300, lambda: self._select_first_term_in_table(main))
                    QTimer.singleShot(200, set_filter_and_select)
                
                self.status_label.setText(f"Navigated to glossary entry: {source_term}")
            
        except Exception as e:
            print(f"[Superlookup] Error navigating to glossary: {e}")
            self.status_label.setText(f"Error navigating to glossary: {e}")
    
    def _select_first_term_in_table(self, main):
        """Select the first term in the filtered termbase terms table"""
        try:
            if hasattr(main, 'termbase_terms_table'):
                table = main.termbase_terms_table
                if table.rowCount() > 0:
                    table.selectRow(0)
                    item = table.item(0, 0)
                    if item:
                        table.scrollToItem(item)
        except Exception as e:
            print(f"[Superlookup] Error selecting term: {e}")

    def display_mt_results(self, results):
        """Display MT results in the table"""
        self.mt_results_table.setRowCount(0)
        
        if results:
            success_count = 0
            error_count = 0
            
            for result in results:
                row = self.mt_results_table.rowCount()
                self.mt_results_table.insertRow(row)
                
                # Check if this is an error result
                is_error = result.get('is_error', False) if isinstance(result, dict) else False
                
                # Provider name
                provider = result.get('provider', 'MT') if isinstance(result, dict) else getattr(result, 'provider', 'MT')
                provider_item = QTableWidgetItem(provider)
                if is_error:
                    provider_item.setForeground(QColor("#F44336"))  # Red for errors
                    error_count += 1
                else:
                    provider_item.setForeground(QColor("#1976d2"))  # Blue for success
                    success_count += 1
                self.mt_results_table.setItem(row, 0, provider_item)
                
                # Translation text (or error message)
                translation = result.get('translation', '') if isinstance(result, dict) else getattr(result, 'target', '')
                trans_item = QTableWidgetItem(translation)
                trans_item.setToolTip(translation)
                if is_error:
                    trans_item.setForeground(QColor("#F44336"))  # Red text for errors
                    trans_item.setFont(QFont(trans_item.font().family(), -1, -1, True))  # Italic
                self.mt_results_table.setItem(row, 1, trans_item)
                
                # Copy button (only for successful translations)
                if not is_error:
                    copy_btn = QPushButton("üìã")
                    copy_btn.setFixedSize(30, 24)
                    copy_btn.setToolTip("Copy translation")
                    copy_btn.clicked.connect(lambda checked, t=translation: self._copy_mt_result(t))
                    self.mt_results_table.setCellWidget(row, 2, copy_btn)
            
            # Update status with breakdown
            if error_count > 0:
                self.mt_status_label.setText(f"‚úì Got {success_count} translation(s), ‚ö† {error_count} error(s)")
                self.mt_status_label.setStyleSheet("color: #FF9800; font-weight: bold;")
            else:
                self.mt_status_label.setText(f"‚úì Got {success_count} translation(s)")
                self.mt_status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
        else:
            self.mt_status_label.setText("No MT results. Check provider settings.")
            self.mt_status_label.setStyleSheet("color: #666; font-style: italic;")
    
    def _copy_mt_result(self, text):
        """Copy MT result to clipboard"""
        import pyperclip
        pyperclip.copy(text)
        self.status_label.setText(f"‚úì Copied: {text[:50]}...")
    
    def on_mt_result_double_click(self, index):
        """Handle double-click on MT result to copy"""
        row = index.row()
        trans_item = self.mt_results_table.item(row, 1)
        if trans_item:
            self._copy_mt_result(trans_item.text())
    
    def on_tm_result_double_click(self, index):
        """Handle double-click on TM result"""
        self.copy_selected_tm_target()
    
    def copy_selected_tm_target(self):
        """Copy selected TM target to clipboard"""
        selected = self.tm_results_table.selectedItems()
        if selected:
            row = selected[0].row()
            target_item = self.tm_results_table.item(row, 2)
            if target_item:
                pyperclip.copy(target_item.text())
                self.status_label.setText(f"‚úì Copied to clipboard: {target_item.text()[:50]}...")
    
    def insert_selected_tm_target(self):
        """Insert selected TM target into active application"""
        selected = self.tm_results_table.selectedItems()
        if selected:
            row = selected[0].row()
            target_item = self.tm_results_table.item(row, 2)
            if target_item:
                pyperclip.copy(target_item.text())
                self.status_label.setText("‚úì Copied to clipboard. Press Ctrl+V to paste.")
                # Could auto-paste here if we wanted to be aggressive
                # pyautogui.hotkey('ctrl', 'v')
    
    def _init_search_history(self):
        """Initialize search history from file."""
        self.search_history = []
        self._search_history_file = None
        
        # Get user_data path from main window
        if self.main_window and hasattr(self.main_window, 'user_data_path'):
            from pathlib import Path
            user_data = Path(self.main_window.user_data_path)
            self._search_history_file = user_data / "superlookup_history.json"
            
            # Load existing history
            if self._search_history_file.exists():
                try:
                    import json
                    with open(self._search_history_file, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        self.search_history = data.get('searches', [])[:20]
                except Exception:
                    pass
    
    def _add_to_search_history(self, text: str):
        """Add a search term to history."""
        if not text or not text.strip():
            return
        
        text = text.strip()
        # Remove if exists, add to front
        if text in self.search_history:
            self.search_history.remove(text)
        self.search_history.insert(0, text)
        self.search_history = self.search_history[:20]  # Keep max 20
        
        # Update dropdown
        if hasattr(self, 'source_text') and hasattr(self.source_text, 'set_history'):
            self.source_text.set_history(self.search_history)
        
        # Save to file
        self._save_search_history()
    
    def _save_search_history(self):
        """Save search history to file."""
        if not self._search_history_file:
            return
        
        try:
            import json
            self._search_history_file.parent.mkdir(parents=True, exist_ok=True)
            with open(self._search_history_file, 'w', encoding='utf-8') as f:
                json.dump({'searches': self.search_history[:20]}, f, ensure_ascii=False, indent=2)
        except Exception:
            pass
    
    def clear_all(self):
        """Clear all text and results"""
        self.source_text.clear()
        self.tm_results_table.setRowCount(0)
        self.termbase_results_table.setRowCount(0)
        self.status_label.setText("Cleared. Ready for new lookup.")
    
    def _normalize_language_code(self, lang: str) -> str:
        """Normalize language code/name to a standard format for comparison.
        
        Converts both full names (English, Dutch) and ISO codes (en, nl)
        to lowercase ISO 2-letter codes for consistent matching.
        """
        if not lang:
            return ''
        
        lang_lower = lang.lower().strip()
        
        # Map full names to ISO codes
        name_to_code = {
            'english': 'en', 'dutch': 'nl', 'german': 'de', 'french': 'fr',
            'spanish': 'es', 'italian': 'it', 'portuguese': 'pt', 'russian': 'ru',
            'chinese': 'zh', 'japanese': 'ja', 'korean': 'ko', 'arabic': 'ar',
            'polish': 'pl', 'czech': 'cs', 'hungarian': 'hu', 'romanian': 'ro',
            'bulgarian': 'bg', 'greek': 'el', 'turkish': 'tr', 'swedish': 'sv',
            'danish': 'da', 'norwegian': 'no', 'finnish': 'fi', 'ukrainian': 'uk',
            'hebrew': 'he', 'thai': 'th', 'vietnamese': 'vi', 'indonesian': 'id',
            'malay': 'ms', 'hindi': 'hi', 'bengali': 'bn', 'tamil': 'ta',
            'catalan': 'ca', 'basque': 'eu', 'galician': 'gl', 'croatian': 'hr',
            'serbian': 'sr', 'slovenian': 'sl', 'slovak': 'sk', 'estonian': 'et',
            'latvian': 'lv', 'lithuanian': 'lt',
        }
        
        # If it's a full name, convert to code
        if lang_lower in name_to_code:
            return name_to_code[lang_lower]
        
        # If it's already an ISO code (2-3 chars), normalize it
        # Handle variants like en-US, nl-BE by taking the base code
        if '-' in lang_lower or '_' in lang_lower:
            base_code = lang_lower.replace('_', '-').split('-')[0]
            return base_code
        
        # Return as-is (already a code like 'en', 'nl')
        return lang_lower
    
    def search_termbases(self, text, source_lang = None, target_lang = None):
        """Search Supervertaler termbases for matching terms.
        
        Uses Superlookup's OWN checkbox selections (independent from Resources > Termbases).
        Respects the search direction setting (source only, target only, or both).
        
        Args:
            text: Text to search for
            source_lang: Filter by source language - can be a string OR a list of variants (None = any)
            target_lang: Filter by target language - can be a string OR a list of variants (None = any)
        """
        results = []
        
        # Normalize language filters to lists of normalized codes for consistent matching
        # Handle both single strings and lists of variants
        if source_lang:
            if isinstance(source_lang, list):
                source_langs_norm = [self._normalize_language_code(lang) for lang in source_lang if lang]
            else:
                source_langs_norm = [self._normalize_language_code(source_lang)]
        else:
            source_langs_norm = None
        
        if target_lang:
            if isinstance(target_lang, list):
                target_langs_norm = [self._normalize_language_code(lang) for lang in target_lang if lang]
            else:
                target_langs_norm = [self._normalize_language_code(target_lang)]
        else:
            target_langs_norm = None
        
        print(f"[DEBUG search_termbases] Called with text='{text[:30]}...', source_lang='{source_lang}' (norm: {source_langs_norm}), target_lang='{target_lang}' (norm: {target_langs_norm})", flush=True)
        print(f"[DEBUG search_termbases] termbase_mgr: {self.termbase_mgr is not None}, db_manager: {self.db_manager is not None}, main_window: {self.main_window is not None}", flush=True)
        
        if not self.termbase_mgr or not self.db_manager or not self.main_window:
            print(f"[DEBUG search_termbases] Early return - missing managers!", flush=True)
            return results
        
        try:
            # Get search direction
            direction = self.get_search_direction()
            
            # Get termbases selected in Superlookup's Settings tab (independent selection)
            selected_tb_ids = self.get_selected_termbase_ids()
            
            # If no termbases selected, search all available termbases
            all_termbases = self.termbase_mgr.get_all_termbases()
            
            if selected_tb_ids:
                # Filter to only selected termbases
                termbases_to_search = [tb for tb in all_termbases if tb['id'] in selected_tb_ids]
            else:
                # No selection = search all (as indicated by the tip in UI)
                termbases_to_search = all_termbases
            
            text_lower = text.lower()
            
            # Search each selected termbase
            for termbase in termbases_to_search:
                termbase_id = termbase['id']
                
                # Check termbase language filters - normalize for comparison
                tb_source_lang = termbase.get('source_lang', '')
                tb_target_lang = termbase.get('target_lang', '')
                tb_source_norm = self._normalize_language_code(tb_source_lang)
                tb_target_norm = self._normalize_language_code(tb_target_lang)
                
                print(f"[DEBUG search_termbases] Checking TB '{termbase['name']}': source='{tb_source_lang}' (norm: '{tb_source_norm}'), target='{tb_target_lang}' (norm: '{tb_target_norm}')")
                
                # Skip termbases that don't match language filters
                # Compare normalized codes - match if TB's language is in the list of variants
                if source_langs_norm and tb_source_norm:
                    if tb_source_norm not in source_langs_norm:
                        print(f"[DEBUG search_termbases] Skipping '{termbase['name']}' - source lang mismatch: '{tb_source_norm}' not in {source_langs_norm}")
                        continue
                if target_langs_norm and tb_target_norm:
                    if tb_target_norm not in target_langs_norm:
                        print(f"[DEBUG search_termbases] Skipping '{termbase['name']}' - target lang mismatch: '{tb_target_norm}' not in {target_langs_norm}")
                        continue
                
                print(f"[DEBUG search_termbases] Searching in '{termbase['name']}'")
                terms = self.termbase_mgr.get_terms(termbase_id)
                
                for term in terms:
                    source_term = term.get('source_term', '').lower()
                    target_term = term.get('target_term', '').lower()
                    target_term_original = term.get('target_term', '')
                    source_term_original = term.get('source_term', '')
                    
                    # Also check term-level language if available (normalize for comparison)
                    term_source_lang = term.get('source_lang', '')
                    term_target_lang = term.get('target_lang', '')
                    term_source_norm = self._normalize_language_code(term_source_lang) if term_source_lang else ''
                    term_target_norm = self._normalize_language_code(term_target_lang) if term_target_lang else ''
                    
                    # Check if term-level languages match any of the filter variants
                    if source_langs_norm and term_source_norm and term_source_norm not in source_langs_norm:
                        continue
                    if target_langs_norm and term_target_norm and term_target_norm not in target_langs_norm:
                        continue
                    
                    match_found = False
                    
                    # Minimum length for substring matching to avoid spurious single-char matches
                    # If search text is longer than 3 chars, require term to be at least 3 chars for substring match
                    min_term_len = 3 if len(text_lower) > 3 else 1
                    
                    # Check based on search direction
                    if direction == 'source':
                        # Search source only
                        if source_term and len(source_term) >= min_term_len:
                            if source_term in text_lower or text_lower in source_term:
                                match_found = True
                    elif direction == 'target':
                        # Search target only
                        if target_term and len(target_term) >= min_term_len:
                            if target_term in text_lower or text_lower in target_term:
                                match_found = True
                    else:
                        # Both directions (bidirectional)
                        if source_term and len(source_term) >= min_term_len:
                            if source_term in text_lower or text_lower in source_term:
                                match_found = True
                        if target_term and len(target_term) >= min_term_len:
                            if target_term in text_lower or text_lower in target_term:
                                match_found = True
                    
                    if match_found:
                        # Create LookupResult with full metadata
                        from modules.superlookup import LookupResult
                        results.append(LookupResult(
                            source=source_term_original,
                            target=target_term_original,
                            match_percent=100,
                            source_type='termbase',
                            metadata={
                                'termbase': termbase['name'],
                                'termbase_id': termbase_id,
                                'domain': term.get('domain', ''),
                                'notes': term.get('notes', ''),
                                'priority': term.get('priority', 50),
                                'project': term.get('project', ''),
                                'client': term.get('client', ''),
                                'forbidden': term.get('forbidden', False)
                            }
                        ))
            
            # Remove duplicates
            seen = set()
            unique_results = []
            for result in results:
                key = (result.source.lower(), result.target.lower())
                if key not in seen:
                    seen.add(key)
                    unique_results.append(result)
            
            return unique_results
            
        except Exception as e:
            if hasattr(self.main_window, 'log'):
                self.main_window.log(f"‚úó Error searching termbases: {e}")
            return results
    
    def copy_selected_termbase_target(self):
        """Copy selected termbase translation to clipboard"""
        selected = self.termbase_results_table.selectedItems()
        if selected:
            row = selected[0].row()
            target_item = self.termbase_results_table.item(row, 1)
            if target_item:
                pyperclip.copy(target_item.text())
                self.status_label.setText(f"‚úì Copied to clipboard: {target_item.text()[:50]}...")
    
    def add_to_termbase(self):
        """Add source text and selected translation as new term to termbase"""
        # Get source text
        source_text = self.source_text.currentText().strip()
        if not source_text:
            QMessageBox.warning(self, "No Source Text", "Please enter or capture source text first.")
            return
        
        # Get selected termbase result if any
        selected = self.termbase_results_table.selectedItems()
        target_text = ""
        if selected:
            row = selected[0].row()
            target_item = self.termbase_results_table.item(row, 1)
            if target_item:
                target_text = target_item.text()
        
        if not self.termbase_mgr or not self.db_manager or not self.main_window:
            QMessageBox.warning(self, "Database Not Available", "Glossary database is not initialized.")
            return
        
        # Show dialog to add term
        self.show_add_term_dialog(source_text, target_text)
    
    def show_add_term_dialog(self, source_text, target_text=""):
        """Show dialog to add new term to glossary"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Add Term to Glossary")
        dialog.setMinimumWidth(500)
        
        layout = QVBoxLayout(dialog)
        
        # Source term
        layout.addWidget(QLabel("Source Term:"))
        source_edit = QLineEdit(source_text)
        layout.addWidget(source_edit)
        
        # Target term
        layout.addWidget(QLabel("Target Translation:"))
        target_edit = QLineEdit(target_text)
        layout.addWidget(target_edit)
        
        # Glossary selection
        layout.addWidget(QLabel("Select Glossary:"))
        termbase_combo = QComboBox()
        
        # Get writable termbases
        try:
            project_id = None
            if hasattr(self.main_window, 'current_project') and self.main_window.current_project:
                project_id = self.main_window.current_project.id if hasattr(self.main_window.current_project, 'id') else None
            
            all_termbases = self.termbase_mgr.get_all_termbases()
            writable_termbases = [tb for tb in all_termbases if not tb.get('read_only', True)]
            
            if not writable_termbases:
                QMessageBox.warning(self, "No Writable Glossaries", 
                    "No writable glossaries found. Please enable Write for at least one glossary in Resources ‚Üí Glossaries.")
                return
            
            for tb in writable_termbases:
                termbase_combo.addItem(tb['name'], tb['id'])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not load glossaries: {e}")
            return
        
        layout.addWidget(termbase_combo)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(dialog.reject)
        button_layout.addWidget(cancel_btn)
        
        add_btn = QPushButton("Add Term")
        add_btn.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; padding: 8px; border: none; outline: none;")
        add_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(add_btn)
        
        layout.addLayout(button_layout)
        
        # Show dialog
        if dialog.exec() == QDialog.DialogCode.Accepted:
            source = source_edit.text().strip()
            target = target_edit.text().strip()
            termbase_id = termbase_combo.currentData()
            
            if not source or not target:
                QMessageBox.warning(self, "Missing Information", "Both source and target terms are required.")
                return
            
            # Add term to termbase
            try:
                term_id = self.termbase_mgr.add_term(
                    termbase_id=termbase_id,
                    source_term=source,
                    target_term=target,
                    domain="",
                    notes=f"Added via Superlookup",
                    project="",
                    client=""
                )
                
                if term_id is None:
                    # Duplicate detected
                    if hasattr(self.main_window, '_play_sound_effect'):
                        self.main_window._play_sound_effect('glossary_term_duplicate')

                    try:
                        if hasattr(self.main_window, 'statusBar') and self.main_window.statusBar():
                            self.main_window.statusBar().showMessage("‚ö† Duplicate glossary entry (not added)", 3500)
                    except Exception:
                        pass

                    QMessageBox.warning(self, "Duplicate Term", 
                        f"This term already exists in {termbase_combo.currentText()}:\n\n{source} ‚Üí {target}\n\nDuplicate terms are not allowed.")
                    return
                
                if hasattr(self.main_window, 'log'):
                    self.main_window.log(f"‚úì Added term to {termbase_combo.currentText()}: {source} ‚Üí {target}")

                if hasattr(self.main_window, '_play_sound_effect'):
                    self.main_window._play_sound_effect('glossary_term_added')

                try:
                    if hasattr(self.main_window, 'statusBar') and self.main_window.statusBar():
                        self.main_window.statusBar().showMessage(
                            f"‚úì Added glossary entry: {source} ‚Üí {target} (to {termbase_combo.currentText()})",
                            3500,
                        )
                except Exception:
                    pass
                
                QMessageBox.information(self, "Term Added", 
                    f"Successfully added term:\n\n{source} ‚Üí {target}\n\nto glossary: {termbase_combo.currentText()}")
                
                # Refresh termbase results
                self.perform_lookup()
                
            except Exception as e:
                if hasattr(self.main_window, '_play_sound_effect'):
                    self.main_window._play_sound_effect('glossary_term_error')

                try:
                    if hasattr(self.main_window, 'statusBar') and self.main_window.statusBar():
                        self.main_window.statusBar().showMessage("‚ùå Error adding glossary entry (see log)", 3500)
                except Exception:
                    pass

                QMessageBox.critical(self, "Error", f"Failed to add term:\n{str(e)}")
    
    def set_tm_database(self, tm_db):
        """Set TM database (called from main window)"""
        self.tm_database = tm_db
        if self.engine:
            self.engine.set_tm_database(tm_db)
    
    def _find_autohotkey_executable(self):
        """Find AutoHotkey executable, checking saved path first
        
        Returns tuple: (exe_path, source) where source is 'saved', 'detected', or None
        """
        # First, check if user has a saved custom path
        if self.main_window and hasattr(self.main_window, 'general_settings'):
            saved_path = self.main_window.general_settings.get('autohotkey_path', '')
            if saved_path and os.path.exists(saved_path):
                print(f"[Superlookup] Using saved AutoHotkey path: {saved_path}")
                return saved_path, 'saved'
        
        # Standard installation paths
        username = os.environ.get('USERNAME', '')
        ahk_paths = [
            r"C:\Program Files\AutoHotkey\v2\AutoHotkey.exe",
            r"C:\Program Files\AutoHotkey\v2\AutoHotkey64.exe",
            r"C:\Program Files\AutoHotkey\AutoHotkey.exe",
            r"C:\Program Files (x86)\AutoHotkey\AutoHotkey.exe",
            fr"C:\Users\{username}\AppData\Local\Programs\AutoHotkey\AutoHotkey.exe",
            # v1 paths
            r"C:\Program Files\AutoHotkey\v1.1\AutoHotkeyU64.exe",
            r"C:\Program Files\AutoHotkey\v1.1\AutoHotkeyU32.exe",
        ]
        
        for path in ahk_paths:
            if os.path.exists(path):
                print(f"[Superlookup] Detected AutoHotkey at: {path}")
                return path, 'detected'
        
        return None, None
    
    def _show_autohotkey_setup_dialog(self):
        """Show dialog to help user install or locate AutoHotkey"""
        dialog = QDialog(self)
        dialog.setWindowTitle("AutoHotkey Setup - Superlookup")
        dialog.setMinimumWidth(500)
        
        layout = QVBoxLayout(dialog)
        
        # Header
        header = QLabel("‚å®Ô∏è AutoHotkey Required for Global Hotkey")
        header.setStyleSheet("font-size: 14px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(header)
        
        # Explanation
        explanation = QLabel(
            "Superlookup uses AutoHotkey to provide a global hotkey (Ctrl+Alt+L) "
            "that works from any application.\n\n"
            "Without AutoHotkey, Superlookup will still work, but only when "
            "Supervertaler is the active window."
        )
        explanation.setWordWrap(True)
        explanation.setStyleSheet("margin-bottom: 15px;")
        layout.addWidget(explanation)
        
        # Options group
        options_group = QGroupBox("Choose an option:")
        options_layout = QVBoxLayout(options_group)
        
        # Option 1: Download AutoHotkey
        download_btn = QPushButton("üì• Download AutoHotkey (Recommended)")
        download_btn.setStyleSheet("padding: 8px; font-size: 11px;")
        download_btn.setToolTip("Opens the AutoHotkey download page in your browser")
        download_btn.clicked.connect(lambda: self._open_ahk_download())
        options_layout.addWidget(download_btn)
        
        # Option 2: Browse for existing installation
        browse_layout = QHBoxLayout()
        browse_btn = QPushButton("üìÅ Browse for AutoHotkey.exe")
        browse_btn.setStyleSheet("padding: 8px; font-size: 11px;")
        browse_btn.setToolTip("Locate AutoHotkey.exe if you have it installed in a custom location")
        browse_btn.clicked.connect(lambda: self._browse_for_autohotkey(dialog))
        browse_layout.addWidget(browse_btn)
        options_layout.addLayout(browse_layout)
        
        # Option 3: Skip
        skip_btn = QPushButton("‚è≠Ô∏è Skip (Use Superlookup without global hotkey)")
        skip_btn.setStyleSheet("padding: 8px; font-size: 11px; color: #666;")
        skip_btn.clicked.connect(dialog.reject)
        options_layout.addWidget(skip_btn)
        
        layout.addWidget(options_group)
        
        # Status label (for showing selected path)
        self._ahk_setup_status = QLabel("")
        self._ahk_setup_status.setStyleSheet("color: green; margin-top: 10px;")
        self._ahk_setup_status.setWordWrap(True)
        layout.addWidget(self._ahk_setup_status)
        
        # Note about restart
        note = QLabel(
            "üí° Note: After installing AutoHotkey, restart Supervertaler to enable the global hotkey."
        )
        note.setStyleSheet("color: #666; font-size: 10px; margin-top: 15px;")
        note.setWordWrap(True)
        layout.addWidget(note)
        
        # Don't show again checkbox
        dont_show_cb = CheckmarkCheckBox("Do not show this dialog again")
        dont_show_cb.setStyleSheet("margin-top: 10px;")
        layout.addWidget(dont_show_cb)
        
        # Close button
        close_btn = QPushButton("Close")
        def on_close():
            # Save preference if checkbox is checked
            if dont_show_cb.isChecked():
                if self.main_window and hasattr(self.main_window, 'general_settings'):
                    self.main_window.general_settings['hide_autohotkey_dialog'] = True
                    self.main_window.save_general_settings()
            dialog.accept()
        close_btn.clicked.connect(on_close)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def _open_ahk_download(self):
        """Open AutoHotkey download page"""
        import webbrowser
        webbrowser.open("https://www.autohotkey.com/download/")
        QMessageBox.information(
            self,
            "Download AutoHotkey",
            "The AutoHotkey download page has been opened in your browser.\n\n"
            "Download and install AutoHotkey v2.x, then restart Supervertaler."
        )
    
    def _browse_for_autohotkey(self, parent_dialog):
        """Let user browse for AutoHotkey executable"""
        file_path, _ = QFileDialog.getOpenFileName(
            parent_dialog,
            "Locate AutoHotkey Executable",
            "C:\\Program Files",
            "Executable Files (*.exe);;All Files (*.*)"
        )
        
        if file_path:
            # Verify it looks like AutoHotkey
            if 'autohotkey' not in file_path.lower():
                result = QMessageBox.question(
                    parent_dialog,
                    "Confirm Selection",
                    f"The selected file doesn't appear to be AutoHotkey:\n{file_path}\n\n"
                    "Are you sure you want to use this file?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                )
                if result != QMessageBox.StandardButton.Yes:
                    return
            
            # Save the path
            if self.main_window and hasattr(self.main_window, 'general_settings'):
                self.main_window.general_settings['autohotkey_path'] = file_path
                self.main_window.save_general_settings()
                print(f"[Superlookup] Saved AutoHotkey path: {file_path}")
            
            self._ahk_setup_status.setText(f"‚úì Saved: {file_path}\n\nRestart Supervertaler to use this path.")
            
            QMessageBox.information(
                parent_dialog,
                "Path Saved",
                f"AutoHotkey path saved:\n{file_path}\n\n"
                "Please restart Supervertaler to enable the global hotkey."
            )
    
    def register_global_hotkey(self):
        """Register global hotkey for Superlookup
        
        Uses external AHK script + signal file method (most reliable).
        The ahk library method is available but disabled by default due to
        callback threading issues.
        
        Note: AutoHotkey is Windows-only, so skip on Linux/Mac.
        """
        global _ahk_process
        print("[Superlookup] register_global_hotkey called")
        
        # AutoHotkey is Windows-only - skip on other platforms
        if sys.platform != 'win32':
            print("[Superlookup] Skipping AutoHotkey registration (not Windows)")
            self.hotkey_registered = False
            return
        
        # Use external script method (most reliable, proven to work)
        self._register_hotkey_external_script()
    
    def _try_ahk_library_method(self):
        """Try to register hotkey using ahk Python library
        
        Returns True if successful, False otherwise
        """
        try:
            from ahk import AHK
            print("[Superlookup] ahk library available, attempting to use it...")
            
            # Find AutoHotkey executable using shared function
            ahk_exe, source = self._find_autohotkey_executable()
            
            # Create AHK instance (with executable path if found)
            if ahk_exe:
                print(f"[Superlookup] Using AutoHotkey at: {ahk_exe} (source: {source})")
                self._ahk = AHK(executable_path=ahk_exe)
            else:
                # Let it try to find AHK on PATH (may fail)
                self._ahk = AHK()
            print(f"[Superlookup] AHK instance created: {self._ahk}")
            
            # Define hotkey callback
            def on_hotkey():
                """Called when Ctrl+Alt+L is pressed"""
                print("[Superlookup] Hotkey triggered via ahk library!")
                try:
                    # Copy selection to clipboard
                    self._ahk.send('^c')  # Ctrl+C
                    time.sleep(0.2)  # Give clipboard time to update
                    
                    # Get clipboard text
                    text = pyperclip.paste()
                    
                    # Activate Supervertaler window
                    try:
                        self._ahk.win_activate('Supervertaler')
                    except Exception as e:
                        print(f"[Superlookup] win_activate error (non-critical): {e}")
                    
                    # Trigger lookup in main thread
                    if text:
                        # Use QTimer to call from main thread
                        QTimer.singleShot(0, lambda: self.on_ahk_capture(text))
                        
                except Exception as e:
                    print(f"[Superlookup] Error in hotkey callback: {e}")
            
            # Register the hotkey
            self._ahk.add_hotkey('^!l', callback=on_hotkey)  # Ctrl+Alt+L
            self._ahk.start_hotkeys()
            
            print("[Superlookup] ‚úì Hotkey registered via ahk library: Ctrl+Alt+L")
            self.hotkey_registered = True
            self._using_ahk_library = True
            return True
            
        except ImportError:
            print("[Superlookup] ahk library not installed (pip install ahk)")
            return False
        except Exception as e:
            print(f"[Superlookup] ahk library method failed: {e}")
            # Clean up on failure
            if hasattr(self, '_ahk'):
                try:
                    self._ahk.stop_hotkeys()
                except:
                    pass
                self._ahk = None
            return False
    
    def _register_hotkey_external_script(self):
        """Register hotkey using external AHK script (fallback method)"""
        global _ahk_process
        self._using_ahk_library = False
        try:
            # Kill any existing instances of the AHK script first
            if os.name == 'nt':
                try:
                    # Use multiple methods to ensure cleanup
                    # Method 1: Kill by window title
                    subprocess.run(['taskkill', '/F', '/FI', 'WINDOWTITLE eq supervertaler_hotkeys.ahk*'],
                                 capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
                    
                    # Method 2: Kill AutoHotkey processes more aggressively
                    subprocess.run(['taskkill', '/F', '/IM', 'AutoHotkey.exe'],
                                 capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
                    
                    # Method 3: Kill by process name pattern
                    import psutil
                    try:
                        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                            try:
                                if 'supervertaler_hotkeys' in ' '.join(proc.cmdline() or []):
                                    proc.kill()
                            except:
                                pass
                    except:
                        pass
                except:
                    pass
            
            # Find AutoHotkey executable using shared function
            ahk_exe, source = self._find_autohotkey_executable()
            
            if not ahk_exe:
                print("[Hotkeys] AutoHotkey not found.")
                print("[Hotkeys] Global hotkeys (Ctrl+Alt+L, Shift+Shift) will not be available.")
                self.hotkey_registered = False
                # Show setup dialog (deferred to avoid blocking startup) - unless user opted out
                if self.main_window and hasattr(self.main_window, 'general_settings'):
                    if not self.main_window.general_settings.get('hide_autohotkey_dialog', False):
                        QTimer.singleShot(2000, self._show_autohotkey_setup_dialog)
                else:
                    QTimer.singleShot(2000, self._show_autohotkey_setup_dialog)
                return
            
            print(f"[Hotkeys] Found AutoHotkey at: {ahk_exe} (source: {source})")
            
            ahk_script = Path(__file__).parent / "supervertaler_hotkeys.ahk"
            print(f"[Hotkeys] Looking for script at: {ahk_script}")
            print(f"[Hotkeys] Script exists: {ahk_script.exists()}")
            
            if ahk_script.exists():
                # Start AHK script in background (hidden)
                self.ahk_process = subprocess.Popen([ahk_exe, str(ahk_script)],
                                                   creationflags=subprocess.CREATE_NO_WINDOW if os.name == 'nt' else 0)
                # Store in global variable for atexit cleanup
                _ahk_process = self.ahk_process
                print(f"[Hotkeys] AHK hotkeys registered (Ctrl+Alt+L, Shift+Shift)")
                
                # Start file watcher
                self.start_file_watcher()
                self.hotkey_registered = True
            else:
                print(f"[Hotkeys] AHK script not found: {ahk_script}")
                self.hotkey_registered = False
        except Exception as e:
            print(f"[Hotkeys] Could not start AHK hotkeys: {e}")
            self.hotkey_registered = False
    
    def start_file_watcher(self):
        """Watch for signal file from AHK"""
        self.signal_file = Path(__file__).parent / "lookup_signal.txt"
        self.capture_file = Path(__file__).parent / "temp_capture.txt"
        
        print(f"[Superlookup] File watcher started, watching: {self.signal_file}")
        
        # Create timer to check for signal file
        self.file_check_timer = QTimer()
        self.file_check_timer.timeout.connect(self.check_for_signal)
        self.file_check_timer.start(100)  # Check every 100ms
    
    def check_for_signal(self):
        """Check if AHK wrote a signal file"""
        if self.signal_file.exists():
            print(f"[Superlookup] Signal file detected!")
            try:
                # Delete signal file
                self.signal_file.unlink()
                print(f"[Superlookup] Signal file deleted")
                
                # Get text from clipboard (AHK already copied it)
                time.sleep(0.1)  # Give clipboard a moment
                text = pyperclip.paste()
                
                # Trigger lookup
                if text:
                    self.on_ahk_capture(text)
            except Exception as e:
                print(f"[Superlookup] Error reading capture: {e}")
    
    def on_ahk_capture(self, text):
        """Handle text captured by AHK"""
        try:
            print(f"[Superlookup] on_ahk_capture called with text: {text[:50]}...")
            
            # Bring Supervertaler to foreground
            main_window = self.window()
            if main_window:
                # Check if window was maximized before restoring
                was_maximized = main_window.isMaximized()
                
                # Restore if minimized or hidden
                if main_window.isMinimized():
                    main_window.showNormal()
                elif main_window.isHidden():
                    main_window.show()
                else:
                    # If already visible, just activate
                    main_window.show()
                
                # Restore maximized state if it was maximized
                if was_maximized:
                    main_window.showMaximized()
                    
                # Bring to front and activate
                main_window.raise_()
                main_window.activateWindow()
                
            # Longer delay to allow all window focus events to settle
            # Window activation triggers focus restoration which takes time
            QTimer.singleShot(250, lambda: self.show_superlookup(text))
            
        except Exception as e:
            print(f"[Superlookup] Error handling capture: {e}")
    
    def show_superlookup(self, text):
        """Show Superlookup with pre-filled text"""
        try:
            print(f"[Superlookup] show_superlookup called with text: {text[:50]}...")
            
            # Get main window reference
            main_window = self.main_window
            if not main_window:
                main_window = self.window()
            
            print(f"[Superlookup] Main window found: {main_window is not None}")
            print(f"[Superlookup] Main window type: {type(main_window).__name__}")
            print(f"[Superlookup] Has main_tabs: {hasattr(main_window, 'main_tabs')}")
            
            # Switch to Tools tab (main_tabs index 3)
            # Tab structure: Grid=0, Resources=1, QuickMenu=2, Tools=3, Settings=4
            if hasattr(main_window, 'main_tabs'):
                print(f"[Superlookup] Current main_tab index: {main_window.main_tabs.currentIndex()}")
                main_window.main_tabs.setCurrentIndex(3)  # Tools tab
                print(f"[Superlookup] Switched to Tools tab (index 2)")
                QApplication.processEvents()  # Force GUI update
            else:
                print(f"[Superlookup] WARNING: Main window has no main_tabs attribute!")
            
            # Switch to Superlookup within modules_tabs
            if hasattr(main_window, 'modules_tabs'):
                print(f"[Superlookup] Current modules_tab index: {main_window.modules_tabs.currentIndex()}")
                for i in range(main_window.modules_tabs.count()):
                    if "Superlookup" in main_window.modules_tabs.tabText(i):
                        main_window.modules_tabs.setCurrentIndex(i)
                        print(f"[Superlookup] Switched to Superlookup tab (index {i})")
                        QApplication.processEvents()  # Force GUI update
                        break
            
            # Delay text input and lookup to ensure tab is fully loaded
            QTimer.singleShot(100, lambda: self._fill_and_search(text))
                    
        except Exception as e:
            print(f"[Superlookup] Error showing lookup: {e}")
    
    def _fill_and_search(self, text):
        """Fill in text and trigger search (called after tab switching completes)"""
        try:
            print(f"[Superlookup] _fill_and_search called")
            # Fill in text and trigger lookup
            if hasattr(self, 'source_text'):
                self.source_text.setCurrentText(text)
                print(f"[Superlookup] Text filled in source_text field")
                # Trigger lookup by calling perform_lookup directly
                self.perform_lookup()
                print(f"[Superlookup] perform_lookup() called")
            else:
                print(f"[Superlookup] ERROR: source_text widget not found!")
        except Exception as e:
            print(f"[Superlookup] Error in _fill_and_search: {e}")
            import traceback
            traceback.print_exc()




# ============================================================================
# AUTOFINGERS DIALOG
# ============================================================================

class CheckmarkCheckBox(QCheckBox):
    """Custom checkbox with green background and white checkmark when checked"""
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setEnabled(True)
        self.setStyleSheet("""
            QCheckBox {
                font-size: 9pt;
                spacing: 6px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid #999;
                border-radius: 3px;
                background-color: white;
            }
            QCheckBox::indicator:checked {
                background-color: #4CAF50;
                border-color: #4CAF50;
            }
            QCheckBox::indicator:hover {
                border-color: #666;
            }
            QCheckBox::indicator:checked:hover {
                background-color: #45a049;
                border-color: #45a049;
            }
        """)
    
    def paintEvent(self, event):
        """Override paint event to draw white checkmark when checked"""
        super().paintEvent(event)
        
        if self.isChecked():
            # Get the indicator rectangle using QStyle
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QPen, QColor
            from PyQt6.QtCore import QPointF, QRect
            
            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_CheckBoxIndicator,
                opt,
                self
            )
            
            if indicator_rect.isValid():
                # Draw white checkmark
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                pen_width = max(2.0, min(indicator_rect.width(), indicator_rect.height()) * 0.12)
                painter.setPen(QPen(QColor(255, 255, 255), pen_width, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin))
                painter.setBrush(QColor(255, 255, 255))
                
                # Draw checkmark (‚úì shape) - coordinates relative to indicator
                x = indicator_rect.x()
                y = indicator_rect.y()
                w = indicator_rect.width()
                h = indicator_rect.height()
                
                # Add padding (15% on all sides)
                padding = min(w, h) * 0.15
                x += padding
                y += padding
                w -= padding * 2
                h -= padding * 2
                
                # Checkmark path
                check_x1 = x + w * 0.10
                check_y1 = y + h * 0.50
                check_x2 = x + w * 0.35
                check_y2 = y + h * 0.70
                check_x3 = x + w * 0.90
                check_y3 = y + h * 0.25
                
                # Draw two lines forming the checkmark
                painter.drawLine(QPointF(check_x2, check_y2), QPointF(check_x3, check_y3))
                painter.drawLine(QPointF(check_x1, check_y1), QPointF(check_x2, check_y2))
                
                painter.end()


class PinkCheckmarkCheckBox(QCheckBox):
    """Custom checkbox with pink background and white checkmark when checked (for project termbases)"""
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setEnabled(True)
        self.setStyleSheet("""
            QCheckBox {
                font-size: 9pt;
                spacing: 6px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid #999;
                border-radius: 3px;
                background-color: white;
            }
            QCheckBox::indicator:checked {
                background-color: #FFB6C1;
                border-color: #FFB6C1;
            }
            QCheckBox::indicator:hover {
                border-color: #666;
            }
            QCheckBox::indicator:checked:hover {
                background-color: #FF99AD;
                border-color: #FF99AD;
            }
        """)
    
    def paintEvent(self, event):
        """Override paint event to draw white checkmark when checked"""
        super().paintEvent(event)
        
        if self.isChecked():
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QPen, QColor
            from PyQt6.QtCore import QPointF
            
            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_CheckBoxIndicator,
                opt,
                self
            )
            
            if indicator_rect.isValid():
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                pen_width = max(2.0, min(indicator_rect.width(), indicator_rect.height()) * 0.12)
                painter.setPen(QPen(QColor(255, 255, 255), pen_width, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin))
                painter.setBrush(QColor(255, 255, 255))
                
                x = indicator_rect.x()
                y = indicator_rect.y()
                w = indicator_rect.width()
                h = indicator_rect.height()
                
                padding = min(w, h) * 0.15
                x += padding
                y += padding
                w -= padding * 2
                h -= padding * 2
                
                check_x1 = x + w * 0.10
                check_y1 = y + h * 0.50
                check_x2 = x + w * 0.35
                check_y2 = y + h * 0.70
                check_x3 = x + w * 0.90
                check_y3 = y + h * 0.25
                
                painter.drawLine(QPointF(check_x2, check_y2), QPointF(check_x3, check_y3))
                painter.drawLine(QPointF(check_x1, check_y1), QPointF(check_x2, check_y2))
                
                painter.end()


class CheckmarkRadioButton(QRadioButton):
    """Custom radio button with green background when checked"""
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setStyleSheet("""
            QRadioButton {
                font-size: 9pt;
                spacing: 6px;
            }
            QRadioButton::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid #999;
                border-radius: 9px;
                background-color: white;
            }
            QRadioButton::indicator:checked {
                background-color: #4CAF50;
                border-color: #4CAF50;
            }
            QRadioButton::indicator:hover {
                border-color: #666;
            }
            QRadioButton::indicator:checked:hover {
                background-color: #45a049;
                border-color: #45a049;
            }
        """)
    
    def paintEvent(self, event):
        """Override paint event to draw white dot when checked"""
        super().paintEvent(event)
        
        if self.isChecked():
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QBrush, QColor
            from PyQt6.QtCore import Qt, QPointF
            
            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_RadioButtonIndicator,
                opt,
                self
            )
            
            if indicator_rect.isValid():
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                painter.setBrush(QBrush(QColor("white")))
                painter.setPen(Qt.PenStyle.NoPen)
                
                # Draw white dot in center
                center = indicator_rect.center()
                center_pt = QPointF(center.x(), center.y())
                
                # Dot size: 25% of width radius (50% diameter)
                radius = indicator_rect.width() * 0.25
                
                painter.drawEllipse(center_pt, radius, radius)
                painter.end()


class BlueCheckmarkCheckBox(QCheckBox):
    """Custom checkbox with blue background and white checkmark when checked (for global/background termbases)"""
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setEnabled(True)
        self.setStyleSheet("""
            QCheckBox {
                font-size: 9pt;
                spacing: 6px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid #999;
                border-radius: 3px;
                background-color: white;
            }
            QCheckBox::indicator:checked {
                background-color: #4d94ff;
                border-color: #4d94ff;
            }
            QCheckBox::indicator:hover {
                border-color: #666;
            }
            QCheckBox::indicator:checked:hover {
                background-color: #3d7dd9;
                border-color: #3d7dd9;
            }
        """)
    
    def paintEvent(self, event):
        """Override paint event to draw white checkmark when checked"""
        super().paintEvent(event)
        
        if self.isChecked():
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QPen, QColor
            from PyQt6.QtCore import QPointF
            
            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_CheckBoxIndicator,
                opt,
                self
            )
            
            if indicator_rect.isValid():
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                pen_width = max(2.0, min(indicator_rect.width(), indicator_rect.height()) * 0.12)
                painter.setPen(QPen(QColor(255, 255, 255), pen_width, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin))
                painter.setBrush(QColor(255, 255, 255))
                
                x = indicator_rect.x()
                y = indicator_rect.y()
                w = indicator_rect.width()
                h = indicator_rect.height()
                
                padding = min(w, h) * 0.15
                x += padding
                y += padding
                w -= padding * 2
                h -= padding * 2
                
                check_x1 = x + w * 0.10
                check_y1 = y + h * 0.50
                check_x2 = x + w * 0.35
                check_y2 = y + h * 0.70
                check_x3 = x + w * 0.90
                check_y3 = y + h * 0.25
                
                painter.drawLine(QPointF(check_x2, check_y2), QPointF(check_x3, check_y3))
                painter.drawLine(QPointF(check_x1, check_y1), QPointF(check_x2, check_y2))

                painter.end()


class OrangeCheckmarkCheckBox(QCheckBox):
    """Custom checkbox with orange background and white checkmark when checked (for AI injection)"""

    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setEnabled(True)
        self.setStyleSheet("""
            QCheckBox {
                font-size: 9pt;
                spacing: 6px;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border: 2px solid #999;
                border-radius: 3px;
                background-color: white;
            }
            QCheckBox::indicator:checked {
                background-color: #FF9800;
                border-color: #FF9800;
            }
            QCheckBox::indicator:hover {
                border-color: #666;
            }
            QCheckBox::indicator:checked:hover {
                background-color: #F57C00;
                border-color: #F57C00;
            }
        """)

    def paintEvent(self, event):
        """Override paint event to draw white checkmark when checked"""
        super().paintEvent(event)

        if self.isChecked():
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QPen, QColor
            from PyQt6.QtCore import QPointF

            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_CheckBoxIndicator,
                opt,
                self
            )

            if indicator_rect.isValid():
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                pen_width = max(2.0, min(indicator_rect.width(), indicator_rect.height()) * 0.12)
                painter.setPen(QPen(QColor(255, 255, 255), pen_width, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin))
                painter.setBrush(QColor(255, 255, 255))

                x = indicator_rect.x()
                y = indicator_rect.y()
                w = indicator_rect.width()
                h = indicator_rect.height()

                padding = min(w, h) * 0.15
                x += padding
                y += padding
                w -= padding * 2
                h -= padding * 2

                check_x1 = x + w * 0.10
                check_y1 = y + h * 0.50
                check_x2 = x + w * 0.35
                check_y2 = y + h * 0.70
                check_x3 = x + w * 0.90
                check_y3 = y + h * 0.25

                painter.drawLine(QPointF(check_x2, check_y2), QPointF(check_x3, check_y3))
                painter.drawLine(QPointF(check_x1, check_y1), QPointF(check_x2, check_y2))

                painter.end()


class CustomRadioButton(QRadioButton):
    """Custom radio button with square indicator, green when checked, white checkmark"""
    
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        self.setCheckable(True)
        self.setEnabled(True)
        self.setStyleSheet("""
            QRadioButton {
                font-size: 9pt;
                spacing: 6px;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
                border: 2px solid #999;
                border-radius: 3px;
                background-color: white;
            }
            QRadioButton::indicator:checked {
                background-color: #4CAF50;
                border-color: #4CAF50;
            }
            QRadioButton::indicator:hover {
                border-color: #666;
            }
            QRadioButton::indicator:checked:hover {
                background-color: #45a049;
                border-color: #45a049;
            }
        """)
    
    def paintEvent(self, event):
        """Override paint event to draw white checkmark when checked"""
        super().paintEvent(event)
        
        if self.isChecked():
            # Get the indicator rectangle using QStyle
            from PyQt6.QtWidgets import QStyleOptionButton
            from PyQt6.QtGui import QPainter, QPen, QColor
            from PyQt6.QtCore import QPointF, QRect
            
            opt = QStyleOptionButton()
            self.initStyleOption(opt)
            indicator_rect = self.style().subElementRect(
                self.style().SubElement.SE_RadioButtonIndicator,
                opt,
                self
            )
            
            if indicator_rect.isValid():
                # Draw white checkmark
                painter = QPainter(self)
                painter.setRenderHint(QPainter.RenderHint.Antialiasing)
                # Slightly thinner pen for better fit on smaller displays
                pen_width = max(2.0, min(indicator_rect.width(), indicator_rect.height()) * 0.12)
                painter.setPen(QPen(QColor(255, 255, 255), pen_width, Qt.PenStyle.SolidLine, Qt.PenCapStyle.RoundCap, Qt.PenJoinStyle.RoundJoin))
                painter.setBrush(QColor(255, 255, 255))
                
                # Draw checkmark (‚úì shape) - coordinates relative to indicator
                # Add padding to prevent clipping on smaller displays
                x = indicator_rect.x()
                y = indicator_rect.y()
                w = indicator_rect.width()
                h = indicator_rect.height()
                
                # Add padding (15% on all sides) to ensure checkmark doesn't get cut off on smaller displays
                padding = min(w, h) * 0.15
                x += padding
                y += padding
                w -= padding * 2
                h -= padding * 2
                
                # Checkmark path: bottom-left to middle, then middle to top-right
                # Using proportions that create a nice checkmark shape with proper padding
                check_x1 = x + w * 0.10  # Left point (more padding from left)
                check_y1 = y + h * 0.50  # Bottom point (centered vertically)
                check_x2 = x + w * 0.35  # Middle-bottom point
                check_y2 = y + h * 0.70  # Bottom point (with padding from bottom)
                check_x3 = x + w * 0.90  # Right point (more padding from right)
                check_y3 = y + h * 0.25  # Top point (with padding from top)
                
                # Draw two lines forming the checkmark
                painter.drawLine(QPointF(check_x2, check_y2), QPointF(check_x3, check_y3))
                painter.drawLine(QPointF(check_x1, check_y1), QPointF(check_x2, check_y2))
                
                painter.end()


class AutoFingersWidget(QWidget):
    """
    AutoFingers - CAT Tool Automation Widget
    Provides UI for translation automation in tools like memoQ
    Now integrated as a tab in the main Supervertaler window
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Import AutoFingers engine
        try:
            from modules.autofingers_engine import AutoFingersEngine
            self.AutoFingersEngine = AutoFingersEngine
        except ImportError:
            QMessageBox.critical(
                self,
                "Import Error",
                "Could not import AutoFingers engine.\n"
                "Make sure modules/autofingers_engine.py exists."
            )
            return
        
        # Initialize engine
        self.engine = None
        self.is_running = False
        
        # Get default TMX path from user_data
        if ENABLE_PRIVATE_FEATURES:
            default_tmx = "user_data_private/autofingers_tm.tmx"
        else:
            default_tmx = "user_data/autofingers_tm.tmx"
        
        self.tmx_file = default_tmx
        
        self.setup_ui()
        self.load_settings()
        
    def setup_ui(self):
        """Setup the user interface"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(5)
        
        # Header (matches Superlookup / PDF Rescue / TMX Editor style)
        header = QLabel("ü§ñ AutoFingers")
        header.setStyleSheet("font-size: 16pt; font-weight: bold; color: #1976D2;")
        layout.addWidget(header, 0)  # 0 = no stretch, stays compact
        
        # Description box (matches Superlookup / PDF Rescue / TMX Editor style)
        info = QLabel(
            "Automated Translation Pasting for memoQ.\n"
            "AutoFingers reads from a TMX file and pastes translations automatically."
        )
        info.setWordWrap(True)
        info.setStyleSheet("color: #666; padding: 5px; background-color: #E3F2FD; border-radius: 3px;")
        layout.addWidget(info, 0)  # 0 = no stretch, stays compact
        
        # Control Panel (single widget, no tab needed)
        control_panel = self.create_control_tab()
        layout.addWidget(control_panel, 1)  # 1 = stretch to fill space
        
        # Close button
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout, 0)  # 0 = no stretch, stays compact
        
        # Setup global keyboard shortcuts (matching AutoHotkey version)
        self.setup_shortcuts()
    
    def setup_shortcuts(self):
        """Setup GLOBAL keyboard shortcuts for AutoFingers actions"""
        # keyboard module is Windows-only
        try:
            import keyboard
        except ImportError:
            self.log("‚ÑπÔ∏è Global hotkeys not available on this platform (Windows only)")
            return
        
        try:
            # Store hotkey references for later removal
            self.hotkeys = []
            
            # Register global hotkeys that work even when memoQ has focus
            # Ctrl+Alt+P - Process single segment
            self.hotkeys.append(keyboard.add_hotkey('ctrl+alt+p', self.process_single_safe))
            
            # Ctrl+Shift+L - Toggle loop mode
            self.hotkeys.append(keyboard.add_hotkey('ctrl+shift+l', self.toggle_loop_safe))
            
            # Ctrl+Alt+S - Stop loop
            self.hotkeys.append(keyboard.add_hotkey('ctrl+alt+s', self.stop_loop_safe))
            
            # Ctrl+Alt+R - Reload TMX
            self.hotkeys.append(keyboard.add_hotkey('ctrl+alt+r', self.reload_tmx_safe))
            
            self.log("‚úì Global hotkeys registered: Ctrl+Alt+P (single), Ctrl+Shift+L (loop), Ctrl+Alt+S (stop), Ctrl+Alt+R (reload)")
            self.log("‚ÑπÔ∏è Hotkeys work globally - even when memoQ has focus!")
            
        except Exception as e:
            self.log(f"‚ö†Ô∏è Could not register global hotkeys: {str(e)}")
            self.log("‚ÑπÔ∏è You may need to run as Administrator for global hotkeys")
    
    def process_single_safe(self):
        """Safe wrapper for process_single (called from global hotkey - runs in hotkey thread)"""
        try:
            # Dispatch to main Qt thread to avoid threading issues
            QTimer.singleShot(0, self.process_single)
        except Exception as e:
            print(f"Error in process_single_safe: {e}")
    
    def toggle_loop_safe(self):
        """Safe wrapper for toggle_loop (called from global hotkey - runs in hotkey thread)"""
        try:
            # Dispatch to main Qt thread to avoid threading issues
            QTimer.singleShot(0, self.toggle_loop)
        except Exception as e:
            print(f"Error in toggle_loop_safe: {e}")
    
    def stop_loop_safe(self):
        """Safe wrapper for stop_loop (called from global hotkey)"""
        try:
            self.stop_loop()
        except Exception as e:
            print(f"Error in stop_loop: {e}")
    
    def reload_tmx_safe(self):
        """Safe wrapper for reload_tmx (called from global hotkey)"""
        try:
            self.reload_tmx()
        except Exception as e:
            print(f"Error in reload_tmx: {e}")
    
    def cleanup_hotkeys(self):
        """Cleanup AutoFingers hotkeys when widget is closed/hidden"""
        # Unregister ONLY AutoFingers hotkeys
        # keyboard module is Windows-only
        try:
            import keyboard
        except ImportError:
            return  # Not available on this platform
        
        try:
            if hasattr(self, 'hotkeys'):
                for hotkey in self.hotkeys:
                    try:
                        keyboard.remove_hotkey(hotkey)
                    except:
                        pass
                self.log("AutoFingers hotkeys unregistered")
        except Exception as e:
            print(f"Error unregistering hotkeys: {e}")
    
    def create_control_tab(self):
        """Create the main control panel with horizontal layout"""
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        main_layout.setContentsMargins(8, 8, 8, 8)
        main_layout.setSpacing(8)
        
        # TOP ROW: Actions and TMX File side by side
        top_row = QHBoxLayout()
        top_row.setSpacing(8)
        
        # === LEFT: ACTIONS GROUP ===
        actions_group = QGroupBox("üéØ Actions")
        actions_layout = QHBoxLayout()
        actions_layout.setSpacing(8)
        
        # Single button
        single_col = QVBoxLayout()
        single_btn = QPushButton("‚ñ∂Ô∏è Single")
        single_btn.setMinimumHeight(40)
        single_btn.setMinimumWidth(100)
        single_btn.setStyleSheet("font-size: 10pt; font-weight: bold;")
        single_btn.clicked.connect(self.process_single)
        single_col.addWidget(single_btn)
        single_info = QLabel("(Ctrl+Alt+P)")
        single_info.setStyleSheet("color: #666; font-size: 8pt;")
        single_info.setAlignment(Qt.AlignmentFlag.AlignCenter)
        single_col.addWidget(single_info)
        actions_layout.addLayout(single_col)
        
        # Loop button
        loop_col = QVBoxLayout()
        self.loop_btn = QPushButton("‚ñ∂ Loop Mode")
        self.loop_btn.setMinimumHeight(40)
        self.loop_btn.setMinimumWidth(110)
        self.loop_btn.setStyleSheet("font-size: 10pt; font-weight: bold; background-color: #4CAF50; color: white;")
        self.loop_btn.clicked.connect(self.toggle_loop)
        loop_col.addWidget(self.loop_btn)
        loop_info = QLabel("(Ctrl+Shift+L)")
        loop_info.setStyleSheet("color: #666; font-size: 8pt;")
        loop_info.setAlignment(Qt.AlignmentFlag.AlignCenter)
        loop_col.addWidget(loop_info)
        actions_layout.addLayout(loop_col)
        
        # Segments spin
        segs_col = QVBoxLayout()
        segs_label = QLabel("Segments:")
        segs_label.setStyleSheet("font-size: 9pt; font-weight: bold;")
        segs_col.addWidget(segs_label)
        self.loop_segments_spin = QSpinBox()
        self.loop_segments_spin.setMinimum(0)
        self.loop_segments_spin.setMaximum(9999)
        self.loop_segments_spin.setValue(0)
        self.loop_segments_spin.setSuffix(" (0=‚àû)")
        self.loop_segments_spin.setMinimumHeight(28)
        self.loop_segments_spin.setStyleSheet("font-size: 9pt;")
        segs_col.addWidget(self.loop_segments_spin)
        actions_layout.addLayout(segs_col)
        
        # Progress
        progress_col = QVBoxLayout()
        self.progress_label = QLabel("Ready")
        self.progress_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        progress_col.addWidget(self.progress_label)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setMinimumHeight(28)
        progress_col.addWidget(self.progress_bar)
        actions_layout.addLayout(progress_col)
        
        actions_group.setLayout(actions_layout)
        top_row.addWidget(actions_group, 2)
        
        # === RIGHT: TMX FILE GROUP ===
        tmx_group = QGroupBox("üìÅ TMX File")
        tmx_layout = QVBoxLayout()
        tmx_layout.setSpacing(4)
        
        # File path row
        path_row = QHBoxLayout()
        self.tmx_path_label = QLabel(self.tmx_file)
        self.tmx_path_label.setStyleSheet("padding: 4px; font-size: 8pt;")
        path_row.addWidget(self.tmx_path_label, 1)
        
        browse_btn = QPushButton("Browse")
        browse_btn.setMaximumWidth(70)
        browse_btn.clicked.connect(self.browse_tmx)
        path_row.addWidget(browse_btn)
        
        reload_btn = QPushButton("Reload")
        reload_btn.setMaximumWidth(70)
        reload_btn.clicked.connect(self.reload_tmx)
        path_row.addWidget(reload_btn)
        
        import_btn = QPushButton("üì• Import from TM")
        import_btn.setMaximumWidth(110)
        import_btn.setToolTip("Import translation units from a Supervertaler Translation Memory")
        import_btn.clicked.connect(self.import_from_tm)
        path_row.addWidget(import_btn)
        
        tmx_layout.addLayout(path_row)
        
        # Status
        self.tmx_status_label = QLabel("No TMX loaded")
        self.tmx_status_label.setStyleSheet("padding: 4px; font-weight: bold; font-size: 9pt;")
        tmx_layout.addWidget(self.tmx_status_label)
        
        tmx_group.setLayout(tmx_layout)
        top_row.addWidget(tmx_group, 1)
        
        main_layout.addLayout(top_row)
        
        # MIDDLE ROW: Settings in a 2-column grid layout for better organization
        settings_group = QGroupBox("‚öôÔ∏è Settings")
        settings_layout = QGridLayout()
        settings_layout.setSpacing(15)
        settings_layout.setColumnStretch(0, 1)  # Left column flexible
        settings_layout.setColumnStretch(1, 1)  # Right column flexible
        
        # LEFT COLUMN: Languages and Timing (input fields grouped together)
        left_col = QVBoxLayout()
        left_col.setSpacing(12)
        
        # Languages section
        lang_group = QVBoxLayout()
        lang_label = QLabel("Languages:")
        lang_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        lang_group.addWidget(lang_label)
        lang_inputs = QHBoxLayout()
        lang_inputs.addWidget(QLabel("Source:"))
        self.source_lang_edit = QLineEdit("en")
        self.source_lang_edit.setMaximumWidth(50)
        lang_inputs.addWidget(self.source_lang_edit)
        lang_inputs.addSpacing(10)
        lang_inputs.addWidget(QLabel("Target:"))
        self.target_lang_edit = QLineEdit("nl")
        self.target_lang_edit.setMaximumWidth(50)
        lang_inputs.addWidget(self.target_lang_edit)
        lang_inputs.addStretch()
        lang_group.addLayout(lang_inputs)
        left_col.addLayout(lang_group)
        
        # Timing section
        timing_group = QVBoxLayout()
        timing_label = QLabel("Timing (ms):")
        timing_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        timing_group.addWidget(timing_label)
        timing_inputs = QHBoxLayout()
        timing_inputs.addWidget(QLabel("Loop:"))
        self.loop_delay_spin = QSpinBox()
        self.loop_delay_spin.setRange(500, 10000)
        self.loop_delay_spin.setValue(4000)
        self.loop_delay_spin.setSuffix(" ms")
        self.loop_delay_spin.setMaximumWidth(90)
        timing_inputs.addWidget(self.loop_delay_spin)
        timing_inputs.addSpacing(10)
        timing_inputs.addWidget(QLabel("Confirm:"))
        self.confirm_delay_spin = QSpinBox()
        self.confirm_delay_spin.setRange(100, 5000)
        self.confirm_delay_spin.setValue(900)
        self.confirm_delay_spin.setSuffix(" ms")
        self.confirm_delay_spin.setMaximumWidth(90)
        timing_inputs.addWidget(self.confirm_delay_spin)
        timing_inputs.addStretch()
        timing_group.addLayout(timing_inputs)
        left_col.addLayout(timing_group)
        
        left_col.addStretch()  # Push content to top
        
        # RIGHT COLUMN: Behavior checkboxes and Save button
        right_col = QVBoxLayout()
        right_col.setSpacing(12)
        
        # Behavior section
        behavior_group = QVBoxLayout()
        behavior_label = QLabel("Behavior:")
        behavior_label.setStyleSheet("font-weight: bold; font-size: 9pt;")
        behavior_group.addWidget(behavior_label)
        
        # Use custom checkboxes with green background and white checkmark when checked
        self.auto_confirm_check = CheckmarkCheckBox("Confirm segments")
        self.auto_confirm_check.setChecked(True)
        self.auto_confirm_check.setToolTip("When checked: Confirm segment with Ctrl+Enter before moving to next. When unchecked: Move to next with Alt+N without confirming")
        behavior_group.addWidget(self.auto_confirm_check)
        self.skip_no_match_check = CheckmarkCheckBox("Skip no match")
        self.skip_no_match_check.setChecked(True)
        behavior_group.addWidget(self.skip_no_match_check)
        right_col.addLayout(behavior_group)

        # Tag Cleaning section
        tag_cleaning_group = QVBoxLayout()
        tag_cleaning_label = QLabel("Tag Cleaning:")
        tag_cleaning_label.setStyleSheet("font-weight: bold; font-size: 9pt; margin-top: 8px;")
        tag_cleaning_group.addWidget(tag_cleaning_label)

        # Master switch
        self.tag_cleaning_enabled_check = CheckmarkCheckBox("Enable tag cleaning")
        self.tag_cleaning_enabled_check.setChecked(False)
        self.tag_cleaning_enabled_check.setToolTip("Remove CAT tool tags from translations before pasting")
        tag_cleaning_group.addWidget(self.tag_cleaning_enabled_check)

        # Granular controls (indented)
        tag_types_layout = QVBoxLayout()
        tag_types_layout.setContentsMargins(20, 0, 0, 0)  # Indent

        self.clean_memoq_index_tags_check = CheckmarkCheckBox("memoQ index tags ([1} {2])")
        self.clean_memoq_index_tags_check.setChecked(True)
        self.clean_memoq_index_tags_check.setToolTip("Remove memoQ index tags like [1} {2] [3} etc.")
        tag_types_layout.addWidget(self.clean_memoq_index_tags_check)

        self.clean_trados_tags_check = CheckmarkCheckBox("Trados Studio tags")
        self.clean_trados_tags_check.setChecked(False)
        self.clean_trados_tags_check.setEnabled(False)  # Not implemented yet
        self.clean_trados_tags_check.setToolTip("Coming soon")
        tag_types_layout.addWidget(self.clean_trados_tags_check)

        self.clean_cafetran_tags_check = CheckmarkCheckBox("CafeTran tags")
        self.clean_cafetran_tags_check.setChecked(False)
        self.clean_cafetran_tags_check.setEnabled(False)  # Not implemented yet
        self.clean_cafetran_tags_check.setToolTip("Coming soon")
        tag_types_layout.addWidget(self.clean_cafetran_tags_check)

        self.clean_wordfast_tags_check = CheckmarkCheckBox("Wordfast tags")
        self.clean_wordfast_tags_check.setChecked(False)
        self.clean_wordfast_tags_check.setEnabled(False)  # Not implemented yet
        self.clean_wordfast_tags_check.setToolTip("Coming soon")
        tag_types_layout.addWidget(self.clean_wordfast_tags_check)

        tag_cleaning_group.addLayout(tag_types_layout)
        right_col.addLayout(tag_cleaning_group)
        
        # Save button - centered at bottom of right column
        right_col.addStretch()
        save_btn = QPushButton("üíæ Save Settings")
        save_btn.setMinimumHeight(35)
        save_btn.setStyleSheet("font-size: 9pt; font-weight: bold;")
        save_btn.clicked.connect(self.save_settings)
        right_col.addWidget(save_btn)
        
        # Add columns to grid layout
        left_widget = QWidget()
        left_widget.setLayout(left_col)

        # Wrap right column in scroll area for smaller screens
        right_widget = QWidget()
        right_widget.setLayout(right_col)

        right_scroll = QScrollArea()
        right_scroll.setWidget(right_widget)
        right_scroll.setWidgetResizable(True)
        right_scroll.setFrameShape(QFrame.Shape.NoFrame)
        right_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        right_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)

        settings_layout.addWidget(left_widget, 0, 0)
        settings_layout.addWidget(right_scroll, 0, 1)
        
        settings_group.setLayout(settings_layout)
        
        # Create horizontal container for Settings and Activity Log side-by-side
        settings_log_row = QHBoxLayout()
        settings_log_row.setSpacing(15)
        settings_log_row.addWidget(settings_group, 1)  # Settings takes flexible space
        
        # Activity Log on the right
        log_group = QGroupBox("üìã Activity Log")
        log_layout = QVBoxLayout()
        log_layout.setContentsMargins(5, 5, 5, 5)
        
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setMinimumHeight(200)  # Give it a reasonable minimum height
        self.log_text.setStyleSheet("""
            font-family: 'Consolas', monospace;
            padding: 4px;
            line-height: 1.3;
            font-size: 8pt;
        """)
        log_layout.addWidget(self.log_text)
        
        log_group.setLayout(log_layout)
        settings_log_row.addWidget(log_group, 1)  # Activity Log takes equal flexible space
        
        main_layout.addLayout(settings_log_row)
        
        return tab
    
    def log(self, message: str):
        """Add message to activity log (thread-safe)"""
        # Skip logging if not on main thread to prevent QTextDocument crashes
        from threading import current_thread, main_thread
        if current_thread() is main_thread():
            timestamp = datetime.now().strftime("%H:%M:%S")
            self._append_log(f"[{timestamp}] {message}")
        else:
            # Queue for main thread
            timestamp = datetime.now().strftime("%H:%M:%S")
            QTimer.singleShot(0, lambda msg=f"[{timestamp}] {message}": self._append_log(msg))
    
    def _append_log(self, message: str):
        """Actually append to log (runs on main thread)"""
        self.log_text.append(message)
        # Auto-scroll to bottom
        scrollbar = self.log_text.verticalScrollBar()
        if scrollbar:
            scrollbar.setValue(scrollbar.maximum())
    
    def update_progress_label(self, text: str):
        """Thread-safe progress label update"""
        QTimer.singleShot(0, lambda t=text: self.progress_label.setText(t))
    
    def update_progress_bar(self, value: int):
        """Thread-safe progress bar update"""
        QTimer.singleShot(0, lambda v=value: self.progress_bar.setValue(v))
    
    def browse_tmx(self):
        """Browse for TMX file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select TMX File",
            "",
            "TMX Files (*.tmx);;All Files (*.*)"
        )
        
        if file_path:
            self.tmx_file = file_path
            self.tmx_path_label.setText(file_path)
            self.reload_tmx()
    
    def reload_tmx(self):
        """Reload TMX file"""
        try:
            self.engine = self.AutoFingersEngine(
                tmx_file=self.tmx_file,
                source_lang=self.source_lang_edit.text(),
                target_lang=self.target_lang_edit.text()
            )
            
            # Apply settings
            self.engine.loop_delay = self.loop_delay_spin.value()
            self.engine.confirm_delay = self.confirm_delay_spin.value()
            self.engine.auto_confirm = self.auto_confirm_check.isChecked()
            self.engine.skip_no_match = self.skip_no_match_check.isChecked()

            # Apply tag cleaner settings
            if self.tag_cleaning_enabled_check.isChecked():
                self.engine.tag_cleaner.enable()
            else:
                self.engine.tag_cleaner.disable()

            if self.clean_memoq_index_tags_check.isChecked():
                self.engine.tag_cleaner.enable_memoq_index_tags()
            else:
                self.engine.tag_cleaner.disable_memoq_index_tags()

            success, message = self.engine.load_tmx()
            
            if success:
                self.log(f"‚úì {message}")
                self.tmx_status_label.setText(f"‚úì {self.engine.tm_count} TUs loaded")
                self.tmx_status_label.setStyleSheet("padding: 4px; font-weight: bold; font-size: 9pt; color: green;")
            else:
                self.log(f"‚úó {message}")
                self.tmx_status_label.setText(f"‚úó {message}")
                self.tmx_status_label.setStyleSheet("padding: 4px; font-weight: bold; font-size: 9pt; color: red;")
                
        except Exception as e:
            self.log(f"‚úó Error: {str(e)}")
            QMessageBox.critical(self, "Error", f"Failed to load TMX:\n{str(e)}")
    
    def sync_settings_to_engine(self):
        """Sync current UI settings to the engine"""
        if self.engine:
            self.engine.loop_delay = self.loop_delay_spin.value()
            self.engine.confirm_delay = self.confirm_delay_spin.value()
            self.engine.auto_confirm = self.auto_confirm_check.isChecked()
            self.engine.skip_no_match = self.skip_no_match_check.isChecked()
    
    def process_single(self):
        """Process a single segment"""
        if not self.engine:
            QMessageBox.warning(self, "No TMX", "Please load a TMX file first.")
            return
        
        # Sync current settings to engine before processing
        self.sync_settings_to_engine()
        
        self.log("‚ñ∂Ô∏è Processing single segment...")
        self.progress_label.setText("Processing...")
        
        # Give user time to switch to memoQ
        QApplication.processEvents()
        import time
        time.sleep(1)
        
        try:
            success, message = self.engine.process_single_segment()
            
            # Log match result
            if self.engine.last_source and self.engine.last_match:
                self.log(f"‚úì Match: {self.engine.last_match.match_type} ({self.engine.last_match.match_percent}%)")
            else:
                self.log(f"‚ö†Ô∏è No match found for segment")
            
            if success:
                self.log(f"‚úì {message}")
                self.progress_label.setText("‚úì Segment processed successfully")
            else:
                self.log(f"‚úó {message}")
                self.progress_label.setText(f"‚úó {message}")
        except Exception as e:
            self.log(f"‚ùå Error in process_single: {str(e)}")
            import traceback
            self.log(traceback.format_exc())
    
    def toggle_loop(self):
        """Toggle loop mode on/off"""
        if self.is_running:
            # Stop loop
            self.engine.stop()
            self.is_running = False
            self.loop_btn.setText("‚ñ∂ Loop Mode")
            self.loop_btn.setStyleSheet("font-size: 9pt; font-weight: bold; background-color: #4CAF50; color: white; padding: 2px;")
            self.progress_bar.setVisible(False)
            self.log("‚èπÔ∏è Loop mode stopped")
        else:
            # Start loop
            if not self.engine:
                QMessageBox.warning(self, "No TMX", "Please load a TMX file first.")
                return
            
            # Sync current settings to engine before starting loop
            self.sync_settings_to_engine()
            
            max_segments = self.loop_segments_spin.value()
            self.is_running = True
            self.loop_btn.setText("‚èπ Stop Loop")
            self.loop_btn.setStyleSheet("font-size: 9pt; font-weight: bold; background-color: #F44336; color: white; padding: 2px;")
            
            if max_segments > 0:
                self.progress_bar.setMaximum(max_segments)
                self.progress_bar.setValue(0)
                self.progress_bar.setVisible(True)
            else:
                self.progress_bar.setVisible(False)
            
            self.log(f"‚ñ∂Ô∏è Starting loop mode ({max_segments if max_segments > 0 else '‚àû'} segments)...")
            
            # Start loop in background thread
            self.loop_thread = threading.Thread(target=self.run_loop, args=(max_segments,), daemon=True)
            self.loop_thread.start()
    
    def run_loop(self, max_segments):
        """Run the loop mode in background thread"""
        import time
        
        segment_count = 0
        
        while self.is_running:
            # Check if reached limit
            if max_segments > 0 and segment_count >= max_segments:
                self.is_running = False
                self.log(f"‚úì Completed {segment_count} segments")
                self.update_progress_label(f"‚úì Completed {segment_count} segments")
                QTimer.singleShot(0, self.reset_loop_ui)
                break
            
            # Process one segment
            try:
                success, message = self.engine.process_single_segment()
                
                if success:
                    segment_count += 1
                    self.log(f"‚úì {message}")
                    self.update_progress_label(f"Processing... ({segment_count} completed)")
                    if max_segments > 0:
                        self.update_progress_bar(segment_count)
                else:
                    self.log(f"‚úó {message}")
                    
                    # Stop if no match and not skipping
                    if not self.engine.skip_no_match:
                        self.is_running = False
                        self.update_progress_label(f"Stopped - no translation found")
                        QTimer.singleShot(0, self.reset_loop_ui)
                        break
                
                # Wait between segments
                if self.is_running:
                    time.sleep(self.engine.loop_delay / 1000)
                    
            except Exception as e:
                self.log(f"‚úó Error: {str(e)}")
                self.is_running = False
                QTimer.singleShot(0, self.reset_loop_ui)
                break
    
    def reset_loop_ui(self):
        """Reset UI after loop stops"""
        self.loop_btn.setText("‚ñ∂ Loop Mode")
        self.loop_btn.setStyleSheet("font-size: 9pt; font-weight: bold; background-color: #4CAF50; color: white; padding: 2px;")
        if self.progress_bar.maximum() > 0:
            self.progress_bar.setVisible(True)  # Keep visible to show final progress
        else:
            self.progress_bar.setVisible(False)
    
    def stop_loop(self):
        """Stop loop mode (separate method for keyboard shortcut)"""
        if self.is_running:
            self.toggle_loop()  # Reuse toggle logic when running
        else:
            self.log("Loop mode is not running")
    
    def create_empty_tmx(self):
        """Create a new empty TMX file"""
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Create New TMX File",
            self.tmx_file,
            "TMX Files (*.tmx)"
        )
        
        if file_path:
            temp_engine = self.AutoFingersEngine(
                tmx_file=file_path,
                source_lang=self.source_lang_edit.text(),
                target_lang=self.target_lang_edit.text()
            )
            
            if temp_engine.create_empty_tmx():
                self.log(f"‚úì Created empty TMX: {file_path}")
                self.tmx_file = file_path
                self.tmx_path_label.setText(file_path)
                self.reload_tmx()
            else:
                QMessageBox.critical(self, "Error", "Failed to create TMX file")
    
    def open_tmx_in_editor(self):
        """Open TMX file in external editor"""
        import subprocess
        try:
            if sys.platform == 'win32':
                os.startfile(self.tmx_file)
            elif sys.platform == 'darwin':
                subprocess.call(['open', self.tmx_file])
            else:
                subprocess.call(['xdg-open', self.tmx_file])
            self.log(f"üìÇ Opened TMX in editor: {self.tmx_file}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Could not open TMX file:\n{str(e)}")
    
    def import_from_tm(self):
        """Import translations from Supervertaler TM database"""
        QMessageBox.information(
            self,
            "Feature Coming Soon",
            "TM import functionality will be added in the next update!\n\n"
            "For now, you can manually edit the TMX file or use the\n"
            "AutoHotkey version to populate your translation memory."
        )
    
    def load_settings(self):
        """Load saved settings from file"""
        try:
            settings_file = Path("user_data_private" if ENABLE_PRIVATE_FEATURES else "user_data") / "autofingers_settings.json"
            if settings_file.exists():
                with open(settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                
                # Apply settings to UI
                self.loop_delay_spin.setValue(settings.get('loop_delay', 4000))
                self.confirm_delay_spin.setValue(settings.get('confirm_delay', 900))
                self.auto_confirm_check.setChecked(settings.get('auto_confirm', True))
                self.skip_no_match_check.setChecked(settings.get('skip_no_match', True))
                # Backward compatibility: if old settings had use_down_arrow=True, set auto_confirm=False
                if settings.get('use_down_arrow', False):
                    self.auto_confirm_check.setChecked(False)

                # Load tag cleaner settings
                tag_cleaner_settings = settings.get('tag_cleaner', {})
                self.tag_cleaning_enabled_check.setChecked(tag_cleaner_settings.get('enabled', False))
                memoq_settings = tag_cleaner_settings.get('memoq', {})
                self.clean_memoq_index_tags_check.setChecked(
                    memoq_settings.get('index_tags', {}).get('enabled', True)
                )

                self.log("‚úì Settings loaded")
        except Exception as e:
            self.log(f"‚ö†Ô∏è Could not load settings: {e}")
    
    def save_settings(self):
        """Save current settings to file"""
        try:
            settings = {
                'loop_delay': self.loop_delay_spin.value(),
                'confirm_delay': self.confirm_delay_spin.value(),
                'auto_confirm': self.auto_confirm_check.isChecked(),
                'skip_no_match': self.skip_no_match_check.isChecked(),
                'tag_cleaner': {
                    'enabled': self.tag_cleaning_enabled_check.isChecked(),
                    'memoq': {
                        'index_tags': {
                            'enabled': self.clean_memoq_index_tags_check.isChecked()
                        }
                    },
                    'trados': {},
                    'cafetran': {},
                    'wordfast': {}
                }
            }

            settings_file = Path("user_data_private" if ENABLE_PRIVATE_FEATURES else "user_data") / "autofingers_settings.json"
            settings_file.parent.mkdir(parents=True, exist_ok=True)

            with open(settings_file, 'w', encoding='utf-8') as f:
                json.dump(settings, f, indent=2)

            self.log("üíæ Settings saved")
            QMessageBox.information(self, "Saved", "Settings saved successfully!")
        except Exception as e:
            self.log(f"‚ö†Ô∏è Could not save settings: {e}")
            QMessageBox.critical(self, "Error", f"Failed to save settings:\n{str(e)}")


# ============================================================================
# APPLICATION ENTRY POINT
# ============================================================================

def main():
    """Application entry point"""
    # Install global exception handler to catch unhandled exceptions
    import traceback
    
    def global_exception_handler(exc_type, exc_value, exc_traceback):
        """Global exception handler - prints full traceback before crashing"""
        print("\n" + "="*60)
        print("üö® UNHANDLED EXCEPTION - FULL TRACEBACK:")
        print("="*60)
        traceback.print_exception(exc_type, exc_value, exc_traceback)
        print("="*60 + "\n")
        # Call the default handler
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
    
    sys.excepthook = global_exception_handler
    
    # Suppress Chromium/QtWebEngine verbose error output (cache errors, GPU warnings, JS console)
    # These are harmless but alarming to users - websites emit tons of CSP/permissions noise
    os.environ["QTWEBENGINE_CHROMIUM_FLAGS"] = "--disable-logging --log-level=3 --enable-logging=stderr --v=-1"
    
    # Suppress Qt WebEngine's "js:" console output (CSP violations, permissions policy warnings)
    # These come from embedded web pages and are not relevant to Supervertaler
    os.environ["QT_LOGGING_RULES"] = "*.debug=false;qt.webenginecontext.debug=false;js=false"
    
    # Filter stderr to suppress noisy Chromium JS console messages
    # These "js:" prefixed messages come from embedded web pages and alarm users
    class StderrFilter:
        """Filter that suppresses Chromium's JS console output from stderr"""
        def __init__(self, original_stderr):
            self.original = original_stderr
            # Patterns to suppress (from embedded web pages)
            self.suppress_prefixes = (
                'js:', 'js: Error with Permissions-Policy', 'js: Refused to load',
                'js: Document-Policy', 'js: Listener added', 'js: No ID or name',
                'js: [Report Only]', 'js: Unrecognized feature'
            )
        
        def write(self, text):
            # Suppress lines starting with JS console prefixes
            if text.strip() and any(text.strip().startswith(prefix) for prefix in self.suppress_prefixes):
                return  # Silently discard
            self.original.write(text)
        
        def flush(self):
            self.original.flush()
        
        def fileno(self):
            return self.original.fileno()
        
        def isatty(self):
            return self.original.isatty() if hasattr(self.original, 'isatty') else False
    
    sys.stderr = StderrFilter(sys.stderr)
    
    # Linux-specific: Avoid memory access violations from native libraries
    # ChromaDB and Hunspell can crash on some Linux configurations
    if sys.platform == 'linux':
        # Disable threading optimizations that can cause crashes in native code
        os.environ.setdefault("TOKENIZERS_PARALLELISM", "false")
        # Use safer malloc implementation if available
        os.environ.setdefault("MALLOC_CHECK_", "0")
    
    # Set OpenGL context sharing before creating QApplication (required for QtWebEngine)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts)
    
    app = QApplication(sys.argv)
    app.setApplicationName("Supervertaler")
    app.setOrganizationName("Supervertaler")
    
    # Global stylesheet to remove ugly focus rectangles from buttons
    app.setStyleSheet("""
        QPushButton:focus {
            outline: none;
            border: none;
        }
        QToolButton:focus {
            outline: none;
            border: none;
        }
    """)

    # Set Windows AppUserModelID for taskbar icon grouping (Windows 7+)
    if sys.platform == 'win32':
        try:
            import ctypes
            myappid = 'com.michaelbeijer.supervertaler.1.9.27'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)
        except Exception:
            pass  # Fail silently if not on Windows or ctypes unavailable

    window = SupervertalerQt()
    window.show()
    
    sys.exit(app.exec())


if __name__ == '__main__':
    main()
