from typing import Optional, Dict, Any, List
from datetime import datetime
from pydantic import BaseModel, Field, EmailStr, ConfigDict, field_validator, model_validator

class UserAuthCreateNew(BaseModel):
    """Model for creating new Firebase Auth users - does not include user_uid"""
    model_config = ConfigDict(extra="forbid")

    # Core authentication fields for new user creation
    email: EmailStr = Field(..., description="User's email address")
    password: str = Field(..., min_length=6, description="User's password (min 6 characters)")
    display_name: Optional[str] = Field(None, description="User's display name")
    phone_number: Optional[str] = Field(None, description="Phone number in E.164 format (e.g. +1234567890)")
    email_verified: bool = Field(default=False, description="Whether the email is already verified")
    disabled: bool = Field(default=False, description="Whether the user should be disabled on creation")

    # Custom claims for new user
    custom_claims: Dict[str, Any] = Field(default_factory=dict, description="Firebase custom claims")

    @field_validator('phone_number')
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate phone number format if provided"""
        if v is None:
            return v
        # Basic E.164 format validation
        if not v.startswith('+') or not v[1:].isdigit() or len(v) < 8 or len(v) > 16:
            raise ValueError('Phone number must be in E.164 format (+1234567890)')
        return v

    @field_validator('custom_claims')
    @classmethod
    def validate_custom_claims(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate custom claims don't contain reserved Firebase claims"""
        reserved_claims = {
            'iss', 'aud', 'auth_time', 'user_id', 'sub', 'iat', 'exp', 'email',
            'email_verified', 'phone_number', 'name', 'picture', 'firebase'
        }

        for claim in v.keys():
            if claim in reserved_claims:
                raise ValueError(f'Custom claim "{claim}" is reserved by Firebase')

        return v

class UserAuth(BaseModel):
    """Comprehensive authentication model for existing user credentials and auth operations"""
    model_config = ConfigDict(extra="forbid")

    # Firebase UID - required for existing users (generated by Firebase when user was created)
    user_uid: str = Field(..., description="Firebase Auth UID - required for existing users")

    # Core authentication fields
    email: EmailStr = Field(..., description="User's email address")
    display_name: Optional[str] = Field(None, description="User's display name")
    password: Optional[str] = Field(None, min_length=6, description="User's password (for updates only)")

    # Firebase Auth specific fields
    provider_id: str = Field(default="password", description="Authentication provider ID")
    email_verified: bool = Field(default=False, description="Whether email is verified")
    disabled: bool = Field(default=False, description="Whether user account is disabled")

    # Multi-factor authentication
    mfa_enabled: bool = Field(default=False, description="Whether MFA is enabled")
    phone_number: Optional[str] = Field(default=None, description="Phone number for SMS MFA")

    # Custom claims and metadata
    custom_claims: Dict[str, Any] = Field(default_factory=dict, description="Firebase custom claims")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional authentication metadata")

    # Provider data
    provider_data: List[Dict[str, Any]] = Field(default_factory=list, description="Provider-specific data")

    # Account management
    created_at: Optional[datetime] = Field(default=None, description="Account creation timestamp")
    last_sign_in: Optional[datetime] = Field(default=None, description="Last sign-in timestamp")
    last_refresh: Optional[datetime] = Field(default=None, description="Last token refresh timestamp")

    # Password management
    password_hash: Optional[str] = Field(default=None, description="Password hash (internal use only)")
    password_salt: Optional[str] = Field(default=None, description="Password salt (internal use only)")
    valid_since: Optional[datetime] = Field(default=None, description="Timestamp since when tokens are valid")

    @field_validator('phone_number')
    @classmethod
    def validate_phone_number(cls, v: Optional[str]) -> Optional[str]:
        """Validate phone number format if provided"""
        if v is None:
            return v
        # Basic E.164 format validation
        if not v.startswith('+') or not v[1:].isdigit() or len(v) < 8 or len(v) > 16:
            raise ValueError('Phone number must be in E.164 format (+1234567890)')
        return v

    @field_validator('custom_claims')
    @classmethod
    def validate_custom_claims(cls, v: Dict[str, Any]) -> Dict[str, Any]:
        """Validate custom claims don't contain reserved Firebase claims"""
        reserved_claims = {
            'iss', 'aud', 'auth_time', 'user_id', 'sub', 'iat', 'exp', 'email',
            'email_verified', 'phone_number', 'name', 'picture', 'firebase'
        }

        for claim in v.keys():
            if claim in reserved_claims:
                raise ValueError(f'Custom claim "{claim}" is reserved by Firebase')

        return v

    @model_validator(mode='before')
    @classmethod
    def check_password_fields(cls, values: Any) -> Any:
        """Ensure that password and password_hash are not set simultaneously."""
        # Handle both dict and object types (e.g., Firebase UserRecord)
        if isinstance(values, dict):
            if values.get('password') and values.get('password_hash'):
                raise ValueError('Cannot set both password and password_hash')
        else:
            # For objects, check using getattr
            if getattr(values, 'password', None) and getattr(values, 'password_hash', None):
                raise ValueError('Cannot set both password and password_hash')
        return values