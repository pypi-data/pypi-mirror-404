/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_FUSEELEMENTWISEPASS
#define GEN_PASS_DECL_INITIALIZEALLOCSPASS
#define GEN_PASS_DECL_LINALGELEMENTWISETOVECTORPASS
#define GEN_PASS_DECL_LOWERXTILEENTRYPASS
#define GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#define GEN_PASS_DECL_SHLOTOVECTORPASS
#define GEN_PASS_DECL_TENSOROPSTOBUFFERIZABLEPASS
#define GEN_PASS_DECL_UNPACKSUBBYTEVECTORWRITEPASS
#define GEN_PASS_DECL_VECTORTOSCALARPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// FuseElementwisePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FUSEELEMENTWISEPASS
std::unique_ptr<::mlir::Pass> createFuseElementwisePass();
#undef GEN_PASS_DECL_FUSEELEMENTWISEPASS
#endif // GEN_PASS_DECL_FUSEELEMENTWISEPASS
#ifdef GEN_PASS_DEF_FUSEELEMENTWISEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createFuseElementwisePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class FuseElementwisePassBase : public ::mlir::OperationPass<> {
public:
  using Base = FuseElementwisePassBase;

  FuseElementwisePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  FuseElementwisePassBase(const FuseElementwisePassBase &other) : ::mlir::OperationPass<>(other) {}
  FuseElementwisePassBase& operator=(const FuseElementwisePassBase &) = delete;
  FuseElementwisePassBase(FuseElementwisePassBase &&) = delete;
  FuseElementwisePassBase& operator=(FuseElementwisePassBase &&) = delete;
  ~FuseElementwisePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-fuse-elementwise");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-fuse-elementwise"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Fuse linalg elementwise ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FuseElementwisePass");
  }
  ::llvm::StringRef getName() const override { return "FuseElementwisePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FuseElementwisePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createFuseElementwisePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createFuseElementwisePass() {
  return impl::createFuseElementwisePass();
}
#undef GEN_PASS_DEF_FUSEELEMENTWISEPASS
#endif // GEN_PASS_DEF_FUSEELEMENTWISEPASS

//===----------------------------------------------------------------------===//
// InitializeAllocsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_INITIALIZEALLOCSPASS
std::unique_ptr<::mlir::Pass> createInitializeAllocsPass();
#undef GEN_PASS_DECL_INITIALIZEALLOCSPASS
#endif // GEN_PASS_DECL_INITIALIZEALLOCSPASS
#ifdef GEN_PASS_DEF_INITIALIZEALLOCSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createInitializeAllocsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class InitializeAllocsPassBase : public ::mlir::OperationPass<> {
public:
  using Base = InitializeAllocsPassBase;

  InitializeAllocsPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  InitializeAllocsPassBase(const InitializeAllocsPassBase &other) : ::mlir::OperationPass<>(other) {}
  InitializeAllocsPassBase& operator=(const InitializeAllocsPassBase &) = delete;
  InitializeAllocsPassBase(InitializeAllocsPassBase &&) = delete;
  InitializeAllocsPassBase& operator=(InitializeAllocsPassBase &&) = delete;
  ~InitializeAllocsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-initialize-allocs");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-initialize-allocs"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Initializes allocations.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("InitializeAllocsPass");
  }
  ::llvm::StringRef getName() const override { return "InitializeAllocsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<::mlir::scf::SCFDialect>();
    registry.insert<::mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(InitializeAllocsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createInitializeAllocsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createInitializeAllocsPass() {
  return impl::createInitializeAllocsPass();
}
#undef GEN_PASS_DEF_INITIALIZEALLOCSPASS
#endif // GEN_PASS_DEF_INITIALIZEALLOCSPASS

//===----------------------------------------------------------------------===//
// LinalgElementwiseToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LINALGELEMENTWISETOVECTORPASS
#undef GEN_PASS_DECL_LINALGELEMENTWISETOVECTORPASS
#endif // GEN_PASS_DECL_LINALGELEMENTWISETOVECTORPASS
#ifdef GEN_PASS_DEF_LINALGELEMENTWISETOVECTORPASS
namespace impl {

template <typename DerivedT>
class LinalgElementwiseToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LinalgElementwiseToVectorPassBase;

  LinalgElementwiseToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LinalgElementwiseToVectorPassBase(const LinalgElementwiseToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LinalgElementwiseToVectorPassBase& operator=(const LinalgElementwiseToVectorPassBase &) = delete;
  LinalgElementwiseToVectorPassBase(LinalgElementwiseToVectorPassBase &&) = delete;
  LinalgElementwiseToVectorPassBase& operator=(LinalgElementwiseToVectorPassBase &&) = delete;
  ~LinalgElementwiseToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-linalg-elementwise-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-linalg-elementwise-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert elementwise linalg ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LinalgElementwiseToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "LinalgElementwiseToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LinalgElementwiseToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LINALGELEMENTWISETOVECTORPASS
#endif // GEN_PASS_DEF_LINALGELEMENTWISETOVECTORPASS

//===----------------------------------------------------------------------===//
// LowerXTileEntryPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERXTILEENTRYPASS
#undef GEN_PASS_DECL_LOWERXTILEENTRYPASS
#endif // GEN_PASS_DECL_LOWERXTILEENTRYPASS
#ifdef GEN_PASS_DEF_LOWERXTILEENTRYPASS
namespace impl {

template <typename DerivedT>
class LowerXTileEntryPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerXTileEntryPassBase;

  LowerXTileEntryPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXTileEntryPassBase(const LowerXTileEntryPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerXTileEntryPassBase& operator=(const LowerXTileEntryPassBase &) = delete;
  LowerXTileEntryPassBase(LowerXTileEntryPassBase &&) = delete;
  LowerXTileEntryPassBase& operator=(LowerXTileEntryPassBase &&) = delete;
  ~LowerXTileEntryPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-lower-xtile-entry");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-lower-xtile-entry"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers the entry function into the form required by the CPU runtime)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXTileEntryPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXTileEntryPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<xla::cpu::XlaCpuDialect>();
    registry.insert<xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXTileEntryPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERXTILEENTRYPASS
#endif // GEN_PASS_DEF_LOWERXTILEENTRYPASS

//===----------------------------------------------------------------------===//
// MemrefCopyToLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass();
#undef GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#endif // GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#ifdef GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class MemrefCopyToLoopsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MemrefCopyToLoopsPassBase;

  MemrefCopyToLoopsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemrefCopyToLoopsPassBase(const MemrefCopyToLoopsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  MemrefCopyToLoopsPassBase& operator=(const MemrefCopyToLoopsPassBase &) = delete;
  MemrefCopyToLoopsPassBase(MemrefCopyToLoopsPassBase &&) = delete;
  MemrefCopyToLoopsPassBase& operator=(MemrefCopyToLoopsPassBase &&) = delete;
  ~MemrefCopyToLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-memref-copy-to-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-memref-copy-to-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite mmeref.copy to loops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemrefCopyToLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "MemrefCopyToLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::scf::SCFDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemrefCopyToLoopsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass() {
  return impl::createMemrefCopyToLoopsPass();
}
#undef GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS
#endif // GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS

//===----------------------------------------------------------------------===//
// ShloToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHLOTOVECTORPASS
#undef GEN_PASS_DECL_SHLOTOVECTORPASS
#endif // GEN_PASS_DECL_SHLOTOVECTORPASS
#ifdef GEN_PASS_DEF_SHLOTOVECTORPASS
namespace impl {

template <typename DerivedT>
class ShloToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ShloToVectorPassBase;

  ShloToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShloToVectorPassBase(const ShloToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ShloToVectorPassBase& operator=(const ShloToVectorPassBase &) = delete;
  ShloToVectorPassBase(ShloToVectorPassBase &&) = delete;
  ShloToVectorPassBase& operator=(ShloToVectorPassBase &&) = delete;
  ~ShloToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-shlo-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-shlo-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering satble hlo ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShloToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "ShloToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::bufferization::BufferizationDialect>();
    registry.insert<mlir::memref::MemRefDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShloToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHLOTOVECTORPASS
#endif // GEN_PASS_DEF_SHLOTOVECTORPASS

//===----------------------------------------------------------------------===//
// TensorOpsToBufferizablePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSOROPSTOBUFFERIZABLEPASS
#undef GEN_PASS_DECL_TENSOROPSTOBUFFERIZABLEPASS
#endif // GEN_PASS_DECL_TENSOROPSTOBUFFERIZABLEPASS
#ifdef GEN_PASS_DEF_TENSOROPSTOBUFFERIZABLEPASS
namespace impl {

template <typename DerivedT>
class TensorOpsToBufferizablePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TensorOpsToBufferizablePassBase;

  TensorOpsToBufferizablePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorOpsToBufferizablePassBase(const TensorOpsToBufferizablePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TensorOpsToBufferizablePassBase& operator=(const TensorOpsToBufferizablePassBase &) = delete;
  TensorOpsToBufferizablePassBase(TensorOpsToBufferizablePassBase &&) = delete;
  TensorOpsToBufferizablePassBase& operator=(TensorOpsToBufferizablePassBase &&) = delete;
  ~TensorOpsToBufferizablePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-tensor-ops-to-bufferizable");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-tensor-ops-to-bufferizable"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering tensor dialect ops to bufferizable ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorOpsToBufferizablePass");
  }
  ::llvm::StringRef getName() const override { return "TensorOpsToBufferizablePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorOpsToBufferizablePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSOROPSTOBUFFERIZABLEPASS
#endif // GEN_PASS_DEF_TENSOROPSTOBUFFERIZABLEPASS

//===----------------------------------------------------------------------===//
// UnpackSubByteVectorWritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNPACKSUBBYTEVECTORWRITEPASS
std::unique_ptr<::mlir::Pass> createUnpackSubByteVectorWritePass();
#undef GEN_PASS_DECL_UNPACKSUBBYTEVECTORWRITEPASS
#endif // GEN_PASS_DECL_UNPACKSUBBYTEVECTORWRITEPASS
#ifdef GEN_PASS_DEF_UNPACKSUBBYTEVECTORWRITEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createUnpackSubByteVectorWritePass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class UnpackSubByteVectorWritePassBase : public ::mlir::OperationPass<> {
public:
  using Base = UnpackSubByteVectorWritePassBase;

  UnpackSubByteVectorWritePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  UnpackSubByteVectorWritePassBase(const UnpackSubByteVectorWritePassBase &other) : ::mlir::OperationPass<>(other) {}
  UnpackSubByteVectorWritePassBase& operator=(const UnpackSubByteVectorWritePassBase &) = delete;
  UnpackSubByteVectorWritePassBase(UnpackSubByteVectorWritePassBase &&) = delete;
  UnpackSubByteVectorWritePassBase& operator=(UnpackSubByteVectorWritePassBase &&) = delete;
  ~UnpackSubByteVectorWritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-unpack-sub-byte-vector-write");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-unpack-sub-byte-vector-write"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Unpacks sub-byte vector writes.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnpackSubByteVectorWritePass");
  }
  ::llvm::StringRef getName() const override { return "UnpackSubByteVectorWritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::memref::MemRefDialect>();
    registry.insert<::mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnpackSubByteVectorWritePassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createUnpackSubByteVectorWritePass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createUnpackSubByteVectorWritePass() {
  return impl::createUnpackSubByteVectorWritePass();
}
#undef GEN_PASS_DEF_UNPACKSUBBYTEVECTORWRITEPASS
#endif // GEN_PASS_DEF_UNPACKSUBBYTEVECTORWRITEPASS

//===----------------------------------------------------------------------===//
// VectorToScalarPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORTOSCALARPASS
std::unique_ptr<::mlir::Pass> createVectorToScalarPass();
#undef GEN_PASS_DECL_VECTORTOSCALARPASS
#endif // GEN_PASS_DECL_VECTORTOSCALARPASS
#ifdef GEN_PASS_DEF_VECTORTOSCALARPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createVectorToScalarPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class VectorToScalarPassBase : public ::mlir::OperationPass<> {
public:
  using Base = VectorToScalarPassBase;

  VectorToScalarPassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  VectorToScalarPassBase(const VectorToScalarPassBase &other) : ::mlir::OperationPass<>(other) {}
  VectorToScalarPassBase& operator=(const VectorToScalarPassBase &) = delete;
  VectorToScalarPassBase(VectorToScalarPassBase &&) = delete;
  VectorToScalarPassBase& operator=(VectorToScalarPassBase &&) = delete;
  ~VectorToScalarPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-vector-to-scalar");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-vector-to-scalar"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert vector ops to scalar ops where possible.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorToScalarPass");
  }
  ::llvm::StringRef getName() const override { return "VectorToScalarPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorToScalarPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createVectorToScalarPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createVectorToScalarPass() {
  return impl::createVectorToScalarPass();
}
#undef GEN_PASS_DEF_VECTORTOSCALARPASS
#endif // GEN_PASS_DEF_VECTORTOSCALARPASS
#ifdef GEN_PASS_REGISTRATION
// Generate registrations for all passes.
#define GEN_PASS_REGISTRATION_FUSEELEMENTWISEPASS
#define GEN_PASS_REGISTRATION_INITIALIZEALLOCSPASS
#define GEN_PASS_REGISTRATION_LINALGELEMENTWISETOVECTORPASS
#define GEN_PASS_REGISTRATION_LOWERXTILEENTRYPASS
#define GEN_PASS_REGISTRATION_MEMREFCOPYTOLOOPSPASS
#define GEN_PASS_REGISTRATION_SHLOTOVECTORPASS
#define GEN_PASS_REGISTRATION_TENSOROPSTOBUFFERIZABLEPASS
#define GEN_PASS_REGISTRATION_UNPACKSUBBYTEVECTORWRITEPASS
#define GEN_PASS_REGISTRATION_VECTORTOSCALARPASS
#endif // GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// FuseElementwisePass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_FUSEELEMENTWISEPASS

inline void registerFuseElementwisePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFuseElementwisePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFuseElementwisePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createFuseElementwisePass();
  });
}

#undef GEN_PASS_REGISTRATION_FUSEELEMENTWISEPASS
#endif // GEN_PASS_REGISTRATION_FUSEELEMENTWISEPASS

//===----------------------------------------------------------------------===//
// InitializeAllocsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_INITIALIZEALLOCSPASS

inline void registerInitializeAllocsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createInitializeAllocsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerInitializeAllocsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createInitializeAllocsPass();
  });
}

#undef GEN_PASS_REGISTRATION_INITIALIZEALLOCSPASS
#endif // GEN_PASS_REGISTRATION_INITIALIZEALLOCSPASS

//===----------------------------------------------------------------------===//
// LinalgElementwiseToVectorPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_LINALGELEMENTWISETOVECTORPASS

inline void registerLinalgElementwiseToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLinalgElementwiseToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLinalgElementwiseToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLinalgElementwiseToVectorPass();
  });
}

#undef GEN_PASS_REGISTRATION_LINALGELEMENTWISETOVECTORPASS
#endif // GEN_PASS_REGISTRATION_LINALGELEMENTWISETOVECTORPASS

//===----------------------------------------------------------------------===//
// LowerXTileEntryPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_LOWERXTILEENTRYPASS

inline void registerLowerXTileEntryPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXTileEntryPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerXTileEntryPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXTileEntryPass();
  });
}

#undef GEN_PASS_REGISTRATION_LOWERXTILEENTRYPASS
#endif // GEN_PASS_REGISTRATION_LOWERXTILEENTRYPASS

//===----------------------------------------------------------------------===//
// MemrefCopyToLoopsPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_MEMREFCOPYTOLOOPSPASS

inline void registerMemrefCopyToLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemrefCopyToLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemrefCopyToLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemrefCopyToLoopsPass();
  });
}

#undef GEN_PASS_REGISTRATION_MEMREFCOPYTOLOOPSPASS
#endif // GEN_PASS_REGISTRATION_MEMREFCOPYTOLOOPSPASS

//===----------------------------------------------------------------------===//
// ShloToVectorPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_SHLOTOVECTORPASS

inline void registerShloToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateShloToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShloToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateShloToVectorPass();
  });
}

#undef GEN_PASS_REGISTRATION_SHLOTOVECTORPASS
#endif // GEN_PASS_REGISTRATION_SHLOTOVECTORPASS

//===----------------------------------------------------------------------===//
// TensorOpsToBufferizablePass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_TENSOROPSTOBUFFERIZABLEPASS

inline void registerTensorOpsToBufferizablePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorOpsToBufferizablePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorOpsToBufferizablePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorOpsToBufferizablePass();
  });
}

#undef GEN_PASS_REGISTRATION_TENSOROPSTOBUFFERIZABLEPASS
#endif // GEN_PASS_REGISTRATION_TENSOROPSTOBUFFERIZABLEPASS

//===----------------------------------------------------------------------===//
// UnpackSubByteVectorWritePass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_UNPACKSUBBYTEVECTORWRITEPASS

inline void registerUnpackSubByteVectorWritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUnpackSubByteVectorWritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnpackSubByteVectorWritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createUnpackSubByteVectorWritePass();
  });
}

#undef GEN_PASS_REGISTRATION_UNPACKSUBBYTEVECTORWRITEPASS
#endif // GEN_PASS_REGISTRATION_UNPACKSUBBYTEVECTORWRITEPASS

//===----------------------------------------------------------------------===//
// VectorToScalarPass Registration
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_REGISTRATION_VECTORTOSCALARPASS

inline void registerVectorToScalarPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVectorToScalarPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorToScalarPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createVectorToScalarPass();
  });
}

#undef GEN_PASS_REGISTRATION_VECTORTOSCALARPASS
#endif // GEN_PASS_REGISTRATION_VECTORTOSCALARPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// XTileCpuTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerXTileCpuTransformsPasses() {
  registerFuseElementwisePass();
  registerInitializeAllocsPass();
  registerLinalgElementwiseToVectorPass();
  registerLowerXTileEntryPass();
  registerMemrefCopyToLoopsPass();
  registerShloToVectorPass();
  registerTensorOpsToBufferizablePass();
  registerUnpackSubByteVectorWritePass();
  registerVectorToScalarPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
#ifdef GEN_PASS_CLASSES
#error "GEN_PASS_CLASSES is deprecated; use per-pass macros"
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
