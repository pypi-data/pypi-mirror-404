import collections.abc
import datetime
import enum
import typing
from _typeshed import Incomplete
from typing import Callable, ClassVar, overload

MISC: LiveDataObjectType
SNA: LiveDataObjectType

class APIEvent:
    class Severity(enum.IntEnum):
        __new__: ClassVar[Callable] = ...
        Any: ClassVar[APIEvent.Severity] = ...
        Error: ClassVar[APIEvent.Severity] = ...
        EventInfo: ClassVar[APIEvent.Severity] = ...
        EventWarning: ClassVar[APIEvent.Severity] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[int]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        def __format__(self, *args, **kwargs) -> str: ...

    class Type(enum.IntEnum):
        __new__: ClassVar[Callable] = ...
        A2BMessageIncompleteFrame: ClassVar[APIEvent.Type] = ...
        AnotherInTerminationGroupEnabled: ClassVar[APIEvent.Type] = ...
        Any: ClassVar[APIEvent.Type] = ...
        AppErrorParsingFailed: ClassVar[APIEvent.Type] = ...
        AtomicOperationCompletedNonatomically: ClassVar[APIEvent.Type] = ...
        AtomicOperationRetried: ClassVar[APIEvent.Type] = ...
        BaudrateNotFound: ClassVar[APIEvent.Type] = ...
        BufferInsufficient: ClassVar[APIEvent.Type] = ...
        CANFDNotSupported: ClassVar[APIEvent.Type] = ...
        CANFDSettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        CANSettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        CoreminiUploadVersionMismatch: ClassVar[APIEvent.Type] = ...
        DXXErrorArg: ClassVar[APIEvent.Type] = ...
        DXXErrorIO: ClassVar[APIEvent.Type] = ...
        DXXErrorInt: ClassVar[APIEvent.Type] = ...
        DXXErrorOverflow: ClassVar[APIEvent.Type] = ...
        DXXErrorSys: ClassVar[APIEvent.Type] = ...
        DeviceCurrentlyClosed: ClassVar[APIEvent.Type] = ...
        DeviceCurrentlyOffline: ClassVar[APIEvent.Type] = ...
        DeviceCurrentlyOnline: ClassVar[APIEvent.Type] = ...
        DeviceCurrentlyOpen: ClassVar[APIEvent.Type] = ...
        DeviceCurrentlyPolling: ClassVar[APIEvent.Type] = ...
        DeviceDisconnected: ClassVar[APIEvent.Type] = ...
        DeviceFirmwareOutOfDate: ClassVar[APIEvent.Type] = ...
        DeviceInUse: ClassVar[APIEvent.Type] = ...
        DeviceNotCurrentlyPolling: ClassVar[APIEvent.Type] = ...
        DiskFormatInvalidCount: ClassVar[APIEvent.Type] = ...
        DiskFormatNotSupported: ClassVar[APIEvent.Type] = ...
        DiskNotConnected: ClassVar[APIEvent.Type] = ...
        DiskNotSupported: ClassVar[APIEvent.Type] = ...
        DriverFailedToClose: ClassVar[APIEvent.Type] = ...
        DriverFailedToOpen: ClassVar[APIEvent.Type] = ...
        EOFReached: ClassVar[APIEvent.Type] = ...
        ErrorSettingSocketOption: ClassVar[APIEvent.Type] = ...
        EthPhyRegisterControlNotAvailable: ClassVar[APIEvent.Type] = ...
        FailedToBind: ClassVar[APIEvent.Type] = ...
        FailedToRead: ClassVar[APIEvent.Type] = ...
        FailedToWrite: ClassVar[APIEvent.Type] = ...
        FixedPointOverflow: ClassVar[APIEvent.Type] = ...
        FixedPointPrecision: ClassVar[APIEvent.Type] = ...
        GPTPNotSupported: ClassVar[APIEvent.Type] = ...
        GetIfAddrsError: ClassVar[APIEvent.Type] = ...
        I2CMessageExceedsMaxLength: ClassVar[APIEvent.Type] = ...
        IncorrectSerialNumber: ClassVar[APIEvent.Type] = ...
        InvalidNeoDevice: ClassVar[APIEvent.Type] = ...
        LINSettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        LSFTCANSettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        LiveDataCommandFailed: ClassVar[APIEvent.Type] = ...
        LiveDataDecoderError: ClassVar[APIEvent.Type] = ...
        LiveDataEncoderError: ClassVar[APIEvent.Type] = ...
        LiveDataInvalidArgument: ClassVar[APIEvent.Type] = ...
        LiveDataInvalidCommand: ClassVar[APIEvent.Type] = ...
        LiveDataInvalidHandle: ClassVar[APIEvent.Type] = ...
        LiveDataMaxSignalsReached: ClassVar[APIEvent.Type] = ...
        LiveDataNoDeviceResponse: ClassVar[APIEvent.Type] = ...
        LiveDataNotSupported: ClassVar[APIEvent.Type] = ...
        LiveDataVersionMismatch: ClassVar[APIEvent.Type] = ...
        MDIOMessageExceedsMaxLength: ClassVar[APIEvent.Type] = ...
        MessageFormattingError: ClassVar[APIEvent.Type] = ...
        MessageMaxLengthExceeded: ClassVar[APIEvent.Type] = ...
        ModeNotFound: ClassVar[APIEvent.Type] = ...
        NoDeviceResponse: ClassVar[APIEvent.Type] = ...
        NoErrorFound: ClassVar[APIEvent.Type] = ...
        NoSerialNumber: ClassVar[APIEvent.Type] = ...
        NoSerialNumber12V: ClassVar[APIEvent.Type] = ...
        NoSerialNumberFW: ClassVar[APIEvent.Type] = ...
        NoSerialNumberFW12V: ClassVar[APIEvent.Type] = ...
        NotSupported: ClassVar[APIEvent.Type] = ...
        OnlineNotSupported: ClassVar[APIEvent.Type] = ...
        OutputTruncated: ClassVar[APIEvent.Type] = ...
        PCAPCouldNotFindDevices: ClassVar[APIEvent.Type] = ...
        PCAPCouldNotStart: ClassVar[APIEvent.Type] = ...
        PacketChecksumError: ClassVar[APIEvent.Type] = ...
        PacketDecodingError: ClassVar[APIEvent.Type] = ...
        ParameterOutOfRange: ClassVar[APIEvent.Type] = ...
        PollingMessageOverflow: ClassVar[APIEvent.Type] = ...
        RTRNotSupported: ClassVar[APIEvent.Type] = ...
        RequiredParameterNull: ClassVar[APIEvent.Type] = ...
        RestrictedEntryFlag: ClassVar[APIEvent.Type] = ...
        SWCANSettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        SendToError: ClassVar[APIEvent.Type] = ...
        ServdBindError: ClassVar[APIEvent.Type] = ...
        ServdInvalidResponseError: ClassVar[APIEvent.Type] = ...
        ServdJoinMulticastError: ClassVar[APIEvent.Type] = ...
        ServdLockError: ClassVar[APIEvent.Type] = ...
        ServdNoDataError: ClassVar[APIEvent.Type] = ...
        ServdNonblockError: ClassVar[APIEvent.Type] = ...
        ServdOutdatedError: ClassVar[APIEvent.Type] = ...
        ServdPollError: ClassVar[APIEvent.Type] = ...
        ServdRecvError: ClassVar[APIEvent.Type] = ...
        ServdSendError: ClassVar[APIEvent.Type] = ...
        ServdTransceiveError: ClassVar[APIEvent.Type] = ...
        SettingNotAvaiableDevice: ClassVar[APIEvent.Type] = ...
        SettingsChecksumError: ClassVar[APIEvent.Type] = ...
        SettingsDefaultsUsed: ClassVar[APIEvent.Type] = ...
        SettingsLengthError: ClassVar[APIEvent.Type] = ...
        SettingsNotAvailable: ClassVar[APIEvent.Type] = ...
        SettingsReadError: ClassVar[APIEvent.Type] = ...
        SettingsReadOnly: ClassVar[APIEvent.Type] = ...
        SettingsStructureMismatch: ClassVar[APIEvent.Type] = ...
        SettingsStructureTruncated: ClassVar[APIEvent.Type] = ...
        SettingsVersionError: ClassVar[APIEvent.Type] = ...
        SocketFailedToOpen: ClassVar[APIEvent.Type] = ...
        SyscallError: ClassVar[APIEvent.Type] = ...
        TerminationNotSupportedDevice: ClassVar[APIEvent.Type] = ...
        TerminationNotSupportedNetwork: ClassVar[APIEvent.Type] = ...
        Timeout: ClassVar[APIEvent.Type] = ...
        TooManyEvents: ClassVar[APIEvent.Type] = ...
        TransmitBufferFull: ClassVar[APIEvent.Type] = ...
        UnexpectedNetworkType: ClassVar[APIEvent.Type] = ...
        UnexpectedResponse: ClassVar[APIEvent.Type] = ...
        Unknown: ClassVar[APIEvent.Type] = ...
        UnsupportedTXNetwork: ClassVar[APIEvent.Type] = ...
        VSABufferCorrupted: ClassVar[APIEvent.Type] = ...
        VSABufferFormatError: ClassVar[APIEvent.Type] = ...
        VSAByteParseFailure: ClassVar[APIEvent.Type] = ...
        VSAExtendedMessageError: ClassVar[APIEvent.Type] = ...
        VSAMaxReadAttemptsReached: ClassVar[APIEvent.Type] = ...
        VSAOtherError: ClassVar[APIEvent.Type] = ...
        VSATimestampNotFound: ClassVar[APIEvent.Type] = ...
        ValueNotYetPresent: ClassVar[APIEvent.Type] = ...
        WiVINotSupported: ClassVar[APIEvent.Type] = ...
        WiVIStackRefreshFailed: ClassVar[APIEvent.Type] = ...
        WiVIUploadStackOverflow: ClassVar[APIEvent.Type] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[int]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        def __format__(self, *args, **kwargs) -> str: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def describe(self) -> str: ...
    def get_description(self) -> str: ...
    def get_severity(self) -> APIEvent.Severity: ...
    def get_type(self) -> APIEvent.Type: ...

class CANErrorCode(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    AckError: ClassVar[CANErrorCode] = ...
    Bit0Error: ClassVar[CANErrorCode] = ...
    Bit1Error: ClassVar[CANErrorCode] = ...
    CRCError: ClassVar[CANErrorCode] = ...
    FormError: ClassVar[CANErrorCode] = ...
    NoChange: ClassVar[CANErrorCode] = ...
    NoError: ClassVar[CANErrorCode] = ...
    StuffError: ClassVar[CANErrorCode] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class CANErrorCountMessage(Message):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def busOff(self) -> bool: ...
    @property
    def dataErrorCode(self) -> CANErrorCode: ...
    @property
    def errorCode(self) -> CANErrorCode: ...
    @property
    def errorPassive(self) -> bool: ...
    @property
    def errorWarn(self) -> bool: ...
    @property
    def network(self) -> Network: ...
    @property
    def receiveErrorCount(self) -> int: ...
    @property
    def transmitErrorCount(self) -> int: ...

class CANErrorMessage(Message):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def busOff(self) -> bool: ...
    @property
    def dataErrorCode(self) -> CANErrorCode: ...
    @property
    def errorCode(self) -> CANErrorCode: ...
    @property
    def errorPassive(self) -> bool: ...
    @property
    def errorWarn(self) -> bool: ...
    @property
    def network(self) -> Network: ...
    @property
    def receiveErrorCount(self) -> int: ...
    @property
    def transmitErrorCount(self) -> int: ...

class CANMessage(Frame):
    arbid: int
    baudrateSwitch: bool
    dlcOnWire: int
    errorStateIndicator: bool
    isCANFD: bool
    isExtended: bool
    isRemote: bool
    def __init__(self) -> None: ...

class ChipID(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    Connect_LINUX: ClassVar[ChipID] = ...
    Connect_ZCHIP: ClassVar[ChipID] = ...
    EEVB_STM32: ClassVar[ChipID] = ...
    EtherBADGE_MCHIP: ClassVar[ChipID] = ...
    FlexRay_VNETZ_FCHIP: ClassVar[ChipID] = ...
    FlexRay_VNETZ_ZCHIP: ClassVar[ChipID] = ...
    Invalid: ClassVar[ChipID] = ...
    NewDevice57_ZCHIP: ClassVar[ChipID] = ...
    NewDevice59_MCHIP: ClassVar[ChipID] = ...
    RAD4G_MCHIP: ClassVar[ChipID] = ...
    RADA2B_REVB_ZCHIP: ClassVar[ChipID] = ...
    RADA2B_ZCHIP: ClassVar[ChipID] = ...
    RADBMS_MCHIP: ClassVar[ChipID] = ...
    RADCOMET3_ZCHIP: ClassVar[ChipID] = ...
    RADComet_ZYNQ: ClassVar[ChipID] = ...
    RADEpsilonExpress_MCHIP: ClassVar[ChipID] = ...
    RADEpsilonT_MCHIP: ClassVar[ChipID] = ...
    RADEpsilon_MCHIP: ClassVar[ChipID] = ...
    RADGALAXY2_SYSMON_CHIP: ClassVar[ChipID] = ...
    RADGalaxy_FFG_Zynq: ClassVar[ChipID] = ...
    RADGalaxy_ZYNQ: ClassVar[ChipID] = ...
    RADGemini_MCHIP: ClassVar[ChipID] = ...
    RADGigastar2_ZYNQ: ClassVar[ChipID] = ...
    RADGigastar_FFG_ZYNQ: ClassVar[ChipID] = ...
    RADGigastar_USBZ_Z7007S_ZYNQ: ClassVar[ChipID] = ...
    RADGigastar_USBZ_Z7010_ZYNQ: ClassVar[ChipID] = ...
    RADGigastar_USBZ_ZYNQ: ClassVar[ChipID] = ...
    RADGigastar_ZYNQ: ClassVar[ChipID] = ...
    RADIOCANHUB_MCHIP: ClassVar[ChipID] = ...
    RADJupiter_MCHIP: ClassVar[ChipID] = ...
    RADMars_3_ZYNQ: ClassVar[ChipID] = ...
    RADMars_ZYNQ: ClassVar[ChipID] = ...
    RADMoon2_Z7010_ZYNQ: ClassVar[ChipID] = ...
    RADMoon2_ZL_MCHIP: ClassVar[ChipID] = ...
    RADMoon2_ZYNQ: ClassVar[ChipID] = ...
    RADMoon3_MCHIP: ClassVar[ChipID] = ...
    RADMoonDuo_MCHIP: ClassVar[ChipID] = ...
    RADPluto_MCHIP: ClassVar[ChipID] = ...
    RADProxima_MCHIP: ClassVar[ChipID] = ...
    RADStar2_ZYNQ: ClassVar[ChipID] = ...
    RADStar_MCHIP: ClassVar[ChipID] = ...
    RADSupermoon_ZYNQ: ClassVar[ChipID] = ...
    RAD_GALAXY_2_ZMPCHIP_ID: ClassVar[ChipID] = ...
    SFPModule_MCHIP: ClassVar[ChipID] = ...
    VEM_01_8DW_ZCHIP: ClassVar[ChipID] = ...
    VEM_02_FR_FCHIP: ClassVar[ChipID] = ...
    VEM_02_FR_ZCHIP: ClassVar[ChipID] = ...
    ValueCAN3_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4Industrial_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4_1_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4_2EL_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4_2_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4_4_2EL_Core: ClassVar[ChipID] = ...
    ValueCAN4_4_MCHIP: ClassVar[ChipID] = ...
    ValueCAN4_4_SCHIP: ClassVar[ChipID] = ...
    ValueCANrf_MCHIP: ClassVar[ChipID] = ...
    VividCANPRO_EXT_FLASH: ClassVar[ChipID] = ...
    VividCANPRO_MCHIP: ClassVar[ChipID] = ...
    VividCAN_EXT_FLASH: ClassVar[ChipID] = ...
    VividCAN_MCHIP: ClassVar[ChipID] = ...
    VividCAN_NRF52: ClassVar[ChipID] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    cmProbe_ZYNQ: ClassVar[ChipID] = ...
    cmProbe_ZYNQ_Unused: ClassVar[ChipID] = ...
    neoECU12_MCHIP: ClassVar[ChipID] = ...
    neoECUAVBTSN_MCHIP: ClassVar[ChipID] = ...
    neoOBD2Dev_MCHIP: ClassVar[ChipID] = ...
    neoOBD2Dev_SCHIP: ClassVar[ChipID] = ...
    neoOBD2PRO_Core: ClassVar[ChipID] = ...
    neoOBD2PRO_MCHIP: ClassVar[ChipID] = ...
    neoOBD2PRO_SCHIP: ClassVar[ChipID] = ...
    neoOBD2SIMDoIP_MCHIP: ClassVar[ChipID] = ...
    neoOBD2SIM_MCHIP: ClassVar[ChipID] = ...
    neoOBD2_LCBADGE_MCHIP: ClassVar[ChipID] = ...
    neoOBD2_LCBADGE_SCHIP: ClassVar[ChipID] = ...
    neoVIANALOG_MPIC: ClassVar[ChipID] = ...
    neoVIAnalogOut_MCHIP: ClassVar[ChipID] = ...
    neoVIECU_MPIC: ClassVar[ChipID] = ...
    neoVIFIRE2_BLECHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_CCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_Core: ClassVar[ChipID] = ...
    neoVIFIRE2_Core_SG4: ClassVar[ChipID] = ...
    neoVIFIRE2_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_SECURITYCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_Slave_VNETZ_A_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_Slave_VNETZ_A_ZYNQ: ClassVar[ChipID] = ...
    neoVIFIRE2_Slave_VNET_A_CCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_Slave_VNET_A_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_VNETZ_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_VNETZ_ZYNQ: ClassVar[ChipID] = ...
    neoVIFIRE2_VNET_CCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_VNET_Core: ClassVar[ChipID] = ...
    neoVIFIRE2_VNET_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE2_ZYNQ: ClassVar[ChipID] = ...
    neoVIFIRE3_LINUX: ClassVar[ChipID] = ...
    neoVIFIRE3_SCHIP: ClassVar[ChipID] = ...
    neoVIFIRE3_ZCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_JCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_LCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_Slave_VNET_EP_LCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_Slave_VNET_EP_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_Slave_VNET_LCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_Slave_VNET_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_UCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_VNET_EP_LCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_VNET_EP_MCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_VNET_LCHIP: ClassVar[ChipID] = ...
    neoVIFIRE_VNET_MCHIP: ClassVar[ChipID] = ...
    neoVIIEVB_MPIC: ClassVar[ChipID] = ...
    neoVIION_Core: ClassVar[ChipID] = ...
    neoVIION_Core_Loader: ClassVar[ChipID] = ...
    neoVIION_FPGA_BIT: ClassVar[ChipID] = ...
    neoVIION_HID: ClassVar[ChipID] = ...
    neoVIION_HID_Loader: ClassVar[ChipID] = ...
    neoVIMOST150_MCHIP: ClassVar[ChipID] = ...
    neoVIMOST25_MCHIP: ClassVar[ChipID] = ...
    neoVIMOST50_MCHIP: ClassVar[ChipID] = ...
    neoVIPENDANT_MPIC: ClassVar[ChipID] = ...
    neoVIPLASMA_ANALOG_Core: ClassVar[ChipID] = ...
    neoVIPLASMA_Core: ClassVar[ChipID] = ...
    neoVIPLASMA_Core_1_12: ClassVar[ChipID] = ...
    neoVIPLASMA_FlexRay_Core: ClassVar[ChipID] = ...
    neoVIPLASMA_HID: ClassVar[ChipID] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class Clause22Message:
    page: int
    phyAddr: int
    regAddr: int
    regVal: int
    def __init__(self, *args, **kwargs) -> None: ...

class Clause45Message:
    device: int
    port: int
    regAddr: int
    regVal: int
    def __init__(self, *args, **kwargs) -> None: ...

class Device:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_message_callback(self, arg0: MessageCallback) -> int: ...
    def clear_all_live_data(self) -> bool: ...
    def clear_script(self, arg0: Disk.MemoryType) -> bool: ...
    def close(self) -> bool: ...
    def describe(self) -> str: ...
    def disable_message_polling(self) -> bool: ...
    def enable_message_polling(self, filter: MessageFilter | None = ...) -> bool: ...
    def get_chip_versions(self, refreshComponents: bool = ...) -> list[VersionReport]: ...
    def get_current_message_count(self) -> int: ...
    def get_digital_io(self, type: IO, number: typing.SupportsInt) -> bool | None: ...
    def get_extension(self, *args, **kwargs): ...
    def get_flexray_controllers(self) -> list[FlexRay.Controller]: ...
    def get_gptp_status(self, timeout: datetime.timedelta = ...) -> GPTPStatus | None: ...
    def get_messages(self) -> tuple[list[Message], bool]: ...
    def get_polling_message_limit(self) -> int: ...
    def get_product_name(self) -> str: ...
    def get_rtc(self) -> datetime.datetime | None: ...
    def get_script_status(self) -> ScriptStatusMessage: ...
    def get_serial(self) -> str: ...
    def get_serial_number(self) -> int: ...
    def get_supported_rx_networks(self) -> list[Network]: ...
    def get_supported_tx_networks(self) -> list[Network]: ...
    def get_tc10_status(self, arg0: Network.NetID) -> TC10StatusMessage | None: ...
    def get_type(self) -> DeviceType: ...
    def go_offline(self) -> bool: ...
    def go_online(self) -> bool: ...
    def is_message_polling_enabled(self) -> bool: ...
    def is_online(self) -> bool: ...
    def is_online_supported(self) -> bool: ...
    def is_open(self) -> bool: ...
    def open(self) -> bool: ...
    def prepare_script_load(self) -> int: ...
    def remove_message_callback(self, arg0: typing.SupportsInt) -> bool: ...
    def request_tc10_sleep(self, arg0: Network.NetID) -> bool: ...
    def request_tc10_wake(self, arg0: Network.NetID) -> bool: ...
    def send_eth_phy_msg(self, message: EthPhyMessage, timeout: datetime.timedelta = ...) -> EthPhyMessage | None: ...
    def set_digital_io(self, type: IO, number: typing.SupportsInt, value: bool) -> bool: ...
    def set_polling_message_limit(self, arg0: typing.SupportsInt) -> None: ...
    def set_rtc(self, arg0: datetime.datetime) -> bool: ...
    def set_value_live_data(self, message: LiveDataSetValueMessage) -> bool: ...
    def start_script(self, arg0: Disk.MemoryType) -> bool: ...
    def stop_script(self) -> bool: ...
    def subscribe_live_data(self, message: LiveDataCommandMessage) -> bool: ...
    def supports_live_data(self) -> bool: ...
    def supports_tc10(self) -> bool: ...
    def transmit(self, arg0: Frame) -> bool: ...
    def unsubscribe_live_data(self, handle: typing.SupportsInt) -> bool: ...
    def upload_coremini(self, arg0: str, arg1: Disk.MemoryType) -> bool: ...
    def write_macsec_config(self, arg0: MACsecConfig) -> bool: ...
    @property
    def settings(self): ...

class DeviceExtension:
    def __init__(self, *args, **kwargs) -> None: ...
    def get_name(self) -> str: ...

class DeviceType:
    class Enum(enum.IntEnum):
        __new__: ClassVar[Callable] = ...
        BLUE: ClassVar[DeviceType.Enum] = ...
        CMProbe: ClassVar[DeviceType.Enum] = ...
        CT_OBD: ClassVar[DeviceType.Enum] = ...
        Connect: ClassVar[DeviceType.Enum] = ...
        DONT_REUSE0: ClassVar[DeviceType.Enum] = ...
        DONT_REUSE1: ClassVar[DeviceType.Enum] = ...
        DONT_REUSE2: ClassVar[DeviceType.Enum] = ...
        DONT_REUSE3: ClassVar[DeviceType.Enum] = ...
        DW_VCAN: ClassVar[DeviceType.Enum] = ...
        ECU: ClassVar[DeviceType.Enum] = ...
        ECUChip_UART: ClassVar[DeviceType.Enum] = ...
        ECU_AVB: ClassVar[DeviceType.Enum] = ...
        EEVB: ClassVar[DeviceType.Enum] = ...
        EtherBADGE: ClassVar[DeviceType.Enum] = ...
        FIRE: ClassVar[DeviceType.Enum] = ...
        FIRE2: ClassVar[DeviceType.Enum] = ...
        FIRE3: ClassVar[DeviceType.Enum] = ...
        FIRE3_FlexRay: ClassVar[DeviceType.Enum] = ...
        FIRE3_T1S_LIN: ClassVar[DeviceType.Enum] = ...
        FIRE3_T1S_SENT: ClassVar[DeviceType.Enum] = ...
        Flex: ClassVar[DeviceType.Enum] = ...
        IEVB: ClassVar[DeviceType.Enum] = ...
        ION: ClassVar[DeviceType.Enum] = ...
        NEOAnalog: ClassVar[DeviceType.Enum] = ...
        NEOECU12: ClassVar[DeviceType.Enum] = ...
        OBD2_LCBADGE: ClassVar[DeviceType.Enum] = ...
        OBD2_PRO: ClassVar[DeviceType.Enum] = ...
        OBD2_SIM: ClassVar[DeviceType.Enum] = ...
        PLASMA: ClassVar[DeviceType.Enum] = ...
        Pendant: ClassVar[DeviceType.Enum] = ...
        RADComet: ClassVar[DeviceType.Enum] = ...
        RADComet3: ClassVar[DeviceType.Enum] = ...
        RADEpsilon: ClassVar[DeviceType.Enum] = ...
        RADEpsilonXL: ClassVar[DeviceType.Enum] = ...
        RADGalaxy: ClassVar[DeviceType.Enum] = ...
        RADGalaxy2: ClassVar[DeviceType.Enum] = ...
        RADGemini: ClassVar[DeviceType.Enum] = ...
        RADGigastar: ClassVar[DeviceType.Enum] = ...
        RADGigastar2: ClassVar[DeviceType.Enum] = ...
        RADIO_CANHUB: ClassVar[DeviceType.Enum] = ...
        RADJupiter: ClassVar[DeviceType.Enum] = ...
        RADMars: ClassVar[DeviceType.Enum] = ...
        RADMoon2: ClassVar[DeviceType.Enum] = ...
        RADMoon3: ClassVar[DeviceType.Enum] = ...
        RADMoonDuo: ClassVar[DeviceType.Enum] = ...
        RADMoonT1S: ClassVar[DeviceType.Enum] = ...
        RADPluto: ClassVar[DeviceType.Enum] = ...
        RADStar: ClassVar[DeviceType.Enum] = ...
        RADStar2: ClassVar[DeviceType.Enum] = ...
        RADSupermoon: ClassVar[DeviceType.Enum] = ...
        RAD_A2B: ClassVar[DeviceType.Enum] = ...
        RED: ClassVar[DeviceType.Enum] = ...
        RED2: ClassVar[DeviceType.Enum] = ...
        Unknown: ClassVar[DeviceType.Enum] = ...
        VCAN3: ClassVar[DeviceType.Enum] = ...
        VCAN4_1: ClassVar[DeviceType.Enum] = ...
        VCAN4_2: ClassVar[DeviceType.Enum] = ...
        VCAN4_2EL: ClassVar[DeviceType.Enum] = ...
        VCAN4_4: ClassVar[DeviceType.Enum] = ...
        VCAN4_IND: ClassVar[DeviceType.Enum] = ...
        VCANrf: ClassVar[DeviceType.Enum] = ...
        VividCAN: ClassVar[DeviceType.Enum] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[int]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        def __format__(self, *args, **kwargs) -> str: ...
    def __init__(self, arg0: DeviceType.Enum) -> None: ...
    def get_device_type(self) -> DeviceType.Enum: ...
    def get_generic_product_name(self) -> str: ...

class Disk:
    class Access:
        __members__: ClassVar[dict] = ...  # read-only
        EntireCard: ClassVar[Disk.Access] = ...
        VSA: ClassVar[Disk.Access] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class MemoryType:
        __members__: ClassVar[dict] = ...  # read-only
        Flash: ClassVar[Disk.MemoryType] = ...
        SD: ClassVar[Disk.MemoryType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...

class EthPhyMessage(Message):
    messages: list[PhyMessage]
    def __init__(self) -> None: ...

class EthernetMessage(Frame):
    crcError: bool
    fcs: int | None
    fcsVerified: bool
    frameTooShort: bool
    isT1S: bool
    isT1SBurst: bool
    isT1SSymbol: bool
    isT1SWake: bool
    noPadding: bool
    preemptionEnabled: bool
    preemptionFlags: int
    t1sBurstCount: int
    t1sNodeId: int
    t1sSymbolType: int
    txAborted: bool
    txCollision: bool
    def __init__(self) -> None: ...
    def get_destination_mac(self) -> MACAddress: ...
    def get_ether_type(self) -> int: ...
    def get_source_mac(self) -> MACAddress: ...

class EthernetStatusMessage(Message):
    class LinkMode:
        __members__: ClassVar[dict] = ...  # read-only
        LinkModeAuto: ClassVar[EthernetStatusMessage.LinkMode] = ...
        LinkModeInvalid: ClassVar[EthernetStatusMessage.LinkMode] = ...
        LinkModeMaster: ClassVar[EthernetStatusMessage.LinkMode] = ...
        LinkModeNone: ClassVar[EthernetStatusMessage.LinkMode] = ...
        LinkModeSlave: ClassVar[EthernetStatusMessage.LinkMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class LinkSpeed:
        __members__: ClassVar[dict] = ...  # read-only
        LinkSpeed10: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeed100: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeed1000: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeed10000: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeed2500: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeed5000: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        LinkSpeedAuto: ClassVar[EthernetStatusMessage.LinkSpeed] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def duplex(self) -> bool: ...
    @property
    def mode(self) -> EthernetStatusMessage.LinkMode: ...
    @property
    def network(self) -> Network: ...
    @property
    def speed(self) -> EthernetStatusMessage.LinkSpeed: ...
    @property
    def state(self) -> bool: ...

class EventCallback:
    @overload
    def __init__(self, arg0: collections.abc.Callable[[APIEvent], None], arg1: EventFilter) -> None: ...
    @overload
    def __init__(self, arg0: collections.abc.Callable[[APIEvent], None]) -> None: ...

class EventFilter:
    serial: str
    severity: APIEvent.Severity
    type: APIEvent.Type
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: APIEvent.Type) -> None: ...
    @overload
    def __init__(self, arg0: APIEvent.Severity) -> None: ...

class EventManager:
    def __init__(self, *args, **kwargs) -> None: ...
    def add_event_callback(self, arg0: EventCallback) -> int: ...
    @staticmethod
    def get_instance() -> EventManager: ...
    def get_last_error(self) -> APIEvent: ...
    def remove_event_callback(self, arg0: typing.SupportsInt) -> bool: ...

class FlexRay:
    class CRCStatus:
        __members__: ClassVar[dict] = ...  # read-only
        Error: ClassVar[FlexRay.CRCStatus] = ...
        NoCRC: ClassVar[FlexRay.CRCStatus] = ...
        OK: ClassVar[FlexRay.CRCStatus] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Channel:
        __members__: ClassVar[dict] = ...  # read-only
        A: ClassVar[FlexRay.Channel] = ...
        AB: ClassVar[FlexRay.Channel] = ...
        B: ClassVar[FlexRay.Channel] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Cluster:
        class Configuration:
            action_point_offset: int
            casr_x_low_max: int
            cold_start_attempts: int
            cycle_duration_micro_sec: int
            dynamic_slot_idle_phase_minislots: int
            listen_noise_macroticks: int
            macrotick_duration_micro_sec: int
            macroticks_per_cycle: int
            max_without_clock_correction_fatal: int
            max_without_clock_correction_passive: int
            minislot_action_point_offset_macroticks: int
            minislot_duration_macroticks: int
            network_idle_time_macroticks: int
            network_management_vector_length_bytes: int
            number_of_minislots: int
            number_of_static_slots: int
            offset_correction_start_macroticks: int
            payload_length_of_static_slot_in_words: int
            speed: FlexRay.Cluster.SpeedType
            static_slot_macroticks: int
            strobe_point_position: FlexRay.Cluster.SPPType
            symbol_window_action_point_offset_macroticks: int
            symbol_window_macroticks: int
            sync_frame_id_count_max: int
            transmission_start_sequence_duration_bits: int
            wakeup_rx_idle_bits: int
            wakeup_rx_low_bits: int
            wakeup_rx_window_bits: int
            wakeup_tx_active_bits: int
            wakeup_tx_idle_bits: int
            def __init__(self) -> None: ...

        class SPPType:
            __members__: ClassVar[dict] = ...  # read-only
            FLEXRAY_SPP_4: ClassVar[FlexRay.Cluster.SPPType] = ...
            FLEXRAY_SPP_5: ClassVar[FlexRay.Cluster.SPPType] = ...
            FLEXRAY_SPP_5_ALT: ClassVar[FlexRay.Cluster.SPPType] = ...
            FLEXRAY_SPP_6: ClassVar[FlexRay.Cluster.SPPType] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: typing.SupportsInt) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...

        class SpeedType:
            __members__: ClassVar[dict] = ...  # read-only
            FLEXRAY_BAUDRATE_10M: ClassVar[FlexRay.Cluster.SpeedType] = ...
            FLEXRAY_BAUDRATE_2M5: ClassVar[FlexRay.Cluster.SpeedType] = ...
            FLEXRAY_BAUDRATE_2M5_ALT: ClassVar[FlexRay.Cluster.SpeedType] = ...
            FLEXRAY_BAUDRATE_5M: ClassVar[FlexRay.Cluster.SpeedType] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: typing.SupportsInt) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        def __init__(self, *args, **kwargs) -> None: ...

    class Controller:
        class Configuration:
            accept_startup_range_microticks: int
            allow_halt_due_to_clock: bool
            allow_passive_to_active_cycle_pairs: int
            channel_a: bool
            channel_b: bool
            cluster_drift_damping: int
            decoding_correction_microticks: int
            delay_compensation_a_microticks: int
            delay_compensation_b_microticks: int
            extern_offset_correction_control: int
            extern_offset_correction_microticks: int
            extern_rate_correction_control: int
            extern_rate_correction_microticks: int
            key_slot_id: int
            key_slot_only_enabled: bool
            key_slot_used_for_startup: bool
            key_slot_used_for_sync: bool
            latest_tx_minislot: int
            listen_timeout: int
            macro_initial_offset_a: int
            macro_initial_offset_b: int
            micro_initial_offset_a: int
            micro_initial_offset_b: int
            micro_per_cycle: int
            mts_on_a: bool
            mts_on_b: bool
            offset_correction_out_microticks: int
            rate_correction_out_microticks: int
            second_key_slot_id: int
            two_key_slot_mode: bool
            wakeup_on_channel_b: bool
            wakeup_pattern: int
            def __init__(self) -> None: ...
        def __init__(self, *args, **kwargs) -> None: ...
        def add_message_buffer(self, arg0: FlexRay.MessageBuffer) -> None: ...
        def clear_message_buffers(self) -> None: ...
        def configure(self, *args, **kwargs): ...
        def freeze(self, *args, **kwargs): ...
        def get_allow_coldstart(self) -> bool: ...
        def get_configuration(self, *args, **kwargs): ...
        def get_network(self) -> Network: ...
        def get_start_when_going_online(self) -> bool: ...
        def get_wakeup_before_start(self) -> bool: ...
        def halt(self, *args, **kwargs): ...
        def set_allow_coldstart(self, arg0: bool) -> None: ...
        def set_configuration(self, arg0, arg1) -> None: ...
        def set_start_when_going_online(self, arg0: bool) -> None: ...
        def set_wakeup_before_start(self, arg0: bool) -> None: ...
        def start(self, *args, **kwargs): ...
        def transmit(self, arg0: FlexRayMessage) -> bool: ...
        def trigger_mts(self, *args, **kwargs): ...
        def wakeup(self, *args, **kwargs): ...

    class MessageBuffer:
        base_cycle: int
        channel_a: bool
        channel_b: bool
        continuous_mode: bool
        cycle_repetition: int
        frame_id: int
        frame_length_bytes: int
        is_dynamic: bool
        is_network_management_frame: bool
        is_startup: bool
        is_sync: bool
        is_transmit: bool
        def __init__(self) -> None: ...

    class Symbol:
        __members__: ClassVar[dict] = ...  # read-only
        CAS: ClassVar[FlexRay.Symbol] = ...
        Unknown: ClassVar[FlexRay.Symbol] = ...
        Wakeup: ClassVar[FlexRay.Symbol] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...

class FlexRayMessage(Frame):
    channel: FlexRay.Channel
    cycle: int
    cycle_repetition: int
    dynamic_frame: bool
    frame_crc: int
    frame_crc_status: FlexRay.CRCStatus
    framelen: float
    header_crc: int
    header_crc_status: FlexRay.CRCStatus
    null_frame: bool
    payload_preamble: bool
    slotid: int
    startup_frame: bool
    symbol: FlexRay.Symbol
    sync_frame: bool
    tsslen: float
    def __init__(self) -> None: ...

class Frame(RawMessage):
    description: int
    error: bool
    transmitted: bool
    def __init__(self, *args, **kwargs) -> None: ...

class GPTPStatus(Message):
    class ClockQuality:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def clock_accuracy(self) -> int: ...
        @property
        def clock_class(self) -> int: ...
        @property
        def offset_scaled_log_variance(self) -> int: ...

    class CurrentDS:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def gm_change_count(self) -> int: ...
        @property
        def gm_time_base_indicator(self) -> int: ...
        @property
        def lastgm_freq_change(self) -> float: ...
        @property
        def lastgm_phase_change(self) -> GPTPStatus.ScaledNanoSeconds: ...
        @property
        def offset_from_master(self) -> int: ...
        @property
        def steps_removed(self) -> int: ...
        @property
        def time_of_lastgm_change_event(self) -> int: ...
        @property
        def time_of_lastgm_freq_change_event(self) -> int: ...
        @property
        def time_of_lastgm_phase_change_event(self) -> int: ...

    class ParentDS:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def cumulative_rate_ratio(self) -> int: ...
        @property
        def gm_clock_quality_clock_accuracy(self) -> int: ...
        @property
        def gm_clock_quality_clock_class(self) -> int: ...
        @property
        def gm_clock_quality_offset_scaled_log_variance(self) -> int: ...
        @property
        def gm_priority1(self) -> int: ...
        @property
        def gm_priority2(self) -> int: ...
        @property
        def grandmaster_identity(self) -> int: ...
        @property
        def parent_port_identity(self) -> GPTPStatus.PortID: ...

    class PortID:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def clock_identity(self) -> int: ...
        @property
        def port_number(self) -> int: ...

    class PriorityVector:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def port_id(self) -> GPTPStatus.PortID: ...
        @property
        def port_number(self) -> int: ...
        @property
        def steps_removed(self) -> int: ...
        @property
        def sys_id(self) -> GPTPStatus.SystemID: ...

    class ScaledNanoSeconds:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def fractional_nanoseconds(self) -> int: ...
        @property
        def nanoseconds_lsb(self) -> int: ...
        @property
        def nanoseconds_msb(self) -> int: ...

    class SystemID:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def clock_id(self) -> int: ...
        @property
        def clock_quality(self) -> GPTPStatus.ClockQuality: ...
        @property
        def priority1(self) -> int: ...
        @property
        def priority2(self) -> int: ...

    class Timestamp:
        def __init__(self, *args, **kwargs) -> None: ...
        def to_seconds(self) -> float: ...
        @property
        def nanoseconds(self) -> int: ...
        @property
        def seconds(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def as_capable(self) -> int: ...
    @property
    def current_ds(self) -> GPTPStatus.CurrentDS: ...
    @property
    def current_time(self) -> GPTPStatus.Timestamp: ...
    @property
    def gm_priority(self) -> GPTPStatus.PriorityVector: ...
    @property
    def is_sync(self) -> int: ...
    @property
    def is_syntonized(self) -> int: ...
    @property
    def last_rx_sync_ts(self) -> GPTPStatus.Timestamp: ...
    @property
    def link_delay_ns(self) -> int: ...
    @property
    def link_status(self) -> int: ...
    @property
    def ms_offset_ns(self) -> int: ...
    @property
    def parent_ds(self) -> GPTPStatus.ParentDS: ...
    @property
    def selected_role(self) -> int: ...
    @property
    def short_format(self) -> bool: ...

class IDeviceSettings:
    def __init__(self, *args, **kwargs) -> None: ...
    def apply(self, temporary: bool = ...) -> bool: ...
    def apply_defaults(self, temporary: bool = ...) -> bool: ...
    def can_termination_be_enabled(self, arg0: Network) -> bool: ...
    def get_baudrate(self, arg0: Network) -> int: ...
    def get_fd_baudrate(self, arg0: Network) -> int: ...
    def get_lin_commander_response_time(self, arg0: Network) -> int | None: ...
    def get_lin_mode(self, arg0: Network) -> Settings.LINMode | None: ...
    def get_phy_enable(self, arg0: typing.SupportsInt) -> bool | None: ...
    def get_phy_enable_for(self, arg0: Network) -> bool | None: ...
    def get_phy_link_mode_for(self, arg0: Network) -> Settings.PhyLinkMode | None: ...
    def get_phy_mode(self, arg0: typing.SupportsInt) -> Settings.EthernetLinkMode | None: ...
    def get_phy_role_for(self, arg0: Network) -> Settings.EthernetLinkMode | None: ...
    def get_phy_speed(self, arg0: typing.SupportsInt) -> Settings.PhyLinkMode | None: ...
    def get_supported_phy_link_modes_for(self, arg0: Network) -> list[Settings.PhyLinkMode]: ...
    def get_t1s_burst_timer(self, arg0: Network) -> int | None: ...
    def get_t1s_local_id(self, arg0: Network) -> int | None: ...
    def get_t1s_max_burst(self, arg0: Network) -> int | None: ...
    def get_t1s_max_nodes(self, arg0: Network) -> int | None: ...
    def get_t1s_tx_opp_timer(self, arg0: Network) -> int | None: ...
    def get_termination_groups(self) -> list[list[Network]]: ...
    def is_commander_resistor_enabled(self, arg0: Network) -> bool | None: ...
    def is_t1s_plca_enabled(self, arg0: Network) -> bool | None: ...
    def is_termination_enabled(self, arg0: Network) -> bool | None: ...
    def is_termination_supported(self, arg0: Network) -> bool: ...
    def refresh(self) -> bool: ...
    def set_baudrate(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_commander_resistor(self, arg0: Network, arg1: bool) -> bool: ...
    def set_fd_baudrate(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_lin_commander_response_time(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_lin_mode(self, arg0: Network, arg1: Settings.LINMode) -> bool: ...
    def set_phy_enable(self, arg0: typing.SupportsInt, arg1: bool) -> bool: ...
    def set_phy_enable_for(self, arg0: Network, arg1: bool) -> bool: ...
    def set_phy_link_mode_for(self, arg0: Network, arg1: Settings.PhyLinkMode) -> bool: ...
    def set_phy_mode(self, arg0: typing.SupportsInt, arg1: Settings.EthernetLinkMode) -> bool: ...
    def set_phy_role_for(self, arg0: Network, arg1: Settings.EthernetLinkMode) -> bool: ...
    def set_phy_speed(self, arg0: typing.SupportsInt, arg1: Settings.PhyLinkMode) -> bool: ...
    def set_t1s_burst_timer(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_t1s_local_id(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_t1s_max_burst(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_t1s_max_nodes(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_t1s_plca(self, arg0: Network, arg1: bool) -> bool: ...
    def set_t1s_tx_opp_timer(self, arg0: Network, arg1: typing.SupportsInt) -> bool: ...
    def set_termination(self, arg0: Network, arg1: bool) -> bool: ...
    @property
    def disabled(self) -> bool: ...
    @property
    def readonly(self) -> bool: ...

class IO:
    __members__: ClassVar[dict] = ...  # read-only
    BackupPowerEnabled: ClassVar[IO] = ...
    BackupPowerGood: ClassVar[IO] = ...
    EMisc: ClassVar[IO] = ...
    EthernetActivation: ClassVar[IO] = ...
    Misc: ClassVar[IO] = ...
    USBHostPower: ClassVar[IO] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LINErrorFlags:
    ErrChecksumMatch: bool
    ErrFrameMessageID: bool
    ErrFrameResponderData: bool
    ErrFrameSync: bool
    ErrRxBreakNotZero: bool
    ErrRxBreakOnly: bool
    ErrRxBreakSyncOnly: bool
    ErrRxBreakTooShort: bool
    ErrRxDataLenOver8: bool
    ErrRxSyncNot55: bool
    ErrTxRxMismatch: bool
    def __init__(self, *args, **kwargs) -> None: ...

class LINMessage(Frame):
    class Type:
        __members__: ClassVar[dict] = ...  # read-only
        LIN_BREAK_ONLY: ClassVar[LINMessage.Type] = ...
        LIN_COMMANDER_MSG: ClassVar[LINMessage.Type] = ...
        LIN_ERROR: ClassVar[LINMessage.Type] = ...
        LIN_HEADER_ONLY: ClassVar[LINMessage.Type] = ...
        LIN_SYNC_ONLY: ClassVar[LINMessage.Type] = ...
        LIN_UPDATE_RESPONDER: ClassVar[LINMessage.Type] = ...
        NOT_SET: ClassVar[LINMessage.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    ID: int
    checksum: int
    errFlags: LINErrorFlags
    isEnhancedChecksum: bool
    linMsgType: LINMessage.Type
    protectedID: int
    statusFlags: LINStatusFlags
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: typing.SupportsInt) -> None: ...
    @staticmethod
    def calc_checksum(arg0: LINMessage) -> None: ...
    def calc_protected_id(self, arg0: typing.SupportsInt) -> int: ...

class LINStatusFlags:
    BreakOnly: bool
    BusRecovered: bool
    HasUpdatedResponderOnce: bool
    TxAborted: bool
    TxChecksumEnhanced: bool
    TxCommander: bool
    TxResponder: bool
    UpdateResponderOnce: bool
    def __init__(self, *args, **kwargs) -> None: ...

class LiveDataArgument:
    object_index: int
    object_type: Incomplete
    signal_index: int
    value_type: Incomplete
    def __init__(self) -> None: ...

class LiveDataCommand(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    CLEAR_ALL: ClassVar[LiveDataCommand] = ...
    RESPONSE: ClassVar[LiveDataCommand] = ...
    SET_VALUE: ClassVar[LiveDataCommand] = ...
    STATUS: ClassVar[LiveDataCommand] = ...
    SUBSCRIBE: ClassVar[LiveDataCommand] = ...
    UNSUBSCRIBE: ClassVar[LiveDataCommand] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class LiveDataCommandMessage(LiveDataMessage):
    args: list[LiveDataArgument]
    expiration_time: datetime.timedelta
    update_period: datetime.timedelta
    def __init__(self) -> None: ...
    def append_signal_arg(self, value_type: LiveDataValueType) -> None: ...

class LiveDataMessage(RawMessage):
    cmd: LiveDataCommand
    handle: int
    def __init__(self) -> None: ...

class LiveDataObjectType:
    __members__: ClassVar[dict] = ...  # read-only
    MISC: ClassVar[LiveDataObjectType] = ...
    SNA: ClassVar[LiveDataObjectType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LiveDataSetValueMessage(LiveDataMessage):
    args: list[LiveDataArgument]
    values: list[LiveDataValue]
    def __init__(self) -> None: ...
    def append_set_value(self, value_type: LiveDataValueType, value: LiveDataValue) -> None: ...

class LiveDataStatus(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    ERR_DUPLICATE: ClassVar[LiveDataStatus] = ...
    ERR_FULL: ClassVar[LiveDataStatus] = ...
    ERR_HANDLE: ClassVar[LiveDataStatus] = ...
    ERR_UNKNOWN_COMMAND: ClassVar[LiveDataStatus] = ...
    SUCCESS: ClassVar[LiveDataStatus] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class LiveDataStatusMessage(LiveDataMessage):
    requested_command: LiveDataCommand
    status: LiveDataStatus
    def __init__(self) -> None: ...

class LiveDataValue:
    value: int
    def __init__(self) -> None: ...

class LiveDataValueMessage(LiveDataMessage):
    num_args: int
    values: list[LiveDataValue]
    def __init__(self) -> None: ...

class LiveDataValueType(enum.IntEnum):
    __new__: ClassVar[Callable] = ...
    DAQ_ENABLE: ClassVar[LiveDataValueType] = ...
    GPS_ACCURACY: ClassVar[LiveDataValueType] = ...
    GPS_ALTITUDE: ClassVar[LiveDataValueType] = ...
    GPS_BEARING: ClassVar[LiveDataValueType] = ...
    GPS_ENABLE: ClassVar[LiveDataValueType] = ...
    GPS_LATITUDE: ClassVar[LiveDataValueType] = ...
    GPS_LONGITUDE: ClassVar[LiveDataValueType] = ...
    GPS_SPEED: ClassVar[LiveDataValueType] = ...
    GPS_TIME: ClassVar[LiveDataValueType] = ...
    GPS_TIME_VALID: ClassVar[LiveDataValueType] = ...
    GPS_VALID: ClassVar[LiveDataValueType] = ...
    MANUAL_TRIGGER: ClassVar[LiveDataValueType] = ...
    TIME_SINCE_MSG: ClassVar[LiveDataValueType] = ...
    _generate_next_value_: ClassVar[Callable] = ...
    _member_map_: ClassVar[dict] = ...
    _member_names_: ClassVar[list] = ...
    _member_type_: ClassVar[type[int]] = ...
    _unhashable_values_: ClassVar[list] = ...
    _use_args_: ClassVar[bool] = ...
    _value2member_map_: ClassVar[dict] = ...
    def __format__(self, *args, **kwargs) -> str: ...

class MACAddress:
    def __init__(self, *args, **kwargs) -> None: ...
    def to_string(self) -> str: ...

class MACsecCipherSuite:
    __members__: ClassVar[dict] = ...  # read-only
    GCM_AES_128: ClassVar[MACsecCipherSuite] = ...
    GCM_AES_128_XPN: ClassVar[MACsecCipherSuite] = ...
    GCM_AES_256: ClassVar[MACsecCipherSuite] = ...
    GCM_AES_256_XPN: ClassVar[MACsecCipherSuite] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MACsecConfig:
    def __init__(self, arg0: DeviceType) -> None: ...
    def add_rx_rule(self, arg0: MACsecRxRule, arg1: typing.SupportsInt) -> int: ...
    def add_rx_sa(self, arg0: MACsecRxSa) -> int: ...
    def add_rx_secy(self, arg0: MACsecRxSecY, arg1: typing.SupportsInt) -> int: ...
    def add_tx_sa(self, arg0: MACsecTxSa) -> int: ...
    def add_tx_secY(self, arg0: MACsecTxSecY, arg1: typing.SupportsInt) -> int: ...
    def clear(self) -> None: ...
    def disable_rx_rekey(self, arg0: typing.SupportsInt) -> None: ...
    def disable_tx_rekey(self, arg0: typing.SupportsInt) -> None: ...
    def enable_rx_rekey(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...
    def enable_tx_rekey(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...
    def get_bin_index(self) -> int: ...
    def get_max_num_rule(self) -> int: ...
    def get_max_num_sa(self) -> int: ...
    def get_max_num_secy(self) -> int: ...
    def get_rx_rule(self, arg0: typing.SupportsInt) -> MACsecRxRule: ...
    def get_rx_sa(self, arg0: typing.SupportsInt) -> MACsecRxSa: ...
    def get_rx_secy(self, arg0: typing.SupportsInt) -> MACsecRxSecY: ...
    def get_tx_sa(self, arg0: typing.SupportsInt) -> MACsecTxSa: ...
    def get_tx_secy(self, arg0: typing.SupportsInt) -> MACsecTxSecY: ...
    def get_type(self) -> DeviceType: ...
    def serialize(self) -> list[int]: ...
    def set_rx_enable(self, arg0: bool) -> None: ...
    def set_rx_sa_index(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...
    def set_rx_sa_rekey_index(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...
    def set_storage(self, arg0: bool) -> None: ...
    def set_tx_enable(self, arg0: bool) -> None: ...
    def set_tx_sa_index(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...
    def set_tx_sa_rekey_index(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> bool: ...

class MACsecMPLSOuter:
    exp: int
    mpls_label: int
    def __init__(self) -> None: ...

class MACsecPacketType:
    __members__: ClassVar[dict] = ...  # read-only
    DEFAULT: ClassVar[MACsecPacketType] = ...
    DUAL_VLAN: ClassVar[MACsecPacketType] = ...
    DUAL_VLAN_FOLLOWED_BY_MPLS: ClassVar[MACsecPacketType] = ...
    MPLS: ClassVar[MACsecPacketType] = ...
    SINGLE_VLAN: ClassVar[MACsecPacketType] = ...
    SINGLE_VLAN_FOLLOWED_BY_MPLS: ClassVar[MACsecPacketType] = ...
    UNSUPPORTED: ClassVar[MACsecPacketType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MACsecRxRule:
    is_mpls: bool
    key_bonus_data: int
    key_ether_type: int
    key_express: bool
    key_inner_vlan_type: int
    key_mac_da: Incomplete
    key_mask_sa: Incomplete
    key_mpls_outer1: MACsecMPLSOuter
    key_mpls_outer2: MACsecMPLSOuter
    key_num_tags: int
    key_outer_vlan_type: int
    key_packet_type: MACsecPacketType
    key_tag_match_bitmap: int
    key_vlan_tag_outer1: MACsecVLANTag
    key_vlan_tag_outer2: MACsecVLANTag
    mask_bonus_data: int
    mask_ether_type: int
    mask_express: bool
    mask_inner_vlan_type: int
    mask_mac_da: Incomplete
    mask_mac_sa: Incomplete
    mask_mpls_outer1: MACsecMPLSOuter
    mask_mpls_outer2: MACsecMPLSOuter
    mask_num_tags: int
    mask_outer_vlan_type: int
    mask_packet_type: int
    mask_tag_match_bitmap: int
    mask_vlan_tag_outer1: MACsecVLANTag
    mask_vlan_tag_outer2: MACsecVLANTag
    def __init__(self) -> None: ...

class MACsecRxSa:
    hash_key: Incomplete
    next_pn: int
    sak: Incomplete
    salt: Incomplete
    ssci: int
    def __init__(self) -> None: ...

class MACsecRxSecY:
    cipher: MACsecCipherSuite
    confidentiality_offset: int
    enable_control_port: bool
    frame_strip: MACsecStrip
    frame_validation: MACsecValidation
    icv_includes_da_sa: bool
    is_control_packet: bool
    replay_protect: bool
    replay_window: int
    sci: int
    def __init__(self) -> None: ...

class MACsecStrip:
    __members__: ClassVar[dict] = ...  # read-only
    NO_STRIP: ClassVar[MACsecStrip] = ...
    PRESERVE_SECTAG_STRIP_ICV: ClassVar[MACsecStrip] = ...
    STRIP_SECTAG_AND_ICV: ClassVar[MACsecStrip] = ...
    STRIP_SECTAG_PRESERVE_ICV: ClassVar[MACsecStrip] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MACsecTci:
    c: bool
    e: bool
    es: bool
    sc: bool
    scb: bool
    def __init__(self) -> None: ...

class MACsecTxSa:
    an: int
    hash_key: Incomplete
    next_pn: int
    sak: Incomplete
    salt: Incomplete
    ssci: int
    def __init__(self) -> None: ...

class MACsecTxSecY:
    auxiliary_policy: int
    cipher: MACsecCipherSuite
    confidentiality_offset: int
    enable_control_port: bool
    icv_includes_da_sa: bool
    is_control_packet: bool
    mtu: int
    protect_frames: bool
    sci: int
    sec_tag_offset: int
    sec_tag_tci: MACsecTci
    def __init__(self) -> None: ...

class MACsecVLANTag:
    pri_cfi: int
    vid: int
    def __init__(self) -> None: ...

class MACsecValidation:
    __members__: ClassVar[dict] = ...  # read-only
    CHECK: ClassVar[MACsecValidation] = ...
    DISABLED: ClassVar[MACsecValidation] = ...
    NA: ClassVar[MACsecValidation] = ...
    STRICT: ClassVar[MACsecValidation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MDIOMessage(Frame):
    class Clause:
        __members__: ClassVar[dict] = ...  # read-only
        Clause22: ClassVar[MDIOMessage.Clause] = ...
        Clause45: ClassVar[MDIOMessage.Clause] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Direction:
        __members__: ClassVar[dict] = ...  # read-only
        Read: ClassVar[MDIOMessage.Direction] = ...
        Write: ClassVar[MDIOMessage.Direction] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    clause: MDIOMessage.Clause
    devAddress: int
    direction: MDIOMessage.Direction
    isTXMsg: bool
    phyAddress: int
    regAddress: int
    txAborted: bool
    txInvalidBus: bool
    txInvalidClause: bool
    txInvalidOpcode: bool
    txInvalidPhyAddr: bool
    txInvalidRegAddr: bool
    txTimeout: bool
    def __init__(self) -> None: ...

class Message:
    class Type(enum.IntEnum):
        __new__: ClassVar[Callable] = ...
        AppError: ClassVar[Message.Type] = ...
        CANError: ClassVar[Message.Type] = ...
        CANErrorCount: ClassVar[Message.Type] = ...
        ComponentVersions: ClassVar[Message.Type] = ...
        DeviceVersion: ClassVar[Message.Type] = ...
        EthernetPhyRegister: ClassVar[Message.Type] = ...
        EthernetStatus: ClassVar[Message.Type] = ...
        ExtendedResponse: ClassVar[Message.Type] = ...
        FlexRayControl: ClassVar[Message.Type] = ...
        Frame: ClassVar[Message.Type] = ...
        GPTPStatus: ClassVar[Message.Type] = ...
        GenericBinaryStatus: ClassVar[Message.Type] = ...
        HardwareInfo: ClassVar[Message.Type] = ...
        Invalid: ClassVar[Message.Type] = ...
        LINBreak: ClassVar[Message.Type] = ...
        LINHeaderOnly: ClassVar[Message.Type] = ...
        LiveData: ClassVar[Message.Type] = ...
        LogicalDiskInfo: ClassVar[Message.Type] = ...
        Main51: ClassVar[Message.Type] = ...
        RawMessage: ClassVar[Message.Type] = ...
        ReadSettings: ClassVar[Message.Type] = ...
        ResetStatus: ClassVar[Message.Type] = ...
        ScriptStatus: ClassVar[Message.Type] = ...
        SupportedFeatures: ClassVar[Message.Type] = ...
        TC10Status: ClassVar[Message.Type] = ...
        WiVICommandResponse: ClassVar[Message.Type] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[int]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        def __format__(self, *args, **kwargs) -> str: ...
    timestamp: int
    def __init__(self, arg0: Message.Type) -> None: ...
    @property
    def type(self) -> Message.Type: ...

class MessageCallback:
    def __init__(self, arg0: collections.abc.Callable[[Message], None], arg1: MessageFilter) -> None: ...

class MessageFilter:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: Message.Type) -> None: ...
    @overload
    def __init__(self, arg0: Network.NetID) -> None: ...

class NeoVersion:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def buildBranch(self) -> str: ...
    @property
    def buildTag(self) -> str: ...
    @property
    def major(self) -> int: ...
    @property
    def metadata(self) -> str: ...
    @property
    def minor(self) -> int: ...
    @property
    def patch(self) -> int: ...

class Network:
    class NetID(enum.IntEnum):
        __new__: ClassVar[Callable] = ...
        A2B_01: ClassVar[Network.NetID] = ...
        A2B_02: ClassVar[Network.NetID] = ...
        AE_01: ClassVar[Network.NetID] = ...
        AE_02: ClassVar[Network.NetID] = ...
        AE_03: ClassVar[Network.NetID] = ...
        AE_04: ClassVar[Network.NetID] = ...
        AE_05: ClassVar[Network.NetID] = ...
        AE_06: ClassVar[Network.NetID] = ...
        AE_07: ClassVar[Network.NetID] = ...
        AE_08: ClassVar[Network.NetID] = ...
        AE_09: ClassVar[Network.NetID] = ...
        AE_10: ClassVar[Network.NetID] = ...
        AE_11: ClassVar[Network.NetID] = ...
        AE_12: ClassVar[Network.NetID] = ...
        AE_13: ClassVar[Network.NetID] = ...
        AE_14: ClassVar[Network.NetID] = ...
        AE_15: ClassVar[Network.NetID] = ...
        AE_16: ClassVar[Network.NetID] = ...
        Any: ClassVar[Network.NetID] = ...
        App_Signal_Status: ClassVar[Network.NetID] = ...
        Aux: ClassVar[Network.NetID] = ...
        CAN_ERRBITS: ClassVar[Network.NetID] = ...
        CGI: ClassVar[Network.NetID] = ...
        CoreMiniPreLoad: ClassVar[Network.NetID] = ...
        DWCAN_01: ClassVar[Network.NetID] = ...
        DWCAN_02: ClassVar[Network.NetID] = ...
        DWCAN_03: ClassVar[Network.NetID] = ...
        DWCAN_04: ClassVar[Network.NetID] = ...
        DWCAN_05: ClassVar[Network.NetID] = ...
        DWCAN_06: ClassVar[Network.NetID] = ...
        DWCAN_07: ClassVar[Network.NetID] = ...
        DWCAN_08: ClassVar[Network.NetID] = ...
        DWCAN_09: ClassVar[Network.NetID] = ...
        DWCAN_10: ClassVar[Network.NetID] = ...
        DWCAN_11: ClassVar[Network.NetID] = ...
        DWCAN_12: ClassVar[Network.NetID] = ...
        DWCAN_13: ClassVar[Network.NetID] = ...
        DWCAN_14: ClassVar[Network.NetID] = ...
        DWCAN_15: ClassVar[Network.NetID] = ...
        DWCAN_16: ClassVar[Network.NetID] = ...
        Data_To_Host: ClassVar[Network.NetID] = ...
        Device: ClassVar[Network.NetID] = ...
        DeviceStatus: ClassVar[Network.NetID] = ...
        DiskData: ClassVar[Network.NetID] = ...
        ETHERNET_01: ClassVar[Network.NetID] = ...
        ETHERNET_02: ClassVar[Network.NetID] = ...
        ETHERNET_03: ClassVar[Network.NetID] = ...
        ETHERNET_DAQ: ClassVar[Network.NetID] = ...
        ETHERNET_TX_WRAP: ClassVar[Network.NetID] = ...
        EthPHYControl: ClassVar[Network.NetID] = ...
        ExtendedCommand: ClassVar[Network.NetID] = ...
        ExtendedData: ClassVar[Network.NetID] = ...
        FB_Status: ClassVar[Network.NetID] = ...
        FLEXRAY_01: ClassVar[Network.NetID] = ...
        FLEXRAY_01A: ClassVar[Network.NetID] = ...
        FLEXRAY_01B: ClassVar[Network.NetID] = ...
        FLEXRAY_02: ClassVar[Network.NetID] = ...
        FLEXRAY_02A: ClassVar[Network.NetID] = ...
        FLEXRAY_02B: ClassVar[Network.NetID] = ...
        FlexRayControl: ClassVar[Network.NetID] = ...
        FordSCP: ClassVar[Network.NetID] = ...
        ForwardedMessage: ClassVar[Network.NetID] = ...
        GMFSA: ClassVar[Network.NetID] = ...
        HW_COM_Latency_Test: ClassVar[Network.NetID] = ...
        I2C_01: ClassVar[Network.NetID] = ...
        I2C_02: ClassVar[Network.NetID] = ...
        I2C_03: ClassVar[Network.NetID] = ...
        I2C_04: ClassVar[Network.NetID] = ...
        ISO14230: ClassVar[Network.NetID] = ...
        ISO9141_01: ClassVar[Network.NetID] = ...
        ISO9141_02: ClassVar[Network.NetID] = ...
        ISO9141_03: ClassVar[Network.NetID] = ...
        ISO9141_04: ClassVar[Network.NetID] = ...
        Invalid: ClassVar[Network.NetID] = ...
        J1708: ClassVar[Network.NetID] = ...
        J1850VPW: ClassVar[Network.NetID] = ...
        LIN_01: ClassVar[Network.NetID] = ...
        LIN_02: ClassVar[Network.NetID] = ...
        LIN_03: ClassVar[Network.NetID] = ...
        LIN_04: ClassVar[Network.NetID] = ...
        LIN_05: ClassVar[Network.NetID] = ...
        LIN_06: ClassVar[Network.NetID] = ...
        LIN_07: ClassVar[Network.NetID] = ...
        LIN_08: ClassVar[Network.NetID] = ...
        LIN_09: ClassVar[Network.NetID] = ...
        LIN_10: ClassVar[Network.NetID] = ...
        LIN_11: ClassVar[Network.NetID] = ...
        LIN_12: ClassVar[Network.NetID] = ...
        LIN_13: ClassVar[Network.NetID] = ...
        LIN_14: ClassVar[Network.NetID] = ...
        LIN_15: ClassVar[Network.NetID] = ...
        LIN_16: ClassVar[Network.NetID] = ...
        LSFTCAN_01: ClassVar[Network.NetID] = ...
        LSFTCAN_02: ClassVar[Network.NetID] = ...
        Logging_Overflow: ClassVar[Network.NetID] = ...
        LogicalDiskInfo: ClassVar[Network.NetID] = ...
        MDIO_01: ClassVar[Network.NetID] = ...
        MDIO_02: ClassVar[Network.NetID] = ...
        MDIO_03: ClassVar[Network.NetID] = ...
        MDIO_04: ClassVar[Network.NetID] = ...
        MDIO_05: ClassVar[Network.NetID] = ...
        MDIO_06: ClassVar[Network.NetID] = ...
        MDIO_07: ClassVar[Network.NetID] = ...
        MDIO_08: ClassVar[Network.NetID] = ...
        MOST_150: ClassVar[Network.NetID] = ...
        MOST_25: ClassVar[Network.NetID] = ...
        MOST_50: ClassVar[Network.NetID] = ...
        Main51: ClassVar[Network.NetID] = ...
        NeoMemorySDRead: ClassVar[Network.NetID] = ...
        NeoMemoryWriteDone: ClassVar[Network.NetID] = ...
        RED: ClassVar[Network.NetID] = ...
        RED_App_Error: ClassVar[Network.NetID] = ...
        RED_DFLASH_READ: ClassVar[Network.NetID] = ...
        RED_EXT_MEMORYREAD: ClassVar[Network.NetID] = ...
        RED_GET_RTC: ClassVar[Network.NetID] = ...
        RED_HARDWARE_EXCEP: ClassVar[Network.NetID] = ...
        RED_INT_MEMORYREAD: ClassVar[Network.NetID] = ...
        RED_NEOVI_NETWORK: ClassVar[Network.NetID] = ...
        RED_NETWORK_COM_ENABLE_EX: ClassVar[Network.NetID] = ...
        RED_OLDFORMAT: ClassVar[Network.NetID] = ...
        RED_READ_BAUD_SETTINGS: ClassVar[Network.NetID] = ...
        RED_SCOPE_CAPTURE: ClassVar[Network.NetID] = ...
        RED_WAVE_CAN1_LOGICAL: ClassVar[Network.NetID] = ...
        RED_WAVE_CAN2_LOGICAL: ClassVar[Network.NetID] = ...
        RED_WAVE_LIN1_ANALOG: ClassVar[Network.NetID] = ...
        RED_WAVE_LIN1_LOGICAL: ClassVar[Network.NetID] = ...
        RED_WAVE_LIN2_ANALOG: ClassVar[Network.NetID] = ...
        RED_WAVE_LIN2_LOGICAL: ClassVar[Network.NetID] = ...
        RED_WAVE_MISCDIO2_LOGICAL: ClassVar[Network.NetID] = ...
        RED_WAVE_MISC_ANALOG: ClassVar[Network.NetID] = ...
        RS232: ClassVar[Network.NetID] = ...
        ReadSettings: ClassVar[Network.NetID] = ...
        Read_Datalink_Cm_Rx_Msg: ClassVar[Network.NetID] = ...
        Read_Datalink_Cm_Tx_Msg: ClassVar[Network.NetID] = ...
        Red_VBat: ClassVar[Network.NetID] = ...
        Reset_Status: ClassVar[Network.NetID] = ...
        SCI: ClassVar[Network.NetID] = ...
        SPI_01: ClassVar[Network.NetID] = ...
        SPI_02: ClassVar[Network.NetID] = ...
        SPI_03: ClassVar[Network.NetID] = ...
        SPI_04: ClassVar[Network.NetID] = ...
        SPI_05: ClassVar[Network.NetID] = ...
        SPI_06: ClassVar[Network.NetID] = ...
        SPI_07: ClassVar[Network.NetID] = ...
        SPI_08: ClassVar[Network.NetID] = ...
        SWCAN_01: ClassVar[Network.NetID] = ...
        SWCAN_02: ClassVar[Network.NetID] = ...
        ScriptStatus: ClassVar[Network.NetID] = ...
        TCP: ClassVar[Network.NetID] = ...
        TextAPI_To_Host: ClassVar[Network.NetID] = ...
        UART_01: ClassVar[Network.NetID] = ...
        UART_02: ClassVar[Network.NetID] = ...
        UART_03: ClassVar[Network.NetID] = ...
        UART_04: ClassVar[Network.NetID] = ...
        UDP: ClassVar[Network.NetID] = ...
        WBMS_01: ClassVar[Network.NetID] = ...
        WiVICommand: ClassVar[Network.NetID] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[int]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        def __format__(self, *args, **kwargs) -> str: ...

    class Type(enum.Enum):
        __new__: ClassVar[Callable] = ...
        A2B: ClassVar[Network.Type] = ...
        Any: ClassVar[Network.Type] = ...
        AutomotiveEthernet: ClassVar[Network.Type] = ...
        CAN: ClassVar[Network.Type] = ...
        Ethernet: ClassVar[Network.Type] = ...
        FlexRay: ClassVar[Network.Type] = ...
        I2C: ClassVar[Network.Type] = ...
        ISO9141: ClassVar[Network.Type] = ...
        Internal: ClassVar[Network.Type] = ...
        Invalid: ClassVar[Network.Type] = ...
        LIN: ClassVar[Network.Type] = ...
        LSFTCAN: ClassVar[Network.Type] = ...
        MDIO: ClassVar[Network.Type] = ...
        MOST: ClassVar[Network.Type] = ...
        Other: ClassVar[Network.Type] = ...
        SPI: ClassVar[Network.Type] = ...
        SWCAN: ClassVar[Network.Type] = ...
        _generate_next_value_: ClassVar[Callable] = ...
        _member_map_: ClassVar[dict] = ...
        _member_names_: ClassVar[list] = ...
        _member_type_: ClassVar[type[object]] = ...
        _unhashable_values_: ClassVar[list] = ...
        _use_args_: ClassVar[bool] = ...
        _value2member_map_: ClassVar[dict] = ...
        _value_repr_: ClassVar[None] = ...
    def __init__(self, arg0: Network.NetID) -> None: ...
    def get_net_id(self) -> Network.NetID: ...
    @staticmethod
    def get_net_id_string(netid: Network.NetID, expand: bool = ...) -> str: ...
    def get_type(self) -> Network.Type: ...

class PhyMessage:
    BusIndex: int
    Clause22: Clause22Message
    Clause45: Clause45Message
    Clause45Enable: bool
    Enabled: bool
    Version: int
    WriteEnable: bool
    def __init__(self) -> None: ...

class RawMessage(Message):
    data: list[int]
    network: Network
    def __init__(self, *args, **kwargs) -> None: ...

class SPIMessage(Frame):
    class Direction:
        __members__: ClassVar[dict] = ...  # read-only
        Read: ClassVar[SPIMessage.Direction] = ...
        Write: ClassVar[SPIMessage.Direction] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    address: int
    direction: SPIMessage.Direction
    mms: int
    payload: list[int]
    stats: int
    def __init__(self) -> None: ...

class ScriptStatusMessage(Message):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def coreminiCreateTime(self) -> int: ...
    @property
    def coreminiHeaderSize(self) -> int: ...
    @property
    def coreminiVersion(self) -> int: ...
    @property
    def currentSector(self) -> int: ...
    @property
    def diagnosticErrorCode(self) -> int: ...
    @property
    def diagnosticErrorCodeCount(self) -> int: ...
    @property
    def fileChecksum(self) -> int: ...
    @property
    def isCoreminiRunning(self) -> bool: ...
    @property
    def isEncrypted(self) -> bool: ...
    @property
    def lastSector(self) -> int: ...
    @property
    def maxCoreminiSizeKB(self) -> int: ...
    @property
    def maxSector(self) -> int: ...
    @property
    def minSector(self) -> int: ...
    @property
    def numRemainingSectorBuffers(self) -> int: ...
    @property
    def readBinSize(self) -> int: ...
    @property
    def sectorOverflows(self) -> int: ...

class Settings:
    class EthernetLinkMode:
        __members__: ClassVar[dict] = ...  # read-only
        Auto: ClassVar[Settings.EthernetLinkMode] = ...
        Master: ClassVar[Settings.EthernetLinkMode] = ...
        Slave: ClassVar[Settings.EthernetLinkMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class LINMode:
        __members__: ClassVar[dict] = ...  # read-only
        Fast: ClassVar[Settings.LINMode] = ...
        Normal: ClassVar[Settings.LINMode] = ...
        Sleep: ClassVar[Settings.LINMode] = ...
        Slow: ClassVar[Settings.LINMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class PhyLinkMode:
        __members__: ClassVar[dict] = ...  # read-only
        ETH_LINK_MODE_100MBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_100MBPS_HALFDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_10GBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_10MBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_10MBPS_HALFDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_1GBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_1GBPS_HALFDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_2_5GBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_5GBPS_FULLDUPLEX: ClassVar[Settings.PhyLinkMode] = ...
        ETH_LINK_MODE_AUTO_NEGOTIATION: ClassVar[Settings.PhyLinkMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: typing.SupportsInt) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...

class TC10SleepStatus:
    __members__: ClassVar[dict] = ...  # read-only
    NoSleepReceived: ClassVar[TC10SleepStatus] = ...
    SleepAborted: ClassVar[TC10SleepStatus] = ...
    SleepFailed: ClassVar[TC10SleepStatus] = ...
    SleepReceived: ClassVar[TC10SleepStatus] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TC10StatusMessage(Message):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def sleepStatus(self) -> TC10SleepStatus: ...
    @property
    def wakeStatus(self) -> TC10WakeStatus: ...

class TC10WakeStatus:
    __members__: ClassVar[dict] = ...  # read-only
    NoWakeReceived: ClassVar[TC10WakeStatus] = ...
    WakeReceived: ClassVar[TC10WakeStatus] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VersionReport:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def build(self) -> int: ...
    @property
    def id(self) -> ChipID: ...
    @property
    def maintenance(self) -> int: ...
    @property
    def major(self) -> int: ...
    @property
    def minor(self) -> int: ...
    @property
    def name(self) -> str: ...

def find_all_devices() -> list[Device]: ...
def get_last_error() -> APIEvent: ...
def get_new_handle() -> int: ...
def get_supported_devices() -> list[DeviceType]: ...
def get_version() -> NeoVersion: ...
def livedata_double_to_value(d: typing.SupportsFloat) -> LiveDataValue | None: ...
def livedata_value_to_double(val: LiveDataValue) -> float: ...
