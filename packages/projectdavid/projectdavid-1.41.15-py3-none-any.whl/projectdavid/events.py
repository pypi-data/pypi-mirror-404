from dataclasses import asdict, dataclass
from typing import Any, Callable, Dict, Optional


@dataclass
class StreamEvent:
    """Base class for all stream events with built-in serialization."""

    run_id: str

    def to_dict(self) -> Dict[str, Any]:
        """Converts the dataclass to a dictionary and adds the 'type' discriminator."""
        data = asdict(self)
        # Identify the event type for the front-end
        data["type"] = self.get_event_type()
        return data

    def get_event_type(self) -> str:
        mapping = {
            "ContentEvent": "content",
            "ReasoningEvent": "reasoning",
            "DecisionEvent": "decision",  # [NEW] Registered here
            "ToolCallRequestEvent": "tool_call_manifest",
            "StatusEvent": "status",
            "HotCodeEvent": "hot_code",
            "CodeExecutionOutputEvent": "code_output",
            "ComputerExecutionOutputEvent": "computer_output",
            "CodeExecutionGeneratedFileEvent": "generated_file",
        }
        return mapping.get(self.__class__.__name__, "unknown")


@dataclass
class ContentEvent(StreamEvent):
    """Represents a text delta from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class ReasoningEvent(StreamEvent):
    """Represents a 'thinking' delta (DeepSeek R1/V3)."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class DecisionEvent(StreamEvent):
    """Represents a structural decision payload (JSON) from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class HotCodeEvent(StreamEvent):
    """Real-time code being typed by the model BEFORE execution."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionOutputEvent(StreamEvent):
    """Stdout/Stderr output from the code sandbox."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class ComputerExecutionOutputEvent(StreamEvent):
    """Output from the shell/computer execution tool."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionGeneratedFileEvent(StreamEvent):
    """A file (plot, csv) generated by the code interpreter."""

    filename: str
    file_id: str
    base64_data: str
    mime_type: str


@dataclass
class StatusEvent(StreamEvent):
    """Represents a lifecycle change (complete, failed, tool_output_received)."""

    status: str


class ToolCallRequestEvent(StreamEvent):
    """A fully accumulated tool call request with execution capability."""

    def __init__(
        self,
        run_id: str,
        tool_name: str,
        args: Dict[str, Any],
        thread_id: str,
        assistant_id: str,
        _runs_client: Any,
        _actions_client: Any,
        _messages_client: Any,
        action_id: Optional[str] = None,
    ):
        super().__init__(run_id)
        self.tool_name = tool_name
        self.args = args
        self.action_id = action_id
        self._thread_id = thread_id
        self._assistant_id = assistant_id
        self._runs_client = _runs_client
        self._actions_client = _actions_client
        self._messages_client = _messages_client

    def to_dict(self) -> Dict[str, Any]:
        # Tool events contain private client references; we exclude them from JSON
        return {
            "type": "tool_call_manifest",
            "run_id": self.run_id,
            "tool": self.tool_name,
            "args": self.args,
            "action_id": self.action_id,
        }

    def execute(self, tool_executor: Callable[[str, Dict[str, Any]], str]) -> bool:
        """Helper to run local code and submit results via Fast-Path Action ID."""
        return self._runs_client.execute_pending_action(
            run_id=self.run_id,
            thread_id=self._thread_id,
            assistant_id=self._assistant_id,
            tool_executor=tool_executor,
            actions_client=self._actions_client,
            messages_client=self._messages_client,
            streamed_args=self.args,
            action_id=self.action_id,
            tool_name=self.tool_name,
        )
