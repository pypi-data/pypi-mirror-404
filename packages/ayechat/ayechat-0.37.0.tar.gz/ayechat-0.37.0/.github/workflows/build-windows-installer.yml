name: Build Windows Installer

on:
  push:
    branches: [ "dev" ]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 0.29.1). Leave empty to use latest tag.'
        required: false
        type: string

permissions:
  contents: write

jobs:
  build-installer:
    name: Build Windows Installer
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for setuptools-scm to get version from tags

      - name: Set up certificate
        run: |
            echo "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}" | base64 --decode > /d/Certificate_pkcs12.p12
        shell: bash

      - name: Set variables
        id: variables
        run: |
          echo "version=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          echo "SM_HOST=${{ secrets.SM_HOST }}" >> "$GITHUB_ENV"
          echo "SM_API_KEY=${{ secrets.SM_API_KEY }}" >> "$GITHUB_ENV"
          echo "SM_CLIENT_CERT_FILE=D:\\Certificate_pkcs12.p12" >> "$GITHUB_ENV"
          echo "SM_CLIENT_CERT_PASSWORD=${{ secrets.SM_CLIENT_CERT_PASSWORD }}" >> "$GITHUB_ENV"
        shell: bash

      - name: Force reg add to be non-interactive (auto-append /f)
        shell: pwsh
        run: |
          $wrapperDir = Join-Path $env:RUNNER_TEMP "reg-wrapper"
          New-Item -ItemType Directory -Force -Path $wrapperDir | Out-Null

          $wrapperPath = Join-Path $wrapperDir "reg.cmd"

          @'
          @echo off
          setlocal EnableExtensions EnableDelayedExpansion

          rem Wrapper around reg.exe to avoid interactive prompts.
          rem If called as: reg add ... (without /f), append /f.

          if /I "%~1"=="add" (
            set "all=%*"
            echo !all! | findstr /I /C:" /f" >nul
            if errorlevel 1 (
              "%SystemRoot%\System32\reg.exe" %* /f
              exit /b %errorlevel%
            )
          )

          "%SystemRoot%\System32\reg.exe" %*
          exit /b %errorlevel%
          '@ | Set-Content -Path $wrapperPath -Encoding ascii

          "${wrapperDir}" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
          Write-Host "Installed reg wrapper at: $wrapperPath"
          Write-Host "Wrapper directory added to PATH: $wrapperDir"

      - name: Setup Software Trust Manager (new)
        id: stm-setup
        uses: digicert/code-signing-software-trust-action@v1.0.1

      - name: Check PKCS11 config file
        run: |
          IF EXIST "${{ steps.stm-setup.outputs.PKCS11_CONFIG }}" (
            echo file exists: ${{ steps.stm-setup.outputs.PKCS11_CONFIG }}
          ) ELSE (
            echo !! file doesn't exist: ${{ steps.stm-setup.outputs.PKCS11_CONFIG }}
          )
        shell: cmd

      - name: Find smctl location
        run: where smctl
        shell: cmd

      - name: Debug certificate setup
        run: |
          echo "Checking if certificate file exists..."
          if [ -f "D:/Certificate_pkcs12.p12" ]; then
            echo "Certificate file exists"
            ls -la D:/Certificate_pkcs12.p12
            echo "Verifying certificate file format..."
            openssl pkcs12 -in D:/Certificate_pkcs12.p12 -info -nokeys -passin pass:${{ secrets.SM_CLIENT_CERT_PASSWORD }} 2>&1 | head -20 || echo "Failed to read certificate - may be wrong password or corrupted file"
            echo "Getting certificate fingerprint (SHA1)..."
            openssl pkcs12 -in D:/Certificate_pkcs12.p12 -passin pass:${{ secrets.SM_CLIENT_CERT_PASSWORD }} -nokeys 2>/dev/null | openssl x509 -fingerprint -sha1 -noout || echo "Failed to get fingerprint"
          else
            echo "Certificate file NOT found!"
          fi
        shell: bash

      - name: Verify secrets are set
        run: |
          echo Checking required secrets...
          if [ -z "${{ secrets.SM_HOST }}" ]; then echo "ERROR: SM_HOST is not set"; else echo "SM_HOST is set"; fi
          if [ -z "${{ secrets.SM_API_KEY }}" ]; then echo "ERROR: SM_API_KEY is not set"; else echo "SM_API_KEY is set (length: ${#SM_API_KEY})"; fi
          if [ -z "${{ secrets.SM_CLIENT_CERT_PASSWORD }}" ]; then echo "ERROR: SM_CLIENT_CERT_PASSWORD is not set"; else echo "SM_CLIENT_CERT_PASSWORD is set"; fi
          if [ -z "${{ secrets.SM_CLIENT_CERT_FILE_B64 }}" ]; then echo "ERROR: SM_CLIENT_CERT_FILE_B64 is not set"; else echo "SM_CLIENT_CERT_FILE_B64 is set"; fi
          if [ -z "${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}" ]; then echo "ERROR: SM_CODE_SIGNING_CERT_SHA1_HASH is not set"; else echo "SM_CODE_SIGNING_CERT_SHA1_HASH is set"; fi
          if [ -z "${{ secrets.SM_KEYPAIR_ALIAS }}" ]; then echo "ERROR: SM_KEYPAIR_ALIAS is not set"; else echo "SM_KEYPAIR_ALIAS is set"; fi
        shell: bash
        env:
          SM_API_KEY: ${{ secrets.SM_API_KEY }}

      # - name: Verify Certificate (Debug)
      #   run: |
      #     smctl keypair ls

      # - name: Sync Certificates to Windows Store
      #   run: smctl windows certsync

      # - name: Verify Certificate (Debug)
      #   run: |
      #     smctl keypair ls

      # - name: Stop for debugging
      #   run: exit 1

      - name: Determine version
        id: version
        shell: pwsh
        run: |
          if ("${{ github.event.inputs.version }}" -ne "") {
            # Manual input - use as-is
            $version = "${{ github.event.inputs.version }}"
          } elseif ("${{ github.event_name }}" -eq "release") {
            # Release event - use tag directly (like python-publish.yml)
            $version = "${{ github.event.release.tag_name }}" -replace '^v', ''
          } else {
            # Dev branch push - generate dev version (like python-publish-dev.yml)
            # Get the latest tag, or use 0.0.0 if no tags exist
            $latestTag = git describe --tags --abbrev=0 2>$null
            if (-not $latestTag) { $latestTag = "0.0.0" }
            $latestTag = $latestTag -replace '^v', ''

            # Split version into major.minor.patch
            $parts = $latestTag.Split('.')
            $major = if ($parts.Length -gt 0) { $parts[0] } else { 0 }
            $minor = if ($parts.Length -gt 1) { $parts[1] } else { 0 }
            $patch = if ($parts.Length -gt 2) { ($parts[2] -replace '[^0-9].*', '') } else { 0 }

            # Increment patch version for dev releases
            $nextPatch = $patch + 1
            $nextVersion = "$major.$minor.$nextPatch"

            # Generate timestamp-based dev version
            $timestamp = Get-Date -Format "yyyyMMddHHmmss"
            $version = "$nextVersion.dev$timestamp"

            Write-Host "Latest release: $latestTag"
          }

          # Extract numeric version for Windows VersionInfo (X.X.X.X format)
          # Remove any non-numeric suffix like .devXXX
          $numericVersion = $version -replace '\.dev.*$', ''
          # Ensure we have at least X.X.X format, pad with .0 if needed
          $parts = $numericVersion.Split('.')
          while ($parts.Length -lt 3) { $parts += "0" }
          $numericVersion = ($parts[0..2] -join '.') + ".0"

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "NUMERIC_VERSION=$numericVersion" >> $env:GITHUB_OUTPUT
          echo "Building version: $version (numeric: $numericVersion)"

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller
          pip install -e .

      - name: Create frozen version module
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $content = "# Auto-generated by build-windows-installer.yml - DO NOT EDIT`n__version__ = `"$version`""
          $content | Set-Content -Path "src/aye/_frozen_version.py" -Encoding utf8NoBOM
          Write-Host "Created _frozen_version.py with version: $version"
          Get-Content -Path "src/aye/_frozen_version.py"

      - name: Create version info file
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $parts = $version.Split('.')
          $major = if ($parts.Length -gt 0) { $parts[0] } else { "0" }
          $minor = if ($parts.Length -gt 1) { $parts[1] } else { "0" }
          $patch = if ($parts.Length -gt 2) { $parts[2] -replace '[^0-9].*', '' } else { "0" }

          $content = @"
          VSVersionInfo(
            ffi=FixedFileInfo(
              filevers=($major, $minor, $patch, 0),
              prodvers=($major, $minor, $patch, 0),
              mask=0x3f,
              flags=0x0,
              OS=0x40004,
              fileType=0x1,
              subtype=0x0,
              date=(0, 0)
            ),
            kids=[
              StringFileInfo([
                StringTable(
                  '040904B0',
                  [
                    StringStruct('CompanyName', 'Acrotron, Inc.'),
                    StringStruct('FileDescription', 'Aye Chat - Terminal-first AI Code Generator'),
                    StringStruct('FileVersion', '$version'),
                    StringStruct('InternalName', 'aye'),
                    StringStruct('LegalCopyright', 'Copyright (C) 2024-2025 Acrotron, Inc.'),
                    StringStruct('OriginalFilename', 'aye.exe'),
                    StringStruct('ProductName', 'Aye Chat'),
                    StringStruct('ProductVersion', '$version'),
                  ]
                )
              ]),
              VarFileInfo([VarStruct('Translation', [1033, 1200])])
            ]
          )
          "@

          # Write without UTF-8 BOM (PowerShell-only fix)
          $content | Set-Content -Path version_info.txt -Encoding utf8NoBOM

          Write-Host "version_info.txt written. First 16 bytes:"
          Format-Hex -Path version_info.txt -Count 16
          Write-Host "First line of version_info.txt:"
          Get-Content -Path version_info.txt -TotalCount 1

      - name: Build with PyInstaller
        run: |
          pyinstaller aye-chat.spec --noconfirm

      - name: Verify build output
        shell: pwsh
        run: |
          if (!(Test-Path "dist/aye-chat/aye.exe")) {
            Write-Error "Build failed: aye.exe not found"
            exit 1
          }
          Write-Host "Build successful! Contents of dist/aye-chat:"
          Get-ChildItem -Path "dist/aye-chat" -Recurse | Select-Object FullName, Length

      - name: Test executable
        shell: pwsh
        run: |
          Write-Host "Testing aye.exe --version:"
          & "dist/aye-chat/aye.exe" --version

      - name: Build installer with Inno Setup
        id: inno-setup
        uses: Minionguyjpro/Inno-Setup-Action@v1.2.7
        with:
          path: installer.iss
          options: /DMyAppVersion=${{ steps.version.outputs.VERSION }} /DMyAppNumericVersion=${{ steps.version.outputs.NUMERIC_VERSION }}

      - name: Find installer executable
        id: find-installer
        shell: pwsh
        run: |
          $exe = Get-ChildItem -Path Output -Filter *.exe | Select-Object -First 1
          echo "INSTALLER_PATH=$($exe.FullName)" >> $env:GITHUB_OUTPUT
          echo "Found installer: $($exe.FullName)"

      - name: Add signtool to PATH
        shell: pwsh
        run: |
          $sdkPath = "C:\Program Files (x86)\Windows Kits\10\bin"
          $latestSdk = Get-ChildItem -Path $sdkPath -Directory | Where-Object { $_.Name -match '^\d+\.\d+\.\d+\.\d+$' } | Sort-Object Name -Descending | Select-Object -First 1
          $signtoolPath = Join-Path $latestSdk.FullName "x64"
          echo "Adding to PATH: $signtoolPath"
          echo "$signtoolPath" >> $env:GITHUB_PATH

      - name: Sign installer with certificate
        if: github.event_name == 'release'
        run: |
           smctl sign --verbose --keypair-alias ${{ secrets.SM_KEYPAIR_ALIAS }} --input "${{ steps.find-installer.outputs.INSTALLER_PATH }}" --config-file ${{ steps.stm-setup.outputs.PKCS11_CONFIG }}
        shell: cmd
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_FILE: D:\Certificate_pkcs12.p12
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}

      - name: Upload installer artifact
        uses: actions/upload-artifact@v6
        with:
          name: aye-chat-installer-${{ steps.version.outputs.VERSION }}
          path: Output/*.exe
          if-no-files-found: error

      - name: Upload to release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: Output/*.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Optional: Create a portable ZIP as well
  build-portable:
    name: Build Portable ZIP
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        shell: pwsh
        run: |
          if ("${{ github.event.inputs.version }}" -ne "") {
            # Manual input - use as-is
            $version = "${{ github.event.inputs.version }}"
          } elseif ("${{ github.event_name }}" -eq "release") {
            # Release event - use tag directly (like python-publish.yml)
            $version = "${{ github.event.release.tag_name }}" -replace '^v', ''
          } else {
            # Dev branch push - generate dev version (like python-publish-dev.yml)
            # Get the latest tag, or use 0.0.0 if no tags exist
            $latestTag = git describe --tags --abbrev=0 2>$null
            if (-not $latestTag) { $latestTag = "0.0.0" }
            $latestTag = $latestTag -replace '^v', ''

            # Split version into major.minor.patch
            $parts = $latestTag.Split('.')
            $major = if ($parts.Length -gt 0) { $parts[0] } else { 0 }
            $minor = if ($parts.Length -gt 1) { $parts[1] } else { 0 }
            $patch = if ($parts.Length -gt 2) { ($parts[2] -replace '[^0-9].*', '') } else { 0 }

            # Increment patch version for dev releases
            $nextPatch = $patch + 1
            $nextVersion = "$major.$minor.$nextPatch"

            # Generate timestamp-based dev version
            $timestamp = Get-Date -Format "yyyyMMddHHmmss"
            $version = "$nextVersion.dev$timestamp"

            Write-Host "Latest release: $latestTag"
          }

          # Extract numeric version for Windows VersionInfo (X.X.X.X format)
          # Remove any non-numeric suffix like .devXXX
          $numericVersion = $version -replace '\.dev.*$', ''
          # Ensure we have at least X.X.X format, pad with .0 if needed
          $parts = $numericVersion.Split('.')
          while ($parts.Length -lt 3) { $parts += "0" }
          $numericVersion = ($parts[0..2] -join '.') + ".0"

          echo "VERSION=$version" >> $env:GITHUB_OUTPUT
          echo "NUMERIC_VERSION=$numericVersion" >> $env:GITHUB_OUTPUT
          echo "Building version: $version (numeric: $numericVersion)"

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller
          pip install -e .

      - name: Create frozen version module
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $content = "# Auto-generated by build-windows-installer.yml - DO NOT EDIT`n__version__ = `"$version`""
          $content | Set-Content -Path "src/aye/_frozen_version.py" -Encoding utf8NoBOM
          Write-Host "Created _frozen_version.py with version: $version"

      - name: Build with PyInstaller
        run: pyinstaller aye-chat.spec --noconfirm

      - name: Create portable ZIP
        shell: pwsh
        run: |
          Compress-Archive -Path "dist/aye-chat/*" -DestinationPath "aye-chat-portable-win64.zip"

      - name: Upload portable artifact
        uses: actions/upload-artifact@v6
        with:
          name: aye-chat-portable-${{ steps.version.outputs.VERSION }}
          path: "*.zip"
          if-no-files-found: error

      - name: Upload to release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: "*.zip"
          