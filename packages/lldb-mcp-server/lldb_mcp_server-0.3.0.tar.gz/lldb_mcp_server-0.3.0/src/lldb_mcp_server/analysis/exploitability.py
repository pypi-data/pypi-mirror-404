from typing import Any, Dict, List, Optional, Tuple

from ..utils.errors import LLDBError
from .crash_analyzer import CrashAnalyzer


class ExploitabilityAnalyzer:
    """Heuristic exploitability analysis for crashes."""

    def __init__(self, manager) -> None:
        self._manager = manager
        self._crash = CrashAnalyzer(manager)

    def analyze(self, session_id: str) -> Dict[str, Any]:
        sess = self._manager._require_session(session_id)
        self._manager._require_stopped(sess)
        crash = self._crash.collect(session_id)
        registers = self._safe_registers(session_id)
        instruction = self._current_instruction(session_id, registers)
        access_type = self._infer_access_type(instruction)
        rating, confidence, indicators = self._rate(crash, registers, access_type)
        recommendation = self._recommendation(rating, access_type)
        return {
            "analysis": {
                "rating": rating,
                "confidence": confidence,
                "crashType": crash.get("crashType"),
                "accessType": access_type,
                "faultAddress": crash.get("faultAddress"),
                "instruction": instruction,
                "registers": registers.get("general", {}),
                "indicators": indicators,
                "recommendation": recommendation,
            }
        }

    def get_suspicious_functions(self, session_id: str) -> Dict[str, Any]:
        sess = self._manager._require_session(session_id)
        self._manager._require_stopped(sess)
        threads = self._manager.threads(session_id)["threads"]
        suspicious = []
        for thread in threads:
            frames = self._manager.frames(session_id, thread["id"])["frames"]
            for frame in frames:
                func_name = (frame.get("function") or "").lower()
                entry = self._match_suspicious(func_name)
                if entry:
                    suspicious.append(
                        {
                            "name": frame.get("function"),
                            "address": frame.get("address"),
                            "frameIndex": frame.get("index"),
                            "category": entry["category"],
                            "risk": entry["risk"],
                            "description": entry["description"],
                        }
                    )
        summary = self._summarize_suspicious(suspicious)
        return {"suspiciousFunctions": suspicious, "summary": summary}

    def _safe_registers(self, session_id: str) -> Dict[str, Dict[str, str]]:
        try:
            return self._manager.read_registers(session_id).get("registers", {})
        except LLDBError:
            return {}

    def _current_instruction(self, session_id: str, registers: Dict[str, Dict[str, str]]) -> Dict[str, Any]:
        pc = self._extract_pc(registers)
        if pc is None:
            return {"address": None, "mnemonic": None, "operands": None}
        try:
            result = self._manager.disassemble(session_id, addr=pc, count=1)
            insn = result.get("instructions", [None])[0] if result else None
            if not insn:
                return {"address": None, "mnemonic": None, "operands": None}
            return {
                "address": insn.get("address"),
                "mnemonic": insn.get("mnemonic"),
                "operands": insn.get("operands"),
            }
        except LLDBError:
            return {"address": None, "mnemonic": None, "operands": None}

    def _extract_pc(self, registers: Dict[str, Dict[str, str]]) -> Optional[int]:
        general = registers.get("general", {})
        for key in ("rip", "pc"):
            value = general.get(key)
            if value:
                return self._parse_int(value)
        return None

    def _infer_access_type(self, instruction: Dict[str, Any]) -> str:
        mnemonic = (instruction.get("mnemonic") or "").lower()
        operands = (instruction.get("operands") or "").lower()
        if mnemonic.startswith("ld") or mnemonic in ("ldr", "ldp", "ldur"):
            return "read"
        if mnemonic.startswith("st") or mnemonic in ("str", "stp", "stur"):
            return "write"
        if mnemonic in ("call", "jmp", "br", "blr"):
            return "execute"
        if "[" in operands or "(" in operands:
            parts = [p.strip() for p in operands.split(",")]
            if parts and ("[" in parts[0] or "(" in parts[0]):
                return "write"
            if len(parts) > 1 and ("[" in parts[1] or "(" in parts[1]):
                return "read"
        return "unknown"

    def _rate(
        self,
        crash: Dict[str, Any],
        registers: Dict[str, Dict[str, str]],
        access_type: str,
    ) -> Tuple[str, float, List[Dict[str, str]]]:
        indicators = []
        fault_addr = crash.get("faultAddress")
        fault_int = self._parse_int(fault_addr)
        if fault_int is not None and fault_int <= 0x1000:
            indicators.append(
                {
                    "type": "null_dereference",
                    "description": "Fault address near null",
                    "severity": "low",
                }
            )
            return "Low", 0.6, indicators
        if fault_addr and self._looks_controlled(fault_addr):
            indicators.append(
                {
                    "type": "controlled_value",
                    "description": "Fault address appears user-controlled",
                    "severity": "high",
                }
            )
        if fault_addr and fault_addr.startswith("0x7fff"):
            indicators.append(
                {
                    "type": "stack_address",
                    "description": "Fault address appears to be in stack region",
                    "severity": "medium",
                }
            )
        if access_type == "write":
            indicators.append(
                {
                    "type": "write_violation",
                    "description": "Write access violation",
                    "severity": "high",
                }
            )
        if access_type == "execute":
            indicators.append(
                {
                    "type": "execution_violation",
                    "description": "Execution access violation",
                    "severity": "critical",
                }
            )
        score = self._score(access_type, indicators)
        rating = self._rating_for_score(score)
        confidence = min(0.95, 0.5 + score / 20.0)
        return rating, confidence, indicators

    def _score(self, access_type: str, indicators: List[Dict[str, str]]) -> int:
        score = 0
        if access_type == "execute":
            score = 9
        elif access_type == "write":
            score = 7
        elif access_type == "read":
            score = 4
        for indicator in indicators:
            if indicator["severity"] == "critical":
                score += 2
            elif indicator["severity"] == "high":
                score += 1
        return score

    def _rating_for_score(self, score: int) -> str:
        if score >= 9:
            return "Critical"
        if score >= 7:
            return "High"
        if score >= 4:
            return "Medium"
        if score >= 1:
            return "Low"
        return "Unknown"

    def _recommendation(self, rating: str, access_type: str) -> str:
        if rating in ("Critical", "High"):
            return "Potentially exploitable crash. Investigate memory safety issues."
        if access_type == "read":
            return "Likely read access violation. Check for out-of-bounds reads."
        if rating == "Low":
            return "Likely null dereference or low impact crash."
        return "Insufficient data to determine exploitability."

    def _looks_controlled(self, value: str) -> bool:
        text = value.lower().replace("0x", "")
        if text in {"41414141", "4141414141414141", "42424242", "43434343"}:
            return True
        if len(text) < 4:
            return False
        chunk = text[:2]
        return chunk != "" and text.count(chunk) > 3

    def _parse_int(self, value: Optional[str]) -> Optional[int]:
        if value is None:
            return None
        if isinstance(value, int):
            return value
        try:
            return int(str(value), 16) if str(value).startswith("0x") else int(str(value))
        except Exception:
            return None

    def _match_suspicious(self, func_name: str) -> Optional[Dict[str, str]]:
        for entry in _SUSPICIOUS_FUNCTIONS:
            if entry["pattern"] in func_name:
                return entry
        return None

    def _summarize_suspicious(self, suspicious: List[Dict[str, Any]]) -> Dict[str, int]:
        summary = {"totalFunctions": len(suspicious), "highRisk": 0, "mediumRisk": 0, "lowRisk": 0}
        for func in suspicious:
            risk = func.get("risk")
            if risk == "high":
                summary["highRisk"] += 1
            elif risk == "medium":
                summary["mediumRisk"] += 1
            elif risk == "low":
                summary["lowRisk"] += 1
        return summary


_SUSPICIOUS_FUNCTIONS = [
    {
        "pattern": "malloc",
        "category": "memory_allocation",
        "risk": "medium",
        "description": "Memory allocation function - check for heap corruption",
    },
    {
        "pattern": "realloc",
        "category": "memory_allocation",
        "risk": "medium",
        "description": "Memory reallocation function - check for heap corruption",
    },
    {
        "pattern": "free",
        "category": "memory_allocation",
        "risk": "medium",
        "description": "Memory deallocation function - check for use-after-free",
    },
    {
        "pattern": "strcpy",
        "category": "unsafe_string",
        "risk": "high",
        "description": "Unsafe string copy - potential buffer overflow",
    },
    {
        "pattern": "strcat",
        "category": "unsafe_string",
        "risk": "high",
        "description": "Unsafe string concatenation - potential buffer overflow",
    },
    {
        "pattern": "sprintf",
        "category": "unsafe_string",
        "risk": "high",
        "description": "Unsafe string formatting - potential buffer overflow",
    },
    {
        "pattern": "gets",
        "category": "unsafe_string",
        "risk": "high",
        "description": "Unsafe input function - potential buffer overflow",
    },
    {
        "pattern": "memcpy",
        "category": "memory_operation",
        "risk": "medium",
        "description": "Memory copy - potential buffer overflow",
    },
    {
        "pattern": "memmove",
        "category": "memory_operation",
        "risk": "medium",
        "description": "Memory move - potential buffer overflow",
    },
    {
        "pattern": "memset",
        "category": "memory_operation",
        "risk": "medium",
        "description": "Memory set - check for size miscalculations",
    },
    {
        "pattern": "objc_msgsend",
        "category": "objective_c",
        "risk": "medium",
        "description": "Objective-C message dispatch - check for use-after-free",
    },
]
