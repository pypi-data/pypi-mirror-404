/**
 * Dataset Loader Module
 *
 * Implements the dataset-contract.md specification.
 * This module is the ONLY data layer - fully dataset-driven,
 * usable by both extension UI and future CLI dashboard.
 */

import {
  getErrorMessage,
  type DimensionsData,
  type DistributionData,
  type CoverageInfo,
  type PredictionsData,
  type InsightsData,
  type ManifestSchema,
} from "./types";
import {
  validateManifest,
  validateDimensions,
  validateRollup,
  validatePredictions,
  SchemaValidationError,
  type ValidationResult,
  type ArtifactType,
} from "./schemas";

// ============================================================================
// Validation Helpers
// ============================================================================

/**
 * Schema validator function signature.
 */
type SchemaValidator = (data: unknown, strict: boolean) => ValidationResult;

/**
 * Validate data against schema and throw SchemaValidationError on failure.
 * Logs warnings for unknown fields in permissive mode.
 *
 * @param data - Raw data to validate
 * @param validator - Schema validator function
 * @param artifactType - Type name for error messages (e.g., "manifest", "rollup")
 * @param strict - If true, unknown fields cause errors; if false, they cause warnings
 * @param context - Optional context for log messages (e.g., week identifier)
 * @throws SchemaValidationError if validation fails
 */
function validateSchema(
  data: unknown,
  validator: SchemaValidator,
  artifactType: ArtifactType,
  strict: boolean,
  context?: string,
): void {
  const result: ValidationResult = validator(data, strict);

  if (!result.valid) {
    throw new SchemaValidationError(result.errors, artifactType);
  }

  // Log warnings for unknown fields
  if (result.warnings.length > 0) {
    const contextSuffix = context ? ` for ${context}` : "";
    console.warn(
      `[DatasetLoader] ${artifactType} validation warnings${contextSuffix}:`,
      result.warnings.map((w) => w.message).join("; "),
    );
  }
}

// Supported schema versions (from dataset-contract.md)
const SUPPORTED_MANIFEST_VERSION = 1;
const SUPPORTED_DATASET_VERSION = 1;
const SUPPORTED_AGGREGATES_VERSION = 1;

/**
 * Candidate paths to search for dataset-manifest.json.
 * CRITICAL: Only flat layout supported (manifest at root OR in aggregates/).
 * Double-nesting (aggregates/aggregates) is DEPRECATED and will hard-fail.
 * Order matters: first match wins.
 */
export const DATASET_CANDIDATE_PATHS = [
  "", // Root of provided base URL (preferred)
  "aggregates", // Single nesting (legacy ADO artifact download)
];

/**
 * Error message for deprecated double-nested layout.
 */
export const DEPRECATED_LAYOUT_ERROR =
  "Deprecated dataset layout detected (aggregates/aggregates nesting). " +
  "This layout is no longer supported. Please re-run the pipeline with the " +
  "updated YAML configuration and re-stage artifacts.";

/**
 * Interface for Rollup data structure.
 */
export interface Rollup {
  week: string;
  pr_count: number;
  cycle_time_p50: number | null;
  cycle_time_p90: number | null;
  authors_count: number;
  reviewers_count: number;
  by_repository: Record<string, number> | null;
  by_team: Record<string, number> | null;
  [key: string]: unknown; // Allow for extra fields preserved during normalization
}

/**
 * Version Adapter Pattern (Phase 7.4)
 *
 * Normalizes rollup data across schema versions, providing sensible defaults
 * for missing fields in older datasets. This ensures backward compatibility
 * when loading datasets generated by older versions of the pipeline.
 */
export const ROLLUP_FIELD_DEFAULTS = {
  pr_count: 0,
  cycle_time_p50: null,
  cycle_time_p90: null,
  authors_count: 0,
  reviewers_count: 0,
  by_repository: null, // null indicates feature not available
  by_team: null, // null indicates feature not available
} as const;

/**
 * Normalize a single rollup object to ensure all expected fields exist.
 * @param rollup - Raw rollup data from JSON
 * @returns Normalized rollup with all expected fields
 */
export function normalizeRollup(rollup: unknown): Rollup {
  if (!rollup || typeof rollup !== "object") {
    return { week: "unknown", ...ROLLUP_FIELD_DEFAULTS };
  }

  const r = rollup as Record<string, unknown>;
  return {
    // Preserve all existing fields
    ...(r as Rollup),
    // Ensure required fields have defaults (don't override if already set)
    pr_count: (r.pr_count as number) ?? ROLLUP_FIELD_DEFAULTS.pr_count,
    cycle_time_p50:
      (r.cycle_time_p50 as number | null) ??
      ROLLUP_FIELD_DEFAULTS.cycle_time_p50,
    cycle_time_p90:
      (r.cycle_time_p90 as number | null) ??
      ROLLUP_FIELD_DEFAULTS.cycle_time_p90,
    authors_count:
      (r.authors_count as number) ?? ROLLUP_FIELD_DEFAULTS.authors_count,
    reviewers_count:
      (r.reviewers_count as number) ?? ROLLUP_FIELD_DEFAULTS.reviewers_count,
    // by_repository and by_team are optional features - preserve null if missing
    by_repository:
      r.by_repository !== undefined
        ? (r.by_repository as Record<string, number> | null)
        : null,
    by_team:
      r.by_team !== undefined
        ? (r.by_team as Record<string, number> | null)
        : null,
  };
}

/**
 * Normalize an array of rollup objects.
 * @param rollups - Array of raw rollup data
 * @returns Normalized rollups
 */
export function normalizeRollups(
  rollups: unknown[] | null | undefined,
): Rollup[] {
  if (!Array.isArray(rollups)) {
    return [];
  }
  return rollups.map(normalizeRollup);
}

/**
 * Semaphore for bounded concurrent fetching (Phase 4).
 * All fetches and retries MUST acquire through this singleton.
 */
export const fetchSemaphore = {
  maxConcurrent: 4,
  maxRetries: 1,
  retryDelayMs: 200,
  active: 0,
  queue: [] as Array<() => void>,

  /**
   * Acquire a semaphore slot. Blocks until slot available.
   * @returns {Promise<void>}
   */
  acquire(): Promise<void> {
    return new Promise((resolve) => {
      if (this.active < this.maxConcurrent) {
        this.active++;
        resolve();
      } else {
        this.queue.push(resolve);
      }
    });
  },

  /**
   * Release a semaphore slot. Unblocks next waiter if any.
   */
  release(): void {
    const next = this.queue.shift();
    if (next) {
      next();
    } else {
      this.active--;
    }
  },

  /**
   * Get current state (for testing).
   * @returns {{ active: number, queued: number }}
   */
  getState(): { active: number; queued: number } {
    return { active: this.active, queued: this.queue.length };
  },

  /**
   * Reset semaphore state (for testing).
   */
  reset(): void {
    this.active = 0;
    this.queue = [];
  },
};

/**
 * LRU Cache interface.
 */
export interface RollupCache {
  maxSize: number;
  ttlMs: number;
  clock: () => number;
  makeKey(params: { week: string; [key: string]: unknown }): string;
  get(key: string): Rollup | undefined;
  set(key: string, value: Rollup): void;
  has(key: string): boolean;
  clear(): void;
  size(): number;
}

/**
 * Create an LRU cache with TTL and bounded size (Phase 4).
 * @param clock - Injected time source (default: Date.now)
 * @returns Cache instance
 */
export function createRollupCache(clock: () => number = Date.now): RollupCache {
  const maxSize = 52; // 1 year of weeks
  const ttlMs = 5 * 60 * 1000; // 5 minutes
  const entries = new Map<
    string,
    { value: Rollup; createdAt: number; touchedAt: number }
  >();

  /**
   * Required fields for cache key.
   */
  const requiredKeyFields = ["week", "org", "project", "repo"] as const;

  return {
    maxSize,
    ttlMs,
    clock,

    /**
     * Build composite cache key. Throws if required params missing.
     */
    makeKey(params: {
      week: string;
      org: string;
      project: string;
      repo: string;
      branch?: string;
      apiVersion?: string;
    }) {
      for (const field of requiredKeyFields) {
        // eslint-disable-next-line security/detect-object-injection -- SECURITY: field is from const array of known property names
        if (!params[field]) {
          throw new Error(`Cache key missing required field: ${field}`);
        }
      }
      const {
        week,
        org,
        project,
        repo,
        branch = "",
        apiVersion = "1",
      } = params;
      return `${week}|${org}|${project}|${repo}|${branch}|${apiVersion}`;
    },

    /**
     * Get cached value if valid.
     */
    get(key: string) {
      const entry = entries.get(key);
      if (!entry) return undefined;

      const now = clock();
      if (now - entry.createdAt > ttlMs) {
        entries.delete(key);
        return undefined;
      }

      // Update LRU touch time
      entry.touchedAt = now;
      return entry.value;
    },

    /**
     * Set cache value, evicting oldest if at capacity.
     */
    set(key: string, value: Rollup) {
      const now = clock();

      // Evict oldest by touchedAt if at capacity
      if (entries.size >= maxSize && !entries.has(key)) {
        let oldestKey: string | null = null;
        let oldestTime = Infinity;
        for (const [k, v] of entries) {
          if (v.touchedAt < oldestTime) {
            oldestTime = v.touchedAt;
            oldestKey = k;
          }
        }
        if (oldestKey) entries.delete(oldestKey);
      }

      entries.set(key, {
        value,
        createdAt: now,
        touchedAt: now,
      });
    },

    /**
     * Check if key exists and is not expired.
     */
    has(key: string) {
      return this.get(key) !== undefined;
    },

    /**
     * Clear all entries.
     */
    clear() {
      entries.clear();
    },

    /**
     * Get cache size.
     */
    size() {
      return entries.size;
    },
  };
}

export interface ProgressEvent {
  loaded: number;
  total: number;
  currentWeek: string | null;
}

export interface RollupResult {
  data: Rollup[];
  missingWeeks: string[];
  failedWeeks: string[];
  partial: boolean;
  authError: boolean;
  degraded: boolean;
}

/**
 * Core interface for data loading.
 * Shared by both direct (fetch-based) and authenticated (ADO artifact-based) loaders.
 */
export interface IDatasetLoader {
  loadManifest(): Promise<ManifestSchema>;
  loadDimensions(): Promise<DimensionsData | null>;
  getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]>;
  getDistributions(startDate: Date, endDate: Date): Promise<DistributionData[]>;
  getCoverage(): CoverageInfo | null;
  getDefaultRangeDays(): number;
  loadPredictions?(): Promise<PredictionsData>;
  loadInsights?(): Promise<InsightsData>;
}

/**
 * Dataset loader state
 */
export class DatasetLoader implements IDatasetLoader {
  protected baseUrl: string;
  protected effectiveBaseUrl: string | null = null; // Resolved after probing
  protected manifest: ManifestSchema | null = null;
  protected dimensions: DimensionsData | null = null;
  protected rollupCache = new Map<string, Rollup>(); // week -> data
  protected distributionCache = new Map<string, DistributionData>(); // year -> data

  constructor(baseUrl?: string) {
    this.baseUrl = baseUrl || "";
    this.effectiveBaseUrl = null; // Will be resolved on first manifest load
  }

  /**
   * Resolve the dataset root by probing candidate paths for manifest.
   * Caches the result for subsequent path resolutions.
   * @returns The effective base URL or null if not found
   */
  async resolveDatasetRoot(): Promise<string | null> {
    if (this.effectiveBaseUrl !== null) {
      return this.effectiveBaseUrl || null;
    }

    for (const candidate of DATASET_CANDIDATE_PATHS) {
      const candidateBase = candidate
        ? `${this.baseUrl}/${candidate}`
        : this.baseUrl;
      const manifestUrl = candidateBase
        ? `${candidateBase}/dataset-manifest.json`
        : "dataset-manifest.json";

      try {
        const response = await fetch(manifestUrl, { method: "HEAD" });
        if (response.ok) {
          console.log("[DatasetLoader] Found manifest at: %s", manifestUrl);
          this.effectiveBaseUrl = candidateBase;
          return candidateBase;
        }
      } catch {
        // Continue to next candidate on network error
      }
    }

    // No manifest found in any candidate path - fall back to original baseUrl
    console.warn(
      "[DatasetLoader] No manifest found in candidate paths, using baseUrl as fallback",
    );
    this.effectiveBaseUrl = this.baseUrl;
    return null;
  }

  /**
   * Load and validate the dataset manifest.
   * Automatically resolves nested dataset root before loading.
   */
  async loadManifest(): Promise<ManifestSchema> {
    // Return cached manifest if already loaded and validated
    if (this.manifest) {
      return this.manifest;
    }

    // Resolve dataset root if not already done
    if (this.effectiveBaseUrl === null) {
      await this.resolveDatasetRoot();
    }

    const url = this.resolvePath("dataset-manifest.json");
    const response = await fetch(url);

    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(
          "Dataset not found. Ensure the analytics pipeline has run successfully.",
        );
      }
      throw new Error(
        `Failed to load manifest: ${response.status} ${response.statusText}`,
      );
    }

    const manifest = await response.json();
    this.validateManifestSchema(manifest);
    this.manifest = manifest;
    return manifest;
  }

  /**
   * Validate manifest schema using schema validator.
   * Throws SchemaValidationError on invalid data.
   */
  protected validateManifestSchema(manifest: unknown): void {
    validateSchema(manifest, validateManifest, "manifest", true);

    // Additional version checks after schema validation
    // Schema validator ensures manifest_schema_version exists, but TypeScript needs explicit check
    const m = manifest as ManifestSchema;
    if (
      m.manifest_schema_version !== undefined &&
      m.manifest_schema_version > SUPPORTED_MANIFEST_VERSION
    ) {
      throw new Error(
        `Manifest version ${m.manifest_schema_version} not supported. ` +
          `Maximum supported: ${SUPPORTED_MANIFEST_VERSION}. ` +
          `Please update the extension.`,
      );
    }

    if (
      m.dataset_schema_version !== undefined &&
      m.dataset_schema_version > SUPPORTED_DATASET_VERSION
    ) {
      throw new Error(
        `Dataset version ${m.dataset_schema_version} not supported. ` +
          `Please update the extension.`,
      );
    }

    if (
      m.aggregates_schema_version !== undefined &&
      m.aggregates_schema_version > SUPPORTED_AGGREGATES_VERSION
    ) {
      throw new Error(
        `Aggregates version ${m.aggregates_schema_version} not supported. ` +
          `Please update the extension.`,
      );
    }
  }

  /**
   * Load dimensions (filter values).
   * Validates against schema and throws SchemaValidationError on invalid data.
   */
  async loadDimensions(): Promise<DimensionsData | null> {
    if (this.dimensions) return this.dimensions;

    const url = this.resolvePath("aggregates/dimensions.json");
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`Failed to load dimensions: ${response.status}`);
    }

    const rawDimensions = await response.json();

    // Validate against schema (strict mode)
    validateSchema(rawDimensions, validateDimensions, "dimensions", true);

    this.dimensions = rawDimensions as DimensionsData;
    return this.dimensions;
  }

  /**
   * Get weekly rollups for a date range.
   * Implements lazy loading with caching.
   */
  async getWeeklyRollups(startDate: Date, endDate: Date): Promise<Rollup[]> {
    if (!this.manifest) {
      throw new Error("Manifest not loaded. Call loadManifest() first.");
    }

    const neededWeeks = this.getWeeksInRange(startDate, endDate);
    const results: Rollup[] = [];

    for (const weekStr of neededWeeks) {
      // Check cache first
      const cached = this.rollupCache.get(weekStr);
      if (cached) {
        results.push(cached);
        continue;
      }

      // Find in index
      const indexEntry = this.manifest?.aggregate_index?.weekly_rollups?.find(
        (r) => r.week === weekStr,
      );

      if (!indexEntry) {
        // No data for this week, skip
        continue;
      }

      // Fetch and cache
      const url = this.resolvePath(indexEntry.path);
      const response = await fetch(url);

      if (response.ok) {
        const rawData = await response.json();

        // Validate rollup data (permissive mode - unknown fields produce warnings)
        validateSchema(rawData, validateRollup, "rollup", false, weekStr);

        // Apply version adapter to normalize rollup data
        const data = normalizeRollup(rawData);
        this.rollupCache.set(weekStr, data);
        results.push(data);
      }
    }

    return results.sort((a, b) => a.week.localeCompare(b.week));
  }

  /**
   * Get weekly rollups with concurrent fetching, progress reporting, and caching (Phase 4).
   */
  async getWeeklyRollupsWithProgress(
    startDate: Date,
    endDate: Date,
    context: {
      org: string;
      project: string;
      repo: string;
      branch?: string;
      apiVersion?: string;
    },
    onProgress: (event: ProgressEvent) => void = () => {},
    cache: RollupCache | null = null,
  ): Promise<RollupResult> {
    if (!this.manifest) {
      throw new Error("Manifest not loaded. Call loadManifest() first.");
    }

    const allWeeks = this.getWeeksInRange(startDate, endDate);
    const data: Rollup[] = [];
    const missingWeeks: string[] = [];
    const failedWeeks: string[] = [];
    let authError = false;

    // Use provided cache or default simple cache
    const useCache: RollupCache =
      cache ||
      ({
        makeKey: (params: { week: string; [key: string]: unknown }) =>
          params.week,
        get: (key: string) => this.rollupCache.get(key),
        set: (key: string, value: Rollup) => this.rollupCache.set(key, value),
        has: (key: string) => this.rollupCache.has(key),
        maxSize: Infinity,
        ttlMs: Infinity,
        clock: Date.now,
        clear: () => this.rollupCache.clear(),
        size: () => this.rollupCache.size,
      } satisfies RollupCache);

    // Separate cache hits from fetch needed
    const cachedResults: Rollup[] = [];
    const weeksToFetch: string[] = [];

    for (const weekStr of allWeeks) {
      try {
        const cacheKey = useCache.makeKey({ week: weekStr, ...context });
        const cached = useCache.get(cacheKey);
        if (cached !== undefined) {
          cachedResults.push(cached);
        } else {
          weeksToFetch.push(weekStr);
        }
      } catch {
        // Cache key failed, need to fetch
        weeksToFetch.push(weekStr);
      }
    }

    // Batch concurrent fetches with semaphore
    const batches: string[][] = [];
    for (
      let i = 0;
      i < weeksToFetch.length;
      i += fetchSemaphore.maxConcurrent
    ) {
      batches.push(weeksToFetch.slice(i, i + fetchSemaphore.maxConcurrent));
    }

    let loaded = 0;
    const total = weeksToFetch.length;

    for (const batch of batches) {
      const batchPromises = batch.map(async (weekStr) => {
        // Progress: report week being requested
        onProgress({ loaded, total, currentWeek: weekStr });

        // Find in index
        const indexEntry = this.manifest?.aggregate_index?.weekly_rollups?.find(
          (r) => r.week === weekStr,
        );

        if (!indexEntry) {
          return { week: weekStr, status: "missing" as const };
        }

        // Fetch with semaphore and retry
        return await this._fetchWeekWithRetry(
          weekStr,
          indexEntry,
          context,
          useCache,
        );
      });

      const results = await Promise.allSettled(batchPromises);

      for (const result of results) {
        loaded++;
        if (result.status === "fulfilled") {
          const outcome = result.value;
          if (outcome.status === "ok") {
            data.push(outcome.data);
          } else if (outcome.status === "missing") {
            missingWeeks.push(outcome.week);
          } else if (outcome.status === "auth") {
            authError = true;
          } else if (outcome.status === "failed") {
            failedWeeks.push(outcome.week);
          }
        } else {
          // Promise rejected - shouldn't happen with our error handling
          failedWeeks.push("unknown");
        }
      }
    }

    // Combine cached and fetched
    const allData = [...cachedResults, ...data];
    const partial = missingWeeks.length > 0 || failedWeeks.length > 0;
    const degraded = partial || authError;

    // INVARIANT: auth error with no data = hard fail
    if (authError && allData.length === 0) {
      const error = new Error("Authentication required") as Error & {
        code?: string;
      };
      error.code = "AUTH_REQUIRED";
      throw error;
    }

    // Final progress
    onProgress({ loaded: total, total, currentWeek: null });

    return {
      data: allData.sort((a, b) => a.week.localeCompare(b.week)),
      missingWeeks,
      failedWeeks,
      partial,
      authError,
      degraded,
    };
  }

  /**
   * Fetch a single week with semaphore control and bounded retry.
   */
  protected async _fetchWeekWithRetry(
    weekStr: string,
    indexEntry: { week: string; path: string },
    context: Record<string, unknown>,
    cache: RollupCache,
  ): Promise<
    | { week: string; status: "ok"; data: Rollup }
    | { week: string; status: "auth" | "missing" | "failed"; error?: string }
  > {
    let retries = 0;

    while (retries <= fetchSemaphore.maxRetries) {
      await fetchSemaphore.acquire();
      try {
        const url = this.resolvePath(indexEntry.path);
        const response = await fetch(url);

        if (response.ok) {
          const rawData = await response.json();
          // Apply version adapter to normalize rollup data
          const data = normalizeRollup(rawData);
          try {
            const cacheKey = cache.makeKey({ week: weekStr, ...context });
            cache.set(cacheKey, data);
          } catch {
            // Cache key error, still return data
          }
          return { week: weekStr, status: "ok", data };
        }

        if (response.status === 401 || response.status === 403) {
          return { week: weekStr, status: "auth" };
        }

        if (response.status === 404) {
          return { week: weekStr, status: "missing" };
        }

        // 5xx - retry once
        if (response.status >= 500 && retries < fetchSemaphore.maxRetries) {
          retries++;
          await this._delay(fetchSemaphore.retryDelayMs);
          continue;
        }

        return {
          week: weekStr,
          status: "failed",
          error: `HTTP ${response.status}`,
        };
      } catch (err: unknown) {
        // Network error - retry once
        if (retries < fetchSemaphore.maxRetries) {
          retries++;
          await this._delay(fetchSemaphore.retryDelayMs);
          continue;
        }
        return { week: weekStr, status: "failed", error: getErrorMessage(err) };
      } finally {
        fetchSemaphore.release();
      }
    }

    return { week: weekStr, status: "failed", error: "max retries exceeded" };
  }

  /**
   * Delay helper for retry backoff.
   */
  protected _delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  /**
   * Get yearly distributions for a date range.
   */
  async getDistributions(
    startDate: Date,
    endDate: Date,
  ): Promise<DistributionData[]> {
    if (!this.manifest) {
      throw new Error("Manifest not loaded. Call loadManifest() first.");
    }

    const startYear = startDate.getFullYear();
    const endYear = endDate.getFullYear();
    const results: DistributionData[] = [];

    for (let year = startYear; year <= endYear; year++) {
      const yearStr = year.toString();

      // Check cache
      const cached = this.distributionCache.get(yearStr);
      if (cached) {
        results.push(cached);
        continue;
      }

      // Find in index
      const indexEntry = this.manifest?.aggregate_index?.distributions?.find(
        (d) => d.year === yearStr,
      );

      if (!indexEntry) continue;

      // Fetch and cache
      const url = this.resolvePath(indexEntry.path);
      const response = await fetch(url);

      if (response.ok) {
        const data = await response.json();
        this.distributionCache.set(yearStr, data);
        results.push(data);
      }
    }

    return results;
  }

  /**
   * Check if a feature is enabled in the dataset.
   */
  isFeatureEnabled(feature: string): boolean {
    if (!this.manifest) return false;
    // eslint-disable-next-line security/detect-object-injection -- SECURITY: feature is string parameter for checking known feature flags
    return this.manifest.features?.[feature] === true;
  }

  /**
   * Get dataset coverage info.
   */
  getCoverage(): CoverageInfo | null {
    if (!this.manifest) return null;
    return this.manifest.coverage ?? null;
  }

  /**
   * Get default date range days.
   */
  getDefaultRangeDays(): number {
    return this.manifest?.defaults?.default_date_range_days || 90;
  }

  /**
   * Load predictions data (Phase 3.5).
   * Validates against schema (permissive mode - unknown fields produce warnings).
   */
  async loadPredictions(): Promise<PredictionsData> {
    if (!this.isFeatureEnabled("predictions")) {
      return { state: "disabled" };
    }

    try {
      const url = this.resolvePath("predictions/trends.json");
      const response = await fetch(url);

      if (!response.ok) {
        if (response.status === 404) {
          return { state: "missing" };
        }
        if (response.status === 401 || response.status === 403) {
          return { state: "auth" };
        }
        return {
          state: "error",
          error: "PRED_003",
          message: `HTTP ${response.status}`,
        };
      }

      const predictions = await response.json();

      // Validate using full schema validator (permissive mode)
      const schemaResult: ValidationResult = validatePredictions(
        predictions,
        false,
      );
      if (!schemaResult.valid) {
        console.error(
          "[DatasetLoader] Invalid predictions schema:",
          schemaResult.errors.map((e) => e.message).join("; "),
        );
        return {
          state: "invalid",
          error: "PRED_001",
          message:
            schemaResult.errors[0]?.message ?? "Schema validation failed",
        };
      }

      // Log warnings for unknown fields in permissive mode
      if (schemaResult.warnings.length > 0) {
        console.warn(
          "[DatasetLoader] Predictions validation warnings:",
          schemaResult.warnings.map((w) => w.message).join("; "),
        );
      }

      return { state: "ok", data: predictions };
    } catch (err: unknown) {
      console.error("[DatasetLoader] Error loading predictions:", err);
      return {
        state: "error",
        error: "PRED_002",
        message: getErrorMessage(err),
      };
    }
  }

  /**
   * Load AI insights data (Phase 3.5).
   */
  async loadInsights(): Promise<InsightsData> {
    if (!this.isFeatureEnabled("ai_insights")) {
      return { state: "disabled" };
    }

    try {
      const url = this.resolvePath("insights/summary.json");
      const response = await fetch(url);

      if (!response.ok) {
        if (response.status === 404) {
          return { state: "missing" };
        }
        if (response.status === 401 || response.status === 403) {
          return { state: "auth" };
        }
        return {
          state: "error",
          error: "AI_003",
          message: `HTTP ${response.status}`,
        };
      }

      const insights = await response.json();

      // Validate schema version
      const validationResult = this.validateInsightsSchema(insights);
      if (!validationResult.valid) {
        console.error(
          "[DatasetLoader] Invalid insights schema:",
          validationResult.error,
        );
        return {
          state: "invalid",
          error: "AI_001",
          message: validationResult.error,
        };
      }

      return { state: "ok", data: insights };
    } catch (err: unknown) {
      console.error("[DatasetLoader] Error loading insights:", err);
      return { state: "error", error: "AI_002", message: getErrorMessage(err) };
    }
  }

  /**
   * Validate predictions schema.
   */
  protected validatePredictionsSchema(predictions: unknown): {
    valid: boolean;
    error?: string;
  } {
    if (!predictions || typeof predictions !== "object")
      return { valid: false, error: "Missing predictions data" };
    const p = predictions as Record<string, unknown>;
    if (typeof p.schema_version !== "number") {
      return { valid: false, error: "Missing schema_version" };
    }
    if (p.schema_version > 1) {
      return {
        valid: false,
        error: `Unsupported schema version: ${p.schema_version}`,
      };
    }
    if (!Array.isArray(p.forecasts)) {
      return { valid: false, error: "Missing forecasts array" };
    }
    // Validate each forecast has required fields
    for (const forecast of p.forecasts as Array<Record<string, unknown>>) {
      if (
        !forecast.metric ||
        !forecast.unit ||
        !Array.isArray(forecast.values)
      ) {
        return { valid: false, error: "Invalid forecast structure" };
      }
    }
    return { valid: true };
  }

  /**
   * Validate insights schema.
   */
  protected validateInsightsSchema(insights: unknown): {
    valid: boolean;
    error?: string;
  } {
    if (!insights || typeof insights !== "object")
      return { valid: false, error: "Missing insights data" };
    const i = insights as Record<string, unknown>;
    if (typeof i.schema_version !== "number") {
      return { valid: false, error: "Missing schema_version" };
    }
    if (i.schema_version > 1) {
      return {
        valid: false,
        error: `Unsupported schema version: ${i.schema_version}`,
      };
    }
    if (!Array.isArray(i.insights)) {
      return { valid: false, error: "Missing insights array" };
    }
    // Validate each insight has required fields
    for (const insight of i.insights as Array<Record<string, unknown>>) {
      if (
        !insight.id ||
        !insight.category ||
        !insight.severity ||
        !insight.title
      ) {
        return { valid: false, error: "Invalid insight structure" };
      }
    }
    return { valid: true };
  }

  /**
   * Resolve a relative path to full URL.
   * Uses effectiveBaseUrl if resolved, otherwise falls back to baseUrl.
   */
  protected resolvePath(relativePath: string): string {
    // Use effective base URL if resolved (supports nested layouts)
    const base =
      this.effectiveBaseUrl !== null ? this.effectiveBaseUrl : this.baseUrl;
    if (base) {
      return `${base}/${relativePath}`;
    }
    return relativePath;
  }

  /**
   * Get ISO week strings for a date range.
   */
  getWeeksInRange(start: Date, end: Date): string[] {
    const weeks: string[] = [];
    const current = new Date(start);

    while (current <= end) {
      const weekStr = this.getISOWeek(current);
      if (!weeks.includes(weekStr)) {
        weeks.push(weekStr);
      }
      current.setDate(current.getDate() + 7);
    }

    // Ensure we include the end date's week
    const endWeek = this.getISOWeek(end);
    if (!weeks.includes(endWeek)) {
      weeks.push(endWeek);
    }

    return weeks;
  }

  /**
   * Get ISO week string for a date.
   */
  getISOWeek(date: Date): string {
    const d = new Date(
      Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
    );
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    const weekNo = Math.ceil(
      ((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7,
    );
    return `${d.getUTCFullYear()}-W${weekNo.toString().padStart(2, "0")}`;
  }
}

// Browser global exports for runtime compatibility
if (typeof window !== "undefined") {
  window.DatasetLoader = DatasetLoader;
  window.fetchSemaphore = fetchSemaphore;
  window.createRollupCache = createRollupCache;
  window.normalizeRollup = normalizeRollup;
  window.normalizeRollups = normalizeRollups;
  window.ROLLUP_FIELD_DEFAULTS = ROLLUP_FIELD_DEFAULTS;
}
