from __future__ import annotations

from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, TypeVar

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..models.e_malware_backup_scan_mode import EMalwareBackupScanMode
from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.backup_object_pair import BackupObjectPair
    from ..models.malware_backup_scan_range import MalwareBackupScanRange
    from ..models.malware_backup_scan_spec_engine import MalwareBackupScanSpecEngine


T = TypeVar("T", bound="MalwareBackupScanSpec")


@_attrs_define
class MalwareBackupScanSpec:
    """
    Attributes:
        backup_object_pair (list[BackupObjectPair]): Array of objects containing the backup IDs and backup object IDs.
        scan_mode (EMalwareBackupScanMode): Backup scan mode.
        scan_engine (MalwareBackupScanSpecEngine): Type of backup scan engine.
        scan_range (MalwareBackupScanRange | Unset): Backup scan range. If you do not specify this parameter, Veeam
            Backup & Replication will scan all available restore points.
        continue_scan (bool | Unset): If `true`, the backup scan will continue even after it finds affected restore
            points.
    """

    backup_object_pair: list[BackupObjectPair]
    scan_mode: EMalwareBackupScanMode
    scan_engine: MalwareBackupScanSpecEngine
    scan_range: MalwareBackupScanRange | Unset = UNSET
    continue_scan: bool | Unset = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        backup_object_pair = []
        for backup_object_pair_item_data in self.backup_object_pair:
            backup_object_pair_item = backup_object_pair_item_data.to_dict()
            backup_object_pair.append(backup_object_pair_item)

        scan_mode = self.scan_mode.value

        scan_engine = self.scan_engine.to_dict()

        scan_range: dict[str, Any] | Unset = UNSET
        if not isinstance(self.scan_range, Unset):
            scan_range = self.scan_range.to_dict()

        continue_scan = self.continue_scan

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "backupObjectPair": backup_object_pair,
                "scanMode": scan_mode,
                "scanEngine": scan_engine,
            }
        )
        if scan_range is not UNSET:
            field_dict["scanRange"] = scan_range
        if continue_scan is not UNSET:
            field_dict["continueScan"] = continue_scan

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.backup_object_pair import BackupObjectPair
        from ..models.malware_backup_scan_range import MalwareBackupScanRange
        from ..models.malware_backup_scan_spec_engine import MalwareBackupScanSpecEngine

        d = dict(src_dict)
        backup_object_pair = []
        _backup_object_pair = d.pop("backupObjectPair")
        for backup_object_pair_item_data in _backup_object_pair:
            backup_object_pair_item = BackupObjectPair.from_dict(backup_object_pair_item_data)

            backup_object_pair.append(backup_object_pair_item)

        scan_mode = EMalwareBackupScanMode(d.pop("scanMode"))

        scan_engine = MalwareBackupScanSpecEngine.from_dict(d.pop("scanEngine"))

        _scan_range = d.pop("scanRange", UNSET)
        scan_range: MalwareBackupScanRange | Unset
        if isinstance(_scan_range, Unset):
            scan_range = UNSET
        else:
            scan_range = MalwareBackupScanRange.from_dict(_scan_range)

        continue_scan = d.pop("continueScan", UNSET)

        malware_backup_scan_spec = cls(
            backup_object_pair=backup_object_pair,
            scan_mode=scan_mode,
            scan_engine=scan_engine,
            scan_range=scan_range,
            continue_scan=continue_scan,
        )

        malware_backup_scan_spec.additional_properties = d
        return malware_backup_scan_spec

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
