"use strict";(self.webpackChunksolace_agenitc_mesh_docs=self.webpackChunksolace_agenitc_mesh_docs||[]).push([[5632],{6284:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"documentation/developing/creating-workflows","title":"Creating Workflows","description":"This guide walks through building workflows that orchestrate multiple agents. You\'ll learn how to define execution sequences, pass data between nodes, handle branching logic, and process collections.","source":"@site/docs/documentation/developing/creating-workflows.md","sourceDirName":"documentation/developing","slug":"/documentation/developing/creating-workflows","permalink":"/solace-agent-mesh/docs/documentation/developing/creating-workflows","draft":false,"unlisted":false,"editUrl":"https://github.com/SolaceLabs/solace-agent-mesh/edit/main/docs/docs/documentation/developing/creating-workflows.md","tags":[],"version":"current","sidebarPosition":425,"frontMatter":{"title":"Creating Workflows","sidebar_position":425},"sidebar":"docSidebar","previous":{"title":"Creating Agents","permalink":"/solace-agent-mesh/docs/documentation/developing/create-agents"},"next":{"title":"Creating Custom Gateways","permalink":"/solace-agent-mesh/docs/documentation/developing/create-gateways"}}');var i=t(4848),a=t(8453);const o={title:"Creating Workflows",sidebar_position:425},r="Creating Workflows",l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Your First Workflow",id:"your-first-workflow",level:2},{value:"Running a Workflow",id:"running-a-workflow",level:2},{value:"Passing Data with Templates",id:"passing-data-with-templates",level:2},{value:"Workflow Input",id:"workflow-input",level:3},{value:"Node Output",id:"node-output",level:3},{value:"Handling Missing Values",id:"handling-missing-values",level:3},{value:"Adding Instructions",id:"adding-instructions",level:2},{value:"Conditional Branching",id:"conditional-branching",level:2},{value:"Processing Collections",id:"processing-collections",level:2},{value:"Polling with Loops",id:"polling-with-loops",level:2},{value:"Composing Workflows",id:"composing-workflows",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Retries",id:"retries",level:3},{value:"Exit Handlers",id:"exit-handlers",level:3},{value:"Timeouts",id:"timeouts",level:2},{value:"Testing Workflows",id:"testing-workflows",level:2},{value:"Example Workflows",id:"example-workflows",level:2},{value:"Reference",id:"reference",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"creating-workflows",children:"Creating Workflows"})}),"\n",(0,i.jsx)(n.p,{children:"This guide walks through building workflows that orchestrate multiple agents. You'll learn how to define execution sequences, pass data between nodes, handle branching logic, and process collections."}),"\n",(0,i.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(n.p,{children:"Before creating workflows, you need:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A running Solace Agent Mesh instance"}),"\n",(0,i.jsxs)(n.li,{children:["The shared configuration file ",(0,i.jsx)(n.a,{href:"https://github.com/SolaceDev/solace-agent-mesh/blob/main/examples/shared_config.yaml",children:(0,i.jsx)(n.code,{children:"examples/shared_config.yaml"})})," which defines broker connections, LLM models, and service configurations"]}),"\n",(0,i.jsx)(n.li,{children:"Familiarity with YAML configuration files"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"your-first-workflow",children:"Your First Workflow"}),"\n",(0,i.jsxs)(n.p,{children:["Create a file called ",(0,i.jsx)(n.code,{children:"text_analysis_workflow.yaml"}),". This workflow calls two agents in sequence: one to analyze text and another to summarize the analysis."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that for simplicity the ",(0,i.jsx)(n.strong,{children:"agents and workflows are defined in the same file below"}),". While this is convenient for examples, in production you might separate them. The workflow references agents by their ",(0,i.jsx)(n.code,{children:"agent_name"}),", and everything runs together."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'log:\n  stdout_log_level: INFO\n  log_file_level: DEBUG\n  log_file: text_analysis_workflow.log\n\n# Import shared configuration (broker, models, services)\n# Note that this file is in the examples/ directory\n!include ../shared_config.yaml\n\napps:\n  # ============================================================================\n  # AGENT: Text Analyzer\n  # Analyzes text and identifies key themes\n  # ============================================================================\n  - name: text_analyzer_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "TextAnalyzer"\n      model: *planning_model\n\n      instruction: |\n        You analyze text content.\n        1. Read the \'content\' from input\n        2. Identify key themes, sentiment, and notable phrases\n\n      # Note that input_schema can be optionally defined in the agent config\n      # and overridden in the workflow if desired.\n      input_schema:\n        type: object\n        properties:\n          content: {type: string, description: "Text to analyze"}\n        required: [content]\n\n      # Note that output_schema can be optionally defined in the agent config\n      # and overridden in the workflow if desired.\n      output_schema:\n        type: object\n        properties:\n          themes: {type: array, items: {type: string}}\n          sentiment: {type: string}\n          word_count: {type: integer}\n        required: [themes, sentiment]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Analyzes text content for themes and sentiment"\n        skills: [{id: "analyze", name: "Analyze Text", description: "Analyzes text", tags: ["analysis"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # AGENT: Summarizer\n  # Creates summaries from analysis results\n  # ============================================================================\n  - name: summarizer_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "Summarizer"\n      model: *planning_model\n\n      instruction: |\n        You create summaries from analysis results.\n        1. Read the \'analysis\' from input\n        2. Create a concise summary highlighting key points\n\n      input_schema:\n        type: object\n        properties:\n          analysis: {type: object, description: "Analysis results to summarize"}\n        required: [analysis]\n\n      output_schema:\n        type: object\n        properties:\n          summary: {type: string}\n          key_points: {type: array, items: {type: string}}\n        required: [summary, key_points]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Creates summaries from analysis"\n        skills: [{id: "summarize", name: "Summarize", description: "Summarizes content", tags: ["summary"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # WORKFLOW: Text Analysis Pipeline\n  # Orchestrates the analysis and summarization agents\n  # ============================================================================\n  - name: text_analysis_workflow\n    app_base_path: .\n    app_module: solace_agent_mesh.workflow.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "TextAnalysisWorkflow"\n\n      workflow:\n        description: "Analyzes text and produces a summary"\n\n        input_schema:\n          type: object\n          properties:\n            text:\n              type: string\n              description: "Text to analyze"\n          required: [text]\n\n        nodes:\n          - id: analyze\n            type: agent\n            agent_name: "TextAnalyzer"\n            input:\n              content: "{{workflow.input.text}}"\n\n          - id: summarize\n            type: agent\n            agent_name: "Summarizer"\n            depends_on: [analyze]\n            input:\n              analysis: "{{analyze.output}}"\n              max_points: 5\n            # Override the agent\'s default input_schema for this workflow.\n            # This adds a \'max_points\' field that the agent doesn\'t normally expect.\n            input_schema:\n              type: object\n              properties:\n                analysis: {type: object, description: "Analysis results to summarize"}\n                max_points: {type: integer, description: "Maximum number of key points to return"}\n              required: [analysis]\n            # Additional instructions for this workflow invocation\n            instruction: "Limit the key_points array to at most `max_points` items."\n\n        output_mapping:\n          summary: "{{summarize.output.summary}}"\n          key_points: "{{summarize.output.key_points}}"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Key points:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"!include"})," directive imports shared configuration with broker, model, and service definitions"]}),"\n",(0,i.jsxs)(n.li,{children:["Both agents and the workflow are in the same ",(0,i.jsx)(n.code,{children:"apps"})," list"]}),"\n",(0,i.jsxs)(n.li,{children:["The workflow uses ",(0,i.jsx)(n.code,{children:"app_module: solace_agent_mesh.workflow.app"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"depends_on: [analyze]"})," ensures ",(0,i.jsx)(n.code,{children:"summarize"})," waits for ",(0,i.jsx)(n.code,{children:"analyze"})," to complete"]}),"\n",(0,i.jsxs)(n.li,{children:["Template expressions like ",(0,i.jsx)(n.code,{children:"{{analyze.output}}"})," pass data between nodes"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"summarize"})," node overrides the agent's ",(0,i.jsx)(n.code,{children:"input_schema"})," to add a ",(0,i.jsx)(n.code,{children:"max_points"})," field\u2014useful when a workflow needs different input than what the agent defines by default"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"instruction"})," field on the ",(0,i.jsx)(n.code,{children:"summarize"})," node provides additional context to the agent for this specific workflow invocation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"running-a-workflow",children:"Running a Workflow"}),"\n",(0,i.jsx)(n.p,{children:"Run the workflow file directly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"sam run text_analysis_workflow.yaml\n"})}),"\n",(0,i.jsx)(n.p,{children:"Workflows register as agents, so you can invoke them the same way you'd invoke any agent. The workflow appears in the UI's agent list and can be triggered through any gateway."}),"\n",(0,i.jsx)(n.h2,{id:"passing-data-with-templates",children:"Passing Data with Templates"}),"\n",(0,i.jsx)(n.p,{children:"Template expressions connect your workflow's pieces together."}),"\n",(0,i.jsx)(n.h3,{id:"workflow-input",children:"Workflow Input"}),"\n",(0,i.jsxs)(n.p,{children:["Access input fields with ",(0,i.jsx)(n.code,{children:"{{workflow.input.field_name}}"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'input_schema:\n  type: object\n  properties:\n    customer_id:\n      type: string\n    include_history:\n      type: boolean\n\nnodes:\n  - id: fetch_customer\n    type: agent\n    agent_name: "CustomerService"\n    input:\n      id: "{{workflow.input.customer_id}}"\n      fetch_history: "{{workflow.input.include_history}}"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"node-output",children:"Node Output"}),"\n",(0,i.jsxs)(n.p,{children:["Reference completed nodes with ",(0,i.jsx)(n.code,{children:"{{node_id.output.field}}"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- id: validate\n  type: agent\n  agent_name: "Validator"\n  input:\n    data: "{{workflow.input.payload}}"\n\n- id: process\n  type: agent\n  agent_name: "Processor"\n  depends_on: [validate]\n  input:\n    validated_data: "{{validate.output.cleaned_data}}"\n    validation_score: "{{validate.output.confidence}}"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"handling-missing-values",children:"Handling Missing Values"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"coalesce"})," when a value might not exist:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- id: enrich\n  type: agent\n  agent_name: "DataEnricher"\n  input:\n    primary_source: "{{workflow.input.preferred_source}}"\n    data:\n      coalesce:\n        - "{{optional_step.output.result}}"\n        - "{{workflow.input.fallback_data}}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"The first non-null value is used."}),"\n",(0,i.jsx)(n.h2,{id:"adding-instructions",children:"Adding Instructions"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"instruction"})," field provides context to agents beyond the structured input:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- id: generate_report\n  type: agent\n  agent_name: "ReportGenerator"\n  input:\n    data: "{{analysis.output.metrics}}"\n  instruction: |\n    Generate an executive summary for {{workflow.input.audience}}.\n    Focus on trends related to {{workflow.input.focus_area}}.\n    Keep the tone {{workflow.input.tone}}.\n'})}),"\n",(0,i.jsx)(n.p,{children:"Instructions support the same template expressions as input fields."}),"\n",(0,i.jsx)(n.h2,{id:"conditional-branching",children:"Conditional Branching"}),"\n",(0,i.jsxs)(n.p,{children:["Switch nodes route execution based on data values. Here's a complete example. Save this as ",(0,i.jsx)(n.code,{children:"request_router_workflow.yaml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'log:\n  stdout_log_level: INFO\n  log_file_level: DEBUG\n  log_file: request_router_workflow.log\n\n!include ../shared_config.yaml\n\napps:\n  # ============================================================================\n  # AGENT: Request Classifier\n  # ============================================================================\n  - name: classifier_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "RequestClassifier"\n      model: *planning_model\n\n      instruction: |\n        Classify the incoming request.\n        1. Read the \'request\' text\n        2. Determine the type: "billing", "technical", or "general"\n        3. Assess urgency: "high", "medium", or "low"\n\n      input_schema:\n        type: object\n        properties:\n          request: {type: string}\n        required: [request]\n\n      output_schema:\n        type: object\n        properties:\n          type: {type: string, enum: ["billing", "technical", "general"]}\n          urgency: {type: string, enum: ["high", "medium", "low"]}\n        required: [type, urgency]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Classifies support requests"\n        skills: [{id: "classify", name: "Classify Request", description: "Classifies requests", tags: ["classification"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # AGENTS: Handlers for each request type\n  # ============================================================================\n  - name: billing_handler_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "BillingHandler"\n      model: *planning_model\n\n      instruction: |\n        Handle billing-related requests.\n        1. Read the \'request\' text\n        2. Generate an appropriate response\n\n      input_schema:\n        type: object\n        properties:\n          request: {type: string}\n        required: [request]\n\n      output_schema:\n        type: object\n        properties:\n          response: {type: string}\n          handler: {type: string}\n        required: [response, handler]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Handles billing requests"\n        skills: [{id: "billing", name: "Handle Billing", description: "Billing support", tags: ["billing"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  - name: technical_handler_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "TechnicalHandler"\n      model: *planning_model\n\n      instruction: |\n        Handle technical support requests.\n        1. Read the \'request\' text\n        2. Generate an appropriate technical response\n\n      input_schema:\n        type: object\n        properties:\n          request: {type: string}\n        required: [request]\n\n      output_schema:\n        type: object\n        properties:\n          response: {type: string}\n          handler: {type: string}\n        required: [response, handler]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Handles technical requests"\n        skills: [{id: "technical", name: "Handle Technical", description: "Technical support", tags: ["technical"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  - name: general_handler_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "GeneralHandler"\n      model: *planning_model\n\n      instruction: |\n        Handle general inquiries.\n        1. Read the \'request\' text\n        2. Generate a helpful response\n\n      input_schema:\n        type: object\n        properties:\n          request: {type: string}\n        required: [request]\n\n      output_schema:\n        type: object\n        properties:\n          response: {type: string}\n          handler: {type: string}\n        required: [response, handler]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Handles general inquiries"\n        skills: [{id: "general", name: "Handle General", description: "General support", tags: ["general"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # WORKFLOW: Request Router\n  # ============================================================================\n  - name: request_router_workflow\n    app_base_path: .\n    app_module: solace_agent_mesh.workflow.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "RequestRouterWorkflow"\n\n      workflow:\n        description: "Routes support requests to appropriate handlers"\n\n        input_schema:\n          type: object\n          properties:\n            request:\n              type: string\n              description: "The support request text"\n          required: [request]\n\n        nodes:\n          - id: classify\n            type: agent\n            agent_name: "RequestClassifier"\n            input:\n              request: "{{workflow.input.request}}"\n\n          - id: route_request\n            type: switch\n            depends_on: [classify]\n            cases:\n              - condition: "{{classify.output.type}} == \'billing\'"\n                node: handle_billing\n              - condition: "{{classify.output.type}} == \'technical\'"\n                node: handle_technical\n            default: handle_general\n\n          - id: handle_billing\n            type: agent\n            agent_name: "BillingHandler"\n            depends_on: [route_request]\n            input:\n              request: "{{workflow.input.request}}"\n\n          - id: handle_technical\n            type: agent\n            agent_name: "TechnicalHandler"\n            depends_on: [route_request]\n            input:\n              request: "{{workflow.input.request}}"\n\n          - id: handle_general\n            type: agent\n            agent_name: "GeneralHandler"\n            depends_on: [route_request]\n            input:\n              request: "{{workflow.input.request}}"\n\n        output_mapping:\n          response:\n            coalesce:\n              - "{{handle_billing.output.response}}"\n              - "{{handle_technical.output.response}}"\n              - "{{handle_general.output.response}}"\n          handled_by:\n            coalesce:\n              - "{{handle_billing.output.handler}}"\n              - "{{handle_technical.output.handler}}"\n              - "{{handle_general.output.handler}}"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Cases are evaluated top to bottom. The first matching condition wins. Nodes in non-selected branches are skipped entirely."}),"\n",(0,i.jsxs)(n.p,{children:["Notice that branch nodes must list the switch node in their ",(0,i.jsx)(n.code,{children:"depends_on"}),". This ensures they only run when selected."]}),"\n",(0,i.jsx)(n.h2,{id:"processing-collections",children:"Processing Collections"}),"\n",(0,i.jsxs)(n.p,{children:["Map nodes iterate over arrays. Each item is processed by the target node. Save this as ",(0,i.jsx)(n.code,{children:"batch_processor_workflow.yaml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'log:\n  stdout_log_level: INFO\n  log_file_level: DEBUG\n  log_file: batch_processor_workflow.log\n\n!include ../shared_config.yaml\n\napps:\n  # ============================================================================\n  # AGENT: Item Processor\n  # Processes individual items from a batch\n  # ============================================================================\n  - name: item_processor_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "ItemProcessor"\n      model: *planning_model\n\n      instruction: |\n        Process a single item from a batch.\n        1. Read \'item_id\', \'quantity\', and \'price\' from input\n        2. Calculate line_total = quantity * price\n\n      input_schema:\n        type: object\n        properties:\n          item_id: {type: string}\n          quantity: {type: integer}\n          price: {type: number}\n        required: [item_id, quantity, price]\n\n      output_schema:\n        type: object\n        properties:\n          item_id: {type: string}\n          line_total: {type: number}\n          processed: {type: boolean}\n        required: [item_id, line_total, processed]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Processes individual items"\n        skills: [{id: "process", name: "Process Item", description: "Processes items", tags: ["processing"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # WORKFLOW: Batch Processor\n  # ============================================================================\n  - name: batch_processor_workflow\n    app_base_path: .\n    app_module: solace_agent_mesh.workflow.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "BatchProcessorWorkflow"\n\n      workflow:\n        description: "Processes a batch of items in parallel"\n\n        input_schema:\n          type: object\n          properties:\n            items:\n              type: array\n              items:\n                type: object\n                properties:\n                  item_id: {type: string}\n                  quantity: {type: integer}\n                  price: {type: number}\n                required: [item_id, quantity, price]\n          required: [items]\n\n        nodes:\n          - id: process_all_items\n            type: map\n            items: "{{workflow.input.items}}"\n            node: process_single_item\n            concurrency_limit: 3\n            max_items: 50\n\n          - id: process_single_item\n            type: agent\n            agent_name: "ItemProcessor"\n            input:\n              item_id: "{{_map_item.item_id}}"\n              quantity: "{{_map_item.quantity}}"\n              price: "{{_map_item.price}}"\n\n        output_mapping:\n          processed_items: "{{process_all_items.output.results}}"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Inside the target node, ",(0,i.jsx)(n.code,{children:"{{_map_item}}"})," is the current item. After all iterations complete, the map node's output contains ",(0,i.jsx)(n.code,{children:"results"}),"\u2014an array of each iteration's output in order."]}),"\n",(0,i.jsxs)(n.p,{children:["Set ",(0,i.jsx)(n.code,{children:"concurrency_limit"})," to control parallelism. Without it, all items process simultaneously."]}),"\n",(0,i.jsx)(n.h2,{id:"polling-with-loops",children:"Polling with Loops"}),"\n",(0,i.jsxs)(n.p,{children:["Loop nodes repeat until a condition becomes false. Use them for polling or retry patterns. Save this as ",(0,i.jsx)(n.code,{children:"polling_workflow.yaml"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'log:\n  stdout_log_level: INFO\n  log_file_level: DEBUG\n  log_file: polling_workflow.log\n\n!include ../shared_config.yaml\n\napps:\n  # ============================================================================\n  # AGENT: Status Checker\n  # Checks if a task is ready (simulates polling an external service)\n  # ============================================================================\n  - name: status_checker_app\n    app_base_path: .\n    app_module: solace_agent_mesh.agent.sac.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "StatusChecker"\n      model: *planning_model\n\n      instruction: |\n        Check if a task is ready.\n        1. Read \'task_id\' and \'iteration\' from input\n        2. Simulate checking: if iteration >= 3, set ready = true\n\n      input_schema:\n        type: object\n        properties:\n          task_id: {type: string}\n          iteration: {type: integer}\n        required: [task_id, iteration]\n\n      output_schema:\n        type: object\n        properties:\n          task_id: {type: string}\n          iteration: {type: integer}\n          ready: {type: boolean}\n          message: {type: string}\n        required: [task_id, ready]\n\n      tools:\n        - tool_type: builtin-group\n          group_name: "artifact_management"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card:\n        description: "Checks task status"\n        skills: [{id: "check", name: "Check Status", description: "Checks status", tags: ["status"]}]\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n\n  # ============================================================================\n  # WORKFLOW: Polling Workflow\n  # ============================================================================\n  - name: polling_workflow\n    app_base_path: .\n    app_module: solace_agent_mesh.workflow.app\n    broker:\n      <<: *broker_connection\n\n    app_config:\n      namespace: ${NAMESPACE}\n      agent_name: "PollingWorkflow"\n\n      workflow:\n        description: "Polls until a task is ready"\n\n        input_schema:\n          type: object\n          properties:\n            task_id:\n              type: string\n              description: "Task to poll for"\n          required: [task_id]\n\n        nodes:\n          - id: poll_until_ready\n            type: loop\n            node: check_status\n            condition: "{{check_status.output.ready}} == false"\n            max_iterations: 10\n            delay: "5s"\n\n          - id: check_status\n            type: agent\n            agent_name: "StatusChecker"\n            input:\n              task_id: "{{workflow.input.task_id}}"\n              iteration: "{{_loop_iteration}}"\n\n        output_mapping:\n          task_id: "{{workflow.input.task_id}}"\n          final_status: "{{check_status.output.ready}}"\n          iterations: "{{poll_until_ready.output.iterations_completed}}"\n\n      session_service:\n        <<: *default_session_service\n      artifact_service:\n        <<: *default_artifact_service\n\n      agent_card_publishing: {interval_seconds: 10}\n      agent_discovery: {enabled: false}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The loop runs ",(0,i.jsx)(n.code,{children:"check_status"})," repeatedly. The first iteration always executes; the condition is checked before each subsequent iteration. Once the condition is false (task ready), execution continues."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"delay"})," adds a wait between iterations\u2014essential for polling to avoid overwhelming the target service."]}),"\n",(0,i.jsx)(n.h2,{id:"composing-workflows",children:"Composing Workflows"}),"\n",(0,i.jsx)(n.p,{children:"Workflow nodes call other workflows as sub-workflows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'- id: run_validation_workflow\n  type: workflow\n  workflow_name: "ValidationWorkflow"\n  input:\n    data: "{{workflow.input.payload}}"\n  timeout: "15m"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The fields match agent nodes, except ",(0,i.jsx)(n.code,{children:"workflow_name"})," replaces ",(0,i.jsx)(n.code,{children:"agent_name"}),". Workflows cannot call themselves directly."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"max_call_depth"})," setting (default: 10) limits how deeply workflows can nest to prevent infinite recursion."]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.h3,{id:"retries",children:"Retries"}),"\n",(0,i.jsx)(n.p,{children:"Configure retries at the workflow level or per-node:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'workflow:\n  # Default for all nodes\n  retry_strategy:\n    limit: 3\n    retry_policy: "OnFailure"\n    backoff:\n      duration: "1s"\n      factor: 2\n      max_duration: "30s"\n\n  nodes:\n    - id: critical_step\n      type: agent\n      agent_name: "CriticalService"\n      # Override for this node\n      retry_strategy:\n        limit: 5\n        backoff:\n          duration: "5s"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"exit-handlers",children:"Exit Handlers"}),"\n",(0,i.jsx)(n.p,{children:"Run cleanup regardless of success or failure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'workflow:\n  on_exit:\n    always: log_completion\n    on_failure: send_alert\n    on_success: send_confirmation\n\n  nodes:\n    # ... workflow nodes ...\n\n    - id: log_completion\n      type: agent\n      agent_name: "AuditLogger"\n      input:\n        workflow_input: "{{workflow.input}}"\n\n    - id: send_alert\n      type: agent\n      agent_name: "AlertSender"\n      input:\n        error: "{{workflow.error}}"\n\n    - id: send_confirmation\n      type: agent\n      agent_name: "NotificationSender"\n      input:\n        result: "{{workflow.output}}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Exit handlers are regular nodes in your workflow\u2014they just get triggered automatically on workflow completion."}),"\n",(0,i.jsx)(n.h2,{id:"timeouts",children:"Timeouts"}),"\n",(0,i.jsx)(n.p,{children:"Set timeouts to prevent workflows or nodes from running indefinitely:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:'app_config:\n  # Workflow-level settings\n  max_workflow_execution_time_seconds: 3600  # 1 hour total\n  default_node_timeout_seconds: 300          # 5 minutes per node\n\n  workflow:\n    nodes:\n      - id: long_running_task\n        type: agent\n        agent_name: "SlowProcessor"\n        timeout: "30m"  # Override for this node\n'})}),"\n",(0,i.jsx)(n.h2,{id:"testing-workflows",children:"Testing Workflows"}),"\n",(0,i.jsx)(n.p,{children:"Test workflows incrementally:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Start simple."})," Get a two-node workflow running before adding complexity."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Check data flow."})," Use agents that echo their input to verify template expressions resolve correctly."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Test branches independently."})," For switch nodes, create test inputs that exercise each branch."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Limit iterations during development."})," Set low ",(0,i.jsx)(n.code,{children:"max_items"})," and ",(0,i.jsx)(n.code,{children:"max_iterations"})," values while testing map and loop nodes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Watch the UI."})," The workflow visualization shows execution progress and helps identify where things go wrong."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"example-workflows",children:"Example Workflows"}),"\n",(0,i.jsx)(n.p,{children:"The repository includes complete example workflows:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/SolaceLabs/solace-agent-mesh/blob/main/examples/agents/all_node_types_workflow.yaml",children:(0,i.jsx)(n.code,{children:"examples/agents/all_node_types_workflow.yaml"})})," - Comprehensive example demonstrating all node types in an order processing pipeline"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/SolaceLabs/solace-agent-mesh/blob/main/examples/agents/jira_bug_triage_workflow.yaml",children:(0,i.jsx)(n.code,{children:"examples/agents/jira_bug_triage_workflow.yaml"})})," - Real-world example of a bug triage workflow with conditional branching"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"reference",children:"Reference"}),"\n",(0,i.jsxs)(n.p,{children:["For complete field documentation and the JSON Schema, see ",(0,i.jsx)(n.a,{href:"/solace-agent-mesh/docs/documentation/components/workflows",children:"Workflows"}),"."]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var s=t(6540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);