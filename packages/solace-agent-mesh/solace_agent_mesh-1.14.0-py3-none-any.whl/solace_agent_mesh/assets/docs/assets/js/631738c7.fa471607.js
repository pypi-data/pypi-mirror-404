"use strict";(self.webpackChunksolace_agenitc_mesh_docs=self.webpackChunksolace_agenitc_mesh_docs||[]).push([[1445],{3190:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"documentation/deploying/debugging","title":"Diagnosing and Resolving Problems","description":"Effective debugging in Agent Mesh requires a systematic approach that leverages the platform\'s distributed architecture. Because your system consists of multiple agents communicating through a Solace event broker, issues can arise at various levels\u2014from individual agent logic to inter-component communication patterns.","source":"@site/docs/documentation/deploying/debugging.md","sourceDirName":"documentation/deploying","slug":"/documentation/deploying/debugging","permalink":"/solace-agent-mesh/docs/documentation/deploying/debugging","draft":false,"unlisted":false,"editUrl":"https://github.com/SolaceLabs/solace-agent-mesh/edit/main/docs/docs/documentation/deploying/debugging.md","tags":[],"version":"current","sidebarPosition":30,"frontMatter":{"title":"Diagnosing and Resolving Problems","sidebar_position":30},"sidebar":"docSidebar","previous":{"title":"Monitoring Your Agent Mesh","permalink":"/solace-agent-mesh/docs/documentation/deploying/observability"},"next":{"title":"Logging","permalink":"/solace-agent-mesh/docs/documentation/deploying/logging"}}');var s=i(4848),o=i(8453);const a={title:"Diagnosing and Resolving Problems",sidebar_position:30},r="Diagnosing and Resolving Problems",l={},c=[{value:"Isolating Components",id:"isolating-components",level:2},{value:"Examining STIM Files",id:"examining-stim-files",level:2},{value:"Monitoring Event Broker Activity",id:"monitoring-event-broker-activity",level:2},{value:"Using Debug Mode",id:"using-debug-mode",level:2},{value:"Setting Up VSCode Debugging",id:"setting-up-vscode-debugging",level:3},{value:"Invoking Agents Directly",id:"invoking-agents-directly",level:2},{value:"Using Tools for Direct Message Testing",id:"using-tools-for-direct-message-testing",level:3},{value:"Formatting Messages for Direct Invocation",id:"formatting-messages-for-direct-invocation",level:3},{value:"Analyzing System Logs",id:"analyzing-system-logs",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"diagnosing-and-resolving-problems",children:"Diagnosing and Resolving Problems"})}),"\n",(0,s.jsx)(n.p,{children:"Effective debugging in Agent Mesh requires a systematic approach that leverages the platform's distributed architecture. Because your system consists of multiple agents communicating through a Solace event broker, issues can arise at various levels\u2014from individual agent logic to inter-component communication patterns."}),"\n",(0,s.jsxs)(n.p,{children:["The key to successful debugging lies in understanding where problems might occur and having the right tools to investigate each layer of your system. Agent Mesh provides comprehensive observability features that serve as your foundation for debugging activities. For detailed information about these monitoring capabilities, see ",(0,s.jsx)(n.a,{href:"/solace-agent-mesh/docs/documentation/deploying/observability",children:"Observability"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This guide presents proven debugging strategies arranged from simple isolation techniques to advanced diagnostic methods. Each approach targets different types of issues, allowing you to choose the most effective method based on your specific situation."}),"\n",(0,s.jsx)(n.h2,{id:"isolating-components",children:"Isolating Components"}),"\n",(0,s.jsx)(n.p,{children:"When facing complex issues in a multi-agent system, isolation becomes your most powerful debugging technique. By running only the components directly related to your problem, you eliminate variables and focus your investigation on the most likely sources of trouble."}),"\n",(0,s.jsx)(n.p,{children:"Component isolation works because it reduces system complexity to manageable levels. Instead of trying to understand interactions across dozens of agents, you can focus on a small subset and verify their behavior in controlled conditions."}),"\n",(0,s.jsx)(n.p,{children:"The Agent Mesh CLI provides precise control over which components run in your debugging session. You can specify exactly which configuration files to load, creating a minimal environment that includes only the agents you need to investigate."}),"\n",(0,s.jsx)(n.p,{children:"For example, if you're debugging an issue with a specific tool integration, you might run only the orchestrator and the problematic tool agent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sam run configs/agents/my_tool_1.yaml configs/agents/my_tool_2.yaml\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This command creates a focused debugging environment that includes only the agents defined in ",(0,s.jsx)(n.code,{children:"my_tool_1.yaml"})," and ",(0,s.jsx)(n.code,{children:"my_tool_2.yaml"}),". By eliminating unrelated components, you reduce log noise and make it easier to trace the specific interactions that might be causing problems."]}),"\n",(0,s.jsx)(n.p,{children:"This isolation approach is particularly effective when you suspect issues with agent-to-agent communication, configuration problems, or logic errors within specific agents."}),"\n",(0,s.jsx)(n.h2,{id:"examining-stim-files",children:"Examining STIM Files"}),"\n",(0,s.jsx)(n.p,{children:"STIM files serve as your detailed forensic evidence when debugging complex issues. These comprehensive traces capture every aspect of how requests flow through your system, making them invaluable for understanding problems that span multiple agents or involve timing-sensitive interactions."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"/solace-agent-mesh/docs/documentation/deploying/observability#examining-stimulus-logs",children:"STIM files"})," provide the most complete picture available of stimulus lifecycles. Unlike real-time monitoring tools that show current activity, STIM files preserve historical data that you can analyze repeatedly and share with team members for collaborative debugging."]}),"\n",(0,s.jsxs)(n.p,{children:["Each ",(0,s.jsx)(n.code,{children:".stim"})," file contains a complete record of all Solace event broker events related to a single stimulus, from the initial user request through every agent interaction to the final response delivery. This comprehensive coverage makes STIM files particularly useful for debugging issues that involve:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multi-agent workflows where the problem might occur at any step"}),"\n",(0,s.jsx)(n.li,{children:"Timing-related issues where sequence and duration matter"}),"\n",(0,s.jsx)(n.li,{children:"Intermittent problems that are difficult to reproduce in real-time"}),"\n",(0,s.jsx)(n.li,{children:"Performance bottlenecks that require detailed timing analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When examining STIM files, look for patterns in agent response times, unexpected message routing, or missing interactions that should have occurred based on your system design."}),"\n",(0,s.jsx)(n.h2,{id:"monitoring-event-broker-activity",children:"Monitoring Event Broker Activity"}),"\n",(0,s.jsx)(n.p,{children:"Real-time Solace event broker monitoring provides immediate insights into your system's communication patterns and helps identify issues as they occur. This approach complements STIM file analysis by giving you live visibility into message flows and event interactions."}),"\n",(0,s.jsx)(n.p,{children:"Broker-level monitoring is particularly valuable because it shows the actual communication happening between components, regardless of how agents are configured or what they report about their own status. This ground-truth perspective helps identify discrepancies between expected and actual behavior."}),"\n",(0,s.jsxs)(n.p,{children:["For comprehensive guidance on Solace event broker monitoring techniques and tools, see ",(0,s.jsx)(n.a,{href:"/solace-agent-mesh/docs/documentation/deploying/observability#monitoring-event-broker-activity",children:"Monitoring Event Broker Activity"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"using-debug-mode",children:"Using Debug Mode"}),"\n",(0,s.jsx)(n.p,{children:"Interactive debugging provides the deepest level of investigation capability by allowing you to pause execution and examine system state in real-time. Because Agent Mesh is built on Python, you can leverage standard Python debugging tools and IDE features to step through code execution and inspect variables."}),"\n",(0,s.jsx)(n.p,{children:"This approach is most effective when you've already isolated the problem to specific components and need to understand exactly what's happening within agent logic or framework code."}),"\n",(0,s.jsx)(n.h3,{id:"setting-up-vscode-debugging",children:"Setting Up VSCode Debugging"}),"\n",(0,s.jsx)(n.p,{children:"VSCode provides an excellent debugging environment for Agent Mesh development. The integrated debugger allows you to set breakpoints, step through code execution, and inspect variables in real-time, making it easier to understand complex agent interactions and identify logic errors."}),"\n",(0,s.jsxs)(n.p,{children:["Configure debugging by creating or updating your ",(0,s.jsx)(n.code,{children:".vscode/launch.json"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "version": "0.2.0",\n  "configurations": [\n    {\n      "name": "sam-debug",\n      "type": "debugpy",\n      "request": "launch",\n      "module": "solace_agent_mesh.cli.main",\n      "console": "integratedTerminal",\n      "envFile": "${workspaceFolder}/.env",\n      "args": [\n        "run",\n        "configs/agents/main_orchestrator.yaml",\n        "configs/gateways/webui.yaml"\n        // Add any other components you want to run here\n      ],\n      "justMyCode": false\n    }\n  ]\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:'"justMyCode": false'})," setting is particularly important because it allows you to step into Agent Mesh framework code, not just your custom agent logic. This capability is valuable when debugging issues that might involve framework behavior or when you need to understand how your agents interact with the underlying platform."]}),"\n",(0,s.jsx)(n.p,{children:"To start a debugging session:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Open the ",(0,s.jsx)(n.strong,{children:"RUN AND DEBUG"})," panel in the left sidebar"]}),"\n",(0,s.jsxs)(n.li,{children:["Select ",(0,s.jsx)(n.code,{children:"sam-debug"})," from the configuration dropdown"]}),"\n",(0,s.jsxs)(n.li,{children:["Click the ",(0,s.jsx)(n.strong,{children:"Play"})," button to launch your system in debug mode"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Once running, you can set breakpoints in your agent code, framework files, or any Python modules your system uses. When execution hits a breakpoint, you can inspect variable states, evaluate expressions, and step through code line by line to understand exactly what's happening."}),"\n",(0,s.jsx)(n.h2,{id:"invoking-agents-directly",children:"Invoking Agents Directly"}),"\n",(0,s.jsx)(n.p,{children:"Direct agent invocation provides a powerful technique for isolating and testing individual agents outside of normal user workflows. This approach helps you verify that specific agents work correctly in isolation, making it easier to determine whether problems lie within agent logic or in the broader system interactions."}),"\n",(0,s.jsx)(n.p,{children:"You can invoke agents directly through two primary methods: using the web UI's agent selection dropdown for quick testing, or sending messages directly through the Solace event broker for more controlled testing scenarios."}),"\n",(0,s.jsx)(n.p,{children:"The Solace event broker-based approach gives you complete control over message content and timing, making it ideal for testing edge cases, error conditions, or specific message formats that might be difficult to generate through normal user interactions."}),"\n",(0,s.jsx)(n.h3,{id:"using-tools-for-direct-message-testing",children:"Using Tools for Direct Message Testing"}),"\n",(0,s.jsx)(n.p,{children:"Several tools facilitate direct message testing, each suited to different debugging scenarios:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://marketplace.visualstudio.com/items?itemName=solace-tools.solace-try-me-vsc-extension",children:"Solace Try Me VSCode Extension"})}),": Integrates directly into your development environment, making it convenient to test messages without switching contexts. This tool is particularly useful during active development when you need to quickly verify agent behavior."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"https://github.com/SolaceLabs/solace-tryme-cli",children:"Solace Try Me (STM) CLI Tool"})}),": Provides command-line access for scripted testing and automation. This tool excels in scenarios where you need to send multiple test messages or integrate testing into automated workflows."]}),"\n",(0,s.jsx)(n.h3,{id:"formatting-messages-for-direct-invocation",children:"Formatting Messages for Direct Invocation"}),"\n",(0,s.jsx)(n.p,{children:"Understanding the exact message format is crucial for successful direct agent testing. The following structure represents how the Agent Mesh framework expects messages to be formatted:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Topic Structure"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[NAME_SPACES]a2a/v1/agent/request/<agent_name>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Replace ",(0,s.jsx)(n.code,{children:"<agent_name>"})," with the specific agent you want to test. The namespace prefix should match your system configuration."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Required User Properties"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"userId: test-0000\nclientId: test-0000\nreplyTo: [NAME_SPACES]a2a/v1/gateway/response/0000000/task-0000000\na2aUserConfig: {}\n"})}),"\n",(0,s.jsx)(n.p,{children:"These properties provide essential context that agents expect, including user identification and response routing information."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Message Payload"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "jsonrpc": "2.0",\n    "id": "000000000",\n    "method": "tasks/sendSubscribe",\n    "params": {\n      "id": "task-0000000",\n      "sessionId": "web-session-00000000",\n      "message": {\n        "role": "user",\n        "parts": [\n          {\n            "type": "text",\n            "text": "Hello World!"\n          }\n        ]\n      },\n      "acceptedOutputModes": [\n        "text"\n      ],\n      "metadata": {\n        "system_purpose": "The system is an AI Chatbot with agentic capabilities. It uses the agents available to provide information, reasoning and general assistance for the users in this system. **Always return useful artifacts and files that you create to the user.** Provide a status update before each tool call. Your external name is Agent Mesh.\\n",\n        "response_format": "Responses should be clear, concise, and professionally toned. Format responses to the user in Markdown using appropriate formatting.\\n"\n      }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expected Response Topic"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[NAME_SPACES]a2a/v1/gateway/response/0000000/task-0000000\n"})}),"\n",(0,s.jsx)(n.p,{children:"Subscribe to this topic to receive the agent's response. The response will follow the same JSON-RPC format and contain the agent's output."}),"\n",(0,s.jsx)(n.p,{children:"By sending carefully crafted requests and observing responses, you can verify agent behavior in complete isolation. This technique helps distinguish between agent-specific issues and broader system problems, significantly streamlining your debugging process."}),"\n",(0,s.jsx)(n.h2,{id:"analyzing-system-logs",children:"Analyzing System Logs"}),"\n",(0,s.jsx)(n.p,{children:"System logs serve as your comprehensive record of application behavior, capturing everything from routine operations to error conditions. These logs provide a different perspective than STIM files or Solace event broker monitoring\u2014they focus on internal application state and framework behavior rather than message flows."}),"\n",(0,s.jsx)(n.p,{children:"Understanding system logs becomes crucial when debugging issues related to agent initialization, configuration problems, or internal framework errors that might not be visible through other observability tools."}),"\n",(0,s.jsxs)(n.p,{children:["For detailed information about configuring system logs, see ",(0,s.jsx)(n.a,{href:"/solace-agent-mesh/docs/documentation/deploying/logging",children:"Logging Configuration"}),"."]})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);