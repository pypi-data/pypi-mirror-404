# DEVELOPER GUIDE: services

## Quick Summary
The `services` directory contains the business logic layer for the HTTP SSE Gateway. It provides high-level services for agent management (discovering and retrieving A2A agents), user feedback processing with database persistence and event publishing, user search via identity services, session management with database persistence, task logging to database, data retention/cleanup, and A2A task operations like cancellation.

## Files Overview
- `__init__.py` - Package initialization file marking the directory as a Python package
- `agent_card_service.py` - Service for retrieving information about discovered A2A agents from the registry
- `data_retention_service.py` - Service for automatic cleanup of old tasks and feedback based on retention policies
- `feedback_service.py` - Service for processing and storing user feedback on chat messages with database and event publishing
- `people_service.py` - Service for searching users via configured identity services
- `session_service.py` - Service for managing chat sessions and messages with database persistence
- `task_logger_service.py` - Service for logging A2A tasks and events to the database
- `task_service.py` - Service for handling A2A task operations like cancellation

## Developer API Reference

### __init__.py
**Purpose:** Marks the services directory as a Python package
**Import:** N/A - No public interfaces

### agent_card_service.py
**Purpose:** Provides methods for accessing information about discovered A2A agents from the shared AgentRegistry
**Import:** `from solace_agent_mesh.gateway.http_sse.services.agent_card_service import AgentCardService`

**Classes:**
- `AgentCardService(agent_registry: AgentRegistry)` - Service for accessing discovered A2A agent information
  - `get_all_agent_cards() -> List[AgentCard]` - Retrieves all currently discovered and registered agent cards
  - `get_agent_card_by_name(agent_name: str) -> Optional[AgentCard]` - Retrieves a specific agent card by name, returns None if not found

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.services.agent_card_service import AgentCardService
from solace_agent_mesh.common.agent_registry import AgentRegistry

# Initialize with shared agent registry
agent_registry = AgentRegistry()  # Usually injected as shared instance
agent_service = AgentCardService(agent_registry=agent_registry)

# Get all available agents
all_agents = agent_service.get_all_agent_cards()
print(f"Found {len(all_agents)} agents")

# Get specific agent by name
agent = agent_service.get_agent_card_by_name("data-processor")
if agent:
    print(f"Found agent: {agent.name}")
else:
    print("Agent not found")
```

### data_retention_service.py
**Purpose:** Service for automatically cleaning up old tasks, task events, and feedback based on configurable retention policies
**Import:** `from solace_agent_mesh.gateway.http_sse.services.data_retention_service import DataRetentionService`

**Classes:**
- `DataRetentionService(session_factory: Callable[[], DBSession] | None, config: Dict[str, Any])` - Service for automatic data cleanup based on retention policies
  - `cleanup_old_data() -> None` - Main orchestration method for cleaning up old data, calls cleanup methods for tasks and feedback

**Constants/Variables:**
- `MIN_RETENTION_DAYS: int` - Minimum retention period (1 day)
- `MIN_CLEANUP_INTERVAL_HOURS: int` - Minimum cleanup interval (1 hour)
- `MIN_BATCH_SIZE: int` - Minimum batch size for deletion (1)
- `MAX_BATCH_SIZE: int` - Maximum batch size for deletion (10000)

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.services.data_retention_service import DataRetentionService
from sqlalchemy.orm import sessionmaker

# Initialize with database session factory and config
session_factory = sessionmaker(bind=your_engine)
config = {
    "enabled": True,
    "task_retention_days": 90,
    "feedback_retention_days": 90,
    "cleanup_interval_hours": 24,
    "batch_size": 1000
}

retention_service = DataRetentionService(
    session_factory=session_factory,
    config=config
)

# Run cleanup (typically called by scheduler)
retention_service.cleanup_old_data()
```

### feedback_service.py
**Purpose:** Handles the business logic for processing and storing user feedback with database persistence and event publishing
**Import:** `from solace_agent_mesh.gateway.http_sse.services.feedback_service import FeedbackService`

**Classes:**
- `FeedbackService(session_factory: Callable[[], DBSession] | None, component: WebUIBackendComponent, task_repo: ITaskRepository)` - Service for processing user feedback with database persistence and event publishing
  - `process_feedback(payload: FeedbackPayload, user_id: str) -> None` - Asynchronously processes and stores feedback, publishes events if configured

**Usage Examples:**
```python
import asyncio
from solace_agent_mesh.gateway.http_sse.services.feedback_service import FeedbackService
from sqlalchemy.orm import sessionmaker

# Initialize with database session factory
session_factory = sessionmaker(bind=your_engine)
component = YourWebUIBackendComponent()  # Your component instance
task_repo = YourTaskRepository()  # Your task repository

feedback_service = FeedbackService(
    session_factory=session_factory,
    component=component,
    task_repo=task_repo
)

# Process feedback (requires FeedbackPayload from router)
async def process_user_feedback():
    # payload would be a FeedbackPayload instance from the router
    await feedback_service.process_feedback(payload, user_id="user123")

asyncio.run(process_user_feedback())
```

### people_service.py
**Purpose:** Provides user search functionality via configured identity services
**Import:** `from solace_agent_mesh.gateway.http_sse.services.people_service import PeopleService`

**Classes:**
- `PeopleService(identity_service: Optional[BaseIdentityService])` - Service for searching and retrieving user information
  - `search_for_users(query: str, limit: int = 10) -> List[Dict[str, Any]]` - Asynchronously searches for users, returns empty list if no identity service configured or query too short

**Usage Examples:**
```python
import asyncio
from solace_agent_mesh.gateway.http_sse.services.people_service import PeopleService
from solace_agent_mesh.common.services.identity_service import BaseIdentityService

# Initialize with identity service
identity_service = SomeIdentityService()  # Your identity service implementation
people_service = PeopleService(identity_service=identity_service)

async def search_users():
    # Search for users
    users = await people_service.search_for_users("john", limit=5)
    for user in users:
        print(f"User: {user.get('name')} - {user.get('email')}")

# Initialize without identity service (graceful degradation)
people_service_no_id = PeopleService(identity_service=None)
# search_for_users will return empty list

asyncio.run(search_users())
```

### session_service.py
**Purpose:** Manages chat sessions and messages with database persistence support
**Import:** `from solace_agent_mesh.gateway.http_sse.services.session_service import SessionService`

**Classes:**
- `SessionService(component: WebUIBackendComponent = None)` - Service for managing chat sessions and messages
  - `is_persistence_enabled() -> bool` - Checks if the service is configured with a persistent backend
  - `get_user_sessions(db: DbSession, user_id: UserId, pagination: PaginationParams | None = None) -> PaginatedResponse[Session]` - Retrieves paginated sessions for a user
  - `get_session_details(db: DbSession, session_id: SessionId, user_id: UserId) -> Session | None` - Gets session details for a specific session
  - `create_session(db: DbSession, user_id: UserId, name: str | None = None, agent_id: str | None = None, session_id: str | None = None) -> Optional[Session]` - Creates a new session
  - `update_session_name(db: DbSession, session_id: SessionId, user_id: UserId, name: str) -> Session | None` - Updates session name
  - `delete_session_with_notifications(db: DbSession, session_id: SessionId, user_id: UserId) -> bool` - Deletes session and notifies agents
  - `save_task(db: DbSession, task_id: str, session_id: str, user_id: str, user_message: Optional[str], message_bubbles: str, task_metadata: Optional[str] = None) -> ChatTask` - Saves a complete task interaction
  - `get_session_tasks(db: DbSession, session_id: str, user_id: str) -> List[ChatTask]` - Gets all tasks for a session
  - `get_session_messages_from_tasks(db: DbSession, session_id: str, user_id: str) -> List[Dict[str, Any]]` - Gets session messages by flattening task message_bubbles for backward compatibility

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.services.session_service import SessionService
from sqlalchemy.orm import Session as DbSession

# Initialize with component
component = YourWebUIBackendComponent()  # Your component
session_service = SessionService(component=component)

# Use with database session
with your_session_factory() as db:
    # Create a new session
    session = session_service.create_session(
        db=db,
        user_id="user123",
        name="My Chat Session",
        agent_id="assistant-agent"
    )

    # Save a task with message bubbles
    import json
    message_bubbles = json.dumps([
        {"type": "user", "text": "Hello", "id": "msg1"},
        {"type": "agent", "text": "Hi there!", "id": "msg2"}
    ])
    
    task = session_service.save_task(
        db=db,
        task_id="task-123",
        session_id=session.id,
        user_id="user123",
        user_message="Hello",
        message_bubbles=message_bubbles
    )

    # Get user's sessions with pagination
    paginated_sessions = session_service.get_user_sessions(db, "user123")
    
    db.commit()
```

### task_logger_service.py
**Purpose:** Service for logging A2A tasks and events to the database with configurable filtering and sanitization
**Import:** `from solace_agent_mesh.gateway.http_sse.services.task_logger_service import TaskLoggerService`

**Classes:**
- `TaskLoggerService(session_factory: Callable[[], DBSession] | None, config: Dict[str, Any])` - Service for logging A2A tasks and events to database
  - `log_event(event_data: Dict[str, Any]) -> None` - Parses a raw A2A message and logs it as a task event, creates or updates master task record

**Usage Examples:**
```python
from solace_agent_mesh.gateway.http_sse.services.task_logger_service import TaskLoggerService
from sqlalchemy.orm import sessionmaker

# Initialize with database session factory and config
session_factory = sessionmaker(bind=your_engine)
config = {
    "enabled": True,
    "log_status_updates": True,
    "log_artifact_events": False,
    "log_file_parts": True,
    "max_file_part_size_bytes": 102400
}

task_logger = TaskLoggerService(
    session_factory=session_factory,
    config=config
)

# Log an A2A event
event_data = {
    "topic": "sam/agents/my-agent/request",
    "payload": {"id": "task-123", "method": "sendMessage"},
    "user_properties": {"userId": "user@example.com"}
}

task_logger.log_event(event_data)
```

### task_service.py
**Purpose:** Handles A2A task operations, specifically task cancellation using CoreA2AService and message publishing
**Import:** `from solace_agent_mesh.gateway.http_sse.services.task_service import TaskService, PublishFunc`

**Type Aliases:**
- `PublishFunc: Callable[[str, Dict, Optional[Dict]], None]` - Function type for publishing messages (topic, payload, user_properties)

**Classes:**
- `TaskService(core_a2a_service: CoreA2AService, publish_func: PublishFunc, namespace: str, gateway_id: str, sse_manager: SSEManager, task_context_map: Dict[str, Dict], task_context_lock: threading.Lock, app_name: str)` - Service for managing A2A task operations
  - `cancel_task(agent_name: str, task_id: str, client_id: str, user_id: str = "web_user") -> None` - Asynchronously cancels a task by publishing A2A CancelTaskRequest message

**Usage Examples:**
```python
import asyncio
import threading
from solace_agent_mesh.gateway.http_sse.services.task_service import TaskService, PublishFunc
from solace_agent_mesh.core_a2a.service import CoreA2AService
from solace_agent_mesh.gateway.http_sse.sse_manager import SSEManager

# Define publish function
def my_publish_func(topic: str, payload: dict, user_properties: dict = None):
    print(f"Publishing to {topic}: {payload}")
    # Your actual message publishing logic here

# Initialize dependencies
core_a2a_service = CoreA2AService()  # Your core A2A service
sse_manager = SSEManager()
task_context_map = {}
task_context_lock = threading.Lock()

# Create task service
task_service = TaskService(
    core_a2a_service=core_a2a_service,
    publish_func=my_publish_func,
    namespace="my-namespace",
    gateway_id="gateway-01",
    sse_manager=sse_manager,
    task_context_map=task_context_map,
    task_context_lock=task_context_lock,
    app_name="my-app"
)

async def cancel_task_example():
    # Cancel a task
    await task_service.cancel_task(
        agent_name="data-processor",
        task_id="task-123",
        client_id="client-456",
        user_id="user@example.com"
    )

asyncio.run(cancel_task_example())
```

# content_hash: 09bc3008d9a6c148b0b9d7477d20b26514f7fc4ee72f36eda5348f8f7d51f2ea
