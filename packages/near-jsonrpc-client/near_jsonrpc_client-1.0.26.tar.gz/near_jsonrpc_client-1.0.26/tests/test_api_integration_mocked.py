# Auto-generated integration tests (mocked) - generated by ClientTestGenerator
# Uses: pytest, respx, httpx

import pytest
import json
from pathlib import Path
import respx
from httpx import Response
import near_jsonrpc_models
from near_jsonrpc_client import NearClientSync

FIXTURES_DIR = Path(__file__).parent / "fixtures" / "json"

def load_mock_json(name: str):
    p = Path(FIXTURES_DIR) / name
    if not p.exists():
        return None
    with p.open("r", encoding="utf-8") as fh:
        return json.load(fh)

def _normalize(obj):
    """Recursively convert pydantic near_jsonrpc_models (and lists/dicts containing them)
    to JSON-serializable Python primitives comparable with fixture JSON.

    Rules:
    - If object has model_dump, call model_dump(mode='json', exclude_none=True)
    - If list, normalize each element
    - If dict, normalize values
    - Otherwise, return as-is
    """
    # pydantic model
    try:
        # check duck-typing attribute (works for pydantic v1 & v2)
        if hasattr(obj, "model_dump") or hasattr(obj, "dict"):
            if hasattr(obj, "model_dump"):
                try:
                    dumped = obj.model_dump(mode="json", exclude_none=True)
                except TypeError:
                    # fallback for different pydantic signatures
                    dumped = obj.model_dump()
            else:
                # pydantic v1 fallback
                dumped = obj.dict(exclude_none=True)
            return _normalize(dumped)
    except Exception:
        # if something unexpected happens, fall through and try other checks
        pass

    # list -> normalize items
    if isinstance(obj, list):
        return [_normalize(v) for v in obj]

    # dict -> normalize values
    if isinstance(obj, dict):
        out = {}
        for k, v in obj.items():
            out[k] = _normalize(v)
        return out

    # primitive
    return obj


def test_experimental_call_function_mocked():
    """
    Calls a view function on a contract and returns the result.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_call_function.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_call_function_response_and_rpc_call_function_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_call_function()
        else:
            params = near_jsonrpc_models.RpcCallFunctionRequest.model_validate(req_params)
            result = client.experimental_call_function(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_call_function: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_call_function: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_call_function: got={} expected={}".format(result_value, exp_resp)



def test_experimental_changes_mocked():
    """
    [Deprecated] Returns changes for a given account, contract or contract code for given block height or hash. Consider using changes instead.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_changes.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_state_changes_in_block_response_and_rpc_state_changes_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_changes()
        else:
            params = near_jsonrpc_models.RpcStateChangesInBlockByTypeRequest.model_validate(req_params)
            result = client.experimental_changes(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_changes: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_changes: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_changes: got={} expected={}".format(result_value, exp_resp)



def test_experimental_changes_in_block_mocked():
    """
    [Deprecated] Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched. Consider using block_effects instead
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_changes_in_block.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_state_changes_in_block_by_type_response_and_rpc_state_changes_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_changes_in_block()
        else:
            params = near_jsonrpc_models.RpcStateChangesInBlockRequest.model_validate(req_params)
            result = client.experimental_changes_in_block(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_changes_in_block: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_changes_in_block: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_changes_in_block: got={} expected={}".format(result_value, exp_resp)



def test_experimental_congestion_level_mocked():
    """
    Queries the congestion level of a shard. More info about congestion [here](https://near.github.io/nearcore/architecture/how/receipt-congestion.html?highlight=congestion#receipt-congestion)
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_congestion_level.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_congestion_level_response_and_rpc_chunk_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_congestion_level()
        else:
            params = near_jsonrpc_models.RpcCongestionLevelRequest.model_validate(req_params)
            result = client.experimental_congestion_level(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_congestion_level: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_congestion_level: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_congestion_level: got={} expected={}".format(result_value, exp_resp)



def test_experimental_genesis_config_mocked():
    """
    [Deprecated] Get initial state and parameters for the genesis block. Consider genesis_config instead.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_genesis_config.json')
    resp_fixture = load_mock_json('json_rpc_response_for_genesis_config_and_genesis_config_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_genesis_config()
        else:
            params = near_jsonrpc_models.GenesisConfigRequest.model_validate(req_params)
            result = client.experimental_genesis_config(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_genesis_config: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_genesis_config: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_genesis_config: got={} expected={}".format(result_value, exp_resp)



def test_experimental_light_client_block_proof_mocked():
    """
    Returns the proofs for a transaction execution.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_light_client_block_proof.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_light_client_block_proof_response_and_rpc_light_client_proof_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_light_client_block_proof()
        else:
            params = near_jsonrpc_models.RpcLightClientBlockProofRequest.model_validate(req_params)
            result = client.experimental_light_client_block_proof(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_light_client_block_proof: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_light_client_block_proof: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_light_client_block_proof: got={} expected={}".format(result_value, exp_resp)



def test_experimental_light_client_proof_mocked():
    """
    Returns the proofs for a transaction execution.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_light_client_proof.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_light_client_execution_proof_response_and_rpc_light_client_proof_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_light_client_proof()
        else:
            params = near_jsonrpc_models.RpcLightClientExecutionProofRequest.model_validate(req_params)
            result = client.experimental_light_client_proof(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_light_client_proof: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_light_client_proof: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_light_client_proof: got={} expected={}".format(result_value, exp_resp)



def test_experimental_maintenance_windows_mocked():
    """
    [Deprecated] Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer. Consider using maintenance_windows instead.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_maintenance_windows.json')
    resp_fixture = load_mock_json('json_rpc_response_for_array_of_range_of_uint64_and_rpc_maintenance_windows_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_maintenance_windows()
        else:
            params = near_jsonrpc_models.RpcMaintenanceWindowsRequest.model_validate(req_params)
            result = client.experimental_maintenance_windows(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_maintenance_windows: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_maintenance_windows: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_maintenance_windows: got={} expected={}".format(result_value, exp_resp)



def test_experimental_protocol_config_mocked():
    """
    A configuration that defines the protocol-level parameters such as gas/storage costs, limits, feature flags, other settings
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_protocol_config.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_protocol_config_response_and_rpc_protocol_config_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_protocol_config()
        else:
            params = near_jsonrpc_models.RpcProtocolConfigRequest.model_validate(req_params)
            result = client.experimental_protocol_config(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_protocol_config: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_protocol_config: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_protocol_config: got={} expected={}".format(result_value, exp_resp)



def test_experimental_receipt_mocked():
    """
    Fetches a receipt by its ID (as is, without a status or execution outcome)
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_receipt.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_receipt_response_and_rpc_receipt_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_receipt()
        else:
            params = near_jsonrpc_models.RpcReceiptRequest.model_validate(req_params)
            result = client.experimental_receipt(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_receipt: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_receipt: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_receipt: got={} expected={}".format(result_value, exp_resp)



def test_experimental_split_storage_info_mocked():
    """
    Contains the split storage information. More info on split storage [here](https://near-nodes.io/archival/split-storage-archival)
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_split_storage_info.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_split_storage_info_response_and_rpc_split_storage_info_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_split_storage_info()
        else:
            params = near_jsonrpc_models.RpcSplitStorageInfoRequest.model_validate(req_params)
            result = client.experimental_split_storage_info(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_split_storage_info: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_split_storage_info: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_split_storage_info: got={} expected={}".format(result_value, exp_resp)



def test_experimental_tx_status_mocked():
    """
    Queries status of a transaction by hash, returning the final transaction result and details of all receipts.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_tx_status.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_transaction_response_and_rpc_transaction_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_tx_status()
        else:
            params = near_jsonrpc_models.RpcTransactionStatusRequest.model_validate(req_params)
            result = client.experimental_tx_status(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_tx_status: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_tx_status: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_tx_status: got={} expected={}".format(result_value, exp_resp)



def test_experimental_validators_ordered_mocked():
    """
    Returns the current epoch validators ordered in the block producer order with repetition. This endpoint is solely used for bridge currently and is not intended for other external use cases.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_validators_ordered.json')
    resp_fixture = load_mock_json('json_rpc_response_for_array_of_validator_stake_view_and_rpc_validator_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_validators_ordered()
        else:
            params = near_jsonrpc_models.RpcValidatorsOrderedRequest.model_validate(req_params)
            result = client.experimental_validators_ordered(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_validators_ordered: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_validators_ordered: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_validators_ordered: got={} expected={}".format(result_value, exp_resp)



def test_experimental_view_access_key_mocked():
    """
    Returns information about a single access key for given account.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_view_access_key.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_view_access_key_response_and_rpc_view_access_key_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_view_access_key()
        else:
            params = near_jsonrpc_models.RpcViewAccessKeyRequest.model_validate(req_params)
            result = client.experimental_view_access_key(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_view_access_key: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_view_access_key: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_view_access_key: got={} expected={}".format(result_value, exp_resp)



def test_experimental_view_access_key_list_mocked():
    """
    Returns all access keys for a given account.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_view_access_key_list.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_view_access_key_list_response_and_rpc_view_access_key_list_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_view_access_key_list()
        else:
            params = near_jsonrpc_models.RpcViewAccessKeyListRequest.model_validate(req_params)
            result = client.experimental_view_access_key_list(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_view_access_key_list: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_view_access_key_list: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_view_access_key_list: got={} expected={}".format(result_value, exp_resp)



def test_experimental_view_account_mocked():
    """
    Returns information about an account for given account_id.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_view_account.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_view_account_response_and_rpc_view_account_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_view_account()
        else:
            params = near_jsonrpc_models.RpcViewAccountRequest.model_validate(req_params)
            result = client.experimental_view_account(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_view_account: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_view_account: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_view_account: got={} expected={}".format(result_value, exp_resp)



def test_experimental_view_code_mocked():
    """
    Returns the contract code (Wasm binary) deployed to the account.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_view_code.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_view_code_response_and_rpc_view_code_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_view_code()
        else:
            params = near_jsonrpc_models.RpcViewCodeRequest.model_validate(req_params)
            result = client.experimental_view_code(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_view_code: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_view_code: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_view_code: got={} expected={}".format(result_value, exp_resp)



def test_experimental_view_state_mocked():
    """
    Returns the state (key-value pairs) of a contract based on the key prefix.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_experimental_view_state.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_view_state_response_and_rpc_view_state_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.experimental_view_state()
        else:
            params = near_jsonrpc_models.RpcViewStateRequest.model_validate(req_params)
            result = client.experimental_view_state(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for experimental_view_state: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for experimental_view_state: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for experimental_view_state: got={} expected={}".format(result_value, exp_resp)



def test_block_mocked():
    """
    Returns block details for given height or hash
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_block.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_block_response_and_rpc_block_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.block()
        else:
            params = near_jsonrpc_models.RpcBlockRequest.model_validate(req_params)
            result = client.block(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for block: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for block: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for block: got={} expected={}".format(result_value, exp_resp)



def test_block_effects_mocked():
    """
    Returns changes in block for given block height or hash over all transactions for all the types. Includes changes like account_touched, access_key_touched, data_touched, contract_code_touched.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_block_effects.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_state_changes_in_block_by_type_response_and_rpc_state_changes_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.block_effects()
        else:
            params = near_jsonrpc_models.RpcStateChangesInBlockRequest.model_validate(req_params)
            result = client.block_effects(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for block_effects: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for block_effects: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for block_effects: got={} expected={}".format(result_value, exp_resp)



def test_broadcast_tx_async_mocked():
    """
    [Deprecated] Sends a transaction and immediately returns transaction hash. Consider using send_tx instead.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_broadcast_tx_async.json')
    resp_fixture = load_mock_json('json_rpc_response_for_crypto_hash_and_rpc_transaction_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.broadcast_tx_async()
        else:
            params = near_jsonrpc_models.RpcSendTransactionRequest.model_validate(req_params)
            result = client.broadcast_tx_async(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for broadcast_tx_async: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for broadcast_tx_async: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for broadcast_tx_async: got={} expected={}".format(result_value, exp_resp)



def test_broadcast_tx_commit_mocked():
    """
    [Deprecated] Sends a transaction and waits until transaction is fully complete. (Has a 10 second timeout). Consider using send_tx instead.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_broadcast_tx_commit.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_transaction_response_and_rpc_transaction_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.broadcast_tx_commit()
        else:
            params = near_jsonrpc_models.RpcSendTransactionRequest.model_validate(req_params)
            result = client.broadcast_tx_commit(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for broadcast_tx_commit: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for broadcast_tx_commit: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for broadcast_tx_commit: got={} expected={}".format(result_value, exp_resp)



def test_changes_mocked():
    """
    Returns changes for a given account, contract or contract code for given block height or hash.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_changes.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_state_changes_in_block_response_and_rpc_state_changes_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.changes()
        else:
            params = near_jsonrpc_models.RpcStateChangesInBlockByTypeRequest.model_validate(req_params)
            result = client.changes(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for changes: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for changes: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for changes: got={} expected={}".format(result_value, exp_resp)



def test_chunk_mocked():
    """
    Returns details of a specific chunk. You can run a block details query to get a valid chunk hash.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_chunk.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_chunk_response_and_rpc_chunk_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.chunk()
        else:
            params = near_jsonrpc_models.RpcChunkRequest.model_validate(req_params)
            result = client.chunk(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for chunk: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for chunk: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for chunk: got={} expected={}".format(result_value, exp_resp)



def test_client_config_mocked():
    """
    Queries client node configuration
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_client_config.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_client_config_response_and_rpc_client_config_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.client_config()
        else:
            params = near_jsonrpc_models.RpcClientConfigRequest.model_validate(req_params)
            result = client.client_config(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for client_config: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for client_config: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for client_config: got={} expected={}".format(result_value, exp_resp)



def test_gas_price_mocked():
    """
    Returns gas price for a specific block_height or block_hash. Using [null] will return the most recent block's gas price.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_gas_price.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_gas_price_response_and_rpc_gas_price_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.gas_price()
        else:
            params = near_jsonrpc_models.RpcGasPriceRequest.model_validate(req_params)
            result = client.gas_price(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for gas_price: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for gas_price: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for gas_price: got={} expected={}".format(result_value, exp_resp)



def test_genesis_config_mocked():
    """
    Get initial state and parameters for the genesis block
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_genesis_config.json')
    resp_fixture = load_mock_json('json_rpc_response_for_genesis_config_and_genesis_config_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.genesis_config()
        else:
            params = near_jsonrpc_models.GenesisConfigRequest.model_validate(req_params)
            result = client.genesis_config(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for genesis_config: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for genesis_config: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for genesis_config: got={} expected={}".format(result_value, exp_resp)



def test_health_mocked():
    """
    Returns the current health status of the RPC node the client connects to.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_health.json')
    resp_fixture = load_mock_json('json_rpc_response_for_nullable_rpc_health_response_and_rpc_status_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.health()
        else:
            params = near_jsonrpc_models.RpcHealthRequest.model_validate(req_params)
            result = client.health(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for health: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for health: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for health: got={} expected={}".format(result_value, exp_resp)



def test_light_client_proof_mocked():
    """
    Returns the proofs for a transaction execution.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_light_client_proof.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_light_client_execution_proof_response_and_rpc_light_client_proof_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.light_client_proof()
        else:
            params = near_jsonrpc_models.RpcLightClientExecutionProofRequest.model_validate(req_params)
            result = client.light_client_proof(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for light_client_proof: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for light_client_proof: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for light_client_proof: got={} expected={}".format(result_value, exp_resp)



def test_maintenance_windows_mocked():
    """
    Returns the future windows for maintenance in current epoch for the specified account. In the maintenance windows, the node will not be block producer or chunk producer.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_maintenance_windows.json')
    resp_fixture = load_mock_json('json_rpc_response_for_array_of_range_of_uint64_and_rpc_maintenance_windows_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.maintenance_windows()
        else:
            params = near_jsonrpc_models.RpcMaintenanceWindowsRequest.model_validate(req_params)
            result = client.maintenance_windows(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for maintenance_windows: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for maintenance_windows: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for maintenance_windows: got={} expected={}".format(result_value, exp_resp)



def test_network_info_mocked():
    """
    Queries the current state of node network connections. This includes information about active peers, transmitted data, known producers, etc.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_network_info.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_network_info_response_and_rpc_network_info_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.network_info()
        else:
            params = near_jsonrpc_models.RpcNetworkInfoRequest.model_validate(req_params)
            result = client.network_info(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for network_info: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for network_info: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for network_info: got={} expected={}".format(result_value, exp_resp)



def test_next_light_client_block_mocked():
    """
    Returns the next light client block.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_next_light_client_block.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_light_client_next_block_response_and_rpc_light_client_next_block_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.next_light_client_block()
        else:
            params = near_jsonrpc_models.RpcLightClientNextBlockRequest.model_validate(req_params)
            result = client.next_light_client_block(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for next_light_client_block: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for next_light_client_block: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for next_light_client_block: got={} expected={}".format(result_value, exp_resp)



def test_query_mocked():
    """
    This module allows you to make generic requests to the network.  The `RpcQueryRequest` struct takes in a [`BlockReference`](https://docs.rs/near-primitives/0.12.0/near_primitives/types/enum.BlockReference.html) and a [`QueryRequest`](https://docs.rs/near-primitives/0.12.0/near_primitives/views/enum.QueryRequest.html).  The `BlockReference` enum allows you to specify a block by `Finality`, `BlockId` or `SyncCheckpoint`.  The `QueryRequest` enum provides multiple variants for performing the following actions:  - View an account's details  - View a contract's code  - View the state of an account  - View the `AccessKey` of an account  - View the `AccessKeyList` of an account  - Call a function in a contract deployed on the network.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_query.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_query_response_and_rpc_query_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.query()
        else:
            params = near_jsonrpc_models.RpcQueryRequest.model_validate(req_params)
            result = client.query(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for query: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for query: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for query: got={} expected={}".format(result_value, exp_resp)



def test_send_tx_mocked():
    """
    Sends transaction. Returns the guaranteed execution status and the results the blockchain can provide at the moment.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_send_tx.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_transaction_response_and_rpc_transaction_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.send_tx()
        else:
            params = near_jsonrpc_models.RpcSendTransactionRequest.model_validate(req_params)
            result = client.send_tx(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for send_tx: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for send_tx: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for send_tx: got={} expected={}".format(result_value, exp_resp)



def test_status_mocked():
    """
    Requests the status of the connected RPC node. This includes information about sync status, nearcore node version, protocol version, the current set of validators, etc.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_status.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_status_response_and_rpc_status_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.status()
        else:
            params = near_jsonrpc_models.RpcStatusRequest.model_validate(req_params)
            result = client.status(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for status: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for status: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for status: got={} expected={}".format(result_value, exp_resp)



def test_tx_mocked():
    """
    Queries status of a transaction by hash and returns the final transaction result.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_tx.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_transaction_response_and_rpc_transaction_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.tx()
        else:
            params = near_jsonrpc_models.RpcTransactionStatusRequest.model_validate(req_params)
            result = client.tx(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for tx: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for tx: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for tx: got={} expected={}".format(result_value, exp_resp)



def test_validators_mocked():
    """
    Queries active validators on the network. Returns details and the state of validation on the blockchain.
    """

    client = NearClientSync(base_url="https://rpc.mainnet.near.org")

    req_fixture = load_mock_json('json_rpc_request_for_validators.json')
    resp_fixture = load_mock_json('json_rpc_response_for_rpc_validator_response_and_rpc_validator_error.json')

    expected_request = req_fixture
    expected_response = resp_fixture

    with respx.mock:
        if isinstance(expected_response, dict) and {'jsonrpc','id','result'}.issubset(expected_response):
            mock_response_json = expected_response
        else:
            mock_response_json = {'jsonrpc': '2.0', 'id': 'test', 'result': expected_response}
        route = respx.post("https://rpc.mainnet.near.org").mock(return_value=Response(200, json=mock_response_json))

        req = expected_request
        if isinstance(req, dict) and 'params' in req:
            req_params = req['params']
        else:
            req_params = req

        if req_params is None:
            result = client.validators()
        else:
            params = near_jsonrpc_models.RpcValidatorRequest.model_validate(req_params)
            result = client.validators(params=params)

        assert route.called
        assert len(route.calls) >= 1
        sent = None
        req_obj = route.calls[0].request
        body = getattr(req_obj, 'content', None)
        if body is None:
            try:
                body = req_obj.read()
            except Exception:
                body = None
        if isinstance(body, bytes):
            try:
                body = body.decode('utf-8')
            except Exception:
                body = body.decode('latin-1')
        if isinstance(body, str) and body.strip():
            try:
                sent = json.loads(body)
            except Exception:
                sent = None

        if isinstance(sent, dict):
            sent_params = sent.get('params')
            exp = req_params
            if isinstance(expected_request, dict) and 'params' in expected_request:
                exp = expected_request.get('params')
            if exp is None:
                assert ('params' not in sent) or (sent.get('params') is None), "params mismatch for validators: expected None but found present"
            else:
                assert sent_params == exp, "params mismatch for validators: sent={} expected={}".format(sent_params, exp)

        exp_resp = expected_response
        if isinstance(exp_resp, dict) and 'result' in exp_resp:
            exp_resp = exp_resp['result']

        result_value = _normalize(result)

        assert result_value == exp_resp, "result mismatch for validators: got={} expected={}".format(result_value, exp_resp)
