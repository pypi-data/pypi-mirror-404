# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import enum
import typing

@typing.final
class AdvanceEpoch:
    @property
    def time(self) -> AdvanceTime: ...
    @property
    def epoch_id(self) -> builtins.int: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, epoch_id: builtins.int, time: AdvanceTime) -> AdvanceEpoch: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class AdvanceSettlementEpoch:
    @property
    def time(self) -> AdvanceTime: ...
    @property
    def actions(self) -> builtins.list[SettlementAction]: ...
    @property
    def epoch_id(self) -> builtins.int: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, epoch_id: builtins.int, time: AdvanceTime, actions: typing.Sequence[SettlementAction]) -> AdvanceSettlementEpoch: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class AdvanceTime:
    @property
    def value(self) -> builtins.int: ...
    @property
    def timestamp(self) -> builtins.int: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, value: builtins.int, timestamp: builtins.int) -> AdvanceTime: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Balance:
    r"""
    Maps token address to balance amount
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, amount: Decimal, address: TokenSymbol) -> Balance: ...
    def __repr__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, key: TokenSymbol) -> Decimal: ...
    def __setitem__(self, key: TokenSymbol, value: Decimal) -> None: ...
    @classmethod
    def default(cls) -> Balance:
        r"""
        Return an empty `Balance` with zero for every token.
        """
    @classmethod
    def new_from_many(cls, amounts: typing.Mapping[TokenSymbol, Decimal]) -> Balance:
        r"""
        Construct a `Balance` from a mapping (`dict`) of
        `TokenSymbol` â†’ `Decimal` amounts.
        """
    def total_value(self) -> Decimal:
        r"""
        Total value of this balance, obtained by summing
        every token amount. This will be either in USD or DDX, depending on
        its contents.
        """
    def amounts(self) -> builtins.list[Decimal]:
        r"""
        Raw amounts ordered by the canonical token list.
        """

@typing.final
class BinaryPredictionFuture:
    @property
    def event(self) -> builtins.str: ...
    @property
    def qualifier(self) -> builtins.int:
        r"""
        numeric qualifier (often year-like "26")
        """
    @property
    def description(self) -> builtins.str: ...
    @property
    def tick_size(self) -> Decimal: ...
    @property
    def max_order_notional(self) -> Decimal: ...
    @property
    def max_taker_price_deviation(self) -> Decimal: ...
    @property
    def min_order_size(self) -> Decimal: ...

@typing.final
class Block:
    r"""
    We use a single `BlockProducer` to sequence blocks along with other requests to ensure that
    all Execution Operators synchronize their state with Ethereum event in the same order.
    
    # Notes
    
    Some Ethereum events (e.g. Deposits) must only be processed on confirmed blocks.
    Block confirmation count is handled client-side during execution. The block producer's
    responsibility is just to post block numbers into the `RequestQueue`.
    """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, number: builtins.int) -> Block: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class BookOrder:
    r"""
    A Bid or Ask in the orderbook (maker order)
    """
    @property
    def side(self) -> OrderSide:
        r"""
        Bid = 0, Ask = 1
        """
    @side.setter
    def side(self, value: OrderSide) -> None:
        r"""
        Bid = 0, Ask = 1
        """
    @property
    def amount(self) -> Decimal:
        r"""
        Order amount
        """
    @amount.setter
    def amount(self, value: Decimal) -> None:
        r"""
        Order amount
        """
    @property
    def price(self) -> Decimal:
        r"""
        Price offered to takers
        """
    @price.setter
    def price(self, value: Decimal) -> None:
        r"""
        Price offered to takers
        """
    @property
    def trader_address(self) -> builtins.str:
        r"""
        Maker address
        """
    @trader_address.setter
    def trader_address(self, value: builtins.str) -> None:
        r"""
        Maker address
        """
    @property
    def strategy_id_hash(self) -> builtins.str:
        r"""
        Maker strategy identifier
        """
    @strategy_id_hash.setter
    def strategy_id_hash(self, value: builtins.str) -> None:
        r"""
        Maker strategy identifier
        """
    @property
    def book_ordinal(self) -> builtins.int:
        r"""
        Per market ordinal sequencing inclusion in the order book
        """
    @book_ordinal.setter
    def book_ordinal(self, value: builtins.int) -> None:
        r"""
        Per market ordinal sequencing inclusion in the order book
        """
    @property
    def time_value(self) -> builtins.int:
        r"""
        Time stamp of the post order transaction
        """
    @time_value.setter
    def time_value(self, value: builtins.int) -> None:
        r"""
        Time stamp of the post order transaction
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, side: OrderSide, amount: Decimal, price: Decimal, trader_address: builtins.str, strategy_id_hash: builtins.str, book_ordinal: builtins.int, time_value: builtins.int) -> BookOrder: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> BookOrder: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> BookOrder:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """

@typing.final
class BookOrderKey:
    @property
    def symbol(self) -> ProductSymbol: ...
    @property
    def order_hash(self) -> builtins.str: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, symbol: ProductSymbol, order_hash: builtins.str) -> BookOrderKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> BookOrderKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> BookOrderKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """

@typing.final
class CancelAllIntent:
    r"""
    Batch cancel all orders for a given strategy
    """
    @property
    def symbol(self) -> ProductSymbol: ...
    @property
    def strategy(self) -> builtins.str:
        r"""
        Strategy to cancel orders for
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function.
        """
    @property
    def session_key_signature(self) -> typing.Optional[builtins.str]:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @session_key_signature.setter
    def session_key_signature(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the order cancellation intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the order cancellation intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, symbol: ProductSymbol, strategy: builtins.str, nonce: builtins.str, session_key_signature: typing.Optional[builtins.str], signature: typing.Optional[builtins.str] = None) -> CancelAllIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """

@typing.final
class CancelOrderIntent:
    @property
    def symbol(self) -> ProductSymbol: ...
    @property
    def order_hash(self) -> builtins.str:
        r"""
        hash of the corresponding order intent
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        `nonce` specified in the order intent to cancel (to lookup the order without storing its hash)
        A salt for uniqueness of the EIP-712 hash function. May optionally have business meaning to the client.
        """
    @property
    def session_key_signature(self) -> typing.Optional[builtins.str]:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @session_key_signature.setter
    def session_key_signature(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the order cancellation intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the order cancellation intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, symbol: ProductSymbol, order_hash: builtins.str, nonce: builtins.str, session_key_signature: typing.Optional[builtins.str], signature: typing.Optional[builtins.str] = None) -> CancelOrderIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """

class CoreCommonError(builtins.Exception):
    r"""
    DDX Core error
    """
    ...

@typing.final
class Decimal:
    r"""
    Wrapped rust_decimal::Decimal. Constructor only supports str, e.g d = Decimal("123.456")
    """
    def __str__(self) -> builtins.str: ...
    def __new__(cls, maybe_value: typing.Optional[typing.Any] = None) -> Decimal:
        r"""
        Create a new Decimal In Python:
        let d1 = Decimal("123.456")
        let d2 = Decimal("-987.654")
        let d3 = Decimal("456")
        let d4 = Decimal() # Decimal("0")
        Accepts `None`, another `Decimal`, a string, an `int`, or a `float`.  
        When no value (or `None`) is supplied the resulting `Decimal` is zero.
        """
    def recorded_amount(self) -> Decimal:
        r"""
        Returns a value rounded toward zero to `TOKEN_UNIT_SCALE` decimal
        places, matching the precision stored on-chain as `RecordedAmount`.
        """
    def to_usdc_grains(self) -> builtins.int:
        r"""
        Converts the current amount into raw USDC grains
        (`u128`, scaled by `10^TOKEN_UNIT_SCALE`).
        Fails if the result does not fit in `u128`.
        """
    def to_ddx_grains(self) -> builtins.int:
        r"""
        Converts the current amount into raw DDX grains
        (`u128`, scaled by `10^18`).
        Fails if the result does not fit in `u128`.
        """
    @classmethod
    def from_usdc_grains(cls, u: builtins.int) -> Decimal:
        r"""
        Creates a `Decimal` from a `u128` expressed in USDC grains
        (i.e. already scaled by `10^TOKEN_UNIT_SCALE`).
        """
    @classmethod
    def from_ddx_grains(cls, u: builtins.int) -> Decimal:
        r"""
        Creates a `Decimal` from a `u128` expressed in DDX grains
        (i.e. already scaled by `10^18`).
        """
    def quantize(self, precision: builtins.int) -> Decimal:
        r"""
        Returns a copy of this value rounded toward zero to the requested
        number of fractional digits (`precision`).
        """
    def __setstate__(self, state: typing.Any) -> None: ...
    def __getstate__(self) -> typing.Any: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other: typing.Any) -> builtins.bool: ...
    def __ne__(self, other: typing.Any) -> builtins.bool: ...
    def __lt__(self, other: typing.Any) -> builtins.bool: ...
    def __le__(self, other: typing.Any) -> builtins.bool: ...
    def __gt__(self, other: typing.Any) -> builtins.bool: ...
    def __ge__(self, other: typing.Any) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __add__(self, other: typing.Any) -> Decimal: ...
    def __radd__(self, other: typing.Any) -> Decimal: ...
    def __sub__(self, other: typing.Any) -> Decimal: ...
    def __rsub__(self, other: typing.Any) -> Decimal: ...
    def __mul__(self, other: typing.Any) -> Decimal: ...
    def __rmul__(self, other: typing.Any) -> Decimal: ...
    def __truediv__(self, other: typing.Any) -> Decimal: ...
    def __rtruediv__(self, other: typing.Any) -> Decimal: ...
    def __mod__(self, other: typing.Any) -> Decimal: ...
    def __rmod__(self, other: typing.Any) -> Decimal: ...
    def __pow__(self, exponent: typing.Any, modulo: typing.Any = None) -> Decimal: ...
    def __rpow__(self, base: typing.Any, modulo: typing.Any = None) -> Decimal: ...
    def __neg__(self) -> Decimal: ...
    def __abs__(self) -> Decimal: ...
    def __int__(self) -> builtins.int: ...
    def __float__(self) -> builtins.float: ...

class DecimalError(builtins.Exception):
    r"""
    rust_decimal::Decimal error
    """
    ...

@typing.final
class DerivadexSMT:
    r"""
    Wrapped DerivaDEX Sparse Merkle Tree.
    """
    def __repr__(self) -> builtins.str: ...
    def __new__(cls) -> DerivadexSMT:
        r"""
        Construct an empty in-memory SMT with a fresh root.
        """
    @classmethod
    def from_genesis(cls, insurance_fund_cap: Balance, ddx_fee_pool: Decimal, specs: typing.Any, current_time: datetime.datetime) -> DerivadexSMT:
        r"""
        Build the genesis SMT, taking `current_time` into account for futures.
        """
    def root(self) -> H256:
        r"""
        Current SMT root hash.
        """
    def merkle_proof(self, keys: typing.Sequence[H256]) -> MerkleProof:
        r"""
        Generate a compiled Merkle proof covering all provided leaf `keys`.
        """
    def store_item_by_key(self, key: H256, maybe_inner: typing.Optional[Item]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf at `key` and return the
        updated tree root hash.
        """
    def __deepcopy__(self, _memo: dict) -> DerivadexSMT: ...
    def trader(self, key: TraderKey) -> typing.Optional[Trader]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_trader(self, key: TraderKey, maybe_inner: typing.Optional[Trader]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_traders(self) -> builtins.list[tuple[TraderKey, Trader]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def strategy(self, key: StrategyKey) -> typing.Optional[Strategy]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_strategy(self, key: StrategyKey, maybe_inner: typing.Optional[Strategy]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_strategies(self) -> builtins.list[tuple[StrategyKey, Strategy]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def position(self, key: PositionKey) -> typing.Optional[Position]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_position(self, key: PositionKey, maybe_inner: typing.Optional[Position]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_positions(self) -> builtins.list[tuple[PositionKey, Position]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def book_order(self, key: BookOrderKey) -> typing.Optional[BookOrder]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_book_order(self, key: BookOrderKey, maybe_inner: typing.Optional[BookOrder]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_book_orders(self) -> builtins.list[tuple[BookOrderKey, BookOrder]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def price(self, key: PriceKey) -> typing.Optional[Price]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_price(self, key: PriceKey, maybe_inner: typing.Optional[Price]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_prices(self) -> builtins.list[tuple[PriceKey, Price]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def insurance_fund(self, key: InsuranceFundKey) -> typing.Optional[InsuranceFund]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_insurance_fund(self, key: InsuranceFundKey, maybe_inner: typing.Optional[InsuranceFund]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_insurance_funds(self) -> builtins.list[tuple[InsuranceFundKey, InsuranceFund]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def stats(self, key: StatsKey) -> typing.Optional[Stats]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_stats(self, key: StatsKey, maybe_inner: typing.Optional[Stats]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_stats(self) -> builtins.list[tuple[StatsKey, Stats]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def signer(self, key: SignerKey) -> typing.Optional[Signer]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_signer(self, key: SignerKey, maybe_inner: typing.Optional[Signer]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_signers(self) -> builtins.list[tuple[SignerKey, Signer]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def specs(self, key: SpecsKey) -> typing.Optional[Specs]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_specs(self, key: SpecsKey, maybe_inner: typing.Optional[Specs]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_specs(self) -> builtins.list[tuple[SpecsKey, Specs]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def tradable_product(self, key: TradableProductKey) -> typing.Optional[TradableProduct]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_tradable_product(self, key: TradableProductKey, maybe_inner: typing.Optional[TradableProduct]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_tradable_products(self) -> builtins.list[tuple[TradableProductKey, TradableProduct]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def insurance_fund_contribution(self, key: InsuranceFundContributionKey) -> typing.Optional[InsuranceFundContribution]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_insurance_fund_contribution(self, key: InsuranceFundContributionKey, maybe_inner: typing.Optional[InsuranceFundContribution]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_insurance_fund_contributions(self) -> builtins.list[tuple[InsuranceFundContributionKey, InsuranceFundContribution]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def epoch_metadata(self, key: EpochMetadataKey) -> typing.Optional[EpochMetadata]:
        r"""
        Fetch the item stored at `key`, or `None` if the leaf is empty.
        """
    def store_epoch_metadata(self, key: EpochMetadataKey, maybe_inner: typing.Optional[EpochMetadata]) -> H256:
        r"""
        Insert (`Some`) or delete (`None`) a leaf and return the new
        SMT root hash.
        """
    def all_epoch_metadatas(self) -> builtins.list[tuple[EpochMetadataKey, EpochMetadata]]:
        r"""
        Return every item of this type currently stored in the tree.
        """
    def all_leaves(self) -> builtins.list[tuple[H256, Item]]:
        r"""
        Helper that returns the filtered list described by the method.
        """
    def all_prices_for_symbol(self, symbol: ProductSymbol) -> builtins.list[tuple[PriceKey, Price]]:
        r"""
        Helper that returns the filtered list described by the method.
        """
    def all_positions_for_symbol(self, symbol: ProductSymbol) -> builtins.list[tuple[PositionKey, Position]]:
        r"""
        Helper that returns the filtered list described by the method.
        """
    def all_book_orders_for_symbol(self, symbol: ProductSymbol) -> builtins.list[tuple[BookOrderKey, BookOrder]]:
        r"""
        Helper that returns the filtered list described by the method.
        """

@typing.final
class EpochMetadata:
    r"""
    Metadata about an epoch that has been transitioned.
    """
    @property
    def ddx_fee_pool(self) -> Decimal:
        r"""
        The DDX fee pool. This represents the total DDX fees collected in this epoch and are
        distributed among custodians during a valid checkpoint.
        """
    @ddx_fee_pool.setter
    def ddx_fee_pool(self, value: Decimal) -> None:
        r"""
        The DDX fee pool. This represents the total DDX fees collected in this epoch and are
        distributed among custodians during a valid checkpoint.
        """
    @property
    def next_book_ordinals(self) -> builtins.dict[ProductSymbol, builtins.int]:
        r"""
        The next book ordinals for all of the active markets. This mapping
        allows follower nodes to reliably generate the market index from the
        sparse merkle tree. The ordinals are logged at the end of the epoch and are None if this is
        the current epoch.
        """
    @next_book_ordinals.setter
    def next_book_ordinals(self, value: builtins.dict[ProductSymbol, builtins.int]) -> None:
        r"""
        The next book ordinals for all of the active markets. This mapping
        allows follower nodes to reliably generate the market index from the
        sparse merkle tree. The ordinals are logged at the end of the epoch and are None if this is
        the current epoch.
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, ddx_fee_pool: Decimal, next_book_ordinals: typing.Mapping[ProductSymbol, builtins.int]) -> EpochMetadata: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> EpochMetadata: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> EpochMetadata:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> EpochMetadata:
        r"""
        Return empty `EpochMetadata` with zero fee pool and no order ordinals.
        """

@typing.final
class EpochMetadataKey:
    @property
    def epoch_id(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, epoch_id: builtins.int) -> EpochMetadataKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> EpochMetadataKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> EpochMetadataKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """

@typing.final
class H256:
    r"""
    Wrapped sparse_merkle_tree::H256.
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    @classmethod
    def from_bytes(cls, b: builtins.bytes) -> H256:
        r"""
        Construct an `H256` from a 32-byte buffer passed from Python.
        Raises `H256Error` when the supplied slice is not exactly 32 bytes long.
        """
    def as_bytes(self) -> builtins.bytes:
        r"""
        Return the underlying 32-byte value as an immutable `bytes`/`memoryview`.
        """
    @staticmethod
    def zero() -> H256:
        r"""
        Return a new zero hash (all bits set to 0).
        """
    def is_zero(self) -> builtins.bool:
        r"""
        `true` if this value equals the zero hash.
        """
    def get_bit(self, i: builtins.int) -> builtins.bool:
        r"""
        Return the bit at position `i` (0 = most-significant bit).
        """
    def set_bit(self, i: builtins.int) -> None:
        r"""
        Set the bit at position `i` to `1`.
        """
    def clear_bit(self, i: builtins.int) -> None:
        r"""
        Clear the bit at position `i` (set it to `0`).
        """
    def fork_height(self, key: H256) -> builtins.int:
        r"""
        Return the length (in bits) of the common prefix between this key and `key`.
        """
    def parent_path(self, height: builtins.int) -> H256:
        r"""
        Return a new key that keeps the first `height` bits of this key
        (i.e. the path of the parent node at that height).
        """
    def copy_bits(self, start: builtins.int) -> H256:
        r"""
        Copy the suffix of this key starting at bit `start` into a new `H256`.
        """
    def __setstate__(self, state: typing.Any) -> None: ...
    def __getstate__(self) -> typing.Any: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

class H256Error(builtins.Exception):
    r"""
    sparse_merkle_tree::H256 error
    """
    ...

@typing.final
class IndexFundPerpetual:
    @property
    def allocation(self) -> builtins.dict[builtins.str, Decimal]: ...
    @property
    def rebalance_interval(self) -> builtins.int: ...
    @property
    def initial_index_price(self) -> Decimal: ...
    @property
    def tick_size(self) -> Decimal: ...
    @property
    def max_order_notional(self) -> Decimal: ...
    @property
    def max_taker_price_deviation(self) -> Decimal: ...
    @property
    def min_order_size(self) -> Decimal: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, **kwds: typing.Any) -> IndexFundPerpetual: ...

@typing.final
class IndexPrice:
    r"""
    An index price is the price update of an instrument coming from the oracle.
    
    It is signed by the oracle's enclave.
    """
    @property
    def symbol(self) -> ProductSymbol:
        r"""
        Symbol of the instrument
        """
    @property
    def price(self) -> Decimal:
        r"""
        Current market price in the source exchange
        """
    @property
    def prev_price(self) -> Decimal:
        r"""
        The previous price update. Useful to prove that no prices were skipped.
        """
    @property
    def metadata(self) -> PriceMetadata:
        r"""
        Additional metadata required by the oracle to initialize
        """
    @property
    def timestamp(self) -> builtins.int: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, symbol: ProductSymbol, price: Decimal, prev_price: Decimal, metadata: PriceMetadata, timestamp: builtins.int) -> IndexPrice: ...
    def __repr__(self) -> builtins.str: ...
    def hash(self) -> builtins.str:
        r"""
        Compute the hash of this index price request.
        """

@typing.final
class InsuranceFund:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> InsuranceFund: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> InsuranceFund:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    def __len__(self) -> builtins.int: ...
    def __getitem__(self, key: TokenSymbol) -> Decimal: ...
    def __setitem__(self, key: TokenSymbol, value: Decimal) -> None: ...
    def __new__(cls, amount: Decimal, symbol: TokenSymbol) -> InsuranceFund:
        r"""
        Construct a balance initialized with `amount` of `symbol`.
        """
    @classmethod
    def default(cls) -> InsuranceFund:
        r"""
        Return an empty balance with zero for every token.
        """
    @classmethod
    def new_from_many(cls, amounts: typing.Mapping[TokenSymbol, Decimal]) -> InsuranceFund:
        r"""
        Construct a balance from a mapping of token amounts.
        """
    def total_value(self) -> Decimal:
        r"""
        Total value of this balance, obtained by summing
        every token amount. This will be either in USD or DDX, depending on
        its contents.
        """
    def amounts(self) -> builtins.list[Decimal]:
        r"""
        Raw amounts ordered by the canonical token list.
        """

@typing.final
class InsuranceFundContribution:
    r"""
    An insurance fund contribution
    """
    @property
    def avail_balance(self) -> Balance:
        r"""
        Total contribution to the insurance fund, minus any withdrawals
        """
    @property
    def locked_balance(self) -> Balance:
        r"""
        Balance locked for withdrawal
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, avail_balance: Balance, locked_balance: Balance) -> InsuranceFundContribution: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> InsuranceFundContribution: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> InsuranceFundContribution:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> InsuranceFundContribution:
        r"""
        Return an empty `InsuranceFundContribution` with zero balances.
        """
    def set_avail_balance(self, symbol: TokenSymbol, amount: Decimal) -> None:
        r"""
        Update this contributor's available balance for `symbol` to `amount`.
        """
    def set_locked_balance(self, symbol: TokenSymbol, amount: Decimal) -> None:
        r"""
        Update this contributor's locked balance for `symbol` to `amount`.
        """
    def update_avail_balance(self, symbol: TokenSymbol, amount: Decimal) -> Balance:
        r"""
        Return a copy of `avail_balance` with `symbol` set to `amount`.
        """
    def update_locked_balance(self, symbol: TokenSymbol, amount: Decimal) -> Balance:
        r"""
        Return a copy of `locked_balance` with `symbol` set to `amount`.
        """

@typing.final
class InsuranceFundContributionKey:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> InsuranceFundContributionKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> InsuranceFundContributionKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def __new__(cls, inner: builtins.str) -> InsuranceFundContributionKey: ...

@typing.final
class InsuranceFundKey:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls) -> InsuranceFundKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> InsuranceFundKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> InsuranceFundKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """

@typing.final
class Item:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def item_kind(self) -> ItemKind:
        r"""
        Return this item's [`ItemKind`] discriminant.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode the wrapped value for hashing / storage.
        """
    @classmethod
    def abi_decode_value_into_item(cls, kind: ItemKind, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode the bytes produced by `abi_encoded_value()` back into
        an [`Item`] of the supplied kind.
        """
    @classmethod
    def decode_key(cls, kind: ItemKind, encoded_key: H256) -> typing.Any:
        r"""
        Decode a 32-byte SMT key into its strongly-typed form for
        the provided item kind.
        """

class MarkPriceMetadata:
    r"""
    Metadata for calculating the mark price, along with the current index price
    """
    @property
    def ema(self) -> typing.Optional[Decimal]: ...
    @classmethod
    def from_dict(cls, ob: typing.Any) -> MarkPriceMetadata:
        r"""
        Deserialize `MarkPriceMetadata` from the operator serialization.
        """
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> MarkPriceMetadata: ...
    @typing.final
    class Ema(MarkPriceMetadata):
        r"""
        The mark price is calculated using the ema
        The calculated exponential moving address (input to the mark price and verifiable using orderbook snapshot in the aggregate tree)
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Decimal: ...
        def __new__(cls, _0: Decimal) -> MarkPriceMetadata.Ema: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class Average(MarkPriceMetadata):
        r"""
        The mark price is calculated as an average using the sum and amount of previous index prices
        Mark price = (accum + index_price) / (count + 1)
        """
        __match_args__ = ("accum", "count",)
        @property
        def accum(self) -> Decimal: ...
        @property
        def count(self) -> builtins.int: ...
        def __new__(cls, accum: Decimal, count: builtins.int) -> MarkPriceMetadata.Average: ...
    

@typing.final
class MarketClose:
    @property
    def result(self) -> builtins.str: ...
    @property
    def timestamp(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...

@typing.final
class MerkleProof:
    def __repr__(self) -> builtins.str: ...
    def as_bytes(self) -> builtins.bytes:
        r"""
        Return the compiled proof as a raw byte slice suitable for
        on-chain verification.
        """

@typing.final
class MintPriceCheckpoint:
    @property
    def time_value(self) -> builtins.int: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, time_value: builtins.int) -> MintPriceCheckpoint: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class ModifyOrderIntent:
    r"""
    Modify order intents are intents that modify the original order details of a specific order
    identified by its order hash.
    
    This is identical to a cancel and a re-placing of the new order,
    the only difference from doing them separately being that the execution is atomic when executed
    as a ModifyOrderIntent.
    """
    @property
    def order_hash(self) -> builtins.str:
        r"""
        Order hash of the order to modify
        """
    @property
    def symbol(self) -> ProductSymbol:
        r"""
        Symbol of the market
        """
    @property
    def strategy(self) -> builtins.str:
        r"""
        Strategy Id (label)
        """
    @property
    def side(self) -> OrderSide:
        r"""
        Side: 0-Long, 1-Short
        """
    @property
    def order_type(self) -> OrderType:
        r"""
        0-Limit, 1-Market, 2-Stop-Limit
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function. May optionally have business meaning to the client.
        """
    @property
    def amount(self) -> Decimal:
        r"""
        Order amount
        """
    @property
    def price(self) -> Decimal:
        r"""
        Order price. For a limit order, it is the limit price.
        """
    @property
    def stop_price(self) -> Decimal:
        r"""
        Stop price. Set to 0 if the order is not a Stop-Limit.
        """
    @property
    def session_key_signature(self) -> typing.Optional[builtins.str]:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @session_key_signature.setter
    def session_key_signature(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, order_hash: builtins.str, symbol: ProductSymbol, strategy: builtins.str, side: OrderSide, order_type: OrderType, nonce: builtins.str, amount: Decimal, price: Decimal, stop_price: Decimal, session_key_signature: typing.Optional[builtins.str], signature: typing.Optional[builtins.str] = None) -> ModifyOrderIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """
    def hash(self) -> builtins.str:
        r"""
        Compute the hash of this modify order intent.
        """

@typing.final
class OperatorContext:
    r"""
    Holds application-layer environment information
    
    Information in here as analogous to something like the operating system locale, but at the application layer.
    In the git application for instance, such context includes name and email.
    Storing this information globally saves us the noise of repeating the same informational arguments
    in multiple functions throughout the application.
    
    This does NOT include logic inputs of individual units like configuration parameters (like db credentials),
    business rules (like epoch sizes), etc. We capture these in `TrustedContext` and `NodeContext`, and
    pass them explicitly to individual components (in the name of functional testability).
    
    This information does not impact logic routes (testability)
    """
    @property
    def contract_address(self) -> builtins.str: ...
    @property
    def chain_id(self) -> builtins.int: ...

@typing.final
class OrderIntent:
    r"""
    Order intents are meta-transactions signed by traders Ethereum wallets and submitted to operators.
    
    They come in through the API, signed by their maker. We verify that:
    
    a) the signatures recovers the `trader_address`
    b) the maker has enough collateral to be solvent when the order gets filled
    
    Following verification, we match an order intent against the order book. This may result in
    fill(s) or posting into the order book depending on the matches found.
    """
    @property
    def symbol(self) -> ProductSymbol:
        r"""
        Symbol of the market
        """
    @property
    def strategy(self) -> builtins.str:
        r"""
        Strategy Id (label)
        """
    @property
    def side(self) -> OrderSide:
        r"""
        Side: 0-Long, 1-Short
        """
    @property
    def order_type(self) -> OrderType:
        r"""
        0-Limit, 1-Market, 2-Stop-Limit
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function. May optionally have business meaning to the client.
        """
    @property
    def amount(self) -> Decimal:
        r"""
        Order amount
        """
    @property
    def price(self) -> Decimal:
        r"""
        Order price. For a limit order, it is the limit price.
        """
    @property
    def stop_price(self) -> Decimal:
        r"""
        Stop price. Set to 0 if the order is not a Stop-Limit.
        """
    @property
    def session_key_signature(self) -> typing.Optional[builtins.str]:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @session_key_signature.setter
    def session_key_signature(self, value: typing.Optional[builtins.str]) -> None:
        r"""
        EIP-191 signature of the 1CT session public key
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, symbol: ProductSymbol, strategy: builtins.str, side: OrderSide, order_type: OrderType, nonce: builtins.str, amount: Decimal, price: Decimal, stop_price: Decimal, session_key_signature: typing.Optional[builtins.str], signature: typing.Optional[builtins.str] = None) -> OrderIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """
    def hash(self) -> builtins.str:
        r"""
        Compute the hash of this order intent.
        """

@typing.final
class OrderType:
    Limit: OrderType = ...
    Market: OrderType = ...
    StopLimit: OrderType = ...
    PostOnlyLimit: OrderType = ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class Position:
    r"""
    An individual position held in an strategy
    """
    @property
    def side(self) -> PositionSide:
        r"""
        The position side: Long = 0, Short = 1
        """
    @side.setter
    def side(self, value: PositionSide) -> None:
        r"""
        The position side: Long = 0, Short = 1
        """
    @property
    def balance(self) -> Decimal:
        r"""
        The position size denominated in the same unit as the underlying
        """
    @balance.setter
    def balance(self, value: Decimal) -> None:
        r"""
        The position size denominated in the same unit as the underlying
        """
    @property
    def avg_entry_price(self) -> Decimal:
        r"""
        The average entry price (updated when adding to the position)
        """
    @avg_entry_price.setter
    def avg_entry_price(self, value: Decimal) -> None:
        r"""
        The average entry price (updated when adding to the position)
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, side: PositionSide, balance: Decimal, avg_entry_price: Decimal) -> Position: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Position: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Position:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> Position:
        r"""
        Return an empty `Position` with zero balance and no entry price.
        """
    def bankruptcy_price(self, mark_price: Decimal, account_total_value: Decimal) -> Decimal:
        r"""
        Bankruptcy price at which margin would be exhausted.
        """
    def unrealized_pnl(self, price: Decimal) -> Decimal:
        r"""
        Unrealized profit and loss at the specified `price`.
        """
    def avg_pnl(self, price: Decimal) -> Decimal:
        r"""
        Average P&L per contract at the specified `price`.
        """
    def increase(self, price: Decimal, amount: Decimal) -> tuple[Position, Decimal]:
        r"""
        Increase position size by `amount` at `price`; returns the new
        position together with any realized P&L.
        """
    def decrease(self, price: Decimal, amount: Decimal) -> tuple[Position, Decimal]:
        r"""
        Decrease position size by `amount` at `price`; returns the new
        position and realized P&L.
        """
    def cross_over(self, price: Decimal, amount: Decimal) -> tuple[Position, Decimal]:
        r"""
        Reverse side by `amount` at `price`; returns updated position and P&L.
        """

@typing.final
class PositionKey:
    @property
    def trader_address(self) -> builtins.str: ...
    @property
    def strategy_id_hash(self) -> builtins.str: ...
    @property
    def symbol(self) -> ProductSymbol: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, trader_address: builtins.str, strategy_id_hash: builtins.str, symbol: ProductSymbol) -> PositionKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> PositionKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> PositionKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def as_strategy_key(self) -> StrategyKey:
        r"""
        Convert this position key into its owner `StrategyKey`.
        """

@typing.final
class Price:
    r"""
    A price value (used for funding and liquidations)
    """
    @property
    def index_price(self) -> Decimal:
        r"""
        The index price number coming from a oracle
        """
    @index_price.setter
    def index_price(self, value: Decimal) -> None:
        r"""
        The index price number coming from a oracle
        """
    @property
    def mark_price_metadata(self) -> MarkPriceMetadata: ...
    @mark_price_metadata.setter
    def mark_price_metadata(self, value: MarkPriceMetadata) -> None: ...
    @property
    def ordinal(self) -> builtins.int: ...
    @ordinal.setter
    def ordinal(self, value: builtins.int) -> None: ...
    @property
    def time_value(self) -> builtins.int: ...
    @time_value.setter
    def time_value(self, value: builtins.int) -> None: ...
    @property
    def mark_price(self) -> Decimal: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, index_price: Decimal, mark_price_metadata: MarkPriceMetadata, ordinal: builtins.int, time_value: builtins.int) -> Price: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Price: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Price:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """

@typing.final
class PriceKey:
    @property
    def symbol(self) -> ProductSymbol: ...
    @property
    def index_price_hash(self) -> builtins.str: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, symbol: ProductSymbol, index_price_hash: builtins.str) -> PriceKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> PriceKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> PriceKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """

@typing.final
class PriceMetadata:
    @property
    def weights(self) -> typing.Optional[builtins.dict[builtins.str, Decimal]]: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    @classmethod
    def from_dict(cls, ob: typing.Any) -> PriceMetadata:
        r"""
        Deserialize `PriceMetadata` from the operator serialization.
        """
    def __repr__(self) -> builtins.str: ...

class ProductSpecs:
    @property
    def tick_size(self) -> Decimal: ...
    @property
    def max_order_notional(self) -> Decimal: ...
    @property
    def max_taker_price_deviation(self) -> Decimal: ...
    @property
    def min_order_size(self) -> Decimal: ...
    def __repr__(self) -> builtins.str: ...
    def underlying_symbols(self, tradable_params: typing.Optional[TradableProductParameters]) -> builtins.list[builtins.str]:
        r"""
        Return the list of underlying symbols referenced by this specification.
        """
    @typing.final
    class SingleNamePerpetual(ProductSpecs):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> SingleNamePerpetual: ...
        def __new__(cls, _0: SingleNamePerpetual) -> ProductSpecs.SingleNamePerpetual: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class IndexFundPerpetual(ProductSpecs):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> IndexFundPerpetual: ...
        def __new__(cls, _0: IndexFundPerpetual) -> ProductSpecs.IndexFundPerpetual: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class QuarterlyExpiryFuture(ProductSpecs):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> QuarterlyExpiryFuture: ...
        def __new__(cls, _0: QuarterlyExpiryFuture) -> ProductSpecs.QuarterlyExpiryFuture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class BinaryPredictionFuture(ProductSpecs):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> BinaryPredictionFuture: ...
        def __new__(cls, _0: BinaryPredictionFuture) -> ProductSpecs.BinaryPredictionFuture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    

@typing.final
class ProductSymbol:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, symbol: builtins.str) -> ProductSymbol:
        r"""
        Construct a product symbol from a string representation such as `"ETHP"`.
        Returns an error if the supplied string cannot be parsed.
        """
    def __deepcopy__(self, _memo: dict) -> ProductSymbol: ...
    def __repr__(self) -> builtins.str: ...
    def __len__(self) -> builtins.int: ...
    def is_perpetual(self) -> builtins.bool:
        r"""
        Return `true` when this symbol represents a perpetual contract.
        """
    def is_future(self) -> builtins.bool:
        r"""
        Return `true` when this symbol corresponds to a fixed-expiry future.
        """
    def futures_quarter(self) -> typing.Optional[Quarter]:
        r"""
        For futures symbols, return the associated `Quarter`; otherwise `None`.
        """
    def price_metadata(self) -> PriceMetadata:
        r"""
        Construct a `PriceMetadata` value appropriate for this product type.
        """

@typing.final
class ProfileUpdateIntent:
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function. May optionally have business meaning to the client.
        """
    @property
    def pay_fees_in_ddx(self) -> builtins.bool:
        r"""
        Sets the flag in the trader profile
        """
    @property
    def referral_address(self) -> typing.Optional[builtins.str]:
        r"""
        Sets a one-time referral address.
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the order intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, nonce: builtins.str, pay_fees_in_ddx: builtins.bool, referral_address: typing.Optional[builtins.str] = None, signature: typing.Optional[builtins.str] = None) -> ProfileUpdateIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """

@typing.final
class QuarterlyExpiryFuture:
    r"""
    Quarterly expiry futures are contracts that expire at a month 28-day basis.
    
    This only include attributes common to all quarterly expiry futures.
    """
    @property
    def underlying(self) -> builtins.str: ...
    @property
    def tick_size(self) -> Decimal: ...
    @property
    def max_order_notional(self) -> Decimal: ...
    @property
    def max_taker_price_deviation(self) -> Decimal: ...
    @property
    def min_order_size(self) -> Decimal: ...
    def __new__(cls, **kwds: typing.Any) -> QuarterlyExpiryFuture: ...

@typing.final
class SettlementAction:
    TradeMining: SettlementAction = ...
    r"""
    Settlement action representing the distribution of trade mining payments.
    """
    PnlRealization: SettlementAction = ...
    r"""
    Settlement action representing the realization of all unrealized P&L.
    """
    FundingDistribution: SettlementAction = ...
    r"""
    Settlement action representing the distribution of funding payments.
    """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    @classmethod
    def FuturesExpiry(cls, quarter: Quarter) -> SettlementAction:
        r"""
        Settlement action representing the expiry of a quarterly future.
        """
    def futures_quarter(self) -> typing.Optional[Quarter]:
        r"""
        For futures-expiry actions, return the quarter of the quarterly expiry future.
        """
    def __repr__(self) -> builtins.str: ...

@typing.final
class SettlementValue:
    @property
    def status(self) -> builtins.str: ...
    @property
    def value(self) -> Decimal: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...

@typing.final
class Signer:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Signer: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Signer:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    def __new__(cls, inner: builtins.str) -> Signer:
        r"""
        Construct a new `Signer` identified by `inner` release hash.
        """

@typing.final
class SignerKey:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> SignerKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> SignerKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def __new__(cls, inner: builtins.str) -> SignerKey: ...

@typing.final
class SingleNamePerpetual:
    r"""
    A set of specification about each market (aka derivative contracts)
    """
    @property
    def underlying(self) -> builtins.str: ...
    @property
    def tick_size(self) -> Decimal: ...
    @property
    def max_order_notional(self) -> Decimal: ...
    @property
    def max_taker_price_deviation(self) -> Decimal: ...
    @property
    def min_order_size(self) -> Decimal: ...
    def __new__(cls, **kwds: typing.Any) -> SingleNamePerpetual: ...

@typing.final
class Specs:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Specs: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Specs:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    def __new__(cls, inner: builtins.str) -> Specs:
        r"""
        Wrapped `SpecsExpr`.
        """
    def as_product_specs(self, specs_kind: SpecsKind) -> ProductSpecs:
        r"""
        Convert this expression into concrete `ProductSpecs` of the requested kind.
        """

@typing.final
class SpecsKey:
    r"""
    Common key for all specs kind.
    """
    @property
    def kind(self) -> SpecsKind: ...
    @property
    def name(self) -> builtins.str:
        r"""
        Defined by convention associated with the specs kind.
        At the time of writing, the naming conventions are:
        
        - `SingleNamePerpetual`: The product market symbol for the single name perpetuals in our universe (e.g. ETHP, BTCP).
        - `SpotGateway`: The host id (e.g. binance, coinbase).
        - `SpotIndex`: The symbol of the spot index (e.g. BTC, ETH).
        - `IndexFundPerpetual`: The product market symbol for the index fund perpetuals in our universe (e.g. ETHP, BTCP).
        - `QuarterlyExpiryFuture`: The product market symbol for the quarterly expiry future in our universe (e.g. ETHHF, BTCHF).
        - `BinaryPredictionFuture`: The internal symbol for each event in our universe (e.g. SB2611B, PG251B).
        - `BinaryPredictionGateway`: The hostname of the binary prediction gateway (e.g. api.elections.kalshi.com).
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, kind: SpecsKind, name: builtins.str) -> SpecsKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> SpecsKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> SpecsKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def current_tradable_products(self, current_time: datetime.datetime) -> builtins.list[TradableProductKey]:
        r"""
        List the currently tradable products that are live at `current_time`.
        """
    def has_lifecycle(self) -> typing.Optional[builtins.bool]:
        r"""
        Return whether this specs has a lifecycle constraint.
        """

@typing.final
class Stats:
    r"""
    A trader statistics value. This is used to store verified data like trade
    volume data for trade mining.
    """
    @property
    def maker_volume(self) -> Decimal:
        r"""
        The maker volume of the trader during this trade mining period
        """
    @maker_volume.setter
    def maker_volume(self, value: Decimal) -> None:
        r"""
        The maker volume of the trader during this trade mining period
        """
    @property
    def taker_volume(self) -> Decimal:
        r"""
        The taker volume of the trader during this trade mining period
        """
    @taker_volume.setter
    def taker_volume(self, value: Decimal) -> None:
        r"""
        The taker volume of the trader during this trade mining period
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, maker_volume: Decimal, taker_volume: Decimal) -> Stats: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Stats: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Stats:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> Stats:
        r"""
        Return a `Stats` structure with all counters set to zero.
        """

@typing.final
class StatsKey:
    @property
    def trader(self) -> builtins.str: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, trader: builtins.str) -> StatsKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> StatsKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> StatsKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def as_trader_key(self) -> TraderKey:
        r"""
        Convert this stats key into the corresponding `TraderKey`.
        """

@typing.final
class Strategy:
    r"""
    An trading strategy (aka sub-account, formerly known as account)
    """
    @property
    def avail_collateral(self) -> Balance:
        r"""
        Amount of the collateral per token available as margin
        """
    @property
    def locked_collateral(self) -> Balance:
        r"""
        Amount of collateral per token frozen for withdrawal
        """
    @property
    def max_leverage(self) -> builtins.int:
        r"""
        Maximum amount of leverage allowed
        """
    @max_leverage.setter
    def max_leverage(self, value: builtins.int) -> None:
        r"""
        Maximum amount of leverage allowed
        """
    @property
    def frozen(self) -> builtins.bool:
        r"""
        Whether the entire account frozen for strategy tokenization
        """
    @frozen.setter
    def frozen(self, value: builtins.bool) -> None:
        r"""
        Whether the entire account frozen for strategy tokenization
        """
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, avail_collateral: Balance, locked_collateral: Balance, max_leverage: builtins.int = 3, frozen: builtins.bool = False) -> Strategy: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Strategy: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Strategy:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> Strategy:
        r"""
        Return an empty `Strategy` with default parameters.
        """
    def set_avail_collateral(self, symbol: TokenSymbol, amount: Decimal) -> None:
        r"""
        Update this strategy's available collateral for `symbol` to `amount`.
        
        Note: This is exposed as a method (instead of relying on `#[pyo3(get, set)]`) to avoid
        mutating a cloned nested value returned from a getter.
        """
    def set_locked_collateral(self, symbol: TokenSymbol, amount: Decimal) -> None:
        r"""
        Update this strategy's locked collateral for `symbol` to `amount`.
        """
    def update_avail_collateral(self, symbol: TokenSymbol, amount: Decimal) -> Balance:
        r"""
        Return a new `Balance` obtained by updating this strategy's
        available collateral for `symbol` to `amount`.
        """
    def update_locked_collateral(self, symbol: TokenSymbol, amount: Decimal) -> Balance:
        r"""
        Return a new `Balance` obtained by updating this strategy's
        locked collateral for `symbol` to `amount`.
        """

@typing.final
class StrategyKey:
    @property
    def trader_address(self) -> builtins.str: ...
    @property
    def strategy_id_hash(self) -> builtins.str: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __new__(cls, trader_address: builtins.str, strategy_id_hash: builtins.str) -> StrategyKey: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> StrategyKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> StrategyKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    @staticmethod
    def generate_strategy_id_hash(strategy_id: builtins.str) -> builtins.str:
        r"""
        Deterministically hash `strategy_id` into a `StrategyIdHash`.
        """
    def as_position_key(self, symbol: ProductSymbol) -> PositionKey:
        r"""
        Derive the `PositionKey` for `symbol` that belongs to this strategy.
        """

@typing.final
class TradableProduct:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> TradableProduct: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> TradableProduct:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    def __new__(cls) -> TradableProduct: ...

@typing.final
class TradableProductKey:
    @property
    def specs_key(self) -> SpecsKey: ...
    @property
    def parameters(self) -> typing.Optional[TradableProductParameters]: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> TradableProductKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> TradableProductKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def as_product_symbol(self) -> ProductSymbol:
        r"""
        Convert this key into its `ProductSymbol`.
        """
    def __new__(cls, specs: SpecsKey, parameters: typing.Optional[TradableProductParameters]) -> TradableProductKey: ...

class TradableProductParameters:
    @property
    def quarter(self) -> typing.Optional[Quarter]: ...
    @classmethod
    def from_dict(cls, ob: typing.Any) -> TradableProductParameters:
        r"""
        Deserialize `TradableProductParameters` from the operator serialization.
        """
    def __repr__(self) -> builtins.str: ...
    @typing.final
    class Empty(TradableProductParameters):
        __match_args__ = ()
        def __new__(cls) -> TradableProductParameters.Empty: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class QuarterlyExpiryFuture(TradableProductParameters):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> Quarter: ...
        def __new__(cls, _0: Quarter) -> TradableProductParameters.QuarterlyExpiryFuture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class BinaryPredictionFuture(TradableProductParameters):
        r"""
        The nonzero index number of the binary prediction future (e.g. 1, 2, ..., 9 for SB26{1:10}B).
        """
        __match_args__ = ("_0",)
        @property
        def _0(self) -> builtins.int: ...
        def __new__(cls, _0: builtins.int) -> TradableProductParameters.BinaryPredictionFuture: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    

@typing.final
class Trader:
    r"""
    An individual trader
    """
    @property
    def avail_ddx_balance(self) -> Decimal:
        r"""
        The DDX balance stated / usable for trading
        """
    @avail_ddx_balance.setter
    def avail_ddx_balance(self, value: Decimal) -> None:
        r"""
        The DDX balance stated / usable for trading
        """
    @property
    def locked_ddx_balance(self) -> Decimal:
        r"""
        The DDX balance locked for withdrawal
        """
    @locked_ddx_balance.setter
    def locked_ddx_balance(self, value: Decimal) -> None:
        r"""
        The DDX balance locked for withdrawal
        """
    @property
    def pay_fees_in_ddx(self) -> builtins.bool:
        r"""
        Switch to paying fees with DDX
        """
    @pay_fees_in_ddx.setter
    def pay_fees_in_ddx(self, value: builtins.bool) -> None:
        r"""
        Switch to paying fees with DDX
        """
    @property
    def access_denied(self) -> builtins.bool:
        r"""
        Whether the trader is denied access to the platform
        """
    @access_denied.setter
    def access_denied(self, value: builtins.bool) -> None:
        r"""
        Whether the trader is denied access to the platform
        """
    @property
    def referral_address(self) -> typing.Optional[builtins.str]: ...
    @referral_address.setter
    def referral_address(self, value: typing.Optional[builtins.str]) -> None: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> Trader: ...
    def as_item(self) -> Item:
        r"""
        Wrap this concrete structure into the generic [`Item`] enum.
        """
    @classmethod
    def from_item(cls, item: Item) -> Trader:
        r"""
        Down-cast a generic [`Item`] into this concrete type.
        """
    def abi_encoded_value(self) -> builtins.bytes:
        r"""
        ABI-encode this value.
        """
    @classmethod
    def abi_decode_value_into_item(cls, abi_encoded_value: builtins.bytes) -> typing.Optional[Item]:
        r"""
        Decode bytes back into an [`Item`] of this concrete type.
        """
    def is_void(self) -> builtins.bool:
        r"""
        `true` when this value represents the special *void* marker
        used to delete a leaf from the SMT.
        """
    @classmethod
    def default(cls) -> Trader:
        r"""
        Return a zero-initialized `Trader` value.
        """
    def __new__(cls, avail_ddx_balance: Decimal, locked_ddx_balance: Decimal, pay_fees_in_ddx: builtins.bool) -> Trader: ...

@typing.final
class TraderKey:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def __deepcopy__(self, _memo: dict) -> TraderKey: ...
    def encode_key(self) -> H256:
        r"""
        Encode this state-key into the 32-byte format used on-chain.
        """
    @classmethod
    def decode_key(cls, value: H256) -> TraderKey:
        r"""
        Decode a previously-encoded key back into its strongly-typed form.
        """
    def __new__(cls, inner: builtins.str) -> TraderKey: ...

@typing.final
class UpdateProductListings:
    r"""
    A signal to update product listings is sent by the operator clock tick mechanism based on the
    current wall clock time. It is used to add or remove products from the exchange's product
    listings.
    
    Motivating example: there are different futures products all corresponding to the same futures
    specs class, but each future is listed/available to trade at different times. For example, ETH{}F
    is a specs class representing futures tracking the price of ETH. ETHHF is a specific tradable
    product referring to the ETH future expiring in March that is listed at the time of writing one
    week before the expiry of the preceding September future until its expiry in March. The operator
    will update the listings to add ETHHF and remove ETHHF at the appropriate times.
    """
    @property
    def additions(self) -> builtins.list[TradableProductKey]: ...
    @property
    def removals(self) -> builtins.list[TradableProductKey]: ...
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, additions: typing.Sequence[TradableProductKey], removals: typing.Sequence[TradableProductKey]) -> UpdateProductListings: ...
    def __repr__(self) -> builtins.str: ...

@typing.final
class WithdrawDDXIntent:
    r"""
    Traders signal their intent to withdraw ddx which freezes the specified amount
    in their account.
    
    Funds may be available on-chain at the next checkpoint the operator is kind enough to
    "prove" the withdrawals on behalf of traders.
    
    Otherwise, traders may submit a merkle proof at any time after a `Checkpoint` to collect
    their funds.
    """
    @property
    def amount(self) -> Decimal:
        r"""
        Amount to withdraw
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function. May optionally have
        business meaning to the client.
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the withdraw ddx intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the withdraw ddx intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, amount: Decimal, nonce: builtins.str, signature: typing.Optional[builtins.str] = None) -> WithdrawDDXIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """

@typing.final
class WithdrawIntent:
    r"""
    Traders signal their intent to withdraw which freezes the requested collateral in their account.
    
    Funds may be available on-chain at the next checkpoint the operator is kind enough to "prove"
    the withdrawals on behalf of traders. Otherwise, traders may submit a merkle proof
    at any time after a `Checkpoint` to collect their funds.
    """
    @property
    def strategy_id(self) -> builtins.str:
        r"""
        Strategy Id (label)
        """
    @property
    def currency(self) -> builtins.str:
        r"""
        Ethereum address of the collateral token (ERC-20)
        """
    @property
    def amount(self) -> Decimal:
        r"""
        Amount to withdraw
        """
    @property
    def nonce(self) -> builtins.str:
        r"""
        A salt for uniqueness of the EIP-712 hash function. May optionally have business meaning to the client.
        """
    @property
    def signature(self) -> builtins.str:
        r"""
        EIP-712 signature of the withdraw intent attributes
        """
    @signature.setter
    def signature(self, value: builtins.str) -> None:
        r"""
        EIP-712 signature of the withdraw intent attributes
        """
    @property
    def json(self) -> typing.Any: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __new__(cls, strategy_id: builtins.str, currency: builtins.str, amount: Decimal, nonce: builtins.str, signature: typing.Optional[builtins.str] = None) -> WithdrawIntent: ...
    def __repr__(self) -> builtins.str: ...
    def hash_eip712(self, message_metadata: typing.Optional[tuple[builtins.int, builtins.str]] = None) -> builtins.str:
        r"""
        Compute the EIP-712 digest for this intent.
        Passing `message_metadata=(chain_id, verifying_contract)`
        overrides the default values used in the hash.
        """
    def recover_signer(self) -> tuple[builtins.str, builtins.str]:
        r"""
        Recover the `(eip712_hash, trader_address)` that signed
        this intent.
        """

@typing.final
class InsuranceFundUpdateKind(enum.Enum):
    Unassigned = ...
    Deposit = ...
    Withdraw = ...

    def __new__(cls, name: builtins.str) -> InsuranceFundUpdateKind:
        r"""
        Parse an `InsuranceFundUpdateKind` from its string discriminant.
        """

@typing.final
class ItemKind(enum.Enum):
    Empty = ...
    Trader = ...
    Strategy = ...
    Position = ...
    BookOrder = ...
    Price = ...
    InsuranceFund = ...
    Stats = ...
    Signer = ...
    Specs = ...
    TradableProduct = ...
    InsuranceFundContribution = ...
    EpochMetadata = ...

    discriminants: dict
    r"""
    Return a Python `dict` that maps variant names to their discriminant values.
    """
    def __new__(cls, value: builtins.int) -> ItemKind:
        r"""
        Create an `ItemKind` from its numeric discriminant (`u8`).  
        Returns `PyValueError` if the value does not correspond to a variant.
        """

@typing.final
class OrderSide(enum.Enum):
    r"""
    0 - Long, 1 - Short
    """
    Bid = ...
    Ask = ...

    def __new__(cls, name: builtins.str) -> OrderSide:
        r"""
        Parse an `OrderSide` (`"Bid"` or `"Ask"`) from its string `name`.
        """

@typing.final
class PositionSide(enum.Enum):
    Empty = ...
    Long = ...
    Short = ...

@typing.final
class PriceDirection(enum.Enum):
    r"""
    Direction of the price movement compared to the last price update executed.
    """
    Up = ...
    Down = ...
    Flat = ...
    Unknown = ...
    r"""
    Not enough context to determine the direction
    """

@typing.final
class Quarter(enum.Enum):
    March = ...
    June = ...
    September = ...
    December = ...

    def __repr__(self) -> builtins.str: ...
    def __new__(cls, name: builtins.str) -> Quarter:
        r"""
        Parse a calendar quarter ("March", "June", â€¦) from `name`.
        """
    @classmethod
    def find_quarter(cls, datetime: datetime.datetime) -> Quarter:
        r"""
        Determine the quarter in which `datetime` lies.
        """
    def expiry_date_after(self, datetime: datetime.datetime) -> datetime.datetime:
        r"""
        First expiry date for this quarter strictly after `datetime`.
        """
    @classmethod
    def upcoming_expiry_date(cls, current_time: datetime.datetime) -> datetime.datetime:
        r"""
        Next quarterly-futures expiry date from `current_time`.
        """
    def next(self) -> Quarter:
        r"""
        Return the quarter immediately following this one.
        """

@typing.final
class SafetyFailure(enum.Enum):
    r"""
    Auto-generated discriminant enum variants
    """
    TraderNotFound = ...
    NotEnoughCollateral = ...
    NoStrategies = ...
    StrategyNotFound = ...
    SignatureRecoveryMismatch = ...
    InsuranceFundContributionNotFound = ...
    MaxOrderNotionalBreached = ...
    MaxTakerPriceDeviationBreached = ...
    OrderNotFound = ...
    OMFLessThanIMF = ...
    MaxWithdrawAmountBreached = ...
    MaxDDXWithdrawAmountBreached = ...
    TooMuchCollateralToWithdrawDDX = ...
    MaxInsuranceFundWithdrawBreached = ...
    OrderPriceNeg = ...
    OrderAmountZeroNeg = ...
    OrderAmountNotMultipleOfMinOrderSize = ...
    OrderTypeIncompatibleWithPrice = ...
    PriceNotMultipleOfTickSize = ...
    UnsupportedMarket = ...
    UnsupportedCurrency = ...
    TooManyOrders = ...
    WithdrawAmountZeroNeg = ...
    WithdrawDDXAmountZeroNeg = ...
    WithdrawInsuranceFundZeroNeg = ...
    AccessDenied = ...
    CancelNoLiquidityForMarket = ...
    UnsupportedTraderUpdate = ...
    MarketPriceNotAvailable = ...

    def __new__(cls, name: builtins.str) -> SafetyFailure: ...

@typing.final
class SpecsKind(enum.Enum):
    SingleNamePerpetual = ...
    SpotGateway = ...
    SpotIndex = ...
    IndexFundPerpetual = ...
    QuarterlyExpiryFuture = ...
    BinaryPredictionFuture = ...
    BinaryIndex = ...
    BinaryPredictionGateway = ...

    def __new__(cls, kind: builtins.str) -> SpecsKind:
        r"""
        Parse a `SpecsKind` from its string representation.
        """

@typing.final
class StrategyUpdateKind(enum.Enum):
    r"""
    Differentiates various types of strategy updates.
    
    Enumerates different scenarios like deposits, withdrawals, and other events
    that impact a trader's strategy, enabling appropriate response and adjustment in the strategy.
    """
    Unassigned = ...
    r"""
    Used as placeholder in default events.
    """
    Deposit = ...
    r"""
    Reacts to contract deposit event.
    """
    Withdraw = ...
    r"""
    Reacts to contract withdraw event, decreasing the (claimed) locked collateral.
    """
    WithdrawIntent = ...
    r"""
    A client request to withdraw funds, which moves funds from available collateral to locked collateral.
    """
    FundingPayment = ...
    RealizedPnl = ...

    def __new__(cls, name: builtins.str) -> StrategyUpdateKind:
        r"""
        Parse a `StrategyUpdateKind` from its string discriminant.
        """

@typing.final
class TokenSymbol(enum.Enum):
    r"""
    Well-known ERC20 tokens used in the underpinning of the protocol
    """
    USDC = ...
    DDX = ...

    @classmethod
    def from_address(cls, address: builtins.str) -> TokenSymbol:
        r"""
        Construct a `TokenSymbol` from the on-chain token `address`.
        """
    def address(self) -> builtins.str:
        r"""
        Return the canonical on-chain address for this token.
        """

@typing.final
class TradeSide(enum.Enum):
    Maker = ...
    Taker = ...

    def trading_fee(self, amount: Decimal, price: Decimal) -> Decimal:
        r"""
        Compute the trading fee for the given `amount` at `price` on this side.
        """

@typing.final
class TraderUpdateKind(enum.Enum):
    r"""
    Differentiates various types of trader updates.
    """
    Unassigned = ...
    r"""
    Used as placeholder in default events.
    """
    DepositDDX = ...
    r"""
    Reacts to contract DDX deposit event.
    """
    WithdrawDDX = ...
    r"""
    Reacts to contract DDX withdraw event, decreasing the (claimed) locked collateral.
    """
    WithdrawDDXIntent = ...
    TradeMiningReward = ...
    Profile = ...
    r"""
    Trader profile parameter updates sent via a client intention.
    """
    FeeDistribution = ...
    r"""
    Fee distribution event.
    """
    Denial = ...
    r"""
    Denial of access to the platform due to KYC blacklist, expiration, or other reasons.
    """
    Admission = ...
    r"""
    Admission to the platform due to KYC re-approval, unbanned, or other reasons.
    """

    def __new__(cls, name: builtins.str) -> TraderUpdateKind:
        r"""
        Parse a `TraderUpdateKind` from its string discriminant.
        """

def get_operator_context() -> OperatorContext:
    r"""
    Get the operator application context for this DerivaDEX instance.
    """

def reinit_operator_context() -> None:
    r"""
    Reinitialize the operator application context for this DerivaDEX instance.
    """

