#  Copyright (C) 2025-2026, HYLi360.
#  Free software distributed under the terms of the GNU GPL-3.0 license,
#  and comes with ABSOLUTELY NO WARRANTY.
#  See at <https://www.gnu.org/licenses/gpl-3.0.en.html>


from Bio import SeqIO
import subprocess
from pathlib import Path

from Bio.SeqRecord import SeqRecord

from ezwgd import console


def gffread_cds_pep_extract(
        gff3_file_path: str,
        fna_file_path: str,
        cmd_or_abs_gffread_path: str = 'gffread',
        workdir: str = '.',
        keep_fai: bool = False,
) -> tuple[dict[str, SeqRecord], dict[str, SeqRecord]]:
    """
    Call `gffread` to extract cds/protein sequence file, by running\n
    `abs_gffread_path gff3_file_path -g fna_file_path -x cds_out`\n
    and\n
    `abs_gffread_path gff3_file_path -g fna_file_path -y prot_out`.
    Args:
        gff3_file_path: GFF3 file path.
        fna_file_path: FASTA file path.
        cmd_or_abs_gffread_path: The command (or execuable file path) to call `gffread`.
        workdir: Which directory the `gffread` will run.
        keep_fai: Keep or delete the fasta index file generated by `gffread` (delete by default).
    """
    gff3_file_path = Path(gff3_file_path).resolve()
    fna_file_path = Path(fna_file_path).resolve()
    workdir = Path(workdir).resolve()

    out_cds_path = (workdir / 'cds.fna').resolve()
    out_pep_path = (workdir / 'pep.faa').resolve()

    cmd_cds = [cmd_or_abs_gffread_path, str(gff3_file_path), '-g', str(fna_file_path), '-x', str(out_cds_path)]
    cmd_pep = [cmd_or_abs_gffread_path, str(gff3_file_path), '-g', str(fna_file_path), '-y', str(out_pep_path)]

    # Extract CDS and PEP sequences
    try:
        subprocess.run(cmd_cds, check=True, capture_output=True, text=True, cwd=str(workdir))
        subprocess.run(cmd_pep, check=True, capture_output=True, text=True, cwd=str(workdir))
    except subprocess.CalledProcessError as e:
        # Give user the actual error message rather than silently failing
        raise RuntimeError(
            'gffread failed.\n'
            f'Command: {" ".join(e.cmd)}\n'
            f'Return code: {e.returncode}\n'
            f'STDERR:\n{e.stderr}\n'
        ) from e

    console.log(f'Outputs of gffread are saved in {workdir}.')

    # Delete .fai file (if you need)
    if not keep_fai:
        fai_path = Path(str(fna_file_path) + '.fai')
        try:
            if fai_path.exists():
                fai_path.unlink()
        except Exception:
            # Don't let cleanup break the whole function
            pass

    return ({cds.id: cds for cds in SeqIO.parse(str(out_cds_path), 'fasta')},
            {pep.id: pep for pep in SeqIO.parse(str(out_pep_path), 'fasta')},)


def muscle5(
        pep_file_path: str,
        workdir: str,
        muscle5_cmd: str = 'muscle'
) -> dict[str, SeqRecord]:
    subprocess.run(
        ['muscle', '-align', pep_file_path, '-output', 'pep.aln'],
        check=True, capture_output=True, text=True, cwd=workdir,
    )
    return {record.id: record for record in SeqIO.parse(f'{workdir}/pep.aln', 'fasta')}


def mafft(
        workdir: str,
        pep_file_name: str,
        res_file_name: str
) -> None:
    with open(f'{workdir}/{res_file_name}', 'w') as outfile:
        subprocess.run(
            ['mafft', '--auto', pep_file_name],
            stdout=outfile,
            stderr=subprocess.PIPE,
            text=True,
            cwd=workdir,
        )
