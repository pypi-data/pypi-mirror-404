# Copyright (C) 2023,2024,2025,2026 Kian-Meng Ang
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""Main logic to generate heatmap."""

import argparse
import copy
import io
import multiprocessing
import re
import shutil
import webbrowser
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any

import matplotlib as mpl
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
from PIL import Image

# Generate matplotlib graphs without an X server.
# See http://stackoverflow.com/a/4935945
mpl.use("agg")

# Define constants for figure and image settings
DEFAULT_FIGURE_SIZE = (8, 5)
DEFAULT_DPI = 76

# Define constants for GIF animation settings
GIF_DURATION_MS = 1000
GIF_LOOP_COUNT = 0

# Define constants for font sizes
DEFAULT_TICK_LABEL_FONTSIZE = 9
ANNOTATION_FONTSIZE = 8
TITLE_FONTSIZE = 11

# Define constants for colorbar settings
COLORBAR_PAD = 0.10
COLORBAR_ASPECT = 60

# Define constant for filename sanitization
MAX_FILENAME_LENGTH = 100

# Define constants for default title strings
DEFAULT_TITLE_PREFIX = "Year {config.year}: Total Daily Walking Steps"
DEFAULT_TITLE_WEEK_SUFFIX = " Through Week {config.week:02d}"

# Define constants for colorbar labels
COLORBAR_BASE_LABEL = (
    "Generated by: pypi.org/project/heatmap_cli, colormap: {cmap}"
)
COLORBAR_ANNOTATION_SUFFIX = ", count: nearest hundred"

# Define constants for count truncation
TRUNCATE_DIVISOR = 100
TRUNCATE_ROUND_DECIMALS = -2

# Define constants for week ranges
ALL_WEEKS_RANGE = range(1, 54)
ALL_WEEKDAYS_RANGE = range(1, 8)

logger = multiprocessing.get_logger()


def run(config: argparse.Namespace) -> None:
    """Run the main flow.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        None
    """
    logger.debug(config)
    logger.debug("number of cpu: %d", multiprocessing.cpu_count())

    _refresh_output_dir(config)

    base_dataframe = _read_and_prepare_data(config)

    for year in config.year:
        # Clone config and set the year for the current iteration
        config_for_year = copy.copy(config)
        config_for_year.year = year

        if config_for_year.animate_by_week:
            _generate_animated_heatmap(base_dataframe, config_for_year)
        else:
            pivoted_dataframe = _filter_and_pivot_data(
                base_dataframe,
                config_for_year,
            )
            _generate_static_heatmaps(pivoted_dataframe, config_for_year)


def _generate_animated_heatmap(
    base_dataframe: pd.DataFrame,
    config: argparse.Namespace,
) -> None:
    """Generate animated heatmap by week.

    This function optimizes the animation generation by pivoting the data only
    once for the entire target week. It then progressively builds each frame by
    adding one day's data at a time, avoiding costly re-computation in a loop.

    Args:
        base_dataframe (pd.DataFrame): The base dataframe with all data.
        config (argparse.Namespace): Config from command line arguments.
    """
    # pivot the data once for the entire week to get the final state
    final_pivoted_df = _filter_and_pivot_data(base_dataframe, config)
    print(final_pivoted_df)

    # get the range dates of the week
    # for example year=2026 and week=1
    # result will be [2025-12-29, 2025-12-30, ..., 2026-01-04]
    start_of_week = datetime.strptime(
        f"{config.year}-W{config.week}-1",
        "%G-W%V-%u",
    ).date()
    dates_in_week = [start_of_week + timedelta(days=i) for i in range(7)]

    config_pre_week = copy.copy(config)

    # get the data for all weeks before the animated current week to use as a
    # base
    if config.week >= 2:
        pre_week_end_date = start_of_week - timedelta(days=1)
        config_pre_week.end_date = pre_week_end_date.strftime("%Y-%m-%d")
        frame_pivoted_df = _filter_and_pivot_data(
            base_dataframe, config_pre_week
        )
    else:
        # for the first week, the end date is the first monday of week 1 of the
        # current year
        config_pre_week.end_date = pd.Timestamp(start_of_week)
        frame_pivoted_df = _filter_and_pivot_data(
            base_dataframe, config_pre_week
        )

    frames = []
    for seq, day in enumerate(dates_in_week, 1):
        # get week and weekday, matching the dataframe's index/columns format
        iso_week = str(day.isocalendar().week).zfill(2)
        iso_weekday = day.isocalendar().weekday

        # add the current day's data to the frame's dataframe
        if (
            iso_week in frame_pivoted_df.columns
            and iso_weekday in frame_pivoted_df.index
        ):
            count = final_pivoted_df.loc[iso_weekday, iso_week]
            frame_pivoted_df.loc[iso_weekday, iso_week] = count

        # generate the heatmap image for the current state
        config_for_heatmap = copy.copy(config)
        config_for_heatmap.end_date = day.strftime("%Y-%m-%d")
        config_for_heatmap.open = False

        frame = _generate_heatmap(
            seq,
            config.cmap[0],
            config_for_heatmap,
            frame_pivoted_df.copy(),  # pass a copy to avoid side effects
            return_image=True,
        )
        if frame:
            frames.append(frame)

    if not frames:
        logger.warning("no frames generated to create GIF animation.")
        return

    config.format = "gif"
    title = _generate_title(config)
    output_dir = _get_output_dir(config)
    img_filename = output_dir / _generate_filename(
        config,
        0,
        config.cmap[0],
        title,
    )
    img_filename.parent.mkdir(parents=True, exist_ok=True)

    frames[0].save(
        img_filename,
        save_all=True,
        append_images=frames[1:],
        optimize=True,
        duration=GIF_DURATION_MS,
        loop=GIF_LOOP_COUNT,
    )
    logger.info("generate animated heatmap: %s", img_filename)

    if config.open:
        _open_heatmap(img_filename)


def _generate_static_heatmaps(
    pivoted_dataframe: pd.DataFrame,
    config: argparse.Namespace,
) -> None:
    """Generate regular heatmaps.

    Args:
        pivoted_dataframe (pd.DataFrame): A fully processed and pivoted
            DataFrame.
        config (argparse.Namespace): Config from command line arguments.
    """
    args = [
        (*seq_cmap, config, pivoted_dataframe, False)
        for seq_cmap in enumerate(config.cmap, 1)
    ]
    logger.debug(args)

    # Fork, instead of spawn process (child) inherit parent logger config.
    # See https://stackoverflow.com/q/14643568
    with multiprocessing.get_context("fork").Pool() as pool:
        pool.starmap(_generate_heatmap, args)


def _read_and_prepare_data(config: argparse.Namespace) -> pd.DataFrame:
    """Reads and performs initial preparation of the data from the CSV file.

    This includes reading the file, converting date columns, checking for
    duplicates, and adding necessary calendar-related columns.

    Args:
        config (argparse.Namespace): Configuration from command line arguments.

    Returns:
        pd.DataFrame: A DataFrame with initial preparations applied.

    Raises:
        FileNotFoundError: If the input CSV file does not exist.
        ValueError: If duplicate dates are found in the input file.
    """
    try:
        dataframe = pd.read_csv(
            config.input_filename,
            header=None,
            names=["date", "count"],
        )
    except FileNotFoundError as e:
        logger.error("Input file not found: %s", config.input_filename)
        raise e

    dataframe["date"] = pd.to_datetime(dataframe["date"])

    duplicate_dates = dataframe[dataframe["date"].duplicated(keep=False)]
    if not duplicate_dates.empty:
        dup_dates_str = ", ".join(
            duplicate_dates["date"].dt.date.astype(str).unique(),
        )
        msg = f"Duplicate dates found: {dup_dates_str}"
        raise ValueError(msg)

    dataframe["weekday"] = dataframe["date"].dt.weekday + 1
    dataframe["year"] = dataframe["date"].dt.isocalendar().year
    dataframe["week"] = (
        dataframe["date"].dt.isocalendar().week.astype(str).str.zfill(2)
    )
    if config.annotate:
        dataframe["count"] = dataframe["count"].apply(_truncate_rounded_count)

    return dataframe


def _filter_and_pivot_data(
    dataframe: pd.DataFrame,
    config: argparse.Namespace,
) -> pd.DataFrame:
    """Filters, structures, and pivots the prepared data for the heatmap.

    This function takes a prepared DataFrame, filters it based on the year and
    week/end date, merges it with a full-year structure to handle missing days,
    and pivots it into the final format for plotting.

    Args:
        dataframe (pd.DataFrame): The initially prepared DataFrame.
        config (argparse.Namespace): Configuration from command line arguments.

    Returns:
        pd.DataFrame: A pivoted DataFrame ready for heatmap plotting.

    Raises:
        ValueError: If no data is extracted for the specified period.
    """
    date_filter = dataframe["year"] == config.year
    date_filter &= dataframe["week"] <= str(config.week).zfill(2)

    if config.start_date:
        date_filter &= dataframe["date"] >= config.start_date

    if config.end_date:
        date_filter &= dataframe["date"] <= config.end_date

    steps = dataframe.loc[date_filter].copy()

    if steps.empty:
        msg = "No data extracted from CSV file for the specified period!"
        raise ValueError(msg)

    logger.debug("Last date in filtered data: %s", max(steps["date"]).date())

    # the start date of the year may span across two years
    # for example, the first monday of 2026 week 1 is 2025-12-29
    start_date = datetime.strptime(
        f"{config.year}-W1-1",
        "%G-W%V-%u",
    ).date()
    end_date = pd.to_datetime(f"{config.year}-12-31")
    logger.debug("start date:: %s", start_date)
    logger.debug("end date:: %s", end_date)
    full_year_dates = pd.date_range(start=start_date, end=end_date, freq="D")
    full_year_structure = pd.DataFrame({"date": full_year_dates})
    full_year_structure["weekday"] = full_year_structure["date"].dt.weekday + 1
    full_year_structure["week"] = (
        full_year_structure["date"]
        .dt.isocalendar()
        .week.astype(str)
        .str.zfill(2)
    )

    steps_to_merge = steps[["date", "count"]]
    merged_data = full_year_structure.merge(
        steps_to_merge,
        on="date",
        how="left",
    )

    merged_data["count"] = merged_data["count"].fillna(0).astype(int)

    year_dataframe = merged_data.pivot_table(
        values="count",
        index=["weekday"],
        columns=["week"],
        fill_value=0,
    )

    all_weeks = [str(w).zfill(2) for w in ALL_WEEKS_RANGE]
    year_dataframe = year_dataframe.reindex(columns=all_weeks, fill_value=0)
    return year_dataframe.reindex(
        index=ALL_WEEKDAYS_RANGE,
        fill_value=0,
    )


def _truncate_rounded_count(count: float) -> int:
    """Truncate and round count values to fit them in heatmap box.

    Rounds the count to the nearest hundred and then divides by 100.
    This transformation is applied when annotations are enabled to simplify
    large numbers and make them fit visually within the heatmap cells.
    For example, 12345 becomes 123, 5678 becomes 57.

    Args:
        count (int/float): The original count value.

    Returns:
        int: Truncated count value (divided by 100).
    """
    return int(round(count, TRUNCATE_ROUND_DECIMALS) / TRUNCATE_DIVISOR)


def _setup_plot_artists(
    cmap: str,
    config: argparse.Namespace,
    dataframe: pd.DataFrame,
) -> plt.Axes:
    """Setup figure, axes, plot heatmap, and apply core styling.

    (annotations/cbar).

    Args:
        cmap (str): Colormap name used for the heatmap.
        config (argparse.Namespace): Config from command line arguments.
        dataframe (pd.core.frame.DataFrame): DataFrame with data.

    Returns:
        plt.Axes: The Axes object with the heatmap plotted.
    """
    _, axis = plt.subplots(figsize=DEFAULT_FIGURE_SIZE)
    axis.tick_params(
        axis="both",
        which="major",
        labelsize=DEFAULT_TICK_LABEL_FONTSIZE,
    )
    axis.tick_params(
        axis="both",
        which="minor",
        labelsize=DEFAULT_TICK_LABEL_FONTSIZE,
    )

    options, _ = _configure_heatmap_options(config, cmap, axis)
    res = sns.heatmap(dataframe, **options)

    if config.annotate:
        _apply_annotations(res)

    if config.cbar:
        _configure_cbar(res)

    return axis


def _generate_heatmap(
    seq: int,
    cmap: str,
    config: argparse.Namespace,
    dataframe: pd.DataFrame,
    return_image: bool = False,
) -> Image.Image | None:
    """Generate a heatmap.

    Args:
        seq (int): Sequence number for generated heatmap image file.
        cmap (str): Colormap name used for the heatmap.
        config (argparse.Namespace): Config from command line arguments.
        dataframe (pd.core.frame.DataFrame): DataFrame with data loaded from
        CSV file.
        return_image (bool): If True, returns a PIL Image object instead of
        saving to disk.

    Returns:
        Optional[Image.Image]: The PIL Image object if return_image is True,
        otherwise None.
    """
    axis = _setup_plot_artists(cmap, config, dataframe)

    title = _generate_title(config)
    _set_plot_titles(axis, config, title)

    result = _save_heatmap_figure(config, seq, cmap, title, return_image)

    if return_image:
        return result

    img_filename = result
    logger.info("generate heatmap: %s", img_filename)

    if config.open:
        _open_heatmap(img_filename)

    return None


def _configure_heatmap_options(
    config: argparse.Namespace,
    cmap: str,
    axis: plt.Axes,
) -> tuple[dict[str, Any], dict[str, Any]]:
    """Configure options for the heatmap plot.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        cmap (str): Colormap name for the heatmap.
        axis (plt.Axes): Matplotlib axes object.

    Returns:
        tuple[dict, dict]: A tuple containing heatmap options and colorbar
            options.
    """
    cbar_options = {
        "orientation": "horizontal",
        "label": COLORBAR_BASE_LABEL.format(cmap=cmap),
        "pad": COLORBAR_PAD,
        "aspect": COLORBAR_ASPECT,
        "extend": "max",
    }
    options = {
        "ax": axis,
        "fmt": "",
        "square": True,
        "cmap": cmap,
        "cbar": config.cbar,
        "cbar_kws": cbar_options,
    }

    if config.cmap_min:
        options["vmin"] = config.cmap_min
    if config.cmap_max:
        options["vmax"] = config.cmap_max

    if config.annotate:
        cbar_options["label"] = (
            f"{cbar_options['label']}{COLORBAR_ANNOTATION_SUFFIX}"
        )
        options.update(
            {
                "annot": True,
                "annot_kws": {"fontsize": ANNOTATION_FONTSIZE},
                "linewidth": 0,
            },
        )
    return options, cbar_options


def _apply_annotations(res: plt.Axes) -> None:
    """Apply custom annotations to the heatmap cells.

    Args:
        res (plt.Axes): The matplotlib axes object returned by seaborn.
    """
    for text in res.texts:
        count = int(float(text.get_text()))
        if count >= 100:
            text.set_text(">" + str(count)[0])
        else:
            text.set_text(str(count))


def _configure_cbar(res: plt.Axes) -> None:
    """Configure the colorbar of the heatmap.

    Args:
        res (plt.Axes): The matplotlib axes object returned by seaborn.
    """
    cbar = res.collections[0].colorbar
    cbar.set_label(cbar.ax.get_xlabel(), rotation=0, labelpad=8, loc="left")


def _set_plot_titles(
    axis: plt.Axes,
    config: argparse.Namespace,
    title: str,
) -> None:
    """Set the titles for the heatmap plot.

    Args:
        axis (plt.Axes): Matplotlib axes object.
        config (argparse.Namespace): Config from command line arguments.
        title (str): The main title of the plot.
    """
    axis.set_title(title, fontsize=TITLE_FONTSIZE, loc="left")
    axis.set_title(config.author, fontsize=TITLE_FONTSIZE, loc="right")


def _save_heatmap_figure(
    config: argparse.Namespace,
    seq: int,
    cmap: str,
    title: str,
    return_image: bool = False,
) -> Path | Image.Image:
    """Save the heatmap figure to a file or return it as a PIL Image object.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        seq (int): Sequence number for the output file.
        cmap (str): Colormap name used for the heatmap.
        title (str): The title of the heatmap.
        return_image (bool): If True, returns a PIL Image object instead of
        saving to disk.

    Returns:
        Path: The path to the saved image file if not returning image.
        Image.Image: The PIL Image object if return_image is True.
    """
    plt.tight_layout()

    if return_image:
        buffer = io.BytesIO()
        plt.savefig(
            buffer,
            bbox_inches="tight",
            transparent=False,
            dpi=DEFAULT_DPI,
            format="png",
        )
        plt.close()
        buffer.seek(0)
        return Image.open(buffer).copy()

    output_dir = _get_output_dir(config)
    img_filename = output_dir / _generate_filename(config, seq, cmap, title)
    img_filename.parent.mkdir(parents=True, exist_ok=True)

    plt.savefig(
        img_filename,
        bbox_inches="tight",
        transparent=False,
        dpi=DEFAULT_DPI,
        format=config.format,
    )
    plt.close()
    return img_filename


def _open_heatmap(filename: Path) -> None:
    """Open generated heatmap using the default program.

    Args:
        filename (str): The filename of the heatmap to open.

    Returns:
        None
    """
    file_uri = f"file://{filename.resolve()}"
    webbrowser.open(file_uri)
    logger.info("Open heatmap: %s using default program.", filename.resolve())


def _sanitize_string_for_filename(s: str) -> str:
    """Sanitize a string to be suitable for use in a filename.

    Replaces spaces with underscores, removes non-alphanumeric characters
    (except underscore, dot, and hyphen), and limits length.

    Args:
        s (str): The input string to sanitize.

    Returns:
        str: The sanitized string.
    """
    s = s.strip().lower()
    s = re.sub(r"\s+", "_", s)  # Replace spaces with single underscore
    # Remove characters not alphanumeric, underscore, dot, or hyphen
    s = re.sub(r"[^\w._-]+", "", s)
    # Limit length to prevent overly long filenames
    return s[:MAX_FILENAME_LENGTH]


def _generate_filename(
    config: argparse.Namespace,
    seq: int,
    cmap: str,
    title_str: str,
) -> str:
    """Generate an image filename based on the title.

    Args:
        config (argparse.Namespace): Config from command line arguments.
        seq (int): Sequence number for generated heatmap image file.
        cmap (str): Colormap name used for the heatmap.
        title_str (str): The title of the heatmap.

    Returns:
        str: A generated file name for the image.
    """
    annotated_suffix = "_annotated" if config.annotate else ""
    animated_suffix = "_animated" if config.format == "gif" else ""

    sanitized_title_part = _sanitize_string_for_filename(title_str)

    return (
        f"{seq:03d}_{sanitized_title_part}_"
        f"{cmap}{annotated_suffix}{animated_suffix}"
        f".{config.format}"
    )


def _generate_title(config: argparse.Namespace) -> str:
    """Generate a title for the heatmap.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        str: A generated title for the heatmap.
    """
    if not config.title:
        if config.start_date and config.end_date:
            title = (
                f"Year {config.year}: Total Daily Walking Steps From "
                f"{config.start_date} to {config.end_date}"
            )
        else:
            title = DEFAULT_TITLE_PREFIX.format(config=config)
            # If config.week is less than 52, it means a partial year is
            # requested.  config.week >= 52 implies the whole year data is used
            # (as per _massage_data logic).
            if config.week < 52:
                title += DEFAULT_TITLE_WEEK_SUFFIX.format(config=config)
    else:
        title = config.title

    logger.debug(title)
    return title


def _refresh_output_dir(config: argparse.Namespace) -> None:
    """Delete and recreate the output folder.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        None
    """
    output_dir = _get_output_dir(config)

    # Determine if purging is required based on --purge and --yes flags.
    should_purge = False
    if config.purge:
        if config.yes:
            should_purge = True
        else:
            prompt = (
                f"Are you sure to purge output folder: {output_dir}? [y/N] "
            )
            if input(prompt).lower() in ["y", "yes"]:
                should_purge = True

    # If purging is required and the directory exists, remove it.
    if should_purge and output_dir.exists():
        logger.info("Purging output folder: %s", output_dir.absolute())
        try:
            shutil.rmtree(output_dir)
        except OSError as e:
            logger.error("Error removing directory: %s - %s.", output_dir, e)
            # Depending on desired error handling, you might want to raise an
            # exception here.
            return

    # Ensure the output directory exists for writing files.
    # This will create it if it doesn't exist or was just purged.
    logger.info("Ensuring output folder exists: %s", output_dir.absolute())
    output_dir.mkdir(parents=True, exist_ok=True)


def _get_output_dir(config: argparse.Namespace) -> Path:
    """Get the current working directory.

    Args:
        config (argparse.Namespace): Config from command line arguments.

    Returns:
        str: The output directory path.
    """
    output_dir = Path(config.output_dir)
    if output_dir.is_absolute():
        return output_dir

    return Path.cwd() / output_dir
