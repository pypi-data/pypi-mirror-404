"""Django management command to disassemble event palettes from ROM and generate Python definitions."""

from django.core.management.base import BaseCommand
from pathlib import Path

from smrpgpatchbuilder.datatypes.sprites.ids.misc import (
    COLORS_PER_PALETTE,
    EVENT_PALETTE_OFFSET,
    PALETTE_SIZE,
    TOTAL_EVENT_PALETTES,
)
from smrpgpatchbuilder.datatypes.sprites.palette import snes_bytes_to_color


class Command(BaseCommand):
    help = "Disassemble event palettes from ROM and generate Python palette definitions"

    def add_arguments(self, parser):
        parser.add_argument(
            "-r",
            "--rom",
            dest="rom",
            required=True,
            help="Path to a Mario RPG ROM file",
        )
        parser.add_argument(
            "-o",
            "--output",
            dest="output",
            default="src/disassembler_output/event_palettes/event_palettes.py",
            help="Output file path",
        )

    def handle(self, *args, **options):
        rom_path = options["rom"]
        output_path = options["output"]

        # read rom
        with open(rom_path, "rb") as f:
            rom = bytearray(f.read())

        # generate output
        output_lines = []
        output_lines.append("# AUTOGENERATED DO NOT EDIT!!")
        output_lines.append("# Run the following command to rebuild:")
        output_lines.append("# python manage.py eventpalettedisassembler --rom <ROM_PATH>")
        output_lines.append("")
        output_lines.append("from smrpgpatchbuilder.datatypes.sprites.palette import (")
        output_lines.append("    EventPalette,")
        output_lines.append("    EventPaletteCollection,")
        output_lines.append(")")
        output_lines.append("from smrpgpatchbuilder.datatypes.sprites.ids.event_palettes import (")
        # Generate EPAL constant imports - use ranges to keep import manageable
        output_lines.append("    # Import all EPAL constants")
        # Break into chunks for readability (100 per line)
        chunk_size = 10
        for i in range(0, TOTAL_EVENT_PALETTES, chunk_size):
            end = min(i + chunk_size, TOTAL_EVENT_PALETTES)
            chunk = [f"EPAL{j:04d}" for j in range(i, end)]
            output_lines.append(f"    {', '.join(chunk)},")
        output_lines.append(")")
        output_lines.append("")
        output_lines.append("")

        # process each palette
        palette_names = []
        for pal_id in range(TOTAL_EVENT_PALETTES):
            offset = EVENT_PALETTE_OFFSET + pal_id * PALETTE_SIZE
            palette_bytes = rom[offset:offset + PALETTE_SIZE]

            # Convert bytes to colors
            colors = []
            for i in range(COLORS_PER_PALETTE):
                byte1 = palette_bytes[i * 2]
                byte2 = palette_bytes[i * 2 + 1]
                color = snes_bytes_to_color(byte1, byte2)
                colors.append(color)

            # Generate palette definition
            pal_name = f"EVENT_PALETTE_{pal_id:04d}"
            palette_names.append(pal_name)

            output_lines.append(f"{pal_name} = EventPalette(EPAL{pal_id:04d}, [")
            # Write colors in groups of 5 for readability
            for i in range(0, COLORS_PER_PALETTE, 5):
                chunk = colors[i:i + 5]
                color_strs = [f"0x{c:06X}" for c in chunk]
                output_lines.append(f"    {', '.join(color_strs)},")
            output_lines.append("])")
            output_lines.append("")

            # Progress indicator for large file
            if (pal_id + 1) % 1000 == 0:
                self.stdout.write(f"Processed {pal_id + 1}/{TOTAL_EVENT_PALETTES} palettes...")

        # generate EventPaletteCollection
        output_lines.append("")
        output_lines.append("# Event palette collection containing all palettes")
        output_lines.append("ALL_EVENT_PALETTES = EventPaletteCollection([")
        # Write in groups for readability
        for i in range(0, len(palette_names), 5):
            chunk = palette_names[i:i + 5]
            output_lines.append(f"    {', '.join(chunk)},")
        output_lines.append("])")
        output_lines.append("")

        # write output file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text("\n".join(output_lines))

        # generate __init__.py with all palette imports
        init_lines = []
        init_lines.append("# AUTOGENERATED DO NOT EDIT!!")
        init_lines.append("# This file imports all event palette definitions from event_palettes.py")
        init_lines.append("")
        init_lines.append("from .event_palettes import (")
        for name in palette_names:
            init_lines.append(f"    {name},")
        init_lines.append("    ALL_EVENT_PALETTES,")
        init_lines.append(")")
        init_lines.append("")

        init_file = output_file.parent / "__init__.py"
        init_file.write_text("\n".join(init_lines))

        self.stdout.write(
            self.style.SUCCESS(f"Successfully generated {TOTAL_EVENT_PALETTES} event palette definitions to {output_path}")
        )
        self.stdout.write(
            self.style.SUCCESS(f"Successfully generated __init__.py with {len(palette_names)} palette imports")
        )
