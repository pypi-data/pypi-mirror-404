{
    Initialize "() {
        AddToPluginsMenu('Cyrus', 'Run');
    }"
    _version "() {
        // Build version displayed in progress dialog and report header
        return 45;
    }"
    Run "() {
        // Entry point: detect staves, process score, show report
        score = Sibelius.ActiveScore;
        if (null = score) {
            Sibelius.MessageBox('No score is open.');
            return False;
        }
        result = DetectLyricStaves(score);
        if (result = null) {
            return False;
        }
        startBar = result[0];
        endBar = result[1];
        selectedStaves = result[2];
        report = ProcessScore(score, startBar, endBar, selectedStaves);
        Sibelius.MessageBox(report);
        return True;
    }"
    ProcessScore "(score, startBar, endBar, selectedStaves) {
        // Main loop: iterate bars then staves, collect changes/skips/unresolved
        report = '';
        changeCount = 0;
        skippedCount = 0;
        boundariesChecked = 0;
        numStaves = 0;
        for i = 0 to 100 {
            if (selectedStaves[i] = null) {
                i = 100;
            } else {
                numStaves = numStaves + 1;
            }
        }
        totalBars = (endBar - startBar + 1) * numStaves;
        Sibelius.CreateProgressDialog('Cyrus v' & _version(), 0, 100);
        barsDone = 0;
        cancelled = False;
        currentSection = '';
        currentPage = 1;
        // ManuScript for-loop upper bound is exclusive, so +1 to include endBar
        for barNum = startBar to endBar + 1 {
            if (not(cancelled)) {
                // Get rehearsal mark from system staff
                sysBar = score.SystemStaff.NthBar(barNum);
                for each obj in sysBar {
                    if (obj.Type = 'RehearsalMark') {
                        currentSection = obj.MarkAsText;
                    }
                }
                staffIdx = 0;
                for each staff in score {
                    if (not(cancelled)) {
                        isSelected = False;
                        for i = 0 to 100 {
                            if (selectedStaves[i] = null) {
                                i = 100;
                            } else {
                                if (selectedStaves[i] = staff.StaffNum) {
                                    isSelected = True;
                                    i = 100;
                                }
                            }
                        }
                        if (isSelected) {
                            staffIdx = staffIdx + 1;
                            staffName = staff.FullInstrumentName;
                            if (staffName = '') {
                                staffName = staff.InstrumentName;
                            }
                            pct = (barsDone * 100) / totalBars;
                            progressMsg = 'Bar ' & barNum & '/' & endBar & Chr(10) & 'Staves: ' & numStaves;
                            continueProcessing = Sibelius.UpdateProgressDialog(pct, progressMsg);
                            if (not(continueProcessing)) {
                                cancelled = True;
                            } else {
                                bar = staff.NthBar(barNum);
                                displayBarNum = bar.ExternalBarNumberString;
                                if (bar.OnNthPage > 0) {
                                    currentPage = bar.OnNthPage;
                                }
                                result = ProcessBar(bar, barNum, displayBarNum, currentSection, currentPage, staffName);
                                // Parse result tags: CHNG, SKIPS{n}|, UNRE
                                if (Length(result) >= 4) {
                                    for j = 0 to Length(result) - 3 {
                                        tag = Substring(result, j, 4);
                                        if (tag = 'CHNG') {
                                            changeCount = changeCount + 1;
                                        }
                                        if (tag = 'SKIP') {
                                            // SKIPS format: SKIPS{count}| - extract the number
                                            endIdx = j + 5;
                                            numStr = '';
                                            while (endIdx < Length(result)) {
                                                ch = Substring(result, endIdx, 1);
                                                if (ch = '0' or ch = '1' or ch = '2' or ch = '3' or ch = '4' or ch = '5' or ch = '6' or ch = '7' or ch = '8' or ch = '9') {
                                                    numStr = numStr & ch;
                                                    endIdx = endIdx + 1;
                                                } else {
                                                    endIdx = Length(result);
                                                }
                                            }
                                            if (numStr != '') {
                                                skippedCount = skippedCount + (0 + numStr);
                                            }
                                        }
                                        if (tag = 'UNRE') {
                                            boundariesChecked = boundariesChecked + 1;
                                        }
                                    }
                                }
                                if (result != 'SKIP') {
                                    report = report & result;
                                }
                            }
                            barsDone = barsDone + 1;
                        }
                    }
                }
            }
        }
        Sibelius.DestroyProgressDialog();
        header = '=== Cyrus Report (v' & _version() & ') ===' & Chr(10);
        if (cancelled) {
            return header & Chr(10) & 'Processing cancelled.';
        }
        header = header & 'Bars: ' &(endBar - startBar + 1) & Chr(10);
        header = header & 'Staves: ' & numStaves & Chr(10);
        header = header & 'Skipped: ' & skippedCount & Chr(10);
        header = header & 'Unresolved: ' & boundariesChecked & Chr(10);
        header = header & 'Changes: ' & changeCount & Chr(10);
        // Strip SKIPS markers from final report
        cleanReport = '';
        i = 0;
        while (i < Length(report)) {
            if (Substring(report, i, 5) = 'SKIPS') {
                while (i < Length(report) and Substring(report, i, 1) != '|') {
                    i = i + 1;
                }
                i = i + 1;
            } else {
                cleanReport = cleanReport & Substring(report, i, 1);
                i = i + 1;
            }
        }
        fullReport = header & Chr(10) & cleanReport;
        filePath = Sibelius.SelectFileToSave('Save Cyrus Report', 'cyrus_report.txt', '', 'txt', 'TEXT');
        if (filePath != '') {
            Sibelius.CreateTextFile(filePath);
            Sibelius.AppendTextFile(filePath, fullReport, True);
            return header & Chr(10) & 'Report saved to: ' & filePath;
        }
        return header;
    }"
    ProcessBar "(bar, barNum, displayBarNum, section, page, staffName) {
        // Collect Cyrillic (verse1) and IPA (verse2) lyrics, process syllable pairs
        report = '';
        skipCount = 0;
        cyrillic = CreateSparseArray();
        ipa = CreateSparseArray();
        cyrSylType = CreateSparseArray();
        for each obj in bar {
            if (obj.Type = 'LyricItem') {
                pos = obj.Position;
                style = obj.StyleId;
                if (StyleIsVerse1(style)) {
                    cyrillic[pos] = obj.Text;
                    cyrSylType[pos] = obj.SyllableType;
                } else {
                    if (StyleIsVerse2(style)) {
                        ipa[pos] = obj;
                    }
                }
            }
        }
        positions = GetSortedPositions(cyrillic);
        // Process consecutive syllable pairs (only mid-word boundaries)
        for i = 0 to 1000 {
            pos = positions[i];
            if (pos = null) {
                i = 1000;
            } else {
                cyrText = cyrillic[pos];
                ipaObj = ipa[pos];
                if (ipaObj != null) {
                    sylType = cyrSylType[pos];
                    // MiddleOfWord means there is a following syllable in same word
                    if (sylType = MiddleOfWord) {
                        nextPos = positions[i + 1];
                        if (nextPos != null) {
                            nextCyrText = cyrillic[nextPos];
                            nextIpaObj = ipa[nextPos];
                            if (nextCyrText != null and nextIpaObj != null) {
                                result = ProcessSyllableBoundary(cyrText, ipaObj, nextCyrText, nextIpaObj, barNum, displayBarNum, section, page, pos, staffName);
                                if (result = 'SKIP') {
                                    skipCount = skipCount + 1;
                                } else {
                                    report = report & result;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (skipCount > 0) {
            report = 'SKIPS' & skipCount & '|' & report;
        }
        return report;
    }"
    ProcessSyllableBoundary "(cyrA, ipaObjA, cyrB, ipaObjB, barNum, displayBarNum, section, page, pos, staffName) {
        // Compare Cyrillic and IPA syllable boundaries, move consonants if needed.
        // cyrA/cyrB = Cyrillic syllables, ipaObjA/ipaObjB = IPA lyric objects
        ipaA = ipaObjA.Text;
        ipaB = ipaObjB.Text;
        // Extract expected IPA onset from Cyrillic second syllable
        cyrOnset = ExtractCyrillicOnset(cyrB);
        expectedIpa = MapCyrillicToIpa(cyrOnset);
        // Handle stress marker at start of IPA syllable
        hasStress = False;
        ipaBWork = ipaB;
        if (Length(ipaB) > 0) {
            fc = Substring(ipaB, 0, 1);
            if (IsStressMarker(fc)) {
                hasStress = True;
                ipaBWork = Substring(ipaB, 1, Length(ipaB) - 1);
            }
        }
        actualOnset = ExtractIpaOnset(ipaBWork);
        // Already correct
        if (OnsetMatches(actualOnset, expectedIpa)) {
            return 'SKIP';
        }
        // Palatalizing vowel exception: ya/ye/yo/yu carry inherent j sound
        if (StartsWithPalatalizingVowel(cyrB) and IsJotatedVowelOnset(ipaBWork)) {
            return 'SKIP';
        }
        // Calculate how many consonant units to move
        unitsToMove = CalculateUnitsToMove(ipaBWork, expectedIpa);
        if (unitsToMove = 0) {
            return 'SKIP';
        }
        // Could not find a match - flag as unresolved
        if (unitsToMove < 0) {
            loc = BuildLocation(page, section, displayBarNum, pos);
            return 'UNRE ' & loc & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' (cyr: ' & cyrA & '-' & cyrB & ', expected: ' & expectedIpa & ')' & Chr(10);
        }
        // Move consonants from ipaB to ipaA
        toMove = ExtractConsonantUnits(ipaBWork, unitsToMove);
        remaining = Substring(ipaBWork, Length(toMove), Length(ipaBWork) - Length(toMove));
        newIpaA = ipaA & toMove;
        newIpaB = remaining;
        // Restore stress marker
        if (hasStress) {
            newIpaB = GetStressMarker() & newIpaB;
        }
        // Apply changes
        ipaObjA.Text = newIpaA;
        ipaObjB.Text = newIpaB;
        loc = BuildLocation(page, section, displayBarNum, pos);
        return 'CHNG ' & loc & ', ' & staffName & ': ' & ipaA & '-' & ipaB & ' -> ' & newIpaA & '-' & newIpaB & ' (cyr: ' & cyrA & '-' & cyrB & ')' & Chr(10);
    }"
    BuildLocation "(page, section, displayBarNum, pos) {
        // Build location string like: p4 [B] Bar 8, Beat 1
        // Sibelius uses 256 ticks per quarter note
        beat = (pos / 256) + 1;
        loc = 'p' & page;
        if (section != '') {
            loc = loc & ' [' & section & ']';
        }
        loc = loc & ' Bar ' & displayBarNum & ', Beat ' & beat;
        return loc;
    }"
    ExtractCyrillicOnset "(text) {
        // Extract consonants before first vowel
        onset = '';
        vowels = GetCyrillicVowels();
        if (Length(text) > 0) {
            for i = 0 to Length(text) {
                c = Substring(text, i, 1);
                if (CharInString(c, vowels)) {
                    return onset;
                }
                onset = onset & c;
            }
        }
        return onset;
    }"
    MapCyrillicToIpa "(cyrOnset) {
        // Convert Cyrillic consonant cluster to expected IPA
        // Special clusters: сч/зч/жч -> ʃ
        if (cyrOnset = 'сч' or cyrOnset = 'зч' or cyrOnset = 'жч') {
            return 'ʃ';
        }
        result = '';
        if (Length(cyrOnset) > 0) {
            for i = 0 to Length(cyrOnset) {
                c = Substring(cyrOnset, i, 1);
                mapped = MapSingleCyrillicConsonant(c);
                result = result & mapped;
            }
        }
        return result;
    }"
    MapSingleCyrillicConsonant "(c) {
        // Single Cyrillic consonant to IPA mapping
        // Edit these to match your transcription conventions
        if (c = 'п') {
            return 'p';
        }
        if (c = 'б') {
            return 'b';
        }
        if (c = 'т') {
            return 't';
        }
        if (c = 'д') {
            return 'd';
        }
        if (c = 'к') {
            return 'k';
        }
        if (c = 'г') {
            return 'g';
        }
        if (c = 'м') {
            return 'm';
        }
        if (c = 'н') {
            return 'n';
        }
        if (c = 'р') {
            return 'r';
        }
        if (c = 'ф') {
            return 'f';
        }
        if (c = 'в') {
            return 'v';
        }
        if (c = 'с') {
            return 's';
        }
        if (c = 'з') {
            return 'z';
        }
        if (c = 'ш') {
            return 'ʃ';
        }
        if (c = 'ж') {
            return 'ʒ';
        }
        if (c = 'щ') {
            return 'ʃ';
        }
        if (c = 'ч') {
            return 't͡ʃ';
        }
        if (c = 'ц') {
            return 't͡s';
        }
        if (c = 'й') {
            return 'j';
        }
        if (c = 'х') {
            return 'x';
        }
        if (c = 'л') {
            return 'l';
        }
        if (c = 'ь') {
            return '';
        }
        if (c = 'ъ') {
            return '';
        }
        return '';
    }"
    ExtractIpaOnset "(text) {
        // Extract consonant units before first vowel
        onset = '';
        vowels = GetIpaVowels();
        i = 0;
        while (i < Length(text)) {
            c = Substring(text, i, 1);
            if (CharInString(c, vowels)) {
                return onset;
            }
            unit = ExtractOneConsonantUnit(text, i);
            onset = onset & unit;
            i = i + Length(unit);
        }
        return onset;
    }"
    ExtractOneConsonantUnit "(text, startIdx) {
        // Extract one consonant unit: base + optional tie bar + diacritics
        // Examples: t, t͡ʃ, tʲ, t͡ʃʲː
        if (startIdx >= Length(text)) {
            return '';
        }
        unit = '';
        c = Substring(text, startIdx, 1);
        unit = unit & c;
        idx = startIdx + 1;
        // Check for tie bar (affricate like t͡ʃ)
        if (idx < Length(text)) {
            nxt = Substring(text, idx, 1);
            if (IsTieBar(nxt)) {
                unit = unit & nxt;
                idx = idx + 1;
                if (idx < Length(text)) {
                    nxt = Substring(text, idx, 1);
                    unit = unit & nxt;
                    idx = idx + 1;
                }
            }
        }
        // Collect trailing diacritics
        while (idx < Length(text)) {
            nxt = Substring(text, idx, 1);
            if (IsDiacritic(nxt)) {
                unit = unit & nxt;
                idx = idx + 1;
            } else {
                idx = Length(text);
            }
        }
        return unit;
    }"
    OnsetMatches "(actualOnset, expectedIpa) {
        // Compare onsets after normalization
        if (expectedIpa = '') {
            return(actualOnset = '');
        }
        normalizedActual = NormalizeIpaForMatching(actualOnset);
        normalizedExpected = NormalizeIpaForMatching(expectedIpa);
        return(normalizedActual = normalizedExpected);
    }"
    NormalizeIpaForMatching "(text) {
        // Strip diacritics/tie bars, normalize variants (dark L, IPA g)
        result = '';
        if (Length(text) > 0) {
            for i = 0 to Length(text) {
                c = Substring(text, i, 1);
                if (not(IsDiacritic(c)) and not(IsTieBar(c))) {
                    if (c = 'ɫ') {
                        result = result & 'l';
                    } else {
                        if (c = 'ɡ') {
                            result = result & 'g';
                        } else {
                            result = result & c;
                        }
                    }
                }
            }
        }
        return result;
    }"
    CalculateUnitsToMove "(ipaB, expectedIpa) {
        // Find how many consonant units to move so remaining matches expected.
        // Returns -1 if no match found (unresolved).
        if (expectedIpa = '') {
            onset = ExtractIpaOnset(ipaB);
            return CountConsonantUnits(onset);
        }
        onset = ExtractIpaOnset(ipaB);
        totalUnits = CountConsonantUnits(onset);
        normalizedExpected = NormalizeIpaForMatching(expectedIpa);
        // Try removing 0, 1, 2... units until remaining matches expected
        for unitsToRemove = 0 to totalUnits + 1 {
            remaining = RemoveNConsonantUnits(onset, unitsToRemove);
            normalizedRemaining = NormalizeIpaForMatching(remaining);
            if (normalizedRemaining = normalizedExpected) {
                return unitsToRemove;
            }
        }
        return -1;
    }"
    CountConsonantUnits "(text) {
        // Count consonant units (affricates count as 1)
        count = 0;
        idx = 0;
        while (idx < Length(text)) {
            unit = ExtractOneConsonantUnit(text, idx);
            if (unit = '') {
                idx = Length(text);
            } else {
                count = count + 1;
                idx = idx + Length(unit);
            }
        }
        return count;
    }"
    ExtractConsonantUnits "(text, numUnits) {
        // Extract first N consonant units
        result = '';
        idx = 0;
        if (numUnits > 0) {
            for u = 1 to numUnits + 1 {
                if (idx < Length(text)) {
                    unit = ExtractOneConsonantUnit(text, idx);
                    result = result & unit;
                    idx = idx + Length(unit);
                }
            }
        }
        return result;
    }"
    RemoveNConsonantUnits "(text, n) {
        // Return text with first N consonant units removed
        idx = 0;
        if (n > 0) {
            for u = 1 to n + 1 {
                if (idx < Length(text)) {
                    unit = ExtractOneConsonantUnit(text, idx);
                    idx = idx + Length(unit);
                }
            }
        }
        return Substring(text, idx, Length(text) - idx);
    }"
    GetCyrillicVowels "() {
        // Cyrillic vowels (add uppercase if needed)
        return 'аеёиоуыэюяАЕЁИОУЫЭЮЯ';
    }"
    GetPalatalizingVowels "() {
        // Vowels that carry inherent j: я=ja, е=je, ё=jo, ю=ju
        return 'яеёюЯЕЁЮ';
    }"
    StartsWithPalatalizingVowel "(cyrText) {
        if (Length(cyrText) = 0) {
            return False;
        }
        firstChar = Substring(cyrText, 0, 1);
        return CharInString(firstChar, GetPalatalizingVowels());
    }"
    IsJotatedVowelOnset "(ipaOnset) {
        // Check for j + vowel pattern (jotated vowel)
        if (Length(ipaOnset) < 2) {
            return False;
        }
        if (Substring(ipaOnset, 0, 1) != 'j') {
            return False;
        }
        secondChar = Substring(ipaOnset, 1, 1);
        return CharInString(secondChar, GetIpaVowels());
    }"
    GetIpaVowels "() {
        // IPA vowels used in transcription
        return 'ɑʌɐeɛɪiouaæɨ';
    }"
    GetStressMarker "() {
        return 'ˈ';
    }"
    IsStressMarker "(c) {
        return(c = 'ˈ');
    }"
    IsTieBar "(c) {
        // Tie bar for affricates: t͡ʃ, t͡s
        return(c = '͡');
    }"
    IsDiacritic "(c) {
        // Diacritics that modify consonants
        diacritics = 'ʲːˑ̟̃';
        return CharInString(c, diacritics);
    }"
    CharInString "(c, str) {
        if (Length(str) > 0) {
            for i = 0 to Length(str) {
                if (Substring(str, i, 1) = c) {
                    return True;
                }
            }
        }
        return False;
    }"
    GetSortedPositions "(arr) {
        // Get array indices with values, in order (max 4096 ticks per bar)
        positions = CreateSparseArray();
        count = 0;
        for pos = 0 to 4096 {
            if (arr[pos] != null) {
                positions[count] = pos;
                count = count + 1;
            }
        }
        return positions;
    }"
    StyleIsVerse1 "(styleId) {
        // Verse 1 = Cyrillic text
        return(styleId = 'text.staff.space.hypen.lyrics.verse1');
    }"
    StyleIsVerse2 "(styleId) {
        // Verse 2 = IPA transcription
        return(styleId = 'text.staff.space.hypen.lyrics.verse2');
    }"
    DetectLyricStaves "(score) {
        // Auto-detect staves with lyrics by scanning first 200 bars
        stavesWithLyrics = CreateSparseArray();
        idx = 0;
        barCount = score.SystemStaff.BarCount;
        checkBars = 200;
        if (barCount < checkBars) {
            checkBars = barCount;
        }
        for each staff in score {
            hasLyrics = False;
            for barNum = 1 to checkBars + 1 {
                bar = staff.NthBar(barNum);
                for each obj in bar {
                    if (obj.Type = 'LyricItem') {
                        hasLyrics = True;
                    }
                }
                if (hasLyrics) {
                    barNum = checkBars + 1;
                }
            }
            if (hasLyrics) {
                stavesWithLyrics[idx] = staff.StaffNum;
                idx = idx + 1;
            }
        }
        if (idx = 0) {
            Sibelius.MessageBox('No staves with lyrics found.');
            return null;
        }
        result = CreateSparseArray();
        result[0] = 1;
        result[1] = barCount;
        result[2] = stavesWithLyrics;
        return result;
    }"
}
