# coding=utf-8
from abc import (
    abstractmethod,
)
import builtins
from conjure_python_client import (
    BinaryType,
    ConjureBeanType,
    ConjureDecoder,
    ConjureEncoder,
    ConjureEnumType,
    ConjureFieldDefinition,
    ConjureUnionType,
    OptionalTypeWrapper,
    Service,
)
from requests.adapters import (
    Response,
)
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Set,
)
from urllib.parse import (
    quote,
)

class api_ArchivedStatus(ConjureEnumType):

    NOT_ARCHIVED = 'NOT_ARCHIVED'
    '''NOT_ARCHIVED'''
    ARCHIVED = 'ARCHIVED'
    '''ARCHIVED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_ArchivedStatus.__name__ = "ArchivedStatus"
api_ArchivedStatus.__qualname__ = "ArchivedStatus"
api_ArchivedStatus.__module__ = "nominal_api.api"


class api_DataSourceType(ConjureEnumType):

    DATASET = 'DATASET'
    '''DATASET'''
    CONNECTION = 'CONNECTION'
    '''CONNECTION'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_DataSourceType.__name__ = "DataSourceType"
api_DataSourceType.__qualname__ = "DataSourceType"
api_DataSourceType.__module__ = "nominal_api.api"


class api_Deleted(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



api_Deleted.__name__ = "Deleted"
api_Deleted.__qualname__ = "Deleted"
api_Deleted.__module__ = "nominal_api.api"


class api_DeletionInProgress(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



api_DeletionInProgress.__name__ = "DeletionInProgress"
api_DeletionInProgress.__qualname__ = "DeletionInProgress"
api_DeletionInProgress.__module__ = "nominal_api.api"


class api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



api_Empty.__name__ = "Empty"
api_Empty.__qualname__ = "Empty"
api_Empty.__module__ = "nominal_api.api"


class api_ErrorResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', api_ErrorType),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_error_type', '_message']

    def __init__(self, error_type: str, message: str) -> None:
        self._error_type = error_type
        self._message = message

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def message(self) -> str:
        return self._message


api_ErrorResult.__name__ = "ErrorResult"
api_ErrorResult.__qualname__ = "ErrorResult"
api_ErrorResult.__module__ = "nominal_api.api"


class api_Granularity(ConjureEnumType):

    PICOSECONDS = 'PICOSECONDS'
    '''PICOSECONDS'''
    NANOSECONDS = 'NANOSECONDS'
    '''NANOSECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_Granularity.__name__ = "Granularity"
api_Granularity.__qualname__ = "Granularity"
api_Granularity.__module__ = "nominal_api.api"


class api_Handle(ConjureUnionType):
    _s3: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', api_S3Path)
        }

    def __init__(
            self,
            s3: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional[str]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, api_HandleVisitor):
            raise ValueError('{} is not an instance of api_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


api_Handle.__name__ = "Handle"
api_Handle.__qualname__ = "Handle"
api_Handle.__module__ = "nominal_api.api"


class api_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: str) -> Any:
        pass


api_HandleVisitor.__name__ = "HandleVisitor"
api_HandleVisitor.__qualname__ = "HandleVisitor"
api_HandleVisitor.__module__ = "nominal_api.api"


class api_InProgressResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



api_InProgressResult.__name__ = "InProgressResult"
api_InProgressResult.__qualname__ = "InProgressResult"
api_InProgressResult.__module__ = "nominal_api.api"


class api_IngestStatus(ConjureEnumType):

    SUCCEEDED = 'SUCCEEDED'
    '''SUCCEEDED'''
    FAILED = 'FAILED'
    '''FAILED'''
    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_IngestStatus.__name__ = "IngestStatus"
api_IngestStatus.__qualname__ = "IngestStatus"
api_IngestStatus.__module__ = "nominal_api.api"


class api_IngestStatusV2(ConjureUnionType):
    _success: Optional["api_SuccessResult"] = None
    _error: Optional["api_ErrorResult"] = None
    _in_progress: Optional["api_InProgressResult"] = None
    _deletion_in_progress: Optional["api_DeletionInProgress"] = None
    _deleted: Optional["api_Deleted"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', api_SuccessResult),
            'error': ConjureFieldDefinition('error', api_ErrorResult),
            'in_progress': ConjureFieldDefinition('inProgress', api_InProgressResult),
            'deletion_in_progress': ConjureFieldDefinition('deletionInProgress', api_DeletionInProgress),
            'deleted': ConjureFieldDefinition('deleted', api_Deleted)
        }

    def __init__(
            self,
            success: Optional["api_SuccessResult"] = None,
            error: Optional["api_ErrorResult"] = None,
            in_progress: Optional["api_InProgressResult"] = None,
            deletion_in_progress: Optional["api_DeletionInProgress"] = None,
            deleted: Optional["api_Deleted"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) + (deletion_in_progress is not None) + (deleted is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'
            if deletion_in_progress is not None:
                self._deletion_in_progress = deletion_in_progress
                self._type = 'deletionInProgress'
            if deleted is not None:
                self._deleted = deleted
                self._type = 'deleted'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'
        elif type_of_union == 'deletionInProgress':
            if deletion_in_progress is None:
                raise ValueError('a union value must not be None')
            self._deletion_in_progress = deletion_in_progress
            self._type = 'deletionInProgress'
        elif type_of_union == 'deleted':
            if deleted is None:
                raise ValueError('a union value must not be None')
            self._deleted = deleted
            self._type = 'deleted'

    @builtins.property
    def success(self) -> Optional["api_SuccessResult"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["api_ErrorResult"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["api_InProgressResult"]:
        return self._in_progress

    @builtins.property
    def deletion_in_progress(self) -> Optional["api_DeletionInProgress"]:
        return self._deletion_in_progress

    @builtins.property
    def deleted(self) -> Optional["api_Deleted"]:
        return self._deleted

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, api_IngestStatusV2Visitor):
            raise ValueError('{} is not an instance of api_IngestStatusV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)
        if self._type == 'deletionInProgress' and self.deletion_in_progress is not None:
            return visitor._deletion_in_progress(self.deletion_in_progress)
        if self._type == 'deleted' and self.deleted is not None:
            return visitor._deleted(self.deleted)


api_IngestStatusV2.__name__ = "IngestStatusV2"
api_IngestStatusV2.__qualname__ = "IngestStatusV2"
api_IngestStatusV2.__module__ = "nominal_api.api"


class api_IngestStatusV2Visitor:

    @abstractmethod
    def _success(self, success: "api_SuccessResult") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "api_ErrorResult") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "api_InProgressResult") -> Any:
        pass

    @abstractmethod
    def _deletion_in_progress(self, deletion_in_progress: "api_DeletionInProgress") -> Any:
        pass

    @abstractmethod
    def _deleted(self, deleted: "api_Deleted") -> Any:
        pass


api_IngestStatusV2Visitor.__name__ = "IngestStatusV2Visitor"
api_IngestStatusV2Visitor.__qualname__ = "IngestStatusV2Visitor"
api_IngestStatusV2Visitor.__module__ = "nominal_api.api"


class api_McapChannelLocator(ConjureUnionType):
    """Locator for a channel in an mcap file. Channel name is not guaranteed to be unique, so channel ID should
be used for mcap files with duplicate channel names.
    """
    _topic: Optional[str] = None
    _id: Optional[int] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'topic': ConjureFieldDefinition('topic', api_McapChannelTopic),
            'id': ConjureFieldDefinition('id', api_McapChannelId)
        }

    def __init__(
            self,
            topic: Optional[str] = None,
            id: Optional[int] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (topic is not None) + (id is not None) != 1:
                raise ValueError('a union must contain a single member')

            if topic is not None:
                self._topic = topic
                self._type = 'topic'
            if id is not None:
                self._id = id
                self._type = 'id'

        elif type_of_union == 'topic':
            if topic is None:
                raise ValueError('a union value must not be None')
            self._topic = topic
            self._type = 'topic'
        elif type_of_union == 'id':
            if id is None:
                raise ValueError('a union value must not be None')
            self._id = id
            self._type = 'id'

    @builtins.property
    def topic(self) -> Optional[str]:
        return self._topic

    @builtins.property
    def id(self) -> Optional[int]:
        return self._id

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, api_McapChannelLocatorVisitor):
            raise ValueError('{} is not an instance of api_McapChannelLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'topic' and self.topic is not None:
            return visitor._topic(self.topic)
        if self._type == 'id' and self.id is not None:
            return visitor._id(self.id)


api_McapChannelLocator.__name__ = "McapChannelLocator"
api_McapChannelLocator.__qualname__ = "McapChannelLocator"
api_McapChannelLocator.__module__ = "nominal_api.api"


class api_McapChannelLocatorVisitor:

    @abstractmethod
    def _topic(self, topic: str) -> Any:
        pass

    @abstractmethod
    def _id(self, id: int) -> Any:
        pass


api_McapChannelLocatorVisitor.__name__ = "McapChannelLocatorVisitor"
api_McapChannelLocatorVisitor.__qualname__ = "McapChannelLocatorVisitor"
api_McapChannelLocatorVisitor.__module__ = "nominal_api.api"


class api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_PropertyName),
            'value': ConjureFieldDefinition('value', api_PropertyValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


api_Property.__name__ = "Property"
api_Property.__qualname__ = "Property"
api_Property.__module__ = "nominal_api.api"


class api_Range(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp)
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp") -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end


api_Range.__name__ = "Range"
api_Range.__qualname__ = "Range"
api_Range.__module__ = "nominal_api.api"


class api_RefNameAndType(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_DataSourceRefName),
            'type': ConjureFieldDefinition('type', api_DataSourceType)
        }

    __slots__: List[str] = ['_name', '_type']

    def __init__(self, name: str, type: "api_DataSourceType") -> None:
        self._name = name
        self._type = type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def type(self) -> "api_DataSourceType":
        return self._type


api_RefNameAndType.__name__ = "RefNameAndType"
api_RefNameAndType.__qualname__ = "RefNameAndType"
api_RefNameAndType.__module__ = "nominal_api.api"


class api_SerializableError(ConjureBeanType):
    """A SerializableError is a representation of a ServiceException that exists to send error
results to clients as part of a response object when directly throwing an exception is undesirable.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'message': ConjureFieldDefinition('message', OptionalTypeWrapper[str]),
            'error_instance_id': ConjureFieldDefinition('errorInstanceId', str),
            'status_code': ConjureFieldDefinition('statusCode', int),
            'params': ConjureFieldDefinition('params', Dict[str, str])
        }

    __slots__: List[str] = ['_name', '_message', '_error_instance_id', '_status_code', '_params']

    def __init__(self, error_instance_id: str, name: str, params: Dict[str, str], status_code: int, message: Optional[str] = None) -> None:
        self._name = name
        self._message = message
        self._error_instance_id = error_instance_id
        self._status_code = status_code
        self._params = params

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def message(self) -> Optional[str]:
        return self._message

    @builtins.property
    def error_instance_id(self) -> str:
        return self._error_instance_id

    @builtins.property
    def status_code(self) -> int:
        return self._status_code

    @builtins.property
    def params(self) -> Dict[str, str]:
        return self._params


api_SerializableError.__name__ = "SerializableError"
api_SerializableError.__qualname__ = "SerializableError"
api_SerializableError.__module__ = "nominal_api.api"


class api_SeriesDataType(ConjureEnumType):
    """The data types that are available for querying.
    """

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    LOG = 'LOG'
    '''LOG'''
    INT = 'INT'
    '''INT'''
    UINT = 'UINT'
    '''UINT'''
    DOUBLE_ARRAY = 'DOUBLE_ARRAY'
    '''DOUBLE_ARRAY'''
    STRING_ARRAY = 'STRING_ARRAY'
    '''STRING_ARRAY'''
    STRUCT = 'STRUCT'
    '''STRUCT'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_SeriesDataType.__name__ = "SeriesDataType"
api_SeriesDataType.__qualname__ = "SeriesDataType"
api_SeriesDataType.__module__ = "nominal_api.api"


class api_SetOperator(ConjureEnumType):

    AND = 'AND'
    '''AND'''
    OR = 'OR'
    '''OR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_SetOperator.__name__ = "SetOperator"
api_SetOperator.__qualname__ = "SetOperator"
api_SetOperator.__module__ = "nominal_api.api"


class api_SuccessResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



api_SuccessResult.__name__ = "SuccessResult"
api_SuccessResult.__qualname__ = "SuccessResult"
api_SuccessResult.__module__ = "nominal_api.api"


class api_TimeUnit(ConjureEnumType):

    DAYS = 'DAYS'
    '''DAYS'''
    HOURS = 'HOURS'
    '''HOURS'''
    MINUTES = 'MINUTES'
    '''MINUTES'''
    SECONDS = 'SECONDS'
    '''SECONDS'''
    MILLISECONDS = 'MILLISECONDS'
    '''MILLISECONDS'''
    MICROSECONDS = 'MICROSECONDS'
    '''MICROSECONDS'''
    NANOSECONDS = 'NANOSECONDS'
    '''NANOSECONDS'''
    PICOSECONDS = 'PICOSECONDS'
    '''PICOSECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


api_TimeUnit.__name__ = "TimeUnit"
api_TimeUnit.__qualname__ = "TimeUnit"
api_TimeUnit.__module__ = "nominal_api.api"


class api_Timestamp(ConjureBeanType):
    """Picosecond precision timestamp type, represented by an epoch time in seconds, a nanosecond offset, and
optional picosecond offset.
The nanosecond offset is from the start of the epoch second, so must be less than 1 billion.
The optional picosecond offset is only used for picosecond-precision data sources and is from the start of
the nanosecond, so must be less than 1000.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds': ConjureFieldDefinition('seconds', int),
            'nanos': ConjureFieldDefinition('nanos', int),
            'picos': ConjureFieldDefinition('picos', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds', '_nanos', '_picos']

    def __init__(self, nanos: int, seconds: int, picos: Optional[int] = None) -> None:
        self._seconds = seconds
        self._nanos = nanos
        self._picos = picos

    @builtins.property
    def seconds(self) -> int:
        return self._seconds

    @builtins.property
    def nanos(self) -> int:
        return self._nanos

    @builtins.property
    def picos(self) -> Optional[int]:
        return self._picos


api_Timestamp.__name__ = "Timestamp"
api_Timestamp.__qualname__ = "Timestamp"
api_Timestamp.__module__ = "nominal_api.api"


class attachments_api_Attachment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_AttachmentRid),
            'title': ConjureFieldDefinition('title', str),
            's3_path': ConjureFieldDefinition('s3Path', api_S3Path),
            'file_type': ConjureFieldDefinition('fileType', str),
            'description': ConjureFieldDefinition('description', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_title', '_s3_path', '_file_type', '_description', '_created_by', '_properties', '_labels', '_created_at', '_is_archived']

    def __init__(self, created_at: str, created_by: str, description: str, file_type: str, is_archived: bool, labels: List[str], properties: Dict[str, str], rid: str, s3_path: str, title: str) -> None:
        self._rid = rid
        self._title = title
        self._s3_path = s3_path
        self._file_type = file_type
        self._description = description
        self._created_by = created_by
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def file_type(self) -> str:
        return self._file_type

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


attachments_api_Attachment.__name__ = "Attachment"
attachments_api_Attachment.__qualname__ = "Attachment"
attachments_api_Attachment.__module__ = "nominal_api.attachments_api"


class attachments_api_AttachmentService(Service):
    """The attachment service provides functionality for creating, updating, and archiving attachments uploaded to S3.
    """

    def create(self, auth_header: str, request: "attachments_api_CreateAttachmentRequest") -> "attachments_api_Attachment":
        """Create a new attachment. Assumes the file is already uploaded to S3 through the upload service.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/attachments/v1/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "attachments_api_Attachment":
        """Get an attachment by its RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def get_batch(self, auth_header: str, request: "attachments_api_GetAttachmentsRequest") -> "attachments_api_GetAttachmentsResponse":
        """Get a set of attachments by their RIDs.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/attachments/v1/attachments/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_GetAttachmentsResponse, self._return_none_for_unknown_union_types)

    def get_content(self, auth_header: str, rid: str) -> Any:
        """Get the binary content of an attachment.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/content'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def get_uri(self, auth_header: str, rid: str) -> "attachments_api_AttachmentUri":
        """Get a pre-signed URI to download an attachment. The link expires in 1 minute.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/uri'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_AttachmentUri, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "attachments_api_UpdateAttachmentRequest", rid: str) -> "attachments_api_Attachment":
        """Update an attachment. Only the fields that are set in the request will be updated.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/attachments/v1/attachments/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), attachments_api_Attachment, self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, rid: str) -> None:
        """Archive an attachment.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """Unarchive an attachment.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/attachments/v1/attachments/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


attachments_api_AttachmentService.__name__ = "AttachmentService"
attachments_api_AttachmentService.__qualname__ = "AttachmentService"
attachments_api_AttachmentService.__module__ = "nominal_api.attachments_api"


class attachments_api_AttachmentUri(ConjureBeanType):
    """Pre-signed URI that will download the attachment directly from S3.
Expires if the download has not started in 1 minute.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uri': ConjureFieldDefinition('uri', str)
        }

    __slots__: List[str] = ['_uri']

    def __init__(self, uri: str) -> None:
        self._uri = uri

    @builtins.property
    def uri(self) -> str:
        return self._uri


attachments_api_AttachmentUri.__name__ = "AttachmentUri"
attachments_api_AttachmentUri.__qualname__ = "AttachmentUri"
attachments_api_AttachmentUri.__module__ = "nominal_api.attachments_api"


class attachments_api_CreateAttachmentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', api_S3Path),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_s3_path', '_title', '_description', '_properties', '_labels', '_workspace']

    def __init__(self, description: str, labels: List[str], properties: Dict[str, str], s3_path: str, title: str, workspace: Optional[str] = None) -> None:
        self._s3_path = s3_path
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._workspace = workspace

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the attachment. If not provided, the attachment will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
        """
        return self._workspace


attachments_api_CreateAttachmentRequest.__name__ = "CreateAttachmentRequest"
attachments_api_CreateAttachmentRequest.__qualname__ = "CreateAttachmentRequest"
attachments_api_CreateAttachmentRequest.__module__ = "nominal_api.attachments_api"


class attachments_api_GetAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachment_rids': ConjureFieldDefinition('attachmentRids', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_attachment_rids']

    def __init__(self, attachment_rids: List[str]) -> None:
        self._attachment_rids = attachment_rids

    @builtins.property
    def attachment_rids(self) -> List[str]:
        return self._attachment_rids


attachments_api_GetAttachmentsRequest.__name__ = "GetAttachmentsRequest"
attachments_api_GetAttachmentsRequest.__qualname__ = "GetAttachmentsRequest"
attachments_api_GetAttachmentsRequest.__module__ = "nominal_api.attachments_api"


class attachments_api_GetAttachmentsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'response': ConjureFieldDefinition('response', List[attachments_api_Attachment])
        }

    __slots__: List[str] = ['_response']

    def __init__(self, response: List["attachments_api_Attachment"]) -> None:
        self._response = response

    @builtins.property
    def response(self) -> List["attachments_api_Attachment"]:
        return self._response


attachments_api_GetAttachmentsResponse.__name__ = "GetAttachmentsResponse"
attachments_api_GetAttachmentsResponse.__qualname__ = "GetAttachmentsResponse"
attachments_api_GetAttachmentsResponse.__module__ = "nominal_api.attachments_api"


class attachments_api_SearchAttachmentsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None
    _or_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[attachments_api_SearchAttachmentsQuery]),
            'or_': ConjureFieldDefinition('or', List[attachments_api_SearchAttachmentsQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None,
            or_: Optional[List["attachments_api_SearchAttachmentsQuery"]] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["attachments_api_SearchAttachmentsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["attachments_api_SearchAttachmentsQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, attachments_api_SearchAttachmentsQueryVisitor):
            raise ValueError('{} is not an instance of attachments_api_SearchAttachmentsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


attachments_api_SearchAttachmentsQuery.__name__ = "SearchAttachmentsQuery"
attachments_api_SearchAttachmentsQuery.__qualname__ = "SearchAttachmentsQuery"
attachments_api_SearchAttachmentsQuery.__module__ = "nominal_api.attachments_api"


class attachments_api_SearchAttachmentsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["attachments_api_SearchAttachmentsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["attachments_api_SearchAttachmentsQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


attachments_api_SearchAttachmentsQueryVisitor.__name__ = "SearchAttachmentsQueryVisitor"
attachments_api_SearchAttachmentsQueryVisitor.__qualname__ = "SearchAttachmentsQueryVisitor"
attachments_api_SearchAttachmentsQueryVisitor.__module__ = "nominal_api.attachments_api"


class attachments_api_UpdateAttachmentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels


attachments_api_UpdateAttachmentRequest.__name__ = "UpdateAttachmentRequest"
attachments_api_UpdateAttachmentRequest.__qualname__ = "UpdateAttachmentRequest"
attachments_api_UpdateAttachmentRequest.__module__ = "nominal_api.attachments_api"


class authentication_api_AppearanceSetting(ConjureEnumType):

    SYSTEM = 'SYSTEM'
    '''SYSTEM'''
    LIGHT = 'LIGHT'
    '''LIGHT'''
    DARK = 'DARK'
    '''DARK'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_AppearanceSetting.__name__ = "AppearanceSetting"
authentication_api_AppearanceSetting.__qualname__ = "AppearanceSetting"
authentication_api_AppearanceSetting.__module__ = "nominal_api.authentication_api"


class authentication_api_AuthenticationServiceV2(Service):
    """This service provides operations for managing user and org profiles/settings.
Its name is a bit of a misnomer.
    """

    def get_my_profile(self, auth_header: str) -> "authentication_api_UserV2":
        """Gets the profile of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/authentication/v2/my/profile'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)

    def update_my_profile(self, auth_header: str, update_my_profile_request: "authentication_api_UpdateMyProfileRequest") -> "authentication_api_UserV2":
        """Updates the profile of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(update_my_profile_request)

        _path = '/authentication/v2/my/profile'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)

    def get_my_settings(self, auth_header: str) -> "authentication_api_UserSettings":
        """Gets the settings of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/authentication/v2/my/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserSettings, self._return_none_for_unknown_union_types)

    def update_my_settings(self, auth_header: str, user_settings: "authentication_api_UserSettings") -> "authentication_api_UserSettings":
        """Updates the settings of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(user_settings)

        _path = '/authentication/v2/my/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserSettings, self._return_none_for_unknown_union_types)

    def get_my_org_settings(self, auth_header: str) -> "authentication_api_OrgSettings":
        """Gets the settings of the org of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/authentication/v2/org/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_OrgSettings, self._return_none_for_unknown_union_types)

    def update_my_org_settings(self, auth_header: str, org_settings: "authentication_api_OrgSettings") -> "authentication_api_OrgSettings":
        """Updates the settings of the org of the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(org_settings)

        _path = '/authentication/v2/org/settings'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_OrgSettings, self._return_none_for_unknown_union_types)

    def search_users_v2(self, auth_header: str, request: "authentication_api_SearchUsersRequest") -> "authentication_api_SearchUsersResponseV2":
        """Searches for users by email and displayName.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authentication/v2/users'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_SearchUsersResponseV2, self._return_none_for_unknown_union_types)

    def get_users(self, auth_header: str, user_rids: List[str] = None) -> List["authentication_api_UserV2"]:
        """Get users by RID.
        """
        user_rids = user_rids if user_rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(user_rids)

        _path = '/authentication/v2/users/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[authentication_api_UserV2], self._return_none_for_unknown_union_types)

    def get_user(self, auth_header: str, user_rid: str) -> "authentication_api_UserV2":
        """Gets a user by RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'userRid': quote(str(_conjure_encoder.default(user_rid)), safe=''),
        }

        _json: Any = None

        _path = '/authentication/v2/users/{userRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_UserV2, self._return_none_for_unknown_union_types)

    def get_jwks(self, ) -> "authentication_api_Jwks":
        """Returns JWKS (JSON Web Key Set) for MediaMTX JWT verification.
Only available if MediaMTX integration is enabled.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/authentication/v2/jwks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_Jwks, self._return_none_for_unknown_union_types)

    def generate_media_mtx_token(self, auth_header: str, request: "authentication_api_GenerateMediaMtxTokenRequest") -> "authentication_api_GenerateMediaMtxTokenResponse":
        """Generates a JWT token for MediaMTX authentication with a 2-hour expiration.
The token is signed with the MediaMTX private key and contains the specified permissions.
Requires authentication with Nominal. This endpoint is intended for internal use only.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authentication/v2/mediamtx/token'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_GenerateMediaMtxTokenResponse, self._return_none_for_unknown_union_types)

    def get_my_coachmark_dismissals(self, auth_header: str, request: "authentication_api_GetCoachmarkDismissalsRequest") -> "authentication_api_GetCoachmarkDismissalsResponse":
        """Gets coachmark dismissals for the authenticated user.
Optionally filter by specific coachmark IDs.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authentication/v2/my/coachmarks/dismissals'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_GetCoachmarkDismissalsResponse, self._return_none_for_unknown_union_types)

    def dismiss_my_coachmark(self, auth_header: str, request: "authentication_api_DismissCoachmarkRequest") -> "authentication_api_CoachmarkDismissal":
        """Dismisses a coachmark for the authenticated user.
Records the dismissal timestamp and app version.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authentication/v2/my/coachmarks/dismiss'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authentication_api_CoachmarkDismissal, self._return_none_for_unknown_union_types)

    def is_my_coachmark_dismissed(self, auth_header: str, coachmark_id: str) -> bool:
        """Checks if a specific coachmark has been dismissed by the authenticated user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'coachmarkId': quote(str(_conjure_encoder.default(coachmark_id)), safe=''),
        }

        _json: Any = None

        _path = '/authentication/v2/my/coachmarks/dismissed/{coachmarkId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def reset_my_coachmark_dismissal(self, auth_header: str, coachmark_id: str) -> None:
        """Resets a coachmark dismissal for the authenticated user.
This allows the coachmark to be shown again.
Primarily intended for testing and debugging.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'coachmarkId': quote(str(_conjure_encoder.default(coachmark_id)), safe=''),
        }

        _json: Any = None

        _path = '/authentication/v2/my/coachmarks/dismissals/{coachmarkId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


authentication_api_AuthenticationServiceV2.__name__ = "AuthenticationServiceV2"
authentication_api_AuthenticationServiceV2.__qualname__ = "AuthenticationServiceV2"
authentication_api_AuthenticationServiceV2.__module__ = "nominal_api.authentication_api"


class authentication_api_ChartTooltipModeSetting(ConjureEnumType):
    """Tooltip modes which affect the data displayed in chart tooltips, primarily for time series charts.
VERBOSE: Shows all the chart's plotted series in the hover tooltip.
CONCISE: Shows only the plotted series within the row currently being hovered.
MULTI_ROW_CONCISE: Show separate tooltips for each row, where each shows the series plotted in that row.
SINGLE: Shows only the plotted series closest to/under the cursor.
NONE: Hides the tooltip entirely (also affects tooltips for other chart types).
    """

    VERBOSE = 'VERBOSE'
    '''VERBOSE'''
    CONCISE = 'CONCISE'
    '''CONCISE'''
    MULTI_ROW_CONCISE = 'MULTI_ROW_CONCISE'
    '''MULTI_ROW_CONCISE'''
    SINGLE = 'SINGLE'
    '''SINGLE'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_ChartTooltipModeSetting.__name__ = "ChartTooltipModeSetting"
authentication_api_ChartTooltipModeSetting.__qualname__ = "ChartTooltipModeSetting"
authentication_api_ChartTooltipModeSetting.__module__ = "nominal_api.authentication_api"


class authentication_api_CoachmarkDismissal(ConjureBeanType):
    """A record of a coachmark dismissal, including when it was dismissed
and on which app version.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'coachmark_id': ConjureFieldDefinition('coachmarkId', str),
            'dismissed_at': ConjureFieldDefinition('dismissedAt', str),
            'app_version': ConjureFieldDefinition('appVersion', str),
            'step_index': ConjureFieldDefinition('stepIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_coachmark_id', '_dismissed_at', '_app_version', '_step_index']

    def __init__(self, app_version: str, coachmark_id: str, dismissed_at: str, step_index: Optional[int] = None) -> None:
        self._coachmark_id = coachmark_id
        self._dismissed_at = dismissed_at
        self._app_version = app_version
        self._step_index = step_index

    @builtins.property
    def coachmark_id(self) -> str:
        """The coachmark identifier (typically the feature flag name)
        """
        return self._coachmark_id

    @builtins.property
    def dismissed_at(self) -> str:
        """ISO 8601 timestamp of when the coachmark was dismissed
        """
        return self._dismissed_at

    @builtins.property
    def app_version(self) -> str:
        """The apps-scout version (semver) when the coachmark was dismissed
        """
        return self._app_version

    @builtins.property
    def step_index(self) -> Optional[int]:
        """The step index when dismissed (for multi-step coachmarks).
If not present, the coachmark was dismissed via the X button.
        """
        return self._step_index


authentication_api_CoachmarkDismissal.__name__ = "CoachmarkDismissal"
authentication_api_CoachmarkDismissal.__qualname__ = "CoachmarkDismissal"
authentication_api_CoachmarkDismissal.__module__ = "nominal_api.authentication_api"


class authentication_api_DefaultNumberFormatConfigurations(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data': ConjureFieldDefinition('data', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormat])
        }

    __slots__: List[str] = ['_data']

    def __init__(self, data: Optional["scout_chartdefinition_api_NumberFormat"] = None) -> None:
        self._data = data

    @builtins.property
    def data(self) -> Optional["scout_chartdefinition_api_NumberFormat"]:
        """Default number format for data values, e.g. chart tooltip and value table cell values.
        """
        return self._data


authentication_api_DefaultNumberFormatConfigurations.__name__ = "DefaultNumberFormatConfigurations"
authentication_api_DefaultNumberFormatConfigurations.__qualname__ = "DefaultNumberFormatConfigurations"
authentication_api_DefaultNumberFormatConfigurations.__module__ = "nominal_api.authentication_api"


class authentication_api_DefaultTimeRangeTypeSetting(ConjureEnumType):

    DEFAULT = 'DEFAULT'
    '''DEFAULT'''
    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_DefaultTimeRangeTypeSetting.__name__ = "DefaultTimeRangeTypeSetting"
authentication_api_DefaultTimeRangeTypeSetting.__qualname__ = "DefaultTimeRangeTypeSetting"
authentication_api_DefaultTimeRangeTypeSetting.__module__ = "nominal_api.authentication_api"


class authentication_api_DismissCoachmarkRequest(ConjureBeanType):
    """Request to dismiss a coachmark
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'coachmark_id': ConjureFieldDefinition('coachmarkId', str),
            'app_version': ConjureFieldDefinition('appVersion', str),
            'step_index': ConjureFieldDefinition('stepIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_coachmark_id', '_app_version', '_step_index']

    def __init__(self, app_version: str, coachmark_id: str, step_index: Optional[int] = None) -> None:
        self._coachmark_id = coachmark_id
        self._app_version = app_version
        self._step_index = step_index

    @builtins.property
    def coachmark_id(self) -> str:
        """The coachmark identifier to dismiss
        """
        return self._coachmark_id

    @builtins.property
    def app_version(self) -> str:
        """The apps-scout version (semver) when dismissing
        """
        return self._app_version

    @builtins.property
    def step_index(self) -> Optional[int]:
        """The step index when dismissed (for multi-step coachmarks)
        """
        return self._step_index


authentication_api_DismissCoachmarkRequest.__name__ = "DismissCoachmarkRequest"
authentication_api_DismissCoachmarkRequest.__qualname__ = "DismissCoachmarkRequest"
authentication_api_DismissCoachmarkRequest.__module__ = "nominal_api.authentication_api"


class authentication_api_GenerateMediaMtxTokenRequest(ConjureBeanType):
    """Request to generate a MediaMTX authentication token
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'permissions': ConjureFieldDefinition('permissions', List[authentication_api_MediaMtxPermission])
        }

    __slots__: List[str] = ['_permissions']

    def __init__(self, permissions: List["authentication_api_MediaMtxPermission"]) -> None:
        self._permissions = permissions

    @builtins.property
    def permissions(self) -> List["authentication_api_MediaMtxPermission"]:
        """List of permissions to include in the token
        """
        return self._permissions


authentication_api_GenerateMediaMtxTokenRequest.__name__ = "GenerateMediaMtxTokenRequest"
authentication_api_GenerateMediaMtxTokenRequest.__qualname__ = "GenerateMediaMtxTokenRequest"
authentication_api_GenerateMediaMtxTokenRequest.__module__ = "nominal_api.authentication_api"


class authentication_api_GenerateMediaMtxTokenResponse(ConjureBeanType):
    """Response containing the generated MediaMTX token
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'token': ConjureFieldDefinition('token', str)
        }

    __slots__: List[str] = ['_token']

    def __init__(self, token: str) -> None:
        self._token = token

    @builtins.property
    def token(self) -> str:
        """The signed JWT token for MediaMTX authentication
        """
        return self._token


authentication_api_GenerateMediaMtxTokenResponse.__name__ = "GenerateMediaMtxTokenResponse"
authentication_api_GenerateMediaMtxTokenResponse.__qualname__ = "GenerateMediaMtxTokenResponse"
authentication_api_GenerateMediaMtxTokenResponse.__module__ = "nominal_api.authentication_api"


class authentication_api_GetCoachmarkDismissalsRequest(ConjureBeanType):
    """Request to get coachmark dismissals
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'coachmark_ids': ConjureFieldDefinition('coachmarkIds', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_coachmark_ids']

    def __init__(self, coachmark_ids: Optional[List[str]] = None) -> None:
        self._coachmark_ids = coachmark_ids

    @builtins.property
    def coachmark_ids(self) -> Optional[List[str]]:
        """Optional list of coachmark IDs to filter by.
If empty, returns all dismissals for the user.
        """
        return self._coachmark_ids


authentication_api_GetCoachmarkDismissalsRequest.__name__ = "GetCoachmarkDismissalsRequest"
authentication_api_GetCoachmarkDismissalsRequest.__qualname__ = "GetCoachmarkDismissalsRequest"
authentication_api_GetCoachmarkDismissalsRequest.__module__ = "nominal_api.authentication_api"


class authentication_api_GetCoachmarkDismissalsResponse(ConjureBeanType):
    """Response containing coachmark dismissals
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dismissals': ConjureFieldDefinition('dismissals', Dict[str, authentication_api_CoachmarkDismissal])
        }

    __slots__: List[str] = ['_dismissals']

    def __init__(self, dismissals: Dict[str, "authentication_api_CoachmarkDismissal"]) -> None:
        self._dismissals = dismissals

    @builtins.property
    def dismissals(self) -> Dict[str, "authentication_api_CoachmarkDismissal"]:
        """Map of coachmark ID to dismissal record
        """
        return self._dismissals


authentication_api_GetCoachmarkDismissalsResponse.__name__ = "GetCoachmarkDismissalsResponse"
authentication_api_GetCoachmarkDismissalsResponse.__qualname__ = "GetCoachmarkDismissalsResponse"
authentication_api_GetCoachmarkDismissalsResponse.__module__ = "nominal_api.authentication_api"


class authentication_api_Jwk(ConjureBeanType):
    """A JSON Web Key (JWK) representation for RSA public keys
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'kty': ConjureFieldDefinition('kty', str),
            'kid': ConjureFieldDefinition('kid', str),
            'use': ConjureFieldDefinition('use', str),
            'alg': ConjureFieldDefinition('alg', str),
            'n': ConjureFieldDefinition('n', str),
            'e': ConjureFieldDefinition('e', str)
        }

    __slots__: List[str] = ['_kty', '_kid', '_use', '_alg', '_n', '_e']

    def __init__(self, alg: str, e: str, kid: str, kty: str, n: str, use: str) -> None:
        self._kty = kty
        self._kid = kid
        self._use = use
        self._alg = alg
        self._n = n
        self._e = e

    @builtins.property
    def kty(self) -> str:
        return self._kty

    @builtins.property
    def kid(self) -> str:
        return self._kid

    @builtins.property
    def use(self) -> str:
        return self._use

    @builtins.property
    def alg(self) -> str:
        return self._alg

    @builtins.property
    def n(self) -> str:
        return self._n

    @builtins.property
    def e(self) -> str:
        return self._e


authentication_api_Jwk.__name__ = "Jwk"
authentication_api_Jwk.__qualname__ = "Jwk"
authentication_api_Jwk.__module__ = "nominal_api.authentication_api"


class authentication_api_Jwks(ConjureBeanType):
    """A JSON Web Key Set (JWKS) containing one or more keys
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'keys': ConjureFieldDefinition('keys', List[authentication_api_Jwk])
        }

    __slots__: List[str] = ['_keys']

    def __init__(self, keys: List["authentication_api_Jwk"]) -> None:
        self._keys = keys

    @builtins.property
    def keys(self) -> List["authentication_api_Jwk"]:
        return self._keys


authentication_api_Jwks.__name__ = "Jwks"
authentication_api_Jwks.__qualname__ = "Jwks"
authentication_api_Jwks.__module__ = "nominal_api.authentication_api"


class authentication_api_MediaMtxPermission(ConjureBeanType):
    """A permission definition for MediaMTX authentication
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'action': ConjureFieldDefinition('action', str),
            'path': ConjureFieldDefinition('path', str)
        }

    __slots__: List[str] = ['_action', '_path']

    def __init__(self, action: str, path: str) -> None:
        self._action = action
        self._path = path

    @builtins.property
    def action(self) -> str:
        """The action permitted. Allowed values are publish, read, playback, api, metrics, pprof.
        """
        return self._action

    @builtins.property
    def path(self) -> str:
        """The stream path this permission applies to (e.g., "stream/test")
        """
        return self._path


authentication_api_MediaMtxPermission.__name__ = "MediaMtxPermission"
authentication_api_MediaMtxPermission.__qualname__ = "MediaMtxPermission"
authentication_api_MediaMtxPermission.__module__ = "nominal_api.authentication_api"


class authentication_api_OrgSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'default_time_range_type': ConjureFieldDefinition('defaultTimeRangeType', OptionalTypeWrapper[authentication_api_DefaultTimeRangeTypeSetting])
        }

    __slots__: List[str] = ['_default_time_range_type']

    def __init__(self, default_time_range_type: Optional["authentication_api_DefaultTimeRangeTypeSetting"] = None) -> None:
        self._default_time_range_type = default_time_range_type

    @builtins.property
    def default_time_range_type(self) -> Optional["authentication_api_DefaultTimeRangeTypeSetting"]:
        return self._default_time_range_type


authentication_api_OrgSettings.__name__ = "OrgSettings"
authentication_api_OrgSettings.__qualname__ = "OrgSettings"
authentication_api_OrgSettings.__module__ = "nominal_api.authentication_api"


class authentication_api_SearchUsersQuery(ConjureUnionType):
    _and_: Optional[List["authentication_api_SearchUsersQuery"]] = None
    _or_: Optional[List["authentication_api_SearchUsersQuery"]] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[authentication_api_SearchUsersQuery]),
            'or_': ConjureFieldDefinition('or', List[authentication_api_SearchUsersQuery]),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str)
        }

    def __init__(
            self,
            and_: Optional[List["authentication_api_SearchUsersQuery"]] = None,
            or_: Optional[List["authentication_api_SearchUsersQuery"]] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (exact_match is not None) + (search_text is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'

    @builtins.property
    def and_(self) -> Optional[List["authentication_api_SearchUsersQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["authentication_api_SearchUsersQuery"]]:
        return self._or_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact match on email
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        """Searches email and display name
        """
        return self._search_text

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, authentication_api_SearchUsersQueryVisitor):
            raise ValueError('{} is not an instance of authentication_api_SearchUsersQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)


authentication_api_SearchUsersQuery.__name__ = "SearchUsersQuery"
authentication_api_SearchUsersQuery.__qualname__ = "SearchUsersQuery"
authentication_api_SearchUsersQuery.__module__ = "nominal_api.authentication_api"


class authentication_api_SearchUsersQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["authentication_api_SearchUsersQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["authentication_api_SearchUsersQuery"]) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass


authentication_api_SearchUsersQueryVisitor.__name__ = "SearchUsersQueryVisitor"
authentication_api_SearchUsersQueryVisitor.__qualname__ = "SearchUsersQueryVisitor"
authentication_api_SearchUsersQueryVisitor.__module__ = "nominal_api.authentication_api"


class authentication_api_SearchUsersRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', authentication_api_SearchUsersQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[authentication_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "authentication_api_SearchUsersQuery", next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["authentication_api_SortBy"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "authentication_api_SearchUsersQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["authentication_api_SortBy"]:
        """UPDATED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size


authentication_api_SearchUsersRequest.__name__ = "SearchUsersRequest"
authentication_api_SearchUsersRequest.__qualname__ = "SearchUsersRequest"
authentication_api_SearchUsersRequest.__module__ = "nominal_api.authentication_api"


class authentication_api_SearchUsersResponseV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[authentication_api_UserV2]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["authentication_api_UserV2"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["authentication_api_UserV2"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


authentication_api_SearchUsersResponseV2.__name__ = "SearchUsersResponseV2"
authentication_api_SearchUsersResponseV2.__qualname__ = "SearchUsersResponseV2"
authentication_api_SearchUsersResponseV2.__module__ = "nominal_api.authentication_api"


class authentication_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', authentication_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "authentication_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "authentication_api_SortByField":
        return self._field


authentication_api_SortBy.__name__ = "SortBy"
authentication_api_SortBy.__qualname__ = "SortBy"
authentication_api_SortBy.__module__ = "nominal_api.authentication_api"


class authentication_api_SortByField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    EMAIL = 'EMAIL'
    '''EMAIL'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_SortByField.__name__ = "SortByField"
authentication_api_SortByField.__qualname__ = "SortByField"
authentication_api_SortByField.__module__ = "nominal_api.authentication_api"


class authentication_api_TimezoneSetting(ConjureEnumType):

    LOCAL = 'LOCAL'
    '''LOCAL'''
    UTC = 'UTC'
    '''UTC'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authentication_api_TimezoneSetting.__name__ = "TimezoneSetting"
authentication_api_TimezoneSetting.__qualname__ = "TimezoneSetting"
authentication_api_TimezoneSetting.__module__ = "nominal_api.authentication_api"


class authentication_api_UpdateMyProfileRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', str)
        }

    __slots__: List[str] = ['_display_name']

    def __init__(self, display_name: str) -> None:
        self._display_name = display_name

    @builtins.property
    def display_name(self) -> str:
        return self._display_name


authentication_api_UpdateMyProfileRequest.__name__ = "UpdateMyProfileRequest"
authentication_api_UpdateMyProfileRequest.__qualname__ = "UpdateMyProfileRequest"
authentication_api_UpdateMyProfileRequest.__module__ = "nominal_api.authentication_api"


class authentication_api_UserSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'default_time_range_type': ConjureFieldDefinition('defaultTimeRangeType', OptionalTypeWrapper[authentication_api_DefaultTimeRangeTypeSetting]),
            'appearance': ConjureFieldDefinition('appearance', OptionalTypeWrapper[authentication_api_AppearanceSetting]),
            'timezone': ConjureFieldDefinition('timezone', OptionalTypeWrapper[authentication_api_TimezoneSetting]),
            'time_series_hover_tooltip_concise': ConjureFieldDefinition('timeSeriesHoverTooltipConcise', OptionalTypeWrapper[bool]),
            'chart_hover_tooltip_mode': ConjureFieldDefinition('chartHoverTooltipMode', OptionalTypeWrapper[authentication_api_ChartTooltipModeSetting]),
            'default_number_formats': ConjureFieldDefinition('defaultNumberFormats', OptionalTypeWrapper[authentication_api_DefaultNumberFormatConfigurations])
        }

    __slots__: List[str] = ['_default_time_range_type', '_appearance', '_timezone', '_time_series_hover_tooltip_concise', '_chart_hover_tooltip_mode', '_default_number_formats']

    def __init__(self, appearance: Optional["authentication_api_AppearanceSetting"] = None, chart_hover_tooltip_mode: Optional["authentication_api_ChartTooltipModeSetting"] = None, default_number_formats: Optional["authentication_api_DefaultNumberFormatConfigurations"] = None, default_time_range_type: Optional["authentication_api_DefaultTimeRangeTypeSetting"] = None, time_series_hover_tooltip_concise: Optional[bool] = None, timezone: Optional["authentication_api_TimezoneSetting"] = None) -> None:
        self._default_time_range_type = default_time_range_type
        self._appearance = appearance
        self._timezone = timezone
        self._time_series_hover_tooltip_concise = time_series_hover_tooltip_concise
        self._chart_hover_tooltip_mode = chart_hover_tooltip_mode
        self._default_number_formats = default_number_formats

    @builtins.property
    def default_time_range_type(self) -> Optional["authentication_api_DefaultTimeRangeTypeSetting"]:
        return self._default_time_range_type

    @builtins.property
    def appearance(self) -> Optional["authentication_api_AppearanceSetting"]:
        return self._appearance

    @builtins.property
    def timezone(self) -> Optional["authentication_api_TimezoneSetting"]:
        return self._timezone

    @builtins.property
    def time_series_hover_tooltip_concise(self) -> Optional[bool]:
        return self._time_series_hover_tooltip_concise

    @builtins.property
    def chart_hover_tooltip_mode(self) -> Optional["authentication_api_ChartTooltipModeSetting"]:
        return self._chart_hover_tooltip_mode

    @builtins.property
    def default_number_formats(self) -> Optional["authentication_api_DefaultNumberFormatConfigurations"]:
        return self._default_number_formats


authentication_api_UserSettings.__name__ = "UserSettings"
authentication_api_UserSettings.__qualname__ = "UserSettings"
authentication_api_UserSettings.__module__ = "nominal_api.authentication_api"


class authentication_api_UserV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', authentication_api_UserRid),
            'org_rid': ConjureFieldDefinition('orgRid', authentication_api_OrgRid),
            'email': ConjureFieldDefinition('email', str),
            'display_name': ConjureFieldDefinition('displayName', str),
            'avatar_url': ConjureFieldDefinition('avatarUrl', str)
        }

    __slots__: List[str] = ['_rid', '_org_rid', '_email', '_display_name', '_avatar_url']

    def __init__(self, avatar_url: str, display_name: str, email: str, org_rid: str, rid: str) -> None:
        self._rid = rid
        self._org_rid = org_rid
        self._email = email
        self._display_name = display_name
        self._avatar_url = avatar_url

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid

    @builtins.property
    def email(self) -> str:
        return self._email

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def avatar_url(self) -> str:
        """Avatar URL or a default avatar if the user does not have one.
        """
        return self._avatar_url


authentication_api_UserV2.__name__ = "UserV2"
authentication_api_UserV2.__qualname__ = "UserV2"
authentication_api_UserV2.__module__ = "nominal_api.authentication_api"


class authorization_ApiKey(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', authorization_ApiKeyRid),
            'api_key_name': ConjureFieldDefinition('apiKeyName', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'expires_at': ConjureFieldDefinition('expiresAt', OptionalTypeWrapper[str]),
            'is_deleted': ConjureFieldDefinition('isDeleted', bool)
        }

    __slots__: List[str] = ['_rid', '_api_key_name', '_created_by', '_created_at', '_expires_at', '_is_deleted']

    def __init__(self, api_key_name: str, created_at: str, created_by: str, is_deleted: bool, rid: str, expires_at: Optional[str] = None) -> None:
        self._rid = rid
        self._api_key_name = api_key_name
        self._created_by = created_by
        self._created_at = created_at
        self._expires_at = expires_at
        self._is_deleted = is_deleted

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def api_key_name(self) -> str:
        return self._api_key_name

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def expires_at(self) -> Optional[str]:
        return self._expires_at

    @builtins.property
    def is_deleted(self) -> bool:
        return self._is_deleted


authorization_ApiKey.__name__ = "ApiKey"
authorization_ApiKey.__qualname__ = "ApiKey"
authorization_ApiKey.__module__ = "nominal_api.authorization"


class authorization_AuthorizationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[str])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


authorization_AuthorizationRequest.__name__ = "AuthorizationRequest"
authorization_AuthorizationRequest.__qualname__ = "AuthorizationRequest"
authorization_AuthorizationRequest.__module__ = "nominal_api.authorization"


class authorization_AuthorizationService(Service):
    """Authorization service manages the permissions for a user
to access resources.
    """

    def authorize(self, auth_header: str, request: "authorization_AuthorizationRequest") -> List[str]:
        """Given a set of resources, returns the set of resources that the
user is authorized to access.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/authorize'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[str], self._return_none_for_unknown_union_types)

    def batch_get_workspace_for_resource(self, auth_header: str, request: List[str] = None) -> Dict[str, str]:
        """Given a set of resources, returns the workspace that each resource belongs to. If a user
is not authorized on the resource, will omit the resource from the response.
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/batch-get-workspace-for-resource'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[str, api_rids_WorkspaceRid], self._return_none_for_unknown_union_types)

    def register_in_workspace(self, auth_header: str, request: "authorization_RegisterInWorkspaceRequest") -> None:
        """Marks a set of resources as belonging to a workspace. Either all resources are
registered or none are.
If the user is not in the workspace, this will throw.
If a resource already belongs to a different workspace, this will throw.
If a resource already belongs to this workspace, this is a no-op.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/register-in-workspace'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def check_admin(self, auth_header: str) -> None:
        """Given an authenticated session, this endpoint returns a HTTP 204 if the
authenticated user is an admin and HTTP 403 otherwise.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/authorization/v1/checkAdmin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def is_email_allowed(self, request: "authorization_IsEmailAllowedRequest") -> "authorization_IsEmailAllowedResponse":
        """Checks if the email is allowed to register.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/is-email-allowed'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_IsEmailAllowedResponse, self._return_none_for_unknown_union_types)

    def is_email_allowed_okta(self, request: "authorization_OktaRegistrationRequest") -> "authorization_OktaRegistrationResponse":
        """Checks if the email is allowed to register, following Okta "registration inline hook" API.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/is-email-allowed-okta'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_OktaRegistrationResponse, self._return_none_for_unknown_union_types)

    def get_access_token(self, request: "authorization_GetAccessTokenRequest") -> "authorization_GetAccessTokenResponse":
        """Provide an OIDC ID token to get a Nominal access token suitable for making API requests.
Its expiry will match that of the input ID token, capped at 24h. TODO(MGMT-933): reduce this duration.
Throws NotAuthorized if the ID token is invalid or if the OIDC provider is not known.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/access-token'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_GetAccessTokenResponse, self._return_none_for_unknown_union_types)

    def refresh_access_token(self, request: "authorization_RefreshAccessTokenRequest") -> "authorization_RefreshAccessTokenResponse":
        """Given an authenticated session, provide an OIDC access token to get a Nominal access token suitable 
for making API requests. Its expiry will match that of the input access token, capped at 24h. TODO(MGMT-933): 
reduce this duration. Throws NotAuthorized if the access token is invalid or if the OIDC provider is not 
known.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/refresh-access-token'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_RefreshAccessTokenResponse, self._return_none_for_unknown_union_types)

    def create_api_key(self, auth_header: str, request: "authorization_CreateApiKeyRequest") -> "authorization_CreateApiKeyResponse":
        """Provide a long-lived API key for making API requests.
The API key is irretrievable after initial creation.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/api-key'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_CreateApiKeyResponse, self._return_none_for_unknown_union_types)

    def list_api_keys_in_org(self, auth_header: str, request: "authorization_ListApiKeyRequest") -> "authorization_ListApiKeyResponse":
        """List all API keys in the organization.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/api-keys/org'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_ListApiKeyResponse, self._return_none_for_unknown_union_types)

    def list_user_api_keys(self, auth_header: str, request: "authorization_ListApiKeyRequest") -> "authorization_ListApiKeyResponse":
        """List all API keys for the user.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/authorization/v1/api-keys/user'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_ListApiKeyResponse, self._return_none_for_unknown_union_types)

    def revoke_api_key(self, auth_header: str, rid: str) -> None:
        """Delete an API key.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/authorization/v1/api-key/{rid}/delete'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


authorization_AuthorizationService.__name__ = "AuthorizationService"
authorization_AuthorizationService.__qualname__ = "AuthorizationService"
authorization_AuthorizationService.__module__ = "nominal_api.authorization"


class authorization_Claim(ConjureUnionType):
    _string: Optional[str] = None
    _string_list: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'string': ConjureFieldDefinition('string', str),
            'string_list': ConjureFieldDefinition('stringList', List[str])
        }

    def __init__(
            self,
            string: Optional[str] = None,
            string_list: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (string is not None) + (string_list is not None) != 1:
                raise ValueError('a union must contain a single member')

            if string is not None:
                self._string = string
                self._type = 'string'
            if string_list is not None:
                self._string_list = string_list
                self._type = 'stringList'

        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'
        elif type_of_union == 'stringList':
            if string_list is None:
                raise ValueError('a union value must not be None')
            self._string_list = string_list
            self._type = 'stringList'

    @builtins.property
    def string(self) -> Optional[str]:
        return self._string

    @builtins.property
    def string_list(self) -> Optional[List[str]]:
        return self._string_list

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, authorization_ClaimVisitor):
            raise ValueError('{} is not an instance of authorization_ClaimVisitor'.format(visitor.__class__.__name__))
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)
        if self._type == 'stringList' and self.string_list is not None:
            return visitor._string_list(self.string_list)


authorization_Claim.__name__ = "Claim"
authorization_Claim.__qualname__ = "Claim"
authorization_Claim.__module__ = "nominal_api.authorization"


class authorization_ClaimVisitor:

    @abstractmethod
    def _string(self, string: str) -> Any:
        pass

    @abstractmethod
    def _string_list(self, string_list: List[str]) -> Any:
        pass


authorization_ClaimVisitor.__name__ = "ClaimVisitor"
authorization_ClaimVisitor.__qualname__ = "ClaimVisitor"
authorization_ClaimVisitor.__module__ = "nominal_api.authorization"


class authorization_CreateApiKeyRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key_name': ConjureFieldDefinition('apiKeyName', str),
            'expires_after_days': ConjureFieldDefinition('expiresAfterDays', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_api_key_name', '_expires_after_days']

    def __init__(self, api_key_name: str, expires_after_days: Optional[int] = None) -> None:
        self._api_key_name = api_key_name
        self._expires_after_days = expires_after_days

    @builtins.property
    def api_key_name(self) -> str:
        """The name of the API key to create.
        """
        return self._api_key_name

    @builtins.property
    def expires_after_days(self) -> Optional[int]:
        """The number of days after which the API key will expire.
If omitted, the API key will not expire.
        """
        return self._expires_after_days


authorization_CreateApiKeyRequest.__name__ = "CreateApiKeyRequest"
authorization_CreateApiKeyRequest.__qualname__ = "CreateApiKeyRequest"
authorization_CreateApiKeyRequest.__module__ = "nominal_api.authorization"


class authorization_CreateApiKeyResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key_metadata': ConjureFieldDefinition('apiKeyMetadata', authorization_ApiKey),
            'api_key_value': ConjureFieldDefinition('apiKeyValue', str)
        }

    __slots__: List[str] = ['_api_key_metadata', '_api_key_value']

    def __init__(self, api_key_metadata: "authorization_ApiKey", api_key_value: str) -> None:
        self._api_key_metadata = api_key_metadata
        self._api_key_value = api_key_value

    @builtins.property
    def api_key_metadata(self) -> "authorization_ApiKey":
        return self._api_key_metadata

    @builtins.property
    def api_key_value(self) -> str:
        return self._api_key_value


authorization_CreateApiKeyResponse.__name__ = "CreateApiKeyResponse"
authorization_CreateApiKeyResponse.__qualname__ = "CreateApiKeyResponse"
authorization_CreateApiKeyResponse.__module__ = "nominal_api.authorization"


class authorization_GetAccessTokenFromApiKeyRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key_value': ConjureFieldDefinition('apiKeyValue', str)
        }

    __slots__: List[str] = ['_api_key_value']

    def __init__(self, api_key_value: str) -> None:
        self._api_key_value = api_key_value

    @builtins.property
    def api_key_value(self) -> str:
        return self._api_key_value


authorization_GetAccessTokenFromApiKeyRequest.__name__ = "GetAccessTokenFromApiKeyRequest"
authorization_GetAccessTokenFromApiKeyRequest.__qualname__ = "GetAccessTokenFromApiKeyRequest"
authorization_GetAccessTokenFromApiKeyRequest.__module__ = "nominal_api.authorization"


class authorization_GetAccessTokenRequest(ConjureBeanType):
    """We accept an OIDC ID token issued by a trusted identity provider as proof of authentication.
The ID token is validated and exchanged for a Nominal access token.
This ID token should generally be short lived since it is fungible with a Nominal access token
via this endpoint.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id_token': ConjureFieldDefinition('idToken', str),
            'access_token': ConjureFieldDefinition('accessToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_id_token', '_access_token']

    def __init__(self, id_token: str, access_token: Optional[str] = None) -> None:
        self._id_token = id_token
        self._access_token = access_token

    @builtins.property
    def id_token(self) -> str:
        return self._id_token

    @builtins.property
    def access_token(self) -> Optional[str]:
        return self._access_token


authorization_GetAccessTokenRequest.__name__ = "GetAccessTokenRequest"
authorization_GetAccessTokenRequest.__qualname__ = "GetAccessTokenRequest"
authorization_GetAccessTokenRequest.__module__ = "nominal_api.authorization"


class authorization_GetAccessTokenResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'access_token': ConjureFieldDefinition('accessToken', str),
            'expires_at_seconds': ConjureFieldDefinition('expiresAtSeconds', int),
            'user_uuid': ConjureFieldDefinition('userUuid', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str)
        }

    __slots__: List[str] = ['_access_token', '_expires_at_seconds', '_user_uuid', '_org_uuid']

    def __init__(self, access_token: str, expires_at_seconds: int, org_uuid: str, user_uuid: str) -> None:
        self._access_token = access_token
        self._expires_at_seconds = expires_at_seconds
        self._user_uuid = user_uuid
        self._org_uuid = org_uuid

    @builtins.property
    def access_token(self) -> str:
        return self._access_token

    @builtins.property
    def expires_at_seconds(self) -> int:
        return self._expires_at_seconds

    @builtins.property
    def user_uuid(self) -> str:
        return self._user_uuid

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid


authorization_GetAccessTokenResponse.__name__ = "GetAccessTokenResponse"
authorization_GetAccessTokenResponse.__qualname__ = "GetAccessTokenResponse"
authorization_GetAccessTokenResponse.__module__ = "nominal_api.authorization"


class authorization_InternalApiKeyService(Service):
    """This internal-only service manages long lived api keys.e
    """

    def get_access_token_from_api_key_value(self, request: "authorization_GetAccessTokenFromApiKeyRequest") -> "authorization_GetAccessTokenResponse":
        """Get a Nominal-issued access token from a long-lived API key. Callers should verify that
their api key is formatted properly (i.e. prefixed with "nominal_api_key") before calling this endpoint.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/api-key-internal/v1/access-token'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), authorization_GetAccessTokenResponse, self._return_none_for_unknown_union_types)


authorization_InternalApiKeyService.__name__ = "InternalApiKeyService"
authorization_InternalApiKeyService.__qualname__ = "InternalApiKeyService"
authorization_InternalApiKeyService.__module__ = "nominal_api.authorization"


class authorization_IsEmailAllowedRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'email': ConjureFieldDefinition('email', str)
        }

    __slots__: List[str] = ['_email']

    def __init__(self, email: str) -> None:
        self._email = email

    @builtins.property
    def email(self) -> str:
        return self._email


authorization_IsEmailAllowedRequest.__name__ = "IsEmailAllowedRequest"
authorization_IsEmailAllowedRequest.__qualname__ = "IsEmailAllowedRequest"
authorization_IsEmailAllowedRequest.__module__ = "nominal_api.authorization"


class authorization_IsEmailAllowedResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'allowed': ConjureFieldDefinition('allowed', bool)
        }

    __slots__: List[str] = ['_allowed']

    def __init__(self, allowed: bool) -> None:
        self._allowed = allowed

    @builtins.property
    def allowed(self) -> bool:
        return self._allowed


authorization_IsEmailAllowedResponse.__name__ = "IsEmailAllowedResponse"
authorization_IsEmailAllowedResponse.__qualname__ = "IsEmailAllowedResponse"
authorization_IsEmailAllowedResponse.__module__ = "nominal_api.authorization"


class authorization_ListApiKeyRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'include_deleted': ConjureFieldDefinition('includeDeleted', OptionalTypeWrapper[bool]),
            'include_expired': ConjureFieldDefinition('includeExpired', OptionalTypeWrapper[bool]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_include_deleted', '_include_expired', '_page_size', '_next_page_token']

    def __init__(self, include_deleted: Optional[bool] = None, include_expired: Optional[bool] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._include_deleted = include_deleted
        self._include_expired = include_expired
        self._page_size = page_size
        self._next_page_token = next_page_token

    @builtins.property
    def include_deleted(self) -> Optional[bool]:
        """If true, include deleted API keys in the response. Defaults to false.
        """
        return self._include_deleted

    @builtins.property
    def include_expired(self) -> Optional[bool]:
        """If true, include expired API keys in the response. Defaults to false.
        """
        return self._include_expired

    @builtins.property
    def page_size(self) -> Optional[int]:
        """The maximum number of API keys to return. Defaults to 100.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


authorization_ListApiKeyRequest.__name__ = "ListApiKeyRequest"
authorization_ListApiKeyRequest.__qualname__ = "ListApiKeyRequest"
authorization_ListApiKeyRequest.__module__ = "nominal_api.authorization"


class authorization_ListApiKeyResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_keys': ConjureFieldDefinition('apiKeys', List[authorization_ApiKey]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_api_keys', '_next_page_token']

    def __init__(self, api_keys: List["authorization_ApiKey"], next_page_token: Optional[str] = None) -> None:
        self._api_keys = api_keys
        self._next_page_token = next_page_token

    @builtins.property
    def api_keys(self) -> List["authorization_ApiKey"]:
        return self._api_keys

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


authorization_ListApiKeyResponse.__name__ = "ListApiKeyResponse"
authorization_ListApiKeyResponse.__qualname__ = "ListApiKeyResponse"
authorization_ListApiKeyResponse.__module__ = "nominal_api.authorization"


class authorization_OktaRegistrationEventData(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'user_profile': ConjureFieldDefinition('userProfile', authorization_OktaRegistrationUserProfile)
        }

    __slots__: List[str] = ['_user_profile']

    def __init__(self, user_profile: "authorization_OktaRegistrationUserProfile") -> None:
        self._user_profile = user_profile

    @builtins.property
    def user_profile(self) -> "authorization_OktaRegistrationUserProfile":
        return self._user_profile


authorization_OktaRegistrationEventData.__name__ = "OktaRegistrationEventData"
authorization_OktaRegistrationEventData.__qualname__ = "OktaRegistrationEventData"
authorization_OktaRegistrationEventData.__module__ = "nominal_api.authorization"


class authorization_OktaRegistrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'request_type': ConjureFieldDefinition('requestType', str),
            'data': ConjureFieldDefinition('data', authorization_OktaRegistrationEventData)
        }

    __slots__: List[str] = ['_request_type', '_data']

    def __init__(self, data: "authorization_OktaRegistrationEventData", request_type: str) -> None:
        self._request_type = request_type
        self._data = data

    @builtins.property
    def request_type(self) -> str:
        return self._request_type

    @builtins.property
    def data(self) -> "authorization_OktaRegistrationEventData":
        return self._data


authorization_OktaRegistrationRequest.__name__ = "OktaRegistrationRequest"
authorization_OktaRegistrationRequest.__qualname__ = "OktaRegistrationRequest"
authorization_OktaRegistrationRequest.__module__ = "nominal_api.authorization"


class authorization_OktaRegistrationResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commands': ConjureFieldDefinition('commands', List[authorization_OktaUpdateActionCommand])
        }

    __slots__: List[str] = ['_commands']

    def __init__(self, commands: List["authorization_OktaUpdateActionCommand"]) -> None:
        self._commands = commands

    @builtins.property
    def commands(self) -> List["authorization_OktaUpdateActionCommand"]:
        return self._commands


authorization_OktaRegistrationResponse.__name__ = "OktaRegistrationResponse"
authorization_OktaRegistrationResponse.__qualname__ = "OktaRegistrationResponse"
authorization_OktaRegistrationResponse.__module__ = "nominal_api.authorization"


class authorization_OktaRegistrationStatus(ConjureEnumType):

    ALLOW = 'ALLOW'
    '''ALLOW'''
    DENY = 'DENY'
    '''DENY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


authorization_OktaRegistrationStatus.__name__ = "OktaRegistrationStatus"
authorization_OktaRegistrationStatus.__qualname__ = "OktaRegistrationStatus"
authorization_OktaRegistrationStatus.__module__ = "nominal_api.authorization"


class authorization_OktaRegistrationUserProfile(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'email': ConjureFieldDefinition('email', str)
        }

    __slots__: List[str] = ['_email']

    def __init__(self, email: str) -> None:
        self._email = email

    @builtins.property
    def email(self) -> str:
        return self._email


authorization_OktaRegistrationUserProfile.__name__ = "OktaRegistrationUserProfile"
authorization_OktaRegistrationUserProfile.__qualname__ = "OktaRegistrationUserProfile"
authorization_OktaRegistrationUserProfile.__module__ = "nominal_api.authorization"


class authorization_OktaUpdateActionCommand(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', str),
            'value': ConjureFieldDefinition('value', authorization_OktaUpdateActionValue)
        }

    __slots__: List[str] = ['_type', '_value']

    def __init__(self, type: str, value: "authorization_OktaUpdateActionValue") -> None:
        self._type = type
        self._value = value

    @builtins.property
    def type(self) -> str:
        return self._type

    @builtins.property
    def value(self) -> "authorization_OktaUpdateActionValue":
        return self._value


authorization_OktaUpdateActionCommand.__name__ = "OktaUpdateActionCommand"
authorization_OktaUpdateActionCommand.__qualname__ = "OktaUpdateActionCommand"
authorization_OktaUpdateActionCommand.__module__ = "nominal_api.authorization"


class authorization_OktaUpdateActionValue(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'registration': ConjureFieldDefinition('registration', authorization_OktaRegistrationStatus)
        }

    __slots__: List[str] = ['_registration']

    def __init__(self, registration: "authorization_OktaRegistrationStatus") -> None:
        self._registration = registration

    @builtins.property
    def registration(self) -> "authorization_OktaRegistrationStatus":
        return self._registration


authorization_OktaUpdateActionValue.__name__ = "OktaUpdateActionValue"
authorization_OktaUpdateActionValue.__qualname__ = "OktaUpdateActionValue"
authorization_OktaUpdateActionValue.__module__ = "nominal_api.authorization"


class authorization_RefreshAccessTokenRequest(ConjureBeanType):
    """We accept an OIDC access token issued by a trusted identity provider to refresh a Nominal access token.
The access token is validated and exchanged for a Nominal access token. To be used in this endpoint,
the OIDC access token must contain an email claim.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'access_token': ConjureFieldDefinition('accessToken', str)
        }

    __slots__: List[str] = ['_access_token']

    def __init__(self, access_token: str) -> None:
        self._access_token = access_token

    @builtins.property
    def access_token(self) -> str:
        return self._access_token


authorization_RefreshAccessTokenRequest.__name__ = "RefreshAccessTokenRequest"
authorization_RefreshAccessTokenRequest.__qualname__ = "RefreshAccessTokenRequest"
authorization_RefreshAccessTokenRequest.__module__ = "nominal_api.authorization"


class authorization_RefreshAccessTokenResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'access_token': ConjureFieldDefinition('accessToken', str),
            'expires_at_seconds': ConjureFieldDefinition('expiresAtSeconds', int),
            'user_uuid': ConjureFieldDefinition('userUuid', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str)
        }

    __slots__: List[str] = ['_access_token', '_expires_at_seconds', '_user_uuid', '_org_uuid']

    def __init__(self, access_token: str, expires_at_seconds: int, org_uuid: str, user_uuid: str) -> None:
        self._access_token = access_token
        self._expires_at_seconds = expires_at_seconds
        self._user_uuid = user_uuid
        self._org_uuid = org_uuid

    @builtins.property
    def access_token(self) -> str:
        return self._access_token

    @builtins.property
    def expires_at_seconds(self) -> int:
        return self._expires_at_seconds

    @builtins.property
    def user_uuid(self) -> str:
        return self._user_uuid

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid


authorization_RefreshAccessTokenResponse.__name__ = "RefreshAccessTokenResponse"
authorization_RefreshAccessTokenResponse.__qualname__ = "RefreshAccessTokenResponse"
authorization_RefreshAccessTokenResponse.__module__ = "nominal_api.authorization"


class authorization_RegisterInWorkspaceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rids': ConjureFieldDefinition('resourceRids', List[str]),
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid)
        }

    __slots__: List[str] = ['_resource_rids', '_workspace_rid']

    def __init__(self, resource_rids: List[str], workspace_rid: str) -> None:
        self._resource_rids = resource_rids
        self._workspace_rid = workspace_rid

    @builtins.property
    def resource_rids(self) -> List[str]:
        return self._resource_rids

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid


authorization_RegisterInWorkspaceRequest.__name__ = "RegisterInWorkspaceRequest"
authorization_RegisterInWorkspaceRequest.__qualname__ = "RegisterInWorkspaceRequest"
authorization_RegisterInWorkspaceRequest.__module__ = "nominal_api.authorization"


class comments_api_Comment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', comments_api_CommentRid),
            'parent': ConjureFieldDefinition('parent', comments_api_CommentParent),
            'author_rid': ConjureFieldDefinition('authorRid', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'edited_at': ConjureFieldDefinition('editedAt', OptionalTypeWrapper[str]),
            'deleted_at': ConjureFieldDefinition('deletedAt', OptionalTypeWrapper[str]),
            'content': ConjureFieldDefinition('content', str),
            'pinned_by': ConjureFieldDefinition('pinnedBy', OptionalTypeWrapper[str]),
            'pinned_at': ConjureFieldDefinition('pinnedAt', OptionalTypeWrapper[str]),
            'reactions': ConjureFieldDefinition('reactions', List[comments_api_Reaction]),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_rid', '_parent', '_author_rid', '_created_at', '_edited_at', '_deleted_at', '_content', '_pinned_by', '_pinned_at', '_reactions', '_attachments']

    def __init__(self, attachments: List[str], author_rid: str, content: str, created_at: str, parent: "comments_api_CommentParent", reactions: List["comments_api_Reaction"], rid: str, deleted_at: Optional[str] = None, edited_at: Optional[str] = None, pinned_at: Optional[str] = None, pinned_by: Optional[str] = None) -> None:
        self._rid = rid
        self._parent = parent
        self._author_rid = author_rid
        self._created_at = created_at
        self._edited_at = edited_at
        self._deleted_at = deleted_at
        self._content = content
        self._pinned_by = pinned_by
        self._pinned_at = pinned_at
        self._reactions = reactions
        self._attachments = attachments

    @builtins.property
    def rid(self) -> str:
        """Unique resource identifier for the comment
        """
        return self._rid

    @builtins.property
    def parent(self) -> "comments_api_CommentParent":
        """The parent of the comment. It can be a resource or another comment.
        """
        return self._parent

    @builtins.property
    def author_rid(self) -> str:
        """The user who authored the comment
        """
        return self._author_rid

    @builtins.property
    def created_at(self) -> str:
        """The time the comment was created
        """
        return self._created_at

    @builtins.property
    def edited_at(self) -> Optional[str]:
        """The time the comment was edited. Empty if the comment has not been edited.
        """
        return self._edited_at

    @builtins.property
    def deleted_at(self) -> Optional[str]:
        """The time the comment was deleted. Empty if the comment has not been deleted.
        """
        return self._deleted_at

    @builtins.property
    def content(self) -> str:
        """The markdown content of the comment.
        """
        return self._content

    @builtins.property
    def pinned_by(self) -> Optional[str]:
        """The user who pinned the comment. Empty if the comment is not pinned.
        """
        return self._pinned_by

    @builtins.property
    def pinned_at(self) -> Optional[str]:
        """The time the comment was pinned. Empty if the comment is not pinned.
        """
        return self._pinned_at

    @builtins.property
    def reactions(self) -> List["comments_api_Reaction"]:
        """The reactions on the comment
        """
        return self._reactions

    @builtins.property
    def attachments(self) -> List[str]:
        """The comment's attachments
        """
        return self._attachments


comments_api_Comment.__name__ = "Comment"
comments_api_Comment.__qualname__ = "Comment"
comments_api_Comment.__module__ = "nominal_api.comments_api"


class comments_api_CommentParent(ConjureUnionType):
    """The parent of a comment. It can be a resource or another comment in the case of a reply.
    """
    _resource: Optional["comments_api_CommentParentResource"] = None
    _comment: Optional["comments_api_CommentParentComment"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource': ConjureFieldDefinition('resource', comments_api_CommentParentResource),
            'comment': ConjureFieldDefinition('comment', comments_api_CommentParentComment)
        }

    def __init__(
            self,
            resource: Optional["comments_api_CommentParentResource"] = None,
            comment: Optional["comments_api_CommentParentComment"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (resource is not None) + (comment is not None) != 1:
                raise ValueError('a union must contain a single member')

            if resource is not None:
                self._resource = resource
                self._type = 'resource'
            if comment is not None:
                self._comment = comment
                self._type = 'comment'

        elif type_of_union == 'resource':
            if resource is None:
                raise ValueError('a union value must not be None')
            self._resource = resource
            self._type = 'resource'
        elif type_of_union == 'comment':
            if comment is None:
                raise ValueError('a union value must not be None')
            self._comment = comment
            self._type = 'comment'

    @builtins.property
    def resource(self) -> Optional["comments_api_CommentParentResource"]:
        return self._resource

    @builtins.property
    def comment(self) -> Optional["comments_api_CommentParentComment"]:
        return self._comment

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, comments_api_CommentParentVisitor):
            raise ValueError('{} is not an instance of comments_api_CommentParentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'resource' and self.resource is not None:
            return visitor._resource(self.resource)
        if self._type == 'comment' and self.comment is not None:
            return visitor._comment(self.comment)


comments_api_CommentParent.__name__ = "CommentParent"
comments_api_CommentParent.__qualname__ = "CommentParent"
comments_api_CommentParent.__module__ = "nominal_api.comments_api"


class comments_api_CommentParentVisitor:

    @abstractmethod
    def _resource(self, resource: "comments_api_CommentParentResource") -> Any:
        pass

    @abstractmethod
    def _comment(self, comment: "comments_api_CommentParentComment") -> Any:
        pass


comments_api_CommentParentVisitor.__name__ = "CommentParentVisitor"
comments_api_CommentParentVisitor.__qualname__ = "CommentParentVisitor"
comments_api_CommentParentVisitor.__module__ = "nominal_api.comments_api"


class comments_api_CommentParentComment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment_rid': ConjureFieldDefinition('commentRid', comments_api_CommentRid)
        }

    __slots__: List[str] = ['_comment_rid']

    def __init__(self, comment_rid: str) -> None:
        self._comment_rid = comment_rid

    @builtins.property
    def comment_rid(self) -> str:
        """The resource identifier for the comment that the comment is replying to
        """
        return self._comment_rid


comments_api_CommentParentComment.__name__ = "CommentParentComment"
comments_api_CommentParentComment.__qualname__ = "CommentParentComment"
comments_api_CommentParentComment.__module__ = "nominal_api.comments_api"


class comments_api_CommentParentResource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_type': ConjureFieldDefinition('resourceType', comments_api_ResourceType),
            'resource_rid': ConjureFieldDefinition('resourceRid', str)
        }

    __slots__: List[str] = ['_resource_type', '_resource_rid']

    def __init__(self, resource_rid: str, resource_type: "comments_api_ResourceType") -> None:
        self._resource_type = resource_type
        self._resource_rid = resource_rid

    @builtins.property
    def resource_type(self) -> "comments_api_ResourceType":
        """The type of resource that the comment is associated with
        """
        return self._resource_type

    @builtins.property
    def resource_rid(self) -> str:
        """The resource identifier for the resource that the comment is associated with. For example, a run or a workbook.
        """
        return self._resource_rid


comments_api_CommentParentResource.__name__ = "CommentParentResource"
comments_api_CommentParentResource.__qualname__ = "CommentParentResource"
comments_api_CommentParentResource.__module__ = "nominal_api.comments_api"


class comments_api_CommentsService(Service):
    """Comments service manages conversations about resources.
    """

    def get_conversation(self, auth_header: str, resource_rid: str, resource_type: "comments_api_ResourceType") -> "comments_api_Conversation":
        """A conversation is a fully resolved comment tree. It includes all comments for the given resource
and all the nested comments/replies to those comments.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceType': quote(str(_conjure_encoder.default(resource_type)), safe=''),
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/conversations/{resourceType}/{resourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Conversation, self._return_none_for_unknown_union_types)

    def get_conversation_count(self, auth_header: str, resource_rid: str, resource_type: "comments_api_ResourceType", include_deleted: Optional[bool] = None) -> int:
        """Returns the number of comments in a conversation.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeDeleted': _conjure_encoder.default(include_deleted),
        }

        _path_params: Dict[str, str] = {
            'resourceType': quote(str(_conjure_encoder.default(resource_type)), safe=''),
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/conversations/{resourceType}/{resourceRid}/count'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), int, self._return_none_for_unknown_union_types)

    def get_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """Get a comment identified by its RID
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def create_comment(self, auth_header: str, request: "comments_api_CreateCommentRequest") -> "comments_api_Comment":
        """Create a comment on a resource
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/comments/v1/comments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def edit_comment(self, auth_header: str, comment_rid: str, request: "comments_api_EditCommentRequest") -> "comments_api_Comment":
        """Edit an existing comment
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def delete_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """Delete an existing comment
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def pin_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """Pin a comment to the top of the conversation
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/pin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def unpin_comment(self, auth_header: str, comment_rid: str) -> "comments_api_Comment":
        """Unpin a comment from the top of the conversation
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/pin'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def add_reaction(self, auth_header: str, comment_rid: str, type: "comments_api_ReactionType") -> "comments_api_Comment":
        """Create a reaction on a comment
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
            'type': quote(str(_conjure_encoder.default(type)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/reactions/{type}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)

    def remove_reaction(self, auth_header: str, comment_rid: str, type: "comments_api_ReactionType") -> "comments_api_Comment":
        """Create a reaction on a comment
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'commentRid': quote(str(_conjure_encoder.default(comment_rid)), safe=''),
            'type': quote(str(_conjure_encoder.default(type)), safe=''),
        }

        _json: Any = None

        _path = '/comments/v1/comments/{commentRid}/reactions/{type}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), comments_api_Comment, self._return_none_for_unknown_union_types)


comments_api_CommentsService.__name__ = "CommentsService"
comments_api_CommentsService.__qualname__ = "CommentsService"
comments_api_CommentsService.__module__ = "nominal_api.comments_api"


class comments_api_Conversation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'resource_type': ConjureFieldDefinition('resourceType', comments_api_ResourceType),
            'comments': ConjureFieldDefinition('comments', List[comments_api_ConversationNode])
        }

    __slots__: List[str] = ['_resource_rid', '_resource_type', '_comments']

    def __init__(self, comments: List["comments_api_ConversationNode"], resource_rid: str, resource_type: "comments_api_ResourceType") -> None:
        self._resource_rid = resource_rid
        self._resource_type = resource_type
        self._comments = comments

    @builtins.property
    def resource_rid(self) -> str:
        """RID for the resource that the conversation is associated with.
        """
        return self._resource_rid

    @builtins.property
    def resource_type(self) -> "comments_api_ResourceType":
        """The type of the resource that the conversation is associated with.
        """
        return self._resource_type

    @builtins.property
    def comments(self) -> List["comments_api_ConversationNode"]:
        """The comments on the conversation ordered by creation time.
Empty if the comment has no replies.
        """
        return self._comments


comments_api_Conversation.__name__ = "Conversation"
comments_api_Conversation.__qualname__ = "Conversation"
comments_api_Conversation.__module__ = "nominal_api.comments_api"


class comments_api_ConversationNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', comments_api_Comment),
            'replies': ConjureFieldDefinition('replies', List[comments_api_ConversationNode])
        }

    __slots__: List[str] = ['_comment', '_replies']

    def __init__(self, comment: "comments_api_Comment", replies: List["comments_api_ConversationNode"]) -> None:
        self._comment = comment
        self._replies = replies

    @builtins.property
    def comment(self) -> "comments_api_Comment":
        """The comment
        """
        return self._comment

    @builtins.property
    def replies(self) -> List["comments_api_ConversationNode"]:
        """The comments on (aka replies to) the comment ordered by creation time. Empty if the comment has no replies.
        """
        return self._replies


comments_api_ConversationNode.__name__ = "ConversationNode"
comments_api_ConversationNode.__qualname__ = "ConversationNode"
comments_api_ConversationNode.__module__ = "nominal_api.comments_api"


class comments_api_CreateCommentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parent': ConjureFieldDefinition('parent', comments_api_CommentParent),
            'content': ConjureFieldDefinition('content', str),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_parent', '_content', '_attachments']

    def __init__(self, attachments: List[str], content: str, parent: "comments_api_CommentParent") -> None:
        self._parent = parent
        self._content = content
        self._attachments = attachments

    @builtins.property
    def parent(self) -> "comments_api_CommentParent":
        return self._parent

    @builtins.property
    def content(self) -> str:
        """The content of the comment. Markdown supported.
        """
        return self._content

    @builtins.property
    def attachments(self) -> List[str]:
        """Attachments to the comment.
        """
        return self._attachments


comments_api_CreateCommentRequest.__name__ = "CreateCommentRequest"
comments_api_CreateCommentRequest.__qualname__ = "CreateCommentRequest"
comments_api_CreateCommentRequest.__module__ = "nominal_api.comments_api"


class comments_api_EditCommentRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'content': ConjureFieldDefinition('content', str),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_content', '_attachments']

    def __init__(self, attachments: List[str], content: str) -> None:
        self._content = content
        self._attachments = attachments

    @builtins.property
    def content(self) -> str:
        """The content of the comment. Markdown supported.
        """
        return self._content

    @builtins.property
    def attachments(self) -> List[str]:
        """Attachments to the comment.
        """
        return self._attachments


comments_api_EditCommentRequest.__name__ = "EditCommentRequest"
comments_api_EditCommentRequest.__qualname__ = "EditCommentRequest"
comments_api_EditCommentRequest.__module__ = "nominal_api.comments_api"


class comments_api_Reaction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', comments_api_ReactionRid),
            'user_rid': ConjureFieldDefinition('userRid', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'type': ConjureFieldDefinition('type', comments_api_ReactionType)
        }

    __slots__: List[str] = ['_rid', '_user_rid', '_created_at', '_type']

    def __init__(self, created_at: str, rid: str, type: "comments_api_ReactionType", user_rid: str) -> None:
        self._rid = rid
        self._user_rid = user_rid
        self._created_at = created_at
        self._type = type

    @builtins.property
    def rid(self) -> str:
        """Unique resource identifier for the reaction
        """
        return self._rid

    @builtins.property
    def user_rid(self) -> str:
        """The user who authored the reaction
        """
        return self._user_rid

    @builtins.property
    def created_at(self) -> str:
        """The time the reaction was created
        """
        return self._created_at

    @builtins.property
    def type(self) -> "comments_api_ReactionType":
        """The type of reaction
        """
        return self._type


comments_api_Reaction.__name__ = "Reaction"
comments_api_Reaction.__qualname__ = "Reaction"
comments_api_Reaction.__module__ = "nominal_api.comments_api"


class comments_api_ReactionType(ConjureEnumType):

    LIKE = 'LIKE'
    '''LIKE'''
    DISLIKE = 'DISLIKE'
    '''DISLIKE'''
    HEART = 'HEART'
    '''HEART'''
    HOORAY = 'HOORAY'
    '''HOORAY'''
    ROCKET = 'ROCKET'
    '''ROCKET'''
    EYES = 'EYES'
    '''EYES'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


comments_api_ReactionType.__name__ = "ReactionType"
comments_api_ReactionType.__qualname__ = "ReactionType"
comments_api_ReactionType.__module__ = "nominal_api.comments_api"


class comments_api_ResourceType(ConjureEnumType):

    RUN = 'RUN'
    '''RUN'''
    EVENT = 'EVENT'
    '''EVENT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


comments_api_ResourceType.__name__ = "ResourceType"
comments_api_ResourceType.__qualname__ = "ResourceType"
comments_api_ResourceType.__module__ = "nominal_api.comments_api"


class connect_download_Platform(ConjureEnumType):

    WINDOWS = 'WINDOWS'
    '''WINDOWS'''
    UBUNTU = 'UBUNTU'
    '''UBUNTU'''
    MACOS = 'MACOS'
    '''MACOS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


connect_download_Platform.__name__ = "Platform"
connect_download_Platform.__qualname__ = "Platform"
connect_download_Platform.__module__ = "nominal_api.connect_download"


class datasource_TimestampType(ConjureEnumType):

    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


datasource_TimestampType.__name__ = "TimestampType"
datasource_TimestampType.__qualname__ = "TimestampType"
datasource_TimestampType.__module__ = "nominal_api.datasource"


class datasource_VideoFileMetadata(ConjureBeanType):
    """Metadata specific to video files.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoFileTimestampManifest),
            'segment_metadata': ConjureFieldDefinition('segmentMetadata', OptionalTypeWrapper[datasource_VideoSegmentsMetadata])
        }

    __slots__: List[str] = ['_timestamp_manifest', '_segment_metadata']

    def __init__(self, timestamp_manifest: "scout_video_api_VideoFileTimestampManifest", segment_metadata: Optional["datasource_VideoSegmentsMetadata"] = None) -> None:
        self._timestamp_manifest = timestamp_manifest
        self._segment_metadata = segment_metadata

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoFileTimestampManifest":
        """Specifies how to determine absolute timestamps for each frame in the video.
Can be an embedded MCAP manifest, an external sidecar file, or calculated
from a starting offset applied to presentation timestamps.
        """
        return self._timestamp_manifest

    @builtins.property
    def segment_metadata(self) -> Optional["datasource_VideoSegmentsMetadata"]:
        """Cached aggregate metadata about the segments comprising this video file
after segmentation has completed. Includes frame counts, duration, and
frame rate. Empty until segmentation is complete.
Note: Min/max timestamps are stored in DatasetFile.bounds field.
Raw file size is stored in DatasetFile.fileSizeBytes.
        """
        return self._segment_metadata


datasource_VideoFileMetadata.__name__ = "VideoFileMetadata"
datasource_VideoFileMetadata.__qualname__ = "VideoFileMetadata"
datasource_VideoFileMetadata.__module__ = "nominal_api.datasource"


class datasource_VideoSegmentsMetadata(ConjureBeanType):
    """Segment metadata for video files.
Lightweight version that excludes bounds and RID since those are stored elsewhere.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_frames': ConjureFieldDefinition('numFrames', int),
            'num_segments': ConjureFieldDefinition('numSegments', int),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float),
            'media_duration_seconds': ConjureFieldDefinition('mediaDurationSeconds', float),
            'media_frame_rate': ConjureFieldDefinition('mediaFrameRate', float)
        }

    __slots__: List[str] = ['_num_frames', '_num_segments', '_scale_factor', '_media_duration_seconds', '_media_frame_rate']

    def __init__(self, media_duration_seconds: float, media_frame_rate: float, num_frames: int, num_segments: int, scale_factor: float) -> None:
        self._num_frames = num_frames
        self._num_segments = num_segments
        self._scale_factor = scale_factor
        self._media_duration_seconds = media_duration_seconds
        self._media_frame_rate = media_frame_rate

    @builtins.property
    def num_frames(self) -> int:
        """Total number of frames across all segments.
        """
        return self._num_frames

    @builtins.property
    def num_segments(self) -> int:
        """Number of segments the video was split into.
        """
        return self._num_segments

    @builtins.property
    def scale_factor(self) -> float:
        """Scale factor applied to timestamps during segmentation.
        """
        return self._scale_factor

    @builtins.property
    def media_duration_seconds(self) -> float:
        """Total duration of the video in seconds.
        """
        return self._media_duration_seconds

    @builtins.property
    def media_frame_rate(self) -> float:
        """Average frame rate (FPS) calculated as total frames / duration.
        """
        return self._media_frame_rate


datasource_VideoSegmentsMetadata.__name__ = "VideoSegmentsMetadata"
datasource_VideoSegmentsMetadata.__qualname__ = "VideoSegmentsMetadata"
datasource_VideoSegmentsMetadata.__module__ = "nominal_api.datasource"


class datasource_api_BatchGetChannelPrefixTreeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rids': ConjureFieldDefinition('dataSourceRids', List[api_rids_DataSourceRid]),
            'data_scope_filters': ConjureFieldDefinition('dataScopeFilters', OptionalTypeWrapper[datasource_api_DataScopeFilters])
        }

    __slots__: List[str] = ['_data_source_rids', '_data_scope_filters']

    def __init__(self, data_source_rids: List[str], data_scope_filters: Optional["datasource_api_DataScopeFilters"] = None) -> None:
        self._data_source_rids = data_source_rids
        self._data_scope_filters = data_scope_filters

    @builtins.property
    def data_source_rids(self) -> List[str]:
        return self._data_source_rids

    @builtins.property
    def data_scope_filters(self) -> Optional["datasource_api_DataScopeFilters"]:
        """When dataScopeFilters are specified, the set of data sources must match the set of data sources in
DataScopeFilters#tags
        """
        return self._data_scope_filters


datasource_api_BatchGetChannelPrefixTreeRequest.__name__ = "BatchGetChannelPrefixTreeRequest"
datasource_api_BatchGetChannelPrefixTreeRequest.__qualname__ = "BatchGetChannelPrefixTreeRequest"
datasource_api_BatchGetChannelPrefixTreeRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_BatchGetChannelPrefixTreeResponse(ConjureBeanType):
    """If the tree for a data source has not been indexed, it will be omitted from the map.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_prefix_trees': ConjureFieldDefinition('channelPrefixTrees', Dict[api_rids_DataSourceRid, datasource_api_ChannelPrefixTree])
        }

    __slots__: List[str] = ['_channel_prefix_trees']

    def __init__(self, channel_prefix_trees: Dict[str, "datasource_api_ChannelPrefixTree"]) -> None:
        self._channel_prefix_trees = channel_prefix_trees

    @builtins.property
    def channel_prefix_trees(self) -> Dict[str, "datasource_api_ChannelPrefixTree"]:
        return self._channel_prefix_trees


datasource_api_BatchGetChannelPrefixTreeResponse.__name__ = "BatchGetChannelPrefixTreeResponse"
datasource_api_BatchGetChannelPrefixTreeResponse.__qualname__ = "BatchGetChannelPrefixTreeResponse"
datasource_api_BatchGetChannelPrefixTreeResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_BatchGetDataScopeBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[datasource_api_GetDataScopeBoundsRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["datasource_api_GetDataScopeBoundsRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["datasource_api_GetDataScopeBoundsRequest"]:
        return self._requests


datasource_api_BatchGetDataScopeBoundsRequest.__name__ = "BatchGetDataScopeBoundsRequest"
datasource_api_BatchGetDataScopeBoundsRequest.__qualname__ = "BatchGetDataScopeBoundsRequest"
datasource_api_BatchGetDataScopeBoundsRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_BatchGetDataScopeBoundsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[datasource_api_GetDataScopeBoundsResponse])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["datasource_api_GetDataScopeBoundsResponse"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["datasource_api_GetDataScopeBoundsResponse"]:
        return self._responses


datasource_api_BatchGetDataScopeBoundsResponse.__name__ = "BatchGetDataScopeBoundsResponse"
datasource_api_BatchGetDataScopeBoundsResponse.__qualname__ = "BatchGetDataScopeBoundsResponse"
datasource_api_BatchGetDataScopeBoundsResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', api_rids_DataSourceRid),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_run_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[api_SeriesDataType]),
            'series_rid': ConjureFieldDefinition('seriesRid', datasource_api_SeriesMetadataRidOrLogicalSeriesRid)
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type', '_series_rid']

    def __init__(self, data_source: str, name: str, series_rid: "datasource_api_SeriesMetadataRidOrLogicalSeriesRid", data_type: Optional["api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["scout_run_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type
        self._series_rid = series_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> str:
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["scout_run_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["api_SeriesDataType"]:
        return self._data_type

    @builtins.property
    def series_rid(self) -> "datasource_api_SeriesMetadataRidOrLogicalSeriesRid":
        return self._series_rid


datasource_api_ChannelMetadata.__name__ = "ChannelMetadata"
datasource_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
datasource_api_ChannelMetadata.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelOrPrefix(ConjureUnionType):
    _channel: Optional["datasource_api_ChannelMetadata"] = None
    _prefix: Optional["datasource_api_DataSourcePrefixNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', datasource_api_ChannelMetadata),
            'prefix': ConjureFieldDefinition('prefix', datasource_api_DataSourcePrefixNode)
        }

    def __init__(
            self,
            channel: Optional["datasource_api_ChannelMetadata"] = None,
            prefix: Optional["datasource_api_DataSourcePrefixNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (prefix is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if prefix is not None:
                self._prefix = prefix
                self._type = 'prefix'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'prefix':
            if prefix is None:
                raise ValueError('a union value must not be None')
            self._prefix = prefix
            self._type = 'prefix'

    @builtins.property
    def channel(self) -> Optional["datasource_api_ChannelMetadata"]:
        return self._channel

    @builtins.property
    def prefix(self) -> Optional["datasource_api_DataSourcePrefixNode"]:
        return self._prefix

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_api_ChannelOrPrefixVisitor):
            raise ValueError('{} is not an instance of datasource_api_ChannelOrPrefixVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'prefix' and self.prefix is not None:
            return visitor._prefix(self.prefix)


datasource_api_ChannelOrPrefix.__name__ = "ChannelOrPrefix"
datasource_api_ChannelOrPrefix.__qualname__ = "ChannelOrPrefix"
datasource_api_ChannelOrPrefix.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelOrPrefixVisitor:

    @abstractmethod
    def _channel(self, channel: "datasource_api_ChannelMetadata") -> Any:
        pass

    @abstractmethod
    def _prefix(self, prefix: "datasource_api_DataSourcePrefixNode") -> Any:
        pass


datasource_api_ChannelOrPrefixVisitor.__name__ = "ChannelOrPrefixVisitor"
datasource_api_ChannelOrPrefixVisitor.__qualname__ = "ChannelOrPrefixVisitor"
datasource_api_ChannelOrPrefixVisitor.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelPrefixTree(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'roots': ConjureFieldDefinition('roots', List[datasource_api_ChannelPrefixTreeNode]),
            'delimiter': ConjureFieldDefinition('delimiter', str)
        }

    __slots__: List[str] = ['_roots', '_delimiter']

    def __init__(self, delimiter: str, roots: List["datasource_api_ChannelPrefixTreeNode"]) -> None:
        self._roots = roots
        self._delimiter = delimiter

    @builtins.property
    def roots(self) -> List["datasource_api_ChannelPrefixTreeNode"]:
        return self._roots

    @builtins.property
    def delimiter(self) -> str:
        return self._delimiter


datasource_api_ChannelPrefixTree.__name__ = "ChannelPrefixTree"
datasource_api_ChannelPrefixTree.__qualname__ = "ChannelPrefixTree"
datasource_api_ChannelPrefixTree.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelPrefixTreeNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part': ConjureFieldDefinition('part', str),
            'children': ConjureFieldDefinition('children', List[datasource_api_ChannelPrefixTreeNode])
        }

    __slots__: List[str] = ['_part', '_children']

    def __init__(self, children: List["datasource_api_ChannelPrefixTreeNode"], part: str) -> None:
        self._part = part
        self._children = children

    @builtins.property
    def part(self) -> str:
        """Should be combined with the ancestor parts and the delimiter to form the full prefix.
        """
        return self._part

    @builtins.property
    def children(self) -> List["datasource_api_ChannelPrefixTreeNode"]:
        return self._children


datasource_api_ChannelPrefixTreeNode.__name__ = "ChannelPrefixTreeNode"
datasource_api_ChannelPrefixTreeNode.__qualname__ = "ChannelPrefixTreeNode"
datasource_api_ChannelPrefixTreeNode.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelWithAvailableTags(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'available_tags': ConjureFieldDefinition('availableTags', Dict[api_TagName, List[api_TagValue]])
        }

    __slots__: List[str] = ['_data_source_rid', '_channel', '_available_tags']

    def __init__(self, available_tags: Dict[str, List[str]], channel: str, data_source_rid: str) -> None:
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._available_tags = available_tags

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def available_tags(self) -> Dict[str, List[str]]:
        """A set of tag keys and their values given the initial set of filters. The initial tag filters
will be included in the map with their corresponding values.
        """
        return self._available_tags


datasource_api_ChannelWithAvailableTags.__name__ = "ChannelWithAvailableTags"
datasource_api_ChannelWithAvailableTags.__qualname__ = "ChannelWithAvailableTags"
datasource_api_ChannelWithAvailableTags.__module__ = "nominal_api.datasource_api"


class datasource_api_ChannelWithTagFilters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tag_filters': ConjureFieldDefinition('tagFilters', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source_rid', '_channel', '_tag_filters']

    def __init__(self, channel: str, data_source_rid: str, tag_filters: Dict[str, str]) -> None:
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._tag_filters = tag_filters

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tag_filters(self) -> Dict[str, str]:
        return self._tag_filters


datasource_api_ChannelWithTagFilters.__name__ = "ChannelWithTagFilters"
datasource_api_ChannelWithTagFilters.__qualname__ = "ChannelWithTagFilters"
datasource_api_ChannelWithTagFilters.__module__ = "nominal_api.datasource_api"


class datasource_api_DataScopeFilters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tags': ConjureFieldDefinition('tags', Dict[api_rids_DataSourceRid, Dict[api_TagName, api_TagValue]]),
            'min_data_updated_time': ConjureFieldDefinition('minDataUpdatedTime', scout_run_api_UtcTimestamp),
            'max_data_start_time': ConjureFieldDefinition('maxDataStartTime', scout_run_api_UtcTimestamp)
        }

    __slots__: List[str] = ['_tags', '_min_data_updated_time', '_max_data_start_time']

    def __init__(self, max_data_start_time: "scout_run_api_UtcTimestamp", min_data_updated_time: "scout_run_api_UtcTimestamp", tags: Dict[str, Dict[str, str]]) -> None:
        self._tags = tags
        self._min_data_updated_time = min_data_updated_time
        self._max_data_start_time = max_data_start_time

    @builtins.property
    def tags(self) -> Dict[str, Dict[str, str]]:
        """For each data source specified as a key, search will only return channels containing a superset of the 
tags specified for that given datasource.
        """
        return self._tags

    @builtins.property
    def min_data_updated_time(self) -> "scout_run_api_UtcTimestamp":
        """Will only return channels that have had new data after the specified time.
        """
        return self._min_data_updated_time

    @builtins.property
    def max_data_start_time(self) -> "scout_run_api_UtcTimestamp":
        """Will only return channels that have data before the specified time.
        """
        return self._max_data_start_time


datasource_api_DataScopeFilters.__name__ = "DataScopeFilters"
datasource_api_DataScopeFilters.__qualname__ = "DataScopeFilters"
datasource_api_DataScopeFilters.__module__ = "nominal_api.datasource_api"


class datasource_api_DataSourcePrefixNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part': ConjureFieldDefinition('part', str),
            'data_source': ConjureFieldDefinition('dataSource', api_rids_DataSourceRid)
        }

    __slots__: List[str] = ['_part', '_data_source']

    def __init__(self, data_source: str, part: str) -> None:
        self._part = part
        self._data_source = data_source

    @builtins.property
    def part(self) -> str:
        """Should be combined with the ancestor parts and the delimiter to form the full prefix.
        """
        return self._part

    @builtins.property
    def data_source(self) -> str:
        return self._data_source


datasource_api_DataSourcePrefixNode.__name__ = "DataSourcePrefixNode"
datasource_api_DataSourcePrefixNode.__qualname__ = "DataSourcePrefixNode"
datasource_api_DataSourcePrefixNode.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagKeysRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filters': ConjureFieldDefinition('filters', datasource_api_TagSearchFilters),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_TagName]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_filters', '_next_page_token', '_page_size']

    def __init__(self, filters: "datasource_api_TagSearchFilters", next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._filters = filters
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def filters(self) -> "datasource_api_TagSearchFilters":
        return self._filters

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        return self._page_size


datasource_api_GetAvailableTagKeysRequest.__name__ = "GetAvailableTagKeysRequest"
datasource_api_GetAvailableTagKeysRequest.__qualname__ = "GetAvailableTagKeysRequest"
datasource_api_GetAvailableTagKeysRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagKeysResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[api_TagName]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_TagName])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List[str], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List[str]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_api_GetAvailableTagKeysResponse.__name__ = "GetAvailableTagKeysResponse"
datasource_api_GetAvailableTagKeysResponse.__qualname__ = "GetAvailableTagKeysResponse"
datasource_api_GetAvailableTagKeysResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagValuesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filters': ConjureFieldDefinition('filters', datasource_api_TagSearchFilters),
            'tag_name': ConjureFieldDefinition('tagName', api_TagName),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_TagValue]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_filters', '_tag_name', '_next_page_token', '_page_size']

    def __init__(self, filters: "datasource_api_TagSearchFilters", tag_name: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._filters = filters
        self._tag_name = tag_name
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def filters(self) -> "datasource_api_TagSearchFilters":
        return self._filters

    @builtins.property
    def tag_name(self) -> str:
        return self._tag_name

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 1000. Will throw if larger than 10000.
        """
        return self._page_size


datasource_api_GetAvailableTagValuesRequest.__name__ = "GetAvailableTagValuesRequest"
datasource_api_GetAvailableTagValuesRequest.__qualname__ = "GetAvailableTagValuesRequest"
datasource_api_GetAvailableTagValuesRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagValuesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[api_TagValue]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_TagValue])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List[str], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List[str]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_api_GetAvailableTagValuesResponse.__name__ = "GetAvailableTagValuesResponse"
datasource_api_GetAvailableTagValuesResponse.__qualname__ = "GetAvailableTagValuesResponse"
datasource_api_GetAvailableTagValuesResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagsForChannelRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_with_tag_filters': ConjureFieldDefinition('channelWithTagFilters', datasource_api_ChannelWithTagFilters),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', scout_run_api_UtcTimestamp)
        }

    __slots__: List[str] = ['_channel_with_tag_filters', '_start_time', '_end_time']

    def __init__(self, channel_with_tag_filters: "datasource_api_ChannelWithTagFilters", end_time: "scout_run_api_UtcTimestamp", start_time: "scout_run_api_UtcTimestamp") -> None:
        self._channel_with_tag_filters = channel_with_tag_filters
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def channel_with_tag_filters(self) -> "datasource_api_ChannelWithTagFilters":
        return self._channel_with_tag_filters

    @builtins.property
    def start_time(self) -> "scout_run_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> "scout_run_api_UtcTimestamp":
        return self._end_time


datasource_api_GetAvailableTagsForChannelRequest.__name__ = "GetAvailableTagsForChannelRequest"
datasource_api_GetAvailableTagsForChannelRequest.__qualname__ = "GetAvailableTagsForChannelRequest"
datasource_api_GetAvailableTagsForChannelRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_GetAvailableTagsForChannelResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'available_tags': ConjureFieldDefinition('availableTags', datasource_api_ChannelWithAvailableTags)
        }

    __slots__: List[str] = ['_available_tags']

    def __init__(self, available_tags: "datasource_api_ChannelWithAvailableTags") -> None:
        self._available_tags = available_tags

    @builtins.property
    def available_tags(self) -> "datasource_api_ChannelWithAvailableTags":
        return self._available_tags


datasource_api_GetAvailableTagsForChannelResponse.__name__ = "GetAvailableTagsForChannelResponse"
datasource_api_GetAvailableTagsForChannelResponse.__qualname__ = "GetAvailableTagsForChannelResponse"
datasource_api_GetAvailableTagsForChannelResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_GetDataScopeBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source_rid', '_tags']

    def __init__(self, data_source_rid: str, tags: Dict[str, str]) -> None:
        self._data_source_rid = data_source_rid
        self._tags = tags

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


datasource_api_GetDataScopeBoundsRequest.__name__ = "GetDataScopeBoundsRequest"
datasource_api_GetDataScopeBoundsRequest.__qualname__ = "GetDataScopeBoundsRequest"
datasource_api_GetDataScopeBoundsRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_GetDataScopeBoundsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_end_time']

    def __init__(self, end_time: Optional["api_Timestamp"] = None) -> None:
        self._end_time = end_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        """If missing, the end bound is not known definitively. This can happen if the
data scope corresponds to an external database or its data was not updated in the last month.
        """
        return self._end_time


datasource_api_GetDataScopeBoundsResponse.__name__ = "GetDataScopeBoundsResponse"
datasource_api_GetDataScopeBoundsResponse.__qualname__ = "GetDataScopeBoundsResponse"
datasource_api_GetDataScopeBoundsResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_GetTagValuesForDataSourceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tag_keys': ConjureFieldDefinition('tagKeys', OptionalTypeWrapper[List[api_TagName]]),
            'range': ConjureFieldDefinition('range', OptionalTypeWrapper[api_Range]),
            'max_values_per_key': ConjureFieldDefinition('maxValuesPerKey', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_tag_keys', '_range', '_max_values_per_key']

    def __init__(self, max_values_per_key: Optional[int] = None, range: Optional["api_Range"] = None, tag_keys: Optional[List[str]] = None) -> None:
        self._tag_keys = tag_keys
        self._range = range
        self._max_values_per_key = max_values_per_key

    @builtins.property
    def tag_keys(self) -> Optional[List[str]]:
        """If empty, returns all available tag keys.
        """
        return self._tag_keys

    @builtins.property
    def range(self) -> Optional["api_Range"]:
        """For Nominal data sources, a time range can be provided to filter tag values to those present within the 
months spanned by the range. If left empty, this defaults to the last month. For external data sources, 
the range must not be specified, as all tag values are returned.
        """
        return self._range

    @builtins.property
    def max_values_per_key(self) -> Optional[int]:
        """If supplied, caps the number of values per key at the specified value.
        """
        return self._max_values_per_key


datasource_api_GetTagValuesForDataSourceRequest.__name__ = "GetTagValuesForDataSourceRequest"
datasource_api_GetTagValuesForDataSourceRequest.__qualname__ = "GetTagValuesForDataSourceRequest"
datasource_api_GetTagValuesForDataSourceRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_IndexChannelPrefixTreeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'delimiter': ConjureFieldDefinition('delimiter', str)
        }

    __slots__: List[str] = ['_data_source_rid', '_delimiter']

    def __init__(self, data_source_rid: str, delimiter: str) -> None:
        self._data_source_rid = data_source_rid
        self._delimiter = delimiter

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def delimiter(self) -> str:
        return self._delimiter


datasource_api_IndexChannelPrefixTreeRequest.__name__ = "IndexChannelPrefixTreeRequest"
datasource_api_IndexChannelPrefixTreeRequest.__qualname__ = "IndexChannelPrefixTreeRequest"
datasource_api_IndexChannelPrefixTreeRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fuzzy_search_text': ConjureFieldDefinition('fuzzySearchText', str),
            'prefix': ConjureFieldDefinition('prefix', OptionalTypeWrapper[str]),
            'exact_match': ConjureFieldDefinition('exactMatch', List[str]),
            'data_sources': ConjureFieldDefinition('dataSources', List[api_rids_DataSourceRid]),
            'data_types': ConjureFieldDefinition('dataTypes', List[api_SeriesDataType]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', OptionalTypeWrapper[Dict[api_rids_DataSourceRid, List[api_Channel]]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_fuzzy_search_text', '_prefix', '_exact_match', '_data_sources', '_data_types', '_previously_selected_channels', '_next_page_token', '_page_size']

    def __init__(self, data_sources: List[str], data_types: List["api_SeriesDataType"], exact_match: List[str], fuzzy_search_text: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, prefix: Optional[str] = None, previously_selected_channels: Optional[Dict[str, List[str]]] = None) -> None:
        self._fuzzy_search_text = fuzzy_search_text
        self._prefix = prefix
        self._exact_match = exact_match
        self._data_sources = data_sources
        self._data_types = data_types
        self._previously_selected_channels = previously_selected_channels
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def fuzzy_search_text(self) -> str:
        return self._fuzzy_search_text

    @builtins.property
    def prefix(self) -> Optional[str]:
        return self._prefix

    @builtins.property
    def exact_match(self) -> List[str]:
        """Will return only channels that contain all strings specified as exact matches (case insensitive).
        """
        return self._exact_match

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources

    @builtins.property
    def data_types(self) -> List["api_SeriesDataType"]:
        """Filter to only channels with these data types. An empty set means no filtering (all data types included).
        """
        return self._data_types

    @builtins.property
    def previously_selected_channels(self) -> Optional[Dict[str, List[str]]]:
        return self._previously_selected_channels

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 1000. Will throw if larger than 1000.
        """
        return self._page_size


datasource_api_SearchChannelsRequest.__name__ = "SearchChannelsRequest"
datasource_api_SearchChannelsRequest.__qualname__ = "SearchChannelsRequest"
datasource_api_SearchChannelsRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["datasource_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["datasource_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_api_SearchChannelsResponse.__name__ = "SearchChannelsResponse"
datasource_api_SearchChannelsResponse.__qualname__ = "SearchChannelsResponse"
datasource_api_SearchChannelsResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchFilteredChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'substrings': ConjureFieldDefinition('substrings', OptionalTypeWrapper[List[str]]),
            'subsequences': ConjureFieldDefinition('subsequences', OptionalTypeWrapper[List[str]]),
            'data_sources': ConjureFieldDefinition('dataSources', List[api_rids_DataSourceRid]),
            'result_size': ConjureFieldDefinition('resultSize', OptionalTypeWrapper[int]),
            'tags': ConjureFieldDefinition('tags', Dict[api_rids_DataSourceRid, Dict[api_TagName, api_TagValue]]),
            'min_data_updated_time': ConjureFieldDefinition('minDataUpdatedTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'max_data_start_time': ConjureFieldDefinition('maxDataStartTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', OptionalTypeWrapper[Dict[api_rids_DataSourceRid, List[api_Channel]]]),
            'fuzzy_search_text': ConjureFieldDefinition('fuzzySearchText', OptionalTypeWrapper[str]),
            'exact_match': ConjureFieldDefinition('exactMatch', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_substrings', '_subsequences', '_data_sources', '_result_size', '_tags', '_min_data_updated_time', '_max_data_start_time', '_previously_selected_channels', '_fuzzy_search_text', '_exact_match']

    def __init__(self, data_sources: List[str], tags: Dict[str, Dict[str, str]], exact_match: Optional[List[str]] = None, fuzzy_search_text: Optional[str] = None, max_data_start_time: Optional["scout_run_api_UtcTimestamp"] = None, min_data_updated_time: Optional["scout_run_api_UtcTimestamp"] = None, previously_selected_channels: Optional[Dict[str, List[str]]] = None, result_size: Optional[int] = None, subsequences: Optional[List[str]] = None, substrings: Optional[List[str]] = None) -> None:
        self._substrings = substrings
        self._subsequences = subsequences
        self._data_sources = data_sources
        self._result_size = result_size
        self._tags = tags
        self._min_data_updated_time = min_data_updated_time
        self._max_data_start_time = max_data_start_time
        self._previously_selected_channels = previously_selected_channels
        self._fuzzy_search_text = fuzzy_search_text
        self._exact_match = exact_match

    @builtins.property
    def substrings(self) -> Optional[List[str]]:
        """All of the strings in the set must appear exactly as substrings within the channel name.
        """
        return self._substrings

    @builtins.property
    def subsequences(self) -> Optional[List[str]]:
        """All of the characters in the string will appear in the same order (not necessarily adjacently)
within the channel name. Only supports one subsequence to match at this time.
        """
        return self._subsequences

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources

    @builtins.property
    def result_size(self) -> Optional[int]:
        """Defaults to 200. Will throw if larger than 200.
        """
        return self._result_size

    @builtins.property
    def tags(self) -> Dict[str, Dict[str, str]]:
        """For each data source specified as a key, search will only return channels containing a superset of the 
tags specified for that given datasource. If a data source is present in the dataSources field but not
in this map, or if a data source points to an empty map of tags, it will be searched without tag filters.
        """
        return self._tags

    @builtins.property
    def min_data_updated_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        """If specified, search will only return channels that have had new data after the specified time.
        """
        return self._min_data_updated_time

    @builtins.property
    def max_data_start_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        """If specified, search will only return channels that have data before the specified time.
        """
        return self._max_data_start_time

    @builtins.property
    def previously_selected_channels(self) -> Optional[Dict[str, List[str]]]:
        return self._previously_selected_channels

    @builtins.property
    def fuzzy_search_text(self) -> Optional[str]:
        return self._fuzzy_search_text

    @builtins.property
    def exact_match(self) -> Optional[List[str]]:
        """Will return only channels that contain all strings specified as exact matches (case insensitive).
        """
        return self._exact_match


datasource_api_SearchFilteredChannelsRequest.__name__ = "SearchFilteredChannelsRequest"
datasource_api_SearchFilteredChannelsRequest.__qualname__ = "SearchFilteredChannelsRequest"
datasource_api_SearchFilteredChannelsRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchFilteredChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelMetadata])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["datasource_api_ChannelMetadata"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["datasource_api_ChannelMetadata"]:
        return self._results


datasource_api_SearchFilteredChannelsResponse.__name__ = "SearchFilteredChannelsResponse"
datasource_api_SearchFilteredChannelsResponse.__qualname__ = "SearchFilteredChannelsResponse"
datasource_api_SearchFilteredChannelsResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchHierarchicalChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parent': ConjureFieldDefinition('parent', List[str]),
            'data_sources': ConjureFieldDefinition('dataSources', List[api_rids_DataSourceRid]),
            'data_scope_filters': ConjureFieldDefinition('dataScopeFilters', OptionalTypeWrapper[datasource_api_DataScopeFilters])
        }

    __slots__: List[str] = ['_parent', '_data_sources', '_data_scope_filters']

    def __init__(self, data_sources: List[str], parent: List[str], data_scope_filters: Optional["datasource_api_DataScopeFilters"] = None) -> None:
        self._parent = parent
        self._data_sources = data_sources
        self._data_scope_filters = data_scope_filters

    @builtins.property
    def parent(self) -> List[str]:
        """The parent (represented as a list of parts) to search under. If empty, will return all top-level channels.
        """
        return self._parent

    @builtins.property
    def data_sources(self) -> List[str]:
        return self._data_sources

    @builtins.property
    def data_scope_filters(self) -> Optional["datasource_api_DataScopeFilters"]:
        """When dataScopeFilters are specified, the set of data sources must match the set of data sources in
DataScopeFilters#tags
        """
        return self._data_scope_filters


datasource_api_SearchHierarchicalChannelsRequest.__name__ = "SearchHierarchicalChannelsRequest"
datasource_api_SearchHierarchicalChannelsRequest.__qualname__ = "SearchHierarchicalChannelsRequest"
datasource_api_SearchHierarchicalChannelsRequest.__module__ = "nominal_api.datasource_api"


class datasource_api_SearchHierarchicalChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[datasource_api_ChannelOrPrefix])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["datasource_api_ChannelOrPrefix"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["datasource_api_ChannelOrPrefix"]:
        return self._results


datasource_api_SearchHierarchicalChannelsResponse.__name__ = "SearchHierarchicalChannelsResponse"
datasource_api_SearchHierarchicalChannelsResponse.__qualname__ = "SearchHierarchicalChannelsResponse"
datasource_api_SearchHierarchicalChannelsResponse.__module__ = "nominal_api.datasource_api"


class datasource_api_SeriesMetadataRidOrLogicalSeriesRid(ConjureUnionType):
    _series_archetype: Optional[str] = None
    _logical_series: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_archetype': ConjureFieldDefinition('seriesArchetype', api_SeriesMetadataRid),
            'logical_series': ConjureFieldDefinition('logicalSeries', api_LogicalSeriesRid)
        }

    def __init__(
            self,
            series_archetype: Optional[str] = None,
            logical_series: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (series_archetype is not None) + (logical_series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if series_archetype is not None:
                self._series_archetype = series_archetype
                self._type = 'seriesArchetype'
            if logical_series is not None:
                self._logical_series = logical_series
                self._type = 'logicalSeries'

        elif type_of_union == 'seriesArchetype':
            if series_archetype is None:
                raise ValueError('a union value must not be None')
            self._series_archetype = series_archetype
            self._type = 'seriesArchetype'
        elif type_of_union == 'logicalSeries':
            if logical_series is None:
                raise ValueError('a union value must not be None')
            self._logical_series = logical_series
            self._type = 'logicalSeries'

    @builtins.property
    def series_archetype(self) -> Optional[str]:
        return self._series_archetype

    @builtins.property
    def logical_series(self) -> Optional[str]:
        return self._logical_series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor):
            raise ValueError('{} is not an instance of datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor'.format(visitor.__class__.__name__))
        if self._type == 'seriesArchetype' and self.series_archetype is not None:
            return visitor._series_archetype(self.series_archetype)
        if self._type == 'logicalSeries' and self.logical_series is not None:
            return visitor._logical_series(self.logical_series)


datasource_api_SeriesMetadataRidOrLogicalSeriesRid.__name__ = "SeriesMetadataRidOrLogicalSeriesRid"
datasource_api_SeriesMetadataRidOrLogicalSeriesRid.__qualname__ = "SeriesMetadataRidOrLogicalSeriesRid"
datasource_api_SeriesMetadataRidOrLogicalSeriesRid.__module__ = "nominal_api.datasource_api"


class datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor:

    @abstractmethod
    def _series_archetype(self, series_archetype: str) -> Any:
        pass

    @abstractmethod
    def _logical_series(self, logical_series: str) -> Any:
        pass


datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor.__name__ = "SeriesMetadataRidOrLogicalSeriesRidVisitor"
datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor.__qualname__ = "SeriesMetadataRidOrLogicalSeriesRidVisitor"
datasource_api_SeriesMetadataRidOrLogicalSeriesRidVisitor.__module__ = "nominal_api.datasource_api"


class datasource_api_TagSearchFilters(ConjureBeanType):
    """Filters to use when searching for available tag names and values in paged endpoints.
All filters are optional.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', OptionalTypeWrapper[api_Channel]),
            'tag_filters': ConjureFieldDefinition('tagFilters', Dict[api_TagName, api_TagValue]),
            'range': ConjureFieldDefinition('range', OptionalTypeWrapper[api_Range])
        }

    __slots__: List[str] = ['_channel', '_tag_filters', '_range']

    def __init__(self, tag_filters: Dict[str, str], channel: Optional[str] = None, range: Optional["api_Range"] = None) -> None:
        self._channel = channel
        self._tag_filters = tag_filters
        self._range = range

    @builtins.property
    def channel(self) -> Optional[str]:
        """Optional, defaults to all channels in datasource.
        """
        return self._channel

    @builtins.property
    def tag_filters(self) -> Dict[str, str]:
        """Optional, defaults to no tag filter.
        """
        return self._tag_filters

    @builtins.property
    def range(self) -> Optional["api_Range"]:
        """Optional, defaults to no range filter.
        """
        return self._range


datasource_api_TagSearchFilters.__name__ = "TagSearchFilters"
datasource_api_TagSearchFilters.__qualname__ = "TagSearchFilters"
datasource_api_TagSearchFilters.__module__ = "nominal_api.datasource_api"


class datasource_pagination_api_PageRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'page_token': ConjureFieldDefinition('pageToken', OptionalTypeWrapper[datasource_pagination_api_PageToken]),
            'page_size': ConjureFieldDefinition('pageSize', int)
        }

    __slots__: List[str] = ['_page_token', '_page_size']

    def __init__(self, page_size: int, page_token: Optional[str] = None) -> None:
        self._page_token = page_token
        self._page_size = page_size

    @builtins.property
    def page_token(self) -> Optional[str]:
        return self._page_token

    @builtins.property
    def page_size(self) -> int:
        return self._page_size


datasource_pagination_api_PageRequest.__name__ = "PageRequest"
datasource_pagination_api_PageRequest.__qualname__ = "PageRequest"
datasource_pagination_api_PageRequest.__module__ = "nominal_api.datasource_pagination_api"


class datasource_pagination_api_PageResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[datasource_pagination_api_PageToken])
        }

    __slots__: List[str] = ['_next_page_token']

    def __init__(self, next_page_token: Optional[str] = None) -> None:
        self._next_page_token = next_page_token

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


datasource_pagination_api_PageResponse.__name__ = "PageResponse"
datasource_pagination_api_PageResponse.__qualname__ = "PageResponse"
datasource_pagination_api_PageResponse.__module__ = "nominal_api.datasource_pagination_api"


class event_AggregateEventsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', event_SearchQuery),
            'aggregate_types': ConjureFieldDefinition('aggregateTypes', List[event_AggregateType])
        }

    __slots__: List[str] = ['_query', '_aggregate_types']

    def __init__(self, aggregate_types: List["event_AggregateType"], query: "event_SearchQuery") -> None:
        self._query = query
        self._aggregate_types = aggregate_types

    @builtins.property
    def query(self) -> "event_SearchQuery":
        return self._query

    @builtins.property
    def aggregate_types(self) -> List["event_AggregateType"]:
        return self._aggregate_types


event_AggregateEventsRequest.__name__ = "AggregateEventsRequest"
event_AggregateEventsRequest.__qualname__ = "AggregateEventsRequest"
event_AggregateEventsRequest.__module__ = "nominal_api.event"


class event_AggregateEventsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'values': ConjureFieldDefinition('values', Dict[event_AggregateType, event_AggregateValue])
        }

    __slots__: List[str] = ['_values']

    def __init__(self, values: Dict["event_AggregateType", "event_AggregateValue"]) -> None:
        self._values = values

    @builtins.property
    def values(self) -> Dict["event_AggregateType", "event_AggregateValue"]:
        return self._values


event_AggregateEventsResponse.__name__ = "AggregateEventsResponse"
event_AggregateEventsResponse.__qualname__ = "AggregateEventsResponse"
event_AggregateEventsResponse.__module__ = "nominal_api.event"


class event_AggregateType(ConjureEnumType):

    TOTAL_DURATION = 'TOTAL_DURATION'
    '''TOTAL_DURATION'''
    TOTAL_COUNT = 'TOTAL_COUNT'
    '''TOTAL_COUNT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_AggregateType.__name__ = "AggregateType"
event_AggregateType.__qualname__ = "AggregateType"
event_AggregateType.__module__ = "nominal_api.event"


class event_AggregateValue(ConjureUnionType):
    _duration: Optional["scout_run_api_Duration"] = None
    _count: Optional[int] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'count': ConjureFieldDefinition('count', int)
        }

    def __init__(
            self,
            duration: Optional["scout_run_api_Duration"] = None,
            count: Optional[int] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration is not None) + (count is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration is not None:
                self._duration = duration
                self._type = 'duration'
            if count is not None:
                self._count = count
                self._type = 'count'

        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'
        elif type_of_union == 'count':
            if count is None:
                raise ValueError('a union value must not be None')
            self._count = count
            self._type = 'count'

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def count(self) -> Optional[int]:
        return self._count

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, event_AggregateValueVisitor):
            raise ValueError('{} is not an instance of event_AggregateValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)
        if self._type == 'count' and self.count is not None:
            return visitor._count(self.count)


event_AggregateValue.__name__ = "AggregateValue"
event_AggregateValue.__qualname__ = "AggregateValue"
event_AggregateValue.__module__ = "nominal_api.event"


class event_AggregateValueVisitor:

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _count(self, count: int) -> Any:
        pass


event_AggregateValueVisitor.__name__ = "AggregateValueVisitor"
event_AggregateValueVisitor.__qualname__ = "AggregateValueVisitor"
event_AggregateValueVisitor.__module__ = "nominal_api.event"


class event_ApiEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



event_ApiEventOrigin.__name__ = "ApiEventOrigin"
event_ApiEventOrigin.__qualname__ = "ApiEventOrigin"
event_ApiEventOrigin.__module__ = "nominal_api.event"


class event_ArchiveEvent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str)
        }

    __slots__: List[str] = ['_uuid']

    def __init__(self, uuid: str) -> None:
        self._uuid = uuid

    @builtins.property
    def uuid(self) -> str:
        return self._uuid


event_ArchiveEvent.__name__ = "ArchiveEvent"
event_ArchiveEvent.__qualname__ = "ArchiveEvent"
event_ArchiveEvent.__module__ = "nominal_api.event"


class event_AssetsFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_operator', '_assets']

    def __init__(self, assets: List[str], operator: "api_SetOperator") -> None:
        self._operator = operator
        self._assets = assets

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets


event_AssetsFilter.__name__ = "AssetsFilter"
event_AssetsFilter.__qualname__ = "AssetsFilter"
event_AssetsFilter.__module__ = "nominal_api.event"


class event_AssigneesFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'assignees': ConjureFieldDefinition('assignees', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_operator', '_assignees']

    def __init__(self, assignees: List[str], operator: "api_SetOperator") -> None:
        self._operator = operator
        self._assignees = assignees

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def assignees(self) -> List[str]:
        return self._assignees


event_AssigneesFilter.__name__ = "AssigneesFilter"
event_AssigneesFilter.__qualname__ = "AssigneesFilter"
event_AssigneesFilter.__module__ = "nominal_api.event"


class event_BatchAggregateEventsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[event_AggregateEventsRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["event_AggregateEventsRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["event_AggregateEventsRequest"]:
        return self._requests


event_BatchAggregateEventsRequest.__name__ = "BatchAggregateEventsRequest"
event_BatchAggregateEventsRequest.__qualname__ = "BatchAggregateEventsRequest"
event_BatchAggregateEventsRequest.__module__ = "nominal_api.event"


class event_BatchAggregateEventsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[event_AggregateEventsResponse])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["event_AggregateEventsResponse"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["event_AggregateEventsResponse"]:
        return self._responses


event_BatchAggregateEventsResponse.__name__ = "BatchAggregateEventsResponse"
event_BatchAggregateEventsResponse.__qualname__ = "BatchAggregateEventsResponse"
event_BatchAggregateEventsResponse.__module__ = "nominal_api.event"


class event_BatchFilterEventsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'event_rids': ConjureFieldDefinition('eventRids', List[api_rids_EventRid]),
            'filter_query': ConjureFieldDefinition('filterQuery', event_SearchQuery)
        }

    __slots__: List[str] = ['_event_rids', '_filter_query']

    def __init__(self, event_rids: List[str], filter_query: "event_SearchQuery") -> None:
        self._event_rids = event_rids
        self._filter_query = filter_query

    @builtins.property
    def event_rids(self) -> List[str]:
        return self._event_rids

    @builtins.property
    def filter_query(self) -> "event_SearchQuery":
        return self._filter_query


event_BatchFilterEventsRequest.__name__ = "BatchFilterEventsRequest"
event_BatchFilterEventsRequest.__qualname__ = "BatchFilterEventsRequest"
event_BatchFilterEventsRequest.__module__ = "nominal_api.event"


class event_BatchUpdateDispositionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[event_UpdateDispositionRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["event_UpdateDispositionRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["event_UpdateDispositionRequest"]:
        return self._requests


event_BatchUpdateDispositionRequest.__name__ = "BatchUpdateDispositionRequest"
event_BatchUpdateDispositionRequest.__qualname__ = "BatchUpdateDispositionRequest"
event_BatchUpdateDispositionRequest.__module__ = "nominal_api.event"


class event_BatchUpdateDispositionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[event_Event])
        }

    __slots__: List[str] = ['_events']

    def __init__(self, events: List["event_Event"]) -> None:
        self._events = events

    @builtins.property
    def events(self) -> List["event_Event"]:
        return self._events


event_BatchUpdateDispositionResponse.__name__ = "BatchUpdateDispositionResponse"
event_BatchUpdateDispositionResponse.__qualname__ = "BatchUpdateDispositionResponse"
event_BatchUpdateDispositionResponse.__module__ = "nominal_api.event"


class event_BatchUpdateEventRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[event_UpdateEventRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["event_UpdateEventRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["event_UpdateEventRequest"]:
        return self._requests


event_BatchUpdateEventRequest.__name__ = "BatchUpdateEventRequest"
event_BatchUpdateEventRequest.__qualname__ = "BatchUpdateEventRequest"
event_BatchUpdateEventRequest.__module__ = "nominal_api.event"


class event_BatchUpdateEventResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', List[event_Event])
        }

    __slots__: List[str] = ['_events']

    def __init__(self, events: List["event_Event"]) -> None:
        self._events = events

    @builtins.property
    def events(self) -> List["event_Event"]:
        return self._events


event_BatchUpdateEventResponse.__name__ = "BatchUpdateEventResponse"
event_BatchUpdateEventResponse.__qualname__ = "BatchUpdateEventResponse"
event_BatchUpdateEventResponse.__module__ = "nominal_api.event"


class event_CheckOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', api_rids_AutomaticCheckEvaluationRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', scout_rids_api_CheckLineageRid),
            'implementation_index': ConjureFieldDefinition('implementationIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_check_evaluation_rid', '_check_rid', '_check_lineage_rid', '_implementation_index']

    def __init__(self, check_evaluation_rid: str, check_lineage_rid: str, check_rid: str, implementation_index: Optional[int] = None) -> None:
        self._check_evaluation_rid = check_evaluation_rid
        self._check_rid = check_rid
        self._check_lineage_rid = check_lineage_rid
        self._implementation_index = implementation_index

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_lineage_rid(self) -> str:
        return self._check_lineage_rid

    @builtins.property
    def implementation_index(self) -> Optional[int]:
        return self._implementation_index


event_CheckOriginMetadata.__name__ = "CheckOriginMetadata"
event_CheckOriginMetadata.__qualname__ = "CheckOriginMetadata"
event_CheckOriginMetadata.__module__ = "nominal_api.event"


class event_CreateEvent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid]),
            'origins': ConjureFieldDefinition('origins', List[event_EventOrigin]),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'type': ConjureFieldDefinition('type', event_EventType),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'disposition': ConjureFieldDefinition('disposition', OptionalTypeWrapper[event_EventDisposition])
        }

    __slots__: List[str] = ['_asset_rids', '_origins', '_timestamp', '_duration', '_name', '_description', '_type', '_labels', '_properties', '_disposition']

    def __init__(self, asset_rids: List[str], duration: "scout_run_api_Duration", labels: List[str], name: str, origins: List["event_EventOrigin"], properties: Dict[str, str], timestamp: "api_Timestamp", type: "event_EventType", description: Optional[str] = None, disposition: Optional["event_EventDisposition"] = None) -> None:
        self._asset_rids = asset_rids
        self._origins = origins
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._description = description
        self._type = type
        self._labels = labels
        self._properties = properties
        self._disposition = disposition

    @builtins.property
    def asset_rids(self) -> List[str]:
        """Must contain at least one asset rid.
        """
        return self._asset_rids

    @builtins.property
    def origins(self) -> List["event_EventOrigin"]:
        """If empty, will default to set<EventOrigin.api>.
        """
        return self._origins

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        """If not provided, will default to an empty string.
        """
        return self._description

    @builtins.property
    def type(self) -> "event_EventType":
        return self._type

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def disposition(self) -> Optional["event_EventDisposition"]:
        return self._disposition


event_CreateEvent.__name__ = "CreateEvent"
event_CreateEvent.__qualname__ = "CreateEvent"
event_CreateEvent.__module__ = "nominal_api.event"


class event_DataReviewChecksFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_checks': ConjureFieldDefinition('dataReviewChecks', List[scout_rids_api_CheckRid])
        }

    __slots__: List[str] = ['_data_review_checks']

    def __init__(self, data_review_checks: List[str]) -> None:
        self._data_review_checks = data_review_checks

    @builtins.property
    def data_review_checks(self) -> List[str]:
        return self._data_review_checks


event_DataReviewChecksFilter.__name__ = "DataReviewChecksFilter"
event_DataReviewChecksFilter.__qualname__ = "DataReviewChecksFilter"
event_DataReviewChecksFilter.__module__ = "nominal_api.event"


class event_DataReviewEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'check_metadata': ConjureFieldDefinition('checkMetadata', event_CheckOriginMetadata)
        }

    __slots__: List[str] = ['_data_review_rid', '_check_metadata']

    def __init__(self, check_metadata: "event_CheckOriginMetadata", data_review_rid: str) -> None:
        self._data_review_rid = data_review_rid
        self._check_metadata = check_metadata

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_metadata(self) -> "event_CheckOriginMetadata":
        """Metadata about the check that created this event.
        """
        return self._check_metadata


event_DataReviewEventOrigin.__name__ = "DataReviewEventOrigin"
event_DataReviewEventOrigin.__qualname__ = "DataReviewEventOrigin"
event_DataReviewEventOrigin.__module__ = "nominal_api.event"


class event_DataReviewsFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_reviews': ConjureFieldDefinition('dataReviews', List[scout_rids_api_DataReviewRid])
        }

    __slots__: List[str] = ['_data_reviews']

    def __init__(self, data_reviews: List[str]) -> None:
        self._data_reviews = data_reviews

    @builtins.property
    def data_reviews(self) -> List[str]:
        return self._data_reviews


event_DataReviewsFilter.__name__ = "DataReviewsFilter"
event_DataReviewsFilter.__qualname__ = "DataReviewsFilter"
event_DataReviewsFilter.__module__ = "nominal_api.event"


class event_Event(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'rid': ConjureFieldDefinition('rid', api_rids_EventRid),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid]),
            'origins': ConjureFieldDefinition('origins', List[event_EventOrigin]),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'type': ConjureFieldDefinition('type', event_EventType),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'created_by': ConjureFieldDefinition('createdBy', OptionalTypeWrapper[scout_rids_api_UserRid]),
            'disposition': ConjureFieldDefinition('disposition', OptionalTypeWrapper[event_EventDisposition])
        }

    __slots__: List[str] = ['_uuid', '_rid', '_asset_rids', '_origins', '_timestamp', '_duration', '_name', '_description', '_type', '_labels', '_properties', '_is_archived', '_created_by', '_disposition']

    def __init__(self, asset_rids: List[str], description: str, duration: "scout_run_api_Duration", is_archived: bool, labels: List[str], name: str, origins: List["event_EventOrigin"], properties: Dict[str, str], rid: str, timestamp: "api_Timestamp", type: "event_EventType", uuid: str, created_by: Optional[str] = None, disposition: Optional["event_EventDisposition"] = None) -> None:
        self._uuid = uuid
        self._rid = rid
        self._asset_rids = asset_rids
        self._origins = origins
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._description = description
        self._type = type
        self._labels = labels
        self._properties = properties
        self._is_archived = is_archived
        self._created_by = created_by
        self._disposition = disposition

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def asset_rids(self) -> List[str]:
        """A set of asset rids associated with the event.
        """
        return self._asset_rids

    @builtins.property
    def origins(self) -> List["event_EventOrigin"]:
        """A set of origins associated with the event.
        """
        return self._origins

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def type(self) -> "event_EventType":
        return self._type

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def created_by(self) -> Optional[str]:
        """The user who created the event.
This field may be missing for legacy events.
        """
        return self._created_by

    @builtins.property
    def disposition(self) -> Optional["event_EventDisposition"]:
        return self._disposition


event_Event.__name__ = "Event"
event_Event.__qualname__ = "Event"
event_Event.__module__ = "nominal_api.event"


class event_EventDisposition(ConjureBeanType):
    """Describes the review status for an event.
This is used to track the disposition status of an event.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'state': ConjureFieldDefinition('state', scout_api_DispositionState),
            'assignees': ConjureFieldDefinition('assignees', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_priority', '_state', '_assignees']

    def __init__(self, assignees: List[str], priority: "scout_api_Priority", state: "scout_api_DispositionState") -> None:
        self._priority = priority
        self._state = state
        self._assignees = assignees

    @builtins.property
    def priority(self) -> "scout_api_Priority":
        return self._priority

    @builtins.property
    def state(self) -> "scout_api_DispositionState":
        return self._state

    @builtins.property
    def assignees(self) -> List[str]:
        return self._assignees


event_EventDisposition.__name__ = "EventDisposition"
event_EventDisposition.__qualname__ = "EventDisposition"
event_EventDisposition.__module__ = "nominal_api.event"


class event_EventDispositionStatus(ConjureEnumType):

    PENDING_REVIEW = 'PENDING_REVIEW'
    '''PENDING_REVIEW'''
    CLOSED_IGNORED = 'CLOSED_IGNORED'
    '''CLOSED_IGNORED'''
    CLOSED_REQUIRES_FURTHER_ACTION = 'CLOSED_REQUIRES_FURTHER_ACTION'
    '''CLOSED_REQUIRES_FURTHER_ACTION'''
    NO_DISPOSITION = 'NO_DISPOSITION'
    '''NO_DISPOSITION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_EventDispositionStatus.__name__ = "EventDispositionStatus"
event_EventDispositionStatus.__qualname__ = "EventDispositionStatus"
event_EventDispositionStatus.__module__ = "nominal_api.event"


class event_EventOrigin(ConjureUnionType):
    """Describes where an event came from.
    """
    _workbook: Optional["event_WorkbookEventOrigin"] = None
    _template: Optional["event_TemplateEventOrigin"] = None
    _api: Optional["event_ApiEventOrigin"] = None
    _data_review: Optional["event_DataReviewEventOrigin"] = None
    _procedure: Optional["event_ProcedureEventOrigin"] = None
    _streaming_checklist: Optional["event_StreamingChecklistEventOrigin"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workbook': ConjureFieldDefinition('workbook', event_WorkbookEventOrigin),
            'template': ConjureFieldDefinition('template', event_TemplateEventOrigin),
            'api': ConjureFieldDefinition('api', event_ApiEventOrigin),
            'data_review': ConjureFieldDefinition('dataReview', event_DataReviewEventOrigin),
            'procedure': ConjureFieldDefinition('procedure', event_ProcedureEventOrigin),
            'streaming_checklist': ConjureFieldDefinition('streamingChecklist', event_StreamingChecklistEventOrigin)
        }

    def __init__(
            self,
            workbook: Optional["event_WorkbookEventOrigin"] = None,
            template: Optional["event_TemplateEventOrigin"] = None,
            api: Optional["event_ApiEventOrigin"] = None,
            data_review: Optional["event_DataReviewEventOrigin"] = None,
            procedure: Optional["event_ProcedureEventOrigin"] = None,
            streaming_checklist: Optional["event_StreamingChecklistEventOrigin"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (workbook is not None) + (template is not None) + (api is not None) + (data_review is not None) + (procedure is not None) + (streaming_checklist is not None) != 1:
                raise ValueError('a union must contain a single member')

            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if template is not None:
                self._template = template
                self._type = 'template'
            if api is not None:
                self._api = api
                self._type = 'api'
            if data_review is not None:
                self._data_review = data_review
                self._type = 'dataReview'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'
            if streaming_checklist is not None:
                self._streaming_checklist = streaming_checklist
                self._type = 'streamingChecklist'

        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'template':
            if template is None:
                raise ValueError('a union value must not be None')
            self._template = template
            self._type = 'template'
        elif type_of_union == 'api':
            if api is None:
                raise ValueError('a union value must not be None')
            self._api = api
            self._type = 'api'
        elif type_of_union == 'dataReview':
            if data_review is None:
                raise ValueError('a union value must not be None')
            self._data_review = data_review
            self._type = 'dataReview'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'
        elif type_of_union == 'streamingChecklist':
            if streaming_checklist is None:
                raise ValueError('a union value must not be None')
            self._streaming_checklist = streaming_checklist
            self._type = 'streamingChecklist'

    @builtins.property
    def workbook(self) -> Optional["event_WorkbookEventOrigin"]:
        """This event was created in this workbook
        """
        return self._workbook

    @builtins.property
    def template(self) -> Optional["event_TemplateEventOrigin"]:
        """This event was created in this template
        """
        return self._template

    @builtins.property
    def api(self) -> Optional["event_ApiEventOrigin"]:
        """This event was created programmatically via the API
        """
        return self._api

    @builtins.property
    def data_review(self) -> Optional["event_DataReviewEventOrigin"]:
        """This event was created automatically from a checklist execution.
        """
        return self._data_review

    @builtins.property
    def procedure(self) -> Optional["event_ProcedureEventOrigin"]:
        """This event was created automatically from a procedure execution.
        """
        return self._procedure

    @builtins.property
    def streaming_checklist(self) -> Optional["event_StreamingChecklistEventOrigin"]:
        """This event was created automatically from the execution of a streaming checklist.
        """
        return self._streaming_checklist

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, event_EventOriginVisitor):
            raise ValueError('{} is not an instance of event_EventOriginVisitor'.format(visitor.__class__.__name__))
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'template' and self.template is not None:
            return visitor._template(self.template)
        if self._type == 'api' and self.api is not None:
            return visitor._api(self.api)
        if self._type == 'dataReview' and self.data_review is not None:
            return visitor._data_review(self.data_review)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)
        if self._type == 'streamingChecklist' and self.streaming_checklist is not None:
            return visitor._streaming_checklist(self.streaming_checklist)


event_EventOrigin.__name__ = "EventOrigin"
event_EventOrigin.__qualname__ = "EventOrigin"
event_EventOrigin.__module__ = "nominal_api.event"


class event_EventOriginVisitor:

    @abstractmethod
    def _workbook(self, workbook: "event_WorkbookEventOrigin") -> Any:
        pass

    @abstractmethod
    def _template(self, template: "event_TemplateEventOrigin") -> Any:
        pass

    @abstractmethod
    def _api(self, api: "event_ApiEventOrigin") -> Any:
        pass

    @abstractmethod
    def _data_review(self, data_review: "event_DataReviewEventOrigin") -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: "event_ProcedureEventOrigin") -> Any:
        pass

    @abstractmethod
    def _streaming_checklist(self, streaming_checklist: "event_StreamingChecklistEventOrigin") -> Any:
        pass


event_EventOriginVisitor.__name__ = "EventOriginVisitor"
event_EventOriginVisitor.__qualname__ = "EventOriginVisitor"
event_EventOriginVisitor.__module__ = "nominal_api.event"


class event_EventService(Service):
    """An Event is an annotated moment or time range.
The Event Service is responsible for creating and retrieving events for a particular data source.
    """

    def create_event(self, auth_header: str, request: "event_CreateEvent") -> "event_Event":
        """Creates an event.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_Event, self._return_none_for_unknown_union_types)

    def get_events(self, auth_header: str, request: "event_GetEvents") -> List["event_Event"]:
        """Gets a set of events by UUIDs
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/get-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[event_Event], self._return_none_for_unknown_union_types)

    def batch_get_events(self, auth_header: str, request: List[str] = None) -> List["event_Event"]:
        """Gets a set of events by RID.
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/events/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[event_Event], self._return_none_for_unknown_union_types)

    def batch_filter_events(self, auth_header: str, request: "event_BatchFilterEventsRequest") -> List["event_Event"]:
        """Gets a filtered set of events by RID and search filters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/events/batch-filter-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[event_Event], self._return_none_for_unknown_union_types)

    def update_event(self, auth_header: str, request: "event_UpdateEvent") -> "event_Event":
        """Updates the fields of an event. Empty fields are left unchanged.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/update-event'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_Event, self._return_none_for_unknown_union_types)

    def batch_update_event(self, auth_header: str, request: "event_BatchUpdateEventRequest") -> "event_BatchUpdateEventResponse":
        """Updates the fields of an event specified by each request in the batch.
Empty fields in the UpdateEventRequest are left unchanged.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/events/batch-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_BatchUpdateEventResponse, self._return_none_for_unknown_union_types)

    def batch_update_disposition(self, auth_header: str, request: "event_BatchUpdateDispositionRequest") -> "event_BatchUpdateDispositionResponse":
        """Updates the disposition of an event.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/update-disposition'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_BatchUpdateDispositionResponse, self._return_none_for_unknown_union_types)

    def archive_event(self, auth_header: str, request: "event_ArchiveEvent") -> None:
        """Archives an event
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/archive-event'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def batch_archive_event(self, auth_header: str, request: List[str] = None) -> None:
        """Archives a set of events
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/batch-archive-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def batch_unarchive_event(self, auth_header: str, request: List[str] = None) -> None:
        """Unarchives a set of events
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/batch-unarchive-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def search_events(self, auth_header: str, request: "event_SearchEventsRequest") -> "event_SearchEventsResponse":
        """Searches for events that match the given filters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/search-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_SearchEventsResponse, self._return_none_for_unknown_union_types)

    def aggregate_events(self, auth_header: str, request: "event_AggregateEventsRequest") -> "event_AggregateEventsResponse":
        """Searches for events matching the given filter and aggregates them based on the requested functions.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/aggregate-events'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_AggregateEventsResponse, self._return_none_for_unknown_union_types)

    def batch_aggregate_events(self, auth_header: str, request: "event_BatchAggregateEventsRequest") -> "event_BatchAggregateEventsResponse":
        """Searches for events matching the given filter and aggregates them based on the requested functions.
Returns a list of responses in same order as the batched requests.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/aggregate-events/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_BatchAggregateEventsResponse, self._return_none_for_unknown_union_types)

    def get_events_histogram(self, auth_header: str, request: "event_EventsHistogramRequest") -> "event_EventsHistogramResponse":
        """Gets a histogram of events that match the given filters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/histogram'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), event_EventsHistogramResponse, self._return_none_for_unknown_union_types)

    def list_properties_and_labels(self, auth_header: str, request: "event_ListPropertiesAndLabelsRequest") -> "scout_metadata_ListPropertiesAndLabelsResponse":
        """Lists the properties and labels of all events in the provided workspaces.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/event/v1/list-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_metadata_ListPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)


event_EventService.__name__ = "EventService"
event_EventService.__qualname__ = "EventService"
event_EventService.__module__ = "nominal_api.event"


class event_EventTimeFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'timestamp_condition': ConjureFieldDefinition('timestampCondition', event_EventTimeFilterCondition)
        }

    __slots__: List[str] = ['_timestamp', '_timestamp_condition']

    def __init__(self, timestamp: "api_Timestamp", timestamp_condition: "event_EventTimeFilterCondition") -> None:
        self._timestamp = timestamp
        self._timestamp_condition = timestamp_condition

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def timestamp_condition(self) -> "event_EventTimeFilterCondition":
        return self._timestamp_condition


event_EventTimeFilter.__name__ = "EventTimeFilter"
event_EventTimeFilter.__qualname__ = "EventTimeFilter"
event_EventTimeFilter.__module__ = "nominal_api.event"


class event_EventTimeFilterCondition(ConjureEnumType):

    START_TIME_BEFORE_INCLUSIVE = 'START_TIME_BEFORE_INCLUSIVE'
    '''START_TIME_BEFORE_INCLUSIVE'''
    START_TIME_BEFORE_EXCLUSIVE = 'START_TIME_BEFORE_EXCLUSIVE'
    '''START_TIME_BEFORE_EXCLUSIVE'''
    START_TIME_AFTER_INCLUSIVE = 'START_TIME_AFTER_INCLUSIVE'
    '''START_TIME_AFTER_INCLUSIVE'''
    START_TIME_AFTER_EXCLUSIVE = 'START_TIME_AFTER_EXCLUSIVE'
    '''START_TIME_AFTER_EXCLUSIVE'''
    END_TIME_BEFORE_INCLUSIVE = 'END_TIME_BEFORE_INCLUSIVE'
    '''END_TIME_BEFORE_INCLUSIVE'''
    END_TIME_BEFORE_EXCLUSIVE = 'END_TIME_BEFORE_EXCLUSIVE'
    '''END_TIME_BEFORE_EXCLUSIVE'''
    END_TIME_AFTER_INCLUSIVE = 'END_TIME_AFTER_INCLUSIVE'
    '''END_TIME_AFTER_INCLUSIVE'''
    END_TIME_AFTER_EXCLUSIVE = 'END_TIME_AFTER_EXCLUSIVE'
    '''END_TIME_AFTER_EXCLUSIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_EventTimeFilterCondition.__name__ = "EventTimeFilterCondition"
event_EventTimeFilterCondition.__qualname__ = "EventTimeFilterCondition"
event_EventTimeFilterCondition.__module__ = "nominal_api.event"


class event_EventType(ConjureEnumType):

    INFO = 'INFO'
    '''INFO'''
    FLAG = 'FLAG'
    '''FLAG'''
    ERROR = 'ERROR'
    '''ERROR'''
    SUCCESS = 'SUCCESS'
    '''SUCCESS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_EventType.__name__ = "EventType"
event_EventType.__qualname__ = "EventType"
event_EventType.__module__ = "nominal_api.event"


class event_EventsHistogramBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_count']

    def __init__(self, count: int, end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._count = count

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def count(self) -> int:
        return self._count


event_EventsHistogramBucket.__name__ = "EventsHistogramBucket"
event_EventsHistogramBucket.__qualname__ = "EventsHistogramBucket"
event_EventsHistogramBucket.__module__ = "nominal_api.event"


class event_EventsHistogramRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'filter_query': ConjureFieldDefinition('filterQuery', OptionalTypeWrapper[event_HistogramFilterQuery]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]]),
            'num_bins': ConjureFieldDefinition('numBins', OptionalTypeWrapper[int]),
            'event_limit': ConjureFieldDefinition('eventLimit', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_filter_query', '_archived_statuses', '_num_bins', '_event_limit']

    def __init__(self, end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, event_limit: Optional[int] = None, filter_query: Optional["event_HistogramFilterQuery"] = None, num_bins: Optional[int] = None) -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._filter_query = filter_query
        self._archived_statuses = archived_statuses
        self._num_bins = num_bins
        self._event_limit = event_limit

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def filter_query(self) -> Optional["event_HistogramFilterQuery"]:
        """The query to filter the events to be included in the histogram.
        """
        return self._filter_query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Filters search on check alerts based on the archived statuses provided. 
Default is NOT_ARCHIVED only if none are provided.
        """
        return self._archived_statuses

    @builtins.property
    def num_bins(self) -> Optional[int]:
        """Defaults to 100. Throws if larger than 1_000.
The resulting histogram may have fewer bins than requested if the requested time window is too small.
        """
        return self._num_bins

    @builtins.property
    def event_limit(self) -> Optional[int]:
        """Limits the number of events to be included in the histogram.
Defaults to 1_000. Throws if larger than 10_000.
        """
        return self._event_limit


event_EventsHistogramRequest.__name__ = "EventsHistogramRequest"
event_EventsHistogramRequest.__qualname__ = "EventsHistogramRequest"
event_EventsHistogramRequest.__module__ = "nominal_api.event"


class event_EventsHistogramResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[event_EventsHistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["event_EventsHistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["event_EventsHistogramBucket"]:
        return self._buckets


event_EventsHistogramResponse.__name__ = "EventsHistogramResponse"
event_EventsHistogramResponse.__qualname__ = "EventsHistogramResponse"
event_EventsHistogramResponse.__module__ = "nominal_api.event"


class event_GetEvents(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuids': ConjureFieldDefinition('uuids', List[str])
        }

    __slots__: List[str] = ['_uuids']

    def __init__(self, uuids: List[str]) -> None:
        self._uuids = uuids

    @builtins.property
    def uuids(self) -> List[str]:
        return self._uuids


event_GetEvents.__name__ = "GetEvents"
event_GetEvents.__qualname__ = "GetEvents"
event_GetEvents.__module__ = "nominal_api.event"


class event_HistogramFilterQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _asset: Optional[str] = None
    _template: Optional[str] = None
    _workbook: Optional[str] = None
    _data_review: Optional[str] = None
    _origin_type: Optional["event_SearchEventOriginType"] = None
    _data_review_check: Optional[str] = None
    _disposition_status: Optional["event_EventDispositionStatus"] = None
    _priority: Optional["scout_api_Priority"] = None
    _assignee: Optional[str] = None
    _event_type: Optional["event_EventType"] = None
    _created_by: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["event_HistogramFilterQuery"]] = None
    _or_: Optional[List["event_HistogramFilterQuery"]] = None
    _not_: Optional["event_HistogramFilterQuery"] = None
    _workspace: Optional[str] = None
    _procedure: Optional[str] = None
    _procedure_execution: Optional[str] = None
    _step_id: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'template': ConjureFieldDefinition('template', scout_rids_api_TemplateRid),
            'workbook': ConjureFieldDefinition('workbook', scout_rids_api_NotebookRid),
            'data_review': ConjureFieldDefinition('dataReview', scout_rids_api_DataReviewRid),
            'origin_type': ConjureFieldDefinition('originType', event_SearchEventOriginType),
            'data_review_check': ConjureFieldDefinition('dataReviewCheck', scout_rids_api_CheckRid),
            'disposition_status': ConjureFieldDefinition('dispositionStatus', event_EventDispositionStatus),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'assignee': ConjureFieldDefinition('assignee', scout_rids_api_UserRid),
            'event_type': ConjureFieldDefinition('eventType', event_EventType),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[event_HistogramFilterQuery]),
            'or_': ConjureFieldDefinition('or', List[event_HistogramFilterQuery]),
            'not_': ConjureFieldDefinition('not', event_HistogramFilterQuery),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'procedure': ConjureFieldDefinition('procedure', api_rids_ProcedureRid),
            'procedure_execution': ConjureFieldDefinition('procedureExecution', api_rids_ProcedureExecutionRid),
            'step_id': ConjureFieldDefinition('stepId', str)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            asset: Optional[str] = None,
            template: Optional[str] = None,
            workbook: Optional[str] = None,
            data_review: Optional[str] = None,
            origin_type: Optional["event_SearchEventOriginType"] = None,
            data_review_check: Optional[str] = None,
            disposition_status: Optional["event_EventDispositionStatus"] = None,
            priority: Optional["scout_api_Priority"] = None,
            assignee: Optional[str] = None,
            event_type: Optional["event_EventType"] = None,
            created_by: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["event_HistogramFilterQuery"]] = None,
            or_: Optional[List["event_HistogramFilterQuery"]] = None,
            not_: Optional["event_HistogramFilterQuery"] = None,
            workspace: Optional[str] = None,
            procedure: Optional[str] = None,
            procedure_execution: Optional[str] = None,
            step_id: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (asset is not None) + (template is not None) + (workbook is not None) + (data_review is not None) + (origin_type is not None) + (data_review_check is not None) + (disposition_status is not None) + (priority is not None) + (assignee is not None) + (event_type is not None) + (created_by is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) + (workspace is not None) + (procedure is not None) + (procedure_execution is not None) + (step_id is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if template is not None:
                self._template = template
                self._type = 'template'
            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if data_review is not None:
                self._data_review = data_review
                self._type = 'dataReview'
            if origin_type is not None:
                self._origin_type = origin_type
                self._type = 'originType'
            if data_review_check is not None:
                self._data_review_check = data_review_check
                self._type = 'dataReviewCheck'
            if disposition_status is not None:
                self._disposition_status = disposition_status
                self._type = 'dispositionStatus'
            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if assignee is not None:
                self._assignee = assignee
                self._type = 'assignee'
            if event_type is not None:
                self._event_type = event_type
                self._type = 'eventType'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'
            if procedure_execution is not None:
                self._procedure_execution = procedure_execution
                self._type = 'procedureExecution'
            if step_id is not None:
                self._step_id = step_id
                self._type = 'stepId'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'template':
            if template is None:
                raise ValueError('a union value must not be None')
            self._template = template
            self._type = 'template'
        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'dataReview':
            if data_review is None:
                raise ValueError('a union value must not be None')
            self._data_review = data_review
            self._type = 'dataReview'
        elif type_of_union == 'originType':
            if origin_type is None:
                raise ValueError('a union value must not be None')
            self._origin_type = origin_type
            self._type = 'originType'
        elif type_of_union == 'dataReviewCheck':
            if data_review_check is None:
                raise ValueError('a union value must not be None')
            self._data_review_check = data_review_check
            self._type = 'dataReviewCheck'
        elif type_of_union == 'dispositionStatus':
            if disposition_status is None:
                raise ValueError('a union value must not be None')
            self._disposition_status = disposition_status
            self._type = 'dispositionStatus'
        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'assignee':
            if assignee is None:
                raise ValueError('a union value must not be None')
            self._assignee = assignee
            self._type = 'assignee'
        elif type_of_union == 'eventType':
            if event_type is None:
                raise ValueError('a union value must not be None')
            self._event_type = event_type
            self._type = 'eventType'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'
        elif type_of_union == 'procedureExecution':
            if procedure_execution is None:
                raise ValueError('a union value must not be None')
            self._procedure_execution = procedure_execution
            self._type = 'procedureExecution'
        elif type_of_union == 'stepId':
            if step_id is None:
                raise ValueError('a union value must not be None')
            self._step_id = step_id
            self._type = 'stepId'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def template(self) -> Optional[str]:
        return self._template

    @builtins.property
    def workbook(self) -> Optional[str]:
        return self._workbook

    @builtins.property
    def data_review(self) -> Optional[str]:
        return self._data_review

    @builtins.property
    def origin_type(self) -> Optional["event_SearchEventOriginType"]:
        return self._origin_type

    @builtins.property
    def data_review_check(self) -> Optional[str]:
        return self._data_review_check

    @builtins.property
    def disposition_status(self) -> Optional["event_EventDispositionStatus"]:
        return self._disposition_status

    @builtins.property
    def priority(self) -> Optional["scout_api_Priority"]:
        return self._priority

    @builtins.property
    def assignee(self) -> Optional[str]:
        return self._assignee

    @builtins.property
    def event_type(self) -> Optional["event_EventType"]:
        return self._event_type

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["event_HistogramFilterQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["event_HistogramFilterQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["event_HistogramFilterQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def procedure(self) -> Optional[str]:
        return self._procedure

    @builtins.property
    def procedure_execution(self) -> Optional[str]:
        return self._procedure_execution

    @builtins.property
    def step_id(self) -> Optional[str]:
        return self._step_id

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, event_HistogramFilterQueryVisitor):
            raise ValueError('{} is not an instance of event_HistogramFilterQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'template' and self.template is not None:
            return visitor._template(self.template)
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'dataReview' and self.data_review is not None:
            return visitor._data_review(self.data_review)
        if self._type == 'originType' and self.origin_type is not None:
            return visitor._origin_type(self.origin_type)
        if self._type == 'dataReviewCheck' and self.data_review_check is not None:
            return visitor._data_review_check(self.data_review_check)
        if self._type == 'dispositionStatus' and self.disposition_status is not None:
            return visitor._disposition_status(self.disposition_status)
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'assignee' and self.assignee is not None:
            return visitor._assignee(self.assignee)
        if self._type == 'eventType' and self.event_type is not None:
            return visitor._event_type(self.event_type)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)
        if self._type == 'procedureExecution' and self.procedure_execution is not None:
            return visitor._procedure_execution(self.procedure_execution)
        if self._type == 'stepId' and self.step_id is not None:
            return visitor._step_id(self.step_id)


event_HistogramFilterQuery.__name__ = "HistogramFilterQuery"
event_HistogramFilterQuery.__qualname__ = "HistogramFilterQuery"
event_HistogramFilterQuery.__module__ = "nominal_api.event"


class event_HistogramFilterQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: str) -> Any:
        pass

    @abstractmethod
    def _template(self, template: str) -> Any:
        pass

    @abstractmethod
    def _workbook(self, workbook: str) -> Any:
        pass

    @abstractmethod
    def _data_review(self, data_review: str) -> Any:
        pass

    @abstractmethod
    def _origin_type(self, origin_type: "event_SearchEventOriginType") -> Any:
        pass

    @abstractmethod
    def _data_review_check(self, data_review_check: str) -> Any:
        pass

    @abstractmethod
    def _disposition_status(self, disposition_status: "event_EventDispositionStatus") -> Any:
        pass

    @abstractmethod
    def _priority(self, priority: "scout_api_Priority") -> Any:
        pass

    @abstractmethod
    def _assignee(self, assignee: str) -> Any:
        pass

    @abstractmethod
    def _event_type(self, event_type: "event_EventType") -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["event_HistogramFilterQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["event_HistogramFilterQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "event_HistogramFilterQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: str) -> Any:
        pass

    @abstractmethod
    def _procedure_execution(self, procedure_execution: str) -> Any:
        pass

    @abstractmethod
    def _step_id(self, step_id: str) -> Any:
        pass


event_HistogramFilterQueryVisitor.__name__ = "HistogramFilterQueryVisitor"
event_HistogramFilterQueryVisitor.__qualname__ = "HistogramFilterQueryVisitor"
event_HistogramFilterQueryVisitor.__module__ = "nominal_api.event"


class event_ListPropertiesAndLabelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspaces': ConjureFieldDefinition('workspaces', OptionalTypeWrapper[List[api_rids_WorkspaceRid]])
        }

    __slots__: List[str] = ['_workspaces']

    def __init__(self, workspaces: Optional[List[str]] = None) -> None:
        self._workspaces = workspaces

    @builtins.property
    def workspaces(self) -> Optional[List[str]]:
        """If omitted, results will come from all workspaces the user belongs to.
        """
        return self._workspaces


event_ListPropertiesAndLabelsRequest.__name__ = "ListPropertiesAndLabelsRequest"
event_ListPropertiesAndLabelsRequest.__qualname__ = "ListPropertiesAndLabelsRequest"
event_ListPropertiesAndLabelsRequest.__module__ = "nominal_api.event"


class event_OriginTypesFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'origin_types': ConjureFieldDefinition('originTypes', List[event_SearchEventOriginType])
        }

    __slots__: List[str] = ['_operator', '_origin_types']

    def __init__(self, operator: "api_SetOperator", origin_types: List["event_SearchEventOriginType"]) -> None:
        self._operator = operator
        self._origin_types = origin_types

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def origin_types(self) -> List["event_SearchEventOriginType"]:
        return self._origin_types


event_OriginTypesFilter.__name__ = "OriginTypesFilter"
event_OriginTypesFilter.__qualname__ = "OriginTypesFilter"
event_OriginTypesFilter.__module__ = "nominal_api.event"


class event_ProcedureEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'procedure_execution_rid': ConjureFieldDefinition('procedureExecutionRid', api_rids_ProcedureExecutionRid),
            'procedure_rid': ConjureFieldDefinition('procedureRid', api_rids_ProcedureRid),
            'step_id': ConjureFieldDefinition('stepId', str)
        }

    __slots__: List[str] = ['_procedure_execution_rid', '_procedure_rid', '_step_id']

    def __init__(self, procedure_execution_rid: str, procedure_rid: str, step_id: str) -> None:
        self._procedure_execution_rid = procedure_execution_rid
        self._procedure_rid = procedure_rid
        self._step_id = step_id

    @builtins.property
    def procedure_execution_rid(self) -> str:
        return self._procedure_execution_rid

    @builtins.property
    def procedure_rid(self) -> str:
        return self._procedure_rid

    @builtins.property
    def step_id(self) -> str:
        return self._step_id


event_ProcedureEventOrigin.__name__ = "ProcedureEventOrigin"
event_ProcedureEventOrigin.__qualname__ = "ProcedureEventOrigin"
event_ProcedureEventOrigin.__module__ = "nominal_api.event"


class event_SearchEventOriginType(ConjureEnumType):

    WORKBOOK = 'WORKBOOK'
    '''WORKBOOK'''
    TEMPLATE = 'TEMPLATE'
    '''TEMPLATE'''
    API = 'API'
    '''API'''
    DATA_REVIEW = 'DATA_REVIEW'
    '''DATA_REVIEW'''
    PROCEDURE = 'PROCEDURE'
    '''PROCEDURE'''
    STREAMING_CHECKLIST = 'STREAMING_CHECKLIST'
    '''STREAMING_CHECKLIST'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_SearchEventOriginType.__name__ = "SearchEventOriginType"
event_SearchEventOriginType.__qualname__ = "SearchEventOriginType"
event_SearchEventOriginType.__module__ = "nominal_api.event"


class event_SearchEventsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', event_SortOptions),
            'page_size': ConjureFieldDefinition('pageSize', int),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'query': ConjureFieldDefinition('query', event_SearchQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, page_size: int, query: "event_SearchQuery", sort: "event_SortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "event_SortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> int:
        """Will reject page sizes greater than 10k.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "event_SearchQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived events in search.
        """
        return self._archived_statuses


event_SearchEventsRequest.__name__ = "SearchEventsRequest"
event_SearchEventsRequest.__qualname__ = "SearchEventsRequest"
event_SearchEventsRequest.__module__ = "nominal_api.event"


class event_SearchEventsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[event_Event]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["event_Event"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["event_Event"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


event_SearchEventsResponse.__name__ = "SearchEventsResponse"
event_SearchEventsResponse.__qualname__ = "SearchEventsResponse"
event_SearchEventsResponse.__module__ = "nominal_api.event"


class event_SearchQuery(ConjureUnionType):
    _archived: Optional[bool] = None
    _search_text: Optional[str] = None
    _after: Optional["api_Timestamp"] = None
    _before: Optional["api_Timestamp"] = None
    _advanced_time_filter: Optional["event_EventTimeFilter"] = None
    _asset: Optional[str] = None
    _assets: Optional["event_AssetsFilter"] = None
    _template: Optional[str] = None
    _workbook: Optional[str] = None
    _data_review: Optional[str] = None
    _data_reviews: Optional["event_DataReviewsFilter"] = None
    _origin_type: Optional["event_SearchEventOriginType"] = None
    _origin_types: Optional["event_OriginTypesFilter"] = None
    _data_review_check: Optional[str] = None
    _data_review_checks: Optional["event_DataReviewChecksFilter"] = None
    _disposition_status: Optional["event_EventDispositionStatus"] = None
    _disposition_statuses: Optional[List["event_EventDispositionStatus"]] = None
    _priority: Optional["scout_api_Priority"] = None
    _priorities: Optional[List["scout_api_Priority"]] = None
    _assignee: Optional[str] = None
    _assignees: Optional["event_AssigneesFilter"] = None
    _event_type: Optional["event_EventType"] = None
    _event_types: Optional[List["event_EventType"]] = None
    _created_by: Optional[str] = None
    _created_by_any_of: Optional[List[str]] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _and_: Optional[List["event_SearchQuery"]] = None
    _or_: Optional[List["event_SearchQuery"]] = None
    _not_: Optional["event_SearchQuery"] = None
    _workspace: Optional[str] = None
    _procedure: Optional[str] = None
    _procedure_execution: Optional[str] = None
    _step_id: Optional[str] = None
    _streaming_checklist: Optional[str] = None
    _streaming_check: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'archived': ConjureFieldDefinition('archived', bool),
            'search_text': ConjureFieldDefinition('searchText', str),
            'after': ConjureFieldDefinition('after', api_Timestamp),
            'before': ConjureFieldDefinition('before', api_Timestamp),
            'advanced_time_filter': ConjureFieldDefinition('advancedTimeFilter', event_EventTimeFilter),
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'assets': ConjureFieldDefinition('assets', event_AssetsFilter),
            'template': ConjureFieldDefinition('template', scout_rids_api_TemplateRid),
            'workbook': ConjureFieldDefinition('workbook', scout_rids_api_NotebookRid),
            'data_review': ConjureFieldDefinition('dataReview', scout_rids_api_DataReviewRid),
            'data_reviews': ConjureFieldDefinition('dataReviews', event_DataReviewsFilter),
            'origin_type': ConjureFieldDefinition('originType', event_SearchEventOriginType),
            'origin_types': ConjureFieldDefinition('originTypes', event_OriginTypesFilter),
            'data_review_check': ConjureFieldDefinition('dataReviewCheck', scout_rids_api_CheckRid),
            'data_review_checks': ConjureFieldDefinition('dataReviewChecks', event_DataReviewChecksFilter),
            'disposition_status': ConjureFieldDefinition('dispositionStatus', event_EventDispositionStatus),
            'disposition_statuses': ConjureFieldDefinition('dispositionStatuses', List[event_EventDispositionStatus]),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'priorities': ConjureFieldDefinition('priorities', List[scout_api_Priority]),
            'assignee': ConjureFieldDefinition('assignee', scout_rids_api_UserRid),
            'assignees': ConjureFieldDefinition('assignees', event_AssigneesFilter),
            'event_type': ConjureFieldDefinition('eventType', event_EventType),
            'event_types': ConjureFieldDefinition('eventTypes', List[event_EventType]),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_by_any_of': ConjureFieldDefinition('createdByAnyOf', List[scout_rids_api_UserRid]),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'and_': ConjureFieldDefinition('and', List[event_SearchQuery]),
            'or_': ConjureFieldDefinition('or', List[event_SearchQuery]),
            'not_': ConjureFieldDefinition('not', event_SearchQuery),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'procedure': ConjureFieldDefinition('procedure', api_rids_ProcedureRid),
            'procedure_execution': ConjureFieldDefinition('procedureExecution', api_rids_ProcedureExecutionRid),
            'step_id': ConjureFieldDefinition('stepId', str),
            'streaming_checklist': ConjureFieldDefinition('streamingChecklist', scout_rids_api_ChecklistRid),
            'streaming_check': ConjureFieldDefinition('streamingCheck', scout_rids_api_CheckRid)
        }

    def __init__(
            self,
            archived: Optional[bool] = None,
            search_text: Optional[str] = None,
            after: Optional["api_Timestamp"] = None,
            before: Optional["api_Timestamp"] = None,
            advanced_time_filter: Optional["event_EventTimeFilter"] = None,
            asset: Optional[str] = None,
            assets: Optional["event_AssetsFilter"] = None,
            template: Optional[str] = None,
            workbook: Optional[str] = None,
            data_review: Optional[str] = None,
            data_reviews: Optional["event_DataReviewsFilter"] = None,
            origin_type: Optional["event_SearchEventOriginType"] = None,
            origin_types: Optional["event_OriginTypesFilter"] = None,
            data_review_check: Optional[str] = None,
            data_review_checks: Optional["event_DataReviewChecksFilter"] = None,
            disposition_status: Optional["event_EventDispositionStatus"] = None,
            disposition_statuses: Optional[List["event_EventDispositionStatus"]] = None,
            priority: Optional["scout_api_Priority"] = None,
            priorities: Optional[List["scout_api_Priority"]] = None,
            assignee: Optional[str] = None,
            assignees: Optional["event_AssigneesFilter"] = None,
            event_type: Optional["event_EventType"] = None,
            event_types: Optional[List["event_EventType"]] = None,
            created_by: Optional[str] = None,
            created_by_any_of: Optional[List[str]] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            and_: Optional[List["event_SearchQuery"]] = None,
            or_: Optional[List["event_SearchQuery"]] = None,
            not_: Optional["event_SearchQuery"] = None,
            workspace: Optional[str] = None,
            procedure: Optional[str] = None,
            procedure_execution: Optional[str] = None,
            step_id: Optional[str] = None,
            streaming_checklist: Optional[str] = None,
            streaming_check: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (archived is not None) + (search_text is not None) + (after is not None) + (before is not None) + (advanced_time_filter is not None) + (asset is not None) + (assets is not None) + (template is not None) + (workbook is not None) + (data_review is not None) + (data_reviews is not None) + (origin_type is not None) + (origin_types is not None) + (data_review_check is not None) + (data_review_checks is not None) + (disposition_status is not None) + (disposition_statuses is not None) + (priority is not None) + (priorities is not None) + (assignee is not None) + (assignees is not None) + (event_type is not None) + (event_types is not None) + (created_by is not None) + (created_by_any_of is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) + (workspace is not None) + (procedure is not None) + (procedure_execution is not None) + (step_id is not None) + (streaming_checklist is not None) + (streaming_check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if archived is not None:
                self._archived = archived
                self._type = 'archived'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if after is not None:
                self._after = after
                self._type = 'after'
            if before is not None:
                self._before = before
                self._type = 'before'
            if advanced_time_filter is not None:
                self._advanced_time_filter = advanced_time_filter
                self._type = 'advancedTimeFilter'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if assets is not None:
                self._assets = assets
                self._type = 'assets'
            if template is not None:
                self._template = template
                self._type = 'template'
            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if data_review is not None:
                self._data_review = data_review
                self._type = 'dataReview'
            if data_reviews is not None:
                self._data_reviews = data_reviews
                self._type = 'dataReviews'
            if origin_type is not None:
                self._origin_type = origin_type
                self._type = 'originType'
            if origin_types is not None:
                self._origin_types = origin_types
                self._type = 'originTypes'
            if data_review_check is not None:
                self._data_review_check = data_review_check
                self._type = 'dataReviewCheck'
            if data_review_checks is not None:
                self._data_review_checks = data_review_checks
                self._type = 'dataReviewChecks'
            if disposition_status is not None:
                self._disposition_status = disposition_status
                self._type = 'dispositionStatus'
            if disposition_statuses is not None:
                self._disposition_statuses = disposition_statuses
                self._type = 'dispositionStatuses'
            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if priorities is not None:
                self._priorities = priorities
                self._type = 'priorities'
            if assignee is not None:
                self._assignee = assignee
                self._type = 'assignee'
            if assignees is not None:
                self._assignees = assignees
                self._type = 'assignees'
            if event_type is not None:
                self._event_type = event_type
                self._type = 'eventType'
            if event_types is not None:
                self._event_types = event_types
                self._type = 'eventTypes'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if created_by_any_of is not None:
                self._created_by_any_of = created_by_any_of
                self._type = 'createdByAnyOf'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'
            if procedure_execution is not None:
                self._procedure_execution = procedure_execution
                self._type = 'procedureExecution'
            if step_id is not None:
                self._step_id = step_id
                self._type = 'stepId'
            if streaming_checklist is not None:
                self._streaming_checklist = streaming_checklist
                self._type = 'streamingChecklist'
            if streaming_check is not None:
                self._streaming_check = streaming_check
                self._type = 'streamingCheck'

        elif type_of_union == 'archived':
            if archived is None:
                raise ValueError('a union value must not be None')
            self._archived = archived
            self._type = 'archived'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'after':
            if after is None:
                raise ValueError('a union value must not be None')
            self._after = after
            self._type = 'after'
        elif type_of_union == 'before':
            if before is None:
                raise ValueError('a union value must not be None')
            self._before = before
            self._type = 'before'
        elif type_of_union == 'advancedTimeFilter':
            if advanced_time_filter is None:
                raise ValueError('a union value must not be None')
            self._advanced_time_filter = advanced_time_filter
            self._type = 'advancedTimeFilter'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'assets':
            if assets is None:
                raise ValueError('a union value must not be None')
            self._assets = assets
            self._type = 'assets'
        elif type_of_union == 'template':
            if template is None:
                raise ValueError('a union value must not be None')
            self._template = template
            self._type = 'template'
        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'dataReview':
            if data_review is None:
                raise ValueError('a union value must not be None')
            self._data_review = data_review
            self._type = 'dataReview'
        elif type_of_union == 'dataReviews':
            if data_reviews is None:
                raise ValueError('a union value must not be None')
            self._data_reviews = data_reviews
            self._type = 'dataReviews'
        elif type_of_union == 'originType':
            if origin_type is None:
                raise ValueError('a union value must not be None')
            self._origin_type = origin_type
            self._type = 'originType'
        elif type_of_union == 'originTypes':
            if origin_types is None:
                raise ValueError('a union value must not be None')
            self._origin_types = origin_types
            self._type = 'originTypes'
        elif type_of_union == 'dataReviewCheck':
            if data_review_check is None:
                raise ValueError('a union value must not be None')
            self._data_review_check = data_review_check
            self._type = 'dataReviewCheck'
        elif type_of_union == 'dataReviewChecks':
            if data_review_checks is None:
                raise ValueError('a union value must not be None')
            self._data_review_checks = data_review_checks
            self._type = 'dataReviewChecks'
        elif type_of_union == 'dispositionStatus':
            if disposition_status is None:
                raise ValueError('a union value must not be None')
            self._disposition_status = disposition_status
            self._type = 'dispositionStatus'
        elif type_of_union == 'dispositionStatuses':
            if disposition_statuses is None:
                raise ValueError('a union value must not be None')
            self._disposition_statuses = disposition_statuses
            self._type = 'dispositionStatuses'
        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'priorities':
            if priorities is None:
                raise ValueError('a union value must not be None')
            self._priorities = priorities
            self._type = 'priorities'
        elif type_of_union == 'assignee':
            if assignee is None:
                raise ValueError('a union value must not be None')
            self._assignee = assignee
            self._type = 'assignee'
        elif type_of_union == 'assignees':
            if assignees is None:
                raise ValueError('a union value must not be None')
            self._assignees = assignees
            self._type = 'assignees'
        elif type_of_union == 'eventType':
            if event_type is None:
                raise ValueError('a union value must not be None')
            self._event_type = event_type
            self._type = 'eventType'
        elif type_of_union == 'eventTypes':
            if event_types is None:
                raise ValueError('a union value must not be None')
            self._event_types = event_types
            self._type = 'eventTypes'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'createdByAnyOf':
            if created_by_any_of is None:
                raise ValueError('a union value must not be None')
            self._created_by_any_of = created_by_any_of
            self._type = 'createdByAnyOf'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'
        elif type_of_union == 'procedureExecution':
            if procedure_execution is None:
                raise ValueError('a union value must not be None')
            self._procedure_execution = procedure_execution
            self._type = 'procedureExecution'
        elif type_of_union == 'stepId':
            if step_id is None:
                raise ValueError('a union value must not be None')
            self._step_id = step_id
            self._type = 'stepId'
        elif type_of_union == 'streamingChecklist':
            if streaming_checklist is None:
                raise ValueError('a union value must not be None')
            self._streaming_checklist = streaming_checklist
            self._type = 'streamingChecklist'
        elif type_of_union == 'streamingCheck':
            if streaming_check is None:
                raise ValueError('a union value must not be None')
            self._streaming_check = streaming_check
            self._type = 'streamingCheck'

    @builtins.property
    def archived(self) -> Optional[bool]:
        return self._archived

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def after(self) -> Optional["api_Timestamp"]:
        """Filters to events after this timestamp, exclusive.
This includes events that start before, but end after this time.
        """
        return self._after

    @builtins.property
    def before(self) -> Optional["api_Timestamp"]:
        """Filters to events before this timestamp, exclusive.
This includes events that start before, but end after this time.
        """
        return self._before

    @builtins.property
    def advanced_time_filter(self) -> Optional["event_EventTimeFilter"]:
        return self._advanced_time_filter

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def assets(self) -> Optional["event_AssetsFilter"]:
        return self._assets

    @builtins.property
    def template(self) -> Optional[str]:
        return self._template

    @builtins.property
    def workbook(self) -> Optional[str]:
        return self._workbook

    @builtins.property
    def data_review(self) -> Optional[str]:
        return self._data_review

    @builtins.property
    def data_reviews(self) -> Optional["event_DataReviewsFilter"]:
        return self._data_reviews

    @builtins.property
    def origin_type(self) -> Optional["event_SearchEventOriginType"]:
        return self._origin_type

    @builtins.property
    def origin_types(self) -> Optional["event_OriginTypesFilter"]:
        return self._origin_types

    @builtins.property
    def data_review_check(self) -> Optional[str]:
        return self._data_review_check

    @builtins.property
    def data_review_checks(self) -> Optional["event_DataReviewChecksFilter"]:
        return self._data_review_checks

    @builtins.property
    def disposition_status(self) -> Optional["event_EventDispositionStatus"]:
        return self._disposition_status

    @builtins.property
    def disposition_statuses(self) -> Optional[List["event_EventDispositionStatus"]]:
        return self._disposition_statuses

    @builtins.property
    def priority(self) -> Optional["scout_api_Priority"]:
        return self._priority

    @builtins.property
    def priorities(self) -> Optional[List["scout_api_Priority"]]:
        return self._priorities

    @builtins.property
    def assignee(self) -> Optional[str]:
        return self._assignee

    @builtins.property
    def assignees(self) -> Optional["event_AssigneesFilter"]:
        return self._assignees

    @builtins.property
    def event_type(self) -> Optional["event_EventType"]:
        return self._event_type

    @builtins.property
    def event_types(self) -> Optional[List["event_EventType"]]:
        return self._event_types

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def created_by_any_of(self) -> Optional[List[str]]:
        return self._created_by_any_of

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def and_(self) -> Optional[List["event_SearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["event_SearchQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["event_SearchQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def procedure(self) -> Optional[str]:
        return self._procedure

    @builtins.property
    def procedure_execution(self) -> Optional[str]:
        return self._procedure_execution

    @builtins.property
    def step_id(self) -> Optional[str]:
        return self._step_id

    @builtins.property
    def streaming_checklist(self) -> Optional[str]:
        """Filters to events created from a checklist executing in streaming.
Use `assets` to further filter to a specific streaming checklist instance.
        """
        return self._streaming_checklist

    @builtins.property
    def streaming_check(self) -> Optional[str]:
        """Filters to events created from the check of a checklist executing in streaming.
Use `assets` to further filter to a specific streaming checklist instance.
        """
        return self._streaming_check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, event_SearchQueryVisitor):
            raise ValueError('{} is not an instance of event_SearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'archived' and self.archived is not None:
            return visitor._archived(self.archived)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'after' and self.after is not None:
            return visitor._after(self.after)
        if self._type == 'before' and self.before is not None:
            return visitor._before(self.before)
        if self._type == 'advancedTimeFilter' and self.advanced_time_filter is not None:
            return visitor._advanced_time_filter(self.advanced_time_filter)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'assets' and self.assets is not None:
            return visitor._assets(self.assets)
        if self._type == 'template' and self.template is not None:
            return visitor._template(self.template)
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'dataReview' and self.data_review is not None:
            return visitor._data_review(self.data_review)
        if self._type == 'dataReviews' and self.data_reviews is not None:
            return visitor._data_reviews(self.data_reviews)
        if self._type == 'originType' and self.origin_type is not None:
            return visitor._origin_type(self.origin_type)
        if self._type == 'originTypes' and self.origin_types is not None:
            return visitor._origin_types(self.origin_types)
        if self._type == 'dataReviewCheck' and self.data_review_check is not None:
            return visitor._data_review_check(self.data_review_check)
        if self._type == 'dataReviewChecks' and self.data_review_checks is not None:
            return visitor._data_review_checks(self.data_review_checks)
        if self._type == 'dispositionStatus' and self.disposition_status is not None:
            return visitor._disposition_status(self.disposition_status)
        if self._type == 'dispositionStatuses' and self.disposition_statuses is not None:
            return visitor._disposition_statuses(self.disposition_statuses)
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'priorities' and self.priorities is not None:
            return visitor._priorities(self.priorities)
        if self._type == 'assignee' and self.assignee is not None:
            return visitor._assignee(self.assignee)
        if self._type == 'assignees' and self.assignees is not None:
            return visitor._assignees(self.assignees)
        if self._type == 'eventType' and self.event_type is not None:
            return visitor._event_type(self.event_type)
        if self._type == 'eventTypes' and self.event_types is not None:
            return visitor._event_types(self.event_types)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'createdByAnyOf' and self.created_by_any_of is not None:
            return visitor._created_by_any_of(self.created_by_any_of)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)
        if self._type == 'procedureExecution' and self.procedure_execution is not None:
            return visitor._procedure_execution(self.procedure_execution)
        if self._type == 'stepId' and self.step_id is not None:
            return visitor._step_id(self.step_id)
        if self._type == 'streamingChecklist' and self.streaming_checklist is not None:
            return visitor._streaming_checklist(self.streaming_checklist)
        if self._type == 'streamingCheck' and self.streaming_check is not None:
            return visitor._streaming_check(self.streaming_check)


event_SearchQuery.__name__ = "SearchQuery"
event_SearchQuery.__qualname__ = "SearchQuery"
event_SearchQuery.__module__ = "nominal_api.event"


class event_SearchQueryVisitor:

    @abstractmethod
    def _archived(self, archived: bool) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _after(self, after: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _before(self, before: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _advanced_time_filter(self, advanced_time_filter: "event_EventTimeFilter") -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: str) -> Any:
        pass

    @abstractmethod
    def _assets(self, assets: "event_AssetsFilter") -> Any:
        pass

    @abstractmethod
    def _template(self, template: str) -> Any:
        pass

    @abstractmethod
    def _workbook(self, workbook: str) -> Any:
        pass

    @abstractmethod
    def _data_review(self, data_review: str) -> Any:
        pass

    @abstractmethod
    def _data_reviews(self, data_reviews: "event_DataReviewsFilter") -> Any:
        pass

    @abstractmethod
    def _origin_type(self, origin_type: "event_SearchEventOriginType") -> Any:
        pass

    @abstractmethod
    def _origin_types(self, origin_types: "event_OriginTypesFilter") -> Any:
        pass

    @abstractmethod
    def _data_review_check(self, data_review_check: str) -> Any:
        pass

    @abstractmethod
    def _data_review_checks(self, data_review_checks: "event_DataReviewChecksFilter") -> Any:
        pass

    @abstractmethod
    def _disposition_status(self, disposition_status: "event_EventDispositionStatus") -> Any:
        pass

    @abstractmethod
    def _disposition_statuses(self, disposition_statuses: List["event_EventDispositionStatus"]) -> Any:
        pass

    @abstractmethod
    def _priority(self, priority: "scout_api_Priority") -> Any:
        pass

    @abstractmethod
    def _priorities(self, priorities: List["scout_api_Priority"]) -> Any:
        pass

    @abstractmethod
    def _assignee(self, assignee: str) -> Any:
        pass

    @abstractmethod
    def _assignees(self, assignees: "event_AssigneesFilter") -> Any:
        pass

    @abstractmethod
    def _event_type(self, event_type: "event_EventType") -> Any:
        pass

    @abstractmethod
    def _event_types(self, event_types: List["event_EventType"]) -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: str) -> Any:
        pass

    @abstractmethod
    def _created_by_any_of(self, created_by_any_of: List[str]) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["event_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["event_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "event_SearchQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: str) -> Any:
        pass

    @abstractmethod
    def _procedure_execution(self, procedure_execution: str) -> Any:
        pass

    @abstractmethod
    def _step_id(self, step_id: str) -> Any:
        pass

    @abstractmethod
    def _streaming_checklist(self, streaming_checklist: str) -> Any:
        pass

    @abstractmethod
    def _streaming_check(self, streaming_check: str) -> Any:
        pass


event_SearchQueryVisitor.__name__ = "SearchQueryVisitor"
event_SearchQueryVisitor.__qualname__ = "SearchQueryVisitor"
event_SearchQueryVisitor.__module__ = "nominal_api.event"


class event_SortField(ConjureEnumType):

    START_TIME = 'START_TIME'
    '''START_TIME'''
    END_TIME = 'END_TIME'
    '''END_TIME'''
    DURATION = 'DURATION'
    '''DURATION'''
    DISPOSITION_STATUS = 'DISPOSITION_STATUS'
    '''DISPOSITION_STATUS'''
    PRIORITY = 'PRIORITY'
    '''PRIORITY'''
    EVENT_NAME = 'EVENT_NAME'
    '''EVENT_NAME'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


event_SortField.__name__ = "SortField"
event_SortField.__qualname__ = "SortField"
event_SortField.__module__ = "nominal_api.event"


class event_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', event_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "event_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "event_SortField":
        return self._field


event_SortOptions.__name__ = "SortOptions"
event_SortOptions.__qualname__ = "SortOptions"
event_SortOptions.__module__ = "nominal_api.event"


class event_StreamingCheckOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', scout_rids_api_CheckLineageRid),
            'implementation_index': ConjureFieldDefinition('implementationIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_check_rid', '_check_lineage_rid', '_implementation_index']

    def __init__(self, check_lineage_rid: str, check_rid: str, implementation_index: Optional[int] = None) -> None:
        self._check_rid = check_rid
        self._check_lineage_rid = check_lineage_rid
        self._implementation_index = implementation_index

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_lineage_rid(self) -> str:
        return self._check_lineage_rid

    @builtins.property
    def implementation_index(self) -> Optional[int]:
        return self._implementation_index


event_StreamingCheckOriginMetadata.__name__ = "StreamingCheckOriginMetadata"
event_StreamingCheckOriginMetadata.__qualname__ = "StreamingCheckOriginMetadata"
event_StreamingCheckOriginMetadata.__module__ = "nominal_api.event"


class event_StreamingChecklistEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'check_metadata': ConjureFieldDefinition('checkMetadata', event_StreamingCheckOriginMetadata)
        }

    __slots__: List[str] = ['_checklist_rid', '_check_metadata']

    def __init__(self, check_metadata: "event_StreamingCheckOriginMetadata", checklist_rid: str) -> None:
        self._checklist_rid = checklist_rid
        self._check_metadata = check_metadata

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def check_metadata(self) -> "event_StreamingCheckOriginMetadata":
        """Metadata about the check that created this event.
        """
        return self._check_metadata


event_StreamingChecklistEventOrigin.__name__ = "StreamingChecklistEventOrigin"
event_StreamingChecklistEventOrigin.__qualname__ = "StreamingChecklistEventOrigin"
event_StreamingChecklistEventOrigin.__module__ = "nominal_api.event"


class event_TemplateEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TemplateRid)
        }

    __slots__: List[str] = ['_rid']

    def __init__(self, rid: str) -> None:
        self._rid = rid

    @builtins.property
    def rid(self) -> str:
        return self._rid


event_TemplateEventOrigin.__name__ = "TemplateEventOrigin"
event_TemplateEventOrigin.__qualname__ = "TemplateEventOrigin"
event_TemplateEventOrigin.__module__ = "nominal_api.event"


class event_TimeSeriesChannelAssociation(ConjureBeanType):
    """A singular time series to associate the event with.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', str),
            'tags': ConjureFieldDefinition('tags', OptionalTypeWrapper[Dict[str, str]])
        }

    __slots__: List[str] = ['_variable_name', '_tags']

    def __init__(self, variable_name: str, tags: Optional[Dict[str, str]] = None) -> None:
        self._variable_name = variable_name
        self._tags = tags

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def tags(self) -> Optional[Dict[str, str]]:
        """If this variable is grouped, the tags within the groupings this event should associate with
        """
        return self._tags


event_TimeSeriesChannelAssociation.__name__ = "TimeSeriesChannelAssociation"
event_TimeSeriesChannelAssociation.__qualname__ = "TimeSeriesChannelAssociation"
event_TimeSeriesChannelAssociation.__module__ = "nominal_api.event"


class event_UpdateDispositionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_EventRid),
            'disposition': ConjureFieldDefinition('disposition', OptionalTypeWrapper[event_EventDisposition])
        }

    __slots__: List[str] = ['_rid', '_disposition']

    def __init__(self, rid: str, disposition: Optional["event_EventDisposition"] = None) -> None:
        self._rid = rid
        self._disposition = disposition

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def disposition(self) -> Optional["event_EventDisposition"]:
        """The new disposition for the event.
If empty, will remove the disposition from the event.
        """
        return self._disposition


event_UpdateDispositionRequest.__name__ = "UpdateDispositionRequest"
event_UpdateDispositionRequest.__qualname__ = "UpdateDispositionRequest"
event_UpdateDispositionRequest.__module__ = "nominal_api.event"


class event_UpdateEvent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'rid': ConjureFieldDefinition('rid', OptionalTypeWrapper[api_rids_EventRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', OptionalTypeWrapper[List[scout_rids_api_AssetRid]]),
            'timestamp': ConjureFieldDefinition('timestamp', OptionalTypeWrapper[api_Timestamp]),
            'duration': ConjureFieldDefinition('duration', OptionalTypeWrapper[scout_run_api_Duration]),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[event_EventType]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]])
        }

    __slots__: List[str] = ['_uuid', '_rid', '_asset_rids', '_timestamp', '_duration', '_name', '_description', '_type', '_labels', '_properties']

    def __init__(self, uuid: str, asset_rids: Optional[List[str]] = None, description: Optional[str] = None, duration: Optional["scout_run_api_Duration"] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None, rid: Optional[str] = None, timestamp: Optional["api_Timestamp"] = None, type: Optional["event_EventType"] = None) -> None:
        self._uuid = uuid
        self._rid = rid
        self._asset_rids = asset_rids
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._description = description
        self._type = type
        self._labels = labels
        self._properties = properties

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def rid(self) -> Optional[str]:
        """The unique identifier for the event.
This field is required if the uuid field is not provided.
        """
        return self._rid

    @builtins.property
    def asset_rids(self) -> Optional[List[str]]:
        """If provided, will replace the existing asset rids.
If provided, must contain at least one asset rid.
        """
        return self._asset_rids

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def type(self) -> Optional["event_EventType"]:
        return self._type

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties


event_UpdateEvent.__name__ = "UpdateEvent"
event_UpdateEvent.__qualname__ = "UpdateEvent"
event_UpdateEvent.__module__ = "nominal_api.event"


class event_UpdateEventRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_EventRid),
            'asset_rids': ConjureFieldDefinition('assetRids', OptionalTypeWrapper[List[scout_rids_api_AssetRid]]),
            'timestamp': ConjureFieldDefinition('timestamp', OptionalTypeWrapper[api_Timestamp]),
            'duration': ConjureFieldDefinition('duration', OptionalTypeWrapper[scout_run_api_Duration]),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[event_EventType]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]])
        }

    __slots__: List[str] = ['_rid', '_asset_rids', '_timestamp', '_duration', '_name', '_description', '_type', '_labels', '_properties']

    def __init__(self, rid: str, asset_rids: Optional[List[str]] = None, description: Optional[str] = None, duration: Optional["scout_run_api_Duration"] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None, timestamp: Optional["api_Timestamp"] = None, type: Optional["event_EventType"] = None) -> None:
        self._rid = rid
        self._asset_rids = asset_rids
        self._timestamp = timestamp
        self._duration = duration
        self._name = name
        self._description = description
        self._type = type
        self._labels = labels
        self._properties = properties

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def asset_rids(self) -> Optional[List[str]]:
        """If provided, will replace the existing asset rids.
If provided, must contain at least one asset rid.
        """
        return self._asset_rids

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def type(self) -> Optional["event_EventType"]:
        return self._type

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties


event_UpdateEventRequest.__name__ = "UpdateEventRequest"
event_UpdateEventRequest.__qualname__ = "UpdateEventRequest"
event_UpdateEventRequest.__module__ = "nominal_api.event"


class event_WorkbookDataAssociation(ConjureUnionType):
    _time_series_channel: Optional["event_TimeSeriesChannelAssociation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_series_channel': ConjureFieldDefinition('timeSeriesChannel', event_TimeSeriesChannelAssociation)
        }

    def __init__(
            self,
            time_series_channel: Optional["event_TimeSeriesChannelAssociation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_series_channel is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_series_channel is not None:
                self._time_series_channel = time_series_channel
                self._type = 'timeSeriesChannel'

        elif type_of_union == 'timeSeriesChannel':
            if time_series_channel is None:
                raise ValueError('a union value must not be None')
            self._time_series_channel = time_series_channel
            self._type = 'timeSeriesChannel'

    @builtins.property
    def time_series_channel(self) -> Optional["event_TimeSeriesChannelAssociation"]:
        return self._time_series_channel

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, event_WorkbookDataAssociationVisitor):
            raise ValueError('{} is not an instance of event_WorkbookDataAssociationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeSeriesChannel' and self.time_series_channel is not None:
            return visitor._time_series_channel(self.time_series_channel)


event_WorkbookDataAssociation.__name__ = "WorkbookDataAssociation"
event_WorkbookDataAssociation.__qualname__ = "WorkbookDataAssociation"
event_WorkbookDataAssociation.__module__ = "nominal_api.event"


class event_WorkbookDataAssociationVisitor:

    @abstractmethod
    def _time_series_channel(self, time_series_channel: "event_TimeSeriesChannelAssociation") -> Any:
        pass


event_WorkbookDataAssociationVisitor.__name__ = "WorkbookDataAssociationVisitor"
event_WorkbookDataAssociationVisitor.__qualname__ = "WorkbookDataAssociationVisitor"
event_WorkbookDataAssociationVisitor.__module__ = "nominal_api.event"


class event_WorkbookEventOrigin(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'data': ConjureFieldDefinition('data', OptionalTypeWrapper[List[event_WorkbookDataAssociation]])
        }

    __slots__: List[str] = ['_rid', '_data']

    def __init__(self, rid: str, data: Optional[List["event_WorkbookDataAssociation"]] = None) -> None:
        self._rid = rid
        self._data = data

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def data(self) -> Optional[List["event_WorkbookDataAssociation"]]:
        """Data visualizations to associate this event with
        """
        return self._data


event_WorkbookEventOrigin.__name__ = "WorkbookEventOrigin"
event_WorkbookEventOrigin.__qualname__ = "WorkbookEventOrigin"
event_WorkbookEventOrigin.__module__ = "nominal_api.event"


class ingest_api_AbsoluteTimestamp(ConjureUnionType):
    _iso8601: Optional["ingest_api_Iso8601Timestamp"] = None
    _epoch_of_time_unit: Optional["ingest_api_EpochTimestamp"] = None
    _custom_format: Optional["ingest_api_CustomTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', ingest_api_Iso8601Timestamp),
            'epoch_of_time_unit': ConjureFieldDefinition('epochOfTimeUnit', ingest_api_EpochTimestamp),
            'custom_format': ConjureFieldDefinition('customFormat', ingest_api_CustomTimestamp)
        }

    def __init__(
            self,
            iso8601: Optional["ingest_api_Iso8601Timestamp"] = None,
            epoch_of_time_unit: Optional["ingest_api_EpochTimestamp"] = None,
            custom_format: Optional["ingest_api_CustomTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (epoch_of_time_unit is not None) + (custom_format is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if epoch_of_time_unit is not None:
                self._epoch_of_time_unit = epoch_of_time_unit
                self._type = 'epochOfTimeUnit'
            if custom_format is not None:
                self._custom_format = custom_format
                self._type = 'customFormat'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'epochOfTimeUnit':
            if epoch_of_time_unit is None:
                raise ValueError('a union value must not be None')
            self._epoch_of_time_unit = epoch_of_time_unit
            self._type = 'epochOfTimeUnit'
        elif type_of_union == 'customFormat':
            if custom_format is None:
                raise ValueError('a union value must not be None')
            self._custom_format = custom_format
            self._type = 'customFormat'

    @builtins.property
    def iso8601(self) -> Optional["ingest_api_Iso8601Timestamp"]:
        return self._iso8601

    @builtins.property
    def epoch_of_time_unit(self) -> Optional["ingest_api_EpochTimestamp"]:
        return self._epoch_of_time_unit

    @builtins.property
    def custom_format(self) -> Optional["ingest_api_CustomTimestamp"]:
        return self._custom_format

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_AbsoluteTimestampVisitor):
            raise ValueError('{} is not an instance of ingest_api_AbsoluteTimestampVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'epochOfTimeUnit' and self.epoch_of_time_unit is not None:
            return visitor._epoch_of_time_unit(self.epoch_of_time_unit)
        if self._type == 'customFormat' and self.custom_format is not None:
            return visitor._custom_format(self.custom_format)


ingest_api_AbsoluteTimestamp.__name__ = "AbsoluteTimestamp"
ingest_api_AbsoluteTimestamp.__qualname__ = "AbsoluteTimestamp"
ingest_api_AbsoluteTimestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_AbsoluteTimestampVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "ingest_api_Iso8601Timestamp") -> Any:
        pass

    @abstractmethod
    def _epoch_of_time_unit(self, epoch_of_time_unit: "ingest_api_EpochTimestamp") -> Any:
        pass

    @abstractmethod
    def _custom_format(self, custom_format: "ingest_api_CustomTimestamp") -> Any:
        pass


ingest_api_AbsoluteTimestampVisitor.__name__ = "AbsoluteTimestampVisitor"
ingest_api_AbsoluteTimestampVisitor.__qualname__ = "AbsoluteTimestampVisitor"
ingest_api_AbsoluteTimestampVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_AsyncHandle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str)
        }

    __slots__: List[str] = ['_rid']

    def __init__(self, rid: str) -> None:
        self._rid = rid

    @builtins.property
    def rid(self) -> str:
        return self._rid


ingest_api_AsyncHandle.__name__ = "AsyncHandle"
ingest_api_AsyncHandle.__qualname__ = "AsyncHandle"
ingest_api_AsyncHandle.__module__ = "nominal_api.ingest_api"


class ingest_api_Authentication(ConjureUnionType):
    """Authentication methods for Docker registries.
    """
    _user_and_password: Optional["ingest_api_UserAndPasswordAuthentication"] = None
    _public: Optional["ingest_api_PublicAuthentication"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'user_and_password': ConjureFieldDefinition('userAndPassword', ingest_api_UserAndPasswordAuthentication),
            'public': ConjureFieldDefinition('public', ingest_api_PublicAuthentication)
        }

    def __init__(
            self,
            user_and_password: Optional["ingest_api_UserAndPasswordAuthentication"] = None,
            public: Optional["ingest_api_PublicAuthentication"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (user_and_password is not None) + (public is not None) != 1:
                raise ValueError('a union must contain a single member')

            if user_and_password is not None:
                self._user_and_password = user_and_password
                self._type = 'userAndPassword'
            if public is not None:
                self._public = public
                self._type = 'public'

        elif type_of_union == 'userAndPassword':
            if user_and_password is None:
                raise ValueError('a union value must not be None')
            self._user_and_password = user_and_password
            self._type = 'userAndPassword'
        elif type_of_union == 'public':
            if public is None:
                raise ValueError('a union value must not be None')
            self._public = public
            self._type = 'public'

    @builtins.property
    def user_and_password(self) -> Optional["ingest_api_UserAndPasswordAuthentication"]:
        return self._user_and_password

    @builtins.property
    def public(self) -> Optional["ingest_api_PublicAuthentication"]:
        return self._public

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_AuthenticationVisitor):
            raise ValueError('{} is not an instance of ingest_api_AuthenticationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'userAndPassword' and self.user_and_password is not None:
            return visitor._user_and_password(self.user_and_password)
        if self._type == 'public' and self.public is not None:
            return visitor._public(self.public)


ingest_api_Authentication.__name__ = "Authentication"
ingest_api_Authentication.__qualname__ = "Authentication"
ingest_api_Authentication.__module__ = "nominal_api.ingest_api"


class ingest_api_AuthenticationVisitor:

    @abstractmethod
    def _user_and_password(self, user_and_password: "ingest_api_UserAndPasswordAuthentication") -> Any:
        pass

    @abstractmethod
    def _public(self, public: "ingest_api_PublicAuthentication") -> Any:
        pass


ingest_api_AuthenticationVisitor.__name__ = "AuthenticationVisitor"
ingest_api_AuthenticationVisitor.__qualname__ = "AuthenticationVisitor"
ingest_api_AuthenticationVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_AvroStreamOpts(ConjureBeanType):
    """Options for ingesting Avro data with the following schema. This is a "stream-like" file format to support
use cases where a columnar/tabular format does not make sense. This closely matches Nominal's streaming
API, making it useful for use cases where network connection drops during streaming and a backup file needs
to be created.

If this schema is not used, will result in a failed ingestion.
{
    "type": "record",
    "name": "AvroStream",
    "namespace": "io.nominal.ingest",
    "fields": [
        {
            "name": "channel",
            "type": "string",
            "doc": "Channel/series name (e.g., 'vehicle_id', 'col_1', 'temperature')",
        },
        {
            "name": "timestamps",
            "type": {"type": "array", "items": "long"},
            "doc": "Array of Unix timestamps in nanoseconds",
        },
        {
            "name": "values",
            "type": {"type": "array", "items": ["double", "string"]},
            "doc": "Array of values. Can either be doubles or strings",
        },
        {
            "name": "tags",
            "type": {"type": "map", "values": "string"},
            "default": {},
            "doc": "Key-value metadata tags",
        },
    ],
}
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget)
        }

    __slots__: List[str] = ['_source', '_target']

    def __init__(self, source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget") -> None:
        self._source = source
        self._target = target

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target


ingest_api_AvroStreamOpts.__name__ = "AvroStreamOpts"
ingest_api_AvroStreamOpts.__qualname__ = "AvroStreamOpts"
ingest_api_AvroStreamOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_ChannelConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'prefix_tree_delimiter': ConjureFieldDefinition('prefixTreeDelimiter', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_prefix_tree_delimiter']

    def __init__(self, prefix_tree_delimiter: Optional[str] = None) -> None:
        self._prefix_tree_delimiter = prefix_tree_delimiter

    @builtins.property
    def prefix_tree_delimiter(self) -> Optional[str]:
        """If set, will construct a prefix tree for channels of the dataset using the given delimiter.
        """
        return self._prefix_tree_delimiter


ingest_api_ChannelConfig.__name__ = "ChannelConfig"
ingest_api_ChannelConfig.__qualname__ = "ChannelConfig"
ingest_api_ChannelConfig.__module__ = "nominal_api.ingest_api"


class ingest_api_CompleteMultipartUploadResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'location': ConjureFieldDefinition('location', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_location']

    def __init__(self, location: Optional[str] = None) -> None:
        self._location = location

    @builtins.property
    def location(self) -> Optional[str]:
        return self._location


ingest_api_CompleteMultipartUploadResponse.__name__ = "CompleteMultipartUploadResponse"
ingest_api_CompleteMultipartUploadResponse.__qualname__ = "CompleteMultipartUploadResponse"
ingest_api_CompleteMultipartUploadResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_ContainerizedExtractor(ConjureBeanType):
    """Represents a containerized extractor that processes input files using a container.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', ingest_api_ContainerizedExtractorRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'image': ConjureFieldDefinition('image', ingest_api_DockerImageSource),
            'inputs': ConjureFieldDefinition('inputs', List[ingest_api_FileExtractionInput]),
            'parameters': ConjureFieldDefinition('parameters', List[ingest_api_FileExtractionParameter]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'output_file_format': ConjureFieldDefinition('outputFileFormat', ingest_api_FileOutputFormat)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_image', '_inputs', '_parameters', '_properties', '_labels', '_created_at', '_is_archived', '_timestamp_metadata', '_output_file_format']

    def __init__(self, created_at: str, image: "ingest_api_DockerImageSource", inputs: List["ingest_api_FileExtractionInput"], is_archived: bool, labels: List[str], name: str, output_file_format: "ingest_api_FileOutputFormat", parameters: List["ingest_api_FileExtractionParameter"], properties: Dict[str, str], rid: str, description: Optional[str] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._image = image
        self._inputs = inputs
        self._parameters = parameters
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived
        self._timestamp_metadata = timestamp_metadata
        self._output_file_format = output_file_format

    @builtins.property
    def rid(self) -> str:
        """Unique resource identifier for the extractor.
        """
        return self._rid

    @builtins.property
    def name(self) -> str:
        """The name of the extractor as defined by the user.
        """
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        """Optional description of the extractor.
        """
        return self._description

    @builtins.property
    def image(self) -> "ingest_api_DockerImageSource":
        """Container image used to run the extractor.
        """
        return self._image

    @builtins.property
    def inputs(self) -> List["ingest_api_FileExtractionInput"]:
        """The input files that this extractor requires, mapped to environment variables that store the path to the file.
        """
        return self._inputs

    @builtins.property
    def parameters(self) -> List["ingest_api_FileExtractionParameter"]:
        """Describes the parameters of the extractor.
        """
        return self._parameters

    @builtins.property
    def properties(self) -> Dict[str, str]:
        """Additional properties associated with this extractor.
        """
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        """Set of labels applied to this extractor.
        """
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        """Timestamp when this extractor was created.
        """
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        """Whether this extractor is archived.
        """
        return self._is_archived

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        """Metadata about the intermediate parquet this extractor will produce.
If not set, timestamp metadata must be provided at ingest time.
        """
        return self._timestamp_metadata

    @builtins.property
    def output_file_format(self) -> "ingest_api_FileOutputFormat":
        """The format of the output file. Currently only "parquet", "csv", "parquet.tar" are supported
        """
        return self._output_file_format


ingest_api_ContainerizedExtractor.__name__ = "ContainerizedExtractor"
ingest_api_ContainerizedExtractor.__qualname__ = "ContainerizedExtractor"
ingest_api_ContainerizedExtractor.__module__ = "nominal_api.ingest_api"


class ingest_api_ContainerizedExtractorService(Service):
    """The Containerized Extractor service provides functionality for creating, updating, and archiving containerized extractors.
    """

    def register_containerized_extractor(self, auth_header: str, request: "ingest_api_RegisterContainerizedExtractorRequest") -> "ingest_api_RegisterContainerizedExtractorResponse":
        """Registers a containerized extractor for a given set of containerized files.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/extractors/v1/container'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_RegisterContainerizedExtractorResponse, self._return_none_for_unknown_union_types)

    def get_containerized_extractor(self, auth_header: str, extractor_rid: str) -> "ingest_api_ContainerizedExtractor":
        """Get a containerized extractor by its RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'extractorRid': quote(str(_conjure_encoder.default(extractor_rid)), safe=''),
        }

        _json: Any = None

        _path = '/extractors/v1/container/{extractorRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_ContainerizedExtractor, self._return_none_for_unknown_union_types)

    def search_containerized_extractors(self, auth_header: str, request: "ingest_api_SearchContainerizedExtractorsRequest") -> List["ingest_api_ContainerizedExtractor"]:
        """Search for containerized extractors based on query parameters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/extractors/v1/container/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[ingest_api_ContainerizedExtractor], self._return_none_for_unknown_union_types)

    def update_containerized_extractor(self, auth_header: str, extractor_rid: str, request: "ingest_api_UpdateContainerizedExtractorRequest") -> "ingest_api_ContainerizedExtractor":
        """Update a containerized extractor. Only the fields that are set in the request will be updated.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'extractorRid': quote(str(_conjure_encoder.default(extractor_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/extractors/v1/container/{extractorRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_ContainerizedExtractor, self._return_none_for_unknown_union_types)

    def archive_containerized_extractor(self, auth_header: str, extractor_rid: str) -> None:
        """Archive a containerized extractor.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'extractorRid': quote(str(_conjure_encoder.default(extractor_rid)), safe=''),
        }

        _json: Any = None

        _path = '/extractors/v1/container/{extractorRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_containerized_extractor(self, auth_header: str, extractor_rid: str) -> None:
        """Unarchive a containerized extractor.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'extractorRid': quote(str(_conjure_encoder.default(extractor_rid)), safe=''),
        }

        _json: Any = None

        _path = '/extractors/v1/container/{extractorRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


ingest_api_ContainerizedExtractorService.__name__ = "ContainerizedExtractorService"
ingest_api_ContainerizedExtractorService.__qualname__ = "ContainerizedExtractorService"
ingest_api_ContainerizedExtractorService.__module__ = "nominal_api.ingest_api"


class ingest_api_ContainerizedOpts(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', Dict[ingest_api_EnvironmentVariable, ingest_api_IngestSource]),
            'arguments': ConjureFieldDefinition('arguments', Dict[ingest_api_EnvironmentVariable, str]),
            'extractor_rid': ConjureFieldDefinition('extractorRid', ingest_api_ContainerizedExtractorRid),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'tag': ConjureFieldDefinition('tag', OptionalTypeWrapper[str]),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_sources', '_arguments', '_extractor_rid', '_timestamp_metadata', '_tag', '_target', '_additional_file_tags']

    def __init__(self, additional_file_tags: Dict[str, str], arguments: Dict[str, str], extractor_rid: str, sources: Dict[str, "ingest_api_IngestSource"], target: "ingest_api_DatasetIngestTarget", tag: Optional[str] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._sources = sources
        self._arguments = arguments
        self._extractor_rid = extractor_rid
        self._timestamp_metadata = timestamp_metadata
        self._tag = tag
        self._target = target
        self._additional_file_tags = additional_file_tags

    @builtins.property
    def sources(self) -> Dict[str, "ingest_api_IngestSource"]:
        return self._sources

    @builtins.property
    def arguments(self) -> Dict[str, str]:
        return self._arguments

    @builtins.property
    def extractor_rid(self) -> str:
        return self._extractor_rid

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def tag(self) -> Optional[str]:
        return self._tag

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def additional_file_tags(self) -> Dict[str, str]:
        """Specifies a tag set to apply to all data in the file.
        """
        return self._additional_file_tags


ingest_api_ContainerizedOpts.__name__ = "ContainerizedOpts"
ingest_api_ContainerizedOpts.__qualname__ = "ContainerizedOpts"
ingest_api_ContainerizedOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_CreateIngestJobRequest(ConjureBeanType):
    """Request to create a new ingest job.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid),
            'ingest_job_request': ConjureFieldDefinition('ingestJobRequest', ingest_api_IngestJobRequest)
        }

    __slots__: List[str] = ['_workspace_rid', '_ingest_job_request']

    def __init__(self, ingest_job_request: "ingest_api_IngestJobRequest", workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid
        self._ingest_job_request = ingest_job_request

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid

    @builtins.property
    def ingest_job_request(self) -> "ingest_api_IngestJobRequest":
        return self._ingest_job_request


ingest_api_CreateIngestJobRequest.__name__ = "CreateIngestJobRequest"
ingest_api_CreateIngestJobRequest.__qualname__ = "CreateIngestJobRequest"
ingest_api_CreateIngestJobRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_CsvOpts(ConjureBeanType):
    """Options for ingesting csv files.  Supported file formats include .csv, .csv.gz
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', ingest_api_TimestampMetadata),
            'channel_prefix': ConjureFieldDefinition('channelPrefix', ingest_api_ChannelPrefix),
            'tag_keys_from_columns': ConjureFieldDefinition('tagKeysFromColumns', OptionalTypeWrapper[List[api_TagName]]),
            'tag_columns': ConjureFieldDefinition('tagColumns', OptionalTypeWrapper[Dict[api_TagName, api_ColumnName]]),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]]),
            'exclude_columns': ConjureFieldDefinition('excludeColumns', List[api_ColumnName])
        }

    __slots__: List[str] = ['_source', '_target', '_timestamp_metadata', '_channel_prefix', '_tag_keys_from_columns', '_tag_columns', '_additional_file_tags', '_exclude_columns']

    def __init__(self, exclude_columns: List[str], source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget", timestamp_metadata: "ingest_api_TimestampMetadata", additional_file_tags: Optional[Dict[str, str]] = None, channel_prefix: Optional[str] = None, tag_columns: Optional[Dict[str, str]] = None, tag_keys_from_columns: Optional[List[str]] = None) -> None:
        self._source = source
        self._target = target
        self._timestamp_metadata = timestamp_metadata
        self._channel_prefix = channel_prefix
        self._tag_keys_from_columns = tag_keys_from_columns
        self._tag_columns = tag_columns
        self._additional_file_tags = additional_file_tags
        self._exclude_columns = exclude_columns

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def timestamp_metadata(self) -> "ingest_api_TimestampMetadata":
        return self._timestamp_metadata

    @builtins.property
    def channel_prefix(self) -> Optional[str]:
        return self._channel_prefix

    @builtins.property
    def tag_keys_from_columns(self) -> Optional[List[str]]:
        return self._tag_keys_from_columns

    @builtins.property
    def tag_columns(self) -> Optional[Dict[str, str]]:
        """A map of tag names to column names to derive the tag values from.
        """
        return self._tag_columns

    @builtins.property
    def additional_file_tags(self) -> Optional[Dict[str, str]]:
        """Specifies a tag set to apply to all data in the file.
        """
        return self._additional_file_tags

    @builtins.property
    def exclude_columns(self) -> List[str]:
        """A set of column names to exclude from ingestion. These columns will not be
ingested as channels. Useful for excluding columns that contain unsupported
data types like multidimensional arrays.
        """
        return self._exclude_columns


ingest_api_CsvOpts.__name__ = "CsvOpts"
ingest_api_CsvOpts.__qualname__ = "CsvOpts"
ingest_api_CsvOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_CustomTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', str),
            'default_year': ConjureFieldDefinition('defaultYear', OptionalTypeWrapper[int]),
            'default_day_of_year': ConjureFieldDefinition('defaultDayOfYear', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_format', '_default_year', '_default_day_of_year']

    def __init__(self, format: str, default_day_of_year: Optional[int] = None, default_year: Optional[int] = None) -> None:
        self._format = format
        self._default_year = default_year
        self._default_day_of_year = default_day_of_year

    @builtins.property
    def format(self) -> str:
        """The format string should be in the format of the `DateTimeFormatter` class in Java.
        """
        return self._format

    @builtins.property
    def default_year(self) -> Optional[int]:
        """Default year is accepted as an optional field for cases like IRIG time format and will be overridden by year in time format.
        """
        return self._default_year

    @builtins.property
    def default_day_of_year(self) -> Optional[int]:
        """Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format.
        """
        return self._default_day_of_year


ingest_api_CustomTimestamp.__name__ = "CustomTimestamp"
ingest_api_CustomTimestamp.__qualname__ = "CustomTimestamp"
ingest_api_CustomTimestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_DataflashOpts(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]])
        }

    __slots__: List[str] = ['_source', '_target', '_additional_file_tags']

    def __init__(self, source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget", additional_file_tags: Optional[Dict[str, str]] = None) -> None:
        self._source = source
        self._target = target
        self._additional_file_tags = additional_file_tags

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def additional_file_tags(self) -> Optional[Dict[str, str]]:
        """Specifies a tag set to apply to all data in the file.
        """
        return self._additional_file_tags


ingest_api_DataflashOpts.__name__ = "DataflashOpts"
ingest_api_DataflashOpts.__qualname__ = "DataflashOpts"
ingest_api_DataflashOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_DatasetIngestTarget(ConjureUnionType):
    _new: Optional["ingest_api_NewDatasetIngestDestination"] = None
    _existing: Optional["ingest_api_ExistingDatasetIngestDestination"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new': ConjureFieldDefinition('new', ingest_api_NewDatasetIngestDestination),
            'existing': ConjureFieldDefinition('existing', ingest_api_ExistingDatasetIngestDestination)
        }

    def __init__(
            self,
            new: Optional["ingest_api_NewDatasetIngestDestination"] = None,
            existing: Optional["ingest_api_ExistingDatasetIngestDestination"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (new is not None) + (existing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if new is not None:
                self._new = new
                self._type = 'new'
            if existing is not None:
                self._existing = existing
                self._type = 'existing'

        elif type_of_union == 'new':
            if new is None:
                raise ValueError('a union value must not be None')
            self._new = new
            self._type = 'new'
        elif type_of_union == 'existing':
            if existing is None:
                raise ValueError('a union value must not be None')
            self._existing = existing
            self._type = 'existing'

    @builtins.property
    def new(self) -> Optional["ingest_api_NewDatasetIngestDestination"]:
        return self._new

    @builtins.property
    def existing(self) -> Optional["ingest_api_ExistingDatasetIngestDestination"]:
        return self._existing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_DatasetIngestTargetVisitor):
            raise ValueError('{} is not an instance of ingest_api_DatasetIngestTargetVisitor'.format(visitor.__class__.__name__))
        if self._type == 'new' and self.new is not None:
            return visitor._new(self.new)
        if self._type == 'existing' and self.existing is not None:
            return visitor._existing(self.existing)


ingest_api_DatasetIngestTarget.__name__ = "DatasetIngestTarget"
ingest_api_DatasetIngestTarget.__qualname__ = "DatasetIngestTarget"
ingest_api_DatasetIngestTarget.__module__ = "nominal_api.ingest_api"


class ingest_api_DatasetIngestTargetVisitor:

    @abstractmethod
    def _new(self, new: "ingest_api_NewDatasetIngestDestination") -> Any:
        pass

    @abstractmethod
    def _existing(self, existing: "ingest_api_ExistingDatasetIngestDestination") -> Any:
        pass


ingest_api_DatasetIngestTargetVisitor.__name__ = "DatasetIngestTargetVisitor"
ingest_api_DatasetIngestTargetVisitor.__qualname__ = "DatasetIngestTargetVisitor"
ingest_api_DatasetIngestTargetVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_DatasetSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: Optional[str] = None) -> None:
        self._name = name

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name


ingest_api_DatasetSpec.__name__ = "DatasetSpec"
ingest_api_DatasetSpec.__qualname__ = "DatasetSpec"
ingest_api_DatasetSpec.__module__ = "nominal_api.ingest_api"


class ingest_api_DeprecatedNewCsv(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[str, str]),
            'time_column_spec': ConjureFieldDefinition('timeColumnSpec', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_source', '_name', '_properties', '_time_column_spec', '_channel_config']

    def __init__(self, properties: Dict[str, str], source: "ingest_api_IngestSource", channel_config: Optional["ingest_api_ChannelConfig"] = None, name: Optional[str] = None, time_column_spec: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._source = source
        self._name = name
        self._properties = properties
        self._time_column_spec = time_column_spec
        self._channel_config = channel_config

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def time_column_spec(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._time_column_spec

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config


ingest_api_DeprecatedNewCsv.__name__ = "DeprecatedNewCsv"
ingest_api_DeprecatedNewCsv.__qualname__ = "DeprecatedNewCsv"
ingest_api_DeprecatedNewCsv.__module__ = "nominal_api.ingest_api"


class ingest_api_DeprecatedNewDataSource(ConjureUnionType):
    _csv: Optional["ingest_api_DeprecatedNewCsv"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'csv': ConjureFieldDefinition('csv', ingest_api_DeprecatedNewCsv)
        }

    def __init__(
            self,
            csv: Optional["ingest_api_DeprecatedNewCsv"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (csv is not None) != 1:
                raise ValueError('a union must contain a single member')

            if csv is not None:
                self._csv = csv
                self._type = 'csv'

        elif type_of_union == 'csv':
            if csv is None:
                raise ValueError('a union value must not be None')
            self._csv = csv
            self._type = 'csv'

    @builtins.property
    def csv(self) -> Optional["ingest_api_DeprecatedNewCsv"]:
        return self._csv

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_DeprecatedNewDataSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_DeprecatedNewDataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'csv' and self.csv is not None:
            return visitor._csv(self.csv)


ingest_api_DeprecatedNewDataSource.__name__ = "DeprecatedNewDataSource"
ingest_api_DeprecatedNewDataSource.__qualname__ = "DeprecatedNewDataSource"
ingest_api_DeprecatedNewDataSource.__module__ = "nominal_api.ingest_api"


class ingest_api_DeprecatedNewDataSourceVisitor:

    @abstractmethod
    def _csv(self, csv: "ingest_api_DeprecatedNewCsv") -> Any:
        pass


ingest_api_DeprecatedNewDataSourceVisitor.__name__ = "DeprecatedNewDataSourceVisitor"
ingest_api_DeprecatedNewDataSourceVisitor.__qualname__ = "DeprecatedNewDataSourceVisitor"
ingest_api_DeprecatedNewDataSourceVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_DockerImageSource(ConjureBeanType):
    """Docker container image source definition.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'registry': ConjureFieldDefinition('registry', str),
            'repository': ConjureFieldDefinition('repository', str),
            'tag_details': ConjureFieldDefinition('tagDetails', ingest_api_TagDetails),
            'authentication': ConjureFieldDefinition('authentication', ingest_api_Authentication),
            'command': ConjureFieldDefinition('command', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_registry', '_repository', '_tag_details', '_authentication', '_command']

    def __init__(self, authentication: "ingest_api_Authentication", registry: str, repository: str, tag_details: "ingest_api_TagDetails", command: Optional[str] = None) -> None:
        self._registry = registry
        self._repository = repository
        self._tag_details = tag_details
        self._authentication = authentication
        self._command = command

    @builtins.property
    def registry(self) -> str:
        """The container registry where the image is hosted.
        """
        return self._registry

    @builtins.property
    def repository(self) -> str:
        """The repository name of the image.
        """
        return self._repository

    @builtins.property
    def tag_details(self) -> "ingest_api_TagDetails":
        return self._tag_details

    @builtins.property
    def authentication(self) -> "ingest_api_Authentication":
        """Optional authentication for accessing private container registries.
        """
        return self._authentication

    @builtins.property
    def command(self) -> Optional[str]:
        return self._command


ingest_api_DockerImageSource.__name__ = "DockerImageSource"
ingest_api_DockerImageSource.__qualname__ = "DockerImageSource"
ingest_api_DockerImageSource.__module__ = "nominal_api.ingest_api"


class ingest_api_EpochTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit)
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: "api_TimeUnit") -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit


ingest_api_EpochTimestamp.__name__ = "EpochTimestamp"
ingest_api_EpochTimestamp.__qualname__ = "EpochTimestamp"
ingest_api_EpochTimestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_ExistingDatasetIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', str),
            'expand_run_bounds': ConjureFieldDefinition('expandRunBounds', OptionalTypeWrapper[List[scout_run_api_RunRid]])
        }

    __slots__: List[str] = ['_dataset_rid', '_expand_run_bounds']

    def __init__(self, dataset_rid: str, expand_run_bounds: Optional[List[str]] = None) -> None:
        self._dataset_rid = dataset_rid
        self._expand_run_bounds = expand_run_bounds

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def expand_run_bounds(self) -> Optional[List[str]]:
        """The ingest will keep track of the range of timestamps in the ingested data and update the included
run's time bounds.
For runs with no end time (uninitialized), it will always set the start time to the file's start time
and set the end time to the file's end time.
For runs with existing end times, it will only expand the bounds (earliest start time, latest end time).
        """
        return self._expand_run_bounds


ingest_api_ExistingDatasetIngestDestination.__name__ = "ExistingDatasetIngestDestination"
ingest_api_ExistingDatasetIngestDestination.__qualname__ = "ExistingDatasetIngestDestination"
ingest_api_ExistingDatasetIngestDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_ExistingVideoIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'video_file_details': ConjureFieldDefinition('videoFileDetails', OptionalTypeWrapper[ingest_api_VideoFileIngestDetails])
        }

    __slots__: List[str] = ['_video_rid', '_video_file_details']

    def __init__(self, video_rid: str, video_file_details: Optional["ingest_api_VideoFileIngestDetails"] = None) -> None:
        self._video_rid = video_rid
        self._video_file_details = video_file_details

    @builtins.property
    def video_rid(self) -> str:
        """RID of the video to ingest the newly created video file to.
        """
        return self._video_rid

    @builtins.property
    def video_file_details(self) -> Optional["ingest_api_VideoFileIngestDetails"]:
        """Metadata to associate with any created video file
        """
        return self._video_file_details


ingest_api_ExistingVideoIngestDestination.__name__ = "ExistingVideoIngestDestination"
ingest_api_ExistingVideoIngestDestination.__qualname__ = "ExistingVideoIngestDestination"
ingest_api_ExistingVideoIngestDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_FileExtractionInput(ConjureBeanType):
    """Defines an input file to be provided to the extractor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'environment_variable': ConjureFieldDefinition('environmentVariable', ingest_api_EnvironmentVariable),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'file_filters': ConjureFieldDefinition('fileFilters', List[ingest_api_FileFilter]),
            'required': ConjureFieldDefinition('required', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_environment_variable', '_name', '_description', '_file_filters', '_required']

    def __init__(self, environment_variable: str, file_filters: List["ingest_api_FileFilter"], name: str, description: Optional[str] = None, required: Optional[bool] = None) -> None:
        self._environment_variable = environment_variable
        self._name = name
        self._description = description
        self._file_filters = file_filters
        self._required = required

    @builtins.property
    def environment_variable(self) -> str:
        """The environment variable that stores the path to the input file.
        """
        return self._environment_variable

    @builtins.property
    def name(self) -> str:
        """Name of the input file which users will be prompted with
        """
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        """Description of the input file which users will be prompted with
        """
        return self._description

    @builtins.property
    def file_filters(self) -> List["ingest_api_FileFilter"]:
        """Optionally filter files for file selection
        """
        return self._file_filters

    @builtins.property
    def required(self) -> Optional[bool]:
        """Whether the input file is required for the extractor to run.
        """
        return self._required


ingest_api_FileExtractionInput.__name__ = "FileExtractionInput"
ingest_api_FileExtractionInput.__qualname__ = "FileExtractionInput"
ingest_api_FileExtractionInput.__module__ = "nominal_api.ingest_api"


class ingest_api_FileExtractionParameter(ConjureBeanType):
    """Defines an input parameter to be provided to the extractor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'environment_variable': ConjureFieldDefinition('environmentVariable', ingest_api_EnvironmentVariable),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'required': ConjureFieldDefinition('required', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_environment_variable', '_name', '_description', '_required']

    def __init__(self, environment_variable: str, name: str, description: Optional[str] = None, required: Optional[bool] = None) -> None:
        self._environment_variable = environment_variable
        self._name = name
        self._description = description
        self._required = required

    @builtins.property
    def environment_variable(self) -> str:
        """The environment variable that stores the argument
        """
        return self._environment_variable

    @builtins.property
    def name(self) -> str:
        """Name of the parameter which users will be prompted with
        """
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        """Description of the parameter which users will be prompted with
        """
        return self._description

    @builtins.property
    def required(self) -> Optional[bool]:
        """Whether the parameter is required for the extractor to run.
        """
        return self._required


ingest_api_FileExtractionParameter.__name__ = "FileExtractionParameter"
ingest_api_FileExtractionParameter.__qualname__ = "FileExtractionParameter"
ingest_api_FileExtractionParameter.__module__ = "nominal_api.ingest_api"


class ingest_api_FileFilter(ConjureUnionType):
    _suffix: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'suffix': ConjureFieldDefinition('suffix', ingest_api_FileSuffix)
        }

    def __init__(
            self,
            suffix: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (suffix is not None) != 1:
                raise ValueError('a union must contain a single member')

            if suffix is not None:
                self._suffix = suffix
                self._type = 'suffix'

        elif type_of_union == 'suffix':
            if suffix is None:
                raise ValueError('a union value must not be None')
            self._suffix = suffix
            self._type = 'suffix'

    @builtins.property
    def suffix(self) -> Optional[str]:
        return self._suffix

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_FileFilterVisitor):
            raise ValueError('{} is not an instance of ingest_api_FileFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'suffix' and self.suffix is not None:
            return visitor._suffix(self.suffix)


ingest_api_FileFilter.__name__ = "FileFilter"
ingest_api_FileFilter.__qualname__ = "FileFilter"
ingest_api_FileFilter.__module__ = "nominal_api.ingest_api"


class ingest_api_FileFilterVisitor:

    @abstractmethod
    def _suffix(self, suffix: str) -> Any:
        pass


ingest_api_FileFilterVisitor.__name__ = "FileFilterVisitor"
ingest_api_FileFilterVisitor.__qualname__ = "FileFilterVisitor"
ingest_api_FileFilterVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_FileOutputFormat(ConjureEnumType):

    PARQUET = 'PARQUET'
    '''PARQUET'''
    CSV = 'CSV'
    '''CSV'''
    PARQUET_TAR = 'PARQUET_TAR'
    '''PARQUET_TAR'''
    AVRO_STREAM = 'AVRO_STREAM'
    '''AVRO_STREAM'''
    JSON_L = 'JSON_L'
    '''JSON_L'''
    MANIFEST = 'MANIFEST'
    '''MANIFEST'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_FileOutputFormat.__name__ = "FileOutputFormat"
ingest_api_FileOutputFormat.__qualname__ = "FileOutputFormat"
ingest_api_FileOutputFormat.__module__ = "nominal_api.ingest_api"


class ingest_api_GcsIngestSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', str)
        }

    __slots__: List[str] = ['_path']

    def __init__(self, path: str) -> None:
        self._path = path

    @builtins.property
    def path(self) -> str:
        return self._path


ingest_api_GcsIngestSource.__name__ = "GcsIngestSource"
ingest_api_GcsIngestSource.__qualname__ = "GcsIngestSource"
ingest_api_GcsIngestSource.__module__ = "nominal_api.ingest_api"


class ingest_api_GetContainerizedExtractorsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'extractor_rids': ConjureFieldDefinition('extractorRids', List[ingest_api_ContainerizedExtractorRid])
        }

    __slots__: List[str] = ['_extractor_rids']

    def __init__(self, extractor_rids: List[str]) -> None:
        self._extractor_rids = extractor_rids

    @builtins.property
    def extractor_rids(self) -> List[str]:
        return self._extractor_rids


ingest_api_GetContainerizedExtractorsRequest.__name__ = "GetContainerizedExtractorsRequest"
ingest_api_GetContainerizedExtractorsRequest.__qualname__ = "GetContainerizedExtractorsRequest"
ingest_api_GetContainerizedExtractorsRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_GetContainerizedExtractorsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'extractors': ConjureFieldDefinition('extractors', List[ingest_api_ContainerizedExtractor])
        }

    __slots__: List[str] = ['_extractors']

    def __init__(self, extractors: List["ingest_api_ContainerizedExtractor"]) -> None:
        self._extractors = extractors

    @builtins.property
    def extractors(self) -> List["ingest_api_ContainerizedExtractor"]:
        return self._extractors


ingest_api_GetContainerizedExtractorsResponse.__name__ = "GetContainerizedExtractorsResponse"
ingest_api_GetContainerizedExtractorsResponse.__qualname__ = "GetContainerizedExtractorsResponse"
ingest_api_GetContainerizedExtractorsResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDataSource(ConjureUnionType):
    _existing_data_source: Optional[str] = None
    _new_data_source: Optional["ingest_api_DeprecatedNewDataSource"] = None
    _new_data_source_v2: Optional["ingest_api_NewDataSource"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_data_source': ConjureFieldDefinition('existingDataSource', api_rids_DataSourceRid),
            'new_data_source': ConjureFieldDefinition('newDataSource', ingest_api_DeprecatedNewDataSource),
            'new_data_source_v2': ConjureFieldDefinition('newDataSourceV2', ingest_api_NewDataSource)
        }

    def __init__(
            self,
            existing_data_source: Optional[str] = None,
            new_data_source: Optional["ingest_api_DeprecatedNewDataSource"] = None,
            new_data_source_v2: Optional["ingest_api_NewDataSource"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (existing_data_source is not None) + (new_data_source is not None) + (new_data_source_v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if existing_data_source is not None:
                self._existing_data_source = existing_data_source
                self._type = 'existingDataSource'
            if new_data_source is not None:
                self._new_data_source = new_data_source
                self._type = 'newDataSource'
            if new_data_source_v2 is not None:
                self._new_data_source_v2 = new_data_source_v2
                self._type = 'newDataSourceV2'

        elif type_of_union == 'existingDataSource':
            if existing_data_source is None:
                raise ValueError('a union value must not be None')
            self._existing_data_source = existing_data_source
            self._type = 'existingDataSource'
        elif type_of_union == 'newDataSource':
            if new_data_source is None:
                raise ValueError('a union value must not be None')
            self._new_data_source = new_data_source
            self._type = 'newDataSource'
        elif type_of_union == 'newDataSourceV2':
            if new_data_source_v2 is None:
                raise ValueError('a union value must not be None')
            self._new_data_source_v2 = new_data_source_v2
            self._type = 'newDataSourceV2'

    @builtins.property
    def existing_data_source(self) -> Optional[str]:
        return self._existing_data_source

    @builtins.property
    def new_data_source(self) -> Optional["ingest_api_DeprecatedNewDataSource"]:
        return self._new_data_source

    @builtins.property
    def new_data_source_v2(self) -> Optional["ingest_api_NewDataSource"]:
        return self._new_data_source_v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestDataSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestDataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'existingDataSource' and self.existing_data_source is not None:
            return visitor._existing_data_source(self.existing_data_source)
        if self._type == 'newDataSource' and self.new_data_source is not None:
            return visitor._new_data_source(self.new_data_source)
        if self._type == 'newDataSourceV2' and self.new_data_source_v2 is not None:
            return visitor._new_data_source_v2(self.new_data_source_v2)


ingest_api_IngestDataSource.__name__ = "IngestDataSource"
ingest_api_IngestDataSource.__qualname__ = "IngestDataSource"
ingest_api_IngestDataSource.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDataSourceVisitor:

    @abstractmethod
    def _existing_data_source(self, existing_data_source: str) -> Any:
        pass

    @abstractmethod
    def _new_data_source(self, new_data_source: "ingest_api_DeprecatedNewDataSource") -> Any:
        pass

    @abstractmethod
    def _new_data_source_v2(self, new_data_source_v2: "ingest_api_NewDataSource") -> Any:
        pass


ingest_api_IngestDataSourceVisitor.__name__ = "IngestDataSourceVisitor"
ingest_api_IngestDataSourceVisitor.__qualname__ = "IngestDataSourceVisitor"
ingest_api_IngestDataSourceVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDatasetFileDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_file_id': ConjureFieldDefinition('datasetFileId', OptionalTypeWrapper[str]),
            'dataset_rid': ConjureFieldDefinition('datasetRid', api_rids_DatasetRid)
        }

    __slots__: List[str] = ['_dataset_file_id', '_dataset_rid']

    def __init__(self, dataset_rid: str, dataset_file_id: Optional[str] = None) -> None:
        self._dataset_file_id = dataset_file_id
        self._dataset_rid = dataset_rid

    @builtins.property
    def dataset_file_id(self) -> Optional[str]:
        return self._dataset_file_id

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid


ingest_api_IngestDatasetFileDetails.__name__ = "IngestDatasetFileDetails"
ingest_api_IngestDatasetFileDetails.__qualname__ = "IngestDatasetFileDetails"
ingest_api_IngestDatasetFileDetails.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDestination(ConjureUnionType):
    _new_dataset: Optional["ingest_api_NewDatasetIngestDestination"] = None
    _existing_dataset: Optional["ingest_api_ExistingDatasetIngestDestination"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_dataset': ConjureFieldDefinition('newDataset', ingest_api_NewDatasetIngestDestination),
            'existing_dataset': ConjureFieldDefinition('existingDataset', ingest_api_ExistingDatasetIngestDestination)
        }

    def __init__(
            self,
            new_dataset: Optional["ingest_api_NewDatasetIngestDestination"] = None,
            existing_dataset: Optional["ingest_api_ExistingDatasetIngestDestination"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (new_dataset is not None) + (existing_dataset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if new_dataset is not None:
                self._new_dataset = new_dataset
                self._type = 'newDataset'
            if existing_dataset is not None:
                self._existing_dataset = existing_dataset
                self._type = 'existingDataset'

        elif type_of_union == 'newDataset':
            if new_dataset is None:
                raise ValueError('a union value must not be None')
            self._new_dataset = new_dataset
            self._type = 'newDataset'
        elif type_of_union == 'existingDataset':
            if existing_dataset is None:
                raise ValueError('a union value must not be None')
            self._existing_dataset = existing_dataset
            self._type = 'existingDataset'

    @builtins.property
    def new_dataset(self) -> Optional["ingest_api_NewDatasetIngestDestination"]:
        return self._new_dataset

    @builtins.property
    def existing_dataset(self) -> Optional["ingest_api_ExistingDatasetIngestDestination"]:
        return self._existing_dataset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestDestinationVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestDestinationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'newDataset' and self.new_dataset is not None:
            return visitor._new_dataset(self.new_dataset)
        if self._type == 'existingDataset' and self.existing_dataset is not None:
            return visitor._existing_dataset(self.existing_dataset)


ingest_api_IngestDestination.__name__ = "IngestDestination"
ingest_api_IngestDestination.__qualname__ = "IngestDestination"
ingest_api_IngestDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDestinationVisitor:

    @abstractmethod
    def _new_dataset(self, new_dataset: "ingest_api_NewDatasetIngestDestination") -> Any:
        pass

    @abstractmethod
    def _existing_dataset(self, existing_dataset: "ingest_api_ExistingDatasetIngestDestination") -> Any:
        pass


ingest_api_IngestDestinationVisitor.__name__ = "IngestDestinationVisitor"
ingest_api_IngestDestinationVisitor.__qualname__ = "IngestDestinationVisitor"
ingest_api_IngestDestinationVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDetails(ConjureUnionType):
    _dataset: Optional["ingest_api_IngestDatasetFileDetails"] = None
    _video: Optional["ingest_api_IngestVideoFileDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset': ConjureFieldDefinition('dataset', ingest_api_IngestDatasetFileDetails),
            'video': ConjureFieldDefinition('video', ingest_api_IngestVideoFileDetails)
        }

    def __init__(
            self,
            dataset: Optional["ingest_api_IngestDatasetFileDetails"] = None,
            video: Optional["ingest_api_IngestVideoFileDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (dataset is not None) + (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if dataset is not None:
                self._dataset = dataset
                self._type = 'dataset'
            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'dataset':
            if dataset is None:
                raise ValueError('a union value must not be None')
            self._dataset = dataset
            self._type = 'dataset'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def dataset(self) -> Optional["ingest_api_IngestDatasetFileDetails"]:
        return self._dataset

    @builtins.property
    def video(self) -> Optional["ingest_api_IngestVideoFileDetails"]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestDetailsVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataset' and self.dataset is not None:
            return visitor._dataset(self.dataset)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


ingest_api_IngestDetails.__name__ = "IngestDetails"
ingest_api_IngestDetails.__qualname__ = "IngestDetails"
ingest_api_IngestDetails.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestDetailsVisitor:

    @abstractmethod
    def _dataset(self, dataset: "ingest_api_IngestDatasetFileDetails") -> Any:
        pass

    @abstractmethod
    def _video(self, video: "ingest_api_IngestVideoFileDetails") -> Any:
        pass


ingest_api_IngestDetailsVisitor.__name__ = "IngestDetailsVisitor"
ingest_api_IngestDetailsVisitor.__qualname__ = "IngestDetailsVisitor"
ingest_api_IngestDetailsVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestJob(ConjureBeanType):
    """Ingest job information
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', ingest_api_IngestJobRid),
            'status': ConjureFieldDefinition('status', ingest_api_IngestJobStatus),
            'origin_files': ConjureFieldDefinition('originFiles', OptionalTypeWrapper[List[str]]),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str),
            'ingest_type': ConjureFieldDefinition('ingestType', ingest_api_IngestType)
        }

    __slots__: List[str] = ['_ingest_job_rid', '_status', '_origin_files', '_created_by', '_org_uuid', '_ingest_type']

    def __init__(self, created_by: str, ingest_job_rid: str, ingest_type: "ingest_api_IngestType", org_uuid: str, status: "ingest_api_IngestJobStatus", origin_files: Optional[List[str]] = None) -> None:
        self._ingest_job_rid = ingest_job_rid
        self._status = status
        self._origin_files = origin_files
        self._created_by = created_by
        self._org_uuid = org_uuid
        self._ingest_type = ingest_type

    @builtins.property
    def ingest_job_rid(self) -> str:
        return self._ingest_job_rid

    @builtins.property
    def status(self) -> "ingest_api_IngestJobStatus":
        return self._status

    @builtins.property
    def origin_files(self) -> Optional[List[str]]:
        return self._origin_files

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid

    @builtins.property
    def ingest_type(self) -> "ingest_api_IngestType":
        return self._ingest_type


ingest_api_IngestJob.__name__ = "IngestJob"
ingest_api_IngestJob.__qualname__ = "IngestJob"
ingest_api_IngestJob.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestJobRequest(ConjureUnionType):
    _ingest_request: Optional["ingest_api_IngestRequest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_request': ConjureFieldDefinition('ingestRequest', ingest_api_IngestRequest)
        }

    def __init__(
            self,
            ingest_request: Optional["ingest_api_IngestRequest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ingest_request is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ingest_request is not None:
                self._ingest_request = ingest_request
                self._type = 'ingestRequest'

        elif type_of_union == 'ingestRequest':
            if ingest_request is None:
                raise ValueError('a union value must not be None')
            self._ingest_request = ingest_request
            self._type = 'ingestRequest'

    @builtins.property
    def ingest_request(self) -> Optional["ingest_api_IngestRequest"]:
        return self._ingest_request

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestJobRequestVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestJobRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ingestRequest' and self.ingest_request is not None:
            return visitor._ingest_request(self.ingest_request)


ingest_api_IngestJobRequest.__name__ = "IngestJobRequest"
ingest_api_IngestJobRequest.__qualname__ = "IngestJobRequest"
ingest_api_IngestJobRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestJobRequestVisitor:

    @abstractmethod
    def _ingest_request(self, ingest_request: "ingest_api_IngestRequest") -> Any:
        pass


ingest_api_IngestJobRequestVisitor.__name__ = "IngestJobRequestVisitor"
ingest_api_IngestJobRequestVisitor.__qualname__ = "IngestJobRequestVisitor"
ingest_api_IngestJobRequestVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestJobService(Service):
    """Public API for querying ingest jobs.
    """

    def get_ingest_job(self, auth_header: str, ingest_job_rid: str) -> "ingest_api_IngestJob":
        """Returns a single ingest job by RID. Does not include the full ingest request details.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'ingestJobRid': quote(str(_conjure_encoder.default(ingest_job_rid)), safe=''),
        }

        _json: Any = None

        _path = '/ingest/v1/ingest-job/{ingestJobRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestJob, self._return_none_for_unknown_union_types)


ingest_api_IngestJobService.__name__ = "IngestJobService"
ingest_api_IngestJobService.__qualname__ = "IngestJobService"
ingest_api_IngestJobService.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestJobStatus(ConjureEnumType):

    SUBMITTED = 'SUBMITTED'
    '''SUBMITTED'''
    QUEUED = 'QUEUED'
    '''QUEUED'''
    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    COMPLETED = 'COMPLETED'
    '''COMPLETED'''
    FAILED = 'FAILED'
    '''FAILED'''
    CANCELLED = 'CANCELLED'
    '''CANCELLED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_IngestJobStatus.__name__ = "IngestJobStatus"
ingest_api_IngestJobStatus.__qualname__ = "IngestJobStatus"
ingest_api_IngestJobStatus.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestMcapRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', List[ingest_api_IngestSource]),
            'channel_config': ConjureFieldDefinition('channelConfig', List[ingest_api_McapChannelConfig]),
            'channels': ConjureFieldDefinition('channels', OptionalTypeWrapper[ingest_api_McapChannels]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_sources', '_channel_config', '_channels', '_properties', '_labels', '_title', '_description', '_workspace']

    def __init__(self, channel_config: List["ingest_api_McapChannelConfig"], labels: List[str], properties: Dict[str, str], sources: List["ingest_api_IngestSource"], channels: Optional["ingest_api_McapChannels"] = None, description: Optional[str] = None, title: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._sources = sources
        self._channel_config = channel_config
        self._channels = channels
        self._properties = properties
        self._labels = labels
        self._title = title
        self._description = description
        self._workspace = workspace

    @builtins.property
    def sources(self) -> List["ingest_api_IngestSource"]:
        """List of files in S3 to be ingested. These should be ordered by time, as data will be ingested and
concatenated across all the files.
Note: only a single files are currently supported, this field is mostly for forward compatibility.
        """
        return self._sources

    @builtins.property
    def channel_config(self) -> List["ingest_api_McapChannelConfig"]:
        return self._channel_config

    @builtins.property
    def channels(self) -> Optional["ingest_api_McapChannels"]:
        """Config to define which channels in the mcap should be ingested. The default is to ingest only
channels with config, otherwise the mcap may not be supported.
        """
        return self._channels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the dataset or video. If not provided, the dataset or video
will be created in the default workspace for the user's organization, if the default
workspace for the organization is configured.
        """
        return self._workspace


ingest_api_IngestMcapRequest.__name__ = "IngestMcapRequest"
ingest_api_IngestMcapRequest.__qualname__ = "IngestMcapRequest"
ingest_api_IngestMcapRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestMcapResponse(ConjureBeanType):
    """Returns references to the data ingested from an MCAP file.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'outputs': ConjureFieldDefinition('outputs', List[ingest_api_McapIngestionOutput]),
            'async_handle': ConjureFieldDefinition('asyncHandle', OptionalTypeWrapper[ingest_api_AsyncHandle])
        }

    __slots__: List[str] = ['_outputs', '_async_handle']

    def __init__(self, outputs: List["ingest_api_McapIngestionOutput"], async_handle: Optional["ingest_api_AsyncHandle"] = None) -> None:
        self._outputs = outputs
        self._async_handle = async_handle

    @builtins.property
    def outputs(self) -> List["ingest_api_McapIngestionOutput"]:
        return self._outputs

    @builtins.property
    def async_handle(self) -> Optional["ingest_api_AsyncHandle"]:
        return self._async_handle


ingest_api_IngestMcapResponse.__name__ = "IngestMcapResponse"
ingest_api_IngestMcapResponse.__qualname__ = "IngestMcapResponse"
ingest_api_IngestMcapResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_prefix': ConjureFieldDefinition('channelPrefix', OptionalTypeWrapper[str]),
            'tag_columns': ConjureFieldDefinition('tagColumns', OptionalTypeWrapper[Dict[api_TagName, api_ColumnName]]),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]])
        }

    __slots__: List[str] = ['_timestamp_metadata', '_channel_prefix', '_tag_columns', '_additional_file_tags']

    def __init__(self, additional_file_tags: Optional[Dict[str, str]] = None, channel_prefix: Optional[str] = None, tag_columns: Optional[Dict[str, str]] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._timestamp_metadata = timestamp_metadata
        self._channel_prefix = channel_prefix
        self._tag_columns = tag_columns
        self._additional_file_tags = additional_file_tags

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        """The timestamp metadata will be recovered from the dataset files if possible.
Older datasets may have unrecoverable timestamp metadata.
If unrecoverable, reingestion will throw MissingMetadataForReingest if not provided in request.
        """
        return self._timestamp_metadata

    @builtins.property
    def channel_prefix(self) -> Optional[str]:
        """Channel prefix to use when reingesting the dataset.
Defaults to empty string. Not recoverable from prior ingests and must be provided in request if needed.
        """
        return self._channel_prefix

    @builtins.property
    def tag_columns(self) -> Optional[Dict[str, str]]:
        """A map of tag names to column names to derive the tag values from.
Not recoverable from prior ingests and must be provided in request if needed.
        """
        return self._tag_columns

    @builtins.property
    def additional_file_tags(self) -> Optional[Dict[str, str]]:
        """Additional tags to apply to all dataset files within the the given dataset.
Not recoverable from prior ingests and must be provided in request if needed.
        """
        return self._additional_file_tags


ingest_api_IngestMetadata.__name__ = "IngestMetadata"
ingest_api_IngestMetadata.__qualname__ = "IngestMetadata"
ingest_api_IngestMetadata.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestOptions(ConjureUnionType):
    _dataflash: Optional["ingest_api_DataflashOpts"] = None
    _mcap_protobuf_timeseries: Optional["ingest_api_McapProtobufTimeseriesOpts"] = None
    _journal_json: Optional["ingest_api_JournalJsonOpts"] = None
    _csv: Optional["ingest_api_CsvOpts"] = None
    _parquet: Optional["ingest_api_ParquetOpts"] = None
    _video: Optional["ingest_api_VideoOpts"] = None
    _video_v2: Optional["ingest_api_VideoOptsV2"] = None
    _containerized: Optional["ingest_api_ContainerizedOpts"] = None
    _avro_stream: Optional["ingest_api_AvroStreamOpts"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataflash': ConjureFieldDefinition('dataflash', ingest_api_DataflashOpts),
            'mcap_protobuf_timeseries': ConjureFieldDefinition('mcapProtobufTimeseries', ingest_api_McapProtobufTimeseriesOpts),
            'journal_json': ConjureFieldDefinition('journalJson', ingest_api_JournalJsonOpts),
            'csv': ConjureFieldDefinition('csv', ingest_api_CsvOpts),
            'parquet': ConjureFieldDefinition('parquet', ingest_api_ParquetOpts),
            'video': ConjureFieldDefinition('video', ingest_api_VideoOpts),
            'video_v2': ConjureFieldDefinition('videoV2', ingest_api_VideoOptsV2),
            'containerized': ConjureFieldDefinition('containerized', ingest_api_ContainerizedOpts),
            'avro_stream': ConjureFieldDefinition('avroStream', ingest_api_AvroStreamOpts)
        }

    def __init__(
            self,
            dataflash: Optional["ingest_api_DataflashOpts"] = None,
            mcap_protobuf_timeseries: Optional["ingest_api_McapProtobufTimeseriesOpts"] = None,
            journal_json: Optional["ingest_api_JournalJsonOpts"] = None,
            csv: Optional["ingest_api_CsvOpts"] = None,
            parquet: Optional["ingest_api_ParquetOpts"] = None,
            video: Optional["ingest_api_VideoOpts"] = None,
            video_v2: Optional["ingest_api_VideoOptsV2"] = None,
            containerized: Optional["ingest_api_ContainerizedOpts"] = None,
            avro_stream: Optional["ingest_api_AvroStreamOpts"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (dataflash is not None) + (mcap_protobuf_timeseries is not None) + (journal_json is not None) + (csv is not None) + (parquet is not None) + (video is not None) + (video_v2 is not None) + (containerized is not None) + (avro_stream is not None) != 1:
                raise ValueError('a union must contain a single member')

            if dataflash is not None:
                self._dataflash = dataflash
                self._type = 'dataflash'
            if mcap_protobuf_timeseries is not None:
                self._mcap_protobuf_timeseries = mcap_protobuf_timeseries
                self._type = 'mcapProtobufTimeseries'
            if journal_json is not None:
                self._journal_json = journal_json
                self._type = 'journalJson'
            if csv is not None:
                self._csv = csv
                self._type = 'csv'
            if parquet is not None:
                self._parquet = parquet
                self._type = 'parquet'
            if video is not None:
                self._video = video
                self._type = 'video'
            if video_v2 is not None:
                self._video_v2 = video_v2
                self._type = 'videoV2'
            if containerized is not None:
                self._containerized = containerized
                self._type = 'containerized'
            if avro_stream is not None:
                self._avro_stream = avro_stream
                self._type = 'avroStream'

        elif type_of_union == 'dataflash':
            if dataflash is None:
                raise ValueError('a union value must not be None')
            self._dataflash = dataflash
            self._type = 'dataflash'
        elif type_of_union == 'mcapProtobufTimeseries':
            if mcap_protobuf_timeseries is None:
                raise ValueError('a union value must not be None')
            self._mcap_protobuf_timeseries = mcap_protobuf_timeseries
            self._type = 'mcapProtobufTimeseries'
        elif type_of_union == 'journalJson':
            if journal_json is None:
                raise ValueError('a union value must not be None')
            self._journal_json = journal_json
            self._type = 'journalJson'
        elif type_of_union == 'csv':
            if csv is None:
                raise ValueError('a union value must not be None')
            self._csv = csv
            self._type = 'csv'
        elif type_of_union == 'parquet':
            if parquet is None:
                raise ValueError('a union value must not be None')
            self._parquet = parquet
            self._type = 'parquet'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'
        elif type_of_union == 'videoV2':
            if video_v2 is None:
                raise ValueError('a union value must not be None')
            self._video_v2 = video_v2
            self._type = 'videoV2'
        elif type_of_union == 'containerized':
            if containerized is None:
                raise ValueError('a union value must not be None')
            self._containerized = containerized
            self._type = 'containerized'
        elif type_of_union == 'avroStream':
            if avro_stream is None:
                raise ValueError('a union value must not be None')
            self._avro_stream = avro_stream
            self._type = 'avroStream'

    @builtins.property
    def dataflash(self) -> Optional["ingest_api_DataflashOpts"]:
        return self._dataflash

    @builtins.property
    def mcap_protobuf_timeseries(self) -> Optional["ingest_api_McapProtobufTimeseriesOpts"]:
        return self._mcap_protobuf_timeseries

    @builtins.property
    def journal_json(self) -> Optional["ingest_api_JournalJsonOpts"]:
        return self._journal_json

    @builtins.property
    def csv(self) -> Optional["ingest_api_CsvOpts"]:
        return self._csv

    @builtins.property
    def parquet(self) -> Optional["ingest_api_ParquetOpts"]:
        return self._parquet

    @builtins.property
    def video(self) -> Optional["ingest_api_VideoOpts"]:
        return self._video

    @builtins.property
    def video_v2(self) -> Optional["ingest_api_VideoOptsV2"]:
        return self._video_v2

    @builtins.property
    def containerized(self) -> Optional["ingest_api_ContainerizedOpts"]:
        return self._containerized

    @builtins.property
    def avro_stream(self) -> Optional["ingest_api_AvroStreamOpts"]:
        return self._avro_stream

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestOptionsVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestOptionsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataflash' and self.dataflash is not None:
            return visitor._dataflash(self.dataflash)
        if self._type == 'mcapProtobufTimeseries' and self.mcap_protobuf_timeseries is not None:
            return visitor._mcap_protobuf_timeseries(self.mcap_protobuf_timeseries)
        if self._type == 'journalJson' and self.journal_json is not None:
            return visitor._journal_json(self.journal_json)
        if self._type == 'csv' and self.csv is not None:
            return visitor._csv(self.csv)
        if self._type == 'parquet' and self.parquet is not None:
            return visitor._parquet(self.parquet)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)
        if self._type == 'videoV2' and self.video_v2 is not None:
            return visitor._video_v2(self.video_v2)
        if self._type == 'containerized' and self.containerized is not None:
            return visitor._containerized(self.containerized)
        if self._type == 'avroStream' and self.avro_stream is not None:
            return visitor._avro_stream(self.avro_stream)


ingest_api_IngestOptions.__name__ = "IngestOptions"
ingest_api_IngestOptions.__qualname__ = "IngestOptions"
ingest_api_IngestOptions.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestOptionsVisitor:

    @abstractmethod
    def _dataflash(self, dataflash: "ingest_api_DataflashOpts") -> Any:
        pass

    @abstractmethod
    def _mcap_protobuf_timeseries(self, mcap_protobuf_timeseries: "ingest_api_McapProtobufTimeseriesOpts") -> Any:
        pass

    @abstractmethod
    def _journal_json(self, journal_json: "ingest_api_JournalJsonOpts") -> Any:
        pass

    @abstractmethod
    def _csv(self, csv: "ingest_api_CsvOpts") -> Any:
        pass

    @abstractmethod
    def _parquet(self, parquet: "ingest_api_ParquetOpts") -> Any:
        pass

    @abstractmethod
    def _video(self, video: "ingest_api_VideoOpts") -> Any:
        pass

    @abstractmethod
    def _video_v2(self, video_v2: "ingest_api_VideoOptsV2") -> Any:
        pass

    @abstractmethod
    def _containerized(self, containerized: "ingest_api_ContainerizedOpts") -> Any:
        pass

    @abstractmethod
    def _avro_stream(self, avro_stream: "ingest_api_AvroStreamOpts") -> Any:
        pass


ingest_api_IngestOptionsVisitor.__name__ = "IngestOptionsVisitor"
ingest_api_IngestOptionsVisitor.__qualname__ = "IngestOptionsVisitor"
ingest_api_IngestOptionsVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestProgressV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', str),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', api_IngestStatusV2),
            'incalculable': ConjureFieldDefinition('incalculable', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_start_time', '_end_time', '_ingest_status', '_incalculable']

    def __init__(self, ingest_status: "api_IngestStatusV2", start_time: str, end_time: Optional[str] = None, incalculable: Optional[bool] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time
        self._ingest_status = ingest_status
        self._incalculable = incalculable

    @builtins.property
    def start_time(self) -> str:
        """Timestamp at start of ingest
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        """Timestamp at end of ingest, empty if still in progress
        """
        return self._end_time

    @builtins.property
    def ingest_status(self) -> "api_IngestStatusV2":
        """Status of ingest, contains error if failed
        """
        return self._ingest_status

    @builtins.property
    def incalculable(self) -> Optional[bool]:
        """Whether ingest duration can be reliably calculated
        """
        return self._incalculable


ingest_api_IngestProgressV2.__name__ = "IngestProgressV2"
ingest_api_IngestProgressV2.__qualname__ = "IngestProgressV2"
ingest_api_IngestProgressV2.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'options': ConjureFieldDefinition('options', ingest_api_IngestOptions)
        }

    __slots__: List[str] = ['_options']

    def __init__(self, options: "ingest_api_IngestOptions") -> None:
        self._options = options

    @builtins.property
    def options(self) -> "ingest_api_IngestOptions":
        return self._options


ingest_api_IngestRequest.__name__ = "IngestRequest"
ingest_api_IngestRequest.__qualname__ = "IngestRequest"
ingest_api_IngestRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'details': ConjureFieldDefinition('details', ingest_api_IngestDetails),
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', OptionalTypeWrapper[ingest_api_IngestJobRid])
        }

    __slots__: List[str] = ['_details', '_ingest_job_rid']

    def __init__(self, details: "ingest_api_IngestDetails", ingest_job_rid: Optional[str] = None) -> None:
        self._details = details
        self._ingest_job_rid = ingest_job_rid

    @builtins.property
    def details(self) -> "ingest_api_IngestDetails":
        return self._details

    @builtins.property
    def ingest_job_rid(self) -> Optional[str]:
        return self._ingest_job_rid


ingest_api_IngestResponse.__name__ = "IngestResponse"
ingest_api_IngestResponse.__qualname__ = "IngestResponse"
ingest_api_IngestResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestRunDataSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', ingest_api_IngestDataSource),
            'time_offset_spec': ConjureFieldDefinition('timeOffsetSpec', OptionalTypeWrapper[ingest_api_TimeOffsetSpec])
        }

    __slots__: List[str] = ['_data_source', '_time_offset_spec']

    def __init__(self, data_source: "ingest_api_IngestDataSource", time_offset_spec: Optional["ingest_api_TimeOffsetSpec"] = None) -> None:
        self._data_source = data_source
        self._time_offset_spec = time_offset_spec

    @builtins.property
    def data_source(self) -> "ingest_api_IngestDataSource":
        return self._data_source

    @builtins.property
    def time_offset_spec(self) -> Optional["ingest_api_TimeOffsetSpec"]:
        return self._time_offset_spec


ingest_api_IngestRunDataSource.__name__ = "IngestRunDataSource"
ingest_api_IngestRunDataSource.__qualname__ = "IngestRunDataSource"
ingest_api_IngestRunDataSource.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'start_time': ConjureFieldDefinition('startTime', ingest_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[ingest_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[ingest_api_DataSourceRefName, ingest_api_IngestRunDataSource]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_run_prefix', '_data_sources', '_workspace']

    def __init__(self, data_sources: Dict[str, "ingest_api_IngestRunDataSource"], description: str, labels: List[str], properties: Dict[str, str], start_time: "ingest_api_UtcTimestamp", title: str, end_time: Optional["ingest_api_UtcTimestamp"] = None, rid: Optional[str] = None, run_prefix: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._run_prefix = run_prefix
        self._data_sources = data_sources
        self._workspace = workspace

    @builtins.property
    def rid(self) -> Optional[str]:
        """If a run with the same rid already exists, the run will be updated.
        """
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def start_time(self) -> "ingest_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["ingest_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        """for example, SIM, HTL, FLT
        """
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Dict[str, "ingest_api_IngestRunDataSource"]:
        return self._data_sources

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


ingest_api_IngestRunRequest.__name__ = "IngestRunRequest"
ingest_api_IngestRunRequest.__qualname__ = "IngestRunRequest"
ingest_api_IngestRunRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestRunResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid)
        }

    __slots__: List[str] = ['_run_rid']

    def __init__(self, run_rid: str) -> None:
        self._run_rid = run_rid

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid


ingest_api_IngestRunResponse.__name__ = "IngestRunResponse"
ingest_api_IngestRunResponse.__qualname__ = "IngestRunResponse"
ingest_api_IngestRunResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestService(Service):
    """The Ingest Service handles the data ingestion into Nominal/Clickhouse.
    """

    def ingest(self, auth_header: str, trigger_ingest: "ingest_api_IngestRequest") -> "ingest_api_IngestResponse":
        """Triggers an ingest job, allowing either creating a new dataset or uploading to an
existing one. This endpoint is meant to supersede all other ingestion endpoints as their functionality
gets migrated to this one.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(trigger_ingest)

        _path = '/ingest/v1/ingest'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestResponse, self._return_none_for_unknown_union_types)

    def rerun_ingest(self, auth_header: str, request: "ingest_api_RerunIngestRequest") -> "ingest_api_IngestResponse":
        """Triggers an ingest job using an existing ingest job RID.
Returns the same response format as the /ingest endpoint.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/ingest/v1/re-ingest'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestResponse, self._return_none_for_unknown_union_types)

    def ingest_run(self, auth_header: str, request: "ingest_api_IngestRunRequest") -> "ingest_api_IngestRunResponse":
        """Creates a run and ingests data sources to be added to the run.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/ingest/v1/ingest-run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestRunResponse, self._return_none_for_unknown_union_types)

    def ingest_video(self, auth_header: str, ingest_video: "ingest_api_IngestVideoRequest") -> "ingest_api_IngestVideoResponse":
        """Ingests video data from a S3 Nominal upload bucket.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(ingest_video)

        _path = '/ingest/v1/ingest-video'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestVideoResponse, self._return_none_for_unknown_union_types)

    def reingest_from_datasets(self, auth_header: str, request: "ingest_api_ReingestDatasetsRequest") -> "ingest_api_ReingestDatasetsResponse":
        """Re-ingests data from provided source datasets into either an existing target dataset, or a new one.
Only supported for CSV and Parquet dataset files.
Will only reingest dataset files and will drop streaming data from datasets.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/ingest/v1/reingest-dataset-files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_ReingestDatasetsResponse, self._return_none_for_unknown_union_types)

    def delete_file(self, auth_header: str, dataset_rid: str, file_id: str) -> None:
        """This is a best effort deletion of the file's data based on the ingestedAt timestamp. This is an unreversible
action. Only v2 dataset file deletion is supported.
!!!WARNING!!!
It's possible that the file has overwritten points, in which case, those older points will not be recovered.
Only use this endpoint if this is acceptable, the data across files are disjoint, or you're willing to
re-ingest files to manually recover older points.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = None

        _path = '/ingest/v1/delete-file/{datasetRid}/file/{fileId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


ingest_api_IngestService.__name__ = "IngestService"
ingest_api_IngestService.__qualname__ = "IngestService"
ingest_api_IngestService.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestSource(ConjureUnionType):
    _s3: Optional["ingest_api_S3IngestSource"] = None
    _gcs: Optional["ingest_api_GcsIngestSource"] = None
    _presigned_file: Optional["ingest_api_PresignedFileIngestSource"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', ingest_api_S3IngestSource),
            'gcs': ConjureFieldDefinition('gcs', ingest_api_GcsIngestSource),
            'presigned_file': ConjureFieldDefinition('presignedFile', ingest_api_PresignedFileIngestSource)
        }

    def __init__(
            self,
            s3: Optional["ingest_api_S3IngestSource"] = None,
            gcs: Optional["ingest_api_GcsIngestSource"] = None,
            presigned_file: Optional["ingest_api_PresignedFileIngestSource"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) + (gcs is not None) + (presigned_file is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'
            if gcs is not None:
                self._gcs = gcs
                self._type = 'gcs'
            if presigned_file is not None:
                self._presigned_file = presigned_file
                self._type = 'presignedFile'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'
        elif type_of_union == 'gcs':
            if gcs is None:
                raise ValueError('a union value must not be None')
            self._gcs = gcs
            self._type = 'gcs'
        elif type_of_union == 'presignedFile':
            if presigned_file is None:
                raise ValueError('a union value must not be None')
            self._presigned_file = presigned_file
            self._type = 'presignedFile'

    @builtins.property
    def s3(self) -> Optional["ingest_api_S3IngestSource"]:
        return self._s3

    @builtins.property
    def gcs(self) -> Optional["ingest_api_GcsIngestSource"]:
        return self._gcs

    @builtins.property
    def presigned_file(self) -> Optional["ingest_api_PresignedFileIngestSource"]:
        return self._presigned_file

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_IngestSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_IngestSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)
        if self._type == 'gcs' and self.gcs is not None:
            return visitor._gcs(self.gcs)
        if self._type == 'presignedFile' and self.presigned_file is not None:
            return visitor._presigned_file(self.presigned_file)


ingest_api_IngestSource.__name__ = "IngestSource"
ingest_api_IngestSource.__qualname__ = "IngestSource"
ingest_api_IngestSource.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestSourceVisitor:

    @abstractmethod
    def _s3(self, s3: "ingest_api_S3IngestSource") -> Any:
        pass

    @abstractmethod
    def _gcs(self, gcs: "ingest_api_GcsIngestSource") -> Any:
        pass

    @abstractmethod
    def _presigned_file(self, presigned_file: "ingest_api_PresignedFileIngestSource") -> Any:
        pass


ingest_api_IngestSourceVisitor.__name__ = "IngestSourceVisitor"
ingest_api_IngestSourceVisitor.__qualname__ = "IngestSourceVisitor"
ingest_api_IngestSourceVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestSourceMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata])
        }

    __slots__: List[str] = ['_timestamp_metadata']

    def __init__(self, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._timestamp_metadata = timestamp_metadata

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._timestamp_metadata


ingest_api_IngestSourceMetadata.__name__ = "IngestSourceMetadata"
ingest_api_IngestSourceMetadata.__qualname__ = "IngestSourceMetadata"
ingest_api_IngestSourceMetadata.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestStatus(ConjureEnumType):

    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    COMPLETED = 'COMPLETED'
    '''COMPLETED'''
    FAILED = 'FAILED'
    '''FAILED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_IngestStatus.__name__ = "IngestStatus"
ingest_api_IngestStatus.__qualname__ = "IngestStatus"
ingest_api_IngestStatus.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestType(ConjureEnumType):

    TABULAR = 'TABULAR'
    '''TABULAR'''
    MCAP = 'MCAP'
    '''MCAP'''
    DATAFLASH = 'DATAFLASH'
    '''DATAFLASH'''
    JOURNAL_JSON = 'JOURNAL_JSON'
    '''JOURNAL_JSON'''
    CONTAINERIZED = 'CONTAINERIZED'
    '''CONTAINERIZED'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    AVRO_STREAM = 'AVRO_STREAM'
    '''AVRO_STREAM'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_api_IngestType.__name__ = "IngestType"
ingest_api_IngestType.__qualname__ = "IngestType"
ingest_api_IngestType.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestVideoFileDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_file_rid': ConjureFieldDefinition('videoFileRid', api_rids_VideoFileRid),
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid)
        }

    __slots__: List[str] = ['_video_file_rid', '_video_rid']

    def __init__(self, video_file_rid: str, video_rid: str) -> None:
        self._video_file_rid = video_file_rid
        self._video_rid = video_rid

    @builtins.property
    def video_file_rid(self) -> str:
        return self._video_file_rid

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid


ingest_api_IngestVideoFileDetails.__name__ = "IngestVideoFileDetails"
ingest_api_IngestVideoFileDetails.__qualname__ = "IngestVideoFileDetails"
ingest_api_IngestVideoFileDetails.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestVideoRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', List[ingest_api_IngestSource]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'timestamps': ConjureFieldDefinition('timestamps', ingest_api_VideoTimestampManifest),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_sources', '_properties', '_labels', '_title', '_description', '_timestamps', '_workspace']

    def __init__(self, labels: List[str], properties: Dict[str, str], sources: List["ingest_api_IngestSource"], timestamps: "ingest_api_VideoTimestampManifest", description: Optional[str] = None, title: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._sources = sources
        self._properties = properties
        self._labels = labels
        self._title = title
        self._description = description
        self._timestamps = timestamps
        self._workspace = workspace

    @builtins.property
    def sources(self) -> List["ingest_api_IngestSource"]:
        return self._sources

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def timestamps(self) -> "ingest_api_VideoTimestampManifest":
        return self._timestamps

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the video. If not provided, the video will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


ingest_api_IngestVideoRequest.__name__ = "IngestVideoRequest"
ingest_api_IngestVideoRequest.__qualname__ = "IngestVideoRequest"
ingest_api_IngestVideoRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_IngestVideoResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'video_file_rid': ConjureFieldDefinition('videoFileRid', api_rids_VideoFileRid),
            'async_handle': ConjureFieldDefinition('asyncHandle', OptionalTypeWrapper[ingest_api_AsyncHandle])
        }

    __slots__: List[str] = ['_video_rid', '_video_file_rid', '_async_handle']

    def __init__(self, video_file_rid: str, video_rid: str, async_handle: Optional["ingest_api_AsyncHandle"] = None) -> None:
        self._video_rid = video_rid
        self._video_file_rid = video_file_rid
        self._async_handle = async_handle

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def video_file_rid(self) -> str:
        return self._video_file_rid

    @builtins.property
    def async_handle(self) -> Optional["ingest_api_AsyncHandle"]:
        return self._async_handle


ingest_api_IngestVideoResponse.__name__ = "IngestVideoResponse"
ingest_api_IngestVideoResponse.__qualname__ = "IngestVideoResponse"
ingest_api_IngestVideoResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_InitiateMultipartUploadRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filename': ConjureFieldDefinition('filename', str),
            'filetype': ConjureFieldDefinition('filetype', str),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_filename', '_filetype', '_workspace']

    def __init__(self, filename: str, filetype: str, workspace: Optional[str] = None) -> None:
        self._filename = filename
        self._filetype = filetype
        self._workspace = workspace

    @builtins.property
    def filename(self) -> str:
        """The desired name of the file in object storage. The final name will be
prefixed with a timestamp to ensure uniqueness.
        """
        return self._filename

    @builtins.property
    def filetype(self) -> str:
        """The MIME type of the file, eg "text/csv" for CSVs or "application/octet-stream"
for binary files.
        """
        return self._filetype

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to upload the file. If not provided, the file will be uploaded to
the default workspace for the user's organization, if that is configured and the user
has access to it.
        """
        return self._workspace


ingest_api_InitiateMultipartUploadRequest.__name__ = "InitiateMultipartUploadRequest"
ingest_api_InitiateMultipartUploadRequest.__qualname__ = "InitiateMultipartUploadRequest"
ingest_api_InitiateMultipartUploadRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_InitiateMultipartUploadResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'upload_id': ConjureFieldDefinition('uploadId', str),
            'key': ConjureFieldDefinition('key', str),
            'bucket': ConjureFieldDefinition('bucket', str)
        }

    __slots__: List[str] = ['_upload_id', '_key', '_bucket']

    def __init__(self, bucket: str, key: str, upload_id: str) -> None:
        self._upload_id = upload_id
        self._key = key
        self._bucket = bucket

    @builtins.property
    def upload_id(self) -> str:
        return self._upload_id

    @builtins.property
    def key(self) -> str:
        return self._key

    @builtins.property
    def bucket(self) -> str:
        return self._bucket


ingest_api_InitiateMultipartUploadResponse.__name__ = "InitiateMultipartUploadResponse"
ingest_api_InitiateMultipartUploadResponse.__qualname__ = "InitiateMultipartUploadResponse"
ingest_api_InitiateMultipartUploadResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_InternalIngestJob(ConjureBeanType):
    """Internal ingest job information including the full ingest request details.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', ingest_api_IngestJobRid),
            'status': ConjureFieldDefinition('status', ingest_api_IngestJobStatus),
            'ingest_job_request': ConjureFieldDefinition('ingestJobRequest', ingest_api_IngestJobRequest),
            'origin_files': ConjureFieldDefinition('originFiles', OptionalTypeWrapper[List[str]]),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'org_uuid': ConjureFieldDefinition('orgUuid', str),
            'ingest_type': ConjureFieldDefinition('ingestType', ingest_api_IngestType)
        }

    __slots__: List[str] = ['_ingest_job_rid', '_status', '_ingest_job_request', '_origin_files', '_created_by', '_org_uuid', '_ingest_type']

    def __init__(self, created_by: str, ingest_job_request: "ingest_api_IngestJobRequest", ingest_job_rid: str, ingest_type: "ingest_api_IngestType", org_uuid: str, status: "ingest_api_IngestJobStatus", origin_files: Optional[List[str]] = None) -> None:
        self._ingest_job_rid = ingest_job_rid
        self._status = status
        self._ingest_job_request = ingest_job_request
        self._origin_files = origin_files
        self._created_by = created_by
        self._org_uuid = org_uuid
        self._ingest_type = ingest_type

    @builtins.property
    def ingest_job_rid(self) -> str:
        return self._ingest_job_rid

    @builtins.property
    def status(self) -> "ingest_api_IngestJobStatus":
        return self._status

    @builtins.property
    def ingest_job_request(self) -> "ingest_api_IngestJobRequest":
        return self._ingest_job_request

    @builtins.property
    def origin_files(self) -> Optional[List[str]]:
        return self._origin_files

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def org_uuid(self) -> str:
        return self._org_uuid

    @builtins.property
    def ingest_type(self) -> "ingest_api_IngestType":
        return self._ingest_type


ingest_api_InternalIngestJob.__name__ = "InternalIngestJob"
ingest_api_InternalIngestJob.__qualname__ = "InternalIngestJob"
ingest_api_InternalIngestJob.__module__ = "nominal_api.ingest_api"


class ingest_api_InternalIngestJobService(Service):
    """Internal API for managing ingest jobs. This service is filtered out from public documentation.
    """

    def create_ingest_job(self, auth_header: str, create_ingest_job_request: "ingest_api_CreateIngestJobRequest") -> str:
        """Creates an ingest job, returning a RID for the job.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(create_ingest_job_request)

        _path = '/internal/ingest/v1/ingest-job'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestJobRid, self._return_none_for_unknown_union_types)

    def get_ingest_job_internal(self, auth_header: str, ingest_job_rid: str) -> "ingest_api_InternalIngestJob":
        """Returns a single ingest job by RID with full details including the ingest request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'ingestJobRid': quote(str(_conjure_encoder.default(ingest_job_rid)), safe=''),
        }

        _json: Any = None

        _path = '/internal/ingest/v1/ingest-job/{ingestJobRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_InternalIngestJob, self._return_none_for_unknown_union_types)

    def update_ingest_job_status(self, auth_header: str, ingest_job_rid: str, status: "ingest_api_IngestJobStatus") -> "ingest_api_IngestJobStatus":
        """Updates the status of an ingest job.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'ingestJobRid': quote(str(_conjure_encoder.default(ingest_job_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(status)

        _path = '/internal/ingest/v1/ingest-job/{ingestJobRid}/status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_IngestJobStatus, self._return_none_for_unknown_union_types)


ingest_api_InternalIngestJobService.__name__ = "InternalIngestJobService"
ingest_api_InternalIngestJobService.__qualname__ = "InternalIngestJobService"
ingest_api_InternalIngestJobService.__module__ = "nominal_api.ingest_api"


class ingest_api_Iso8601Timestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_Iso8601Timestamp.__name__ = "Iso8601Timestamp"
ingest_api_Iso8601Timestamp.__qualname__ = "Iso8601Timestamp"
ingest_api_Iso8601Timestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_JournalJsonOpts(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'channel': ConjureFieldDefinition('channel', OptionalTypeWrapper[api_Channel])
        }

    __slots__: List[str] = ['_source', '_target', '_channel']

    def __init__(self, source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget", channel: Optional[str] = None) -> None:
        self._source = source
        self._target = target
        self._channel = channel

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def channel(self) -> Optional[str]:
        """If provided, ingests logs to the given channel.
By default, log data will be ingested to a channel named 'logs'.
        """
        return self._channel


ingest_api_JournalJsonOpts.__name__ = "JournalJsonOpts"
ingest_api_JournalJsonOpts.__qualname__ = "JournalJsonOpts"
ingest_api_JournalJsonOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_JournalTimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field_name': ConjureFieldDefinition('fieldName', str),
            'epoch_of_time_unit': ConjureFieldDefinition('epochOfTimeUnit', ingest_api_EpochTimestamp)
        }

    __slots__: List[str] = ['_field_name', '_epoch_of_time_unit']

    def __init__(self, epoch_of_time_unit: "ingest_api_EpochTimestamp", field_name: str) -> None:
        self._field_name = field_name
        self._epoch_of_time_unit = epoch_of_time_unit

    @builtins.property
    def field_name(self) -> str:
        return self._field_name

    @builtins.property
    def epoch_of_time_unit(self) -> "ingest_api_EpochTimestamp":
        return self._epoch_of_time_unit


ingest_api_JournalTimestampMetadata.__name__ = "JournalTimestampMetadata"
ingest_api_JournalTimestampMetadata.__qualname__ = "JournalTimestampMetadata"
ingest_api_JournalTimestampMetadata.__module__ = "nominal_api.ingest_api"


class ingest_api_LogTime(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_LogTime.__name__ = "LogTime"
ingest_api_LogTime.__qualname__ = "LogTime"
ingest_api_LogTime.__module__ = "nominal_api.ingest_api"


class ingest_api_McapChannelConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', api_McapChannelLocator),
            'channel_type': ConjureFieldDefinition('channelType', ingest_api_McapChannelConfigType)
        }

    __slots__: List[str] = ['_locator', '_channel_type']

    def __init__(self, channel_type: "ingest_api_McapChannelConfigType", locator: "api_McapChannelLocator") -> None:
        self._locator = locator
        self._channel_type = channel_type

    @builtins.property
    def locator(self) -> "api_McapChannelLocator":
        return self._locator

    @builtins.property
    def channel_type(self) -> "ingest_api_McapChannelConfigType":
        return self._channel_type


ingest_api_McapChannelConfig.__name__ = "McapChannelConfig"
ingest_api_McapChannelConfig.__qualname__ = "McapChannelConfig"
ingest_api_McapChannelConfig.__module__ = "nominal_api.ingest_api"


class ingest_api_McapChannelConfigType(ConjureUnionType):
    _video: Optional["ingest_api_McapVideoChannelConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video': ConjureFieldDefinition('video', ingest_api_McapVideoChannelConfig)
        }

    def __init__(
            self,
            video: Optional["ingest_api_McapVideoChannelConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def video(self) -> Optional["ingest_api_McapVideoChannelConfig"]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_McapChannelConfigTypeVisitor):
            raise ValueError('{} is not an instance of ingest_api_McapChannelConfigTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


ingest_api_McapChannelConfigType.__name__ = "McapChannelConfigType"
ingest_api_McapChannelConfigType.__qualname__ = "McapChannelConfigType"
ingest_api_McapChannelConfigType.__module__ = "nominal_api.ingest_api"


class ingest_api_McapChannelConfigTypeVisitor:

    @abstractmethod
    def _video(self, video: "ingest_api_McapVideoChannelConfig") -> Any:
        pass


ingest_api_McapChannelConfigTypeVisitor.__name__ = "McapChannelConfigTypeVisitor"
ingest_api_McapChannelConfigTypeVisitor.__qualname__ = "McapChannelConfigTypeVisitor"
ingest_api_McapChannelConfigTypeVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_McapChannels(ConjureUnionType):
    _all: Optional["api_Empty"] = None
    _include: Optional[List["api_McapChannelLocator"]] = None
    _exclude: Optional[List["api_McapChannelLocator"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'all': ConjureFieldDefinition('all', api_Empty),
            'include': ConjureFieldDefinition('include', List[api_McapChannelLocator]),
            'exclude': ConjureFieldDefinition('exclude', List[api_McapChannelLocator])
        }

    def __init__(
            self,
            all: Optional["api_Empty"] = None,
            include: Optional[List["api_McapChannelLocator"]] = None,
            exclude: Optional[List["api_McapChannelLocator"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (all is not None) + (include is not None) + (exclude is not None) != 1:
                raise ValueError('a union must contain a single member')

            if all is not None:
                self._all = all
                self._type = 'all'
            if include is not None:
                self._include = include
                self._type = 'include'
            if exclude is not None:
                self._exclude = exclude
                self._type = 'exclude'

        elif type_of_union == 'all':
            if all is None:
                raise ValueError('a union value must not be None')
            self._all = all
            self._type = 'all'
        elif type_of_union == 'include':
            if include is None:
                raise ValueError('a union value must not be None')
            self._include = include
            self._type = 'include'
        elif type_of_union == 'exclude':
            if exclude is None:
                raise ValueError('a union value must not be None')
            self._exclude = exclude
            self._type = 'exclude'

    @builtins.property
    def all(self) -> Optional["api_Empty"]:
        return self._all

    @builtins.property
    def include(self) -> Optional[List["api_McapChannelLocator"]]:
        return self._include

    @builtins.property
    def exclude(self) -> Optional[List["api_McapChannelLocator"]]:
        return self._exclude

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_McapChannelsVisitor):
            raise ValueError('{} is not an instance of ingest_api_McapChannelsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'all' and self.all is not None:
            return visitor._all(self.all)
        if self._type == 'include' and self.include is not None:
            return visitor._include(self.include)
        if self._type == 'exclude' and self.exclude is not None:
            return visitor._exclude(self.exclude)


ingest_api_McapChannels.__name__ = "McapChannels"
ingest_api_McapChannels.__qualname__ = "McapChannels"
ingest_api_McapChannels.__module__ = "nominal_api.ingest_api"


class ingest_api_McapChannelsVisitor:

    @abstractmethod
    def _all(self, all: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _include(self, include: List["api_McapChannelLocator"]) -> Any:
        pass

    @abstractmethod
    def _exclude(self, exclude: List["api_McapChannelLocator"]) -> Any:
        pass


ingest_api_McapChannelsVisitor.__name__ = "McapChannelsVisitor"
ingest_api_McapChannelsVisitor.__qualname__ = "McapChannelsVisitor"
ingest_api_McapChannelsVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_McapDestination(ConjureUnionType):
    _video_rid: Optional[str] = None
    _dataset_rid: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'dataset_rid': ConjureFieldDefinition('datasetRid', str)
        }

    def __init__(
            self,
            video_rid: Optional[str] = None,
            dataset_rid: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (video_rid is not None) + (dataset_rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if video_rid is not None:
                self._video_rid = video_rid
                self._type = 'videoRid'
            if dataset_rid is not None:
                self._dataset_rid = dataset_rid
                self._type = 'datasetRid'

        elif type_of_union == 'videoRid':
            if video_rid is None:
                raise ValueError('a union value must not be None')
            self._video_rid = video_rid
            self._type = 'videoRid'
        elif type_of_union == 'datasetRid':
            if dataset_rid is None:
                raise ValueError('a union value must not be None')
            self._dataset_rid = dataset_rid
            self._type = 'datasetRid'

    @builtins.property
    def video_rid(self) -> Optional[str]:
        return self._video_rid

    @builtins.property
    def dataset_rid(self) -> Optional[str]:
        return self._dataset_rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_McapDestinationVisitor):
            raise ValueError('{} is not an instance of ingest_api_McapDestinationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'videoRid' and self.video_rid is not None:
            return visitor._video_rid(self.video_rid)
        if self._type == 'datasetRid' and self.dataset_rid is not None:
            return visitor._dataset_rid(self.dataset_rid)


ingest_api_McapDestination.__name__ = "McapDestination"
ingest_api_McapDestination.__qualname__ = "McapDestination"
ingest_api_McapDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_McapDestinationVisitor:

    @abstractmethod
    def _video_rid(self, video_rid: str) -> Any:
        pass

    @abstractmethod
    def _dataset_rid(self, dataset_rid: str) -> Any:
        pass


ingest_api_McapDestinationVisitor.__name__ = "McapDestinationVisitor"
ingest_api_McapDestinationVisitor.__qualname__ = "McapDestinationVisitor"
ingest_api_McapDestinationVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_McapIngestionOutput(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_McapSource),
            'target': ConjureFieldDefinition('target', ingest_api_McapDestination),
            'video_file_rid': ConjureFieldDefinition('videoFileRid', OptionalTypeWrapper[api_rids_VideoFileRid])
        }

    __slots__: List[str] = ['_source', '_target', '_video_file_rid']

    def __init__(self, source: "ingest_api_McapSource", target: "ingest_api_McapDestination", video_file_rid: Optional[str] = None) -> None:
        self._source = source
        self._target = target
        self._video_file_rid = video_file_rid

    @builtins.property
    def source(self) -> "ingest_api_McapSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_McapDestination":
        return self._target

    @builtins.property
    def video_file_rid(self) -> Optional[str]:
        """If the destination points to a video, this will be populated with the video file
populated during ingestion.
        """
        return self._video_file_rid


ingest_api_McapIngestionOutput.__name__ = "McapIngestionOutput"
ingest_api_McapIngestionOutput.__qualname__ = "McapIngestionOutput"
ingest_api_McapIngestionOutput.__module__ = "nominal_api.ingest_api"


class ingest_api_McapProtobufTimeseriesOpts(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'channel_filter': ConjureFieldDefinition('channelFilter', ingest_api_McapChannels),
            'timestamp_type': ConjureFieldDefinition('timestampType', ingest_api_McapTimestampType),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]])
        }

    __slots__: List[str] = ['_source', '_target', '_channel_filter', '_timestamp_type', '_additional_file_tags']

    def __init__(self, channel_filter: "ingest_api_McapChannels", source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget", timestamp_type: "ingest_api_McapTimestampType", additional_file_tags: Optional[Dict[str, str]] = None) -> None:
        self._source = source
        self._target = target
        self._channel_filter = channel_filter
        self._timestamp_type = timestamp_type
        self._additional_file_tags = additional_file_tags

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def channel_filter(self) -> "ingest_api_McapChannels":
        return self._channel_filter

    @builtins.property
    def timestamp_type(self) -> "ingest_api_McapTimestampType":
        return self._timestamp_type

    @builtins.property
    def additional_file_tags(self) -> Optional[Dict[str, str]]:
        """Specifies a tag set to apply to all data in the file.
        """
        return self._additional_file_tags


ingest_api_McapProtobufTimeseriesOpts.__name__ = "McapProtobufTimeseriesOpts"
ingest_api_McapProtobufTimeseriesOpts.__qualname__ = "McapProtobufTimeseriesOpts"
ingest_api_McapProtobufTimeseriesOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_McapSource(ConjureUnionType):
    _single_channel: Optional["api_McapChannelLocator"] = None
    _mcap_file: Optional["ingest_api_IngestSource"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single_channel': ConjureFieldDefinition('singleChannel', api_McapChannelLocator),
            'mcap_file': ConjureFieldDefinition('mcapFile', ingest_api_IngestSource)
        }

    def __init__(
            self,
            single_channel: Optional["api_McapChannelLocator"] = None,
            mcap_file: Optional["ingest_api_IngestSource"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single_channel is not None) + (mcap_file is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single_channel is not None:
                self._single_channel = single_channel
                self._type = 'singleChannel'
            if mcap_file is not None:
                self._mcap_file = mcap_file
                self._type = 'mcapFile'

        elif type_of_union == 'singleChannel':
            if single_channel is None:
                raise ValueError('a union value must not be None')
            self._single_channel = single_channel
            self._type = 'singleChannel'
        elif type_of_union == 'mcapFile':
            if mcap_file is None:
                raise ValueError('a union value must not be None')
            self._mcap_file = mcap_file
            self._type = 'mcapFile'

    @builtins.property
    def single_channel(self) -> Optional["api_McapChannelLocator"]:
        return self._single_channel

    @builtins.property
    def mcap_file(self) -> Optional["ingest_api_IngestSource"]:
        return self._mcap_file

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_McapSourceVisitor):
            raise ValueError('{} is not an instance of ingest_api_McapSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'singleChannel' and self.single_channel is not None:
            return visitor._single_channel(self.single_channel)
        if self._type == 'mcapFile' and self.mcap_file is not None:
            return visitor._mcap_file(self.mcap_file)


ingest_api_McapSource.__name__ = "McapSource"
ingest_api_McapSource.__qualname__ = "McapSource"
ingest_api_McapSource.__module__ = "nominal_api.ingest_api"


class ingest_api_McapSourceVisitor:

    @abstractmethod
    def _single_channel(self, single_channel: "api_McapChannelLocator") -> Any:
        pass

    @abstractmethod
    def _mcap_file(self, mcap_file: "ingest_api_IngestSource") -> Any:
        pass


ingest_api_McapSourceVisitor.__name__ = "McapSourceVisitor"
ingest_api_McapSourceVisitor.__qualname__ = "McapSourceVisitor"
ingest_api_McapSourceVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_McapTimestampType(ConjureUnionType):
    """LogTime is default timestamp for MCAP messages and should be used in most cases.
    """
    _log_time: Optional["ingest_api_LogTime"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'log_time': ConjureFieldDefinition('logTime', ingest_api_LogTime)
        }

    def __init__(
            self,
            log_time: Optional["ingest_api_LogTime"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (log_time is not None) != 1:
                raise ValueError('a union must contain a single member')

            if log_time is not None:
                self._log_time = log_time
                self._type = 'logTime'

        elif type_of_union == 'logTime':
            if log_time is None:
                raise ValueError('a union value must not be None')
            self._log_time = log_time
            self._type = 'logTime'

    @builtins.property
    def log_time(self) -> Optional["ingest_api_LogTime"]:
        return self._log_time

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_McapTimestampTypeVisitor):
            raise ValueError('{} is not an instance of ingest_api_McapTimestampTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'logTime' and self.log_time is not None:
            return visitor._log_time(self.log_time)


ingest_api_McapTimestampType.__name__ = "McapTimestampType"
ingest_api_McapTimestampType.__qualname__ = "McapTimestampType"
ingest_api_McapTimestampType.__module__ = "nominal_api.ingest_api"


class ingest_api_McapTimestampTypeVisitor:

    @abstractmethod
    def _log_time(self, log_time: "ingest_api_LogTime") -> Any:
        pass


ingest_api_McapTimestampTypeVisitor.__name__ = "McapTimestampTypeVisitor"
ingest_api_McapTimestampTypeVisitor.__qualname__ = "McapTimestampTypeVisitor"
ingest_api_McapTimestampTypeVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_McapVideoChannelConfig(ConjureBeanType):
    """Ingest a channel as video. This requires:
* Using the `foxglove.CompressedVideo` schema
* Protobuf representation of the message data
* Messages are in sequential order in the mcap file
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_McapVideoChannelConfig.__name__ = "McapVideoChannelConfig"
ingest_api_McapVideoChannelConfig.__qualname__ = "McapVideoChannelConfig"
ingest_api_McapVideoChannelConfig.__module__ = "nominal_api.ingest_api"


class ingest_api_NewDataSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'time_column_spec': ConjureFieldDefinition('timeColumnSpec', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig])
        }

    __slots__: List[str] = ['_source', '_properties', '_labels', '_description', '_name', '_time_column_spec', '_channel_config']

    def __init__(self, labels: List[str], properties: Dict[str, str], source: "ingest_api_IngestSource", channel_config: Optional["ingest_api_ChannelConfig"] = None, description: Optional[str] = None, name: Optional[str] = None, time_column_spec: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._source = source
        self._properties = properties
        self._labels = labels
        self._description = description
        self._name = name
        self._time_column_spec = time_column_spec
        self._channel_config = channel_config

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def time_column_spec(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._time_column_spec

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config


ingest_api_NewDataSource.__name__ = "NewDataSource"
ingest_api_NewDataSource.__qualname__ = "NewDataSource"
ingest_api_NewDataSource.__module__ = "nominal_api.ingest_api"


class ingest_api_NewDatasetIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_name': ConjureFieldDefinition('datasetName', OptionalTypeWrapper[str]),
            'dataset_description': ConjureFieldDefinition('datasetDescription', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[ingest_api_ChannelConfig]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'marking_rids': ConjureFieldDefinition('markingRids', List[scout_rids_api_MarkingRid])
        }

    __slots__: List[str] = ['_dataset_name', '_dataset_description', '_properties', '_labels', '_channel_config', '_workspace', '_marking_rids']

    def __init__(self, labels: List[str], marking_rids: List[str], properties: Dict[str, str], channel_config: Optional["ingest_api_ChannelConfig"] = None, dataset_description: Optional[str] = None, dataset_name: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._dataset_name = dataset_name
        self._dataset_description = dataset_description
        self._properties = properties
        self._labels = labels
        self._channel_config = channel_config
        self._workspace = workspace
        self._marking_rids = marking_rids

    @builtins.property
    def dataset_name(self) -> Optional[str]:
        return self._dataset_name

    @builtins.property
    def dataset_description(self) -> Optional[str]:
        return self._dataset_description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def channel_config(self) -> Optional["ingest_api_ChannelConfig"]:
        return self._channel_config

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace

    @builtins.property
    def marking_rids(self) -> List[str]:
        """The markings to apply to the created dataset.
If not provided, the dataset will be visible to all users in the same workspace.
        """
        return self._marking_rids


ingest_api_NewDatasetIngestDestination.__name__ = "NewDatasetIngestDestination"
ingest_api_NewDatasetIngestDestination.__qualname__ = "NewDatasetIngestDestination"
ingest_api_NewDatasetIngestDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_NewVideoIngestDestination(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'video_file_details': ConjureFieldDefinition('videoFileDetails', OptionalTypeWrapper[ingest_api_VideoFileIngestDetails]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'marking_rids': ConjureFieldDefinition('markingRids', List[scout_rids_api_MarkingRid])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels', '_video_file_details', '_workspace', '_marking_rids']

    def __init__(self, labels: List[str], marking_rids: List[str], properties: Dict[str, str], description: Optional[str] = None, title: Optional[str] = None, video_file_details: Optional["ingest_api_VideoFileIngestDetails"] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._video_file_details = video_file_details
        self._workspace = workspace
        self._marking_rids = marking_rids

    @builtins.property
    def title(self) -> Optional[str]:
        """Title of the Video that will get created.
If not provided, a name is deduced from the ingested file.
        """
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        """Description that is applied to the newly created video
        """
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        """Key-Value properties that are applied to the newly created video
        """
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        """Labels that are applied to the newly created video
        """
        return self._labels

    @builtins.property
    def video_file_details(self) -> Optional["ingest_api_VideoFileIngestDetails"]:
        """Metadata to associate with any created video file
        """
        return self._video_file_details

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the video. If not provided, the video will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace

    @builtins.property
    def marking_rids(self) -> List[str]:
        """The markings to apply to the created video.
If not provided, the video will be visible to all users in the same workspace.
        """
        return self._marking_rids


ingest_api_NewVideoIngestDestination.__name__ = "NewVideoIngestDestination"
ingest_api_NewVideoIngestDestination.__qualname__ = "NewVideoIngestDestination"
ingest_api_NewVideoIngestDestination.__module__ = "nominal_api.ingest_api"


class ingest_api_NoTimestampManifest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', ingest_api_UtcTimestamp),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[ingest_api_ScaleParameter])
        }

    __slots__: List[str] = ['_starting_timestamp', '_scale_parameter']

    def __init__(self, starting_timestamp: "ingest_api_UtcTimestamp", scale_parameter: Optional["ingest_api_ScaleParameter"] = None) -> None:
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def starting_timestamp(self) -> "ingest_api_UtcTimestamp":
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["ingest_api_ScaleParameter"]:
        """A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
        """
        return self._scale_parameter


ingest_api_NoTimestampManifest.__name__ = "NoTimestampManifest"
ingest_api_NoTimestampManifest.__qualname__ = "NoTimestampManifest"
ingest_api_NoTimestampManifest.__module__ = "nominal_api.ingest_api"


class ingest_api_ParquetOpts(ConjureBeanType):
    """Options for ingesting parquet files.
Supported file formats include .parquet, .parquet.gz 
and archives such as .tar, .tar.gz, and .zip (must set the isArchive flag).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', ingest_api_TimestampMetadata),
            'channel_prefix': ConjureFieldDefinition('channelPrefix', ingest_api_ChannelPrefix),
            'tag_keys_from_columns': ConjureFieldDefinition('tagKeysFromColumns', OptionalTypeWrapper[List[api_TagName]]),
            'tag_columns': ConjureFieldDefinition('tagColumns', OptionalTypeWrapper[Dict[api_TagName, api_ColumnName]]),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]]),
            'is_archive': ConjureFieldDefinition('isArchive', OptionalTypeWrapper[bool]),
            'exclude_columns': ConjureFieldDefinition('excludeColumns', List[api_ColumnName])
        }

    __slots__: List[str] = ['_source', '_target', '_timestamp_metadata', '_channel_prefix', '_tag_keys_from_columns', '_tag_columns', '_additional_file_tags', '_is_archive', '_exclude_columns']

    def __init__(self, exclude_columns: List[str], source: "ingest_api_IngestSource", target: "ingest_api_DatasetIngestTarget", timestamp_metadata: "ingest_api_TimestampMetadata", additional_file_tags: Optional[Dict[str, str]] = None, channel_prefix: Optional[str] = None, is_archive: Optional[bool] = None, tag_columns: Optional[Dict[str, str]] = None, tag_keys_from_columns: Optional[List[str]] = None) -> None:
        self._source = source
        self._target = target
        self._timestamp_metadata = timestamp_metadata
        self._channel_prefix = channel_prefix
        self._tag_keys_from_columns = tag_keys_from_columns
        self._tag_columns = tag_columns
        self._additional_file_tags = additional_file_tags
        self._is_archive = is_archive
        self._exclude_columns = exclude_columns

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def timestamp_metadata(self) -> "ingest_api_TimestampMetadata":
        return self._timestamp_metadata

    @builtins.property
    def channel_prefix(self) -> Optional[str]:
        return self._channel_prefix

    @builtins.property
    def tag_keys_from_columns(self) -> Optional[List[str]]:
        return self._tag_keys_from_columns

    @builtins.property
    def tag_columns(self) -> Optional[Dict[str, str]]:
        """A map of tag names to column names to derive the tag values from.
        """
        return self._tag_columns

    @builtins.property
    def additional_file_tags(self) -> Optional[Dict[str, str]]:
        """Specifies a tag set to apply to all data in the file.
        """
        return self._additional_file_tags

    @builtins.property
    def is_archive(self) -> Optional[bool]:
        """If true, the file is an archive. Supported archive formats include
.tar, .tar.gz, and .zip. Only files ending in .parquet
within the archive will be ingested. If field not provided, defaults to false.
        """
        return self._is_archive

    @builtins.property
    def exclude_columns(self) -> List[str]:
        """A set of column names to exclude from ingestion. These columns will not be
ingested as channels. Useful for excluding columns that contain unsupported
data types like multidimensional arrays.
        """
        return self._exclude_columns


ingest_api_ParquetOpts.__name__ = "ParquetOpts"
ingest_api_ParquetOpts.__qualname__ = "ParquetOpts"
ingest_api_ParquetOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_Part(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part_number': ConjureFieldDefinition('partNumber', int),
            'etag': ConjureFieldDefinition('etag', str)
        }

    __slots__: List[str] = ['_part_number', '_etag']

    def __init__(self, etag: str, part_number: int) -> None:
        self._part_number = part_number
        self._etag = etag

    @builtins.property
    def part_number(self) -> int:
        return self._part_number

    @builtins.property
    def etag(self) -> str:
        return self._etag


ingest_api_Part.__name__ = "Part"
ingest_api_Part.__qualname__ = "Part"
ingest_api_Part.__module__ = "nominal_api.ingest_api"


class ingest_api_PartWithSize(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'part_number': ConjureFieldDefinition('partNumber', int),
            'etag': ConjureFieldDefinition('etag', str),
            'size': ConjureFieldDefinition('size', int)
        }

    __slots__: List[str] = ['_part_number', '_etag', '_size']

    def __init__(self, etag: str, part_number: int, size: int) -> None:
        self._part_number = part_number
        self._etag = etag
        self._size = size

    @builtins.property
    def part_number(self) -> int:
        return self._part_number

    @builtins.property
    def etag(self) -> str:
        return self._etag

    @builtins.property
    def size(self) -> int:
        return self._size


ingest_api_PartWithSize.__name__ = "PartWithSize"
ingest_api_PartWithSize.__qualname__ = "PartWithSize"
ingest_api_PartWithSize.__module__ = "nominal_api.ingest_api"


class ingest_api_PresignedFileIngestSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_url']

    def __init__(self, url: str) -> None:
        self._url = url

    @builtins.property
    def url(self) -> str:
        return self._url


ingest_api_PresignedFileIngestSource.__name__ = "PresignedFileIngestSource"
ingest_api_PresignedFileIngestSource.__qualname__ = "PresignedFileIngestSource"
ingest_api_PresignedFileIngestSource.__module__ = "nominal_api.ingest_api"


class ingest_api_PublicAuthentication(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_api_PublicAuthentication.__name__ = "PublicAuthentication"
ingest_api_PublicAuthentication.__qualname__ = "PublicAuthentication"
ingest_api_PublicAuthentication.__module__ = "nominal_api.ingest_api"


class ingest_api_RegisterContainerizedExtractorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'image': ConjureFieldDefinition('image', ingest_api_DockerImageSource),
            'inputs': ConjureFieldDefinition('inputs', List[ingest_api_FileExtractionInput]),
            'parameters': ConjureFieldDefinition('parameters', List[ingest_api_FileExtractionParameter]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'output_file_format': ConjureFieldDefinition('outputFileFormat', OptionalTypeWrapper[ingest_api_FileOutputFormat])
        }

    __slots__: List[str] = ['_name', '_description', '_image', '_inputs', '_parameters', '_properties', '_labels', '_workspace', '_timestamp_metadata', '_output_file_format']

    def __init__(self, image: "ingest_api_DockerImageSource", inputs: List["ingest_api_FileExtractionInput"], labels: List[str], name: str, parameters: List["ingest_api_FileExtractionParameter"], properties: Dict[str, str], workspace: str, description: Optional[str] = None, output_file_format: Optional["ingest_api_FileOutputFormat"] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._name = name
        self._description = description
        self._image = image
        self._inputs = inputs
        self._parameters = parameters
        self._properties = properties
        self._labels = labels
        self._workspace = workspace
        self._timestamp_metadata = timestamp_metadata
        self._output_file_format = output_file_format

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def image(self) -> "ingest_api_DockerImageSource":
        return self._image

    @builtins.property
    def inputs(self) -> List["ingest_api_FileExtractionInput"]:
        """payload must match input defined in containerized extraction
        """
        return self._inputs

    @builtins.property
    def parameters(self) -> List["ingest_api_FileExtractionParameter"]:
        """Describes the parameters of the extractor.
        """
        return self._parameters

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def workspace(self) -> str:
        """The workspace in which to create the extractor
        """
        return self._workspace

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        """Metadata about the intermediate parquet this extractor will produce.
If not set, timestamp metadata must be provided at ingest time.
        """
        return self._timestamp_metadata

    @builtins.property
    def output_file_format(self) -> Optional["ingest_api_FileOutputFormat"]:
        """The format of the output file. Currently only "parquet", "csv", "parquet.tar" are supported
        """
        return self._output_file_format


ingest_api_RegisterContainerizedExtractorRequest.__name__ = "RegisterContainerizedExtractorRequest"
ingest_api_RegisterContainerizedExtractorRequest.__qualname__ = "RegisterContainerizedExtractorRequest"
ingest_api_RegisterContainerizedExtractorRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_RegisterContainerizedExtractorResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'extractor_rid': ConjureFieldDefinition('extractorRid', ingest_api_ContainerizedExtractorRid)
        }

    __slots__: List[str] = ['_extractor_rid']

    def __init__(self, extractor_rid: str) -> None:
        self._extractor_rid = extractor_rid

    @builtins.property
    def extractor_rid(self) -> str:
        return self._extractor_rid


ingest_api_RegisterContainerizedExtractorResponse.__name__ = "RegisterContainerizedExtractorResponse"
ingest_api_RegisterContainerizedExtractorResponse.__qualname__ = "RegisterContainerizedExtractorResponse"
ingest_api_RegisterContainerizedExtractorResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_ReingestDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source_datasets': ConjureFieldDefinition('sourceDatasets', List[api_rids_DatasetRid]),
            'target_dataset': ConjureFieldDefinition('targetDataset', ingest_api_DatasetIngestTarget),
            'ingest_metadata': ConjureFieldDefinition('ingestMetadata', Dict[api_rids_DatasetRid, ingest_api_IngestMetadata])
        }

    __slots__: List[str] = ['_source_datasets', '_target_dataset', '_ingest_metadata']

    def __init__(self, ingest_metadata: Dict[str, "ingest_api_IngestMetadata"], source_datasets: List[str], target_dataset: "ingest_api_DatasetIngestTarget") -> None:
        self._source_datasets = source_datasets
        self._target_dataset = target_dataset
        self._ingest_metadata = ingest_metadata

    @builtins.property
    def source_datasets(self) -> List[str]:
        """The datasets to reingest data from. Can only include tagless, non-streaming datasets (V1).
The datasets must be of the same granularity and must only include CSV or Parquet files.
Will attempt to reingest from datasets in list order.
        """
        return self._source_datasets

    @builtins.property
    def target_dataset(self) -> "ingest_api_DatasetIngestTarget":
        """The dataset to ingest data into. Can either be a new dataset or an existing dataset RID.
        """
        return self._target_dataset

    @builtins.property
    def ingest_metadata(self) -> Dict[str, "ingest_api_IngestMetadata"]:
        """Mapping of dataset to ingest metadata.
Ingest metadata only needs to be provided in request if it cannot be recovered from prior ingests.
See documentation on each field to determine what metadata can be auto-recovered.
        """
        return self._ingest_metadata


ingest_api_ReingestDatasetsRequest.__name__ = "ReingestDatasetsRequest"
ingest_api_ReingestDatasetsRequest.__qualname__ = "ReingestDatasetsRequest"
ingest_api_ReingestDatasetsRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_ReingestDatasetsResponse(ConjureBeanType):
    """The response to a reingest request.
Maps the source dataset RID and file ID to the destination dataset RID and file ID.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'datasets': ConjureFieldDefinition('datasets', Dict[api_rids_DatasetRid, ingest_api_ReingestFilesMapping])
        }

    __slots__: List[str] = ['_datasets']

    def __init__(self, datasets: Dict[str, "ingest_api_ReingestFilesMapping"]) -> None:
        self._datasets = datasets

    @builtins.property
    def datasets(self) -> Dict[str, "ingest_api_ReingestFilesMapping"]:
        return self._datasets


ingest_api_ReingestDatasetsResponse.__name__ = "ReingestDatasetsResponse"
ingest_api_ReingestDatasetsResponse.__qualname__ = "ReingestDatasetsResponse"
ingest_api_ReingestDatasetsResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_ReingestFilesMapping(ConjureBeanType):
    """Maps the source dataset file ID to the destination dataset and file ID.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'file_map': ConjureFieldDefinition('fileMap', Dict[datasource_DatasetFileId, ingest_api_IngestDetails])
        }

    __slots__: List[str] = ['_file_map']

    def __init__(self, file_map: Dict[str, "ingest_api_IngestDetails"]) -> None:
        self._file_map = file_map

    @builtins.property
    def file_map(self) -> Dict[str, "ingest_api_IngestDetails"]:
        return self._file_map


ingest_api_ReingestFilesMapping.__name__ = "ReingestFilesMapping"
ingest_api_ReingestFilesMapping.__qualname__ = "ReingestFilesMapping"
ingest_api_ReingestFilesMapping.__module__ = "nominal_api.ingest_api"


class ingest_api_RelativeTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_time_unit', '_offset']

    def __init__(self, time_unit: "api_TimeUnit", offset: Optional[str] = None) -> None:
        self._time_unit = time_unit
        self._offset = offset

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit

    @builtins.property
    def offset(self) -> Optional[str]:
        """Starting timestamp to use when indexing the file. This field is required when uploading a new file to an existing dataset.
        """
        return self._offset


ingest_api_RelativeTimestamp.__name__ = "RelativeTimestamp"
ingest_api_RelativeTimestamp.__qualname__ = "RelativeTimestamp"
ingest_api_RelativeTimestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_RerunIngestRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', ingest_api_IngestJobRid)
        }

    __slots__: List[str] = ['_ingest_job_rid']

    def __init__(self, ingest_job_rid: str) -> None:
        self._ingest_job_rid = ingest_job_rid

    @builtins.property
    def ingest_job_rid(self) -> str:
        return self._ingest_job_rid


ingest_api_RerunIngestRequest.__name__ = "RerunIngestRequest"
ingest_api_RerunIngestRequest.__qualname__ = "RerunIngestRequest"
ingest_api_RerunIngestRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_S3IngestSource(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', str)
        }

    __slots__: List[str] = ['_path']

    def __init__(self, path: str) -> None:
        self._path = path

    @builtins.property
    def path(self) -> str:
        return self._path


ingest_api_S3IngestSource.__name__ = "S3IngestSource"
ingest_api_S3IngestSource.__qualname__ = "S3IngestSource"
ingest_api_S3IngestSource.__module__ = "nominal_api.ingest_api"


class ingest_api_ScaleParameter(ConjureUnionType):
    _true_frame_rate: Optional[float] = None
    _ending_timestamp: Optional["ingest_api_UtcTimestamp"] = None
    _scale_factor: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'true_frame_rate': ConjureFieldDefinition('trueFrameRate', float),
            'ending_timestamp': ConjureFieldDefinition('endingTimestamp', ingest_api_UtcTimestamp),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float)
        }

    def __init__(
            self,
            true_frame_rate: Optional[float] = None,
            ending_timestamp: Optional["ingest_api_UtcTimestamp"] = None,
            scale_factor: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (true_frame_rate is not None) + (ending_timestamp is not None) + (scale_factor is not None) != 1:
                raise ValueError('a union must contain a single member')

            if true_frame_rate is not None:
                self._true_frame_rate = true_frame_rate
                self._type = 'trueFrameRate'
            if ending_timestamp is not None:
                self._ending_timestamp = ending_timestamp
                self._type = 'endingTimestamp'
            if scale_factor is not None:
                self._scale_factor = scale_factor
                self._type = 'scaleFactor'

        elif type_of_union == 'trueFrameRate':
            if true_frame_rate is None:
                raise ValueError('a union value must not be None')
            self._true_frame_rate = true_frame_rate
            self._type = 'trueFrameRate'
        elif type_of_union == 'endingTimestamp':
            if ending_timestamp is None:
                raise ValueError('a union value must not be None')
            self._ending_timestamp = ending_timestamp
            self._type = 'endingTimestamp'
        elif type_of_union == 'scaleFactor':
            if scale_factor is None:
                raise ValueError('a union value must not be None')
            self._scale_factor = scale_factor
            self._type = 'scaleFactor'

    @builtins.property
    def true_frame_rate(self) -> Optional[float]:
        return self._true_frame_rate

    @builtins.property
    def ending_timestamp(self) -> Optional["ingest_api_UtcTimestamp"]:
        """the timestamp corresponding to absolute starting timestamp plus absolute duration of the video.
        """
        return self._ending_timestamp

    @builtins.property
    def scale_factor(self) -> Optional[float]:
        """the scale factor can be used to calculate whether media duration differs from a video's | real duration, and if so, the true frame rate of the camera. The video time will thus be scaled | by the ratio of the real duration to media duration, or media frame rate to true frame rate.
        """
        return self._scale_factor

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_ScaleParameterVisitor):
            raise ValueError('{} is not an instance of ingest_api_ScaleParameterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'trueFrameRate' and self.true_frame_rate is not None:
            return visitor._true_frame_rate(self.true_frame_rate)
        if self._type == 'endingTimestamp' and self.ending_timestamp is not None:
            return visitor._ending_timestamp(self.ending_timestamp)
        if self._type == 'scaleFactor' and self.scale_factor is not None:
            return visitor._scale_factor(self.scale_factor)


ingest_api_ScaleParameter.__name__ = "ScaleParameter"
ingest_api_ScaleParameter.__qualname__ = "ScaleParameter"
ingest_api_ScaleParameter.__module__ = "nominal_api.ingest_api"


class ingest_api_ScaleParameterVisitor:

    @abstractmethod
    def _true_frame_rate(self, true_frame_rate: float) -> Any:
        pass

    @abstractmethod
    def _ending_timestamp(self, ending_timestamp: "ingest_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _scale_factor(self, scale_factor: float) -> Any:
        pass


ingest_api_ScaleParameterVisitor.__name__ = "ScaleParameterVisitor"
ingest_api_ScaleParameterVisitor.__qualname__ = "ScaleParameterVisitor"
ingest_api_ScaleParameterVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_SearchContainerizedExtractorsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]] = None
    _or_: Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[ingest_api_SearchContainerizedExtractorsQuery]),
            'or_': ConjureFieldDefinition('or', List[ingest_api_SearchContainerizedExtractorsQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]] = None,
            or_: Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["ingest_api_SearchContainerizedExtractorsQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_SearchContainerizedExtractorsQueryVisitor):
            raise ValueError('{} is not an instance of ingest_api_SearchContainerizedExtractorsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


ingest_api_SearchContainerizedExtractorsQuery.__name__ = "SearchContainerizedExtractorsQuery"
ingest_api_SearchContainerizedExtractorsQuery.__qualname__ = "SearchContainerizedExtractorsQuery"
ingest_api_SearchContainerizedExtractorsQuery.__module__ = "nominal_api.ingest_api"


class ingest_api_SearchContainerizedExtractorsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["ingest_api_SearchContainerizedExtractorsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["ingest_api_SearchContainerizedExtractorsQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


ingest_api_SearchContainerizedExtractorsQueryVisitor.__name__ = "SearchContainerizedExtractorsQueryVisitor"
ingest_api_SearchContainerizedExtractorsQueryVisitor.__qualname__ = "SearchContainerizedExtractorsQueryVisitor"
ingest_api_SearchContainerizedExtractorsQueryVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_SearchContainerizedExtractorsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', ingest_api_SearchContainerizedExtractorsQuery)
        }

    __slots__: List[str] = ['_query']

    def __init__(self, query: "ingest_api_SearchContainerizedExtractorsQuery") -> None:
        self._query = query

    @builtins.property
    def query(self) -> "ingest_api_SearchContainerizedExtractorsQuery":
        return self._query


ingest_api_SearchContainerizedExtractorsRequest.__name__ = "SearchContainerizedExtractorsRequest"
ingest_api_SearchContainerizedExtractorsRequest.__qualname__ = "SearchContainerizedExtractorsRequest"
ingest_api_SearchContainerizedExtractorsRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_SignPartResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str),
            'headers': ConjureFieldDefinition('headers', Dict[str, str])
        }

    __slots__: List[str] = ['_url', '_headers']

    def __init__(self, headers: Dict[str, str], url: str) -> None:
        self._url = url
        self._headers = headers

    @builtins.property
    def url(self) -> str:
        return self._url

    @builtins.property
    def headers(self) -> Dict[str, str]:
        return self._headers


ingest_api_SignPartResponse.__name__ = "SignPartResponse"
ingest_api_SignPartResponse.__qualname__ = "SignPartResponse"
ingest_api_SignPartResponse.__module__ = "nominal_api.ingest_api"


class ingest_api_TagDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tags': ConjureFieldDefinition('tags', List[str]),
            'default_tag': ConjureFieldDefinition('defaultTag', str)
        }

    __slots__: List[str] = ['_tags', '_default_tag']

    def __init__(self, default_tag: str, tags: List[str]) -> None:
        self._tags = tags
        self._default_tag = default_tag

    @builtins.property
    def tags(self) -> List[str]:
        return self._tags

    @builtins.property
    def default_tag(self) -> str:
        return self._default_tag


ingest_api_TagDetails.__name__ = "TagDetails"
ingest_api_TagDetails.__qualname__ = "TagDetails"
ingest_api_TagDetails.__module__ = "nominal_api.ingest_api"


class ingest_api_TimeOffsetSpec(ConjureUnionType):
    _nanos: Optional["scout_run_api_Duration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nanos': ConjureFieldDefinition('nanos', scout_run_api_Duration)
        }

    def __init__(
            self,
            nanos: Optional["scout_run_api_Duration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (nanos is not None) != 1:
                raise ValueError('a union must contain a single member')

            if nanos is not None:
                self._nanos = nanos
                self._type = 'nanos'

        elif type_of_union == 'nanos':
            if nanos is None:
                raise ValueError('a union value must not be None')
            self._nanos = nanos
            self._type = 'nanos'

    @builtins.property
    def nanos(self) -> Optional["scout_run_api_Duration"]:
        return self._nanos

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_TimeOffsetSpecVisitor):
            raise ValueError('{} is not an instance of ingest_api_TimeOffsetSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'nanos' and self.nanos is not None:
            return visitor._nanos(self.nanos)


ingest_api_TimeOffsetSpec.__name__ = "TimeOffsetSpec"
ingest_api_TimeOffsetSpec.__qualname__ = "TimeOffsetSpec"
ingest_api_TimeOffsetSpec.__module__ = "nominal_api.ingest_api"


class ingest_api_TimeOffsetSpecVisitor:

    @abstractmethod
    def _nanos(self, nanos: "scout_run_api_Duration") -> Any:
        pass


ingest_api_TimeOffsetSpecVisitor.__name__ = "TimeOffsetSpecVisitor"
ingest_api_TimeOffsetSpecVisitor.__qualname__ = "TimeOffsetSpecVisitor"
ingest_api_TimeOffsetSpecVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_TimestampManifest(ConjureBeanType):
    """The timestamp manifest files will contain a list of absolute timestamps, in nanoseconds, that correspond to
each frame in a video. Each file should be of type JSON and store a single list, the length of which equals
the number of frames in its corresponding video.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sources': ConjureFieldDefinition('sources', List[ingest_api_IngestSource])
        }

    __slots__: List[str] = ['_sources']

    def __init__(self, sources: List["ingest_api_IngestSource"]) -> None:
        self._sources = sources

    @builtins.property
    def sources(self) -> List["ingest_api_IngestSource"]:
        return self._sources


ingest_api_TimestampManifest.__name__ = "TimestampManifest"
ingest_api_TimestampManifest.__qualname__ = "TimestampManifest"
ingest_api_TimestampManifest.__module__ = "nominal_api.ingest_api"


class ingest_api_TimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_name': ConjureFieldDefinition('seriesName', str),
            'timestamp_type': ConjureFieldDefinition('timestampType', ingest_api_TimestampType)
        }

    __slots__: List[str] = ['_series_name', '_timestamp_type']

    def __init__(self, series_name: str, timestamp_type: "ingest_api_TimestampType") -> None:
        self._series_name = series_name
        self._timestamp_type = timestamp_type

    @builtins.property
    def series_name(self) -> str:
        return self._series_name

    @builtins.property
    def timestamp_type(self) -> "ingest_api_TimestampType":
        return self._timestamp_type


ingest_api_TimestampMetadata.__name__ = "TimestampMetadata"
ingest_api_TimestampMetadata.__qualname__ = "TimestampMetadata"
ingest_api_TimestampMetadata.__module__ = "nominal_api.ingest_api"


class ingest_api_TimestampType(ConjureUnionType):
    _relative: Optional["ingest_api_RelativeTimestamp"] = None
    _absolute: Optional["ingest_api_AbsoluteTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative': ConjureFieldDefinition('relative', ingest_api_RelativeTimestamp),
            'absolute': ConjureFieldDefinition('absolute', ingest_api_AbsoluteTimestamp)
        }

    def __init__(
            self,
            relative: Optional["ingest_api_RelativeTimestamp"] = None,
            absolute: Optional["ingest_api_AbsoluteTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (relative is not None) + (absolute is not None) != 1:
                raise ValueError('a union must contain a single member')

            if relative is not None:
                self._relative = relative
                self._type = 'relative'
            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'

        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'
        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'

    @builtins.property
    def relative(self) -> Optional["ingest_api_RelativeTimestamp"]:
        return self._relative

    @builtins.property
    def absolute(self) -> Optional["ingest_api_AbsoluteTimestamp"]:
        return self._absolute

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_TimestampTypeVisitor):
            raise ValueError('{} is not an instance of ingest_api_TimestampTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)


ingest_api_TimestampType.__name__ = "TimestampType"
ingest_api_TimestampType.__qualname__ = "TimestampType"
ingest_api_TimestampType.__module__ = "nominal_api.ingest_api"


class ingest_api_TimestampTypeVisitor:

    @abstractmethod
    def _relative(self, relative: "ingest_api_RelativeTimestamp") -> Any:
        pass

    @abstractmethod
    def _absolute(self, absolute: "ingest_api_AbsoluteTimestamp") -> Any:
        pass


ingest_api_TimestampTypeVisitor.__name__ = "TimestampTypeVisitor"
ingest_api_TimestampTypeVisitor.__qualname__ = "TimestampTypeVisitor"
ingest_api_TimestampTypeVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_UpdateContainerizedExtractorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'inputs': ConjureFieldDefinition('inputs', OptionalTypeWrapper[List[ingest_api_FileExtractionInput]]),
            'parameters': ConjureFieldDefinition('parameters', OptionalTypeWrapper[List[ingest_api_FileExtractionParameter]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[ingest_api_TimestampMetadata]),
            'output_file_format': ConjureFieldDefinition('outputFileFormat', OptionalTypeWrapper[ingest_api_FileOutputFormat]),
            'registry': ConjureFieldDefinition('registry', OptionalTypeWrapper[str]),
            'repository': ConjureFieldDefinition('repository', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', OptionalTypeWrapper[List[str]]),
            'default_tag': ConjureFieldDefinition('defaultTag', OptionalTypeWrapper[str]),
            'authentication': ConjureFieldDefinition('authentication', OptionalTypeWrapper[ingest_api_Authentication]),
            'command': ConjureFieldDefinition('command', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name', '_description', '_inputs', '_parameters', '_properties', '_labels', '_timestamp_metadata', '_output_file_format', '_registry', '_repository', '_tags', '_default_tag', '_authentication', '_command']

    def __init__(self, authentication: Optional["ingest_api_Authentication"] = None, command: Optional[str] = None, default_tag: Optional[str] = None, description: Optional[str] = None, inputs: Optional[List["ingest_api_FileExtractionInput"]] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, output_file_format: Optional["ingest_api_FileOutputFormat"] = None, parameters: Optional[List["ingest_api_FileExtractionParameter"]] = None, properties: Optional[Dict[str, str]] = None, registry: Optional[str] = None, repository: Optional[str] = None, tags: Optional[List[str]] = None, timestamp_metadata: Optional["ingest_api_TimestampMetadata"] = None) -> None:
        self._name = name
        self._description = description
        self._inputs = inputs
        self._parameters = parameters
        self._properties = properties
        self._labels = labels
        self._timestamp_metadata = timestamp_metadata
        self._output_file_format = output_file_format
        self._registry = registry
        self._repository = repository
        self._tags = tags
        self._default_tag = default_tag
        self._authentication = authentication
        self._command = command

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def inputs(self) -> Optional[List["ingest_api_FileExtractionInput"]]:
        return self._inputs

    @builtins.property
    def parameters(self) -> Optional[List["ingest_api_FileExtractionParameter"]]:
        return self._parameters

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def timestamp_metadata(self) -> Optional["ingest_api_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def output_file_format(self) -> Optional["ingest_api_FileOutputFormat"]:
        return self._output_file_format

    @builtins.property
    def registry(self) -> Optional[str]:
        return self._registry

    @builtins.property
    def repository(self) -> Optional[str]:
        return self._repository

    @builtins.property
    def tags(self) -> Optional[List[str]]:
        return self._tags

    @builtins.property
    def default_tag(self) -> Optional[str]:
        return self._default_tag

    @builtins.property
    def authentication(self) -> Optional["ingest_api_Authentication"]:
        return self._authentication

    @builtins.property
    def command(self) -> Optional[str]:
        return self._command


ingest_api_UpdateContainerizedExtractorRequest.__name__ = "UpdateContainerizedExtractorRequest"
ingest_api_UpdateContainerizedExtractorRequest.__qualname__ = "UpdateContainerizedExtractorRequest"
ingest_api_UpdateContainerizedExtractorRequest.__module__ = "nominal_api.ingest_api"


class ingest_api_UserAndPasswordAuthentication(ConjureBeanType):
    """Username and password authentication.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'username': ConjureFieldDefinition('username', str),
            'password_secret_rid': ConjureFieldDefinition('passwordSecretRid', secrets_api_SecretRid)
        }

    __slots__: List[str] = ['_username', '_password_secret_rid']

    def __init__(self, password_secret_rid: str, username: str) -> None:
        self._username = username
        self._password_secret_rid = password_secret_rid

    @builtins.property
    def username(self) -> str:
        """Username for registry authentication.
        """
        return self._username

    @builtins.property
    def password_secret_rid(self) -> str:
        """The RID of the secret containing the password for registry authentication.
        """
        return self._password_secret_rid


ingest_api_UserAndPasswordAuthentication.__name__ = "UserAndPasswordAuthentication"
ingest_api_UserAndPasswordAuthentication.__qualname__ = "UserAndPasswordAuthentication"
ingest_api_UserAndPasswordAuthentication.__module__ = "nominal_api.ingest_api"


class ingest_api_UtcTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds_since_epoch': ConjureFieldDefinition('secondsSinceEpoch', int),
            'offset_nanoseconds': ConjureFieldDefinition('offsetNanoseconds', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds_since_epoch', '_offset_nanoseconds']

    def __init__(self, seconds_since_epoch: int, offset_nanoseconds: Optional[int] = None) -> None:
        self._seconds_since_epoch = seconds_since_epoch
        self._offset_nanoseconds = offset_nanoseconds

    @builtins.property
    def seconds_since_epoch(self) -> int:
        return self._seconds_since_epoch

    @builtins.property
    def offset_nanoseconds(self) -> Optional[int]:
        return self._offset_nanoseconds


ingest_api_UtcTimestamp.__name__ = "UtcTimestamp"
ingest_api_UtcTimestamp.__qualname__ = "UtcTimestamp"
ingest_api_UtcTimestamp.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoFileIngestDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'file_description': ConjureFieldDefinition('fileDescription', OptionalTypeWrapper[str]),
            'file_properties': ConjureFieldDefinition('fileProperties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'file_labels': ConjureFieldDefinition('fileLabels', OptionalTypeWrapper[List[api_Label]])
        }

    __slots__: List[str] = ['_file_description', '_file_properties', '_file_labels']

    def __init__(self, file_description: Optional[str] = None, file_labels: Optional[List[str]] = None, file_properties: Optional[Dict[str, str]] = None) -> None:
        self._file_description = file_description
        self._file_properties = file_properties
        self._file_labels = file_labels

    @builtins.property
    def file_description(self) -> Optional[str]:
        """Description that is applied to the newly created video file.
If not provided, defaults to the description used to create the video.
        """
        return self._file_description

    @builtins.property
    def file_properties(self) -> Optional[Dict[str, str]]:
        """Key-Value properties that are applied to the newly created video file.
        """
        return self._file_properties

    @builtins.property
    def file_labels(self) -> Optional[List[str]]:
        """Labels that are applied to the newly created video file.
        """
        return self._file_labels


ingest_api_VideoFileIngestDetails.__name__ = "VideoFileIngestDetails"
ingest_api_VideoFileIngestDetails.__qualname__ = "VideoFileIngestDetails"
ingest_api_VideoFileIngestDetails.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoIngestTarget(ConjureUnionType):
    _new: Optional["ingest_api_NewVideoIngestDestination"] = None
    _existing: Optional["ingest_api_ExistingVideoIngestDestination"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new': ConjureFieldDefinition('new', ingest_api_NewVideoIngestDestination),
            'existing': ConjureFieldDefinition('existing', ingest_api_ExistingVideoIngestDestination)
        }

    def __init__(
            self,
            new: Optional["ingest_api_NewVideoIngestDestination"] = None,
            existing: Optional["ingest_api_ExistingVideoIngestDestination"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (new is not None) + (existing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if new is not None:
                self._new = new
                self._type = 'new'
            if existing is not None:
                self._existing = existing
                self._type = 'existing'

        elif type_of_union == 'new':
            if new is None:
                raise ValueError('a union value must not be None')
            self._new = new
            self._type = 'new'
        elif type_of_union == 'existing':
            if existing is None:
                raise ValueError('a union value must not be None')
            self._existing = existing
            self._type = 'existing'

    @builtins.property
    def new(self) -> Optional["ingest_api_NewVideoIngestDestination"]:
        return self._new

    @builtins.property
    def existing(self) -> Optional["ingest_api_ExistingVideoIngestDestination"]:
        return self._existing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_VideoIngestTargetVisitor):
            raise ValueError('{} is not an instance of ingest_api_VideoIngestTargetVisitor'.format(visitor.__class__.__name__))
        if self._type == 'new' and self.new is not None:
            return visitor._new(self.new)
        if self._type == 'existing' and self.existing is not None:
            return visitor._existing(self.existing)


ingest_api_VideoIngestTarget.__name__ = "VideoIngestTarget"
ingest_api_VideoIngestTarget.__qualname__ = "VideoIngestTarget"
ingest_api_VideoIngestTarget.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoIngestTargetVisitor:

    @abstractmethod
    def _new(self, new: "ingest_api_NewVideoIngestDestination") -> Any:
        pass

    @abstractmethod
    def _existing(self, existing: "ingest_api_ExistingVideoIngestDestination") -> Any:
        pass


ingest_api_VideoIngestTargetVisitor.__name__ = "VideoIngestTargetVisitor"
ingest_api_VideoIngestTargetVisitor.__qualname__ = "VideoIngestTargetVisitor"
ingest_api_VideoIngestTargetVisitor.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoOpts(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_VideoIngestTarget),
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoFileTimestampManifest),
            'over_write_segments': ConjureFieldDefinition('overWriteSegments', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_source', '_target', '_timestamp_manifest', '_over_write_segments']

    def __init__(self, source: "ingest_api_IngestSource", target: "ingest_api_VideoIngestTarget", timestamp_manifest: "scout_video_api_VideoFileTimestampManifest", over_write_segments: Optional[bool] = None) -> None:
        self._source = source
        self._target = target
        self._timestamp_manifest = timestamp_manifest
        self._over_write_segments = over_write_segments

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_VideoIngestTarget":
        return self._target

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoFileTimestampManifest":
        return self._timestamp_manifest

    @builtins.property
    def over_write_segments(self) -> Optional[bool]:
        """If true, overlapping segments from other video files within the same video will be deleted
before inserting new segments. The cached segment metadata for affected files will be recomputed.
        """
        return self._over_write_segments


ingest_api_VideoOpts.__name__ = "VideoOpts"
ingest_api_VideoOpts.__qualname__ = "VideoOpts"
ingest_api_VideoOpts.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoOptsV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', ingest_api_IngestSource),
            'target': ConjureFieldDefinition('target', ingest_api_DatasetIngestTarget),
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoFileTimestampManifest),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'over_write_segments': ConjureFieldDefinition('overWriteSegments', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_source', '_target', '_timestamp_manifest', '_channel', '_tags', '_over_write_segments']

    def __init__(self, channel: str, source: "ingest_api_IngestSource", tags: Dict[str, str], target: "ingest_api_DatasetIngestTarget", timestamp_manifest: "scout_video_api_VideoFileTimestampManifest", over_write_segments: Optional[bool] = None) -> None:
        self._source = source
        self._target = target
        self._timestamp_manifest = timestamp_manifest
        self._channel = channel
        self._tags = tags
        self._over_write_segments = over_write_segments

    @builtins.property
    def source(self) -> "ingest_api_IngestSource":
        return self._source

    @builtins.property
    def target(self) -> "ingest_api_DatasetIngestTarget":
        return self._target

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoFileTimestampManifest":
        return self._timestamp_manifest

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def over_write_segments(self) -> Optional[bool]:
        """If true, overlapping segments from other dataset files within the same series will be deleted
before inserting new segments. The cached segment metadata for affected files will be recomputed.
        """
        return self._over_write_segments


ingest_api_VideoOptsV2.__name__ = "VideoOptsV2"
ingest_api_VideoOptsV2.__qualname__ = "VideoOptsV2"
ingest_api_VideoOptsV2.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoTimestampManifest(ConjureUnionType):
    _no_manifest: Optional["ingest_api_NoTimestampManifest"] = None
    _timestamp_manifests: Optional["ingest_api_TimestampManifest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'no_manifest': ConjureFieldDefinition('noManifest', ingest_api_NoTimestampManifest),
            'timestamp_manifests': ConjureFieldDefinition('timestampManifests', ingest_api_TimestampManifest)
        }

    def __init__(
            self,
            no_manifest: Optional["ingest_api_NoTimestampManifest"] = None,
            timestamp_manifests: Optional["ingest_api_TimestampManifest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (no_manifest is not None) + (timestamp_manifests is not None) != 1:
                raise ValueError('a union must contain a single member')

            if no_manifest is not None:
                self._no_manifest = no_manifest
                self._type = 'noManifest'
            if timestamp_manifests is not None:
                self._timestamp_manifests = timestamp_manifests
                self._type = 'timestampManifests'

        elif type_of_union == 'noManifest':
            if no_manifest is None:
                raise ValueError('a union value must not be None')
            self._no_manifest = no_manifest
            self._type = 'noManifest'
        elif type_of_union == 'timestampManifests':
            if timestamp_manifests is None:
                raise ValueError('a union value must not be None')
            self._timestamp_manifests = timestamp_manifests
            self._type = 'timestampManifests'

    @builtins.property
    def no_manifest(self) -> Optional["ingest_api_NoTimestampManifest"]:
        return self._no_manifest

    @builtins.property
    def timestamp_manifests(self) -> Optional["ingest_api_TimestampManifest"]:
        return self._timestamp_manifests

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_api_VideoTimestampManifestVisitor):
            raise ValueError('{} is not an instance of ingest_api_VideoTimestampManifestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'noManifest' and self.no_manifest is not None:
            return visitor._no_manifest(self.no_manifest)
        if self._type == 'timestampManifests' and self.timestamp_manifests is not None:
            return visitor._timestamp_manifests(self.timestamp_manifests)


ingest_api_VideoTimestampManifest.__name__ = "VideoTimestampManifest"
ingest_api_VideoTimestampManifest.__qualname__ = "VideoTimestampManifest"
ingest_api_VideoTimestampManifest.__module__ = "nominal_api.ingest_api"


class ingest_api_VideoTimestampManifestVisitor:

    @abstractmethod
    def _no_manifest(self, no_manifest: "ingest_api_NoTimestampManifest") -> Any:
        pass

    @abstractmethod
    def _timestamp_manifests(self, timestamp_manifests: "ingest_api_TimestampManifest") -> Any:
        pass


ingest_api_VideoTimestampManifestVisitor.__name__ = "VideoTimestampManifestVisitor"
ingest_api_VideoTimestampManifestVisitor.__qualname__ = "VideoTimestampManifestVisitor"
ingest_api_VideoTimestampManifestVisitor.__module__ = "nominal_api.ingest_api"


class ingest_manifest_ExtractorManifest(ConjureBeanType):
    """Manifest file produced by containerized extractors to describe their outputs.
This is written as manifest.json in the OUTPUT_DIR by the container.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'outputs': ConjureFieldDefinition('outputs', List[ingest_manifest_ManifestOutput])
        }

    __slots__: List[str] = ['_outputs']

    def __init__(self, outputs: List["ingest_manifest_ManifestOutput"]) -> None:
        self._outputs = outputs

    @builtins.property
    def outputs(self) -> List["ingest_manifest_ManifestOutput"]:
        """List of output files produced by the extractor
        """
        return self._outputs


ingest_manifest_ExtractorManifest.__name__ = "ExtractorManifest"
ingest_manifest_ExtractorManifest.__qualname__ = "ExtractorManifest"
ingest_manifest_ExtractorManifest.__module__ = "nominal_api.ingest_manifest"


class ingest_manifest_ExtractorUploadMetadata(ConjureBeanType):
    """Metadata file created by yeeter after uploading extractor outputs to S3.
This is uploaded to S3 by yeeter and read by the Temporal activity to orchestrate ingestion.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uploads': ConjureFieldDefinition('uploads', List[ingest_manifest_UploadMetadata])
        }

    __slots__: List[str] = ['_uploads']

    def __init__(self, uploads: List["ingest_manifest_UploadMetadata"]) -> None:
        self._uploads = uploads

    @builtins.property
    def uploads(self) -> List["ingest_manifest_UploadMetadata"]:
        """List of uploaded files with their S3 locations and manifest metadata
        """
        return self._uploads


ingest_manifest_ExtractorUploadMetadata.__name__ = "ExtractorUploadMetadata"
ingest_manifest_ExtractorUploadMetadata.__qualname__ = "ExtractorUploadMetadata"
ingest_manifest_ExtractorUploadMetadata.__module__ = "nominal_api.ingest_manifest"


class ingest_manifest_ManifestIngestType(ConjureEnumType):
    """Supported ingest types for containerized extractor outputs.
    """

    TABULAR = 'TABULAR'
    '''TABULAR'''
    AVRO_STREAM = 'AVRO_STREAM'
    '''AVRO_STREAM'''
    JSON_L = 'JSON_L'
    '''JSON_L'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_manifest_ManifestIngestType.__name__ = "ManifestIngestType"
ingest_manifest_ManifestIngestType.__qualname__ = "ManifestIngestType"
ingest_manifest_ManifestIngestType.__module__ = "nominal_api.ingest_manifest"


class ingest_manifest_ManifestOutput(ConjureBeanType):
    """Describes a single output file from a containerized extractor.
This is written by the container in manifest.json.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_type': ConjureFieldDefinition('ingestType', ingest_manifest_ManifestIngestType),
            'relative_path': ConjureFieldDefinition('relativePath', str),
            'tag_columns': ConjureFieldDefinition('tagColumns', Dict[str, str]),
            'channel_prefix': ConjureFieldDefinition('channelPrefix', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_ingest_type', '_relative_path', '_tag_columns', '_channel_prefix']

    def __init__(self, ingest_type: "ingest_manifest_ManifestIngestType", relative_path: str, tag_columns: Dict[str, str], channel_prefix: Optional[str] = None) -> None:
        self._ingest_type = ingest_type
        self._relative_path = relative_path
        self._tag_columns = tag_columns
        self._channel_prefix = channel_prefix

    @builtins.property
    def ingest_type(self) -> "ingest_manifest_ManifestIngestType":
        """The type of ingestion for this output file
        """
        return self._ingest_type

    @builtins.property
    def relative_path(self) -> str:
        """Relative path to the output file within OUTPUT_DIR.
Example: "telemetry.csv" or "data/sensor_readings.parquet"
        """
        return self._relative_path

    @builtins.property
    def tag_columns(self) -> Dict[str, str]:
        """Optional mapping of tag names to column names for CSV/Parquet ingestion.
Example: {"vehicle_id": "veh_id", "mission_id": "msn_id"}
        """
        return self._tag_columns

    @builtins.property
    def channel_prefix(self) -> Optional[str]:
        """Optional prefix to prepend to channel names during ingestion.
Example: "telemetry/" would create channels like "telemetry/speed", "telemetry/altitude"
        """
        return self._channel_prefix


ingest_manifest_ManifestOutput.__name__ = "ManifestOutput"
ingest_manifest_ManifestOutput.__qualname__ = "ManifestOutput"
ingest_manifest_ManifestOutput.__module__ = "nominal_api.ingest_manifest"


class ingest_manifest_UploadMetadata(ConjureBeanType):
    """Metadata about a single file uploaded to S3 by yeeter.
Enriches the original manifest entry with S3 upload information.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_key': ConjureFieldDefinition('s3Key', str),
            's3_bucket': ConjureFieldDefinition('s3Bucket', str),
            'manifest_output': ConjureFieldDefinition('manifestOutput', ingest_manifest_ManifestOutput)
        }

    __slots__: List[str] = ['_s3_key', '_s3_bucket', '_manifest_output']

    def __init__(self, manifest_output: "ingest_manifest_ManifestOutput", s3_bucket: str, s3_key: str) -> None:
        self._s3_key = s3_key
        self._s3_bucket = s3_bucket
        self._manifest_output = manifest_output

    @builtins.property
    def s3_key(self) -> str:
        """Full S3 key where the file was uploaded
        """
        return self._s3_key

    @builtins.property
    def s3_bucket(self) -> str:
        """S3 bucket name where the file was uploaded
        """
        return self._s3_bucket

    @builtins.property
    def manifest_output(self) -> "ingest_manifest_ManifestOutput":
        """The original manifest entry from the container's manifest.yaml
        """
        return self._manifest_output


ingest_manifest_UploadMetadata.__name__ = "UploadMetadata"
ingest_manifest_UploadMetadata.__qualname__ = "UploadMetadata"
ingest_manifest_UploadMetadata.__module__ = "nominal_api.ingest_manifest"


class ingest_workflow_api_Empty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_workflow_api_Empty.__name__ = "Empty"
ingest_workflow_api_Empty.__qualname__ = "Empty"
ingest_workflow_api_Empty.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureExtractorJobCreatedRequest(ConjureBeanType):
    """Ensure that the extractor job exists in the control plane. Runs in the namespace given by workspaceRid.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bearer_token': ConjureFieldDefinition('bearerToken', str),
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid),
            'ingest_job_uuid': ConjureFieldDefinition('ingestJobUuid', str),
            'containerized_extractor': ConjureFieldDefinition('containerizedExtractor', ingest_api_ContainerizedExtractor),
            'tag': ConjureFieldDefinition('tag', str),
            'validated_file_inputs': ConjureFieldDefinition('validatedFileInputs', List[ingest_workflow_api_ValidatedFileInput]),
            'multipart_upload_details': ConjureFieldDefinition('multipartUploadDetails', ingest_workflow_api_MultipartUploadDetails),
            'image_pull_secret_name': ConjureFieldDefinition('imagePullSecretName', OptionalTypeWrapper[str]),
            'arguments': ConjureFieldDefinition('arguments', Dict[ingest_api_EnvironmentVariable, str])
        }

    __slots__: List[str] = ['_bearer_token', '_workspace_rid', '_ingest_job_uuid', '_containerized_extractor', '_tag', '_validated_file_inputs', '_multipart_upload_details', '_image_pull_secret_name', '_arguments']

    def __init__(self, arguments: Dict[str, str], bearer_token: str, containerized_extractor: "ingest_api_ContainerizedExtractor", ingest_job_uuid: str, multipart_upload_details: "ingest_workflow_api_MultipartUploadDetails", tag: str, validated_file_inputs: List["ingest_workflow_api_ValidatedFileInput"], workspace_rid: str, image_pull_secret_name: Optional[str] = None) -> None:
        self._bearer_token = bearer_token
        self._workspace_rid = workspace_rid
        self._ingest_job_uuid = ingest_job_uuid
        self._containerized_extractor = containerized_extractor
        self._tag = tag
        self._validated_file_inputs = validated_file_inputs
        self._multipart_upload_details = multipart_upload_details
        self._image_pull_secret_name = image_pull_secret_name
        self._arguments = arguments

    @builtins.property
    def bearer_token(self) -> str:
        return self._bearer_token

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid

    @builtins.property
    def ingest_job_uuid(self) -> str:
        return self._ingest_job_uuid

    @builtins.property
    def containerized_extractor(self) -> "ingest_api_ContainerizedExtractor":
        return self._containerized_extractor

    @builtins.property
    def tag(self) -> str:
        return self._tag

    @builtins.property
    def validated_file_inputs(self) -> List["ingest_workflow_api_ValidatedFileInput"]:
        return self._validated_file_inputs

    @builtins.property
    def multipart_upload_details(self) -> "ingest_workflow_api_MultipartUploadDetails":
        return self._multipart_upload_details

    @builtins.property
    def image_pull_secret_name(self) -> Optional[str]:
        """Name of the Kubernetes secret to use for pulling the image, if authentication is required.
        """
        return self._image_pull_secret_name

    @builtins.property
    def arguments(self) -> Dict[str, str]:
        """Additional arguments to pass as environment variables to the container.
        """
        return self._arguments


ingest_workflow_api_EnsureExtractorJobCreatedRequest.__name__ = "EnsureExtractorJobCreatedRequest"
ingest_workflow_api_EnsureExtractorJobCreatedRequest.__qualname__ = "EnsureExtractorJobCreatedRequest"
ingest_workflow_api_EnsureExtractorJobCreatedRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureExtractorJobCreatedResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_workflow_api_EnsureExtractorJobCreatedResponse.__name__ = "EnsureExtractorJobCreatedResponse"
ingest_workflow_api_EnsureExtractorJobCreatedResponse.__qualname__ = "EnsureExtractorJobCreatedResponse"
ingest_workflow_api_EnsureExtractorJobCreatedResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureImagePullSecretCreatedRequest(ConjureBeanType):
    """Ensures a Kubernetes secret of type kubernetes.io/dockerconfigjson exists
for the given registry credentials.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid),
            'image_source': ConjureFieldDefinition('imageSource', ingest_api_DockerImageSource),
            'authentication': ConjureFieldDefinition('authentication', ingest_api_UserAndPasswordAuthentication),
            'ingest_job_uuid': ConjureFieldDefinition('ingestJobUuid', str),
            'bearer_token': ConjureFieldDefinition('bearerToken', str)
        }

    __slots__: List[str] = ['_workspace_rid', '_image_source', '_authentication', '_ingest_job_uuid', '_bearer_token']

    def __init__(self, authentication: "ingest_api_UserAndPasswordAuthentication", bearer_token: str, image_source: "ingest_api_DockerImageSource", ingest_job_uuid: str, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid
        self._image_source = image_source
        self._authentication = authentication
        self._ingest_job_uuid = ingest_job_uuid
        self._bearer_token = bearer_token

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid

    @builtins.property
    def image_source(self) -> "ingest_api_DockerImageSource":
        return self._image_source

    @builtins.property
    def authentication(self) -> "ingest_api_UserAndPasswordAuthentication":
        return self._authentication

    @builtins.property
    def ingest_job_uuid(self) -> str:
        return self._ingest_job_uuid

    @builtins.property
    def bearer_token(self) -> str:
        return self._bearer_token


ingest_workflow_api_EnsureImagePullSecretCreatedRequest.__name__ = "EnsureImagePullSecretCreatedRequest"
ingest_workflow_api_EnsureImagePullSecretCreatedRequest.__qualname__ = "EnsureImagePullSecretCreatedRequest"
ingest_workflow_api_EnsureImagePullSecretCreatedRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureImagePullSecretCreatedResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'secret_name': ConjureFieldDefinition('secretName', str)
        }

    __slots__: List[str] = ['_secret_name']

    def __init__(self, secret_name: str) -> None:
        self._secret_name = secret_name

    @builtins.property
    def secret_name(self) -> str:
        return self._secret_name


ingest_workflow_api_EnsureImagePullSecretCreatedResponse.__name__ = "EnsureImagePullSecretCreatedResponse"
ingest_workflow_api_EnsureImagePullSecretCreatedResponse.__qualname__ = "EnsureImagePullSecretCreatedResponse"
ingest_workflow_api_EnsureImagePullSecretCreatedResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureWorkspaceConfigMapCreatedRequest(ConjureBeanType):
    """For a given workspace rid, ensures there is a log4j2 config map defined in the namespace.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid)
        }

    __slots__: List[str] = ['_workspace_rid']

    def __init__(self, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid


ingest_workflow_api_EnsureWorkspaceConfigMapCreatedRequest.__name__ = "EnsureWorkspaceConfigMapCreatedRequest"
ingest_workflow_api_EnsureWorkspaceConfigMapCreatedRequest.__qualname__ = "EnsureWorkspaceConfigMapCreatedRequest"
ingest_workflow_api_EnsureWorkspaceConfigMapCreatedRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureWorkspaceNamespaceCreatedRequest(ConjureBeanType):
    """For a given workspace rid, ensures that there is a corresponding K8s namespace created.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid)
        }

    __slots__: List[str] = ['_workspace_rid']

    def __init__(self, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid


ingest_workflow_api_EnsureWorkspaceNamespaceCreatedRequest.__name__ = "EnsureWorkspaceNamespaceCreatedRequest"
ingest_workflow_api_EnsureWorkspaceNamespaceCreatedRequest.__qualname__ = "EnsureWorkspaceNamespaceCreatedRequest"
ingest_workflow_api_EnsureWorkspaceNamespaceCreatedRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_EnsureWorkspaceServiceAccountCreatedRequest(ConjureBeanType):
    """For a given workspace rid, ensures that there is a service account in the proper K8s Namespace.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid)
        }

    __slots__: List[str] = ['_workspace_rid']

    def __init__(self, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid


ingest_workflow_api_EnsureWorkspaceServiceAccountCreatedRequest.__name__ = "EnsureWorkspaceServiceAccountCreatedRequest"
ingest_workflow_api_EnsureWorkspaceServiceAccountCreatedRequest.__qualname__ = "EnsureWorkspaceServiceAccountCreatedRequest"
ingest_workflow_api_EnsureWorkspaceServiceAccountCreatedRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_ExtractorJobState(ConjureEnumType):

    PENDING = 'PENDING'
    '''PENDING'''
    RUNNING = 'RUNNING'
    '''RUNNING'''
    FAILED = 'FAILED'
    '''FAILED'''
    SUCCEEDED = 'SUCCEEDED'
    '''SUCCEEDED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_workflow_api_ExtractorJobState.__name__ = "ExtractorJobState"
ingest_workflow_api_ExtractorJobState.__qualname__ = "ExtractorJobState"
ingest_workflow_api_ExtractorJobState.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_FetchExtractorJobLogsRequest(ConjureBeanType):
    """Request to fetch logs for all containers in a completed extractor job's pod.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid),
            'log_dataset_rid': ConjureFieldDefinition('logDatasetRid', api_rids_DatasetRid),
            'ingest_job_uuid': ConjureFieldDefinition('ingestJobUuid', str),
            'bearer_token': ConjureFieldDefinition('bearerToken', str),
            'extractor_rid': ConjureFieldDefinition('extractorRid', ingest_api_ContainerizedExtractorRid)
        }

    __slots__: List[str] = ['_workspace_rid', '_log_dataset_rid', '_ingest_job_uuid', '_bearer_token', '_extractor_rid']

    def __init__(self, bearer_token: str, extractor_rid: str, ingest_job_uuid: str, log_dataset_rid: str, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid
        self._log_dataset_rid = log_dataset_rid
        self._ingest_job_uuid = ingest_job_uuid
        self._bearer_token = bearer_token
        self._extractor_rid = extractor_rid

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid

    @builtins.property
    def log_dataset_rid(self) -> str:
        return self._log_dataset_rid

    @builtins.property
    def ingest_job_uuid(self) -> str:
        return self._ingest_job_uuid

    @builtins.property
    def bearer_token(self) -> str:
        return self._bearer_token

    @builtins.property
    def extractor_rid(self) -> str:
        return self._extractor_rid


ingest_workflow_api_FetchExtractorJobLogsRequest.__name__ = "FetchExtractorJobLogsRequest"
ingest_workflow_api_FetchExtractorJobLogsRequest.__qualname__ = "FetchExtractorJobLogsRequest"
ingest_workflow_api_FetchExtractorJobLogsRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_FetchExtractorJobLogsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



ingest_workflow_api_FetchExtractorJobLogsResponse.__name__ = "FetchExtractorJobLogsResponse"
ingest_workflow_api_FetchExtractorJobLogsResponse.__qualname__ = "FetchExtractorJobLogsResponse"
ingest_workflow_api_FetchExtractorJobLogsResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_GetExtractorJobStateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_rid': ConjureFieldDefinition('workspaceRid', api_rids_WorkspaceRid),
            'ingest_job_uuid': ConjureFieldDefinition('ingestJobUuid', str)
        }

    __slots__: List[str] = ['_workspace_rid', '_ingest_job_uuid']

    def __init__(self, ingest_job_uuid: str, workspace_rid: str) -> None:
        self._workspace_rid = workspace_rid
        self._ingest_job_uuid = ingest_job_uuid

    @builtins.property
    def workspace_rid(self) -> str:
        return self._workspace_rid

    @builtins.property
    def ingest_job_uuid(self) -> str:
        return self._ingest_job_uuid


ingest_workflow_api_GetExtractorJobStateRequest.__name__ = "GetExtractorJobStateRequest"
ingest_workflow_api_GetExtractorJobStateRequest.__qualname__ = "GetExtractorJobStateRequest"
ingest_workflow_api_GetExtractorJobStateRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_GetExtractorJobStateResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'state': ConjureFieldDefinition('state', ingest_workflow_api_ExtractorJobState),
            'message': ConjureFieldDefinition('message', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_state', '_message']

    def __init__(self, state: "ingest_workflow_api_ExtractorJobState", message: Optional[str] = None) -> None:
        self._state = state
        self._message = message

    @builtins.property
    def state(self) -> "ingest_workflow_api_ExtractorJobState":
        return self._state

    @builtins.property
    def message(self) -> Optional[str]:
        return self._message


ingest_workflow_api_GetExtractorJobStateResponse.__name__ = "GetExtractorJobStateResponse"
ingest_workflow_api_GetExtractorJobStateResponse.__qualname__ = "GetExtractorJobStateResponse"
ingest_workflow_api_GetExtractorJobStateResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_IngestDataflashRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', ingest_workflow_api_ObjectLocator)
        }

    __slots__: List[str] = ['_locator']

    def __init__(self, locator: "ingest_workflow_api_ObjectLocator") -> None:
        self._locator = locator

    @builtins.property
    def locator(self) -> "ingest_workflow_api_ObjectLocator":
        return self._locator


ingest_workflow_api_IngestDataflashRequest.__name__ = "IngestDataflashRequest"
ingest_workflow_api_IngestDataflashRequest.__qualname__ = "IngestDataflashRequest"
ingest_workflow_api_IngestDataflashRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_IngestDataflashResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'units': ConjureFieldDefinition('units', Dict[str, str]),
            'parquet_object_locators': ConjureFieldDefinition('parquetObjectLocators', List[ingest_workflow_api_ObjectLocator]),
            'timestamp_series_name': ConjureFieldDefinition('timestampSeriesName', str),
            'time_unit': ConjureFieldDefinition('timeUnit', ingest_workflow_api_TimeUnitSeconds),
            'avro_locator': ConjureFieldDefinition('avroLocator', OptionalTypeWrapper[ingest_workflow_api_ObjectLocator])
        }

    __slots__: List[str] = ['_units', '_parquet_object_locators', '_timestamp_series_name', '_time_unit', '_avro_locator']

    def __init__(self, parquet_object_locators: List["ingest_workflow_api_ObjectLocator"], time_unit: "ingest_workflow_api_TimeUnitSeconds", timestamp_series_name: str, units: Dict[str, str], avro_locator: Optional["ingest_workflow_api_ObjectLocator"] = None) -> None:
        self._units = units
        self._parquet_object_locators = parquet_object_locators
        self._timestamp_series_name = timestamp_series_name
        self._time_unit = time_unit
        self._avro_locator = avro_locator

    @builtins.property
    def units(self) -> Dict[str, str]:
        return self._units

    @builtins.property
    def parquet_object_locators(self) -> List["ingest_workflow_api_ObjectLocator"]:
        """Azure or S3-style blob locators of parquet files. Currently
only a single file is supported, the list type is used for future compatibility.
        """
        return self._parquet_object_locators

    @builtins.property
    def timestamp_series_name(self) -> str:
        """The name of the column in the generated parquet file that contains the timestamp.
        """
        return self._timestamp_series_name

    @builtins.property
    def time_unit(self) -> "ingest_workflow_api_TimeUnitSeconds":
        """The unit of time for the timestamp column. Can only be seconds.
        """
        return self._time_unit

    @builtins.property
    def avro_locator(self) -> Optional["ingest_workflow_api_ObjectLocator"]:
        """Azure or S3-style blob locator of avro file when avro processing is configured.
This field is only set when the workflow is configured to write avro stream.
        """
        return self._avro_locator


ingest_workflow_api_IngestDataflashResponse.__name__ = "IngestDataflashResponse"
ingest_workflow_api_IngestDataflashResponse.__qualname__ = "IngestDataflashResponse"
ingest_workflow_api_IngestDataflashResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_IngestMcapProtobufRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', ingest_workflow_api_ObjectLocator),
            'channels': ConjureFieldDefinition('channels', ingest_workflow_api_McapProtoChannels)
        }

    __slots__: List[str] = ['_locator', '_channels']

    def __init__(self, channels: "ingest_workflow_api_McapProtoChannels", locator: "ingest_workflow_api_ObjectLocator") -> None:
        self._locator = locator
        self._channels = channels

    @builtins.property
    def locator(self) -> "ingest_workflow_api_ObjectLocator":
        return self._locator

    @builtins.property
    def channels(self) -> "ingest_workflow_api_McapProtoChannels":
        return self._channels


ingest_workflow_api_IngestMcapProtobufRequest.__name__ = "IngestMcapProtobufRequest"
ingest_workflow_api_IngestMcapProtobufRequest.__qualname__ = "IngestMcapProtobufRequest"
ingest_workflow_api_IngestMcapProtobufRequest.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_IngestMcapProtobufResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_column_name': ConjureFieldDefinition('timestampColumnName', str),
            'parquet_object_locators': ConjureFieldDefinition('parquetObjectLocators', List[ingest_workflow_api_ObjectLocator])
        }

    __slots__: List[str] = ['_timestamp_column_name', '_parquet_object_locators']

    def __init__(self, parquet_object_locators: List["ingest_workflow_api_ObjectLocator"], timestamp_column_name: str) -> None:
        self._timestamp_column_name = timestamp_column_name
        self._parquet_object_locators = parquet_object_locators

    @builtins.property
    def timestamp_column_name(self) -> str:
        return self._timestamp_column_name

    @builtins.property
    def parquet_object_locators(self) -> List["ingest_workflow_api_ObjectLocator"]:
        """Azure or S3-style blob locators of parquet files. Currently
only a single file is supported, the list type is used for future compatibility.
        """
        return self._parquet_object_locators


ingest_workflow_api_IngestMcapProtobufResponse.__name__ = "IngestMcapProtobufResponse"
ingest_workflow_api_IngestMcapProtobufResponse.__qualname__ = "IngestMcapProtobufResponse"
ingest_workflow_api_IngestMcapProtobufResponse.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_McapProtoChannels(ConjureUnionType):
    _all: Optional["ingest_workflow_api_Empty"] = None
    _include_topics: Optional[List[str]] = None
    _exclude_topics: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'all': ConjureFieldDefinition('all', ingest_workflow_api_Empty),
            'include_topics': ConjureFieldDefinition('includeTopics', List[ingest_workflow_api_McapTopicName]),
            'exclude_topics': ConjureFieldDefinition('excludeTopics', List[ingest_workflow_api_McapTopicName])
        }

    def __init__(
            self,
            all: Optional["ingest_workflow_api_Empty"] = None,
            include_topics: Optional[List[str]] = None,
            exclude_topics: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (all is not None) + (include_topics is not None) + (exclude_topics is not None) != 1:
                raise ValueError('a union must contain a single member')

            if all is not None:
                self._all = all
                self._type = 'all'
            if include_topics is not None:
                self._include_topics = include_topics
                self._type = 'includeTopics'
            if exclude_topics is not None:
                self._exclude_topics = exclude_topics
                self._type = 'excludeTopics'

        elif type_of_union == 'all':
            if all is None:
                raise ValueError('a union value must not be None')
            self._all = all
            self._type = 'all'
        elif type_of_union == 'includeTopics':
            if include_topics is None:
                raise ValueError('a union value must not be None')
            self._include_topics = include_topics
            self._type = 'includeTopics'
        elif type_of_union == 'excludeTopics':
            if exclude_topics is None:
                raise ValueError('a union value must not be None')
            self._exclude_topics = exclude_topics
            self._type = 'excludeTopics'

    @builtins.property
    def all(self) -> Optional["ingest_workflow_api_Empty"]:
        return self._all

    @builtins.property
    def include_topics(self) -> Optional[List[str]]:
        return self._include_topics

    @builtins.property
    def exclude_topics(self) -> Optional[List[str]]:
        return self._exclude_topics

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, ingest_workflow_api_McapProtoChannelsVisitor):
            raise ValueError('{} is not an instance of ingest_workflow_api_McapProtoChannelsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'all' and self.all is not None:
            return visitor._all(self.all)
        if self._type == 'includeTopics' and self.include_topics is not None:
            return visitor._include_topics(self.include_topics)
        if self._type == 'excludeTopics' and self.exclude_topics is not None:
            return visitor._exclude_topics(self.exclude_topics)


ingest_workflow_api_McapProtoChannels.__name__ = "McapProtoChannels"
ingest_workflow_api_McapProtoChannels.__qualname__ = "McapProtoChannels"
ingest_workflow_api_McapProtoChannels.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_McapProtoChannelsVisitor:

    @abstractmethod
    def _all(self, all: "ingest_workflow_api_Empty") -> Any:
        pass

    @abstractmethod
    def _include_topics(self, include_topics: List[str]) -> Any:
        pass

    @abstractmethod
    def _exclude_topics(self, exclude_topics: List[str]) -> Any:
        pass


ingest_workflow_api_McapProtoChannelsVisitor.__name__ = "McapProtoChannelsVisitor"
ingest_workflow_api_McapProtoChannelsVisitor.__qualname__ = "McapProtoChannelsVisitor"
ingest_workflow_api_McapProtoChannelsVisitor.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_MultipartUploadDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'upload_id': ConjureFieldDefinition('uploadId', str),
            's3_handle': ConjureFieldDefinition('s3Handle', scout_catalog_S3Handle)
        }

    __slots__: List[str] = ['_upload_id', '_s3_handle']

    def __init__(self, s3_handle: "scout_catalog_S3Handle", upload_id: str) -> None:
        self._upload_id = upload_id
        self._s3_handle = s3_handle

    @builtins.property
    def upload_id(self) -> str:
        return self._upload_id

    @builtins.property
    def s3_handle(self) -> "scout_catalog_S3Handle":
        return self._s3_handle


ingest_workflow_api_MultipartUploadDetails.__name__ = "MultipartUploadDetails"
ingest_workflow_api_MultipartUploadDetails.__qualname__ = "MultipartUploadDetails"
ingest_workflow_api_MultipartUploadDetails.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_ObjectLocator(ConjureBeanType):
    """Locator for files in an object store. 
Clients are expected to have auth and origin/region configured independently.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', str),
            'object_name': ConjureFieldDefinition('objectName', str)
        }

    __slots__: List[str] = ['_bucket', '_object_name']

    def __init__(self, bucket: str, object_name: str) -> None:
        self._bucket = bucket
        self._object_name = object_name

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def object_name(self) -> str:
        return self._object_name


ingest_workflow_api_ObjectLocator.__name__ = "ObjectLocator"
ingest_workflow_api_ObjectLocator.__qualname__ = "ObjectLocator"
ingest_workflow_api_ObjectLocator.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_PresignedFileInput(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', ingest_workflow_api_PresignedUrl),
            'input': ConjureFieldDefinition('input', ingest_workflow_api_ValidatedFileInput)
        }

    __slots__: List[str] = ['_url', '_input']

    def __init__(self, input: "ingest_workflow_api_ValidatedFileInput", url: str) -> None:
        self._url = url
        self._input = input

    @builtins.property
    def url(self) -> str:
        return self._url

    @builtins.property
    def input(self) -> "ingest_workflow_api_ValidatedFileInput":
        return self._input


ingest_workflow_api_PresignedFileInput.__name__ = "PresignedFileInput"
ingest_workflow_api_PresignedFileInput.__qualname__ = "PresignedFileInput"
ingest_workflow_api_PresignedFileInput.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_TimeUnitSeconds(ConjureEnumType):

    SECONDS = 'SECONDS'
    '''SECONDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


ingest_workflow_api_TimeUnitSeconds.__name__ = "TimeUnitSeconds"
ingest_workflow_api_TimeUnitSeconds.__qualname__ = "TimeUnitSeconds"
ingest_workflow_api_TimeUnitSeconds.__module__ = "nominal_api.ingest_workflow_api"


class ingest_workflow_api_ValidatedFileInput(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'handle': ConjureFieldDefinition('handle', scout_catalog_S3Handle),
            'file_name': ConjureFieldDefinition('fileName', str),
            'env_var': ConjureFieldDefinition('envVar', str)
        }

    __slots__: List[str] = ['_handle', '_file_name', '_env_var']

    def __init__(self, env_var: str, file_name: str, handle: "scout_catalog_S3Handle") -> None:
        self._handle = handle
        self._file_name = file_name
        self._env_var = env_var

    @builtins.property
    def handle(self) -> "scout_catalog_S3Handle":
        """Path to the input file in S3.
        """
        return self._handle

    @builtins.property
    def file_name(self) -> str:
        """Name of the file that will be placed on disk.
        """
        return self._file_name

    @builtins.property
    def env_var(self) -> str:
        """Environment variable that will store the path to the file.
        """
        return self._env_var


ingest_workflow_api_ValidatedFileInput.__name__ = "ValidatedFileInput"
ingest_workflow_api_ValidatedFileInput.__qualname__ = "ValidatedFileInput"
ingest_workflow_api_ValidatedFileInput.__module__ = "nominal_api.ingest_workflow_api"


class module_BatchArchiveModulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[modules_api_ModuleRid])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List[str]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List[str]:
        return self._requests


module_BatchArchiveModulesRequest.__name__ = "BatchArchiveModulesRequest"
module_BatchArchiveModulesRequest.__qualname__ = "BatchArchiveModulesRequest"
module_BatchArchiveModulesRequest.__module__ = "nominal_api.module"


class module_BatchArchiveModulesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'archived_module_rids': ConjureFieldDefinition('archivedModuleRids', List[modules_api_ModuleRid])
        }

    __slots__: List[str] = ['_archived_module_rids']

    def __init__(self, archived_module_rids: List[str]) -> None:
        self._archived_module_rids = archived_module_rids

    @builtins.property
    def archived_module_rids(self) -> List[str]:
        return self._archived_module_rids


module_BatchArchiveModulesResponse.__name__ = "BatchArchiveModulesResponse"
module_BatchArchiveModulesResponse.__qualname__ = "BatchArchiveModulesResponse"
module_BatchArchiveModulesResponse.__module__ = "nominal_api.module"


class module_BatchGetModulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[module_RequestModuleRef])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["module_RequestModuleRef"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["module_RequestModuleRef"]:
        return self._requests


module_BatchGetModulesRequest.__name__ = "BatchGetModulesRequest"
module_BatchGetModulesRequest.__qualname__ = "BatchGetModulesRequest"
module_BatchGetModulesRequest.__module__ = "nominal_api.module"


class module_BatchUnarchiveModulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[modules_api_ModuleRid])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List[str]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List[str]:
        return self._requests


module_BatchUnarchiveModulesRequest.__name__ = "BatchUnarchiveModulesRequest"
module_BatchUnarchiveModulesRequest.__qualname__ = "BatchUnarchiveModulesRequest"
module_BatchUnarchiveModulesRequest.__module__ = "nominal_api.module"


class module_BatchUnarchiveModulesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unarchived_module_rids': ConjureFieldDefinition('unarchivedModuleRids', List[modules_api_ModuleRid])
        }

    __slots__: List[str] = ['_unarchived_module_rids']

    def __init__(self, unarchived_module_rids: List[str]) -> None:
        self._unarchived_module_rids = unarchived_module_rids

    @builtins.property
    def unarchived_module_rids(self) -> List[str]:
        return self._unarchived_module_rids


module_BatchUnarchiveModulesResponse.__name__ = "BatchUnarchiveModulesResponse"
module_BatchUnarchiveModulesResponse.__qualname__ = "BatchUnarchiveModulesResponse"
module_BatchUnarchiveModulesResponse.__module__ = "nominal_api.module"


class module_CreateModuleRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_name': ConjureFieldDefinition('apiName', str),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'definition': ConjureFieldDefinition('definition', module_ModuleVersionDefinition),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_api_name', '_title', '_description', '_definition', '_workspace']

    def __init__(self, api_name: str, definition: "module_ModuleVersionDefinition", description: str, title: str, workspace: Optional[str] = None) -> None:
        self._api_name = api_name
        self._title = title
        self._description = description
        self._definition = definition
        self._workspace = workspace

    @builtins.property
    def api_name(self) -> str:
        """The API name for the module. This string will uniquely identify the module within the organization.
        """
        return self._api_name

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def definition(self) -> "module_ModuleVersionDefinition":
        return self._definition

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace


module_CreateModuleRequest.__name__ = "CreateModuleRequest"
module_CreateModuleRequest.__qualname__ = "CreateModuleRequest"
module_CreateModuleRequest.__module__ = "nominal_api.module"


class module_Function(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'parameters': ConjureFieldDefinition('parameters', List[module_FunctionParameter]),
            'function_node': ConjureFieldDefinition('functionNode', module_FunctionNode),
            'is_exported': ConjureFieldDefinition('isExported', bool)
        }

    __slots__: List[str] = ['_name', '_description', '_parameters', '_function_node', '_is_exported']

    def __init__(self, description: str, function_node: "module_FunctionNode", is_exported: bool, name: str, parameters: List["module_FunctionParameter"]) -> None:
        self._name = name
        self._description = description
        self._parameters = parameters
        self._function_node = function_node
        self._is_exported = is_exported

    @builtins.property
    def name(self) -> str:
        """The name of the function. This should be unique to the function in the current module.
        """
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def parameters(self) -> List["module_FunctionParameter"]:
        return self._parameters

    @builtins.property
    def function_node(self) -> "module_FunctionNode":
        return self._function_node

    @builtins.property
    def is_exported(self) -> bool:
        return self._is_exported


module_Function.__name__ = "Function"
module_Function.__qualname__ = "Function"
module_Function.__module__ = "nominal_api.module"


class module_FunctionNode(ConjureUnionType):
    _enum: Optional["scout_compute_api_EnumSeries"] = None
    _numeric: Optional["scout_compute_api_NumericSeries"] = None
    _ranges: Optional["scout_compute_api_RangeSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeries),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeries),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries)
        }

    def __init__(
            self,
            enum: Optional["scout_compute_api_EnumSeries"] = None,
            numeric: Optional["scout_compute_api_NumericSeries"] = None,
            ranges: Optional["scout_compute_api_RangeSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum is not None) + (numeric is not None) + (ranges is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'

        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeries"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeries"]:
        return self._numeric

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_RangeSeries"]:
        return self._ranges

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, module_FunctionNodeVisitor):
            raise ValueError('{} is not an instance of module_FunctionNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)


module_FunctionNode.__name__ = "FunctionNode"
module_FunctionNode.__qualname__ = "FunctionNode"
module_FunctionNode.__module__ = "nominal_api.module"


class module_FunctionNodeVisitor:

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeries") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeries") -> Any:
        pass

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_RangeSeries") -> Any:
        pass


module_FunctionNodeVisitor.__name__ = "FunctionNodeVisitor"
module_FunctionNodeVisitor.__qualname__ = "FunctionNodeVisitor"
module_FunctionNodeVisitor.__module__ = "nominal_api.module"


class module_FunctionParameter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', module_ParameterName),
            'type': ConjureFieldDefinition('type', module_ValueType)
        }

    __slots__: List[str] = ['_name', '_type']

    def __init__(self, name: str, type: "module_ValueType") -> None:
        self._name = name
        self._type = type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def type(self) -> "module_ValueType":
        return self._type


module_FunctionParameter.__name__ = "FunctionParameter"
module_FunctionParameter.__qualname__ = "FunctionParameter"
module_FunctionParameter.__module__ = "nominal_api.module"


class module_LatestVersionStrategy(ConjureBeanType):
    """This strategy refers to the latest version of the module.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



module_LatestVersionStrategy.__name__ = "LatestVersionStrategy"
module_LatestVersionStrategy.__qualname__ = "LatestVersionStrategy"
module_LatestVersionStrategy.__module__ = "nominal_api.module"


class module_Module(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', module_ModuleMetadata),
            'version_metadata': ConjureFieldDefinition('versionMetadata', module_ModuleVersionMetadata),
            'definition': ConjureFieldDefinition('definition', module_ModuleVersionDefinition)
        }

    __slots__: List[str] = ['_metadata', '_version_metadata', '_definition']

    def __init__(self, definition: "module_ModuleVersionDefinition", metadata: "module_ModuleMetadata", version_metadata: "module_ModuleVersionMetadata") -> None:
        self._metadata = metadata
        self._version_metadata = version_metadata
        self._definition = definition

    @builtins.property
    def metadata(self) -> "module_ModuleMetadata":
        return self._metadata

    @builtins.property
    def version_metadata(self) -> "module_ModuleVersionMetadata":
        return self._version_metadata

    @builtins.property
    def definition(self) -> "module_ModuleVersionDefinition":
        return self._definition


module_Module.__name__ = "Module"
module_Module.__qualname__ = "Module"
module_Module.__module__ = "nominal_api.module"


class module_ModuleMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', modules_api_ModuleRid),
            'api_name': ConjureFieldDefinition('apiName', str),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'archived_at': ConjureFieldDefinition('archivedAt', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_rid', '_api_name', '_title', '_description', '_created_by', '_created_at', '_archived_at']

    def __init__(self, api_name: str, created_at: str, created_by: str, description: str, rid: str, title: str, archived_at: Optional[str] = None) -> None:
        self._rid = rid
        self._api_name = api_name
        self._title = title
        self._description = description
        self._created_by = created_by
        self._created_at = created_at
        self._archived_at = archived_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def api_name(self) -> str:
        """This uniquely identifies the module within the org.
Note that this cannot be changed after creation.
        """
        return self._api_name

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def archived_at(self) -> Optional[str]:
        """The time at which the module was archived. Unset if the module is not archived.
        """
        return self._archived_at


module_ModuleMetadata.__name__ = "ModuleMetadata"
module_ModuleMetadata.__qualname__ = "ModuleMetadata"
module_ModuleMetadata.__module__ = "nominal_api.module"


class module_ModuleRef(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', modules_api_ModuleRid),
            'api_name': ConjureFieldDefinition('apiName', str),
            'version': ConjureFieldDefinition('version', module_ModuleVersion)
        }

    __slots__: List[str] = ['_rid', '_api_name', '_version']

    def __init__(self, api_name: str, rid: str, version: str) -> None:
        self._rid = rid
        self._api_name = api_name
        self._version = version

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def api_name(self) -> str:
        return self._api_name

    @builtins.property
    def version(self) -> str:
        return self._version


module_ModuleRef.__name__ = "ModuleRef"
module_ModuleRef.__qualname__ = "ModuleRef"
module_ModuleRef.__module__ = "nominal_api.module"


class module_ModuleService(Service):
    """Modules define collections of compute logic that can be shared and used across different contexts.
The Modules Service provides the API for managing these collections of functions.
    """

    def create_module(self, auth_header: str, request: "module_CreateModuleRequest") -> "module_Module":
        """Create a new module.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_Module, self._return_none_for_unknown_union_types)

    def update_module(self, auth_header: str, module_rid: str, request: "module_UpdateModuleRequest") -> "module_Module":
        """Update an existing module.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'moduleRid': quote(str(_conjure_encoder.default(module_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module/{moduleRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_Module, self._return_none_for_unknown_union_types)

    def batch_get_modules(self, auth_header: str, request: "module_BatchGetModulesRequest") -> List["module_Module"]:
        """Get a list of modules by their RIDs and version specifiers if provided.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[module_Module], self._return_none_for_unknown_union_types)

    def search_modules(self, auth_header: str, request: "module_SearchModulesRequest") -> "module_SearchModulesResponse":
        """Search for modules.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_SearchModulesResponse, self._return_none_for_unknown_union_types)

    def batch_archive_modules(self, auth_header: str, request: "module_BatchArchiveModulesRequest") -> "module_BatchArchiveModulesResponse":
        """Archive a set of modules.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_BatchArchiveModulesResponse, self._return_none_for_unknown_union_types)

    def batch_unarchive_modules(self, auth_header: str, request: "module_BatchUnarchiveModulesRequest") -> "module_BatchUnarchiveModulesResponse":
        """Unarchive a set of modules.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/module/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_BatchUnarchiveModulesResponse, self._return_none_for_unknown_union_types)


module_ModuleService.__name__ = "ModuleService"
module_ModuleService.__qualname__ = "ModuleService"
module_ModuleService.__module__ = "nominal_api.module"


class module_ModuleSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', module_ModuleMetadata),
            'latest': ConjureFieldDefinition('latest', module_ModuleVersionMetadata)
        }

    __slots__: List[str] = ['_metadata', '_latest']

    def __init__(self, latest: "module_ModuleVersionMetadata", metadata: "module_ModuleMetadata") -> None:
        self._metadata = metadata
        self._latest = latest

    @builtins.property
    def metadata(self) -> "module_ModuleMetadata":
        return self._metadata

    @builtins.property
    def latest(self) -> "module_ModuleVersionMetadata":
        return self._latest


module_ModuleSummary.__name__ = "ModuleSummary"
module_ModuleSummary.__qualname__ = "ModuleSummary"
module_ModuleSummary.__module__ = "nominal_api.module"


class module_ModuleVersionDefinition(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'functions': ConjureFieldDefinition('functions', List[module_Function])
        }

    __slots__: List[str] = ['_functions']

    def __init__(self, functions: List["module_Function"]) -> None:
        self._functions = functions

    @builtins.property
    def functions(self) -> List["module_Function"]:
        """The list of functions that resolve to derived series that appear in channel search after applying to an
asset. Limited to 100.
        """
        return self._functions


module_ModuleVersionDefinition.__name__ = "ModuleVersionDefinition"
module_ModuleVersionDefinition.__qualname__ = "ModuleVersionDefinition"
module_ModuleVersionDefinition.__module__ = "nominal_api.module"


class module_ModuleVersionMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'version': ConjureFieldDefinition('version', module_ModuleVersion)
        }

    __slots__: List[str] = ['_created_by', '_created_at', '_version']

    def __init__(self, created_at: str, created_by: str, version: str) -> None:
        self._created_by = created_by
        self._created_at = created_at
        self._version = version

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def version(self) -> str:
        return self._version


module_ModuleVersionMetadata.__name__ = "ModuleVersionMetadata"
module_ModuleVersionMetadata.__qualname__ = "ModuleVersionMetadata"
module_ModuleVersionMetadata.__module__ = "nominal_api.module"


class module_PinnedVersionStrategy(ConjureBeanType):
    """This strategy refers to a specific version of the module.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'version': ConjureFieldDefinition('version', module_ModuleVersion)
        }

    __slots__: List[str] = ['_version']

    def __init__(self, version: str) -> None:
        self._version = version

    @builtins.property
    def version(self) -> str:
        return self._version


module_PinnedVersionStrategy.__name__ = "PinnedVersionStrategy"
module_PinnedVersionStrategy.__qualname__ = "PinnedVersionStrategy"
module_PinnedVersionStrategy.__module__ = "nominal_api.module"


class module_RequestModuleNameRef(ConjureBeanType):
    """This is used to refer to modules in requests by name.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_name': ConjureFieldDefinition('apiName', str),
            'version_strategy': ConjureFieldDefinition('versionStrategy', module_VersionStrategy)
        }

    __slots__: List[str] = ['_api_name', '_version_strategy']

    def __init__(self, api_name: str, version_strategy: "module_VersionStrategy") -> None:
        self._api_name = api_name
        self._version_strategy = version_strategy

    @builtins.property
    def api_name(self) -> str:
        return self._api_name

    @builtins.property
    def version_strategy(self) -> "module_VersionStrategy":
        return self._version_strategy


module_RequestModuleNameRef.__name__ = "RequestModuleNameRef"
module_RequestModuleNameRef.__qualname__ = "RequestModuleNameRef"
module_RequestModuleNameRef.__module__ = "nominal_api.module"


class module_RequestModuleRef(ConjureUnionType):
    """Request reference to a module. This is used to refer to modules in requests.
    """
    _name: Optional["module_RequestModuleNameRef"] = None
    _rid: Optional["module_RequestModuleRidRef"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', module_RequestModuleNameRef),
            'rid': ConjureFieldDefinition('rid', module_RequestModuleRidRef)
        }

    def __init__(
            self,
            name: Optional["module_RequestModuleNameRef"] = None,
            rid: Optional["module_RequestModuleRidRef"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (name is not None) + (rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if name is not None:
                self._name = name
                self._type = 'name'
            if rid is not None:
                self._rid = rid
                self._type = 'rid'

        elif type_of_union == 'name':
            if name is None:
                raise ValueError('a union value must not be None')
            self._name = name
            self._type = 'name'
        elif type_of_union == 'rid':
            if rid is None:
                raise ValueError('a union value must not be None')
            self._rid = rid
            self._type = 'rid'

    @builtins.property
    def name(self) -> Optional["module_RequestModuleNameRef"]:
        return self._name

    @builtins.property
    def rid(self) -> Optional["module_RequestModuleRidRef"]:
        return self._rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, module_RequestModuleRefVisitor):
            raise ValueError('{} is not an instance of module_RequestModuleRefVisitor'.format(visitor.__class__.__name__))
        if self._type == 'name' and self.name is not None:
            return visitor._name(self.name)
        if self._type == 'rid' and self.rid is not None:
            return visitor._rid(self.rid)


module_RequestModuleRef.__name__ = "RequestModuleRef"
module_RequestModuleRef.__qualname__ = "RequestModuleRef"
module_RequestModuleRef.__module__ = "nominal_api.module"


class module_RequestModuleRefVisitor:

    @abstractmethod
    def _name(self, name: "module_RequestModuleNameRef") -> Any:
        pass

    @abstractmethod
    def _rid(self, rid: "module_RequestModuleRidRef") -> Any:
        pass


module_RequestModuleRefVisitor.__name__ = "RequestModuleRefVisitor"
module_RequestModuleRefVisitor.__qualname__ = "RequestModuleRefVisitor"
module_RequestModuleRefVisitor.__module__ = "nominal_api.module"


class module_RequestModuleRidRef(ConjureBeanType):
    """This is used to refer to modules in requests by rid.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', modules_api_ModuleRid),
            'version_strategy': ConjureFieldDefinition('versionStrategy', module_VersionStrategy)
        }

    __slots__: List[str] = ['_rid', '_version_strategy']

    def __init__(self, rid: str, version_strategy: "module_VersionStrategy") -> None:
        self._rid = rid
        self._version_strategy = version_strategy

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def version_strategy(self) -> "module_VersionStrategy":
        return self._version_strategy


module_RequestModuleRidRef.__name__ = "RequestModuleRidRef"
module_RequestModuleRidRef.__qualname__ = "RequestModuleRidRef"
module_RequestModuleRidRef.__module__ = "nominal_api.module"


class module_SearchModulesQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _created_by: Optional[str] = None
    _last_updated_by: Optional[str] = None
    _workspace: Optional[str] = None
    _and_: Optional[List["module_SearchModulesQuery"]] = None
    _or_: Optional[List["module_SearchModulesQuery"]] = None
    _not_: Optional["module_SearchModulesQuery"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'last_updated_by': ConjureFieldDefinition('lastUpdatedBy', scout_rids_api_UserRid),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'and_': ConjureFieldDefinition('and', List[module_SearchModulesQuery]),
            'or_': ConjureFieldDefinition('or', List[module_SearchModulesQuery]),
            'not_': ConjureFieldDefinition('not', module_SearchModulesQuery)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            created_by: Optional[str] = None,
            last_updated_by: Optional[str] = None,
            workspace: Optional[str] = None,
            and_: Optional[List["module_SearchModulesQuery"]] = None,
            or_: Optional[List["module_SearchModulesQuery"]] = None,
            not_: Optional["module_SearchModulesQuery"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (created_by is not None) + (last_updated_by is not None) + (workspace is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if last_updated_by is not None:
                self._last_updated_by = last_updated_by
                self._type = 'lastUpdatedBy'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'lastUpdatedBy':
            if last_updated_by is None:
                raise ValueError('a union value must not be None')
            self._last_updated_by = last_updated_by
            self._type = 'lastUpdatedBy'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def last_updated_by(self) -> Optional[str]:
        return self._last_updated_by

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def and_(self) -> Optional[List["module_SearchModulesQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["module_SearchModulesQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["module_SearchModulesQuery"]:
        return self._not_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, module_SearchModulesQueryVisitor):
            raise ValueError('{} is not an instance of module_SearchModulesQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'lastUpdatedBy' and self.last_updated_by is not None:
            return visitor._last_updated_by(self.last_updated_by)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)


module_SearchModulesQuery.__name__ = "SearchModulesQuery"
module_SearchModulesQuery.__qualname__ = "SearchModulesQuery"
module_SearchModulesQuery.__module__ = "nominal_api.module"


class module_SearchModulesQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: str) -> Any:
        pass

    @abstractmethod
    def _last_updated_by(self, last_updated_by: str) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["module_SearchModulesQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["module_SearchModulesQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "module_SearchModulesQuery") -> Any:
        pass


module_SearchModulesQueryVisitor.__name__ = "SearchModulesQueryVisitor"
module_SearchModulesQueryVisitor.__qualname__ = "SearchModulesQueryVisitor"
module_SearchModulesQueryVisitor.__module__ = "nominal_api.module"


class module_SearchModulesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', module_SearchModulesQuery),
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[module_SearchModulesSortOptions]),
            'page_size': ConjureFieldDefinition('pageSize', int),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_sort', '_page_size', '_next_page_token', '_archived_statuses']

    def __init__(self, page_size: int, query: "module_SearchModulesQuery", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, sort: Optional["module_SearchModulesSortOptions"] = None) -> None:
        self._query = query
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "module_SearchModulesQuery":
        return self._query

    @builtins.property
    def sort(self) -> Optional["module_SearchModulesSortOptions"]:
        return self._sort

    @builtins.property
    def page_size(self) -> int:
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived modules in search.
        """
        return self._archived_statuses


module_SearchModulesRequest.__name__ = "SearchModulesRequest"
module_SearchModulesRequest.__qualname__ = "SearchModulesRequest"
module_SearchModulesRequest.__module__ = "nominal_api.module"


class module_SearchModulesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[module_ModuleSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["module_ModuleSummary"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["module_ModuleSummary"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


module_SearchModulesResponse.__name__ = "SearchModulesResponse"
module_SearchModulesResponse.__qualname__ = "SearchModulesResponse"
module_SearchModulesResponse.__module__ = "nominal_api.module"


class module_SearchModulesSortField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    LAST_UPDATED_AT = 'LAST_UPDATED_AT'
    '''LAST_UPDATED_AT'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    ARCHIVED_AT = 'ARCHIVED_AT'
    '''ARCHIVED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


module_SearchModulesSortField.__name__ = "SearchModulesSortField"
module_SearchModulesSortField.__qualname__ = "SearchModulesSortField"
module_SearchModulesSortField.__module__ = "nominal_api.module"


class module_SearchModulesSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', module_SearchModulesSortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "module_SearchModulesSortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "module_SearchModulesSortField":
        return self._field


module_SearchModulesSortOptions.__name__ = "SearchModulesSortOptions"
module_SearchModulesSortOptions.__qualname__ = "SearchModulesSortOptions"
module_SearchModulesSortOptions.__module__ = "nominal_api.module"


class module_UpdateModuleRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'definition': ConjureFieldDefinition('definition', module_ModuleVersionDefinition)
        }

    __slots__: List[str] = ['_title', '_description', '_definition']

    def __init__(self, definition: "module_ModuleVersionDefinition", description: str, title: str) -> None:
        self._title = title
        self._description = description
        self._definition = definition

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def definition(self) -> "module_ModuleVersionDefinition":
        return self._definition


module_UpdateModuleRequest.__name__ = "UpdateModuleRequest"
module_UpdateModuleRequest.__qualname__ = "UpdateModuleRequest"
module_UpdateModuleRequest.__module__ = "nominal_api.module"


class module_ValueType(ConjureEnumType):

    NUMERIC_SERIES = 'NUMERIC_SERIES'
    '''NUMERIC_SERIES'''
    ENUM_SERIES = 'ENUM_SERIES'
    '''ENUM_SERIES'''
    RANGES_SERIES = 'RANGES_SERIES'
    '''RANGES_SERIES'''
    STRING_CONSTANT = 'STRING_CONSTANT'
    '''STRING_CONSTANT'''
    DURATION_CONSTANT = 'DURATION_CONSTANT'
    '''DURATION_CONSTANT'''
    TIMESTAMP_CONSTANT = 'TIMESTAMP_CONSTANT'
    '''TIMESTAMP_CONSTANT'''
    INTEGER_CONSTANT = 'INTEGER_CONSTANT'
    '''INTEGER_CONSTANT'''
    DOUBLE_CONSTANT = 'DOUBLE_CONSTANT'
    '''DOUBLE_CONSTANT'''
    ASSET_RID = 'ASSET_RID'
    '''ASSET_RID'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


module_ValueType.__name__ = "ValueType"
module_ValueType.__qualname__ = "ValueType"
module_ValueType.__module__ = "nominal_api.module"


class module_VersionStrategy(ConjureUnionType):
    _pinned: Optional["module_PinnedVersionStrategy"] = None
    _latest: Optional["module_LatestVersionStrategy"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pinned': ConjureFieldDefinition('pinned', module_PinnedVersionStrategy),
            'latest': ConjureFieldDefinition('latest', module_LatestVersionStrategy)
        }

    def __init__(
            self,
            pinned: Optional["module_PinnedVersionStrategy"] = None,
            latest: Optional["module_LatestVersionStrategy"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pinned is not None) + (latest is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pinned is not None:
                self._pinned = pinned
                self._type = 'pinned'
            if latest is not None:
                self._latest = latest
                self._type = 'latest'

        elif type_of_union == 'pinned':
            if pinned is None:
                raise ValueError('a union value must not be None')
            self._pinned = pinned
            self._type = 'pinned'
        elif type_of_union == 'latest':
            if latest is None:
                raise ValueError('a union value must not be None')
            self._latest = latest
            self._type = 'latest'

    @builtins.property
    def pinned(self) -> Optional["module_PinnedVersionStrategy"]:
        return self._pinned

    @builtins.property
    def latest(self) -> Optional["module_LatestVersionStrategy"]:
        return self._latest

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, module_VersionStrategyVisitor):
            raise ValueError('{} is not an instance of module_VersionStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pinned' and self.pinned is not None:
            return visitor._pinned(self.pinned)
        if self._type == 'latest' and self.latest is not None:
            return visitor._latest(self.latest)


module_VersionStrategy.__name__ = "VersionStrategy"
module_VersionStrategy.__qualname__ = "VersionStrategy"
module_VersionStrategy.__module__ = "nominal_api.module"


class module_VersionStrategyVisitor:

    @abstractmethod
    def _pinned(self, pinned: "module_PinnedVersionStrategy") -> Any:
        pass

    @abstractmethod
    def _latest(self, latest: "module_LatestVersionStrategy") -> Any:
        pass


module_VersionStrategyVisitor.__name__ = "VersionStrategyVisitor"
module_VersionStrategyVisitor.__qualname__ = "VersionStrategyVisitor"
module_VersionStrategyVisitor.__module__ = "nominal_api.module"


class module_internal_BatchGetUnresolvedModuleDefinitionsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[module_RequestModuleNameRef])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["module_RequestModuleNameRef"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["module_RequestModuleNameRef"]:
        return self._requests


module_internal_BatchGetUnresolvedModuleDefinitionsRequest.__name__ = "BatchGetUnresolvedModuleDefinitionsRequest"
module_internal_BatchGetUnresolvedModuleDefinitionsRequest.__qualname__ = "BatchGetUnresolvedModuleDefinitionsRequest"
module_internal_BatchGetUnresolvedModuleDefinitionsRequest.__module__ = "nominal_api.module_internal"


class module_internal_BatchGetUnresolvedModuleDefinitionsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[module_internal_ModuleComputeDefinition])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["module_internal_ModuleComputeDefinition"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["module_internal_ModuleComputeDefinition"]:
        return self._results


module_internal_BatchGetUnresolvedModuleDefinitionsResponse.__name__ = "BatchGetUnresolvedModuleDefinitionsResponse"
module_internal_BatchGetUnresolvedModuleDefinitionsResponse.__qualname__ = "BatchGetUnresolvedModuleDefinitionsResponse"
module_internal_BatchGetUnresolvedModuleDefinitionsResponse.__module__ = "nominal_api.module_internal"


class module_internal_InternalModuleService(Service):
    """This service provides internal APIs related to modules.
    """

    def batch_get_unresolved_module_definition(self, auth_header: str, request: "module_internal_BatchGetUnresolvedModuleDefinitionsRequest") -> "module_internal_BatchGetUnresolvedModuleDefinitionsResponse":
        """Returns the module definition for the given module reference.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/scout/v2/module/unresolved-module/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), module_internal_BatchGetUnresolvedModuleDefinitionsResponse, self._return_none_for_unknown_union_types)


module_internal_InternalModuleService.__name__ = "InternalModuleService"
module_internal_InternalModuleService.__qualname__ = "InternalModuleService"
module_internal_InternalModuleService.__module__ = "nominal_api.module_internal"


class module_internal_ModuleComputeDefinition(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'module_api_name': ConjureFieldDefinition('moduleApiName', str),
            'module_rid': ConjureFieldDefinition('moduleRid', modules_api_ModuleRid),
            'version': ConjureFieldDefinition('version', module_ModuleVersion),
            'functions': ConjureFieldDefinition('functions', List[module_Function])
        }

    __slots__: List[str] = ['_module_api_name', '_module_rid', '_version', '_functions']

    def __init__(self, functions: List["module_Function"], module_api_name: str, module_rid: str, version: str) -> None:
        self._module_api_name = module_api_name
        self._module_rid = module_rid
        self._version = version
        self._functions = functions

    @builtins.property
    def module_api_name(self) -> str:
        return self._module_api_name

    @builtins.property
    def module_rid(self) -> str:
        return self._module_rid

    @builtins.property
    def version(self) -> str:
        return self._version

    @builtins.property
    def functions(self) -> List["module_Function"]:
        return self._functions


module_internal_ModuleComputeDefinition.__name__ = "ModuleComputeDefinition"
module_internal_ModuleComputeDefinition.__qualname__ = "ModuleComputeDefinition"
module_internal_ModuleComputeDefinition.__module__ = "nominal_api.module_internal"


class persistent_compute_api_AppendOnlyConfig(ConjureBeanType):
    """Defines the append results from the websocket.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'decimate_results': ConjureFieldDefinition('decimateResults', bool)
        }

    __slots__: List[str] = ['_decimate_results']

    def __init__(self, decimate_results: bool) -> None:
        self._decimate_results = decimate_results

    @builtins.property
    def decimate_results(self) -> bool:
        """Specifies whether the returned results should be decimated.
If this is false, the client may receive a `SubscriptionCreationError` if the data rate is too high
and responses must be decimated.
        """
        return self._decimate_results


persistent_compute_api_AppendOnlyConfig.__name__ = "AppendOnlyConfig"
persistent_compute_api_AppendOnlyConfig.__qualname__ = "AppendOnlyConfig"
persistent_compute_api_AppendOnlyConfig.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_AppendResult(ConjureBeanType):
    """An append result won't cover the full `StreamingComputeNodeRequest#windowWidth` but rather just a smaller 
window. The end of the window that the append covers is guaranteed to be later than previously sent results.
The start, however, can and most likely will overlap with previous results. That allows us to support 
out-of-order points. The client will have to merge this new `AppendResult` with previous results.
Example of time windows that might be covered by results for a subscription: 
We send a full result for window [0s, 120s] followed by an append result for [116s, 121s] and another 
append result for [117s, 122s].
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'result': ConjureFieldDefinition('result', persistent_compute_api_ComputeNodeAppendResponse)
        }

    __slots__: List[str] = ['_start', '_end', '_result']

    def __init__(self, end: "api_Timestamp", result: "persistent_compute_api_ComputeNodeAppendResponse", start: "api_Timestamp") -> None:
        self._start = start
        self._end = end
        self._result = result

    @builtins.property
    def start(self) -> "api_Timestamp":
        """The start of the time range that the append result covers
        """
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        """The end of the time range that the append result covers
        """
        return self._end

    @builtins.property
    def result(self) -> "persistent_compute_api_ComputeNodeAppendResponse":
        return self._result


persistent_compute_api_AppendResult.__name__ = "AppendResult"
persistent_compute_api_AppendResult.__qualname__ = "AppendResult"
persistent_compute_api_AppendResult.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ClientMessage(ConjureUnionType):
    _subscribe: Optional[Dict[str, "persistent_compute_api_StreamingComputeNodeSubscription"]] = None
    _unsubscribe: Optional[List[str]] = None
    _ping: Optional["persistent_compute_api_Ping"] = None
    _pong: Optional["persistent_compute_api_Pong"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'subscribe': ConjureFieldDefinition('subscribe', Dict[persistent_compute_api_SubscriptionId, persistent_compute_api_StreamingComputeNodeSubscription]),
            'unsubscribe': ConjureFieldDefinition('unsubscribe', List[persistent_compute_api_SubscriptionId]),
            'ping': ConjureFieldDefinition('ping', persistent_compute_api_Ping),
            'pong': ConjureFieldDefinition('pong', persistent_compute_api_Pong)
        }

    def __init__(
            self,
            subscribe: Optional[Dict[str, "persistent_compute_api_StreamingComputeNodeSubscription"]] = None,
            unsubscribe: Optional[List[str]] = None,
            ping: Optional["persistent_compute_api_Ping"] = None,
            pong: Optional["persistent_compute_api_Pong"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (subscribe is not None) + (unsubscribe is not None) + (ping is not None) + (pong is not None) != 1:
                raise ValueError('a union must contain a single member')

            if subscribe is not None:
                self._subscribe = subscribe
                self._type = 'subscribe'
            if unsubscribe is not None:
                self._unsubscribe = unsubscribe
                self._type = 'unsubscribe'
            if ping is not None:
                self._ping = ping
                self._type = 'ping'
            if pong is not None:
                self._pong = pong
                self._type = 'pong'

        elif type_of_union == 'subscribe':
            if subscribe is None:
                raise ValueError('a union value must not be None')
            self._subscribe = subscribe
            self._type = 'subscribe'
        elif type_of_union == 'unsubscribe':
            if unsubscribe is None:
                raise ValueError('a union value must not be None')
            self._unsubscribe = unsubscribe
            self._type = 'unsubscribe'
        elif type_of_union == 'ping':
            if ping is None:
                raise ValueError('a union value must not be None')
            self._ping = ping
            self._type = 'ping'
        elif type_of_union == 'pong':
            if pong is None:
                raise ValueError('a union value must not be None')
            self._pong = pong
            self._type = 'pong'

    @builtins.property
    def subscribe(self) -> Optional[Dict[str, "persistent_compute_api_StreamingComputeNodeSubscription"]]:
        """Subscribes to all of the given `StreamingComputeNodeSubscription`s. For identifying the subscriptions and
their results a `SubscriptionId` has to be passed, which should be a unique identifier.
A `ServerMessage::subscriptionCreation` will be sent back for each subscription which shows whether the 
subscription was successfully created. If it was, updated results for the subscription will be  sent 
periodically via `ServerMessage::subscriptionUpdate`.
        """
        return self._subscribe

    @builtins.property
    def unsubscribe(self) -> Optional[List[str]]:
        return self._unsubscribe

    @builtins.property
    def ping(self) -> Optional["persistent_compute_api_Ping"]:
        return self._ping

    @builtins.property
    def pong(self) -> Optional["persistent_compute_api_Pong"]:
        return self._pong

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_ClientMessageVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_ClientMessageVisitor'.format(visitor.__class__.__name__))
        if self._type == 'subscribe' and self.subscribe is not None:
            return visitor._subscribe(self.subscribe)
        if self._type == 'unsubscribe' and self.unsubscribe is not None:
            return visitor._unsubscribe(self.unsubscribe)
        if self._type == 'ping' and self.ping is not None:
            return visitor._ping(self.ping)
        if self._type == 'pong' and self.pong is not None:
            return visitor._pong(self.pong)


persistent_compute_api_ClientMessage.__name__ = "ClientMessage"
persistent_compute_api_ClientMessage.__qualname__ = "ClientMessage"
persistent_compute_api_ClientMessage.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ClientMessageVisitor:

    @abstractmethod
    def _subscribe(self, subscribe: Dict[str, "persistent_compute_api_StreamingComputeNodeSubscription"]) -> Any:
        pass

    @abstractmethod
    def _unsubscribe(self, unsubscribe: List[str]) -> Any:
        pass

    @abstractmethod
    def _ping(self, ping: "persistent_compute_api_Ping") -> Any:
        pass

    @abstractmethod
    def _pong(self, pong: "persistent_compute_api_Pong") -> Any:
        pass


persistent_compute_api_ClientMessageVisitor.__name__ = "ClientMessageVisitor"
persistent_compute_api_ClientMessageVisitor.__qualname__ = "ClientMessageVisitor"
persistent_compute_api_ClientMessageVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ClientMessageError(ConjureBeanType):
    """This will be sent if there is an error processing a `ClientMessage`. Note: This won't automatically close 
the connection. The client can continue sending `ClientMessage`s after receiving this error.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error': ConjureFieldDefinition('error', api_SerializableError)
        }

    __slots__: List[str] = ['_error']

    def __init__(self, error: "api_SerializableError") -> None:
        self._error = error

    @builtins.property
    def error(self) -> "api_SerializableError":
        return self._error


persistent_compute_api_ClientMessageError.__name__ = "ClientMessageError"
persistent_compute_api_ClientMessageError.__qualname__ = "ClientMessageError"
persistent_compute_api_ClientMessageError.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ComputeNodeAppendResponse(ConjureUnionType):
    """These cover the subset of the union type in `ComputeNodeResponse` for which we support append results.
Append results will have the same subtype as the previous full result for the same `SubscriptionId`. 
If the subtype were to change (e.g., we start doing bucketing because data frequency increased) we will send 
a new full result with that new type. The results will also have the same units as the previous `FullResult`.
Notably, we currently don't support appends for bucketed results as merging buckets is not trivial, especially 
when accounting for out-of-order points.
    """
    _range: Optional[List["scout_compute_api_Range"]] = None
    _enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None
    _numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None
    _single_point: Optional[Optional["scout_compute_api_SinglePoint"]] = None
    _log_point: Optional[Optional["scout_compute_api_LogPoint"]] = None
    _range_value: Optional[Optional["scout_compute_api_Range"]] = None
    _numeric: Optional["scout_compute_api_NumericPlot"] = None
    _enum: Optional["scout_compute_api_EnumPlot"] = None
    _bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None
    _bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None
    _arrow_numeric: Optional["scout_compute_api_ArrowNumericPlot"] = None
    _arrow_enum: Optional["scout_compute_api_ArrowEnumPlot"] = None
    _arrow_bucketed_numeric: Optional["scout_compute_api_ArrowBucketedNumericPlot"] = None
    _arrow_bucketed_enum: Optional["scout_compute_api_ArrowBucketedEnumPlot"] = None
    _grouped: Optional["persistent_compute_api_GroupedComputeNodeAppendResponses"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range': ConjureFieldDefinition('range', List[scout_compute_api_Range]),
            'enum_point': ConjureFieldDefinition('enumPoint', OptionalTypeWrapper[scout_compute_api_EnumPoint]),
            'numeric_point': ConjureFieldDefinition('numericPoint', OptionalTypeWrapper[scout_compute_api_NumericPoint]),
            'single_point': ConjureFieldDefinition('singlePoint', OptionalTypeWrapper[scout_compute_api_SinglePoint]),
            'log_point': ConjureFieldDefinition('logPoint', OptionalTypeWrapper[scout_compute_api_LogPoint]),
            'range_value': ConjureFieldDefinition('rangeValue', OptionalTypeWrapper[scout_compute_api_Range]),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericPlot),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumPlot),
            'bucketed_numeric': ConjureFieldDefinition('bucketedNumeric', scout_compute_api_BucketedNumericPlot),
            'bucketed_enum': ConjureFieldDefinition('bucketedEnum', scout_compute_api_BucketedEnumPlot),
            'arrow_numeric': ConjureFieldDefinition('arrowNumeric', scout_compute_api_ArrowNumericPlot),
            'arrow_enum': ConjureFieldDefinition('arrowEnum', scout_compute_api_ArrowEnumPlot),
            'arrow_bucketed_numeric': ConjureFieldDefinition('arrowBucketedNumeric', scout_compute_api_ArrowBucketedNumericPlot),
            'arrow_bucketed_enum': ConjureFieldDefinition('arrowBucketedEnum', scout_compute_api_ArrowBucketedEnumPlot),
            'grouped': ConjureFieldDefinition('grouped', persistent_compute_api_GroupedComputeNodeAppendResponses)
        }

    def __init__(
            self,
            range: Optional[List["scout_compute_api_Range"]] = None,
            enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None,
            numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None,
            single_point: Optional[Optional["scout_compute_api_SinglePoint"]] = None,
            log_point: Optional[Optional["scout_compute_api_LogPoint"]] = None,
            range_value: Optional[Optional["scout_compute_api_Range"]] = None,
            numeric: Optional["scout_compute_api_NumericPlot"] = None,
            enum: Optional["scout_compute_api_EnumPlot"] = None,
            bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None,
            bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None,
            arrow_numeric: Optional["scout_compute_api_ArrowNumericPlot"] = None,
            arrow_enum: Optional["scout_compute_api_ArrowEnumPlot"] = None,
            arrow_bucketed_numeric: Optional["scout_compute_api_ArrowBucketedNumericPlot"] = None,
            arrow_bucketed_enum: Optional["scout_compute_api_ArrowBucketedEnumPlot"] = None,
            grouped: Optional["persistent_compute_api_GroupedComputeNodeAppendResponses"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (range is not None) + (enum_point is not None) + (numeric_point is not None) + (single_point is not None) + (log_point is not None) + (range_value is not None) + (numeric is not None) + (enum is not None) + (bucketed_numeric is not None) + (bucketed_enum is not None) + (arrow_numeric is not None) + (arrow_enum is not None) + (arrow_bucketed_numeric is not None) + (arrow_bucketed_enum is not None) + (grouped is not None) != 1:
                raise ValueError('a union must contain a single member')

            if range is not None:
                self._range = range
                self._type = 'range'
            if enum_point is not None:
                self._enum_point = enum_point
                self._type = 'enumPoint'
            if numeric_point is not None:
                self._numeric_point = numeric_point
                self._type = 'numericPoint'
            if single_point is not None:
                self._single_point = single_point
                self._type = 'singlePoint'
            if log_point is not None:
                self._log_point = log_point
                self._type = 'logPoint'
            if range_value is not None:
                self._range_value = range_value
                self._type = 'rangeValue'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if bucketed_numeric is not None:
                self._bucketed_numeric = bucketed_numeric
                self._type = 'bucketedNumeric'
            if bucketed_enum is not None:
                self._bucketed_enum = bucketed_enum
                self._type = 'bucketedEnum'
            if arrow_numeric is not None:
                self._arrow_numeric = arrow_numeric
                self._type = 'arrowNumeric'
            if arrow_enum is not None:
                self._arrow_enum = arrow_enum
                self._type = 'arrowEnum'
            if arrow_bucketed_numeric is not None:
                self._arrow_bucketed_numeric = arrow_bucketed_numeric
                self._type = 'arrowBucketedNumeric'
            if arrow_bucketed_enum is not None:
                self._arrow_bucketed_enum = arrow_bucketed_enum
                self._type = 'arrowBucketedEnum'
            if grouped is not None:
                self._grouped = grouped
                self._type = 'grouped'

        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'
        elif type_of_union == 'enumPoint':
            if enum_point is None:
                raise ValueError('a union value must not be None')
            self._enum_point = enum_point
            self._type = 'enumPoint'
        elif type_of_union == 'numericPoint':
            if numeric_point is None:
                raise ValueError('a union value must not be None')
            self._numeric_point = numeric_point
            self._type = 'numericPoint'
        elif type_of_union == 'singlePoint':
            if single_point is None:
                raise ValueError('a union value must not be None')
            self._single_point = single_point
            self._type = 'singlePoint'
        elif type_of_union == 'logPoint':
            if log_point is None:
                raise ValueError('a union value must not be None')
            self._log_point = log_point
            self._type = 'logPoint'
        elif type_of_union == 'rangeValue':
            if range_value is None:
                raise ValueError('a union value must not be None')
            self._range_value = range_value
            self._type = 'rangeValue'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'bucketedNumeric':
            if bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._bucketed_numeric = bucketed_numeric
            self._type = 'bucketedNumeric'
        elif type_of_union == 'bucketedEnum':
            if bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._bucketed_enum = bucketed_enum
            self._type = 'bucketedEnum'
        elif type_of_union == 'arrowNumeric':
            if arrow_numeric is None:
                raise ValueError('a union value must not be None')
            self._arrow_numeric = arrow_numeric
            self._type = 'arrowNumeric'
        elif type_of_union == 'arrowEnum':
            if arrow_enum is None:
                raise ValueError('a union value must not be None')
            self._arrow_enum = arrow_enum
            self._type = 'arrowEnum'
        elif type_of_union == 'arrowBucketedNumeric':
            if arrow_bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._arrow_bucketed_numeric = arrow_bucketed_numeric
            self._type = 'arrowBucketedNumeric'
        elif type_of_union == 'arrowBucketedEnum':
            if arrow_bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._arrow_bucketed_enum = arrow_bucketed_enum
            self._type = 'arrowBucketedEnum'
        elif type_of_union == 'grouped':
            if grouped is None:
                raise ValueError('a union value must not be None')
            self._grouped = grouped
            self._type = 'grouped'

    @builtins.property
    def range(self) -> Optional[List["scout_compute_api_Range"]]:
        """Merging can be done via dropping any old ranges (possibly truncating the last one) and adding these new 
ranges, possibly merging them if they overlap or are adjacent.
        """
        return self._range

    @builtins.property
    def enum_point(self) -> Optional[Optional["scout_compute_api_EnumPoint"]]:
        """Merging can be done by keeping track of the applicable point present within the current window
        """
        return self._enum_point

    @builtins.property
    def numeric_point(self) -> Optional[Optional["scout_compute_api_NumericPoint"]]:
        """Merging can be done by keeping track of the applicable point present within the current window
        """
        return self._numeric_point

    @builtins.property
    def single_point(self) -> Optional[Optional["scout_compute_api_SinglePoint"]]:
        """Merging can be done by keeping track of the applicable point present within the current window
        """
        return self._single_point

    @builtins.property
    def log_point(self) -> Optional[Optional["scout_compute_api_LogPoint"]]:
        """Merging can be done by keeping track of the applicable point present within the current window
        """
        return self._log_point

    @builtins.property
    def range_value(self) -> Optional[Optional["scout_compute_api_Range"]]:
        """Merging can be done by keeping track of the applicable range present within the current window, possibly
merging ranges if they are overlap or are adjacent
        """
        return self._range_value

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericPlot"]:
        """Merging can be done by dropping any old points and adding the new ones, accounting for overlaps
        """
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumPlot"]:
        """Merging can be done by dropping any old points and adding the new ones, accounting for overlaps
        """
        return self._enum

    @builtins.property
    def bucketed_numeric(self) -> Optional["scout_compute_api_BucketedNumericPlot"]:
        """Merging can be done by dropping any old buckets and adding the new ones. Overlapping buckets are
guaranteed to align (same bucket end timestamp) and the older version of the bucket can be replaced
with the newer ones.
        """
        return self._bucketed_numeric

    @builtins.property
    def bucketed_enum(self) -> Optional["scout_compute_api_BucketedEnumPlot"]:
        """Merging can be done by dropping any old buckets and adding the new ones. Overlapping buckets are
guaranteed to align (same bucket end timestamp) and the older version of the bucket can be replaced
with the newer ones.
        """
        return self._bucketed_enum

    @builtins.property
    def arrow_numeric(self) -> Optional["scout_compute_api_ArrowNumericPlot"]:
        """Merging can be done by dropping any old points and adding the new ones, accounting for overlaps
        """
        return self._arrow_numeric

    @builtins.property
    def arrow_enum(self) -> Optional["scout_compute_api_ArrowEnumPlot"]:
        """Merging can be done by dropping any old points and adding the new ones, accounting for overlaps
        """
        return self._arrow_enum

    @builtins.property
    def arrow_bucketed_numeric(self) -> Optional["scout_compute_api_ArrowBucketedNumericPlot"]:
        """Merging can be done by dropping any old buckets and adding the new ones. Overlapping buckets are
guaranteed to align (same bucket end timestamp) and the older version of the bucket can be replaced
with the newer ones.
        """
        return self._arrow_bucketed_numeric

    @builtins.property
    def arrow_bucketed_enum(self) -> Optional["scout_compute_api_ArrowBucketedEnumPlot"]:
        """Merging can be done by dropping any old buckets and adding the new ones. Overlapping buckets are
guaranteed to align (same bucket end timestamp) and the older version of the bucket can be replaced
with the newer ones.
        """
        return self._arrow_bucketed_enum

    @builtins.property
    def grouped(self) -> Optional["persistent_compute_api_GroupedComputeNodeAppendResponses"]:
        """Appends can be done by doing an append individually for each contained `ComputeNodeAppendResponse`.
        """
        return self._grouped

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_ComputeNodeAppendResponseVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_ComputeNodeAppendResponseVisitor'.format(visitor.__class__.__name__))
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)
        if self._type == 'enumPoint' and self.enum_point is not None:
            return visitor._enum_point(self.enum_point)
        if self._type == 'numericPoint' and self.numeric_point is not None:
            return visitor._numeric_point(self.numeric_point)
        if self._type == 'singlePoint' and self.single_point is not None:
            return visitor._single_point(self.single_point)
        if self._type == 'logPoint' and self.log_point is not None:
            return visitor._log_point(self.log_point)
        if self._type == 'rangeValue' and self.range_value is not None:
            return visitor._range_value(self.range_value)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'bucketedNumeric' and self.bucketed_numeric is not None:
            return visitor._bucketed_numeric(self.bucketed_numeric)
        if self._type == 'bucketedEnum' and self.bucketed_enum is not None:
            return visitor._bucketed_enum(self.bucketed_enum)
        if self._type == 'arrowNumeric' and self.arrow_numeric is not None:
            return visitor._arrow_numeric(self.arrow_numeric)
        if self._type == 'arrowEnum' and self.arrow_enum is not None:
            return visitor._arrow_enum(self.arrow_enum)
        if self._type == 'arrowBucketedNumeric' and self.arrow_bucketed_numeric is not None:
            return visitor._arrow_bucketed_numeric(self.arrow_bucketed_numeric)
        if self._type == 'arrowBucketedEnum' and self.arrow_bucketed_enum is not None:
            return visitor._arrow_bucketed_enum(self.arrow_bucketed_enum)
        if self._type == 'grouped' and self.grouped is not None:
            return visitor._grouped(self.grouped)


persistent_compute_api_ComputeNodeAppendResponse.__name__ = "ComputeNodeAppendResponse"
persistent_compute_api_ComputeNodeAppendResponse.__qualname__ = "ComputeNodeAppendResponse"
persistent_compute_api_ComputeNodeAppendResponse.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ComputeNodeAppendResponseVisitor:

    @abstractmethod
    def _range(self, range: List["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _enum_point(self, enum_point: Optional["scout_compute_api_EnumPoint"]) -> Any:
        pass

    @abstractmethod
    def _numeric_point(self, numeric_point: Optional["scout_compute_api_NumericPoint"]) -> Any:
        pass

    @abstractmethod
    def _single_point(self, single_point: Optional["scout_compute_api_SinglePoint"]) -> Any:
        pass

    @abstractmethod
    def _log_point(self, log_point: Optional["scout_compute_api_LogPoint"]) -> Any:
        pass

    @abstractmethod
    def _range_value(self, range_value: Optional["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericPlot") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_numeric(self, bucketed_numeric: "scout_compute_api_BucketedNumericPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_enum(self, bucketed_enum: "scout_compute_api_BucketedEnumPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_numeric(self, arrow_numeric: "scout_compute_api_ArrowNumericPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_enum(self, arrow_enum: "scout_compute_api_ArrowEnumPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_bucketed_numeric(self, arrow_bucketed_numeric: "scout_compute_api_ArrowBucketedNumericPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_bucketed_enum(self, arrow_bucketed_enum: "scout_compute_api_ArrowBucketedEnumPlot") -> Any:
        pass

    @abstractmethod
    def _grouped(self, grouped: "persistent_compute_api_GroupedComputeNodeAppendResponses") -> Any:
        pass


persistent_compute_api_ComputeNodeAppendResponseVisitor.__name__ = "ComputeNodeAppendResponseVisitor"
persistent_compute_api_ComputeNodeAppendResponseVisitor.__qualname__ = "ComputeNodeAppendResponseVisitor"
persistent_compute_api_ComputeNodeAppendResponseVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_FullResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'result': ConjureFieldDefinition('result', scout_compute_api_ComputeNodeResponse)
        }

    __slots__: List[str] = ['_result']

    def __init__(self, result: "scout_compute_api_ComputeNodeResponse") -> None:
        self._result = result

    @builtins.property
    def result(self) -> "scout_compute_api_ComputeNodeResponse":
        return self._result


persistent_compute_api_FullResult.__name__ = "FullResult"
persistent_compute_api_FullResult.__qualname__ = "FullResult"
persistent_compute_api_FullResult.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_GroupedComputeNodeAppendResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'grouping': ConjureFieldDefinition('grouping', scout_compute_api_Grouping),
            'response': ConjureFieldDefinition('response', persistent_compute_api_ComputeNodeAppendResponse)
        }

    __slots__: List[str] = ['_grouping', '_response']

    def __init__(self, grouping: "scout_compute_api_Grouping", response: "persistent_compute_api_ComputeNodeAppendResponse") -> None:
        self._grouping = grouping
        self._response = response

    @builtins.property
    def grouping(self) -> "scout_compute_api_Grouping":
        return self._grouping

    @builtins.property
    def response(self) -> "persistent_compute_api_ComputeNodeAppendResponse":
        return self._response


persistent_compute_api_GroupedComputeNodeAppendResponse.__name__ = "GroupedComputeNodeAppendResponse"
persistent_compute_api_GroupedComputeNodeAppendResponse.__qualname__ = "GroupedComputeNodeAppendResponse"
persistent_compute_api_GroupedComputeNodeAppendResponse.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_GroupedComputeNodeAppendResponses(ConjureBeanType):
    """Contains a `GroupedComputeNodeAppendResponse` for each applicable grouping along with metadata describing the 
grouping. All the contained `GroupedComputeNodeAppendResponse`s are guaranteed to be of the same type.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[persistent_compute_api_GroupedComputeNodeAppendResponse])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["persistent_compute_api_GroupedComputeNodeAppendResponse"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["persistent_compute_api_GroupedComputeNodeAppendResponse"]:
        return self._responses


persistent_compute_api_GroupedComputeNodeAppendResponses.__name__ = "GroupedComputeNodeAppendResponses"
persistent_compute_api_GroupedComputeNodeAppendResponses.__qualname__ = "GroupedComputeNodeAppendResponses"
persistent_compute_api_GroupedComputeNodeAppendResponses.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_HealthMessage(ConjureUnionType):
    _ping: Optional["persistent_compute_api_Ping"] = None
    _pong: Optional["persistent_compute_api_Pong"] = None
    _shutdown_notice: Optional["persistent_compute_api_ShutdownNotice"] = None
    _client_message_error: Optional["persistent_compute_api_ClientMessageError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ping': ConjureFieldDefinition('ping', persistent_compute_api_Ping),
            'pong': ConjureFieldDefinition('pong', persistent_compute_api_Pong),
            'shutdown_notice': ConjureFieldDefinition('shutdownNotice', persistent_compute_api_ShutdownNotice),
            'client_message_error': ConjureFieldDefinition('clientMessageError', persistent_compute_api_ClientMessageError)
        }

    def __init__(
            self,
            ping: Optional["persistent_compute_api_Ping"] = None,
            pong: Optional["persistent_compute_api_Pong"] = None,
            shutdown_notice: Optional["persistent_compute_api_ShutdownNotice"] = None,
            client_message_error: Optional["persistent_compute_api_ClientMessageError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ping is not None) + (pong is not None) + (shutdown_notice is not None) + (client_message_error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ping is not None:
                self._ping = ping
                self._type = 'ping'
            if pong is not None:
                self._pong = pong
                self._type = 'pong'
            if shutdown_notice is not None:
                self._shutdown_notice = shutdown_notice
                self._type = 'shutdownNotice'
            if client_message_error is not None:
                self._client_message_error = client_message_error
                self._type = 'clientMessageError'

        elif type_of_union == 'ping':
            if ping is None:
                raise ValueError('a union value must not be None')
            self._ping = ping
            self._type = 'ping'
        elif type_of_union == 'pong':
            if pong is None:
                raise ValueError('a union value must not be None')
            self._pong = pong
            self._type = 'pong'
        elif type_of_union == 'shutdownNotice':
            if shutdown_notice is None:
                raise ValueError('a union value must not be None')
            self._shutdown_notice = shutdown_notice
            self._type = 'shutdownNotice'
        elif type_of_union == 'clientMessageError':
            if client_message_error is None:
                raise ValueError('a union value must not be None')
            self._client_message_error = client_message_error
            self._type = 'clientMessageError'

    @builtins.property
    def ping(self) -> Optional["persistent_compute_api_Ping"]:
        return self._ping

    @builtins.property
    def pong(self) -> Optional["persistent_compute_api_Pong"]:
        return self._pong

    @builtins.property
    def shutdown_notice(self) -> Optional["persistent_compute_api_ShutdownNotice"]:
        return self._shutdown_notice

    @builtins.property
    def client_message_error(self) -> Optional["persistent_compute_api_ClientMessageError"]:
        return self._client_message_error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_HealthMessageVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_HealthMessageVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ping' and self.ping is not None:
            return visitor._ping(self.ping)
        if self._type == 'pong' and self.pong is not None:
            return visitor._pong(self.pong)
        if self._type == 'shutdownNotice' and self.shutdown_notice is not None:
            return visitor._shutdown_notice(self.shutdown_notice)
        if self._type == 'clientMessageError' and self.client_message_error is not None:
            return visitor._client_message_error(self.client_message_error)


persistent_compute_api_HealthMessage.__name__ = "HealthMessage"
persistent_compute_api_HealthMessage.__qualname__ = "HealthMessage"
persistent_compute_api_HealthMessage.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_HealthMessageVisitor:

    @abstractmethod
    def _ping(self, ping: "persistent_compute_api_Ping") -> Any:
        pass

    @abstractmethod
    def _pong(self, pong: "persistent_compute_api_Pong") -> Any:
        pass

    @abstractmethod
    def _shutdown_notice(self, shutdown_notice: "persistent_compute_api_ShutdownNotice") -> Any:
        pass

    @abstractmethod
    def _client_message_error(self, client_message_error: "persistent_compute_api_ClientMessageError") -> Any:
        pass


persistent_compute_api_HealthMessageVisitor.__name__ = "HealthMessageVisitor"
persistent_compute_api_HealthMessageVisitor.__qualname__ = "HealthMessageVisitor"
persistent_compute_api_HealthMessageVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_InvalidComputationType(ConjureEnumType):
    """Compute types that are completely incompatible with streaming.
If any of these are present, the subscription cannot be created.
    """

    POINT_PERSISTENCE = 'POINT_PERSISTENCE'
    '''POINT_PERSISTENCE'''
    CUMULATIVE_SUM = 'CUMULATIVE_SUM'
    '''CUMULATIVE_SUM'''
    INTEGRAL = 'INTEGRAL'
    '''INTEGRAL'''
    STALENESS_DETECTION = 'STALENESS_DETECTION'
    '''STALENESS_DETECTION'''
    TIME_RANGE_FILTER = 'TIME_RANGE_FILTER'
    '''TIME_RANGE_FILTER'''
    LITERAL_RANGES = 'LITERAL_RANGES'
    '''LITERAL_RANGES'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


persistent_compute_api_InvalidComputationType.__name__ = "InvalidComputationType"
persistent_compute_api_InvalidComputationType.__qualname__ = "InvalidComputationType"
persistent_compute_api_InvalidComputationType.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_IsEnabledResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



persistent_compute_api_IsEnabledResponse.__name__ = "IsEnabledResponse"
persistent_compute_api_IsEnabledResponse.__qualname__ = "IsEnabledResponse"
persistent_compute_api_IsEnabledResponse.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_PersistentComputeService(Service):
    """Exposes a simple endpoints for checking whether or not persistent compute is enabled.
    """

    def is_enabled(self, auth_header: str) -> "persistent_compute_api_IsEnabledResponse":
        """Simple "ping" like endpoint to see if the service is enabled (and available).
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/persistent-compute/enabled'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), persistent_compute_api_IsEnabledResponse, self._return_none_for_unknown_union_types)


persistent_compute_api_PersistentComputeService.__name__ = "PersistentComputeService"
persistent_compute_api_PersistentComputeService.__qualname__ = "PersistentComputeService"
persistent_compute_api_PersistentComputeService.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_Ping(ConjureBeanType):
    """A ping can be sent by both client and server to keep the connection open and check that it is still working.
The receiving end should send back a pong immediately.
We also include the times that pings and pongs are sent so that we can track latency and/or discover clock
drift between server and client.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sent_at': ConjureFieldDefinition('sentAt', str)
        }

    __slots__: List[str] = ['_sent_at']

    def __init__(self, sent_at: str) -> None:
        self._sent_at = sent_at

    @builtins.property
    def sent_at(self) -> str:
        return self._sent_at


persistent_compute_api_Ping.__name__ = "Ping"
persistent_compute_api_Ping.__qualname__ = "Ping"
persistent_compute_api_Ping.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_PollingOnlyComputationType(ConjureEnumType):
    """Compute types that support streaming but only via polling (not real-time appends).
Subscriptions with these types will be created successfully, but the frontend should
use polling mode instead of expecting append updates.
    """

    FREQUENCY_DOMAIN = 'FREQUENCY_DOMAIN'
    '''FREQUENCY_DOMAIN'''
    PAGE_SUMMARIZATION_STRATEGY = 'PAGE_SUMMARIZATION_STRATEGY'
    '''PAGE_SUMMARIZATION_STRATEGY'''
    TRUNCATE_SUMMARIZATION_STRATEGY = 'TRUNCATE_SUMMARIZATION_STRATEGY'
    '''TRUNCATE_SUMMARIZATION_STRATEGY'''
    LOG_SERIES = 'LOG_SERIES'
    '''LOG_SERIES'''
    CURVE_FITTING = 'CURVE_FITTING'
    '''CURVE_FITTING'''
    ARRAY = 'ARRAY'
    '''ARRAY'''
    STRUCT = 'STRUCT'
    '''STRUCT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


persistent_compute_api_PollingOnlyComputationType.__name__ = "PollingOnlyComputationType"
persistent_compute_api_PollingOnlyComputationType.__qualname__ = "PollingOnlyComputationType"
persistent_compute_api_PollingOnlyComputationType.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_Pong(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ping_originally_sent_at': ConjureFieldDefinition('pingOriginallySentAt', str),
            'sent_at': ConjureFieldDefinition('sentAt', str)
        }

    __slots__: List[str] = ['_ping_originally_sent_at', '_sent_at']

    def __init__(self, ping_originally_sent_at: str, sent_at: str) -> None:
        self._ping_originally_sent_at = ping_originally_sent_at
        self._sent_at = sent_at

    @builtins.property
    def ping_originally_sent_at(self) -> str:
        return self._ping_originally_sent_at

    @builtins.property
    def sent_at(self) -> str:
        return self._sent_at


persistent_compute_api_Pong.__name__ = "Pong"
persistent_compute_api_Pong.__qualname__ = "Pong"
persistent_compute_api_Pong.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ResultConfiguration(ConjureUnionType):
    _append_only: Optional["persistent_compute_api_AppendOnlyConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'append_only': ConjureFieldDefinition('appendOnly', persistent_compute_api_AppendOnlyConfig)
        }

    def __init__(
            self,
            append_only: Optional["persistent_compute_api_AppendOnlyConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (append_only is not None) != 1:
                raise ValueError('a union must contain a single member')

            if append_only is not None:
                self._append_only = append_only
                self._type = 'appendOnly'

        elif type_of_union == 'appendOnly':
            if append_only is None:
                raise ValueError('a union value must not be None')
            self._append_only = append_only
            self._type = 'appendOnly'

    @builtins.property
    def append_only(self) -> Optional["persistent_compute_api_AppendOnlyConfig"]:
        return self._append_only

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_ResultConfigurationVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_ResultConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'appendOnly' and self.append_only is not None:
            return visitor._append_only(self.append_only)


persistent_compute_api_ResultConfiguration.__name__ = "ResultConfiguration"
persistent_compute_api_ResultConfiguration.__qualname__ = "ResultConfiguration"
persistent_compute_api_ResultConfiguration.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ResultConfigurationVisitor:

    @abstractmethod
    def _append_only(self, append_only: "persistent_compute_api_AppendOnlyConfig") -> Any:
        pass


persistent_compute_api_ResultConfigurationVisitor.__name__ = "ResultConfigurationVisitor"
persistent_compute_api_ResultConfigurationVisitor.__qualname__ = "ResultConfigurationVisitor"
persistent_compute_api_ResultConfigurationVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ServerMessage(ConjureUnionType):
    _subscription_update: Optional["persistent_compute_api_SubscriptionUpdateMessage"] = None
    _subscription_creation: Optional["persistent_compute_api_SubscriptionCreationMessage"] = None
    _health: Optional["persistent_compute_api_HealthMessage"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'subscription_update': ConjureFieldDefinition('subscriptionUpdate', persistent_compute_api_SubscriptionUpdateMessage),
            'subscription_creation': ConjureFieldDefinition('subscriptionCreation', persistent_compute_api_SubscriptionCreationMessage),
            'health': ConjureFieldDefinition('health', persistent_compute_api_HealthMessage)
        }

    def __init__(
            self,
            subscription_update: Optional["persistent_compute_api_SubscriptionUpdateMessage"] = None,
            subscription_creation: Optional["persistent_compute_api_SubscriptionCreationMessage"] = None,
            health: Optional["persistent_compute_api_HealthMessage"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (subscription_update is not None) + (subscription_creation is not None) + (health is not None) != 1:
                raise ValueError('a union must contain a single member')

            if subscription_update is not None:
                self._subscription_update = subscription_update
                self._type = 'subscriptionUpdate'
            if subscription_creation is not None:
                self._subscription_creation = subscription_creation
                self._type = 'subscriptionCreation'
            if health is not None:
                self._health = health
                self._type = 'health'

        elif type_of_union == 'subscriptionUpdate':
            if subscription_update is None:
                raise ValueError('a union value must not be None')
            self._subscription_update = subscription_update
            self._type = 'subscriptionUpdate'
        elif type_of_union == 'subscriptionCreation':
            if subscription_creation is None:
                raise ValueError('a union value must not be None')
            self._subscription_creation = subscription_creation
            self._type = 'subscriptionCreation'
        elif type_of_union == 'health':
            if health is None:
                raise ValueError('a union value must not be None')
            self._health = health
            self._type = 'health'

    @builtins.property
    def subscription_update(self) -> Optional["persistent_compute_api_SubscriptionUpdateMessage"]:
        return self._subscription_update

    @builtins.property
    def subscription_creation(self) -> Optional["persistent_compute_api_SubscriptionCreationMessage"]:
        return self._subscription_creation

    @builtins.property
    def health(self) -> Optional["persistent_compute_api_HealthMessage"]:
        return self._health

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_ServerMessageVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_ServerMessageVisitor'.format(visitor.__class__.__name__))
        if self._type == 'subscriptionUpdate' and self.subscription_update is not None:
            return visitor._subscription_update(self.subscription_update)
        if self._type == 'subscriptionCreation' and self.subscription_creation is not None:
            return visitor._subscription_creation(self.subscription_creation)
        if self._type == 'health' and self.health is not None:
            return visitor._health(self.health)


persistent_compute_api_ServerMessage.__name__ = "ServerMessage"
persistent_compute_api_ServerMessage.__qualname__ = "ServerMessage"
persistent_compute_api_ServerMessage.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ServerMessageVisitor:

    @abstractmethod
    def _subscription_update(self, subscription_update: "persistent_compute_api_SubscriptionUpdateMessage") -> Any:
        pass

    @abstractmethod
    def _subscription_creation(self, subscription_creation: "persistent_compute_api_SubscriptionCreationMessage") -> Any:
        pass

    @abstractmethod
    def _health(self, health: "persistent_compute_api_HealthMessage") -> Any:
        pass


persistent_compute_api_ServerMessageVisitor.__name__ = "ServerMessageVisitor"
persistent_compute_api_ServerMessageVisitor.__qualname__ = "ServerMessageVisitor"
persistent_compute_api_ServerMessageVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_ShutdownNotice(ConjureBeanType):
    """Indicates that the websocket will shut down in the near future. Until it is, SubscriptionUpdates will 
still be sent to the client. Clients that want to avoid downtime or latency spikes should initiate a new 
websocket and recreate all their subscriptions there but still keep this websocket open until the new 
websockets starts sending SubscriptionUpdates. 
Note: The initial updates that the new websocket sends might be somewhat stale because of server and 
connection pools warm up. The client might want to wait with fully switching to the new subscription until 
the updates aren't very stale anymore.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



persistent_compute_api_ShutdownNotice.__name__ = "ShutdownNotice"
persistent_compute_api_ShutdownNotice.__qualname__ = "ShutdownNotice"
persistent_compute_api_ShutdownNotice.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_StreamingComputeNodeRequest(ConjureBeanType):
    """A templatized version of `ComputeNodeRequest` where the end of the range will track the current time and
the start of the range tracks `windowWidth` time ago.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'window_width': ConjureFieldDefinition('windowWidth', scout_run_api_Duration),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_window_width', '_context']

    def __init__(self, context: "scout_compute_api_Context", node: "scout_compute_api_ComputableNode", window_width: "scout_run_api_Duration") -> None:
        self._node = node
        self._window_width = window_width
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def window_width(self) -> "scout_run_api_Duration":
        return self._window_width

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


persistent_compute_api_StreamingComputeNodeRequest.__name__ = "StreamingComputeNodeRequest"
persistent_compute_api_StreamingComputeNodeRequest.__qualname__ = "StreamingComputeNodeRequest"
persistent_compute_api_StreamingComputeNodeRequest.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_StreamingComputeNodeSubscription(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_request': ConjureFieldDefinition('computeRequest', persistent_compute_api_StreamingComputeNodeRequest),
            'subscription_options': ConjureFieldDefinition('subscriptionOptions', persistent_compute_api_SubscriptionOptions)
        }

    __slots__: List[str] = ['_compute_request', '_subscription_options']

    def __init__(self, compute_request: "persistent_compute_api_StreamingComputeNodeRequest", subscription_options: "persistent_compute_api_SubscriptionOptions") -> None:
        self._compute_request = compute_request
        self._subscription_options = subscription_options

    @builtins.property
    def compute_request(self) -> "persistent_compute_api_StreamingComputeNodeRequest":
        return self._compute_request

    @builtins.property
    def subscription_options(self) -> "persistent_compute_api_SubscriptionOptions":
        return self._subscription_options


persistent_compute_api_StreamingComputeNodeSubscription.__name__ = "StreamingComputeNodeSubscription"
persistent_compute_api_StreamingComputeNodeSubscription.__qualname__ = "StreamingComputeNodeSubscription"
persistent_compute_api_StreamingComputeNodeSubscription.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionCreation(ConjureUnionType):
    _success: Optional["persistent_compute_api_SubscriptionCreationSuccess"] = None
    _error: Optional["persistent_compute_api_SubscriptionCreationError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', persistent_compute_api_SubscriptionCreationSuccess),
            'error': ConjureFieldDefinition('error', persistent_compute_api_SubscriptionCreationError)
        }

    def __init__(
            self,
            success: Optional["persistent_compute_api_SubscriptionCreationSuccess"] = None,
            error: Optional["persistent_compute_api_SubscriptionCreationError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def success(self) -> Optional["persistent_compute_api_SubscriptionCreationSuccess"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["persistent_compute_api_SubscriptionCreationError"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_SubscriptionCreationVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_SubscriptionCreationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


persistent_compute_api_SubscriptionCreation.__name__ = "SubscriptionCreation"
persistent_compute_api_SubscriptionCreation.__qualname__ = "SubscriptionCreation"
persistent_compute_api_SubscriptionCreation.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionCreationVisitor:

    @abstractmethod
    def _success(self, success: "persistent_compute_api_SubscriptionCreationSuccess") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "persistent_compute_api_SubscriptionCreationError") -> Any:
        pass


persistent_compute_api_SubscriptionCreationVisitor.__name__ = "SubscriptionCreationVisitor"
persistent_compute_api_SubscriptionCreationVisitor.__qualname__ = "SubscriptionCreationVisitor"
persistent_compute_api_SubscriptionCreationVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionCreationError(ConjureBeanType):
    """This will be sent if there is an error while creating a subscription. This means that the subscription was
never created and the client will have to re-try creating it if warranted.
This can also be sent after a subscription was first successfully started and sent result. In that case it
means that the subscription encountered an unrecoverable error at runtime and will be stopped.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'serializable_error': ConjureFieldDefinition('serializableError', api_SerializableError)
        }

    __slots__: List[str] = ['_serializable_error']

    def __init__(self, serializable_error: "api_SerializableError") -> None:
        self._serializable_error = serializable_error

    @builtins.property
    def serializable_error(self) -> "api_SerializableError":
        """A serialized version of the error. Should match the errors defined below.
        """
        return self._serializable_error


persistent_compute_api_SubscriptionCreationError.__name__ = "SubscriptionCreationError"
persistent_compute_api_SubscriptionCreationError.__qualname__ = "SubscriptionCreationError"
persistent_compute_api_SubscriptionCreationError.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionCreationMessage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'subscription_id': ConjureFieldDefinition('subscriptionId', persistent_compute_api_SubscriptionId),
            'creation': ConjureFieldDefinition('creation', persistent_compute_api_SubscriptionCreation)
        }

    __slots__: List[str] = ['_subscription_id', '_creation']

    def __init__(self, creation: "persistent_compute_api_SubscriptionCreation", subscription_id: str) -> None:
        self._subscription_id = subscription_id
        self._creation = creation

    @builtins.property
    def subscription_id(self) -> str:
        return self._subscription_id

    @builtins.property
    def creation(self) -> "persistent_compute_api_SubscriptionCreation":
        return self._creation


persistent_compute_api_SubscriptionCreationMessage.__name__ = "SubscriptionCreationMessage"
persistent_compute_api_SubscriptionCreationMessage.__qualname__ = "SubscriptionCreationMessage"
persistent_compute_api_SubscriptionCreationMessage.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionCreationSuccess(ConjureBeanType):
    """Will be returned once a subscriptions has been successfully created.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit_result': ConjureFieldDefinition('unitResult', scout_compute_api_ComputeUnitResult)
        }

    __slots__: List[str] = ['_unit_result']

    def __init__(self, unit_result: "scout_compute_api_ComputeUnitResult") -> None:
        self._unit_result = unit_result

    @builtins.property
    def unit_result(self) -> "scout_compute_api_ComputeUnitResult":
        return self._unit_result


persistent_compute_api_SubscriptionCreationSuccess.__name__ = "SubscriptionCreationSuccess"
persistent_compute_api_SubscriptionCreationSuccess.__qualname__ = "SubscriptionCreationSuccess"
persistent_compute_api_SubscriptionCreationSuccess.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_delay': ConjureFieldDefinition('minDelay', persistent_compute_api_Milliseconds),
            'allow_appends': ConjureFieldDefinition('allowAppends', OptionalTypeWrapper[bool]),
            'result_configuration': ConjureFieldDefinition('resultConfiguration', OptionalTypeWrapper[persistent_compute_api_ResultConfiguration])
        }

    __slots__: List[str] = ['_min_delay', '_allow_appends', '_result_configuration']

    def __init__(self, min_delay: int, allow_appends: Optional[bool] = None, result_configuration: Optional["persistent_compute_api_ResultConfiguration"] = None) -> None:
        self._min_delay = min_delay
        self._allow_appends = allow_appends
        self._result_configuration = result_configuration

    @builtins.property
    def min_delay(self) -> int:
        """The minimum delay between `SubscriptionUpdate`s sent for this subscription.
        """
        return self._min_delay

    @builtins.property
    def allow_appends(self) -> Optional[bool]:
        """Can be set to `false` by the client to indicate that it doesn't support appends for this subscription
and always wants to receive full results. Defaults to `false` if not set.
The expectation is that clients should implement support for appends for any of the results covered in
`ComputeNodeAppendResponse` and set this to `true` as quickly as possible. However, in order to support 
adding new sub-types to `ComputeNodeAppendResponse` without breaking clients that haven't upgraded yet 
and haven't yet added support for them, we default this to `false` and make clients opt-in as soon as they
implement support.
        """
        return self._allow_appends

    @builtins.property
    def result_configuration(self) -> Optional["persistent_compute_api_ResultConfiguration"]:
        """Defines the results that are sent for this subscription. If not set, falls back to the behavior 
defined by `allowAppends`.
        """
        return self._result_configuration


persistent_compute_api_SubscriptionOptions.__name__ = "SubscriptionOptions"
persistent_compute_api_SubscriptionOptions.__qualname__ = "SubscriptionOptions"
persistent_compute_api_SubscriptionOptions.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionUpdate(ConjureUnionType):
    _full: Optional["persistent_compute_api_FullResult"] = None
    _append: Optional["persistent_compute_api_AppendResult"] = None
    _error: Optional["persistent_compute_api_SubscriptionUpdateError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'full': ConjureFieldDefinition('full', persistent_compute_api_FullResult),
            'append': ConjureFieldDefinition('append', persistent_compute_api_AppendResult),
            'error': ConjureFieldDefinition('error', persistent_compute_api_SubscriptionUpdateError)
        }

    def __init__(
            self,
            full: Optional["persistent_compute_api_FullResult"] = None,
            append: Optional["persistent_compute_api_AppendResult"] = None,
            error: Optional["persistent_compute_api_SubscriptionUpdateError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (full is not None) + (append is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if full is not None:
                self._full = full
                self._type = 'full'
            if append is not None:
                self._append = append
                self._type = 'append'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'full':
            if full is None:
                raise ValueError('a union value must not be None')
            self._full = full
            self._type = 'full'
        elif type_of_union == 'append':
            if append is None:
                raise ValueError('a union value must not be None')
            self._append = append
            self._type = 'append'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def full(self) -> Optional["persistent_compute_api_FullResult"]:
        return self._full

    @builtins.property
    def append(self) -> Optional["persistent_compute_api_AppendResult"]:
        return self._append

    @builtins.property
    def error(self) -> Optional["persistent_compute_api_SubscriptionUpdateError"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, persistent_compute_api_SubscriptionUpdateVisitor):
            raise ValueError('{} is not an instance of persistent_compute_api_SubscriptionUpdateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'full' and self.full is not None:
            return visitor._full(self.full)
        if self._type == 'append' and self.append is not None:
            return visitor._append(self.append)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


persistent_compute_api_SubscriptionUpdate.__name__ = "SubscriptionUpdate"
persistent_compute_api_SubscriptionUpdate.__qualname__ = "SubscriptionUpdate"
persistent_compute_api_SubscriptionUpdate.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionUpdateVisitor:

    @abstractmethod
    def _full(self, full: "persistent_compute_api_FullResult") -> Any:
        pass

    @abstractmethod
    def _append(self, append: "persistent_compute_api_AppendResult") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "persistent_compute_api_SubscriptionUpdateError") -> Any:
        pass


persistent_compute_api_SubscriptionUpdateVisitor.__name__ = "SubscriptionUpdateVisitor"
persistent_compute_api_SubscriptionUpdateVisitor.__qualname__ = "SubscriptionUpdateVisitor"
persistent_compute_api_SubscriptionUpdateVisitor.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionUpdateError(ConjureBeanType):
    """This will be sent if there is an error while updating a subscription. Note: This won't automatically cancel 
the subscription. The client will have to call `ClientMessage::unsubscribe` to do that if warranted.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'serializable_error': ConjureFieldDefinition('serializableError', api_SerializableError)
        }

    __slots__: List[str] = ['_serializable_error']

    def __init__(self, serializable_error: "api_SerializableError") -> None:
        self._serializable_error = serializable_error

    @builtins.property
    def serializable_error(self) -> "api_SerializableError":
        """A serialized version of the error. Should match the errors defined below.
        """
        return self._serializable_error


persistent_compute_api_SubscriptionUpdateError.__name__ = "SubscriptionUpdateError"
persistent_compute_api_SubscriptionUpdateError.__qualname__ = "SubscriptionUpdateError"
persistent_compute_api_SubscriptionUpdateError.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_SubscriptionUpdateMessage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'subscription_id': ConjureFieldDefinition('subscriptionId', persistent_compute_api_SubscriptionId),
            'update': ConjureFieldDefinition('update', persistent_compute_api_SubscriptionUpdate)
        }

    __slots__: List[str] = ['_subscription_id', '_update']

    def __init__(self, subscription_id: str, update: "persistent_compute_api_SubscriptionUpdate") -> None:
        self._subscription_id = subscription_id
        self._update = update

    @builtins.property
    def subscription_id(self) -> str:
        return self._subscription_id

    @builtins.property
    def update(self) -> "persistent_compute_api_SubscriptionUpdate":
        return self._update


persistent_compute_api_SubscriptionUpdateMessage.__name__ = "SubscriptionUpdateMessage"
persistent_compute_api_SubscriptionUpdateMessage.__qualname__ = "SubscriptionUpdateMessage"
persistent_compute_api_SubscriptionUpdateMessage.__module__ = "nominal_api.persistent_compute_api"


class persistent_compute_api_UnavailableResultConfigurationReason(ConjureEnumType):

    APPENDS_NOT_SUPPORTED_FOR_COMPUTE = 'APPENDS_NOT_SUPPORTED_FOR_COMPUTE'
    '''APPENDS_NOT_SUPPORTED_FOR_COMPUTE'''
    TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS = 'TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS'
    '''TOO_MANY_POINTS_FOR_UNDECIMATED_APPENDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


persistent_compute_api_UnavailableResultConfigurationReason.__name__ = "UnavailableResultConfigurationReason"
persistent_compute_api_UnavailableResultConfigurationReason.__qualname__ = "UnavailableResultConfigurationReason"
persistent_compute_api_UnavailableResultConfigurationReason.__module__ = "nominal_api.persistent_compute_api"


class scout_InternalVersioningService(Service):
    """These endpoints are not intended to be used directly by clients, since
they require saving resource-specific state associated with new commits.
    """

    def init_resource_versioning(self, auth_header: str, request: "scout_versioning_api_InitResourceVersioningRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """Creates a root commit (no parents) and a "main" branch 
pointing to that commit, for the given resource.
Throws if the resource already has a commit graph.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/scout/v1/versioning/{resourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, branch_name: str, request: "scout_versioning_api_SaveWorkingStateRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """Creates a non-permanent commit on the given branch,
Throws if the branch doesn't exist.
Throws if latestCommit is passed and is not the latest commit.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'branchName': quote(str(_conjure_encoder.default(branch_name)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/scout/v1/versioning/{resourceRid}/branch/{branchName}/working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, branch_name: str, request: "scout_versioning_api_CommitRequest", resource_rid: str) -> "scout_versioning_api_BranchAndCommit":
        """Creates a new permanent commit on the given branch.
Throws if the branch doesn't exist.
Throws if latestCommit is passed and is not the latest commit.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'branchName': quote(str(_conjure_encoder.default(branch_name)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/scout/v1/versioning/{resourceRid}/branch/{branchName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_BranchAndCommit, self._return_none_for_unknown_union_types)

    def compact_commits(self, auth_header: str, request: "scout_versioning_api_CompactCommitsRequest", resource_rid: str) -> List[str]:
        """Compacts the commit graph for the resource by deleting
working state commits that match the provided strategy.
Persists commits that are pointed to by branches.
Returns the set of commits that were compacted.
Throws if the resource doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/scout/v1/versioning/{resourceRid}/compact-commits'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_CommitId], self._return_none_for_unknown_union_types)


scout_InternalVersioningService.__name__ = "InternalVersioningService"
scout_InternalVersioningService.__qualname__ = "InternalVersioningService"
scout_InternalVersioningService.__module__ = "nominal_api.scout"


class scout_NotebookService(Service):
    """NotebookService manages workbooks (formerly known as notebooks).
    """

    def create(self, auth_header: str, request: "scout_notebook_api_CreateNotebookRequest") -> "scout_notebook_api_Notebook":
        """Creates a new workbook. The workbook will be associated with the provided run. If the run does not exist, 
a RunNotFound error will be thrown.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "scout_notebook_api_UpdateNotebookRequest", rid: str) -> "scout_notebook_api_Notebook":
        """Updates the contents of a workbook.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str, snapshot: Optional[str] = None) -> "scout_notebook_api_Notebook":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'snapshot': _conjure_encoder.default(snapshot),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, rids: List[str] = None) -> List["scout_notebook_api_Notebook"]:
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v2/notebook/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_notebook_api_Notebook], self._return_none_for_unknown_union_types)

    def batch_get_metadata(self, auth_header: str, rids: List[str] = None) -> List["scout_notebook_api_NotebookMetadataWithRid"]:
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v2/notebook/batch-get-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_notebook_api_NotebookMetadataWithRid], self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_notebook_api_UpdateNotebookMetadataRequest", rid: str) -> "scout_notebook_api_NotebookMetadata":
        """Updates metadata about a workbook, but not its contents.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook/{rid}/update-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_NotebookMetadata, self._return_none_for_unknown_union_types)

    def get_used_ref_names(self, auth_header: str, rid: str) -> List[str]:
        """Returns the set of all ref names used by the workbook.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_api_DataSourceRefName], self._return_none_for_unknown_union_types)

    def update_ref_names(self, auth_header: str, request: "scout_notebook_api_UpdateRefNameRequest", rid: str) -> "scout_notebook_api_Notebook":
        """Updates the data source ref names for all variables used in the workbook.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook/{rid}/update-ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_Notebook, self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str, workspaces: List[str] = None) -> "scout_notebook_api_GetAllLabelsAndPropertiesResponse":
        """Returns all properties (key value pairs) and labels that have been previously used on workbook. These can
be used to organize workbooks.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v2/notebook/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_notebook_api_SearchNotebooksRequest") -> "scout_notebook_api_SearchNotebooksResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_SearchNotebooksResponse, self._return_none_for_unknown_union_types)

    def lock(self, auth_header: str, rid: str) -> None:
        """Makes a workbook uneditable.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/lock'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unlock(self, auth_header: str, rid: str) -> None:
        """Unlocks a workbook for editing.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/unlock'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive(self, auth_header: str, rid: str) -> None:
        """Archives a workbook, which excludes it from search and hides it from being publicly visible, but does not
permanently delete it. Archived workbooks can be unarchived.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """Makes a previously archived workbook searchable.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete(self, auth_header: str, rid: str) -> None:
        """The workbook will be deleted and is not recoverable. For soft deletion, use archive.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/notebook/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_snapshot_history(self, auth_header: str, request: "scout_notebook_api_GetSnapshotHistoryRequest") -> "scout_notebook_api_GetSnapshotHistoryResponse":
        """Retrieves the snapshot history for a given workbook. These are sorted in reverse chronological order. Results
are limited by page size.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/notebook/snapshot-history'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_notebook_api_GetSnapshotHistoryResponse, self._return_none_for_unknown_union_types)


scout_NotebookService.__name__ = "NotebookService"
scout_NotebookService.__qualname__ = "NotebookService"
scout_NotebookService.__module__ = "nominal_api.scout"


class scout_RunService(Service):
    """Runs are collections of channels and metadata from one or more data sources, synchronized over a 
range of real time, which represents a test event or simulation. These API endpoints let you
manage runs in the Nominal app.
    """

    def create_run(self, auth_header: str, details: "scout_run_api_CreateRunRequest") -> "scout_run_api_Run":
        """Create a new run in Nominal.

Throws if start is equal to or after end.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/scout/v1/run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def update_run(self, auth_header: str, details: "scout_run_api_UpdateRunRequest", rid: str) -> "scout_run_api_Run":
        """Updates an existing run based on its RID.

Throws if start is equal to or after end.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/scout/v1/run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def add_data_sources_to_run(self, auth_header: str, request: Dict[str, "scout_run_api_CreateRunDataSource"], run_rid: str) -> "scout_run_api_Run":
        """Adds datasources to the run in question.

Throws if any of the ref names conflict with existing data sources or each other.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'runRid': quote(str(_conjure_encoder.default(run_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/run/{runRid}/data-sources'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def create_or_update_run(self, auth_header: str, details: "scout_run_api_CreateOrUpdateRunRequest") -> "scout_run_api_Run":
        """Updates a run if it exists, otherwise it's created from scratch.
Will throw if the workspace of an existing run is different from the workspace of the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/scout/v1/run/create-or-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_run(self, auth_header: str, rid: str) -> "scout_run_api_Run":
        """Fetches details about the run in question based on its RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_run_with_data_review_metrics(self, auth_header: str, rid: str) -> "scout_run_api_RunWithDataReviewMetrics":
        """Fetches details about the run in question based on its RID, 
including metrics for check and violation review status.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}/with-data-review-metrics'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_RunWithDataReviewMetrics, self._return_none_for_unknown_union_types)

    def get_run_with_data_review_summary(self, auth_header: str, rid: str) -> "scout_run_api_RunWithDataReviewSummary":
        """Fetches details about the run in question based on its RID, including a summary of the data review status.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/run/{rid}/with-data-review-summary'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_RunWithDataReviewSummary, self._return_none_for_unknown_union_types)

    def get_run_by_id(self, auth_header: str, get_run_by_id_request: "scout_run_api_GetRunByIdRequest") -> "scout_run_api_Run":
        """Fetches a run based on the run number, rather than RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(get_run_by_id_request)

        _path = '/scout/v1/run/by-id'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_Run, self._return_none_for_unknown_union_types)

    def get_runs(self, auth_header: str, rids: List[str] = None) -> Dict[str, "scout_run_api_Run"]:
        """Fetches a list of run details based on a list of RIDs.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v1/run/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_run_api_RunRid, scout_run_api_Run], self._return_none_for_unknown_union_types)

    def get_runs_by_asset(self, auth_header: str, request: "scout_run_api_GetRunsByAssetRequest") -> "scout_run_api_GetRunsByAssetResponse":
        """Fetches the runs with the given asset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/run/by-asset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_GetRunsByAssetResponse, self._return_none_for_unknown_union_types)

    def get_latest_run_for_assets(self, auth_header: str, request: List[str] = None) -> Dict[str, "scout_run_api_Run"]:
        """Fetches the latest run for each requested asset.
Assets without associated runs will not be included in response.
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/run/by-assets/latest'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_AssetRid, scout_run_api_Run], self._return_none_for_unknown_union_types)

    def get_all_runs_properties_and_labels(self, auth_header: str, workspaces: List[str] = None) -> "scout_run_api_AllRunsPropertiesAndLabelsResponse":
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v1/all-runs-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_AllRunsPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)

    def search_runs(self, auth_header: str, request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsResponse":
        """Searches for runs that match the given filters. Defaults to returning un-archived runs, absent an archive
filter.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/search-runs'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsResponse, self._return_none_for_unknown_union_types)

    def search_runs_with_data_review_metrics(self, auth_header: str, request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsWithDataReviewMetricsResponse":
        """Searches for runs that match the given filters and 
includes metrics for check and violation review status. Defaults to returning un-archived runs, absent an 
archive filter.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/search-runs-with-data-review-metrics'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsWithDataReviewMetricsResponse, self._return_none_for_unknown_union_types)

    def search_runs_with_data_review_summary(self, auth_header: str, request: "scout_run_api_SearchRunsRequest") -> "scout_run_api_SearchRunsWithDataReviewSummaryResponse":
        """Searches for runs that match the given filters and includes a summary of the data review status. Defaults to 
returning un-archived runs, absent an archive filter.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/search-runs-with-data-review-summary'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_run_api_SearchRunsWithDataReviewSummaryResponse, self._return_none_for_unknown_union_types)

    def archive_run(self, auth_header: str, rid: str, include_linked_workbooks: Optional[bool] = None) -> bool:
        """Soft-deletes a run. Runs still exist in the database but are no longer visible.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeLinkedWorkbooks': _conjure_encoder.default(include_linked_workbooks),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/archive-run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def unarchive_run(self, auth_header: str, rid: str, include_linked_workbooks: Optional[bool] = None) -> bool:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeLinkedWorkbooks': _conjure_encoder.default(include_linked_workbooks),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/unarchive-run/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def archive_runs(self, auth_header: str, request: "scout_run_api_ArchiveRunsRequest") -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/archive-run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_runs(self, auth_header: str, request: "scout_run_api_UnarchiveRunsRequest") -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/unarchive-run'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_data_source_ref_name_and_type_list(self, auth_header: str, workspaces: List[str] = None) -> List["scout_run_api_RefNameAndType"]:
        """Returns the list of ref names that are in use across specified and authorized workspaces.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v1/data-source-ref-names-and-types'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_run_api_RefNameAndType], self._return_none_for_unknown_union_types)

    def update_run_attachment(self, auth_header: str, request: "scout_run_api_UpdateAttachmentsRequest", rid: str) -> None:
        """Updates the attachments associated with a run.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/run/{rid}/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_RunService.__name__ = "RunService"
scout_RunService.__qualname__ = "RunService"
scout_RunService.__module__ = "nominal_api.scout"


class scout_TemplateService(Service):
    """TemplateService manages templates, which are workbooks that
can be re-used across runs. Templates are versioned.
    """

    def create(self, auth_header: str, request: "scout_template_api_CreateTemplateRequest") -> "scout_template_api_Template":
        """Creates a new template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, template_rid: str, branch: Optional[str] = None, commit: Optional[str] = None) -> "scout_template_api_Template":
        """Must only pass one of (branch, commit). If neither are passed,
the latest commit on the "main" branch is returned.
Throws if the template, branch, or commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
            'commit': _conjure_encoder.default(commit),
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/template/{templateRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def batch_get_metadata(self, auth_header: str, rids: List[str] = None) -> List["scout_template_api_TemplateSummary"]:
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v1/template/batch-get-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_template_api_TemplateSummary], self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, request: "scout_template_api_SaveTemplateRequest", template_rid: str, branch: Optional[str] = None) -> "scout_template_api_Template":
        """Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you save to an archived template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/{templateRid}/save-working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def get_used_ref_names(self, auth_header: str, template_rid: str, branch: Optional[str] = None, commit: Optional[str] = None) -> List[str]:
        """Returns the set of all ref names used by the template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
            'commit': _conjure_encoder.default(commit),
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/template/{templateRid}/ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_api_DataSourceRefName], self._return_none_for_unknown_union_types)

    def update_ref_names(self, auth_header: str, request: "scout_template_api_UpdateRefNameRequest", template_rid: str, branch: Optional[str] = None) -> "scout_template_api_Template":
        """Updates the data source ref names for all variables used in the template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/{templateRid}/update-ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, request: "scout_template_api_CommitTemplateRequest", template_rid: str, branch: Optional[str] = None) -> "scout_template_api_Template":
        """Creates a commit with a commit message. 
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you commit to an archived template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/{templateRid}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_template_api_UpdateMetadataRequest", template_rid: str) -> "scout_template_api_TemplateMetadata":
        """Throws if the template doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/{templateRid}/metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_TemplateMetadata, self._return_none_for_unknown_union_types)

    def search_templates(self, auth_header: str, request: "scout_template_api_SearchTemplatesRequest") -> "scout_template_api_SearchTemplatesResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_SearchTemplatesResponse, self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str, workspaces: List[str] = None) -> "scout_template_api_GetAllLabelsAndPropertiesResponse":
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v1/template/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)

    def merge_to_main(self, auth_header: str, request: "scout_template_api_MergeToMainRequest", template_rid: str) -> "scout_template_api_Template":
        """Merges the given branch to the "main" branch.
Throws if the template or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you merge on an archived template.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'templateRid': quote(str(_conjure_encoder.default(template_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/template/{templateRid}/merge-to-main'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_template_api_Template, self._return_none_for_unknown_union_types)


scout_TemplateService.__name__ = "TemplateService"
scout_TemplateService.__qualname__ = "TemplateService"
scout_TemplateService.__module__ = "nominal_api.scout"


class scout_UnitsService(Service):
    """The Units Service serves as a comprehensive catalog of the units of measurement supported by scout. Units, by 
default, follow the UCUM convention for representation.
    """

    def get_all_units(self, auth_header: str) -> "scout_units_api_GetUnitsResponse":
        """Returns all known units, grouped by the physical property they measure.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/units/v1/units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_units_api_GetUnitsResponse, self._return_none_for_unknown_union_types)

    def get_unit(self, auth_header: str, unit: str) -> Optional["scout_units_api_Unit"]:
        """Returns information for a unit symbol if available. Returns as empty if the provided symbol cannot be parsed.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(unit)

        _path = '/units/v1/units/get-unit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_units_api_Unit], self._return_none_for_unknown_union_types)

    def get_batch_units(self, auth_header: str, units: List[str] = None) -> Dict[str, "scout_units_api_Unit"]:
        """Returns information for the unit symbols if available. If the provided symbol cannot be parsed, it will be 
omitted from the map.
        """
        units = units if units is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(units)

        _path = '/units/v1/units/get-batch-units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_units_api_UnitSymbol, scout_units_api_Unit], self._return_none_for_unknown_union_types)

    def get_commensurable_units(self, auth_header: str, unit: str) -> List["scout_units_api_Unit"]:
        """Returns the set of cataloged units that can be converted to and from the given unit.
No commensurable units does not imply the unit is invalid. Use /get-unit to check for validity.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(unit)

        _path = '/units/v1/units/commensurable-units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_units_api_Unit], self._return_none_for_unknown_union_types)


scout_UnitsService.__name__ = "UnitsService"
scout_UnitsService.__qualname__ = "UnitsService"
scout_UnitsService.__module__ = "nominal_api.scout"


class scout_VersioningService(Service):
    """This is the external-facing portion of VersioningService which
gives clients access to functionality that doesn't create new
commits. The creation of new commits should be done via the
resource-specific services.
    """

    def create_branch(self, auth_header: str, request: "scout_versioning_api_CreateBranchRequest", resource_rid: str) -> "scout_versioning_api_Branch":
        """Creates a mutable pointer to the provided commit.
"Saves"/"commits" can be performed on this pointer.
Throws if the name is already used as a commit
pointer for this resource.
Throws if the provided commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/versioning/{resourceRid}/branch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Branch, self._return_none_for_unknown_union_types)

    def create_tag(self, auth_header: str, request: "scout_versioning_api_CreateTagRequest", resource_rid: str) -> "scout_versioning_api_Tag":
        """Creates an immutable pointer to the provided commit.
Throws if the name is already used as a commit
pointer for this resource.
Throws if the provided commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/versioning/{resourceRid}/tag'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Tag, self._return_none_for_unknown_union_types)

    def get_commit(self, auth_header: str, commit_id: str, resource_rid: str) -> "scout_versioning_api_Commit":
        """Throws if the commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'commitId': quote(str(_conjure_encoder.default(commit_id)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/commit/{commitId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def batch_get_commits(self, auth_header: str, resource_and_commit_ids: List["scout_versioning_api_ResourceAndCommitId"] = None) -> List["scout_versioning_api_Commit"]:
        """Filters out resources that are not authorized.
        """
        resource_and_commit_ids = resource_and_commit_ids if resource_and_commit_ids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(resource_and_commit_ids)

        _path = '/scout/v1/versioning/commit/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Commit], self._return_none_for_unknown_union_types)

    def get_commit_by_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> "scout_versioning_api_Commit":
        """Returns the commit pointed to by the branch.
Throws if the branch doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'branchName': quote(str(_conjure_encoder.default(branch_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def get_commit_by_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> "scout_versioning_api_Commit":
        """Returns the commit pointed to by the tag.
Throws if the tag doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'tagName': quote(str(_conjure_encoder.default(tag_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Commit, self._return_none_for_unknown_union_types)

    def get_least_common_ancestor(self, auth_header: str, request: "scout_versioning_api_GetLeastCommonAncestorRequest", resource_rid: str) -> str:
        """Returns the least common ancestor of the two commits.
Throws if either commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/versioning/{resourceRid}/commit/least-common-ancestor'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_CommitId, self._return_none_for_unknown_union_types)

    def get_commit_history(self, auth_header: str, commit_id: str, resource_rid: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> "scout_versioning_api_CommitHistory":
        """Returns the commit history sorted by creation time descending.
Excludes working state commits.
Throws if the commit doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'pageSize': _conjure_encoder.default(page_size),
            'nextPageToken': _conjure_encoder.default(next_page_token),
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'commitId': quote(str(_conjure_encoder.default(commit_id)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/commit/{commitId}/history'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_CommitHistory, self._return_none_for_unknown_union_types)

    def persist_commits(self, auth_header: str, request: List["scout_versioning_api_ResourceAndCommitId"] = None) -> None:
        """Persists the commits so that they are not compacted.
This operation is atomic - either all commits are persisted
or none are (in the case of an error).
        """
        request = request if request is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/versioning/commit/persist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> "scout_versioning_api_Branch":
        """Throws if the branch doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'branchName': quote(str(_conjure_encoder.default(branch_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Branch, self._return_none_for_unknown_union_types)

    def get_branches(self, auth_header: str, resource_rid: str) -> List["scout_versioning_api_Branch"]:
        """Returns all branches for the resource in order of
most recently updated.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Branch], self._return_none_for_unknown_union_types)

    def batch_get_branches(self, auth_header: str, resource_and_branches: List["scout_versioning_api_ResourceAndBranchName"] = None) -> List["scout_versioning_api_Branch"]:
        """Omits branches that are not authorized.
        """
        resource_and_branches = resource_and_branches if resource_and_branches is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(resource_and_branches)

        _path = '/scout/v1/versioning/branch/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Branch], self._return_none_for_unknown_union_types)

    def get_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> "scout_versioning_api_Tag":
        """Throws if the tag doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'tagName': quote(str(_conjure_encoder.default(tag_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_versioning_api_Tag, self._return_none_for_unknown_union_types)

    def batch_get_tags(self, auth_header: str, resource_and_commits: List["scout_versioning_api_ResourceAndCommitId"] = None) -> List["scout_versioning_api_Tag"]:
        """Omits tags that are not authorized.
        """
        resource_and_commits = resource_and_commits if resource_and_commits is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(resource_and_commits)

        _path = '/scout/v1/versioning/tag/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Tag], self._return_none_for_unknown_union_types)

    def get_tags_by_resource(self, auth_header: str, resource_rid: str) -> List["scout_versioning_api_Tag"]:
        """Returns all tags for the resource in order of
most recently created.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_versioning_api_Tag], self._return_none_for_unknown_union_types)

    def delete_branch(self, auth_header: str, branch_name: str, resource_rid: str) -> None:
        """Deletes the branch pointer.
Throws if the branch doesn't exist.
Throws if you attempt to delete the "main" branch.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'branchName': quote(str(_conjure_encoder.default(branch_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/branch/{branchName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete_branches(self, auth_header: str, resource_and_branches: List["scout_versioning_api_ResourceAndBranchName"] = None) -> None:
        """Deletes the branch pointers.
Throws if any resource or branch is non-existent
or unauthorized.
Throws if any attempt is made to delete "main".
        """
        resource_and_branches = resource_and_branches if resource_and_branches is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(resource_and_branches)

        _path = '/scout/v1/versioning/branch/batch-delete'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def delete_tag(self, auth_header: str, resource_rid: str, tag_name: str) -> None:
        """Deletes the tag pointer.
Throws if the tag doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'resourceRid': quote(str(_conjure_encoder.default(resource_rid)), safe=''),
            'tagName': quote(str(_conjure_encoder.default(tag_name)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/versioning/{resourceRid}/tag/{tagName}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_VersioningService.__name__ = "VersioningService"
scout_VersioningService.__qualname__ = "VersioningService"
scout_VersioningService.__module__ = "nominal_api.scout"


class scout_api_ChannelLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_ref': ConjureFieldDefinition('dataSourceRef', scout_api_DataSourceRefName),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRefName]),
            'run': ConjureFieldDefinition('run', OptionalTypeWrapper[scout_rids_api_RunRefName])
        }

    __slots__: List[str] = ['_data_source_ref', '_channel', '_tags', '_asset', '_run']

    def __init__(self, channel: str, data_source_ref: str, tags: Dict[str, str], asset: Optional[str] = None, run: Optional[str] = None) -> None:
        self._data_source_ref = data_source_ref
        self._channel = channel
        self._tags = tags
        self._asset = asset
        self._run = run

    @builtins.property
    def data_source_ref(self) -> str:
        return self._data_source_ref

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def run(self) -> Optional[str]:
        return self._run


scout_api_ChannelLocator.__name__ = "ChannelLocator"
scout_api_ChannelLocator.__qualname__ = "ChannelLocator"
scout_api_ChannelLocator.__module__ = "nominal_api.scout_api"


class scout_api_ClosedWithFurtherActionDispositionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_closed_by']

    def __init__(self, closed_by: str) -> None:
        self._closed_by = closed_by

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_api_ClosedWithFurtherActionDispositionState.__name__ = "ClosedWithFurtherActionDispositionState"
scout_api_ClosedWithFurtherActionDispositionState.__qualname__ = "ClosedWithFurtherActionDispositionState"
scout_api_ClosedWithFurtherActionDispositionState.__module__ = "nominal_api.scout_api"


class scout_api_ClosedWithIgnoreDispositionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_closed_by']

    def __init__(self, closed_by: str) -> None:
        self._closed_by = closed_by

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_api_ClosedWithIgnoreDispositionState.__name__ = "ClosedWithIgnoreDispositionState"
scout_api_ClosedWithIgnoreDispositionState.__qualname__ = "ClosedWithIgnoreDispositionState"
scout_api_ClosedWithIgnoreDispositionState.__module__ = "nominal_api.scout_api"


class scout_api_Color(ConjureUnionType):
    _hex_code: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'hex_code': ConjureFieldDefinition('hexCode', str)
        }

    def __init__(
            self,
            hex_code: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (hex_code is not None) != 1:
                raise ValueError('a union must contain a single member')

            if hex_code is not None:
                self._hex_code = hex_code
                self._type = 'hexCode'

        elif type_of_union == 'hexCode':
            if hex_code is None:
                raise ValueError('a union value must not be None')
            self._hex_code = hex_code
            self._type = 'hexCode'

    @builtins.property
    def hex_code(self) -> Optional[str]:
        return self._hex_code

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_api_ColorVisitor):
            raise ValueError('{} is not an instance of scout_api_ColorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'hexCode' and self.hex_code is not None:
            return visitor._hex_code(self.hex_code)


scout_api_Color.__name__ = "Color"
scout_api_Color.__qualname__ = "Color"
scout_api_Color.__module__ = "nominal_api.scout_api"


class scout_api_ColorVisitor:

    @abstractmethod
    def _hex_code(self, hex_code: str) -> Any:
        pass


scout_api_ColorVisitor.__name__ = "ColorVisitor"
scout_api_ColorVisitor.__qualname__ = "ColorVisitor"
scout_api_ColorVisitor.__module__ = "nominal_api.scout_api"


class scout_api_DispositionState(ConjureUnionType):
    _pending_review: Optional["scout_api_PendingReviewDispositionState"] = None
    _closed_with_further_action: Optional["scout_api_ClosedWithFurtherActionDispositionState"] = None
    _closed_with_ignore: Optional["scout_api_ClosedWithIgnoreDispositionState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', scout_api_PendingReviewDispositionState),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', scout_api_ClosedWithFurtherActionDispositionState),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', scout_api_ClosedWithIgnoreDispositionState)
        }

    def __init__(
            self,
            pending_review: Optional["scout_api_PendingReviewDispositionState"] = None,
            closed_with_further_action: Optional["scout_api_ClosedWithFurtherActionDispositionState"] = None,
            closed_with_ignore: Optional["scout_api_ClosedWithIgnoreDispositionState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_review is not None) + (closed_with_further_action is not None) + (closed_with_ignore is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_review is not None:
                self._pending_review = pending_review
                self._type = 'pendingReview'
            if closed_with_further_action is not None:
                self._closed_with_further_action = closed_with_further_action
                self._type = 'closedWithFurtherAction'
            if closed_with_ignore is not None:
                self._closed_with_ignore = closed_with_ignore
                self._type = 'closedWithIgnore'

        elif type_of_union == 'pendingReview':
            if pending_review is None:
                raise ValueError('a union value must not be None')
            self._pending_review = pending_review
            self._type = 'pendingReview'
        elif type_of_union == 'closedWithFurtherAction':
            if closed_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._closed_with_further_action = closed_with_further_action
            self._type = 'closedWithFurtherAction'
        elif type_of_union == 'closedWithIgnore':
            if closed_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._closed_with_ignore = closed_with_ignore
            self._type = 'closedWithIgnore'

    @builtins.property
    def pending_review(self) -> Optional["scout_api_PendingReviewDispositionState"]:
        return self._pending_review

    @builtins.property
    def closed_with_further_action(self) -> Optional["scout_api_ClosedWithFurtherActionDispositionState"]:
        return self._closed_with_further_action

    @builtins.property
    def closed_with_ignore(self) -> Optional["scout_api_ClosedWithIgnoreDispositionState"]:
        return self._closed_with_ignore

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_api_DispositionStateVisitor):
            raise ValueError('{} is not an instance of scout_api_DispositionStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingReview' and self.pending_review is not None:
            return visitor._pending_review(self.pending_review)
        if self._type == 'closedWithFurtherAction' and self.closed_with_further_action is not None:
            return visitor._closed_with_further_action(self.closed_with_further_action)
        if self._type == 'closedWithIgnore' and self.closed_with_ignore is not None:
            return visitor._closed_with_ignore(self.closed_with_ignore)


scout_api_DispositionState.__name__ = "DispositionState"
scout_api_DispositionState.__qualname__ = "DispositionState"
scout_api_DispositionState.__module__ = "nominal_api.scout_api"


class scout_api_DispositionStateVisitor:

    @abstractmethod
    def _pending_review(self, pending_review: "scout_api_PendingReviewDispositionState") -> Any:
        pass

    @abstractmethod
    def _closed_with_further_action(self, closed_with_further_action: "scout_api_ClosedWithFurtherActionDispositionState") -> Any:
        pass

    @abstractmethod
    def _closed_with_ignore(self, closed_with_ignore: "scout_api_ClosedWithIgnoreDispositionState") -> Any:
        pass


scout_api_DispositionStateVisitor.__name__ = "DispositionStateVisitor"
scout_api_DispositionStateVisitor.__qualname__ = "DispositionStateVisitor"
scout_api_DispositionStateVisitor.__module__ = "nominal_api.scout_api"


class scout_api_PendingReviewDispositionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'opened_by': ConjureFieldDefinition('openedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_opened_by']

    def __init__(self, opened_by: str) -> None:
        self._opened_by = opened_by

    @builtins.property
    def opened_by(self) -> str:
        return self._opened_by


scout_api_PendingReviewDispositionState.__name__ = "PendingReviewDispositionState"
scout_api_PendingReviewDispositionState.__qualname__ = "PendingReviewDispositionState"
scout_api_PendingReviewDispositionState.__module__ = "nominal_api.scout_api"


class scout_api_Priority(ConjureEnumType):

    P0 = 'P0'
    '''P0'''
    P1 = 'P1'
    '''P1'''
    P2 = 'P2'
    '''P2'''
    P3 = 'P3'
    '''P3'''
    P4 = 'P4'
    '''P4'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_api_Priority.__name__ = "Priority"
scout_api_Priority.__qualname__ = "Priority"
scout_api_Priority.__module__ = "nominal_api.scout_api"


class scout_api_Symbol(ConjureUnionType):
    _icon: Optional[str] = None
    _emoji: Optional[str] = None
    _image: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'icon': ConjureFieldDefinition('icon', str),
            'emoji': ConjureFieldDefinition('emoji', str),
            'image': ConjureFieldDefinition('image', str)
        }

    def __init__(
            self,
            icon: Optional[str] = None,
            emoji: Optional[str] = None,
            image: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (icon is not None) + (emoji is not None) + (image is not None) != 1:
                raise ValueError('a union must contain a single member')

            if icon is not None:
                self._icon = icon
                self._type = 'icon'
            if emoji is not None:
                self._emoji = emoji
                self._type = 'emoji'
            if image is not None:
                self._image = image
                self._type = 'image'

        elif type_of_union == 'icon':
            if icon is None:
                raise ValueError('a union value must not be None')
            self._icon = icon
            self._type = 'icon'
        elif type_of_union == 'emoji':
            if emoji is None:
                raise ValueError('a union value must not be None')
            self._emoji = emoji
            self._type = 'emoji'
        elif type_of_union == 'image':
            if image is None:
                raise ValueError('a union value must not be None')
            self._image = image
            self._type = 'image'

    @builtins.property
    def icon(self) -> Optional[str]:
        """Icon name (e.g. castle)
        """
        return self._icon

    @builtins.property
    def emoji(self) -> Optional[str]:
        """Emoji name (e.g. :castle:)
        """
        return self._emoji

    @builtins.property
    def image(self) -> Optional[str]:
        """Image url (e.g. https://example.com/image.png)
        """
        return self._image

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_api_SymbolVisitor):
            raise ValueError('{} is not an instance of scout_api_SymbolVisitor'.format(visitor.__class__.__name__))
        if self._type == 'icon' and self.icon is not None:
            return visitor._icon(self.icon)
        if self._type == 'emoji' and self.emoji is not None:
            return visitor._emoji(self.emoji)
        if self._type == 'image' and self.image is not None:
            return visitor._image(self.image)


scout_api_Symbol.__name__ = "Symbol"
scout_api_Symbol.__qualname__ = "Symbol"
scout_api_Symbol.__module__ = "nominal_api.scout_api"


class scout_api_SymbolVisitor:

    @abstractmethod
    def _icon(self, icon: str) -> Any:
        pass

    @abstractmethod
    def _emoji(self, emoji: str) -> Any:
        pass

    @abstractmethod
    def _image(self, image: str) -> Any:
        pass


scout_api_SymbolVisitor.__name__ = "SymbolVisitor"
scout_api_SymbolVisitor.__qualname__ = "SymbolVisitor"
scout_api_SymbolVisitor.__module__ = "nominal_api.scout_api"


class scout_asset_api_AddDataScopesToAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_CreateAssetDataScope])
        }

    __slots__: List[str] = ['_data_scopes']

    def __init__(self, data_scopes: List["scout_asset_api_CreateAssetDataScope"]) -> None:
        self._data_scopes = data_scopes

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_CreateAssetDataScope"]:
        """The data scopes to add to the asset.

Throws if any existing data scopes have data scope names that conflict with the data scope names
in the request.
        """
        return self._data_scopes


scout_asset_api_AddDataScopesToAssetRequest.__name__ = "AddDataScopesToAssetRequest"
scout_asset_api_AddDataScopesToAssetRequest.__qualname__ = "AddDataScopesToAssetRequest"
scout_asset_api_AddDataScopesToAssetRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_Asset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_AssetRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_DataScope]),
            'created_by': ConjureFieldDefinition('createdBy', OptionalTypeWrapper[str]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid]),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[scout_rids_api_TypeRid]),
            'is_staged': ConjureFieldDefinition('isStaged', bool),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_properties', '_labels', '_links', '_data_scopes', '_created_by', '_created_at', '_updated_at', '_attachments', '_type', '_is_staged', '_is_archived']

    def __init__(self, attachments: List[str], created_at: str, data_scopes: List["scout_asset_api_DataScope"], is_archived: bool, is_staged: bool, labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], rid: str, title: str, updated_at: str, created_by: Optional[str] = None, description: Optional[str] = None, type: Optional[str] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at
        self._attachments = attachments
        self._type = type
        self._is_staged = is_staged
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        """Labels associated with the asset. These labels do not have a time dimension.
To associate labels with a range of time, create a time range on the asset with labels.
        """
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        """Links associated with the asset. These links do not have a time dimension.
To associate links with a range of time, create a time range on the asset with links.
        """
        return self._links

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_DataScope"]:
        """The data scopes associated with the asset.
        """
        return self._data_scopes

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def type(self) -> Optional[str]:
        return self._type

    @builtins.property
    def is_staged(self) -> bool:
        """Auto created assets are considered staged by default.
        """
        return self._is_staged

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_asset_api_Asset.__name__ = "Asset"
scout_asset_api_Asset.__qualname__ = "Asset"
scout_asset_api_Asset.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_AssetSortField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_asset_api_AssetSortField.__name__ = "AssetSortField"
scout_asset_api_AssetSortField.__qualname__ = "AssetSortField"
scout_asset_api_AssetSortField.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_AssetSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', OptionalTypeWrapper[scout_asset_api_AssetSortField]),
            'sort_key': ConjureFieldDefinition('sortKey', OptionalTypeWrapper[scout_asset_api_SortKey])
        }

    __slots__: List[str] = ['_is_descending', '_field', '_sort_key']

    def __init__(self, is_descending: bool, field: Optional["scout_asset_api_AssetSortField"] = None, sort_key: Optional["scout_asset_api_SortKey"] = None) -> None:
        self._is_descending = is_descending
        self._field = field
        self._sort_key = sort_key

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> Optional["scout_asset_api_AssetSortField"]:
        return self._field

    @builtins.property
    def sort_key(self) -> Optional["scout_asset_api_SortKey"]:
        """Field to sort by. Includes both field and property-based sorting.
Must be supplied if field is not provided separately.
        """
        return self._sort_key


scout_asset_api_AssetSortOptions.__name__ = "AssetSortOptions"
scout_asset_api_AssetSortOptions.__qualname__ = "AssetSortOptions"
scout_asset_api_AssetSortOptions.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_AssetTypeDataScopeConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'suggested_ref_name': ConjureFieldDefinition('suggestedRefName', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', scout_asset_api_TagConfig)
        }

    __slots__: List[str] = ['_suggested_ref_name', '_tags']

    def __init__(self, tags: "scout_asset_api_TagConfig", suggested_ref_name: Optional[str] = None) -> None:
        self._suggested_ref_name = suggested_ref_name
        self._tags = tags

    @builtins.property
    def suggested_ref_name(self) -> Optional[str]:
        return self._suggested_ref_name

    @builtins.property
    def tags(self) -> "scout_asset_api_TagConfig":
        """Tag names that should be supplied to downscope data for an asset of the asset type. These are not 
enforced.
        """
        return self._tags


scout_asset_api_AssetTypeDataScopeConfig.__name__ = "AssetTypeDataScopeConfig"
scout_asset_api_AssetTypeDataScopeConfig.__qualname__ = "AssetTypeDataScopeConfig"
scout_asset_api_AssetTypeDataScopeConfig.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_AssetTypesFilter(ConjureBeanType):
    """returns runs that match any of the provided assetTypes.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_types': ConjureFieldDefinition('assetTypes', List[scout_rids_api_TypeRid])
        }

    __slots__: List[str] = ['_asset_types']

    def __init__(self, asset_types: List[str]) -> None:
        self._asset_types = asset_types

    @builtins.property
    def asset_types(self) -> List[str]:
        return self._asset_types


scout_asset_api_AssetTypesFilter.__name__ = "AssetTypesFilter"
scout_asset_api_AssetTypesFilter.__qualname__ = "AssetTypesFilter"
scout_asset_api_AssetTypesFilter.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_asset_api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_run_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[api_SeriesDataType])
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type']

    def __init__(self, data_source: "scout_run_api_DataSource", name: str, data_type: Optional["api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["scout_run_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["scout_run_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["api_SeriesDataType"]:
        return self._data_type


scout_asset_api_ChannelMetadata.__name__ = "ChannelMetadata"
scout_asset_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
scout_asset_api_ChannelMetadata.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_CreateAssetDataScope(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_api_DataSourceRefName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_scope_name', '_data_source', '_offset', '_series_tags']

    def __init__(self, data_scope_name: str, data_source: "scout_run_api_DataSource", series_tags: Dict[str, str], offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_scope_name = data_scope_name
        self._data_source = data_source
        self._offset = offset
        self._series_tags = series_tags

    @builtins.property
    def data_scope_name(self) -> str:
        """The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
        """
        return self._data_scope_name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """Filters the data source to series matching these tag values. The filtered set of series should be
the ones that belong to the asset.
        """
        return self._series_tags


scout_asset_api_CreateAssetDataScope.__name__ = "CreateAssetDataScope"
scout_asset_api_CreateAssetDataScope.__qualname__ = "CreateAssetDataScope"
scout_asset_api_CreateAssetDataScope.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_CreateAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'data_scopes': ConjureFieldDefinition('dataScopes', List[scout_asset_api_CreateAssetDataScope]),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid]),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[scout_rids_api_TypeRid]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels', '_links', '_data_scopes', '_attachments', '_type', '_workspace']

    def __init__(self, attachments: List[str], data_scopes: List["scout_asset_api_CreateAssetDataScope"], labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], title: str, description: Optional[str] = None, type: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes
        self._attachments = attachments
        self._type = type
        self._workspace = workspace

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def data_scopes(self) -> List["scout_asset_api_CreateAssetDataScope"]:
        """The data scopes associated with the asset.
        """
        return self._data_scopes

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def type(self) -> Optional[str]:
        return self._type

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the asset. If not provided, the asset will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
All data scopes, attachments, and the optional asset type must be in the same workspace.
        """
        return self._workspace


scout_asset_api_CreateAssetRequest.__name__ = "CreateAssetRequest"
scout_asset_api_CreateAssetRequest.__qualname__ = "CreateAssetRequest"
scout_asset_api_CreateAssetRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_CreateTypeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'property_configs': ConjureFieldDefinition('propertyConfigs', Dict[api_PropertyName, scout_asset_api_PropertyConfig]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'icon_name': ConjureFieldDefinition('iconName', OptionalTypeWrapper[str]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'datasource_configs': ConjureFieldDefinition('datasourceConfigs', OptionalTypeWrapper[Dict[api_rids_DataSourceRid, scout_asset_api_AssetTypeDataScopeConfig]])
        }

    __slots__: List[str] = ['_name', '_property_configs', '_description', '_icon_name', '_workspace', '_datasource_configs']

    def __init__(self, name: str, property_configs: Dict[str, "scout_asset_api_PropertyConfig"], datasource_configs: Optional[Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"]] = None, description: Optional[str] = None, icon_name: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._name = name
        self._property_configs = property_configs
        self._description = description
        self._icon_name = icon_name
        self._workspace = workspace
        self._datasource_configs = datasource_configs

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def property_configs(self) -> Dict[str, "scout_asset_api_PropertyConfig"]:
        return self._property_configs

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def icon_name(self) -> Optional[str]:
        return self._icon_name

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the asset type. If not provided, the asset type will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
        """
        return self._workspace

    @builtins.property
    def datasource_configs(self) -> Optional[Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"]]:
        """The configuration outlines what a data scope should provide when added to an asset of this type. It is 
referenced at data scope creation time, but does not actively modify existing data scopes.
        """
        return self._datasource_configs


scout_asset_api_CreateTypeRequest.__name__ = "CreateTypeRequest"
scout_asset_api_CreateTypeRequest.__qualname__ = "CreateTypeRequest"
scout_asset_api_CreateTypeRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_DataScope(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_api_DataSourceRefName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_run_api_WeakTimestampType),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_scope_name', '_data_source', '_offset', '_timestamp_type', '_series_tags']

    def __init__(self, data_scope_name: str, data_source: "scout_run_api_DataSource", series_tags: Dict[str, str], timestamp_type: "scout_run_api_WeakTimestampType", offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_scope_name = data_scope_name
        self._data_source = data_source
        self._offset = offset
        self._timestamp_type = timestamp_type
        self._series_tags = series_tags

    @builtins.property
    def data_scope_name(self) -> str:
        """The name of the data scope. The name is guaranteed to be be unique within the context of an asset.
        """
        return self._data_scope_name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def timestamp_type(self) -> "scout_run_api_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """Filters the data source to series matching these tag values. The filtered set of series should be
the ones that belong to the asset.
        """
        return self._series_tags


scout_asset_api_DataScope.__name__ = "DataScope"
scout_asset_api_DataScope.__qualname__ = "DataScope"
scout_asset_api_DataScope.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_PropertyConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_required': ConjureFieldDefinition('isRequired', bool),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_is_required', '_description']

    def __init__(self, is_required: bool, description: Optional[str] = None) -> None:
        self._is_required = is_required
        self._description = description

    @builtins.property
    def is_required(self) -> bool:
        return self._is_required

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


scout_asset_api_PropertyConfig.__name__ = "PropertyConfig"
scout_asset_api_PropertyConfig.__qualname__ = "PropertyConfig"
scout_asset_api_PropertyConfig.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_RemoveType(ConjureBeanType):
    """The request to remove the type from the asset.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_asset_api_RemoveType.__name__ = "RemoveType"
scout_asset_api_RemoveType.__qualname__ = "RemoveType"
scout_asset_api_RemoveType.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'data_scope_name_filter': ConjureFieldDefinition('dataScopeNameFilter', OptionalTypeWrapper[List[scout_api_DataSourceRefName]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_search_text', '_data_scope_name_filter', '_next_page_token', '_page_size']

    def __init__(self, search_text: str, data_scope_name_filter: Optional[List[str]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._search_text = search_text
        self._data_scope_name_filter = data_scope_name_filter
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def search_text(self) -> str:
        return self._search_text

    @builtins.property
    def data_scope_name_filter(self) -> Optional[List[str]]:
        """If not empty, will filter to channels from the selected data scope names.
        """
        return self._data_scope_name_filter

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 1000. Will throw if larger than 10000. Default pageSize is 100.
        """
        return self._page_size


scout_asset_api_SearchAssetChannelsRequest.__name__ = "SearchAssetChannelsRequest"
scout_asset_api_SearchAssetChannelsRequest.__qualname__ = "SearchAssetChannelsRequest"
scout_asset_api_SearchAssetChannelsRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_asset_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_asset_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_asset_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_asset_api_SearchAssetChannelsResponse.__name__ = "SearchAssetChannelsResponse"
scout_asset_api_SearchAssetChannelsResponse.__qualname__ = "SearchAssetChannelsResponse"
scout_asset_api_SearchAssetChannelsResponse.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _exact_substring: Optional[str] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _type_rid: Optional[str] = None
    _asset_types: Optional["scout_asset_api_AssetTypesFilter"] = None
    _is_staged: Optional[bool] = None
    _archived: Optional[bool] = None
    _and_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None
    _or_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'exact_substring': ConjureFieldDefinition('exactSubstring', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'type_rid': ConjureFieldDefinition('typeRid', scout_rids_api_TypeRid),
            'asset_types': ConjureFieldDefinition('assetTypes', scout_asset_api_AssetTypesFilter),
            'is_staged': ConjureFieldDefinition('isStaged', bool),
            'archived': ConjureFieldDefinition('archived', bool),
            'and_': ConjureFieldDefinition('and', List[scout_asset_api_SearchAssetsQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_asset_api_SearchAssetsQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            exact_substring: Optional[str] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            type_rid: Optional[str] = None,
            asset_types: Optional["scout_asset_api_AssetTypesFilter"] = None,
            is_staged: Optional[bool] = None,
            archived: Optional[bool] = None,
            and_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None,
            or_: Optional[List["scout_asset_api_SearchAssetsQuery"]] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (exact_substring is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (type_rid is not None) + (asset_types is not None) + (is_staged is not None) + (archived is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if exact_substring is not None:
                self._exact_substring = exact_substring
                self._type = 'exactSubstring'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if type_rid is not None:
                self._type_rid = type_rid
                self._type = 'typeRid'
            if asset_types is not None:
                self._asset_types = asset_types
                self._type = 'assetTypes'
            if is_staged is not None:
                self._is_staged = is_staged
                self._type = 'isStaged'
            if archived is not None:
                self._archived = archived
                self._type = 'archived'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'exactSubstring':
            if exact_substring is None:
                raise ValueError('a union value must not be None')
            self._exact_substring = exact_substring
            self._type = 'exactSubstring'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'typeRid':
            if type_rid is None:
                raise ValueError('a union value must not be None')
            self._type_rid = type_rid
            self._type = 'typeRid'
        elif type_of_union == 'assetTypes':
            if asset_types is None:
                raise ValueError('a union value must not be None')
            self._asset_types = asset_types
            self._type = 'assetTypes'
        elif type_of_union == 'isStaged':
            if is_staged is None:
                raise ValueError('a union value must not be None')
            self._is_staged = is_staged
            self._type = 'isStaged'
        elif type_of_union == 'archived':
            if archived is None:
                raise ValueError('a union value must not be None')
            self._archived = archived
            self._type = 'archived'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def exact_substring(self) -> Optional[str]:
        """An case-insensitive substring match of the title or description of the asset.
        """
        return self._exact_substring

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def type_rid(self) -> Optional[str]:
        return self._type_rid

    @builtins.property
    def asset_types(self) -> Optional["scout_asset_api_AssetTypesFilter"]:
        return self._asset_types

    @builtins.property
    def is_staged(self) -> Optional[bool]:
        return self._is_staged

    @builtins.property
    def archived(self) -> Optional[bool]:
        return self._archived

    @builtins.property
    def and_(self) -> Optional[List["scout_asset_api_SearchAssetsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_asset_api_SearchAssetsQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_SearchAssetsQueryVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_SearchAssetsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'exactSubstring' and self.exact_substring is not None:
            return visitor._exact_substring(self.exact_substring)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'typeRid' and self.type_rid is not None:
            return visitor._type_rid(self.type_rid)
        if self._type == 'assetTypes' and self.asset_types is not None:
            return visitor._asset_types(self.asset_types)
        if self._type == 'isStaged' and self.is_staged is not None:
            return visitor._is_staged(self.is_staged)
        if self._type == 'archived' and self.archived is not None:
            return visitor._archived(self.archived)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


scout_asset_api_SearchAssetsQuery.__name__ = "SearchAssetsQuery"
scout_asset_api_SearchAssetsQuery.__qualname__ = "SearchAssetsQuery"
scout_asset_api_SearchAssetsQuery.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _exact_substring(self, exact_substring: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _type_rid(self, type_rid: str) -> Any:
        pass

    @abstractmethod
    def _asset_types(self, asset_types: "scout_asset_api_AssetTypesFilter") -> Any:
        pass

    @abstractmethod
    def _is_staged(self, is_staged: bool) -> Any:
        pass

    @abstractmethod
    def _archived(self, archived: bool) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_asset_api_SearchAssetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_asset_api_SearchAssetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


scout_asset_api_SearchAssetsQueryVisitor.__name__ = "SearchAssetsQueryVisitor"
scout_asset_api_SearchAssetsQueryVisitor.__qualname__ = "SearchAssetsQueryVisitor"
scout_asset_api_SearchAssetsQueryVisitor.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_asset_api_AssetSortOptions),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'query': ConjureFieldDefinition('query', scout_asset_api_SearchAssetsQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, query: "scout_asset_api_SearchAssetsQuery", sort: "scout_asset_api_AssetSortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "scout_asset_api_AssetSortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_asset_api_SearchAssetsQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search.
        """
        return self._archived_statuses


scout_asset_api_SearchAssetsRequest.__name__ = "SearchAssetsRequest"
scout_asset_api_SearchAssetsRequest.__qualname__ = "SearchAssetsRequest"
scout_asset_api_SearchAssetsRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchAssetsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_asset_api_Asset]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_asset_api_Asset"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_asset_api_Asset"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_asset_api_SearchAssetsResponse.__name__ = "SearchAssetsResponse"
scout_asset_api_SearchAssetsResponse.__qualname__ = "SearchAssetsResponse"
scout_asset_api_SearchAssetsResponse.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchTypesQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _property: Optional[str] = None
    _and_: Optional[List["scout_asset_api_SearchTypesQuery"]] = None
    _or_: Optional[List["scout_asset_api_SearchTypesQuery"]] = None
    _workspace: Optional[str] = None
    _configured_datasource: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'property': ConjureFieldDefinition('property', api_PropertyName),
            'and_': ConjureFieldDefinition('and', List[scout_asset_api_SearchTypesQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_asset_api_SearchTypesQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'configured_datasource': ConjureFieldDefinition('configuredDatasource', api_rids_DataSourceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            property: Optional[str] = None,
            and_: Optional[List["scout_asset_api_SearchTypesQuery"]] = None,
            or_: Optional[List["scout_asset_api_SearchTypesQuery"]] = None,
            workspace: Optional[str] = None,
            configured_datasource: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) + (configured_datasource is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if configured_datasource is not None:
                self._configured_datasource = configured_datasource
                self._type = 'configuredDatasource'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'configuredDatasource':
            if configured_datasource is None:
                raise ValueError('a union value must not be None')
            self._configured_datasource = configured_datasource
            self._type = 'configuredDatasource'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def property(self) -> Optional[str]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_asset_api_SearchTypesQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_asset_api_SearchTypesQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def configured_datasource(self) -> Optional[str]:
        return self._configured_datasource

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_SearchTypesQueryVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_SearchTypesQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'configuredDatasource' and self.configured_datasource is not None:
            return visitor._configured_datasource(self.configured_datasource)


scout_asset_api_SearchTypesQuery.__name__ = "SearchTypesQuery"
scout_asset_api_SearchTypesQuery.__qualname__ = "SearchTypesQuery"
scout_asset_api_SearchTypesQuery.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchTypesQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: str) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_asset_api_SearchTypesQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_asset_api_SearchTypesQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _configured_datasource(self, configured_datasource: str) -> Any:
        pass


scout_asset_api_SearchTypesQueryVisitor.__name__ = "SearchTypesQueryVisitor"
scout_asset_api_SearchTypesQueryVisitor.__qualname__ = "SearchTypesQueryVisitor"
scout_asset_api_SearchTypesQueryVisitor.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchTypesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_asset_api_TypeSortOptions),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'query': ConjureFieldDefinition('query', scout_asset_api_SearchTypesQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, query: "scout_asset_api_SearchTypesQuery", sort: "scout_asset_api_TypeSortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "scout_asset_api_TypeSortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_asset_api_SearchTypesQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        return self._archived_statuses


scout_asset_api_SearchTypesRequest.__name__ = "SearchTypesRequest"
scout_asset_api_SearchTypesRequest.__qualname__ = "SearchTypesRequest"
scout_asset_api_SearchTypesRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SearchTypesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_asset_api_Type]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_asset_api_Type"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_asset_api_Type"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_asset_api_SearchTypesResponse.__name__ = "SearchTypesResponse"
scout_asset_api_SearchTypesResponse.__qualname__ = "SearchTypesResponse"
scout_asset_api_SearchTypesResponse.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SortKey(ConjureUnionType):
    _field: Optional["scout_asset_api_AssetSortField"] = None
    _property: Optional["scout_asset_api_SortProperty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field': ConjureFieldDefinition('field', scout_asset_api_AssetSortField),
            'property': ConjureFieldDefinition('property', scout_asset_api_SortProperty)
        }

    def __init__(
            self,
            field: Optional["scout_asset_api_AssetSortField"] = None,
            property: Optional["scout_asset_api_SortProperty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (field is not None) + (property is not None) != 1:
                raise ValueError('a union must contain a single member')

            if field is not None:
                self._field = field
                self._type = 'field'
            if property is not None:
                self._property = property
                self._type = 'property'

        elif type_of_union == 'field':
            if field is None:
                raise ValueError('a union value must not be None')
            self._field = field
            self._type = 'field'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'

    @builtins.property
    def field(self) -> Optional["scout_asset_api_AssetSortField"]:
        return self._field

    @builtins.property
    def property(self) -> Optional["scout_asset_api_SortProperty"]:
        return self._property

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_SortKeyVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_SortKeyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'field' and self.field is not None:
            return visitor._field(self.field)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)


scout_asset_api_SortKey.__name__ = "SortKey"
scout_asset_api_SortKey.__qualname__ = "SortKey"
scout_asset_api_SortKey.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SortKeyVisitor:

    @abstractmethod
    def _field(self, field: "scout_asset_api_AssetSortField") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_asset_api_SortProperty") -> Any:
        pass


scout_asset_api_SortKeyVisitor.__name__ = "SortKeyVisitor"
scout_asset_api_SortKeyVisitor.__qualname__ = "SortKeyVisitor"
scout_asset_api_SortKeyVisitor.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_SortProperty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_PropertyName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_asset_api_SortProperty.__name__ = "SortProperty"
scout_asset_api_SortProperty.__qualname__ = "SortProperty"
scout_asset_api_SortProperty.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_TagConfig(ConjureUnionType):
    _v1: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', List[api_TagName])
        }

    def __init__(
            self,
            v1: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional[List[str]]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_TagConfigVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_TagConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_asset_api_TagConfig.__name__ = "TagConfig"
scout_asset_api_TagConfig.__qualname__ = "TagConfig"
scout_asset_api_TagConfig.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_TagConfigVisitor:

    @abstractmethod
    def _v1(self, v1: List[str]) -> Any:
        pass


scout_asset_api_TagConfigVisitor.__name__ = "TagConfigVisitor"
scout_asset_api_TagConfigVisitor.__qualname__ = "TagConfigVisitor"
scout_asset_api_TagConfigVisitor.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_Type(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TypeRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'property_configs': ConjureFieldDefinition('propertyConfigs', Dict[api_PropertyName, scout_asset_api_PropertyConfig]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'icon_name': ConjureFieldDefinition('iconName', OptionalTypeWrapper[str]),
            'datasource_configs': ConjureFieldDefinition('datasourceConfigs', Dict[api_rids_DataSourceRid, scout_asset_api_AssetTypeDataScopeConfig])
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_property_configs', '_created_at', '_icon_name', '_datasource_configs']

    def __init__(self, created_at: str, datasource_configs: Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"], name: str, property_configs: Dict[str, "scout_asset_api_PropertyConfig"], rid: str, description: Optional[str] = None, icon_name: Optional[str] = None) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._property_configs = property_configs
        self._created_at = created_at
        self._icon_name = icon_name
        self._datasource_configs = datasource_configs

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def property_configs(self) -> Dict[str, "scout_asset_api_PropertyConfig"]:
        return self._property_configs

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def icon_name(self) -> Optional[str]:
        """The name of the icon to display for the type. This name maps to a Lucide icon in the frontend.
        """
        return self._icon_name

    @builtins.property
    def datasource_configs(self) -> Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"]:
        """The configuration outlines what a data scope should provide when added to an asset of this type. It is 
referenced at data scope creation time, but does not actively modify existing data scopes.
        """
        return self._datasource_configs


scout_asset_api_Type.__name__ = "Type"
scout_asset_api_Type.__qualname__ = "Type"
scout_asset_api_Type.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_TypeSortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_asset_api_TypeSortField.__name__ = "TypeSortField"
scout_asset_api_TypeSortField.__qualname__ = "TypeSortField"
scout_asset_api_TypeSortField.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_TypeSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_asset_api_TypeSortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_asset_api_TypeSortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_asset_api_TypeSortField":
        return self._field


scout_asset_api_TypeSortOptions.__name__ = "TypeSortOptions"
scout_asset_api_TypeSortOptions.__qualname__ = "TypeSortOptions"
scout_asset_api_TypeSortOptions.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateAssetRefNamesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope_ref_name_updates': ConjureFieldDefinition('dataScopeRefNameUpdates', Dict[scout_api_DataSourceRefName, scout_api_DataSourceRefName])
        }

    __slots__: List[str] = ['_data_scope_ref_name_updates']

    def __init__(self, data_scope_ref_name_updates: Dict[str, str]) -> None:
        self._data_scope_ref_name_updates = data_scope_ref_name_updates

    @builtins.property
    def data_scope_ref_name_updates(self) -> Dict[str, str]:
        return self._data_scope_ref_name_updates


scout_asset_api_UpdateAssetRefNamesRequest.__name__ = "UpdateAssetRefNamesRequest"
scout_asset_api_UpdateAssetRefNamesRequest.__qualname__ = "UpdateAssetRefNamesRequest"
scout_asset_api_UpdateAssetRefNamesRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'links': ConjureFieldDefinition('links', OptionalTypeWrapper[List[scout_run_api_Link]]),
            'data_scopes': ConjureFieldDefinition('dataScopes', OptionalTypeWrapper[List[scout_asset_api_CreateAssetDataScope]]),
            'type': ConjureFieldDefinition('type', OptionalTypeWrapper[scout_asset_api_UpdateOrRemoveAssetType]),
            'is_staged': ConjureFieldDefinition('isStaged', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_description', '_properties', '_labels', '_links', '_data_scopes', '_type', '_is_staged']

    def __init__(self, data_scopes: Optional[List["scout_asset_api_CreateAssetDataScope"]] = None, description: Optional[str] = None, is_staged: Optional[bool] = None, labels: Optional[List[str]] = None, links: Optional[List["scout_run_api_Link"]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None, type: Optional["scout_asset_api_UpdateOrRemoveAssetType"] = None) -> None:
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._links = links
        self._data_scopes = data_scopes
        self._type = type
        self._is_staged = is_staged

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def links(self) -> Optional[List["scout_run_api_Link"]]:
        return self._links

    @builtins.property
    def data_scopes(self) -> Optional[List["scout_asset_api_CreateAssetDataScope"]]:
        """The data scopes for the asset. This will replace all existing data scopes with the scopes specified.
        """
        return self._data_scopes

    @builtins.property
    def type(self) -> Optional["scout_asset_api_UpdateOrRemoveAssetType"]:
        return self._type

    @builtins.property
    def is_staged(self) -> Optional[bool]:
        return self._is_staged


scout_asset_api_UpdateAssetRequest.__name__ = "UpdateAssetRequest"
scout_asset_api_UpdateAssetRequest.__qualname__ = "UpdateAssetRequest"
scout_asset_api_UpdateAssetRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachments_to_add': ConjureFieldDefinition('attachmentsToAdd', List[api_rids_AttachmentRid]),
            'attachments_to_remove': ConjureFieldDefinition('attachmentsToRemove', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_attachments_to_add', '_attachments_to_remove']

    def __init__(self, attachments_to_add: List[str], attachments_to_remove: List[str]) -> None:
        self._attachments_to_add = attachments_to_add
        self._attachments_to_remove = attachments_to_remove

    @builtins.property
    def attachments_to_add(self) -> List[str]:
        return self._attachments_to_add

    @builtins.property
    def attachments_to_remove(self) -> List[str]:
        return self._attachments_to_remove


scout_asset_api_UpdateAttachmentsRequest.__name__ = "UpdateAttachmentsRequest"
scout_asset_api_UpdateAttachmentsRequest.__qualname__ = "UpdateAttachmentsRequest"
scout_asset_api_UpdateAttachmentsRequest.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateOrRemoveAssetType(ConjureUnionType):
    """The request to update the type of the asset. The request will replace the existing type with the type
specified in the request if a typeRID is provided. Otherwise, the type will be removed from the asset.
    """
    _type_rid: Optional[str] = None
    _remove_type: Optional["scout_asset_api_RemoveType"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type_rid': ConjureFieldDefinition('typeRid', scout_rids_api_TypeRid),
            'remove_type': ConjureFieldDefinition('removeType', scout_asset_api_RemoveType)
        }

    def __init__(
            self,
            type_rid: Optional[str] = None,
            remove_type: Optional["scout_asset_api_RemoveType"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (type_rid is not None) + (remove_type is not None) != 1:
                raise ValueError('a union must contain a single member')

            if type_rid is not None:
                self._type_rid = type_rid
                self._type = 'typeRid'
            if remove_type is not None:
                self._remove_type = remove_type
                self._type = 'removeType'

        elif type_of_union == 'typeRid':
            if type_rid is None:
                raise ValueError('a union value must not be None')
            self._type_rid = type_rid
            self._type = 'typeRid'
        elif type_of_union == 'removeType':
            if remove_type is None:
                raise ValueError('a union value must not be None')
            self._remove_type = remove_type
            self._type = 'removeType'

    @builtins.property
    def type_rid(self) -> Optional[str]:
        return self._type_rid

    @builtins.property
    def remove_type(self) -> Optional["scout_asset_api_RemoveType"]:
        return self._remove_type

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_asset_api_UpdateOrRemoveAssetTypeVisitor):
            raise ValueError('{} is not an instance of scout_asset_api_UpdateOrRemoveAssetTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'typeRid' and self.type_rid is not None:
            return visitor._type_rid(self.type_rid)
        if self._type == 'removeType' and self.remove_type is not None:
            return visitor._remove_type(self.remove_type)


scout_asset_api_UpdateOrRemoveAssetType.__name__ = "UpdateOrRemoveAssetType"
scout_asset_api_UpdateOrRemoveAssetType.__qualname__ = "UpdateOrRemoveAssetType"
scout_asset_api_UpdateOrRemoveAssetType.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateOrRemoveAssetTypeVisitor:

    @abstractmethod
    def _type_rid(self, type_rid: str) -> Any:
        pass

    @abstractmethod
    def _remove_type(self, remove_type: "scout_asset_api_RemoveType") -> Any:
        pass


scout_asset_api_UpdateOrRemoveAssetTypeVisitor.__name__ = "UpdateOrRemoveAssetTypeVisitor"
scout_asset_api_UpdateOrRemoveAssetTypeVisitor.__qualname__ = "UpdateOrRemoveAssetTypeVisitor"
scout_asset_api_UpdateOrRemoveAssetTypeVisitor.__module__ = "nominal_api.scout_asset_api"


class scout_asset_api_UpdateTypeRequest(ConjureBeanType):
    """The request to update a type. The request will replace all existing properties with the properties
specified in the request.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'property_configs': ConjureFieldDefinition('propertyConfigs', OptionalTypeWrapper[Dict[api_PropertyName, scout_asset_api_PropertyConfig]]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'icon_name': ConjureFieldDefinition('iconName', OptionalTypeWrapper[str]),
            'datasource_configs': ConjureFieldDefinition('datasourceConfigs', OptionalTypeWrapper[Dict[api_rids_DataSourceRid, scout_asset_api_AssetTypeDataScopeConfig]])
        }

    __slots__: List[str] = ['_name', '_property_configs', '_description', '_icon_name', '_datasource_configs']

    def __init__(self, datasource_configs: Optional[Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"]] = None, description: Optional[str] = None, icon_name: Optional[str] = None, name: Optional[str] = None, property_configs: Optional[Dict[str, "scout_asset_api_PropertyConfig"]] = None) -> None:
        self._name = name
        self._property_configs = property_configs
        self._description = description
        self._icon_name = icon_name
        self._datasource_configs = datasource_configs

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def property_configs(self) -> Optional[Dict[str, "scout_asset_api_PropertyConfig"]]:
        return self._property_configs

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def icon_name(self) -> Optional[str]:
        return self._icon_name

    @builtins.property
    def datasource_configs(self) -> Optional[Dict[str, "scout_asset_api_AssetTypeDataScopeConfig"]]:
        """The configuration outlines what a data scope should provide when added to an asset of this type. It is 
referenced at data scope creation time, but does not actively modify existing data scopes.
        """
        return self._datasource_configs


scout_asset_api_UpdateTypeRequest.__name__ = "UpdateTypeRequest"
scout_asset_api_UpdateTypeRequest.__qualname__ = "UpdateTypeRequest"
scout_asset_api_UpdateTypeRequest.__module__ = "nominal_api.scout_asset_api"


class scout_assets_AssetService(Service):
    """An asset is a physical entity within an organization, such as a vehicle or ground station. Assets are comprised
of some metadata about the data, as well as a set of data scopes that define the data belonging to the asset. API
endpoints allow for CRUD operations on asset objects.
    """

    def create_asset(self, auth_header: str, details: "scout_asset_api_CreateAssetRequest") -> "scout_asset_api_Asset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/scout/v1/asset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def update_asset(self, auth_header: str, details: "scout_asset_api_UpdateAssetRequest", rid: str) -> "scout_asset_api_Asset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/scout/v1/asset/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def add_data_scopes_to_asset(self, asset_rid: str, auth_header: str, request: "scout_asset_api_AddDataScopesToAssetRequest") -> "scout_asset_api_Asset":
        """Adds data scopes to an asset.

Throws if the asset already has data scopes with data scope names matching those in the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'assetRid': quote(str(_conjure_encoder.default(asset_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/asset/{assetRid}/data-sources'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Asset, self._return_none_for_unknown_union_types)

    def get_assets(self, auth_header: str, rids: List[str] = None) -> Dict[str, "scout_asset_api_Asset"]:
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v1/asset/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_AssetRid, scout_asset_api_Asset], self._return_none_for_unknown_union_types)

    def get_assets_by_data_source(self, auth_header: str, data_source_rid: str) -> List["scout_asset_api_Asset"]:
        """Returns all assets with given data source as a data scope.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/asset/by-data-source/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_asset_api_Asset], self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, rid: str, include_linked_workbooks: Optional[bool] = None) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeLinkedWorkbooks': _conjure_encoder.default(include_linked_workbooks),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/archive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str, include_linked_workbooks: Optional[bool] = None) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeLinkedWorkbooks': _conjure_encoder.default(include_linked_workbooks),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/unarchive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def search_assets(self, auth_header: str, search_assets_request: "scout_asset_api_SearchAssetsRequest") -> "scout_asset_api_SearchAssetsResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(search_assets_request)

        _path = '/scout/v1/search-assets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_SearchAssetsResponse, self._return_none_for_unknown_union_types)

    def search_types(self, auth_header: str, search_types_request: "scout_asset_api_SearchTypesRequest") -> "scout_asset_api_SearchTypesResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(search_types_request)

        _path = '/scout/v1/search-types'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_SearchTypesResponse, self._return_none_for_unknown_union_types)

    def update_asset_attachments(self, auth_header: str, request: "scout_asset_api_UpdateAttachmentsRequest", rid: str) -> None:
        """Update the attachments associated with an asset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/asset/{rid}/attachments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def update_asset_ref_names(self, auth_header: str, request: "scout_asset_api_UpdateAssetRefNamesRequest", rid: str) -> None:
        """Update the ref names for the data scopes on the asset. This update will also be applied on all associated 
workbooks.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/asset/{rid}/ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def create_type(self, auth_header: str, request: "scout_asset_api_CreateTypeRequest") -> "scout_asset_api_Type":
        """Creates a new type.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/type'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Type, self._return_none_for_unknown_union_types)

    def update_type(self, auth_header: str, request: "scout_asset_api_UpdateTypeRequest", type_rid: str) -> "scout_asset_api_Type":
        """Updates a type. Will throw unless all assets that reference the type pass the updated type check.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'typeRid': quote(str(_conjure_encoder.default(type_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/type/{typeRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_asset_api_Type, self._return_none_for_unknown_union_types)

    def get_types(self, auth_header: str, rids: List[str] = None) -> Dict[str, "scout_asset_api_Type"]:
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v1/type/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_TypeRid, scout_asset_api_Type], self._return_none_for_unknown_union_types)

    def get_types_for_datasource(self, auth_header: str, datasource_rid: str) -> List["scout_asset_api_Type"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(datasource_rid)

        _path = '/scout/v1/type/datasource'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_asset_api_Type], self._return_none_for_unknown_union_types)

    def delete_type(self, auth_header: str, rid: str) -> None:
        """Deletes a type. The type must not be referenced by any assets.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/type/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive_type(self, auth_header: str, rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/type/archive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_type(self, auth_header: str, rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/type/unarchive/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_assets_AssetService.__name__ = "AssetService"
scout_assets_AssetService.__qualname__ = "AssetService"
scout_assets_AssetService.__module__ = "nominal_api.scout_assets"


class scout_catalog_AbsoluteTimestamp(ConjureUnionType):
    _iso8601: Optional["scout_catalog_Iso8601Timestamp"] = None
    _epoch_of_time_unit: Optional["scout_catalog_EpochTimestamp"] = None
    _custom_format: Optional["scout_catalog_CustomTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', scout_catalog_Iso8601Timestamp),
            'epoch_of_time_unit': ConjureFieldDefinition('epochOfTimeUnit', scout_catalog_EpochTimestamp),
            'custom_format': ConjureFieldDefinition('customFormat', scout_catalog_CustomTimestamp)
        }

    def __init__(
            self,
            iso8601: Optional["scout_catalog_Iso8601Timestamp"] = None,
            epoch_of_time_unit: Optional["scout_catalog_EpochTimestamp"] = None,
            custom_format: Optional["scout_catalog_CustomTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (epoch_of_time_unit is not None) + (custom_format is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if epoch_of_time_unit is not None:
                self._epoch_of_time_unit = epoch_of_time_unit
                self._type = 'epochOfTimeUnit'
            if custom_format is not None:
                self._custom_format = custom_format
                self._type = 'customFormat'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'epochOfTimeUnit':
            if epoch_of_time_unit is None:
                raise ValueError('a union value must not be None')
            self._epoch_of_time_unit = epoch_of_time_unit
            self._type = 'epochOfTimeUnit'
        elif type_of_union == 'customFormat':
            if custom_format is None:
                raise ValueError('a union value must not be None')
            self._custom_format = custom_format
            self._type = 'customFormat'

    @builtins.property
    def iso8601(self) -> Optional["scout_catalog_Iso8601Timestamp"]:
        return self._iso8601

    @builtins.property
    def epoch_of_time_unit(self) -> Optional["scout_catalog_EpochTimestamp"]:
        return self._epoch_of_time_unit

    @builtins.property
    def custom_format(self) -> Optional["scout_catalog_CustomTimestamp"]:
        return self._custom_format

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_AbsoluteTimestampVisitor):
            raise ValueError('{} is not an instance of scout_catalog_AbsoluteTimestampVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'epochOfTimeUnit' and self.epoch_of_time_unit is not None:
            return visitor._epoch_of_time_unit(self.epoch_of_time_unit)
        if self._type == 'customFormat' and self.custom_format is not None:
            return visitor._custom_format(self.custom_format)


scout_catalog_AbsoluteTimestamp.__name__ = "AbsoluteTimestamp"
scout_catalog_AbsoluteTimestamp.__qualname__ = "AbsoluteTimestamp"
scout_catalog_AbsoluteTimestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_AbsoluteTimestampVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "scout_catalog_Iso8601Timestamp") -> Any:
        pass

    @abstractmethod
    def _epoch_of_time_unit(self, epoch_of_time_unit: "scout_catalog_EpochTimestamp") -> Any:
        pass

    @abstractmethod
    def _custom_format(self, custom_format: "scout_catalog_CustomTimestamp") -> Any:
        pass


scout_catalog_AbsoluteTimestampVisitor.__name__ = "AbsoluteTimestampVisitor"
scout_catalog_AbsoluteTimestampVisitor.__qualname__ = "AbsoluteTimestampVisitor"
scout_catalog_AbsoluteTimestampVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_AddFileToDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'file_size': ConjureFieldDefinition('fileSize', int),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata]),
            'ingest_tag_metadata': ConjureFieldDefinition('ingestTagMetadata', OptionalTypeWrapper[scout_catalog_IngestTagMetadata]),
            'origin_file_handles': ConjureFieldDefinition('originFileHandles', OptionalTypeWrapper[List[scout_catalog_S3Handle]]),
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', OptionalTypeWrapper[ingest_api_IngestJobRid]),
            'metadata': ConjureFieldDefinition('metadata', OptionalTypeWrapper[scout_catalog_DatasetFileMetadata])
        }

    __slots__: List[str] = ['_handle', '_file_size', '_timestamp_metadata', '_ingest_tag_metadata', '_origin_file_handles', '_ingest_job_rid', '_metadata']

    def __init__(self, file_size: int, handle: "scout_catalog_Handle", ingest_job_rid: Optional[str] = None, ingest_tag_metadata: Optional["scout_catalog_IngestTagMetadata"] = None, metadata: Optional["scout_catalog_DatasetFileMetadata"] = None, origin_file_handles: Optional[List["scout_catalog_S3Handle"]] = None, timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None) -> None:
        self._handle = handle
        self._file_size = file_size
        self._timestamp_metadata = timestamp_metadata
        self._ingest_tag_metadata = ingest_tag_metadata
        self._origin_file_handles = origin_file_handles
        self._ingest_job_rid = ingest_job_rid
        self._metadata = metadata

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def file_size(self) -> int:
        """The size of the file in bytes.
        """
        return self._file_size

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def ingest_tag_metadata(self) -> Optional["scout_catalog_IngestTagMetadata"]:
        return self._ingest_tag_metadata

    @builtins.property
    def origin_file_handles(self) -> Optional[List["scout_catalog_S3Handle"]]:
        return self._origin_file_handles

    @builtins.property
    def ingest_job_rid(self) -> Optional[str]:
        return self._ingest_job_rid

    @builtins.property
    def metadata(self) -> Optional["scout_catalog_DatasetFileMetadata"]:
        """File-type-specific metadata. For video files, contains timestamp manifest.
        """
        return self._metadata


scout_catalog_AddFileToDataset.__name__ = "AddFileToDataset"
scout_catalog_AddFileToDataset.__qualname__ = "AddFileToDataset"
scout_catalog_AddFileToDataset.__module__ = "nominal_api.scout_catalog"


class scout_catalog_AllPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_catalog_AllPropertiesAndLabelsResponse.__name__ = "AllPropertiesAndLabelsResponse"
scout_catalog_AllPropertiesAndLabelsResponse.__qualname__ = "AllPropertiesAndLabelsResponse"
scout_catalog_AllPropertiesAndLabelsResponse.__module__ = "nominal_api.scout_catalog"


class scout_catalog_Bounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'type': ConjureFieldDefinition('type', datasource_TimestampType)
        }

    __slots__: List[str] = ['_start', '_end', '_type']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp", type: "datasource_TimestampType") -> None:
        self._start = start
        self._end = end
        self._type = type

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def type(self) -> "datasource_TimestampType":
        return self._type


scout_catalog_Bounds.__name__ = "Bounds"
scout_catalog_Bounds.__qualname__ = "Bounds"
scout_catalog_Bounds.__module__ = "nominal_api.scout_catalog"


class scout_catalog_CatalogService(Service):
    """The Catalog Service provides the ability to query for information about Datasets that are stored in
the Nominal platform. A Dataset is the Nominal representation of data that has been uploaded to Nominal via
a file, primarily CSV.
    """

    def get_enriched_dataset(self, auth_header: str, dataset_uuid: str) -> "scout_catalog_EnrichedDataset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetUuid': quote(str(_conjure_encoder.default(dataset_uuid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetUuid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def get_enriched_datasets(self, auth_header: str, get_datasets_request: "scout_catalog_GetDatasetsRequest") -> List["scout_catalog_EnrichedDataset"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(get_datasets_request)

        _path = '/catalog/v1/datasets/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_catalog_EnrichedDataset], self._return_none_for_unknown_union_types)

    def get_dataset(self, auth_header: str, dataset_uuid: str) -> "scout_catalog_Dataset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetUuid': quote(str(_conjure_encoder.default(dataset_uuid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets-simple/{datasetUuid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_Dataset, self._return_none_for_unknown_union_types)

    def get_datasets(self, auth_header: str, get_datasets_request: "scout_catalog_GetDatasetsRequest") -> List["scout_catalog_Dataset"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(get_datasets_request)

        _path = '/catalog/v1/datasets-simple/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_catalog_Dataset], self._return_none_for_unknown_union_types)

    def get_dataset_file(self, auth_header: str, dataset_rid: str, file_id: str) -> "scout_catalog_DatasetFile":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/dataset/{datasetRid}/file/{fileId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def get_dataset_files_for_job(self, auth_header: str, ingest_job_rid: str, next_page_token: Optional[str] = None) -> "scout_catalog_DatasetFilesPage":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'nextPageToken': _conjure_encoder.default(next_page_token),
        }

        _path_params: Dict[str, str] = {
            'ingestJobRid': quote(str(_conjure_encoder.default(ingest_job_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/ingest-job/{ingestJobRid}/files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFilesPage, self._return_none_for_unknown_union_types)

    def search_datasets(self, auth_header: str, request: "scout_catalog_SearchDatasetsRequest") -> "scout_catalog_SearchDatasetsResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/search-datasets-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_SearchDatasetsResponse, self._return_none_for_unknown_union_types)

    def update_dataset_ingest_status_v2(self, auth_header: str, details: "scout_catalog_UpdateIngestStatusV2") -> "api_IngestStatusV2":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/catalog/v1/datasets/ingest-status-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), api_IngestStatusV2, self._return_none_for_unknown_union_types)

    def get_ingest_progress_v2(self, auth_header: str, dataset_rid: str) -> "scout_catalog_IngestProgressV2":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/ingest-progress-v2'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_IngestProgressV2, self._return_none_for_unknown_union_types)

    def get_handle_for_dataset(self, auth_header: str, dataset: str) -> Optional["scout_catalog_Handle"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataset': quote(str(_conjure_encoder.default(dataset)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{dataset}/handle'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_catalog_Handle], self._return_none_for_unknown_union_types)

    def create_dataset(self, auth_header: str, details: "scout_catalog_CreateDataset") -> "scout_catalog_EnrichedDataset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/catalog/v1/datasets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def create_or_update_dataset(self, auth_header: str, details: "scout_catalog_CreateDataset") -> "scout_catalog_EnrichedDataset":
        """Creates a dataset if the s3 path does not exist, otherwise updates the dataset
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(details)

        _path = '/catalog/v1/datasets/create-or-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def create_dataset_with_uuid(self, auth_header: str, request: "scout_catalog_CreateDatasetWithUuidRequest") -> "scout_catalog_EnrichedDataset":
        """Creates a dataset with a specific UUID. This is useful for migrations and advanced use cases
where the dataset UUID must be controlled by the caller. Throws a conflict error if a dataset
with the specified UUID already exists. This endpoint is not intended for general use. Use /datasets instead to create a new dataset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/with-uuid'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def add_file_to_dataset(self, auth_header: str, dataset_rid: str, request: "scout_catalog_AddFileToDataset") -> "scout_catalog_DatasetFile":
        """Adds a single file to an existing dataset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/add-file'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def list_dataset_files(self, auth_header: str, dataset_rid: str, next_page_token: Optional[str] = None) -> "scout_catalog_DatasetFilesPage":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'nextPageToken': _conjure_encoder.default(next_page_token),
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFilesPage, self._return_none_for_unknown_union_types)

    def search_dataset_files(self, auth_header: str, request: "scout_catalog_SearchDatasetFilesRequest") -> "scout_catalog_SearchDatasetFilesResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/search-dataset-files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_SearchDatasetFilesResponse, self._return_none_for_unknown_union_types)

    def get_dataset_file_uri(self, auth_header: str, dataset_rid: str, file_id: str) -> "scout_catalog_DatasetFileUri":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/{fileId}/uri'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFileUri, self._return_none_for_unknown_union_types)

    def get_video_file_uri(self, auth_header: str, video_file_rid: str) -> "scout_catalog_VideoFileUri":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/videos/{videoFileRid}/uri'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_VideoFileUri, self._return_none_for_unknown_union_types)

    def get_origin_file_uris(self, auth_header: str, dataset_rid: str, file_id: str) -> List["scout_catalog_OriginFileUri"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/{fileId}/origin-uris'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_catalog_OriginFileUri], self._return_none_for_unknown_union_types)

    def mark_file_ingest_successful(self, auth_header: str, dataset_rid: str, file_id: str, request: "scout_catalog_MarkFileIngestSuccessful") -> "scout_catalog_DatasetFile":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/file/{fileId}/success'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def mark_file_ingest_error(self, auth_header: str, dataset_rid: str, file_id: str, request: "scout_catalog_MarkFileIngestError") -> "scout_catalog_DatasetFile":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{datasetRid}/file/{fileId}/error'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def update_dataset_file_metadata(self, auth_header: str, dataset_rid: str, file_id: str, metadata: "scout_catalog_DatasetFileMetadata") -> "scout_catalog_DatasetFile":
        """Updates file-type-specific metadata for a dataset file. Currently used to update video segment metadata
after video segmentation is complete.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
            'fileId': quote(str(_conjure_encoder.default(file_id)), safe=''),
        }

        _json: Any = _conjure_encoder.default(metadata)

        _path = '/catalog/v1/datasets/{datasetRid}/file/{fileId}/metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_DatasetFile, self._return_none_for_unknown_union_types)

    def update_dataset_metadata(self, auth_header: str, dataset_rid: str, request: "scout_catalog_UpdateDatasetMetadata") -> "scout_catalog_EnrichedDataset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{datasetRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def update_bounds(self, auth_header: str, request: "scout_catalog_UpdateBoundsRequest", rid: str) -> "scout_catalog_EnrichedDataset":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{rid}/bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_EnrichedDataset, self._return_none_for_unknown_union_types)

    def update_global_dataset_bounds(self, auth_header: str, request: "scout_catalog_UpdateBoundsRequest", rid: str) -> "scout_catalog_Dataset":
        """Update the bounds for a dataset without updating bounds of files within the dataset. If the
current bounds of the dataset are not set, then the bounds of the request will be used. Otherwise,
the bounds will be min(current start, request start), max(current end, request end).
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/catalog/v1/datasets/{rid}/bounds-from-streaming'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_Dataset, self._return_none_for_unknown_union_types)

    def archive_dataset(self, auth_header: str, dataset_rid: str) -> None:
        """Archives a dataset, which will hide it from search results unless the includeArchived flag is set to true. The
dataset can still be directly accessed by its UUID/rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_dataset(self, auth_header: str, dataset_rid: str) -> None:
        """Undoes the archiving of a dataset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'datasetRid': quote(str(_conjure_encoder.default(dataset_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/{datasetRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_all_properties_and_labels(self, auth_header: str, workspaces: List[str] = None) -> "scout_catalog_AllPropertiesAndLabelsResponse":
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/catalog/v1/datasets/all-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_catalog_AllPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)

    def get_log_dataset_for_workspace(self, auth_header: str, workspace_rid: str) -> Optional[str]:
        """Returns the log dataset RID for the specified workspace if configured and accessible to the caller.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'workspaceRid': quote(str(_conjure_encoder.default(workspace_rid)), safe=''),
        }

        _json: Any = None

        _path = '/catalog/v1/workspaces/{workspaceRid}/log-dataset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[api_rids_DatasetRid], self._return_none_for_unknown_union_types)


scout_catalog_CatalogService.__name__ = "CatalogService"
scout_catalog_CatalogService.__qualname__ = "CatalogService"
scout_catalog_CatalogService.__module__ = "nominal_api.scout_catalog"


class scout_catalog_Channel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_uuid', '_name', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, name: str, uuid: str) -> None:
        self._uuid = uuid
        self._name = name
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_Channel.__name__ = "Channel"
scout_catalog_Channel.__qualname__ = "Channel"
scout_catalog_Channel.__module__ = "nominal_api.scout_catalog"


class scout_catalog_ChannelConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'prefix_tree_delimiter': ConjureFieldDefinition('prefixTreeDelimiter', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_prefix_tree_delimiter']

    def __init__(self, prefix_tree_delimiter: Optional[str] = None) -> None:
        self._prefix_tree_delimiter = prefix_tree_delimiter

    @builtins.property
    def prefix_tree_delimiter(self) -> Optional[str]:
        """If set, will construct a prefix tree for channels of the dataset using the given delimiter.
        """
        return self._prefix_tree_delimiter


scout_catalog_ChannelConfig.__name__ = "ChannelConfig"
scout_catalog_ChannelConfig.__qualname__ = "ChannelConfig"
scout_catalog_ChannelConfig.__module__ = "nominal_api.scout_catalog"


class scout_catalog_ChannelDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'origin_metadata': ConjureFieldDefinition('originMetadata', Dict[str, str]),
            'csv_index': ConjureFieldDefinition('csvIndex', int),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle)
        }

    __slots__: List[str] = ['_uuid', '_name', '_origin_metadata', '_csv_index', '_dataset_uuid', '_handle']

    def __init__(self, csv_index: int, dataset_uuid: str, handle: "scout_catalog_Handle", name: str, origin_metadata: Dict[str, str], uuid: str) -> None:
        self._uuid = uuid
        self._name = name
        self._origin_metadata = origin_metadata
        self._csv_index = csv_index
        self._dataset_uuid = dataset_uuid
        self._handle = handle

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def origin_metadata(self) -> Dict[str, str]:
        return self._origin_metadata

    @builtins.property
    def csv_index(self) -> int:
        return self._csv_index

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle


scout_catalog_ChannelDetails.__name__ = "ChannelDetails"
scout_catalog_ChannelDetails.__qualname__ = "ChannelDetails"
scout_catalog_ChannelDetails.__module__ = "nominal_api.scout_catalog"


class scout_catalog_CreateDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', OptionalTypeWrapper[scout_catalog_Handle]),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'granularity': ConjureFieldDefinition('granularity', OptionalTypeWrapper[api_Granularity]),
            'is_v2_dataset': ConjureFieldDefinition('isV2Dataset', OptionalTypeWrapper[bool]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'marking_rids': ConjureFieldDefinition('markingRids', List[scout_rids_api_MarkingRid])
        }

    __slots__: List[str] = ['_name', '_handle', '_metadata', '_origin_metadata', '_labels', '_properties', '_description', '_granularity', '_is_v2_dataset', '_workspace', '_marking_rids']

    def __init__(self, labels: List[str], marking_rids: List[str], metadata: Dict[str, str], name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], description: Optional[str] = None, granularity: Optional["api_Granularity"] = None, handle: Optional["scout_catalog_Handle"] = None, is_v2_dataset: Optional[bool] = None, workspace: Optional[str] = None) -> None:
        self._name = name
        self._handle = handle
        self._metadata = metadata
        self._origin_metadata = origin_metadata
        self._labels = labels
        self._properties = properties
        self._description = description
        self._granularity = granularity
        self._is_v2_dataset = is_v2_dataset
        self._workspace = workspace
        self._marking_rids = marking_rids

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> Optional["scout_catalog_Handle"]:
        return self._handle

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        return self._metadata

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def granularity(self) -> Optional["api_Granularity"]:
        """Granularity of dataset timestamps. Defaults to nanoseconds.
        """
        return self._granularity

    @builtins.property
    def is_v2_dataset(self) -> Optional[bool]:
        """If true, the dataset should be ingested to the v2 tables and is compatible with streaming.
        """
        return self._is_v2_dataset

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the dataset. If not provided, the dataset will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace

    @builtins.property
    def marking_rids(self) -> List[str]:
        """The markings to apply to the created dataset.
If not provided, the dataset will be visible to all users in the same workspace.
        """
        return self._marking_rids


scout_catalog_CreateDataset.__name__ = "CreateDataset"
scout_catalog_CreateDataset.__qualname__ = "CreateDataset"
scout_catalog_CreateDataset.__module__ = "nominal_api.scout_catalog"


class scout_catalog_CreateDatasetWithUuidRequest(ConjureBeanType):
    """Request to create a dataset with a specific UUID. Used for migrations
where the UUID must be controlled by the caller.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'create_dataset': ConjureFieldDefinition('createDataset', scout_catalog_CreateDataset)
        }

    __slots__: List[str] = ['_uuid', '_create_dataset']

    def __init__(self, create_dataset: "scout_catalog_CreateDataset", uuid: str) -> None:
        self._uuid = uuid
        self._create_dataset = create_dataset

    @builtins.property
    def uuid(self) -> str:
        """The UUID to assign to the new dataset.
        """
        return self._uuid

    @builtins.property
    def create_dataset(self) -> "scout_catalog_CreateDataset":
        return self._create_dataset


scout_catalog_CreateDatasetWithUuidRequest.__name__ = "CreateDatasetWithUuidRequest"
scout_catalog_CreateDatasetWithUuidRequest.__qualname__ = "CreateDatasetWithUuidRequest"
scout_catalog_CreateDatasetWithUuidRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_CustomTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', str),
            'default_year': ConjureFieldDefinition('defaultYear', OptionalTypeWrapper[int]),
            'default_day_of_year': ConjureFieldDefinition('defaultDayOfYear', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_format', '_default_year', '_default_day_of_year']

    def __init__(self, format: str, default_day_of_year: Optional[int] = None, default_year: Optional[int] = None) -> None:
        self._format = format
        self._default_year = default_year
        self._default_day_of_year = default_day_of_year

    @builtins.property
    def format(self) -> str:
        """The format string should be in the format of the `DateTimeFormatter` class in Java.
        """
        return self._format

    @builtins.property
    def default_year(self) -> Optional[int]:
        """Year is accepted as an optional field for cases like IRIG time format, and will be assumed as current year if not provided.
        """
        return self._default_year

    @builtins.property
    def default_day_of_year(self) -> Optional[int]:
        """Default day of year is accepted as an optional field for cases like IRIG time format and will be overridden by day of year in time format.
        """
        return self._default_day_of_year


scout_catalog_CustomTimestamp.__name__ = "CustomTimestamp"
scout_catalog_CustomTimestamp.__qualname__ = "CustomTimestamp"
scout_catalog_CustomTimestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_Dataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', OptionalTypeWrapper[scout_catalog_Handle]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_WeakTimestampType),
            'allow_streaming': ConjureFieldDefinition('allowStreaming', bool),
            'granularity': ConjureFieldDefinition('granularity', api_Granularity),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_name', '_handle', '_description', '_origin_metadata', '_bounds', '_properties', '_labels', '_timestamp_type', '_allow_streaming', '_granularity', '_is_archived']

    def __init__(self, allow_streaming: bool, granularity: "api_Granularity", is_archived: bool, labels: List[str], name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], rid: str, timestamp_type: "scout_catalog_WeakTimestampType", bounds: Optional["scout_catalog_Bounds"] = None, description: Optional[str] = None, handle: Optional["scout_catalog_Handle"] = None) -> None:
        self._rid = rid
        self._name = name
        self._handle = handle
        self._description = description
        self._origin_metadata = origin_metadata
        self._bounds = bounds
        self._properties = properties
        self._labels = labels
        self._timestamp_type = timestamp_type
        self._allow_streaming = allow_streaming
        self._granularity = granularity
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> Optional["scout_catalog_Handle"]:
        return self._handle

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def allow_streaming(self) -> bool:
        return self._allow_streaming

    @builtins.property
    def granularity(self) -> "api_Granularity":
        return self._granularity

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_catalog_Dataset.__name__ = "Dataset"
scout_catalog_Dataset.__qualname__ = "Dataset"
scout_catalog_Dataset.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFile(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', datasource_DatasetFileId),
            'dataset_rid': ConjureFieldDefinition('datasetRid', api_rids_DatasetRid),
            'name': ConjureFieldDefinition('name', str),
            'handle': ConjureFieldDefinition('handle', scout_catalog_Handle),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'uploaded_at': ConjureFieldDefinition('uploadedAt', str),
            'ingested_at': ConjureFieldDefinition('ingestedAt', OptionalTypeWrapper[str]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', api_IngestStatusV2),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata]),
            'ingest_tag_metadata': ConjureFieldDefinition('ingestTagMetadata', OptionalTypeWrapper[scout_catalog_IngestTagMetadata]),
            'origin_file_paths': ConjureFieldDefinition('originFilePaths', OptionalTypeWrapper[List[str]]),
            'ingest_job_rid': ConjureFieldDefinition('ingestJobRid', OptionalTypeWrapper[ingest_api_IngestJobRid]),
            'deleted_at': ConjureFieldDefinition('deletedAt', OptionalTypeWrapper[str]),
            'metadata': ConjureFieldDefinition('metadata', OptionalTypeWrapper[scout_catalog_DatasetFileMetadata])
        }

    __slots__: List[str] = ['_id', '_dataset_rid', '_name', '_handle', '_bounds', '_uploaded_at', '_ingested_at', '_ingest_status', '_timestamp_metadata', '_ingest_tag_metadata', '_origin_file_paths', '_ingest_job_rid', '_deleted_at', '_metadata']

    def __init__(self, dataset_rid: str, handle: "scout_catalog_Handle", id: str, ingest_status: "api_IngestStatusV2", name: str, uploaded_at: str, bounds: Optional["scout_catalog_Bounds"] = None, deleted_at: Optional[str] = None, ingest_job_rid: Optional[str] = None, ingest_tag_metadata: Optional["scout_catalog_IngestTagMetadata"] = None, ingested_at: Optional[str] = None, metadata: Optional["scout_catalog_DatasetFileMetadata"] = None, origin_file_paths: Optional[List[str]] = None, timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None) -> None:
        self._id = id
        self._dataset_rid = dataset_rid
        self._name = name
        self._handle = handle
        self._bounds = bounds
        self._uploaded_at = uploaded_at
        self._ingested_at = ingested_at
        self._ingest_status = ingest_status
        self._timestamp_metadata = timestamp_metadata
        self._ingest_tag_metadata = ingest_tag_metadata
        self._origin_file_paths = origin_file_paths
        self._ingest_job_rid = ingest_job_rid
        self._deleted_at = deleted_at
        self._metadata = metadata

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def handle(self) -> "scout_catalog_Handle":
        return self._handle

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def uploaded_at(self) -> str:
        """Timestamp that the file was received and stored, but not processed or made available to consumers.
        """
        return self._uploaded_at

    @builtins.property
    def ingested_at(self) -> Optional[str]:
        """Timestamp that the file is ingested at and made available for processing. If the file has failed to be
ingested for any reason or is still being processed, then this value will be empty.
        """
        return self._ingested_at

    @builtins.property
    def ingest_status(self) -> "api_IngestStatusV2":
        return self._ingest_status

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        return self._timestamp_metadata

    @builtins.property
    def ingest_tag_metadata(self) -> Optional["scout_catalog_IngestTagMetadata"]:
        return self._ingest_tag_metadata

    @builtins.property
    def origin_file_paths(self) -> Optional[List[str]]:
        return self._origin_file_paths

    @builtins.property
    def ingest_job_rid(self) -> Optional[str]:
        return self._ingest_job_rid

    @builtins.property
    def deleted_at(self) -> Optional[str]:
        """Timestamp that the file is deleted at, only present if the file has been deleted.
        """
        return self._deleted_at

    @builtins.property
    def metadata(self) -> Optional["scout_catalog_DatasetFileMetadata"]:
        """File-type-specific metadata. For video files, contains timestamp manifest and segment metadata.
        """
        return self._metadata


scout_catalog_DatasetFile.__name__ = "DatasetFile"
scout_catalog_DatasetFile.__qualname__ = "DatasetFile"
scout_catalog_DatasetFile.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFileMetadata(ConjureUnionType):
    """Metadata specific to different file types stored in datasets.
    """
    _video: Optional["datasource_VideoFileMetadata"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video': ConjureFieldDefinition('video', datasource_VideoFileMetadata)
        }

    def __init__(
            self,
            video: Optional["datasource_VideoFileMetadata"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def video(self) -> Optional["datasource_VideoFileMetadata"]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_DatasetFileMetadataVisitor):
            raise ValueError('{} is not an instance of scout_catalog_DatasetFileMetadataVisitor'.format(visitor.__class__.__name__))
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


scout_catalog_DatasetFileMetadata.__name__ = "DatasetFileMetadata"
scout_catalog_DatasetFileMetadata.__qualname__ = "DatasetFileMetadata"
scout_catalog_DatasetFileMetadata.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFileMetadataVisitor:

    @abstractmethod
    def _video(self, video: "datasource_VideoFileMetadata") -> Any:
        pass


scout_catalog_DatasetFileMetadataVisitor.__name__ = "DatasetFileMetadataVisitor"
scout_catalog_DatasetFileMetadataVisitor.__qualname__ = "DatasetFileMetadataVisitor"
scout_catalog_DatasetFileMetadataVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFileSortField(ConjureEnumType):

    UPLOADED_AT = 'UPLOADED_AT'
    '''UPLOADED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_DatasetFileSortField.__name__ = "DatasetFileSortField"
scout_catalog_DatasetFileSortField.__qualname__ = "DatasetFileSortField"
scout_catalog_DatasetFileSortField.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFileSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_catalog_DatasetFileSortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_catalog_DatasetFileSortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_catalog_DatasetFileSortField":
        return self._field


scout_catalog_DatasetFileSortOptions.__name__ = "DatasetFileSortOptions"
scout_catalog_DatasetFileSortOptions.__qualname__ = "DatasetFileSortOptions"
scout_catalog_DatasetFileSortOptions.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFileUri(ConjureBeanType):
    """Pre-signed URI that can be used to download the original file directly. Expires if the download has
not been initiated within 1 minute.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uri': ConjureFieldDefinition('uri', str)
        }

    __slots__: List[str] = ['_uri']

    def __init__(self, uri: str) -> None:
        self._uri = uri

    @builtins.property
    def uri(self) -> str:
        return self._uri


scout_catalog_DatasetFileUri.__name__ = "DatasetFileUri"
scout_catalog_DatasetFileUri.__qualname__ = "DatasetFileUri"
scout_catalog_DatasetFileUri.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetFilesPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'files': ConjureFieldDefinition('files', List[scout_catalog_DatasetFile]),
            'next_page': ConjureFieldDefinition('nextPage', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_files', '_next_page']

    def __init__(self, files: List["scout_catalog_DatasetFile"], next_page: Optional[str] = None) -> None:
        self._files = files
        self._next_page = next_page

    @builtins.property
    def files(self) -> List["scout_catalog_DatasetFile"]:
        return self._files

    @builtins.property
    def next_page(self) -> Optional[str]:
        return self._next_page


scout_catalog_DatasetFilesPage.__name__ = "DatasetFilesPage"
scout_catalog_DatasetFilesPage.__qualname__ = "DatasetFilesPage"
scout_catalog_DatasetFilesPage.__module__ = "nominal_api.scout_catalog"


class scout_catalog_DatasetOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'path': ConjureFieldDefinition('path', OptionalTypeWrapper[str]),
            'x_series_is_absolute': ConjureFieldDefinition('xSeriesIsAbsolute', OptionalTypeWrapper[bool]),
            'schema_directive_path': ConjureFieldDefinition('schemaDirectivePath', OptionalTypeWrapper[str]),
            'x_series_column_name': ConjureFieldDefinition('xSeriesColumnName', OptionalTypeWrapper[str]),
            'x_series_time_unit': ConjureFieldDefinition('xSeriesTimeUnit', OptionalTypeWrapper[api_TimeUnit]),
            'timestamp_metadata': ConjureFieldDefinition('timestampMetadata', OptionalTypeWrapper[scout_catalog_TimestampMetadata]),
            'channel_config': ConjureFieldDefinition('channelConfig', OptionalTypeWrapper[scout_catalog_ChannelConfig])
        }

    __slots__: List[str] = ['_path', '_x_series_is_absolute', '_schema_directive_path', '_x_series_column_name', '_x_series_time_unit', '_timestamp_metadata', '_channel_config']

    def __init__(self, channel_config: Optional["scout_catalog_ChannelConfig"] = None, path: Optional[str] = None, schema_directive_path: Optional[str] = None, timestamp_metadata: Optional["scout_catalog_TimestampMetadata"] = None, x_series_column_name: Optional[str] = None, x_series_is_absolute: Optional[bool] = None, x_series_time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._path = path
        self._x_series_is_absolute = x_series_is_absolute
        self._schema_directive_path = schema_directive_path
        self._x_series_column_name = x_series_column_name
        self._x_series_time_unit = x_series_time_unit
        self._timestamp_metadata = timestamp_metadata
        self._channel_config = channel_config

    @builtins.property
    def path(self) -> Optional[str]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._path

    @builtins.property
    def x_series_is_absolute(self) -> Optional[bool]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._x_series_is_absolute

    @builtins.property
    def schema_directive_path(self) -> Optional[str]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._schema_directive_path

    @builtins.property
    def x_series_column_name(self) -> Optional[str]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._x_series_column_name

    @builtins.property
    def x_series_time_unit(self) -> Optional["api_TimeUnit"]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._x_series_time_unit

    @builtins.property
    def timestamp_metadata(self) -> Optional["scout_catalog_TimestampMetadata"]:
        """Deprecated in favor of FileOriginMetadata
        """
        return self._timestamp_metadata

    @builtins.property
    def channel_config(self) -> Optional["scout_catalog_ChannelConfig"]:
        return self._channel_config


scout_catalog_DatasetOriginMetadata.__name__ = "DatasetOriginMetadata"
scout_catalog_DatasetOriginMetadata.__qualname__ = "DatasetOriginMetadata"
scout_catalog_DatasetOriginMetadata.__module__ = "nominal_api.scout_catalog"


class scout_catalog_EnrichedDataset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', str),
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'display_name': ConjureFieldDefinition('displayName', str),
            'metadata': ConjureFieldDefinition('metadata', OptionalTypeWrapper[Dict[str, str]]),
            'handle': ConjureFieldDefinition('handle', OptionalTypeWrapper[scout_catalog_Handle]),
            'ingest_date': ConjureFieldDefinition('ingestDate', str),
            'ingest_status': ConjureFieldDefinition('ingestStatus', OptionalTypeWrapper[scout_catalog_IngestStatus]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_catalog_DatasetOriginMetadata),
            'last_ingest_status': ConjureFieldDefinition('lastIngestStatus', api_IngestStatusV2),
            'retention_policy': ConjureFieldDefinition('retentionPolicy', scout_catalog_RetentionPolicy),
            'source': ConjureFieldDefinition('source', OptionalTypeWrapper[str]),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_catalog_Bounds]),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_WeakTimestampType),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'granularity': ConjureFieldDefinition('granularity', api_Granularity),
            'allow_streaming': ConjureFieldDefinition('allowStreaming', bool),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_uuid', '_name', '_description', '_display_name', '_metadata', '_handle', '_ingest_date', '_ingest_status', '_origin_metadata', '_last_ingest_status', '_retention_policy', '_source', '_bounds', '_timestamp_type', '_labels', '_properties', '_granularity', '_allow_streaming', '_is_archived']

    def __init__(self, allow_streaming: bool, display_name: str, granularity: "api_Granularity", ingest_date: str, is_archived: bool, labels: List[str], last_ingest_status: "api_IngestStatusV2", name: str, origin_metadata: "scout_catalog_DatasetOriginMetadata", properties: Dict[str, str], retention_policy: "scout_catalog_RetentionPolicy", rid: str, timestamp_type: "scout_catalog_WeakTimestampType", uuid: str, bounds: Optional["scout_catalog_Bounds"] = None, description: Optional[str] = None, handle: Optional["scout_catalog_Handle"] = None, ingest_status: Optional["scout_catalog_IngestStatus"] = None, metadata: Optional[Dict[str, str]] = None, source: Optional[str] = None) -> None:
        self._rid = rid
        self._uuid = uuid
        self._name = name
        self._description = description
        self._display_name = display_name
        self._metadata = metadata
        self._handle = handle
        self._ingest_date = ingest_date
        self._ingest_status = ingest_status
        self._origin_metadata = origin_metadata
        self._last_ingest_status = last_ingest_status
        self._retention_policy = retention_policy
        self._source = source
        self._bounds = bounds
        self._timestamp_type = timestamp_type
        self._labels = labels
        self._properties = properties
        self._granularity = granularity
        self._allow_streaming = allow_streaming
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def display_name(self) -> str:
        return self._display_name

    @builtins.property
    def metadata(self) -> Optional[Dict[str, str]]:
        return self._metadata

    @builtins.property
    def handle(self) -> Optional["scout_catalog_Handle"]:
        return self._handle

    @builtins.property
    def ingest_date(self) -> str:
        return self._ingest_date

    @builtins.property
    def ingest_status(self) -> Optional["scout_catalog_IngestStatus"]:
        return self._ingest_status

    @builtins.property
    def origin_metadata(self) -> "scout_catalog_DatasetOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def last_ingest_status(self) -> "api_IngestStatusV2":
        return self._last_ingest_status

    @builtins.property
    def retention_policy(self) -> "scout_catalog_RetentionPolicy":
        return self._retention_policy

    @builtins.property
    def source(self) -> Optional[str]:
        return self._source

    @builtins.property
    def bounds(self) -> Optional["scout_catalog_Bounds"]:
        return self._bounds

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def granularity(self) -> "api_Granularity":
        return self._granularity

    @builtins.property
    def allow_streaming(self) -> bool:
        return self._allow_streaming

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_catalog_EnrichedDataset.__name__ = "EnrichedDataset"
scout_catalog_EnrichedDataset.__qualname__ = "EnrichedDataset"
scout_catalog_EnrichedDataset.__module__ = "nominal_api.scout_catalog"


class scout_catalog_EpochTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit)
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: "api_TimeUnit") -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit


scout_catalog_EpochTimestamp.__name__ = "EpochTimestamp"
scout_catalog_EpochTimestamp.__qualname__ = "EpochTimestamp"
scout_catalog_EpochTimestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_GetChannelsForDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_uuids': ConjureFieldDefinition('datasetUuids', List[str])
        }

    __slots__: List[str] = ['_dataset_uuids']

    def __init__(self, dataset_uuids: List[str]) -> None:
        self._dataset_uuids = dataset_uuids

    @builtins.property
    def dataset_uuids(self) -> List[str]:
        return self._dataset_uuids


scout_catalog_GetChannelsForDatasetsRequest.__name__ = "GetChannelsForDatasetsRequest"
scout_catalog_GetChannelsForDatasetsRequest.__qualname__ = "GetChannelsForDatasetsRequest"
scout_catalog_GetChannelsForDatasetsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_GetDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rids': ConjureFieldDefinition('datasetRids', List[str])
        }

    __slots__: List[str] = ['_dataset_rids']

    def __init__(self, dataset_rids: List[str]) -> None:
        self._dataset_rids = dataset_rids

    @builtins.property
    def dataset_rids(self) -> List[str]:
        return self._dataset_rids


scout_catalog_GetDatasetsRequest.__name__ = "GetDatasetsRequest"
scout_catalog_GetDatasetsRequest.__qualname__ = "GetDatasetsRequest"
scout_catalog_GetDatasetsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_GetDetailsForChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_uuids': ConjureFieldDefinition('channelUuids', List[str])
        }

    __slots__: List[str] = ['_channel_uuids']

    def __init__(self, channel_uuids: List[str]) -> None:
        self._channel_uuids = channel_uuids

    @builtins.property
    def channel_uuids(self) -> List[str]:
        return self._channel_uuids


scout_catalog_GetDetailsForChannelsRequest.__name__ = "GetDetailsForChannelsRequest"
scout_catalog_GetDetailsForChannelsRequest.__qualname__ = "GetDetailsForChannelsRequest"
scout_catalog_GetDetailsForChannelsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_GetHandlesForDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_uuids': ConjureFieldDefinition('datasetUuids', List[str])
        }

    __slots__: List[str] = ['_dataset_uuids']

    def __init__(self, dataset_uuids: List[str]) -> None:
        self._dataset_uuids = dataset_uuids

    @builtins.property
    def dataset_uuids(self) -> List[str]:
        return self._dataset_uuids


scout_catalog_GetHandlesForDatasetsRequest.__name__ = "GetHandlesForDatasetsRequest"
scout_catalog_GetHandlesForDatasetsRequest.__qualname__ = "GetHandlesForDatasetsRequest"
scout_catalog_GetHandlesForDatasetsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_Handle(ConjureUnionType):
    _s3: Optional["scout_catalog_S3Handle"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', scout_catalog_S3Handle)
        }

    def __init__(
            self,
            s3: Optional["scout_catalog_S3Handle"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["scout_catalog_S3Handle"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_HandleVisitor):
            raise ValueError('{} is not an instance of scout_catalog_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


scout_catalog_Handle.__name__ = "Handle"
scout_catalog_Handle.__qualname__ = "Handle"
scout_catalog_Handle.__module__ = "nominal_api.scout_catalog"


class scout_catalog_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: "scout_catalog_S3Handle") -> Any:
        pass


scout_catalog_HandleVisitor.__name__ = "HandleVisitor"
scout_catalog_HandleVisitor.__qualname__ = "HandleVisitor"
scout_catalog_HandleVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_IngestProgressV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', str),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', api_IngestStatusV2),
            'incalculable': ConjureFieldDefinition('incalculable', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_start_time', '_end_time', '_ingest_status', '_incalculable']

    def __init__(self, ingest_status: "api_IngestStatusV2", start_time: str, end_time: Optional[str] = None, incalculable: Optional[bool] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time
        self._ingest_status = ingest_status
        self._incalculable = incalculable

    @builtins.property
    def start_time(self) -> str:
        """Timestamp at start of ingest
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        """Timestamp at end of ingest, empty if still in progress
        """
        return self._end_time

    @builtins.property
    def ingest_status(self) -> "api_IngestStatusV2":
        """Status of ingest, contains error if failed
        """
        return self._ingest_status

    @builtins.property
    def incalculable(self) -> Optional[bool]:
        """Whether ingest duration can be reliably calculated
        """
        return self._incalculable


scout_catalog_IngestProgressV2.__name__ = "IngestProgressV2"
scout_catalog_IngestProgressV2.__qualname__ = "IngestProgressV2"
scout_catalog_IngestProgressV2.__module__ = "nominal_api.scout_catalog"


class scout_catalog_IngestStatus(ConjureEnumType):

    IN_PROGRESS = 'IN_PROGRESS'
    '''IN_PROGRESS'''
    COMPLETED = 'COMPLETED'
    '''COMPLETED'''
    FAILED = 'FAILED'
    '''FAILED'''
    DELETION_IN_PROGRESS = 'DELETION_IN_PROGRESS'
    '''DELETION_IN_PROGRESS'''
    DELETED = 'DELETED'
    '''DELETED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_IngestStatus.__name__ = "IngestStatus"
scout_catalog_IngestStatus.__qualname__ = "IngestStatus"
scout_catalog_IngestStatus.__module__ = "nominal_api.scout_catalog"


class scout_catalog_IngestTagMetadata(ConjureBeanType):
    """The tags used when ingesting the dataset file.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tag_columns': ConjureFieldDefinition('tagColumns', Dict[api_TagName, api_ColumnName]),
            'additional_file_tags': ConjureFieldDefinition('additionalFileTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_tag_columns', '_additional_file_tags']

    def __init__(self, additional_file_tags: Dict[str, str], tag_columns: Dict[str, str]) -> None:
        self._tag_columns = tag_columns
        self._additional_file_tags = additional_file_tags

    @builtins.property
    def tag_columns(self) -> Dict[str, str]:
        """A map of tag names to column names to derive the tag values from.
        """
        return self._tag_columns

    @builtins.property
    def additional_file_tags(self) -> Dict[str, str]:
        return self._additional_file_tags


scout_catalog_IngestTagMetadata.__name__ = "IngestTagMetadata"
scout_catalog_IngestTagMetadata.__qualname__ = "IngestTagMetadata"
scout_catalog_IngestTagMetadata.__module__ = "nominal_api.scout_catalog"


class scout_catalog_Iso8601Timestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_catalog_Iso8601Timestamp.__name__ = "Iso8601Timestamp"
scout_catalog_Iso8601Timestamp.__qualname__ = "Iso8601Timestamp"
scout_catalog_Iso8601Timestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_MarkFileIngestError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_result': ConjureFieldDefinition('errorResult', api_ErrorResult)
        }

    __slots__: List[str] = ['_error_result']

    def __init__(self, error_result: "api_ErrorResult") -> None:
        self._error_result = error_result

    @builtins.property
    def error_result(self) -> "api_ErrorResult":
        return self._error_result


scout_catalog_MarkFileIngestError.__name__ = "MarkFileIngestError"
scout_catalog_MarkFileIngestError.__qualname__ = "MarkFileIngestError"
scout_catalog_MarkFileIngestError.__module__ = "nominal_api.scout_catalog"


class scout_catalog_MarkFileIngestSuccessful(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', scout_catalog_Bounds),
            'ingested_at': ConjureFieldDefinition('ingestedAt', api_Timestamp)
        }

    __slots__: List[str] = ['_bounds', '_ingested_at']

    def __init__(self, bounds: "scout_catalog_Bounds", ingested_at: "api_Timestamp") -> None:
        self._bounds = bounds
        self._ingested_at = ingested_at

    @builtins.property
    def bounds(self) -> "scout_catalog_Bounds":
        return self._bounds

    @builtins.property
    def ingested_at(self) -> "api_Timestamp":
        """The ingestion timestamp is produced by CSV splitter and stored directly in the clickhouse table.
It's produced externally and passed here to handle retries and failures, and must be nanosecond precision.
Two files cannot have the same ingested at timestamp.
        """
        return self._ingested_at


scout_catalog_MarkFileIngestSuccessful.__name__ = "MarkFileIngestSuccessful"
scout_catalog_MarkFileIngestSuccessful.__qualname__ = "MarkFileIngestSuccessful"
scout_catalog_MarkFileIngestSuccessful.__module__ = "nominal_api.scout_catalog"


class scout_catalog_OriginFileUri(ConjureBeanType):
    """Pre-signed URI that can be used to download an origin file directly. Expires if the download has
not been initiated within 1 minute.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uri': ConjureFieldDefinition('uri', str),
            'path': ConjureFieldDefinition('path', str)
        }

    __slots__: List[str] = ['_uri', '_path']

    def __init__(self, path: str, uri: str) -> None:
        self._uri = uri
        self._path = path

    @builtins.property
    def uri(self) -> str:
        return self._uri

    @builtins.property
    def path(self) -> str:
        return self._path


scout_catalog_OriginFileUri.__name__ = "OriginFileUri"
scout_catalog_OriginFileUri.__qualname__ = "OriginFileUri"
scout_catalog_OriginFileUri.__module__ = "nominal_api.scout_catalog"


class scout_catalog_RelativeTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_time_unit', '_offset']

    def __init__(self, time_unit: "api_TimeUnit", offset: Optional[str] = None) -> None:
        self._time_unit = time_unit
        self._offset = offset

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit

    @builtins.property
    def offset(self) -> Optional[str]:
        return self._offset


scout_catalog_RelativeTimestamp.__name__ = "RelativeTimestamp"
scout_catalog_RelativeTimestamp.__qualname__ = "RelativeTimestamp"
scout_catalog_RelativeTimestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_RetentionPolicy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', scout_catalog_RetentionPolicyType),
            'expiry_days': ConjureFieldDefinition('expiryDays', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_type', '_expiry_days']

    def __init__(self, type: "scout_catalog_RetentionPolicyType", expiry_days: Optional[int] = None) -> None:
        self._type = type
        self._expiry_days = expiry_days

    @builtins.property
    def type(self) -> "scout_catalog_RetentionPolicyType":
        return self._type

    @builtins.property
    def expiry_days(self) -> Optional[int]:
        return self._expiry_days


scout_catalog_RetentionPolicy.__name__ = "RetentionPolicy"
scout_catalog_RetentionPolicy.__qualname__ = "RetentionPolicy"
scout_catalog_RetentionPolicy.__module__ = "nominal_api.scout_catalog"


class scout_catalog_RetentionPolicyType(ConjureEnumType):

    KEEP_UNTIL_EXPIRY = 'KEEP_UNTIL_EXPIRY'
    '''KEEP_UNTIL_EXPIRY'''
    KEEP_FOREVER = 'KEEP_FOREVER'
    '''KEEP_FOREVER'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_RetentionPolicyType.__name__ = "RetentionPolicyType"
scout_catalog_RetentionPolicyType.__qualname__ = "RetentionPolicyType"
scout_catalog_RetentionPolicyType.__module__ = "nominal_api.scout_catalog"


class scout_catalog_S3Handle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', str),
            'key': ConjureFieldDefinition('key', str)
        }

    __slots__: List[str] = ['_bucket', '_key']

    def __init__(self, bucket: str, key: str) -> None:
        self._bucket = bucket
        self._key = key

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def key(self) -> str:
        return self._key


scout_catalog_S3Handle.__name__ = "S3Handle"
scout_catalog_S3Handle.__qualname__ = "S3Handle"
scout_catalog_S3Handle.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetFilesQuery(ConjureUnionType):
    _time_range: Optional["scout_catalog_TimeRangeFilter"] = None
    _file_tags: Optional[Dict[str, str]] = None
    _and_: Optional[List["scout_catalog_SearchDatasetFilesQuery"]] = None
    _or_: Optional[List["scout_catalog_SearchDatasetFilesQuery"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_range': ConjureFieldDefinition('timeRange', scout_catalog_TimeRangeFilter),
            'file_tags': ConjureFieldDefinition('fileTags', Dict[api_TagName, api_TagValue]),
            'and_': ConjureFieldDefinition('and', List[scout_catalog_SearchDatasetFilesQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_catalog_SearchDatasetFilesQuery])
        }

    def __init__(
            self,
            time_range: Optional["scout_catalog_TimeRangeFilter"] = None,
            file_tags: Optional[Dict[str, str]] = None,
            and_: Optional[List["scout_catalog_SearchDatasetFilesQuery"]] = None,
            or_: Optional[List["scout_catalog_SearchDatasetFilesQuery"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_range is not None) + (file_tags is not None) + (and_ is not None) + (or_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_range is not None:
                self._time_range = time_range
                self._type = 'timeRange'
            if file_tags is not None:
                self._file_tags = file_tags
                self._type = 'fileTags'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'

        elif type_of_union == 'timeRange':
            if time_range is None:
                raise ValueError('a union value must not be None')
            self._time_range = time_range
            self._type = 'timeRange'
        elif type_of_union == 'fileTags':
            if file_tags is None:
                raise ValueError('a union value must not be None')
            self._file_tags = file_tags
            self._type = 'fileTags'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'

    @builtins.property
    def time_range(self) -> Optional["scout_catalog_TimeRangeFilter"]:
        return self._time_range

    @builtins.property
    def file_tags(self) -> Optional[Dict[str, str]]:
        return self._file_tags

    @builtins.property
    def and_(self) -> Optional[List["scout_catalog_SearchDatasetFilesQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_catalog_SearchDatasetFilesQuery"]]:
        return self._or_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_SearchDatasetFilesQueryVisitor):
            raise ValueError('{} is not an instance of scout_catalog_SearchDatasetFilesQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeRange' and self.time_range is not None:
            return visitor._time_range(self.time_range)
        if self._type == 'fileTags' and self.file_tags is not None:
            return visitor._file_tags(self.file_tags)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)


scout_catalog_SearchDatasetFilesQuery.__name__ = "SearchDatasetFilesQuery"
scout_catalog_SearchDatasetFilesQuery.__qualname__ = "SearchDatasetFilesQuery"
scout_catalog_SearchDatasetFilesQuery.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetFilesQueryVisitor:

    @abstractmethod
    def _time_range(self, time_range: "scout_catalog_TimeRangeFilter") -> Any:
        pass

    @abstractmethod
    def _file_tags(self, file_tags: Dict[str, str]) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_catalog_SearchDatasetFilesQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_catalog_SearchDatasetFilesQuery"]) -> Any:
        pass


scout_catalog_SearchDatasetFilesQueryVisitor.__name__ = "SearchDatasetFilesQueryVisitor"
scout_catalog_SearchDatasetFilesQueryVisitor.__qualname__ = "SearchDatasetFilesQueryVisitor"
scout_catalog_SearchDatasetFilesQueryVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetFilesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', api_rids_DatasetRid),
            'query': ConjureFieldDefinition('query', scout_catalog_SearchDatasetFilesQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token]),
            'sort_options': ConjureFieldDefinition('sortOptions', scout_catalog_DatasetFileSortOptions)
        }

    __slots__: List[str] = ['_dataset_rid', '_query', '_page_size', '_token', '_sort_options']

    def __init__(self, dataset_rid: str, query: "scout_catalog_SearchDatasetFilesQuery", sort_options: "scout_catalog_DatasetFileSortOptions", page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._dataset_rid = dataset_rid
        self._query = query
        self._page_size = page_size
        self._token = token
        self._sort_options = sort_options

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def query(self) -> "scout_catalog_SearchDatasetFilesQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def sort_options(self) -> "scout_catalog_DatasetFileSortOptions":
        return self._sort_options


scout_catalog_SearchDatasetFilesRequest.__name__ = "SearchDatasetFilesRequest"
scout_catalog_SearchDatasetFilesRequest.__qualname__ = "SearchDatasetFilesRequest"
scout_catalog_SearchDatasetFilesRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetFilesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_catalog_DatasetFile]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_catalog_DatasetFile"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_catalog_DatasetFile"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_catalog_SearchDatasetFilesResponse.__name__ = "SearchDatasetFilesResponse"
scout_catalog_SearchDatasetFilesResponse.__qualname__ = "SearchDatasetFilesResponse"
scout_catalog_SearchDatasetFilesResponse.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _exact_match: Optional[str] = None
    _label: Optional[str] = None
    _properties: Optional["api_Property"] = None
    _ingest_status: Optional["scout_catalog_IngestStatus"] = None
    _ingested_before_inclusive: Optional[str] = None
    _ingested_after_inclusive: Optional[str] = None
    _archive_status: Optional[bool] = None
    _and_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None
    _or_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'properties': ConjureFieldDefinition('properties', api_Property),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_catalog_IngestStatus),
            'ingested_before_inclusive': ConjureFieldDefinition('ingestedBeforeInclusive', str),
            'ingested_after_inclusive': ConjureFieldDefinition('ingestedAfterInclusive', str),
            'archive_status': ConjureFieldDefinition('archiveStatus', bool),
            'and_': ConjureFieldDefinition('and', List[scout_catalog_SearchDatasetsQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_catalog_SearchDatasetsQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            exact_match: Optional[str] = None,
            label: Optional[str] = None,
            properties: Optional["api_Property"] = None,
            ingest_status: Optional["scout_catalog_IngestStatus"] = None,
            ingested_before_inclusive: Optional[str] = None,
            ingested_after_inclusive: Optional[str] = None,
            archive_status: Optional[bool] = None,
            and_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None,
            or_: Optional[List["scout_catalog_SearchDatasetsQuery"]] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (exact_match is not None) + (label is not None) + (properties is not None) + (ingest_status is not None) + (ingested_before_inclusive is not None) + (ingested_after_inclusive is not None) + (archive_status is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if label is not None:
                self._label = label
                self._type = 'label'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if ingest_status is not None:
                self._ingest_status = ingest_status
                self._type = 'ingestStatus'
            if ingested_before_inclusive is not None:
                self._ingested_before_inclusive = ingested_before_inclusive
                self._type = 'ingestedBeforeInclusive'
            if ingested_after_inclusive is not None:
                self._ingested_after_inclusive = ingested_after_inclusive
                self._type = 'ingestedAfterInclusive'
            if archive_status is not None:
                self._archive_status = archive_status
                self._type = 'archiveStatus'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'ingestStatus':
            if ingest_status is None:
                raise ValueError('a union value must not be None')
            self._ingest_status = ingest_status
            self._type = 'ingestStatus'
        elif type_of_union == 'ingestedBeforeInclusive':
            if ingested_before_inclusive is None:
                raise ValueError('a union value must not be None')
            self._ingested_before_inclusive = ingested_before_inclusive
            self._type = 'ingestedBeforeInclusive'
        elif type_of_union == 'ingestedAfterInclusive':
            if ingested_after_inclusive is None:
                raise ValueError('a union value must not be None')
            self._ingested_after_inclusive = ingested_after_inclusive
            self._type = 'ingestedAfterInclusive'
        elif type_of_union == 'archiveStatus':
            if archive_status is None:
                raise ValueError('a union value must not be None')
            self._archive_status = archive_status
            self._type = 'archiveStatus'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact match search on the name.
        """
        return self._exact_match

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def properties(self) -> Optional["api_Property"]:
        return self._properties

    @builtins.property
    def ingest_status(self) -> Optional["scout_catalog_IngestStatus"]:
        return self._ingest_status

    @builtins.property
    def ingested_before_inclusive(self) -> Optional[str]:
        return self._ingested_before_inclusive

    @builtins.property
    def ingested_after_inclusive(self) -> Optional[str]:
        return self._ingested_after_inclusive

    @builtins.property
    def archive_status(self) -> Optional[bool]:
        return self._archive_status

    @builtins.property
    def and_(self) -> Optional[List["scout_catalog_SearchDatasetsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_catalog_SearchDatasetsQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_SearchDatasetsQueryVisitor):
            raise ValueError('{} is not an instance of scout_catalog_SearchDatasetsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'ingestStatus' and self.ingest_status is not None:
            return visitor._ingest_status(self.ingest_status)
        if self._type == 'ingestedBeforeInclusive' and self.ingested_before_inclusive is not None:
            return visitor._ingested_before_inclusive(self.ingested_before_inclusive)
        if self._type == 'ingestedAfterInclusive' and self.ingested_after_inclusive is not None:
            return visitor._ingested_after_inclusive(self.ingested_after_inclusive)
        if self._type == 'archiveStatus' and self.archive_status is not None:
            return visitor._archive_status(self.archive_status)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


scout_catalog_SearchDatasetsQuery.__name__ = "SearchDatasetsQuery"
scout_catalog_SearchDatasetsQuery.__qualname__ = "SearchDatasetsQuery"
scout_catalog_SearchDatasetsQuery.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "api_Property") -> Any:
        pass

    @abstractmethod
    def _ingest_status(self, ingest_status: "scout_catalog_IngestStatus") -> Any:
        pass

    @abstractmethod
    def _ingested_before_inclusive(self, ingested_before_inclusive: str) -> Any:
        pass

    @abstractmethod
    def _ingested_after_inclusive(self, ingested_after_inclusive: str) -> Any:
        pass

    @abstractmethod
    def _archive_status(self, archive_status: bool) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_catalog_SearchDatasetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_catalog_SearchDatasetsQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


scout_catalog_SearchDatasetsQueryVisitor.__name__ = "SearchDatasetsQueryVisitor"
scout_catalog_SearchDatasetsQueryVisitor.__qualname__ = "SearchDatasetsQueryVisitor"
scout_catalog_SearchDatasetsQueryVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_catalog_SearchDatasetsQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token]),
            'sort_options': ConjureFieldDefinition('sortOptions', scout_catalog_SortOptions)
        }

    __slots__: List[str] = ['_query', '_page_size', '_token', '_sort_options']

    def __init__(self, query: "scout_catalog_SearchDatasetsQuery", sort_options: "scout_catalog_SortOptions", page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._token = token
        self._sort_options = sort_options

    @builtins.property
    def query(self) -> "scout_catalog_SearchDatasetsQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def sort_options(self) -> "scout_catalog_SortOptions":
        return self._sort_options


scout_catalog_SearchDatasetsRequest.__name__ = "SearchDatasetsRequest"
scout_catalog_SearchDatasetsRequest.__qualname__ = "SearchDatasetsRequest"
scout_catalog_SearchDatasetsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SearchDatasetsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_catalog_EnrichedDataset]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_catalog_EnrichedDataset"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_catalog_EnrichedDataset"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_catalog_SearchDatasetsResponse.__name__ = "SearchDatasetsResponse"
scout_catalog_SearchDatasetsResponse.__qualname__ = "SearchDatasetsResponse"
scout_catalog_SearchDatasetsResponse.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SkipRowsConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'header_row_index': ConjureFieldDefinition('headerRowIndex', int),
            'data_start_row_index': ConjureFieldDefinition('dataStartRowIndex', int)
        }

    __slots__: List[str] = ['_header_row_index', '_data_start_row_index']

    def __init__(self, data_start_row_index: int, header_row_index: int) -> None:
        self._header_row_index = header_row_index
        self._data_start_row_index = data_start_row_index

    @builtins.property
    def header_row_index(self) -> int:
        return self._header_row_index

    @builtins.property
    def data_start_row_index(self) -> int:
        return self._data_start_row_index


scout_catalog_SkipRowsConfig.__name__ = "SkipRowsConfig"
scout_catalog_SkipRowsConfig.__qualname__ = "SkipRowsConfig"
scout_catalog_SkipRowsConfig.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SortField(ConjureEnumType):

    INGEST_DATE = 'INGEST_DATE'
    '''INGEST_DATE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_SortField.__name__ = "SortField"
scout_catalog_SortField.__qualname__ = "SortField"
scout_catalog_SortField.__module__ = "nominal_api.scout_catalog"


class scout_catalog_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_catalog_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_catalog_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_catalog_SortField":
        return self._field


scout_catalog_SortOptions.__name__ = "SortOptions"
scout_catalog_SortOptions.__qualname__ = "SortOptions"
scout_catalog_SortOptions.__module__ = "nominal_api.scout_catalog"


class scout_catalog_TimeRangeFilter(ConjureBeanType):
    """searches for files that intersect with the specified range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[scout_catalog_UtcTimestamp]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[scout_catalog_UtcTimestamp])
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: Optional["scout_catalog_UtcTimestamp"] = None, start: Optional["scout_catalog_UtcTimestamp"] = None) -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> Optional["scout_catalog_UtcTimestamp"]:
        return self._start

    @builtins.property
    def end(self) -> Optional["scout_catalog_UtcTimestamp"]:
        return self._end


scout_catalog_TimeRangeFilter.__name__ = "TimeRangeFilter"
scout_catalog_TimeRangeFilter.__qualname__ = "TimeRangeFilter"
scout_catalog_TimeRangeFilter.__module__ = "nominal_api.scout_catalog"


class scout_catalog_TimestampMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_name': ConjureFieldDefinition('seriesName', str),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_catalog_TimestampType)
        }

    __slots__: List[str] = ['_series_name', '_timestamp_type']

    def __init__(self, series_name: str, timestamp_type: "scout_catalog_TimestampType") -> None:
        self._series_name = series_name
        self._timestamp_type = timestamp_type

    @builtins.property
    def series_name(self) -> str:
        return self._series_name

    @builtins.property
    def timestamp_type(self) -> "scout_catalog_TimestampType":
        return self._timestamp_type


scout_catalog_TimestampMetadata.__name__ = "TimestampMetadata"
scout_catalog_TimestampMetadata.__qualname__ = "TimestampMetadata"
scout_catalog_TimestampMetadata.__module__ = "nominal_api.scout_catalog"


class scout_catalog_TimestampType(ConjureUnionType):
    _relative: Optional["scout_catalog_RelativeTimestamp"] = None
    _absolute: Optional["scout_catalog_AbsoluteTimestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative': ConjureFieldDefinition('relative', scout_catalog_RelativeTimestamp),
            'absolute': ConjureFieldDefinition('absolute', scout_catalog_AbsoluteTimestamp)
        }

    def __init__(
            self,
            relative: Optional["scout_catalog_RelativeTimestamp"] = None,
            absolute: Optional["scout_catalog_AbsoluteTimestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (relative is not None) + (absolute is not None) != 1:
                raise ValueError('a union must contain a single member')

            if relative is not None:
                self._relative = relative
                self._type = 'relative'
            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'

        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'
        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'

    @builtins.property
    def relative(self) -> Optional["scout_catalog_RelativeTimestamp"]:
        return self._relative

    @builtins.property
    def absolute(self) -> Optional["scout_catalog_AbsoluteTimestamp"]:
        return self._absolute

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_catalog_TimestampTypeVisitor):
            raise ValueError('{} is not an instance of scout_catalog_TimestampTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)


scout_catalog_TimestampType.__name__ = "TimestampType"
scout_catalog_TimestampType.__qualname__ = "TimestampType"
scout_catalog_TimestampType.__module__ = "nominal_api.scout_catalog"


class scout_catalog_TimestampTypeVisitor:

    @abstractmethod
    def _relative(self, relative: "scout_catalog_RelativeTimestamp") -> Any:
        pass

    @abstractmethod
    def _absolute(self, absolute: "scout_catalog_AbsoluteTimestamp") -> Any:
        pass


scout_catalog_TimestampTypeVisitor.__name__ = "TimestampTypeVisitor"
scout_catalog_TimestampTypeVisitor.__qualname__ = "TimestampTypeVisitor"
scout_catalog_TimestampTypeVisitor.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UnitConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit_metadata_key': ConjureFieldDefinition('unitMetadataKey', str)
        }

    __slots__: List[str] = ['_unit_metadata_key']

    def __init__(self, unit_metadata_key: str) -> None:
        self._unit_metadata_key = unit_metadata_key

    @builtins.property
    def unit_metadata_key(self) -> str:
        """If set, will extract the series unit from the column metadata of the ingested file.
        """
        return self._unit_metadata_key


scout_catalog_UnitConfig.__name__ = "UnitConfig"
scout_catalog_UnitConfig.__qualname__ = "UnitConfig"
scout_catalog_UnitConfig.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UpdateBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', scout_catalog_Bounds)
        }

    __slots__: List[str] = ['_bounds']

    def __init__(self, bounds: "scout_catalog_Bounds") -> None:
        self._bounds = bounds

    @builtins.property
    def bounds(self) -> "scout_catalog_Bounds":
        return self._bounds


scout_catalog_UpdateBoundsRequest.__name__ = "UpdateBoundsRequest"
scout_catalog_UpdateBoundsRequest.__qualname__ = "UpdateBoundsRequest"
scout_catalog_UpdateBoundsRequest.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UpdateDatasetMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]])
        }

    __slots__: List[str] = ['_name', '_description', '_labels', '_properties']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None) -> None:
        self._name = name
        self._description = description
        self._labels = labels
        self._properties = properties

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties


scout_catalog_UpdateDatasetMetadata.__name__ = "UpdateDatasetMetadata"
scout_catalog_UpdateDatasetMetadata.__qualname__ = "UpdateDatasetMetadata"
scout_catalog_UpdateDatasetMetadata.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UpdateIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_catalog_IngestStatus),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_status', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, status: "scout_catalog_IngestStatus") -> None:
        self._status = status
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def status(self) -> "scout_catalog_IngestStatus":
        return self._status

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_UpdateIngestStatus.__name__ = "UpdateIngestStatus"
scout_catalog_UpdateIngestStatus.__qualname__ = "UpdateIngestStatus"
scout_catalog_UpdateIngestStatus.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UpdateIngestStatusV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', api_IngestStatusV2),
            'dataset_uuid': ConjureFieldDefinition('datasetUuid', str)
        }

    __slots__: List[str] = ['_status', '_dataset_uuid']

    def __init__(self, dataset_uuid: str, status: "api_IngestStatusV2") -> None:
        self._status = status
        self._dataset_uuid = dataset_uuid

    @builtins.property
    def status(self) -> "api_IngestStatusV2":
        return self._status

    @builtins.property
    def dataset_uuid(self) -> str:
        return self._dataset_uuid


scout_catalog_UpdateIngestStatusV2.__name__ = "UpdateIngestStatusV2"
scout_catalog_UpdateIngestStatusV2.__qualname__ = "UpdateIngestStatusV2"
scout_catalog_UpdateIngestStatusV2.__module__ = "nominal_api.scout_catalog"


class scout_catalog_UtcTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds_since_epoch': ConjureFieldDefinition('secondsSinceEpoch', int)
        }

    __slots__: List[str] = ['_seconds_since_epoch']

    def __init__(self, seconds_since_epoch: int) -> None:
        self._seconds_since_epoch = seconds_since_epoch

    @builtins.property
    def seconds_since_epoch(self) -> int:
        return self._seconds_since_epoch


scout_catalog_UtcTimestamp.__name__ = "UtcTimestamp"
scout_catalog_UtcTimestamp.__qualname__ = "UtcTimestamp"
scout_catalog_UtcTimestamp.__module__ = "nominal_api.scout_catalog"


class scout_catalog_VideoFileUri(ConjureBeanType):
    """Pre-signed URI that can be used to download the original video file directly. Expires if the download has
not been initiated within 1 minute.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uri': ConjureFieldDefinition('uri', str)
        }

    __slots__: List[str] = ['_uri']

    def __init__(self, uri: str) -> None:
        self._uri = uri

    @builtins.property
    def uri(self) -> str:
        return self._uri


scout_catalog_VideoFileUri.__name__ = "VideoFileUri"
scout_catalog_VideoFileUri.__qualname__ = "VideoFileUri"
scout_catalog_VideoFileUri.__module__ = "nominal_api.scout_catalog"


class scout_catalog_WeakTimestampType(ConjureEnumType):
    """If a CSV dataset is still being split, the timestamp type is not known.
    """

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    PENDING = 'PENDING'
    '''PENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_catalog_WeakTimestampType.__name__ = "WeakTimestampType"
scout_catalog_WeakTimestampType.__qualname__ = "WeakTimestampType"
scout_catalog_WeakTimestampType.__module__ = "nominal_api.scout_catalog"


class scout_channelvariables_api_ChannelVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'compute_spec': ConjureFieldDefinition('computeSpec', scout_channelvariables_api_ComputeSpec),
            'compute_spec_v2': ConjureFieldDefinition('computeSpecV2', OptionalTypeWrapper[scout_channelvariables_api_ComputeNodeWithContext])
        }

    __slots__: List[str] = ['_display_name', '_variable_name', '_compute_spec', '_compute_spec_v2']

    def __init__(self, compute_spec: "scout_channelvariables_api_ComputeSpec", variable_name: str, compute_spec_v2: Optional["scout_channelvariables_api_ComputeNodeWithContext"] = None, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._variable_name = variable_name
        self._compute_spec = compute_spec
        self._compute_spec_v2 = compute_spec_v2

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def compute_spec(self) -> "scout_channelvariables_api_ComputeSpec":
        return self._compute_spec

    @builtins.property
    def compute_spec_v2(self) -> Optional["scout_channelvariables_api_ComputeNodeWithContext"]:
        """optional for backcompatibility. If empty, fall back to computeSpec.
        """
        return self._compute_spec_v2


scout_channelvariables_api_ChannelVariable.__name__ = "ChannelVariable"
scout_channelvariables_api_ChannelVariable.__qualname__ = "ChannelVariable"
scout_channelvariables_api_ChannelVariable.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_channelvariables_api_WorkbookContext)
        }

    __slots__: List[str] = ['_compute_node', '_context']

    def __init__(self, compute_node: "scout_compute_api_ComputeNode", context: "scout_channelvariables_api_WorkbookContext") -> None:
        self._compute_node = compute_node
        self._context = context

    @builtins.property
    def compute_node(self) -> "scout_compute_api_ComputeNode":
        return self._compute_node

    @builtins.property
    def context(self) -> "scout_channelvariables_api_WorkbookContext":
        return self._context


scout_channelvariables_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_channelvariables_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_channelvariables_api_ComputeNodeWithContext.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_ComputeSpec(ConjureUnionType):
    _v1: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_channelvariables_api_ComputeSpecV1)
        }

    def __init__(
            self,
            v1: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional[str]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_channelvariables_api_ComputeSpecVisitor):
            raise ValueError('{} is not an instance of scout_channelvariables_api_ComputeSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_channelvariables_api_ComputeSpec.__name__ = "ComputeSpec"
scout_channelvariables_api_ComputeSpec.__qualname__ = "ComputeSpec"
scout_channelvariables_api_ComputeSpec.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_ComputeSpecVisitor:

    @abstractmethod
    def _v1(self, v1: str) -> Any:
        pass


scout_channelvariables_api_ComputeSpecVisitor.__name__ = "ComputeSpecVisitor"
scout_channelvariables_api_ComputeSpecVisitor.__qualname__ = "ComputeSpecVisitor"
scout_channelvariables_api_ComputeSpecVisitor.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_VariableLocator(ConjureUnionType):
    _variable: Optional[str] = None
    _series: Optional["scout_api_ChannelLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator)
        }

    def __init__(
            self,
            variable: Optional[str] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (variable is not None) + (series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if variable is not None:
                self._variable = variable
                self._type = 'variable'
            if series is not None:
                self._series = series
                self._type = 'series'

        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_channelvariables_api_VariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_channelvariables_api_VariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)


scout_channelvariables_api_VariableLocator.__name__ = "VariableLocator"
scout_channelvariables_api_VariableLocator.__qualname__ = "VariableLocator"
scout_channelvariables_api_VariableLocator.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_VariableLocatorVisitor:

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass


scout_channelvariables_api_VariableLocatorVisitor.__name__ = "VariableLocatorVisitor"
scout_channelvariables_api_VariableLocatorVisitor.__qualname__ = "VariableLocatorVisitor"
scout_channelvariables_api_VariableLocatorVisitor.__module__ = "nominal_api.scout_channelvariables_api"


class scout_channelvariables_api_WorkbookContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_channelvariables_api_VariableLocator])
        }

    __slots__: List[str] = ['_variables']

    def __init__(self, variables: Dict[str, "scout_channelvariables_api_VariableLocator"]) -> None:
        self._variables = variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_channelvariables_api_VariableLocator"]:
        return self._variables


scout_channelvariables_api_WorkbookContext.__name__ = "WorkbookContext"
scout_channelvariables_api_WorkbookContext.__qualname__ = "WorkbookContext"
scout_channelvariables_api_WorkbookContext.__module__ = "nominal_api.scout_channelvariables_api"


class scout_chart_api_DeprecatedDefinitionAndSchemaVersion(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'schema_version': ConjureFieldDefinition('schemaVersion', str),
            'definition': ConjureFieldDefinition('definition', scout_chart_api_JsonString)
        }

    __slots__: List[str] = ['_schema_version', '_definition']

    def __init__(self, definition: str, schema_version: str) -> None:
        self._schema_version = schema_version
        self._definition = definition

    @builtins.property
    def schema_version(self) -> str:
        return self._schema_version

    @builtins.property
    def definition(self) -> str:
        return self._definition


scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__name__ = "DeprecatedDefinitionAndSchemaVersion"
scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__qualname__ = "DeprecatedDefinitionAndSchemaVersion"
scout_chart_api_DeprecatedDefinitionAndSchemaVersion.__module__ = "nominal_api.scout_chart_api"


class scout_chartdefinition_api_AlwaysConnectDisconnectedValues(ConjureBeanType):
    """This option indicates that disconnected values will always be connected with a line.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_AlwaysConnectDisconnectedValues.__name__ = "AlwaysConnectDisconnectedValues"
scout_chartdefinition_api_AlwaysConnectDisconnectedValues.__qualname__ = "AlwaysConnectDisconnectedValues"
scout_chartdefinition_api_AlwaysConnectDisconnectedValues.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisDisplayOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'show_title': ConjureFieldDefinition('showTitle', bool),
            'axis_width': ConjureFieldDefinition('axisWidth', OptionalTypeWrapper[float]),
            'scale_type': ConjureFieldDefinition('scaleType', OptionalTypeWrapper[scout_chartdefinition_api_AxisScaleType])
        }

    __slots__: List[str] = ['_show_title', '_axis_width', '_scale_type']

    def __init__(self, show_title: bool, axis_width: Optional[float] = None, scale_type: Optional["scout_chartdefinition_api_AxisScaleType"] = None) -> None:
        self._show_title = show_title
        self._axis_width = axis_width
        self._scale_type = scale_type

    @builtins.property
    def show_title(self) -> bool:
        return self._show_title

    @builtins.property
    def axis_width(self) -> Optional[float]:
        return self._axis_width

    @builtins.property
    def scale_type(self) -> Optional["scout_chartdefinition_api_AxisScaleType"]:
        """The scale type of the axis. If not specified, the default is LINEAR.
        """
        return self._scale_type


scout_chartdefinition_api_AxisDisplayOptions.__name__ = "AxisDisplayOptions"
scout_chartdefinition_api_AxisDisplayOptions.__qualname__ = "AxisDisplayOptions"
scout_chartdefinition_api_AxisDisplayOptions.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisDomainType(ConjureEnumType):

    NUMERIC = 'NUMERIC'
    '''NUMERIC'''
    CATEGORICAL = 'CATEGORICAL'
    '''CATEGORICAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_AxisDomainType.__name__ = "AxisDomainType"
scout_chartdefinition_api_AxisDomainType.__qualname__ = "AxisDomainType"
scout_chartdefinition_api_AxisDomainType.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisPosition(ConjureEnumType):

    LEFT = 'LEFT'
    '''LEFT'''
    RIGHT = 'RIGHT'
    '''RIGHT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_AxisPosition.__name__ = "AxisPosition"
scout_chartdefinition_api_AxisPosition.__qualname__ = "AxisPosition"
scout_chartdefinition_api_AxisPosition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisRange(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[float]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: Optional[float] = None, start: Optional[float] = None) -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> Optional[float]:
        return self._start

    @builtins.property
    def end(self) -> Optional[float]:
        return self._end


scout_chartdefinition_api_AxisRange.__name__ = "AxisRange"
scout_chartdefinition_api_AxisRange.__qualname__ = "AxisRange"
scout_chartdefinition_api_AxisRange.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisScaleType(ConjureEnumType):

    LINEAR = 'LINEAR'
    '''LINEAR'''
    LOG = 'LOG'
    '''LOG'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_AxisScaleType.__name__ = "AxisScaleType"
scout_chartdefinition_api_AxisScaleType.__qualname__ = "AxisScaleType"
scout_chartdefinition_api_AxisScaleType.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdGroup(ConjureUnionType):
    _line_thresholds: Optional["scout_chartdefinition_api_LineThresholdGroup"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'line_thresholds': ConjureFieldDefinition('lineThresholds', scout_chartdefinition_api_LineThresholdGroup)
        }

    def __init__(
            self,
            line_thresholds: Optional["scout_chartdefinition_api_LineThresholdGroup"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (line_thresholds is not None) != 1:
                raise ValueError('a union must contain a single member')

            if line_thresholds is not None:
                self._line_thresholds = line_thresholds
                self._type = 'lineThresholds'

        elif type_of_union == 'lineThresholds':
            if line_thresholds is None:
                raise ValueError('a union value must not be None')
            self._line_thresholds = line_thresholds
            self._type = 'lineThresholds'

    @builtins.property
    def line_thresholds(self) -> Optional["scout_chartdefinition_api_LineThresholdGroup"]:
        return self._line_thresholds

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_AxisThresholdGroupVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_AxisThresholdGroupVisitor'.format(visitor.__class__.__name__))
        if self._type == 'lineThresholds' and self.line_thresholds is not None:
            return visitor._line_thresholds(self.line_thresholds)


scout_chartdefinition_api_AxisThresholdGroup.__name__ = "AxisThresholdGroup"
scout_chartdefinition_api_AxisThresholdGroup.__qualname__ = "AxisThresholdGroup"
scout_chartdefinition_api_AxisThresholdGroup.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdGroupVisitor:

    @abstractmethod
    def _line_thresholds(self, line_thresholds: "scout_chartdefinition_api_LineThresholdGroup") -> Any:
        pass


scout_chartdefinition_api_AxisThresholdGroupVisitor.__name__ = "AxisThresholdGroupVisitor"
scout_chartdefinition_api_AxisThresholdGroupVisitor.__qualname__ = "AxisThresholdGroupVisitor"
scout_chartdefinition_api_AxisThresholdGroupVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_AxisThresholdVisualization(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'axis_id': ConjureFieldDefinition('axisId', scout_chartdefinition_api_AxisId),
            'visibility': ConjureFieldDefinition('visibility', bool),
            'thresholds': ConjureFieldDefinition('thresholds', scout_chartdefinition_api_AxisThresholdGroup)
        }

    __slots__: List[str] = ['_axis_id', '_visibility', '_thresholds']

    def __init__(self, axis_id: str, thresholds: "scout_chartdefinition_api_AxisThresholdGroup", visibility: bool) -> None:
        self._axis_id = axis_id
        self._visibility = visibility
        self._thresholds = thresholds

    @builtins.property
    def axis_id(self) -> str:
        return self._axis_id

    @builtins.property
    def visibility(self) -> bool:
        """Determines it's current visibility in the time series chart.
        """
        return self._visibility

    @builtins.property
    def thresholds(self) -> "scout_chartdefinition_api_AxisThresholdGroup":
        return self._thresholds


scout_chartdefinition_api_AxisThresholdVisualization.__name__ = "AxisThresholdVisualization"
scout_chartdefinition_api_AxisThresholdVisualization.__qualname__ = "AxisThresholdVisualization"
scout_chartdefinition_api_AxisThresholdVisualization.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_BitFlag(ConjureBeanType):
    """The settings for a bit flag mapping. Each position should be unique. Position 0 represents the least significant bit
and position 31 represents the most significant bit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'position': ConjureFieldDefinition('position', int),
            'label': ConjureFieldDefinition('label', str)
        }

    __slots__: List[str] = ['_position', '_label']

    def __init__(self, label: str, position: int) -> None:
        self._position = position
        self._label = label

    @builtins.property
    def position(self) -> int:
        return self._position

    @builtins.property
    def label(self) -> str:
        return self._label


scout_chartdefinition_api_BitFlag.__name__ = "BitFlag"
scout_chartdefinition_api_BitFlag.__qualname__ = "BitFlag"
scout_chartdefinition_api_BitFlag.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_BitFlagMapCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_BitFlagMapVisualisation])
        }

    __slots__: List[str] = ['_visualisation']

    def __init__(self, visualisation: Optional["scout_chartdefinition_api_BitFlagMapVisualisation"] = None) -> None:
        self._visualisation = visualisation

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_BitFlagMapVisualisation"]:
        return self._visualisation


scout_chartdefinition_api_BitFlagMapCellConfig.__name__ = "BitFlagMapCellConfig"
scout_chartdefinition_api_BitFlagMapCellConfig.__qualname__ = "BitFlagMapCellConfig"
scout_chartdefinition_api_BitFlagMapCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_BitFlagMapRawVisualisation(ConjureBeanType):
    """The settings for a raw bit flag map visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'high_color': ConjureFieldDefinition('highColor', OptionalTypeWrapper[scout_api_HexColor]),
            'low_color': ConjureFieldDefinition('lowColor', OptionalTypeWrapper[scout_api_HexColor]),
            'bit_flags': ConjureFieldDefinition('bitFlags', List[scout_chartdefinition_api_BitFlag])
        }

    __slots__: List[str] = ['_high_color', '_low_color', '_bit_flags']

    def __init__(self, bit_flags: List["scout_chartdefinition_api_BitFlag"], high_color: Optional[str] = None, low_color: Optional[str] = None) -> None:
        self._high_color = high_color
        self._low_color = low_color
        self._bit_flags = bit_flags

    @builtins.property
    def high_color(self) -> Optional[str]:
        """The color when any bit is high
        """
        return self._high_color

    @builtins.property
    def low_color(self) -> Optional[str]:
        """The color when all bits are low
        """
        return self._low_color

    @builtins.property
    def bit_flags(self) -> List["scout_chartdefinition_api_BitFlag"]:
        return self._bit_flags


scout_chartdefinition_api_BitFlagMapRawVisualisation.__name__ = "BitFlagMapRawVisualisation"
scout_chartdefinition_api_BitFlagMapRawVisualisation.__qualname__ = "BitFlagMapRawVisualisation"
scout_chartdefinition_api_BitFlagMapRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_BitFlagMapVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_BitFlagMapRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_BitFlagMapRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_BitFlagMapRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_BitFlagMapRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_BitFlagMapVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_BitFlagMapVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_BitFlagMapVisualisation.__name__ = "BitFlagMapVisualisation"
scout_chartdefinition_api_BitFlagMapVisualisation.__qualname__ = "BitFlagMapVisualisation"
scout_chartdefinition_api_BitFlagMapVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_BitFlagMapVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_BitFlagMapRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_BitFlagMapVisualisationVisitor.__name__ = "BitFlagMapVisualisationVisitor"
scout_chartdefinition_api_BitFlagMapVisualisationVisitor.__qualname__ = "BitFlagMapVisualisationVisitor"
scout_chartdefinition_api_BitFlagMapVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_CartesianChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_CartesianChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_CartesianChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_CartesianChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_CartesianChartDefinition.__name__ = "CartesianChartDefinition"
scout_chartdefinition_api_CartesianChartDefinition.__qualname__ = "CartesianChartDefinition"
scout_chartdefinition_api_CartesianChartDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_CartesianChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_CartesianChartDefinitionVisitor.__name__ = "CartesianChartDefinitionVisitor"
scout_chartdefinition_api_CartesianChartDefinitionVisitor.__qualname__ = "CartesianChartDefinitionVisitor"
scout_chartdefinition_api_CartesianChartDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_CartesianPlot]),
            'events': ConjureFieldDefinition('events', OptionalTypeWrapper[List[scout_chartdefinition_api_Event]]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'connect_points': ConjureFieldDefinition('connectPoints', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_plots', '_events', '_comparison_run_groups', '_title', '_value_axes', '_connect_points']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], plots: List["scout_chartdefinition_api_CartesianPlot"], value_axes: List["scout_chartdefinition_api_ValueAxis"], connect_points: Optional[bool] = None, events: Optional[List["scout_chartdefinition_api_Event"]] = None, title: Optional[str] = None) -> None:
        self._plots = plots
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._value_axes = value_axes
        self._connect_points = connect_points

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_CartesianPlot"]:
        return self._plots

    @builtins.property
    def events(self) -> Optional[List["scout_chartdefinition_api_Event"]]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes

    @builtins.property
    def connect_points(self) -> Optional[bool]:
        """If toggled true, will visually connect the points of the series
        """
        return self._connect_points


scout_chartdefinition_api_CartesianChartDefinitionV1.__name__ = "CartesianChartDefinitionV1"
scout_chartdefinition_api_CartesianChartDefinitionV1.__qualname__ = "CartesianChartDefinitionV1"
scout_chartdefinition_api_CartesianChartDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_CartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_variable_name': ConjureFieldDefinition('xVariableName', scout_channelvariables_api_ChannelVariableName),
            'y_variable_name': ConjureFieldDefinition('yVariableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'x_axis_id': ConjureFieldDefinition('xAxisId', scout_chartdefinition_api_AxisId),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_x_variable_name', '_y_variable_name', '_enabled', '_x_axis_id', '_y_axis_id', '_color']

    def __init__(self, color: str, x_axis_id: str, x_variable_name: str, y_axis_id: str, y_variable_name: str, enabled: Optional[bool] = None) -> None:
        self._x_variable_name = x_variable_name
        self._y_variable_name = y_variable_name
        self._enabled = enabled
        self._x_axis_id = x_axis_id
        self._y_axis_id = y_axis_id
        self._color = color

    @builtins.property
    def x_variable_name(self) -> str:
        return self._x_variable_name

    @builtins.property
    def y_variable_name(self) -> str:
        return self._y_variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def x_axis_id(self) -> str:
        return self._x_axis_id

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_CartesianPlot.__name__ = "CartesianPlot"
scout_chartdefinition_api_CartesianPlot.__qualname__ = "CartesianPlot"
scout_chartdefinition_api_CartesianPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_ChecklistChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_ChecklistChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ChecklistChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ChecklistChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_ChecklistChartDefinition.__name__ = "ChecklistChartDefinition"
scout_chartdefinition_api_ChecklistChartDefinition.__qualname__ = "ChecklistChartDefinition"
scout_chartdefinition_api_ChecklistChartDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_ChecklistChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__name__ = "ChecklistChartDefinitionVisitor"
scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__qualname__ = "ChecklistChartDefinitionVisitor"
scout_chartdefinition_api_ChecklistChartDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ChecklistChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'selected_checklist_rids': ConjureFieldDefinition('selectedChecklistRids', List[str]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_selected_checklist_rids', '_title']

    def __init__(self, selected_checklist_rids: List[str], title: Optional[str] = None) -> None:
        self._selected_checklist_rids = selected_checklist_rids
        self._title = title

    @builtins.property
    def selected_checklist_rids(self) -> List[str]:
        return self._selected_checklist_rids

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title


scout_chartdefinition_api_ChecklistChartDefinitionV1.__name__ = "ChecklistChartDefinitionV1"
scout_chartdefinition_api_ChecklistChartDefinitionV1.__qualname__ = "ChecklistChartDefinitionV1"
scout_chartdefinition_api_ChecklistChartDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ColorStyle(ConjureUnionType):
    _mapped: Optional[Dict[str, str]] = None
    _single: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'mapped': ConjureFieldDefinition('mapped', Dict[str, scout_api_HexColor]),
            'single': ConjureFieldDefinition('single', scout_api_HexColor)
        }

    def __init__(
            self,
            mapped: Optional[Dict[str, str]] = None,
            single: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (mapped is not None) + (single is not None) != 1:
                raise ValueError('a union must contain a single member')

            if mapped is not None:
                self._mapped = mapped
                self._type = 'mapped'
            if single is not None:
                self._single = single
                self._type = 'single'

        elif type_of_union == 'mapped':
            if mapped is None:
                raise ValueError('a union value must not be None')
            self._mapped = mapped
            self._type = 'mapped'
        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'

    @builtins.property
    def mapped(self) -> Optional[Dict[str, str]]:
        """Defines specific colors for specific values
        """
        return self._mapped

    @builtins.property
    def single(self) -> Optional[str]:
        """A single color to apply to the whole plot
        """
        return self._single

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ColorStyleVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ColorStyleVisitor'.format(visitor.__class__.__name__))
        if self._type == 'mapped' and self.mapped is not None:
            return visitor._mapped(self.mapped)
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)


scout_chartdefinition_api_ColorStyle.__name__ = "ColorStyle"
scout_chartdefinition_api_ColorStyle.__qualname__ = "ColorStyle"
scout_chartdefinition_api_ColorStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ColorStyleVisitor:

    @abstractmethod
    def _mapped(self, mapped: Dict[str, str]) -> Any:
        pass

    @abstractmethod
    def _single(self, single: str) -> Any:
        pass


scout_chartdefinition_api_ColorStyleVisitor.__name__ = "ColorStyleVisitor"
scout_chartdefinition_api_ColorStyleVisitor.__qualname__ = "ColorStyleVisitor"
scout_chartdefinition_api_ColorStyleVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DecimalPlaces(ConjureUnionType):
    _fixed: Optional["scout_chartdefinition_api_FixedDecimalPlaces"] = None
    _max: Optional["scout_chartdefinition_api_MaxDecimalPlaces"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fixed': ConjureFieldDefinition('fixed', scout_chartdefinition_api_FixedDecimalPlaces),
            'max': ConjureFieldDefinition('max', scout_chartdefinition_api_MaxDecimalPlaces)
        }

    def __init__(
            self,
            fixed: Optional["scout_chartdefinition_api_FixedDecimalPlaces"] = None,
            max: Optional["scout_chartdefinition_api_MaxDecimalPlaces"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fixed is not None) + (max is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fixed is not None:
                self._fixed = fixed
                self._type = 'fixed'
            if max is not None:
                self._max = max
                self._type = 'max'

        elif type_of_union == 'fixed':
            if fixed is None:
                raise ValueError('a union value must not be None')
            self._fixed = fixed
            self._type = 'fixed'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'

    @builtins.property
    def fixed(self) -> Optional["scout_chartdefinition_api_FixedDecimalPlaces"]:
        return self._fixed

    @builtins.property
    def max(self) -> Optional["scout_chartdefinition_api_MaxDecimalPlaces"]:
        return self._max

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_DecimalPlacesVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_DecimalPlacesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fixed' and self.fixed is not None:
            return visitor._fixed(self.fixed)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)


scout_chartdefinition_api_DecimalPlaces.__name__ = "DecimalPlaces"
scout_chartdefinition_api_DecimalPlaces.__qualname__ = "DecimalPlaces"
scout_chartdefinition_api_DecimalPlaces.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DecimalPlacesVisitor:

    @abstractmethod
    def _fixed(self, fixed: "scout_chartdefinition_api_FixedDecimalPlaces") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_chartdefinition_api_MaxDecimalPlaces") -> Any:
        pass


scout_chartdefinition_api_DecimalPlacesVisitor.__name__ = "DecimalPlacesVisitor"
scout_chartdefinition_api_DecimalPlacesVisitor.__qualname__ = "DecimalPlacesVisitor"
scout_chartdefinition_api_DecimalPlacesVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DefaultFill(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_color']

    def __init__(self, color: str) -> None:
        self._color = color

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_DefaultFill.__name__ = "DefaultFill"
scout_chartdefinition_api_DefaultFill.__qualname__ = "DefaultFill"
scout_chartdefinition_api_DefaultFill.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DisconnectedValueVisualization(ConjureUnionType):
    _always_connect: Optional["scout_chartdefinition_api_AlwaysConnectDisconnectedValues"] = None
    _never: Optional["scout_chartdefinition_api_NeverConnectDisconnectedValues"] = None
    _threshold: Optional["scout_chartdefinition_api_ThresholdDisconnectedValues"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'always_connect': ConjureFieldDefinition('alwaysConnect', scout_chartdefinition_api_AlwaysConnectDisconnectedValues),
            'never': ConjureFieldDefinition('never', scout_chartdefinition_api_NeverConnectDisconnectedValues),
            'threshold': ConjureFieldDefinition('threshold', scout_chartdefinition_api_ThresholdDisconnectedValues)
        }

    def __init__(
            self,
            always_connect: Optional["scout_chartdefinition_api_AlwaysConnectDisconnectedValues"] = None,
            never: Optional["scout_chartdefinition_api_NeverConnectDisconnectedValues"] = None,
            threshold: Optional["scout_chartdefinition_api_ThresholdDisconnectedValues"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (always_connect is not None) + (never is not None) + (threshold is not None) != 1:
                raise ValueError('a union must contain a single member')

            if always_connect is not None:
                self._always_connect = always_connect
                self._type = 'alwaysConnect'
            if never is not None:
                self._never = never
                self._type = 'never'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'

        elif type_of_union == 'alwaysConnect':
            if always_connect is None:
                raise ValueError('a union value must not be None')
            self._always_connect = always_connect
            self._type = 'alwaysConnect'
        elif type_of_union == 'never':
            if never is None:
                raise ValueError('a union value must not be None')
            self._never = never
            self._type = 'never'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'

    @builtins.property
    def always_connect(self) -> Optional["scout_chartdefinition_api_AlwaysConnectDisconnectedValues"]:
        return self._always_connect

    @builtins.property
    def never(self) -> Optional["scout_chartdefinition_api_NeverConnectDisconnectedValues"]:
        return self._never

    @builtins.property
    def threshold(self) -> Optional["scout_chartdefinition_api_ThresholdDisconnectedValues"]:
        return self._threshold

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_DisconnectedValueVisualizationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_DisconnectedValueVisualizationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'alwaysConnect' and self.always_connect is not None:
            return visitor._always_connect(self.always_connect)
        if self._type == 'never' and self.never is not None:
            return visitor._never(self.never)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)


scout_chartdefinition_api_DisconnectedValueVisualization.__name__ = "DisconnectedValueVisualization"
scout_chartdefinition_api_DisconnectedValueVisualization.__qualname__ = "DisconnectedValueVisualization"
scout_chartdefinition_api_DisconnectedValueVisualization.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_DisconnectedValueVisualizationVisitor:

    @abstractmethod
    def _always_connect(self, always_connect: "scout_chartdefinition_api_AlwaysConnectDisconnectedValues") -> Any:
        pass

    @abstractmethod
    def _never(self, never: "scout_chartdefinition_api_NeverConnectDisconnectedValues") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_chartdefinition_api_ThresholdDisconnectedValues") -> Any:
        pass


scout_chartdefinition_api_DisconnectedValueVisualizationVisitor.__name__ = "DisconnectedValueVisualizationVisitor"
scout_chartdefinition_api_DisconnectedValueVisualizationVisitor.__qualname__ = "DisconnectedValueVisualizationVisitor"
scout_chartdefinition_api_DisconnectedValueVisualizationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumArrayCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_EnumArrayVisualisation])
        }

    __slots__: List[str] = ['_visualisation']

    def __init__(self, visualisation: Optional["scout_chartdefinition_api_EnumArrayVisualisation"] = None) -> None:
        self._visualisation = visualisation

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_EnumArrayVisualisation"]:
        return self._visualisation


scout_chartdefinition_api_EnumArrayCellConfig.__name__ = "EnumArrayCellConfig"
scout_chartdefinition_api_EnumArrayCellConfig.__qualname__ = "EnumArrayCellConfig"
scout_chartdefinition_api_EnumArrayCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumArrayRawVisualisation(ConjureBeanType):
    """A raw enum array visualisation with optional coloring based on enum thresholds.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_EnumArrayRawVisualisation.__name__ = "EnumArrayRawVisualisation"
scout_chartdefinition_api_EnumArrayRawVisualisation.__qualname__ = "EnumArrayRawVisualisation"
scout_chartdefinition_api_EnumArrayRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumArrayVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_EnumArrayRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_EnumArrayRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_EnumArrayRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_EnumArrayRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_EnumArrayVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_EnumArrayVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_EnumArrayVisualisation.__name__ = "EnumArrayVisualisation"
scout_chartdefinition_api_EnumArrayVisualisation.__qualname__ = "EnumArrayVisualisation"
scout_chartdefinition_api_EnumArrayVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumArrayVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_EnumArrayRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_EnumArrayVisualisationVisitor.__name__ = "EnumArrayVisualisationVisitor"
scout_chartdefinition_api_EnumArrayVisualisationVisitor.__qualname__ = "EnumArrayVisualisationVisitor"
scout_chartdefinition_api_EnumArrayVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_EnumValueVisualisation]),
            'group_by_sort': ConjureFieldDefinition('groupBySort', OptionalTypeWrapper[scout_chartdefinition_api_EnumGroupBySort])
        }

    __slots__: List[str] = ['_visualisation', '_group_by_sort']

    def __init__(self, group_by_sort: Optional["scout_chartdefinition_api_EnumGroupBySort"] = None, visualisation: Optional["scout_chartdefinition_api_EnumValueVisualisation"] = None) -> None:
        self._visualisation = visualisation
        self._group_by_sort = group_by_sort

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_EnumValueVisualisation"]:
        return self._visualisation

    @builtins.property
    def group_by_sort(self) -> Optional["scout_chartdefinition_api_EnumGroupBySort"]:
        """Sorting configuration for grouped data rendering in a cell.
If undefined, will sort alphabetically by grouping.
        """
        return self._group_by_sort


scout_chartdefinition_api_EnumCellConfig.__name__ = "EnumCellConfig"
scout_chartdefinition_api_EnumCellConfig.__qualname__ = "EnumCellConfig"
scout_chartdefinition_api_EnumCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyle(ConjureUnionType):
    _stacked: Optional["scout_chartdefinition_api_EnumDisplayStyleStacked"] = None
    _inline: Optional["scout_chartdefinition_api_EnumDisplayStyleInline"] = None
    _bar: Optional["scout_chartdefinition_api_EnumDisplayStyleBar"] = None
    _line: Optional["scout_chartdefinition_api_EnumDisplayStyleLine"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stacked': ConjureFieldDefinition('stacked', scout_chartdefinition_api_EnumDisplayStyleStacked),
            'inline': ConjureFieldDefinition('inline', scout_chartdefinition_api_EnumDisplayStyleInline),
            'bar': ConjureFieldDefinition('bar', scout_chartdefinition_api_EnumDisplayStyleBar),
            'line': ConjureFieldDefinition('line', scout_chartdefinition_api_EnumDisplayStyleLine)
        }

    def __init__(
            self,
            stacked: Optional["scout_chartdefinition_api_EnumDisplayStyleStacked"] = None,
            inline: Optional["scout_chartdefinition_api_EnumDisplayStyleInline"] = None,
            bar: Optional["scout_chartdefinition_api_EnumDisplayStyleBar"] = None,
            line: Optional["scout_chartdefinition_api_EnumDisplayStyleLine"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (stacked is not None) + (inline is not None) + (bar is not None) + (line is not None) != 1:
                raise ValueError('a union must contain a single member')

            if stacked is not None:
                self._stacked = stacked
                self._type = 'stacked'
            if inline is not None:
                self._inline = inline
                self._type = 'inline'
            if bar is not None:
                self._bar = bar
                self._type = 'bar'
            if line is not None:
                self._line = line
                self._type = 'line'

        elif type_of_union == 'stacked':
            if stacked is None:
                raise ValueError('a union value must not be None')
            self._stacked = stacked
            self._type = 'stacked'
        elif type_of_union == 'inline':
            if inline is None:
                raise ValueError('a union value must not be None')
            self._inline = inline
            self._type = 'inline'
        elif type_of_union == 'bar':
            if bar is None:
                raise ValueError('a union value must not be None')
            self._bar = bar
            self._type = 'bar'
        elif type_of_union == 'line':
            if line is None:
                raise ValueError('a union value must not be None')
            self._line = line
            self._type = 'line'

    @builtins.property
    def stacked(self) -> Optional["scout_chartdefinition_api_EnumDisplayStyleStacked"]:
        return self._stacked

    @builtins.property
    def inline(self) -> Optional["scout_chartdefinition_api_EnumDisplayStyleInline"]:
        return self._inline

    @builtins.property
    def bar(self) -> Optional["scout_chartdefinition_api_EnumDisplayStyleBar"]:
        return self._bar

    @builtins.property
    def line(self) -> Optional["scout_chartdefinition_api_EnumDisplayStyleLine"]:
        return self._line

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_EnumDisplayStyleVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_EnumDisplayStyleVisitor'.format(visitor.__class__.__name__))
        if self._type == 'stacked' and self.stacked is not None:
            return visitor._stacked(self.stacked)
        if self._type == 'inline' and self.inline is not None:
            return visitor._inline(self.inline)
        if self._type == 'bar' and self.bar is not None:
            return visitor._bar(self.bar)
        if self._type == 'line' and self.line is not None:
            return visitor._line(self.line)


scout_chartdefinition_api_EnumDisplayStyle.__name__ = "EnumDisplayStyle"
scout_chartdefinition_api_EnumDisplayStyle.__qualname__ = "EnumDisplayStyle"
scout_chartdefinition_api_EnumDisplayStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyleVisitor:

    @abstractmethod
    def _stacked(self, stacked: "scout_chartdefinition_api_EnumDisplayStyleStacked") -> Any:
        pass

    @abstractmethod
    def _inline(self, inline: "scout_chartdefinition_api_EnumDisplayStyleInline") -> Any:
        pass

    @abstractmethod
    def _bar(self, bar: "scout_chartdefinition_api_EnumDisplayStyleBar") -> Any:
        pass

    @abstractmethod
    def _line(self, line: "scout_chartdefinition_api_EnumDisplayStyleLine") -> Any:
        pass


scout_chartdefinition_api_EnumDisplayStyleVisitor.__name__ = "EnumDisplayStyleVisitor"
scout_chartdefinition_api_EnumDisplayStyleVisitor.__qualname__ = "EnumDisplayStyleVisitor"
scout_chartdefinition_api_EnumDisplayStyleVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyleBar(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_EnumDisplayStyleBar.__name__ = "EnumDisplayStyleBar"
scout_chartdefinition_api_EnumDisplayStyleBar.__qualname__ = "EnumDisplayStyleBar"
scout_chartdefinition_api_EnumDisplayStyleBar.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyleInline(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_EnumDisplayStyleInline.__name__ = "EnumDisplayStyleInline"
scout_chartdefinition_api_EnumDisplayStyleInline.__qualname__ = "EnumDisplayStyleInline"
scout_chartdefinition_api_EnumDisplayStyleInline.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyleLine(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_EnumDisplayStyleLine.__name__ = "EnumDisplayStyleLine"
scout_chartdefinition_api_EnumDisplayStyleLine.__qualname__ = "EnumDisplayStyleLine"
scout_chartdefinition_api_EnumDisplayStyleLine.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumDisplayStyleStacked(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_EnumDisplayStyleStacked.__name__ = "EnumDisplayStyleStacked"
scout_chartdefinition_api_EnumDisplayStyleStacked.__qualname__ = "EnumDisplayStyleStacked"
scout_chartdefinition_api_EnumDisplayStyleStacked.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumGroupBySort(ConjureUnionType):
    _custom: Optional["scout_chartdefinition_api_EnumGroupBySortCustom"] = None
    _alphabetical: Optional["scout_chartdefinition_api_ValueSort"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'custom': ConjureFieldDefinition('custom', scout_chartdefinition_api_EnumGroupBySortCustom),
            'alphabetical': ConjureFieldDefinition('alphabetical', scout_chartdefinition_api_ValueSort)
        }

    def __init__(
            self,
            custom: Optional["scout_chartdefinition_api_EnumGroupBySortCustom"] = None,
            alphabetical: Optional["scout_chartdefinition_api_ValueSort"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (custom is not None) + (alphabetical is not None) != 1:
                raise ValueError('a union must contain a single member')

            if custom is not None:
                self._custom = custom
                self._type = 'custom'
            if alphabetical is not None:
                self._alphabetical = alphabetical
                self._type = 'alphabetical'

        elif type_of_union == 'custom':
            if custom is None:
                raise ValueError('a union value must not be None')
            self._custom = custom
            self._type = 'custom'
        elif type_of_union == 'alphabetical':
            if alphabetical is None:
                raise ValueError('a union value must not be None')
            self._alphabetical = alphabetical
            self._type = 'alphabetical'

    @builtins.property
    def custom(self) -> Optional["scout_chartdefinition_api_EnumGroupBySortCustom"]:
        return self._custom

    @builtins.property
    def alphabetical(self) -> Optional["scout_chartdefinition_api_ValueSort"]:
        return self._alphabetical

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_EnumGroupBySortVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_EnumGroupBySortVisitor'.format(visitor.__class__.__name__))
        if self._type == 'custom' and self.custom is not None:
            return visitor._custom(self.custom)
        if self._type == 'alphabetical' and self.alphabetical is not None:
            return visitor._alphabetical(self.alphabetical)


scout_chartdefinition_api_EnumGroupBySort.__name__ = "EnumGroupBySort"
scout_chartdefinition_api_EnumGroupBySort.__qualname__ = "EnumGroupBySort"
scout_chartdefinition_api_EnumGroupBySort.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumGroupBySortVisitor:

    @abstractmethod
    def _custom(self, custom: "scout_chartdefinition_api_EnumGroupBySortCustom") -> Any:
        pass

    @abstractmethod
    def _alphabetical(self, alphabetical: "scout_chartdefinition_api_ValueSort") -> Any:
        pass


scout_chartdefinition_api_EnumGroupBySortVisitor.__name__ = "EnumGroupBySortVisitor"
scout_chartdefinition_api_EnumGroupBySortVisitor.__qualname__ = "EnumGroupBySortVisitor"
scout_chartdefinition_api_EnumGroupBySortVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumGroupBySortCustom(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'order': ConjureFieldDefinition('order', List[str])
        }

    __slots__: List[str] = ['_order']

    def __init__(self, order: List[str]) -> None:
        self._order = order

    @builtins.property
    def order(self) -> List[str]:
        """Specify the values in the order they should appear.
Unspecified values will be sorted to the bottom.
        """
        return self._order


scout_chartdefinition_api_EnumGroupBySortCustom.__name__ = "EnumGroupBySortCustom"
scout_chartdefinition_api_EnumGroupBySortCustom.__qualname__ = "EnumGroupBySortCustom"
scout_chartdefinition_api_EnumGroupBySortCustom.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumRawVisualisation(ConjureBeanType):
    """The settings for a raw enum visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color_map': ConjureFieldDefinition('colorMap', OptionalTypeWrapper[Dict[str, scout_api_HexColor]])
        }

    __slots__: List[str] = ['_color_map']

    def __init__(self, color_map: Optional[Dict[str, str]] = None) -> None:
        self._color_map = color_map

    @builtins.property
    def color_map(self) -> Optional[Dict[str, str]]:
        return self._color_map


scout_chartdefinition_api_EnumRawVisualisation.__name__ = "EnumRawVisualisation"
scout_chartdefinition_api_EnumRawVisualisation.__qualname__ = "EnumRawVisualisation"
scout_chartdefinition_api_EnumRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_EnumValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_EnumValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_EnumValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_EnumValueChannel.__name__ = "EnumValueChannel"
scout_chartdefinition_api_EnumValueChannel.__qualname__ = "EnumValueChannel"
scout_chartdefinition_api_EnumValueChannel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_EnumRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_EnumRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_EnumRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_EnumRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_EnumValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_EnumValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_EnumValueVisualisation.__name__ = "EnumValueVisualisation"
scout_chartdefinition_api_EnumValueVisualisation.__qualname__ = "EnumValueVisualisation"
scout_chartdefinition_api_EnumValueVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_EnumValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_EnumRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_EnumValueVisualisationVisitor.__name__ = "EnumValueVisualisationVisitor"
scout_chartdefinition_api_EnumValueVisualisationVisitor.__qualname__ = "EnumValueVisualisationVisitor"
scout_chartdefinition_api_EnumValueVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Event(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'event_uuid': ConjureFieldDefinition('eventUuid', str),
            'is_pinned': ConjureFieldDefinition('isPinned', bool)
        }

    __slots__: List[str] = ['_display_name', '_event_uuid', '_is_pinned']

    def __init__(self, event_uuid: str, is_pinned: bool, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._event_uuid = event_uuid
        self._is_pinned = is_pinned

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def event_uuid(self) -> str:
        return self._event_uuid

    @builtins.property
    def is_pinned(self) -> bool:
        return self._is_pinned


scout_chartdefinition_api_Event.__name__ = "Event"
scout_chartdefinition_api_Event.__qualname__ = "Event"
scout_chartdefinition_api_Event.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Figure(ConjureBeanType):
    """The root figure definition for a plotly instance
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data': ConjureFieldDefinition('data', List[scout_chartdefinition_api_Trace]),
            'layout': ConjureFieldDefinition('layout', scout_chartdefinition_api_Layout),
            'plotly_config': ConjureFieldDefinition('plotlyConfig', str)
        }

    __slots__: List[str] = ['_data', '_layout', '_plotly_config']

    def __init__(self, data: List["scout_chartdefinition_api_Trace"], layout: "scout_chartdefinition_api_Layout", plotly_config: str) -> None:
        self._data = data
        self._layout = layout
        self._plotly_config = plotly_config

    @builtins.property
    def data(self) -> List["scout_chartdefinition_api_Trace"]:
        return self._data

    @builtins.property
    def layout(self) -> "scout_chartdefinition_api_Layout":
        return self._layout

    @builtins.property
    def plotly_config(self) -> str:
        """The json config definition according to plotly's schema
https://plotly.com/python/figure-structure/#the-toplevel-config-attribute
        """
        return self._plotly_config


scout_chartdefinition_api_Figure.__name__ = "Figure"
scout_chartdefinition_api_Figure.__qualname__ = "Figure"
scout_chartdefinition_api_Figure.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FixedDecimalPlaces(ConjureBeanType):
    """Format the number to a fixed number of decimal places, padding with zeroes or rounding as needed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'places': ConjureFieldDefinition('places', int)
        }

    __slots__: List[str] = ['_places']

    def __init__(self, places: int) -> None:
        self._places = places

    @builtins.property
    def places(self) -> int:
        return self._places


scout_chartdefinition_api_FixedDecimalPlaces.__name__ = "FixedDecimalPlaces"
scout_chartdefinition_api_FixedDecimalPlaces.__qualname__ = "FixedDecimalPlaces"
scout_chartdefinition_api_FixedDecimalPlaces.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FloatingLegend(ConjureUnionType):
    _per_row: Optional["scout_chartdefinition_api_PerRowFloatingLegends"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'per_row': ConjureFieldDefinition('perRow', scout_chartdefinition_api_PerRowFloatingLegends)
        }

    def __init__(
            self,
            per_row: Optional["scout_chartdefinition_api_PerRowFloatingLegends"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (per_row is not None) != 1:
                raise ValueError('a union must contain a single member')

            if per_row is not None:
                self._per_row = per_row
                self._type = 'perRow'

        elif type_of_union == 'perRow':
            if per_row is None:
                raise ValueError('a union value must not be None')
            self._per_row = per_row
            self._type = 'perRow'

    @builtins.property
    def per_row(self) -> Optional["scout_chartdefinition_api_PerRowFloatingLegends"]:
        return self._per_row

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_FloatingLegendVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_FloatingLegendVisitor'.format(visitor.__class__.__name__))
        if self._type == 'perRow' and self.per_row is not None:
            return visitor._per_row(self.per_row)


scout_chartdefinition_api_FloatingLegend.__name__ = "FloatingLegend"
scout_chartdefinition_api_FloatingLegend.__qualname__ = "FloatingLegend"
scout_chartdefinition_api_FloatingLegend.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FloatingLegendVisitor:

    @abstractmethod
    def _per_row(self, per_row: "scout_chartdefinition_api_PerRowFloatingLegends") -> Any:
        pass


scout_chartdefinition_api_FloatingLegendVisitor.__name__ = "FloatingLegendVisitor"
scout_chartdefinition_api_FloatingLegendVisitor.__qualname__ = "FloatingLegendVisitor"
scout_chartdefinition_api_FloatingLegendVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FloatingLegendConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'hidden': ConjureFieldDefinition('hidden', OptionalTypeWrapper[bool]),
            'legend': ConjureFieldDefinition('legend', scout_chartdefinition_api_FloatingLegend)
        }

    __slots__: List[str] = ['_hidden', '_legend']

    def __init__(self, legend: "scout_chartdefinition_api_FloatingLegend", hidden: Optional[bool] = None) -> None:
        self._hidden = hidden
        self._legend = legend

    @builtins.property
    def hidden(self) -> Optional[bool]:
        """Whether to hide the floating legend. Defaults to false.
        """
        return self._hidden

    @builtins.property
    def legend(self) -> "scout_chartdefinition_api_FloatingLegend":
        return self._legend


scout_chartdefinition_api_FloatingLegendConfig.__name__ = "FloatingLegendConfig"
scout_chartdefinition_api_FloatingLegendConfig.__qualname__ = "FloatingLegendConfig"
scout_chartdefinition_api_FloatingLegendConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"] = None
    _v2: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_FrequencyChartDefinitionV1),
            'v2': ConjureFieldDefinition('v2', scout_chartdefinition_api_FrequencyChartDefinitionV2)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"] = None,
            v2: Optional["scout_chartdefinition_api_FrequencyChartDefinitionV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) + (v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'
            if v2 is not None:
                self._v2 = v2
                self._type = 'v2'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'
        elif type_of_union == 'v2':
            if v2 is None:
                raise ValueError('a union value must not be None')
            self._v2 = v2
            self._type = 'v2'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_FrequencyChartDefinitionV1"]:
        return self._v1

    @builtins.property
    def v2(self) -> Optional["scout_chartdefinition_api_FrequencyChartDefinitionV2"]:
        return self._v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_FrequencyChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_FrequencyChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)
        if self._type == 'v2' and self.v2 is not None:
            return visitor._v2(self.v2)


scout_chartdefinition_api_FrequencyChartDefinition.__name__ = "FrequencyChartDefinition"
scout_chartdefinition_api_FrequencyChartDefinition.__qualname__ = "FrequencyChartDefinition"
scout_chartdefinition_api_FrequencyChartDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_FrequencyChartDefinitionV1") -> Any:
        pass

    @abstractmethod
    def _v2(self, v2: "scout_chartdefinition_api_FrequencyChartDefinitionV2") -> Any:
        pass


scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__name__ = "FrequencyChartDefinitionVisitor"
scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__qualname__ = "FrequencyChartDefinitionVisitor"
scout_chartdefinition_api_FrequencyChartDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_FrequencyPlot]),
            'events': ConjureFieldDefinition('events', OptionalTypeWrapper[List[scout_chartdefinition_api_Event]]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'plot_type': ConjureFieldDefinition('plotType', OptionalTypeWrapper[scout_chartdefinition_api_FrequencyPlotType])
        }

    __slots__: List[str] = ['_plots', '_events', '_comparison_run_groups', '_title', '_value_axes', '_plot_type']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], plots: List["scout_chartdefinition_api_FrequencyPlot"], value_axes: List["scout_chartdefinition_api_ValueAxis"], events: Optional[List["scout_chartdefinition_api_Event"]] = None, plot_type: Optional["scout_chartdefinition_api_FrequencyPlotType"] = None, title: Optional[str] = None) -> None:
        self._plots = plots
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._value_axes = value_axes
        self._plot_type = plot_type

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_FrequencyPlot"]:
        return self._plots

    @builtins.property
    def events(self) -> Optional[List["scout_chartdefinition_api_Event"]]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes

    @builtins.property
    def plot_type(self) -> Optional["scout_chartdefinition_api_FrequencyPlotType"]:
        """The type of plot to display. If not specified, the default is FFT.
        """
        return self._plot_type


scout_chartdefinition_api_FrequencyChartDefinitionV1.__name__ = "FrequencyChartDefinitionV1"
scout_chartdefinition_api_FrequencyChartDefinitionV1.__qualname__ = "FrequencyChartDefinitionV1"
scout_chartdefinition_api_FrequencyChartDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyChartDefinitionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_FrequencyPlotV2]),
            'events': ConjureFieldDefinition('events', OptionalTypeWrapper[List[scout_chartdefinition_api_Event]]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'plot_type': ConjureFieldDefinition('plotType', OptionalTypeWrapper[scout_chartdefinition_api_FrequencyPlotType])
        }

    __slots__: List[str] = ['_plots', '_events', '_comparison_run_groups', '_title', '_value_axes', '_plot_type']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], plots: List["scout_chartdefinition_api_FrequencyPlotV2"], value_axes: List["scout_chartdefinition_api_ValueAxis"], events: Optional[List["scout_chartdefinition_api_Event"]] = None, plot_type: Optional["scout_chartdefinition_api_FrequencyPlotType"] = None, title: Optional[str] = None) -> None:
        self._plots = plots
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._value_axes = value_axes
        self._plot_type = plot_type

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_FrequencyPlotV2"]:
        return self._plots

    @builtins.property
    def events(self) -> Optional[List["scout_chartdefinition_api_Event"]]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes

    @builtins.property
    def plot_type(self) -> Optional["scout_chartdefinition_api_FrequencyPlotType"]:
        """The type of plot to display. If not specified, the default is FFT.
        """
        return self._plot_type


scout_chartdefinition_api_FrequencyChartDefinitionV2.__name__ = "FrequencyChartDefinitionV2"
scout_chartdefinition_api_FrequencyChartDefinitionV2.__qualname__ = "FrequencyChartDefinitionV2"
scout_chartdefinition_api_FrequencyChartDefinitionV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlot(ConjureBeanType):
    """A frequency plot that displays a real value against the frequency domain.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_y_axis_id', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_LineStyle", variable_name: str, y_axis_id: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._y_axis_id = y_axis_id
        self._color = color
        self._line_style = line_style

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_FrequencyPlot.__name__ = "FrequencyPlot"
scout_chartdefinition_api_FrequencyPlot.__qualname__ = "FrequencyPlot"
scout_chartdefinition_api_FrequencyPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotMultivariate(ConjureBeanType):
    """A plot that performs an analysis on an multiple signals and returns
data mapped to the frequency domain.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'variable_names': ConjureFieldDefinition('variableNames', List[scout_channelvariables_api_ChannelVariableName]),
            'axes_ids': ConjureFieldDefinition('axesIds', List[scout_chartdefinition_api_AxisId]),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_title', '_variable_names', '_axes_ids', '_enabled', '_color', '_line_style']

    def __init__(self, axes_ids: List[str], color: str, line_style: "scout_chartdefinition_api_LineStyle", variable_names: List[str], enabled: Optional[bool] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._variable_names = variable_names
        self._axes_ids = axes_ids
        self._enabled = enabled
        self._color = color
        self._line_style = line_style

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def variable_names(self) -> List[str]:
        return self._variable_names

    @builtins.property
    def axes_ids(self) -> List[str]:
        return self._axes_ids

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_FrequencyPlotMultivariate.__name__ = "FrequencyPlotMultivariate"
scout_chartdefinition_api_FrequencyPlotMultivariate.__qualname__ = "FrequencyPlotMultivariate"
scout_chartdefinition_api_FrequencyPlotMultivariate.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotType(ConjureUnionType):
    _fft: Optional["scout_chartdefinition_api_FrequencyPlotTypeFft"] = None
    _periodogram: Optional["scout_chartdefinition_api_FrequencyPlotTypePeriodogram"] = None
    _psd: Optional["scout_chartdefinition_api_FrequencyPlotTypePsd"] = None
    _cpsd: Optional["scout_chartdefinition_api_FrequencyPlotTypeCpsd"] = None
    _nyquist: Optional["scout_chartdefinition_api_FrequencyPlotTypeNyquist"] = None
    _bode: Optional["scout_chartdefinition_api_FrequencyPlotTypeBode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_chartdefinition_api_FrequencyPlotTypeFft),
            'periodogram': ConjureFieldDefinition('periodogram', scout_chartdefinition_api_FrequencyPlotTypePeriodogram),
            'psd': ConjureFieldDefinition('psd', scout_chartdefinition_api_FrequencyPlotTypePsd),
            'cpsd': ConjureFieldDefinition('cpsd', scout_chartdefinition_api_FrequencyPlotTypeCpsd),
            'nyquist': ConjureFieldDefinition('nyquist', scout_chartdefinition_api_FrequencyPlotTypeNyquist),
            'bode': ConjureFieldDefinition('bode', scout_chartdefinition_api_FrequencyPlotTypeBode)
        }

    def __init__(
            self,
            fft: Optional["scout_chartdefinition_api_FrequencyPlotTypeFft"] = None,
            periodogram: Optional["scout_chartdefinition_api_FrequencyPlotTypePeriodogram"] = None,
            psd: Optional["scout_chartdefinition_api_FrequencyPlotTypePsd"] = None,
            cpsd: Optional["scout_chartdefinition_api_FrequencyPlotTypeCpsd"] = None,
            nyquist: Optional["scout_chartdefinition_api_FrequencyPlotTypeNyquist"] = None,
            bode: Optional["scout_chartdefinition_api_FrequencyPlotTypeBode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) + (periodogram is not None) + (psd is not None) + (cpsd is not None) + (nyquist is not None) + (bode is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'
            if periodogram is not None:
                self._periodogram = periodogram
                self._type = 'periodogram'
            if psd is not None:
                self._psd = psd
                self._type = 'psd'
            if cpsd is not None:
                self._cpsd = cpsd
                self._type = 'cpsd'
            if nyquist is not None:
                self._nyquist = nyquist
                self._type = 'nyquist'
            if bode is not None:
                self._bode = bode
                self._type = 'bode'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'
        elif type_of_union == 'periodogram':
            if periodogram is None:
                raise ValueError('a union value must not be None')
            self._periodogram = periodogram
            self._type = 'periodogram'
        elif type_of_union == 'psd':
            if psd is None:
                raise ValueError('a union value must not be None')
            self._psd = psd
            self._type = 'psd'
        elif type_of_union == 'cpsd':
            if cpsd is None:
                raise ValueError('a union value must not be None')
            self._cpsd = cpsd
            self._type = 'cpsd'
        elif type_of_union == 'nyquist':
            if nyquist is None:
                raise ValueError('a union value must not be None')
            self._nyquist = nyquist
            self._type = 'nyquist'
        elif type_of_union == 'bode':
            if bode is None:
                raise ValueError('a union value must not be None')
            self._bode = bode
            self._type = 'bode'

    @builtins.property
    def fft(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypeFft"]:
        return self._fft

    @builtins.property
    def periodogram(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypePeriodogram"]:
        return self._periodogram

    @builtins.property
    def psd(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypePsd"]:
        return self._psd

    @builtins.property
    def cpsd(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypeCpsd"]:
        return self._cpsd

    @builtins.property
    def nyquist(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypeNyquist"]:
        return self._nyquist

    @builtins.property
    def bode(self) -> Optional["scout_chartdefinition_api_FrequencyPlotTypeBode"]:
        return self._bode

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_FrequencyPlotTypeVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_FrequencyPlotTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)
        if self._type == 'periodogram' and self.periodogram is not None:
            return visitor._periodogram(self.periodogram)
        if self._type == 'psd' and self.psd is not None:
            return visitor._psd(self.psd)
        if self._type == 'cpsd' and self.cpsd is not None:
            return visitor._cpsd(self.cpsd)
        if self._type == 'nyquist' and self.nyquist is not None:
            return visitor._nyquist(self.nyquist)
        if self._type == 'bode' and self.bode is not None:
            return visitor._bode(self.bode)


scout_chartdefinition_api_FrequencyPlotType.__name__ = "FrequencyPlotType"
scout_chartdefinition_api_FrequencyPlotType.__qualname__ = "FrequencyPlotType"
scout_chartdefinition_api_FrequencyPlotType.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_chartdefinition_api_FrequencyPlotTypeFft") -> Any:
        pass

    @abstractmethod
    def _periodogram(self, periodogram: "scout_chartdefinition_api_FrequencyPlotTypePeriodogram") -> Any:
        pass

    @abstractmethod
    def _psd(self, psd: "scout_chartdefinition_api_FrequencyPlotTypePsd") -> Any:
        pass

    @abstractmethod
    def _cpsd(self, cpsd: "scout_chartdefinition_api_FrequencyPlotTypeCpsd") -> Any:
        pass

    @abstractmethod
    def _nyquist(self, nyquist: "scout_chartdefinition_api_FrequencyPlotTypeNyquist") -> Any:
        pass

    @abstractmethod
    def _bode(self, bode: "scout_chartdefinition_api_FrequencyPlotTypeBode") -> Any:
        pass


scout_chartdefinition_api_FrequencyPlotTypeVisitor.__name__ = "FrequencyPlotTypeVisitor"
scout_chartdefinition_api_FrequencyPlotTypeVisitor.__qualname__ = "FrequencyPlotTypeVisitor"
scout_chartdefinition_api_FrequencyPlotTypeVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypeBode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool]),
            'display_mode': ConjureFieldDefinition('displayMode', OptionalTypeWrapper[scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode])
        }

    __slots__: List[str] = ['_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase', '_display_mode']

    def __init__(self, display_mode: Optional["scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode"] = None, magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase
        self._display_mode = display_mode

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        return self._unwrap_phase

    @builtins.property
    def display_mode(self) -> Optional["scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode"]:
        """Whether to the magnitude or phase of the output. Defaults to MAGNITUDE if not specified.
        """
        return self._display_mode


scout_chartdefinition_api_FrequencyPlotTypeBode.__name__ = "FrequencyPlotTypeBode"
scout_chartdefinition_api_FrequencyPlotTypeBode.__qualname__ = "FrequencyPlotTypeBode"
scout_chartdefinition_api_FrequencyPlotTypeBode.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypeCpsd(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool]),
            'output_phase_unit': ConjureFieldDefinition('outputPhaseUnit', OptionalTypeWrapper[scout_compute_api_OutputPhaseUnit]),
            'display_mode': ConjureFieldDefinition('displayMode', OptionalTypeWrapper[scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode])
        }

    __slots__: List[str] = ['_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase', '_output_phase_unit', '_display_mode']

    def __init__(self, display_mode: Optional["scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode"] = None, magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, output_phase_unit: Optional["scout_compute_api_OutputPhaseUnit"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase
        self._output_phase_unit = output_phase_unit
        self._display_mode = display_mode

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        return self._unwrap_phase

    @builtins.property
    def output_phase_unit(self) -> Optional["scout_compute_api_OutputPhaseUnit"]:
        return self._output_phase_unit

    @builtins.property
    def display_mode(self) -> Optional["scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode"]:
        """Whether to the magnitude or phase of the output. Defaults to MAGNITUDE if not specified.
        """
        return self._display_mode


scout_chartdefinition_api_FrequencyPlotTypeCpsd.__name__ = "FrequencyPlotTypeCpsd"
scout_chartdefinition_api_FrequencyPlotTypeCpsd.__qualname__ = "FrequencyPlotTypeCpsd"
scout_chartdefinition_api_FrequencyPlotTypeCpsd.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypeFft(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'window': ConjureFieldDefinition('window', OptionalTypeWrapper[scout_compute_api_FftWindow])
        }

    __slots__: List[str] = ['_window']

    def __init__(self, window: Optional["scout_compute_api_FftWindow"] = None) -> None:
        self._window = window

    @builtins.property
    def window(self) -> Optional["scout_compute_api_FftWindow"]:
        return self._window


scout_chartdefinition_api_FrequencyPlotTypeFft.__name__ = "FrequencyPlotTypeFft"
scout_chartdefinition_api_FrequencyPlotTypeFft.__qualname__ = "FrequencyPlotTypeFft"
scout_chartdefinition_api_FrequencyPlotTypeFft.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypeNyquist(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions])
        }

    __slots__: List[str] = ['_stft_options']

    def __init__(self, stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._stft_options = stft_options

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options


scout_chartdefinition_api_FrequencyPlotTypeNyquist.__name__ = "FrequencyPlotTypeNyquist"
scout_chartdefinition_api_FrequencyPlotTypeNyquist.__qualname__ = "FrequencyPlotTypeNyquist"
scout_chartdefinition_api_FrequencyPlotTypeNyquist.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypePeriodogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'method': ConjureFieldDefinition('method', scout_compute_api_PeriodogramMethod)
        }

    __slots__: List[str] = ['_method']

    def __init__(self, method: "scout_compute_api_PeriodogramMethod") -> None:
        self._method = method

    @builtins.property
    def method(self) -> "scout_compute_api_PeriodogramMethod":
        return self._method


scout_chartdefinition_api_FrequencyPlotTypePeriodogram.__name__ = "FrequencyPlotTypePeriodogram"
scout_chartdefinition_api_FrequencyPlotTypePeriodogram.__qualname__ = "FrequencyPlotTypePeriodogram"
scout_chartdefinition_api_FrequencyPlotTypePeriodogram.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotTypePsd(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType])
        }

    __slots__: List[str] = ['_stft_options', '_magnitude_scaling', '_output_frequency_type']

    def __init__(self, magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type


scout_chartdefinition_api_FrequencyPlotTypePsd.__name__ = "FrequencyPlotTypePsd"
scout_chartdefinition_api_FrequencyPlotTypePsd.__qualname__ = "FrequencyPlotTypePsd"
scout_chartdefinition_api_FrequencyPlotTypePsd.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotV2(ConjureUnionType):
    _single: Optional["scout_chartdefinition_api_FrequencyPlot"] = None
    _multivariate: Optional["scout_chartdefinition_api_FrequencyPlotMultivariate"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single': ConjureFieldDefinition('single', scout_chartdefinition_api_FrequencyPlot),
            'multivariate': ConjureFieldDefinition('multivariate', scout_chartdefinition_api_FrequencyPlotMultivariate)
        }

    def __init__(
            self,
            single: Optional["scout_chartdefinition_api_FrequencyPlot"] = None,
            multivariate: Optional["scout_chartdefinition_api_FrequencyPlotMultivariate"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single is not None) + (multivariate is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single is not None:
                self._single = single
                self._type = 'single'
            if multivariate is not None:
                self._multivariate = multivariate
                self._type = 'multivariate'

        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'
        elif type_of_union == 'multivariate':
            if multivariate is None:
                raise ValueError('a union value must not be None')
            self._multivariate = multivariate
            self._type = 'multivariate'

    @builtins.property
    def single(self) -> Optional["scout_chartdefinition_api_FrequencyPlot"]:
        return self._single

    @builtins.property
    def multivariate(self) -> Optional["scout_chartdefinition_api_FrequencyPlotMultivariate"]:
        return self._multivariate

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_FrequencyPlotV2Visitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_FrequencyPlotV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)
        if self._type == 'multivariate' and self.multivariate is not None:
            return visitor._multivariate(self.multivariate)


scout_chartdefinition_api_FrequencyPlotV2.__name__ = "FrequencyPlotV2"
scout_chartdefinition_api_FrequencyPlotV2.__qualname__ = "FrequencyPlotV2"
scout_chartdefinition_api_FrequencyPlotV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_FrequencyPlotV2Visitor:

    @abstractmethod
    def _single(self, single: "scout_chartdefinition_api_FrequencyPlot") -> Any:
        pass

    @abstractmethod
    def _multivariate(self, multivariate: "scout_chartdefinition_api_FrequencyPlotMultivariate") -> Any:
        pass


scout_chartdefinition_api_FrequencyPlotV2Visitor.__name__ = "FrequencyPlotV2Visitor"
scout_chartdefinition_api_FrequencyPlotV2Visitor.__qualname__ = "FrequencyPlotV2Visitor"
scout_chartdefinition_api_FrequencyPlotV2Visitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dCustomModel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachment_rid': ConjureFieldDefinition('attachmentRid', api_rids_AttachmentRid),
            'file_extension': ConjureFieldDefinition('fileExtension', str)
        }

    __slots__: List[str] = ['_attachment_rid', '_file_extension']

    def __init__(self, attachment_rid: str, file_extension: str) -> None:
        self._attachment_rid = attachment_rid
        self._file_extension = file_extension

    @builtins.property
    def attachment_rid(self) -> str:
        return self._attachment_rid

    @builtins.property
    def file_extension(self) -> str:
        return self._file_extension


scout_chartdefinition_api_Geo3dCustomModel.__name__ = "Geo3dCustomModel"
scout_chartdefinition_api_Geo3dCustomModel.__qualname__ = "Geo3dCustomModel"
scout_chartdefinition_api_Geo3dCustomModel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dDefaultModel(ConjureEnumType):

    FICTIONAL_FIGHTER = 'FICTIONAL_FIGHTER'
    '''FICTIONAL_FIGHTER'''
    SATELLITE = 'SATELLITE'
    '''SATELLITE'''
    QUADCOPTER = 'QUADCOPTER'
    '''QUADCOPTER'''
    FIXEDWING = 'FIXEDWING'
    '''FIXEDWING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_Geo3dDefaultModel.__name__ = "Geo3dDefaultModel"
scout_chartdefinition_api_Geo3dDefaultModel.__qualname__ = "Geo3dDefaultModel"
scout_chartdefinition_api_Geo3dDefaultModel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_Geo3dDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_Geo3dDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_Geo3dDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_Geo3dDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_Geo3dDefinition.__name__ = "Geo3dDefinition"
scout_chartdefinition_api_Geo3dDefinition.__qualname__ = "Geo3dDefinition"
scout_chartdefinition_api_Geo3dDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_Geo3dDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_Geo3dDefinitionVisitor.__name__ = "Geo3dDefinitionVisitor"
scout_chartdefinition_api_Geo3dDefinitionVisitor.__qualname__ = "Geo3dDefinitionVisitor"
scout_chartdefinition_api_Geo3dDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_GeoPlot3d]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_plots', '_title']

    def __init__(self, plots: List["scout_chartdefinition_api_GeoPlot3d"], title: Optional[str] = None) -> None:
        self._plots = plots
        self._title = title

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_GeoPlot3d"]:
        return self._plots

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title


scout_chartdefinition_api_Geo3dDefinitionV1.__name__ = "Geo3dDefinitionV1"
scout_chartdefinition_api_Geo3dDefinitionV1.__qualname__ = "Geo3dDefinitionV1"
scout_chartdefinition_api_Geo3dDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dModel(ConjureUnionType):
    _default: Optional["scout_chartdefinition_api_Geo3dDefaultModel"] = None
    _custom: Optional["scout_chartdefinition_api_Geo3dCustomModel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'default': ConjureFieldDefinition('default', scout_chartdefinition_api_Geo3dDefaultModel),
            'custom': ConjureFieldDefinition('custom', scout_chartdefinition_api_Geo3dCustomModel)
        }

    def __init__(
            self,
            default: Optional["scout_chartdefinition_api_Geo3dDefaultModel"] = None,
            custom: Optional["scout_chartdefinition_api_Geo3dCustomModel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (default is not None) + (custom is not None) != 1:
                raise ValueError('a union must contain a single member')

            if default is not None:
                self._default = default
                self._type = 'default'
            if custom is not None:
                self._custom = custom
                self._type = 'custom'

        elif type_of_union == 'default':
            if default is None:
                raise ValueError('a union value must not be None')
            self._default = default
            self._type = 'default'
        elif type_of_union == 'custom':
            if custom is None:
                raise ValueError('a union value must not be None')
            self._custom = custom
            self._type = 'custom'

    @builtins.property
    def default(self) -> Optional["scout_chartdefinition_api_Geo3dDefaultModel"]:
        return self._default

    @builtins.property
    def custom(self) -> Optional["scout_chartdefinition_api_Geo3dCustomModel"]:
        return self._custom

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dModelVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dModelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'default' and self.default is not None:
            return visitor._default(self.default)
        if self._type == 'custom' and self.custom is not None:
            return visitor._custom(self.custom)


scout_chartdefinition_api_Geo3dModel.__name__ = "Geo3dModel"
scout_chartdefinition_api_Geo3dModel.__qualname__ = "Geo3dModel"
scout_chartdefinition_api_Geo3dModel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dModelVisitor:

    @abstractmethod
    def _default(self, default: "scout_chartdefinition_api_Geo3dDefaultModel") -> Any:
        pass

    @abstractmethod
    def _custom(self, custom: "scout_chartdefinition_api_Geo3dCustomModel") -> Any:
        pass


scout_chartdefinition_api_Geo3dModelVisitor.__name__ = "Geo3dModelVisitor"
scout_chartdefinition_api_Geo3dModelVisitor.__qualname__ = "Geo3dModelVisitor"
scout_chartdefinition_api_Geo3dModelVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientation(ConjureUnionType):
    _principal_axes: Optional["scout_chartdefinition_api_Geo3dOrientationPrincipalAxes"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'principal_axes': ConjureFieldDefinition('principalAxes', scout_chartdefinition_api_Geo3dOrientationPrincipalAxes)
        }

    def __init__(
            self,
            principal_axes: Optional["scout_chartdefinition_api_Geo3dOrientationPrincipalAxes"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (principal_axes is not None) != 1:
                raise ValueError('a union must contain a single member')

            if principal_axes is not None:
                self._principal_axes = principal_axes
                self._type = 'principalAxes'

        elif type_of_union == 'principalAxes':
            if principal_axes is None:
                raise ValueError('a union value must not be None')
            self._principal_axes = principal_axes
            self._type = 'principalAxes'

    @builtins.property
    def principal_axes(self) -> Optional["scout_chartdefinition_api_Geo3dOrientationPrincipalAxes"]:
        return self._principal_axes

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dOrientationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dOrientationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'principalAxes' and self.principal_axes is not None:
            return visitor._principal_axes(self.principal_axes)


scout_chartdefinition_api_Geo3dOrientation.__name__ = "Geo3dOrientation"
scout_chartdefinition_api_Geo3dOrientation.__qualname__ = "Geo3dOrientation"
scout_chartdefinition_api_Geo3dOrientation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientationVisitor:

    @abstractmethod
    def _principal_axes(self, principal_axes: "scout_chartdefinition_api_Geo3dOrientationPrincipalAxes") -> Any:
        pass


scout_chartdefinition_api_Geo3dOrientationVisitor.__name__ = "Geo3dOrientationVisitor"
scout_chartdefinition_api_Geo3dOrientationVisitor.__qualname__ = "Geo3dOrientationVisitor"
scout_chartdefinition_api_Geo3dOrientationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientationPrincipalAxes(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'heading_variable_name': ConjureFieldDefinition('headingVariableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName]),
            'pitch_variable_name': ConjureFieldDefinition('pitchVariableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName]),
            'roll_variable_name': ConjureFieldDefinition('rollVariableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName])
        }

    __slots__: List[str] = ['_heading_variable_name', '_pitch_variable_name', '_roll_variable_name']

    def __init__(self, heading_variable_name: Optional[str] = None, pitch_variable_name: Optional[str] = None, roll_variable_name: Optional[str] = None) -> None:
        self._heading_variable_name = heading_variable_name
        self._pitch_variable_name = pitch_variable_name
        self._roll_variable_name = roll_variable_name

    @builtins.property
    def heading_variable_name(self) -> Optional[str]:
        return self._heading_variable_name

    @builtins.property
    def pitch_variable_name(self) -> Optional[str]:
        return self._pitch_variable_name

    @builtins.property
    def roll_variable_name(self) -> Optional[str]:
        return self._roll_variable_name


scout_chartdefinition_api_Geo3dOrientationPrincipalAxes.__name__ = "Geo3dOrientationPrincipalAxes"
scout_chartdefinition_api_Geo3dOrientationPrincipalAxes.__qualname__ = "Geo3dOrientationPrincipalAxes"
scout_chartdefinition_api_Geo3dOrientationPrincipalAxes.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientationStatic(ConjureUnionType):
    _principal_axes: Optional["scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'principal_axes': ConjureFieldDefinition('principalAxes', scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes)
        }

    def __init__(
            self,
            principal_axes: Optional["scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (principal_axes is not None) != 1:
                raise ValueError('a union must contain a single member')

            if principal_axes is not None:
                self._principal_axes = principal_axes
                self._type = 'principalAxes'

        elif type_of_union == 'principalAxes':
            if principal_axes is None:
                raise ValueError('a union value must not be None')
            self._principal_axes = principal_axes
            self._type = 'principalAxes'

    @builtins.property
    def principal_axes(self) -> Optional["scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes"]:
        return self._principal_axes

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dOrientationStaticVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dOrientationStaticVisitor'.format(visitor.__class__.__name__))
        if self._type == 'principalAxes' and self.principal_axes is not None:
            return visitor._principal_axes(self.principal_axes)


scout_chartdefinition_api_Geo3dOrientationStatic.__name__ = "Geo3dOrientationStatic"
scout_chartdefinition_api_Geo3dOrientationStatic.__qualname__ = "Geo3dOrientationStatic"
scout_chartdefinition_api_Geo3dOrientationStatic.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientationStaticVisitor:

    @abstractmethod
    def _principal_axes(self, principal_axes: "scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes") -> Any:
        pass


scout_chartdefinition_api_Geo3dOrientationStaticVisitor.__name__ = "Geo3dOrientationStaticVisitor"
scout_chartdefinition_api_Geo3dOrientationStaticVisitor.__qualname__ = "Geo3dOrientationStaticVisitor"
scout_chartdefinition_api_Geo3dOrientationStaticVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes(ConjureBeanType):
    """Orientation specified as heading/pitch/roll in WGS84.
Heading is clockwise with respect to north.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'heading': ConjureFieldDefinition('heading', float),
            'pitch': ConjureFieldDefinition('pitch', float),
            'roll': ConjureFieldDefinition('roll', float)
        }

    __slots__: List[str] = ['_heading', '_pitch', '_roll']

    def __init__(self, heading: float, pitch: float, roll: float) -> None:
        self._heading = heading
        self._pitch = pitch
        self._roll = roll

    @builtins.property
    def heading(self) -> float:
        """Clockwise angle with respect to north (a.k.a. yaw).
        """
        return self._heading

    @builtins.property
    def pitch(self) -> float:
        return self._pitch

    @builtins.property
    def roll(self) -> float:
        return self._roll


scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes.__name__ = "Geo3dOrientationStaticPrincipalAxes"
scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes.__qualname__ = "Geo3dOrientationStaticPrincipalAxes"
scout_chartdefinition_api_Geo3dOrientationStaticPrincipalAxes.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dPosition(ConjureUnionType):
    _wgs84: Optional["scout_chartdefinition_api_Geo3dPositionWgs84"] = None
    _ecef: Optional["scout_chartdefinition_api_Geo3dPositionEcef"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'wgs84': ConjureFieldDefinition('wgs84', scout_chartdefinition_api_Geo3dPositionWgs84),
            'ecef': ConjureFieldDefinition('ecef', scout_chartdefinition_api_Geo3dPositionEcef)
        }

    def __init__(
            self,
            wgs84: Optional["scout_chartdefinition_api_Geo3dPositionWgs84"] = None,
            ecef: Optional["scout_chartdefinition_api_Geo3dPositionEcef"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (wgs84 is not None) + (ecef is not None) != 1:
                raise ValueError('a union must contain a single member')

            if wgs84 is not None:
                self._wgs84 = wgs84
                self._type = 'wgs84'
            if ecef is not None:
                self._ecef = ecef
                self._type = 'ecef'

        elif type_of_union == 'wgs84':
            if wgs84 is None:
                raise ValueError('a union value must not be None')
            self._wgs84 = wgs84
            self._type = 'wgs84'
        elif type_of_union == 'ecef':
            if ecef is None:
                raise ValueError('a union value must not be None')
            self._ecef = ecef
            self._type = 'ecef'

    @builtins.property
    def wgs84(self) -> Optional["scout_chartdefinition_api_Geo3dPositionWgs84"]:
        return self._wgs84

    @builtins.property
    def ecef(self) -> Optional["scout_chartdefinition_api_Geo3dPositionEcef"]:
        return self._ecef

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dPositionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dPositionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'wgs84' and self.wgs84 is not None:
            return visitor._wgs84(self.wgs84)
        if self._type == 'ecef' and self.ecef is not None:
            return visitor._ecef(self.ecef)


scout_chartdefinition_api_Geo3dPosition.__name__ = "Geo3dPosition"
scout_chartdefinition_api_Geo3dPosition.__qualname__ = "Geo3dPosition"
scout_chartdefinition_api_Geo3dPosition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dPositionVisitor:

    @abstractmethod
    def _wgs84(self, wgs84: "scout_chartdefinition_api_Geo3dPositionWgs84") -> Any:
        pass

    @abstractmethod
    def _ecef(self, ecef: "scout_chartdefinition_api_Geo3dPositionEcef") -> Any:
        pass


scout_chartdefinition_api_Geo3dPositionVisitor.__name__ = "Geo3dPositionVisitor"
scout_chartdefinition_api_Geo3dPositionVisitor.__qualname__ = "Geo3dPositionVisitor"
scout_chartdefinition_api_Geo3dPositionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dPositionEcef(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ecef_x_variable_name': ConjureFieldDefinition('ecefXVariableName', scout_channelvariables_api_ChannelVariableName),
            'ecef_y_variable_name': ConjureFieldDefinition('ecefYVariableName', scout_channelvariables_api_ChannelVariableName),
            'ecef_z_variable_name': ConjureFieldDefinition('ecefZVariableName', scout_channelvariables_api_ChannelVariableName)
        }

    __slots__: List[str] = ['_ecef_x_variable_name', '_ecef_y_variable_name', '_ecef_z_variable_name']

    def __init__(self, ecef_x_variable_name: str, ecef_y_variable_name: str, ecef_z_variable_name: str) -> None:
        self._ecef_x_variable_name = ecef_x_variable_name
        self._ecef_y_variable_name = ecef_y_variable_name
        self._ecef_z_variable_name = ecef_z_variable_name

    @builtins.property
    def ecef_x_variable_name(self) -> str:
        return self._ecef_x_variable_name

    @builtins.property
    def ecef_y_variable_name(self) -> str:
        return self._ecef_y_variable_name

    @builtins.property
    def ecef_z_variable_name(self) -> str:
        return self._ecef_z_variable_name


scout_chartdefinition_api_Geo3dPositionEcef.__name__ = "Geo3dPositionEcef"
scout_chartdefinition_api_Geo3dPositionEcef.__qualname__ = "Geo3dPositionEcef"
scout_chartdefinition_api_Geo3dPositionEcef.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dPositionWgs84(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude_variable_name': ConjureFieldDefinition('latitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'longitude_variable_name': ConjureFieldDefinition('longitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'height_variable_name': ConjureFieldDefinition('heightVariableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName])
        }

    __slots__: List[str] = ['_latitude_variable_name', '_longitude_variable_name', '_height_variable_name']

    def __init__(self, latitude_variable_name: str, longitude_variable_name: str, height_variable_name: Optional[str] = None) -> None:
        self._latitude_variable_name = latitude_variable_name
        self._longitude_variable_name = longitude_variable_name
        self._height_variable_name = height_variable_name

    @builtins.property
    def latitude_variable_name(self) -> str:
        return self._latitude_variable_name

    @builtins.property
    def longitude_variable_name(self) -> str:
        return self._longitude_variable_name

    @builtins.property
    def height_variable_name(self) -> Optional[str]:
        return self._height_variable_name


scout_chartdefinition_api_Geo3dPositionWgs84.__name__ = "Geo3dPositionWgs84"
scout_chartdefinition_api_Geo3dPositionWgs84.__qualname__ = "Geo3dPositionWgs84"
scout_chartdefinition_api_Geo3dPositionWgs84.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dSensor(ConjureBeanType):
    """A 3D sensor configuration for rendering/animating sensors in a 3D scene.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sensor_id': ConjureFieldDefinition('sensorId', str),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'orientation': ConjureFieldDefinition('orientation', OptionalTypeWrapper[scout_chartdefinition_api_Geo3dSensorOrientationConfig]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_api_HexColor])
        }

    __slots__: List[str] = ['_sensor_id', '_enabled', '_name', '_orientation', '_color']

    def __init__(self, sensor_id: str, color: Optional[str] = None, enabled: Optional[bool] = None, name: Optional[str] = None, orientation: Optional["scout_chartdefinition_api_Geo3dSensorOrientationConfig"] = None) -> None:
        self._sensor_id = sensor_id
        self._enabled = enabled
        self._name = name
        self._orientation = orientation
        self._color = color

    @builtins.property
    def sensor_id(self) -> str:
        return self._sensor_id

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def name(self) -> Optional[str]:
        """The name of the sensor.
        """
        return self._name

    @builtins.property
    def orientation(self) -> Optional["scout_chartdefinition_api_Geo3dSensorOrientationConfig"]:
        """The orientation of the sensor.
        """
        return self._orientation

    @builtins.property
    def color(self) -> Optional[str]:
        """The color of the sensor.
        """
        return self._color


scout_chartdefinition_api_Geo3dSensor.__name__ = "Geo3dSensor"
scout_chartdefinition_api_Geo3dSensor.__qualname__ = "Geo3dSensor"
scout_chartdefinition_api_Geo3dSensor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dSensorOrientationConfig(ConjureUnionType):
    """Orientation configuration for a sensor.
    """
    _static: Optional["scout_chartdefinition_api_Geo3dOrientationStatic"] = None
    _channel: Optional["scout_chartdefinition_api_Geo3dOrientation"] = None
    _nadir: Optional["scout_chartdefinition_api_Geo3dSensorOrientationNadir"] = None
    _zenith: Optional["scout_chartdefinition_api_Geo3dSensorOrientationZenith"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'static': ConjureFieldDefinition('static', scout_chartdefinition_api_Geo3dOrientationStatic),
            'channel': ConjureFieldDefinition('channel', scout_chartdefinition_api_Geo3dOrientation),
            'nadir': ConjureFieldDefinition('nadir', scout_chartdefinition_api_Geo3dSensorOrientationNadir),
            'zenith': ConjureFieldDefinition('zenith', scout_chartdefinition_api_Geo3dSensorOrientationZenith)
        }

    def __init__(
            self,
            static: Optional["scout_chartdefinition_api_Geo3dOrientationStatic"] = None,
            channel: Optional["scout_chartdefinition_api_Geo3dOrientation"] = None,
            nadir: Optional["scout_chartdefinition_api_Geo3dSensorOrientationNadir"] = None,
            zenith: Optional["scout_chartdefinition_api_Geo3dSensorOrientationZenith"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (static is not None) + (channel is not None) + (nadir is not None) + (zenith is not None) != 1:
                raise ValueError('a union must contain a single member')

            if static is not None:
                self._static = static
                self._type = 'static'
            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if nadir is not None:
                self._nadir = nadir
                self._type = 'nadir'
            if zenith is not None:
                self._zenith = zenith
                self._type = 'zenith'

        elif type_of_union == 'static':
            if static is None:
                raise ValueError('a union value must not be None')
            self._static = static
            self._type = 'static'
        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'nadir':
            if nadir is None:
                raise ValueError('a union value must not be None')
            self._nadir = nadir
            self._type = 'nadir'
        elif type_of_union == 'zenith':
            if zenith is None:
                raise ValueError('a union value must not be None')
            self._zenith = zenith
            self._type = 'zenith'

    @builtins.property
    def static(self) -> Optional["scout_chartdefinition_api_Geo3dOrientationStatic"]:
        return self._static

    @builtins.property
    def channel(self) -> Optional["scout_chartdefinition_api_Geo3dOrientation"]:
        return self._channel

    @builtins.property
    def nadir(self) -> Optional["scout_chartdefinition_api_Geo3dSensorOrientationNadir"]:
        return self._nadir

    @builtins.property
    def zenith(self) -> Optional["scout_chartdefinition_api_Geo3dSensorOrientationZenith"]:
        return self._zenith

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'static' and self.static is not None:
            return visitor._static(self.static)
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'nadir' and self.nadir is not None:
            return visitor._nadir(self.nadir)
        if self._type == 'zenith' and self.zenith is not None:
            return visitor._zenith(self.zenith)


scout_chartdefinition_api_Geo3dSensorOrientationConfig.__name__ = "Geo3dSensorOrientationConfig"
scout_chartdefinition_api_Geo3dSensorOrientationConfig.__qualname__ = "Geo3dSensorOrientationConfig"
scout_chartdefinition_api_Geo3dSensorOrientationConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor:

    @abstractmethod
    def _static(self, static: "scout_chartdefinition_api_Geo3dOrientationStatic") -> Any:
        pass

    @abstractmethod
    def _channel(self, channel: "scout_chartdefinition_api_Geo3dOrientation") -> Any:
        pass

    @abstractmethod
    def _nadir(self, nadir: "scout_chartdefinition_api_Geo3dSensorOrientationNadir") -> Any:
        pass

    @abstractmethod
    def _zenith(self, zenith: "scout_chartdefinition_api_Geo3dSensorOrientationZenith") -> Any:
        pass


scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor.__name__ = "Geo3dSensorOrientationConfigVisitor"
scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor.__qualname__ = "Geo3dSensorOrientationConfigVisitor"
scout_chartdefinition_api_Geo3dSensorOrientationConfigVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dSensorOrientationNadir(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_Geo3dSensorOrientationNadir.__name__ = "Geo3dSensorOrientationNadir"
scout_chartdefinition_api_Geo3dSensorOrientationNadir.__qualname__ = "Geo3dSensorOrientationNadir"
scout_chartdefinition_api_Geo3dSensorOrientationNadir.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Geo3dSensorOrientationZenith(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_Geo3dSensorOrientationZenith.__name__ = "Geo3dSensorOrientationZenith"
scout_chartdefinition_api_Geo3dSensorOrientationZenith.__qualname__ = "Geo3dSensorOrientationZenith"
scout_chartdefinition_api_Geo3dSensorOrientationZenith.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoAdditionalTileset(ConjureEnumType):
    """A standard tileset to overlay on the base map.
    """

    VFR = 'VFR'
    '''VFR'''
    BATHYMETRY = 'BATHYMETRY'
    '''BATHYMETRY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_GeoAdditionalTileset.__name__ = "GeoAdditionalTileset"
scout_chartdefinition_api_GeoAdditionalTileset.__qualname__ = "GeoAdditionalTileset"
scout_chartdefinition_api_GeoAdditionalTileset.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoAdditionalVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'visualization_option': ConjureFieldDefinition('visualizationOption', OptionalTypeWrapper[scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption])
        }

    __slots__: List[str] = ['_variable_name', '_label', '_visualization_option']

    def __init__(self, variable_name: str, label: Optional[str] = None, visualization_option: Optional["scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption"] = None) -> None:
        self._variable_name = variable_name
        self._label = label
        self._visualization_option = visualization_option

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def visualization_option(self) -> Optional["scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption"]:
        return self._visualization_option


scout_chartdefinition_api_GeoAdditionalVariable.__name__ = "GeoAdditionalVariable"
scout_chartdefinition_api_GeoAdditionalVariable.__qualname__ = "GeoAdditionalVariable"
scout_chartdefinition_api_GeoAdditionalVariable.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoBaseTileset(ConjureEnumType):
    """The base map style. Default STREET if unspecified.
    """

    STREET = 'STREET'
    '''STREET'''
    SATELLITE = 'SATELLITE'
    '''SATELLITE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_GeoBaseTileset.__name__ = "GeoBaseTileset"
scout_chartdefinition_api_GeoBaseTileset.__qualname__ = "GeoBaseTileset"
scout_chartdefinition_api_GeoBaseTileset.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoCustomFeature(ConjureUnionType):
    """Additional static objects on the map, such as a point representing a tower
    """
    _point: Optional["scout_chartdefinition_api_GeoPoint"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'point': ConjureFieldDefinition('point', scout_chartdefinition_api_GeoPoint)
        }

    def __init__(
            self,
            point: Optional["scout_chartdefinition_api_GeoPoint"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (point is not None) != 1:
                raise ValueError('a union must contain a single member')

            if point is not None:
                self._point = point
                self._type = 'point'

        elif type_of_union == 'point':
            if point is None:
                raise ValueError('a union value must not be None')
            self._point = point
            self._type = 'point'

    @builtins.property
    def point(self) -> Optional["scout_chartdefinition_api_GeoPoint"]:
        return self._point

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_GeoCustomFeatureVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_GeoCustomFeatureVisitor'.format(visitor.__class__.__name__))
        if self._type == 'point' and self.point is not None:
            return visitor._point(self.point)


scout_chartdefinition_api_GeoCustomFeature.__name__ = "GeoCustomFeature"
scout_chartdefinition_api_GeoCustomFeature.__qualname__ = "GeoCustomFeature"
scout_chartdefinition_api_GeoCustomFeature.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoCustomFeatureVisitor:

    @abstractmethod
    def _point(self, point: "scout_chartdefinition_api_GeoPoint") -> Any:
        pass


scout_chartdefinition_api_GeoCustomFeatureVisitor.__name__ = "GeoCustomFeatureVisitor"
scout_chartdefinition_api_GeoCustomFeatureVisitor.__qualname__ = "GeoCustomFeatureVisitor"
scout_chartdefinition_api_GeoCustomFeatureVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoLine3dStyle(ConjureEnumType):

    SOLID = 'SOLID'
    '''SOLID'''
    DASH = 'DASH'
    '''DASH'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_GeoLine3dStyle.__name__ = "GeoLine3dStyle"
scout_chartdefinition_api_GeoLine3dStyle.__qualname__ = "GeoLine3dStyle"
scout_chartdefinition_api_GeoLine3dStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoLineStyle(ConjureEnumType):

    POINTS = 'POINTS'
    '''POINTS'''
    SOLID = 'SOLID'
    '''SOLID'''
    DASH = 'DASH'
    '''DASH'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_GeoLineStyle.__name__ = "GeoLineStyle"
scout_chartdefinition_api_GeoLineStyle.__qualname__ = "GeoLineStyle"
scout_chartdefinition_api_GeoLineStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlot3d(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plot_id': ConjureFieldDefinition('plotId', str),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_chartdefinition_api_GeoPlot3dVisualizationOptions),
            'position': ConjureFieldDefinition('position', scout_chartdefinition_api_Geo3dPosition),
            'orientation': ConjureFieldDefinition('orientation', scout_chartdefinition_api_Geo3dOrientation),
            'sensors': ConjureFieldDefinition('sensors', OptionalTypeWrapper[List[scout_chartdefinition_api_Geo3dSensor]])
        }

    __slots__: List[str] = ['_plot_id', '_enabled', '_label', '_visualization_options', '_position', '_orientation', '_sensors']

    def __init__(self, orientation: "scout_chartdefinition_api_Geo3dOrientation", plot_id: str, position: "scout_chartdefinition_api_Geo3dPosition", visualization_options: "scout_chartdefinition_api_GeoPlot3dVisualizationOptions", enabled: Optional[bool] = None, label: Optional[str] = None, sensors: Optional[List["scout_chartdefinition_api_Geo3dSensor"]] = None) -> None:
        self._plot_id = plot_id
        self._enabled = enabled
        self._label = label
        self._visualization_options = visualization_options
        self._position = position
        self._orientation = orientation
        self._sensors = sensors

    @builtins.property
    def plot_id(self) -> str:
        return self._plot_id

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def visualization_options(self) -> "scout_chartdefinition_api_GeoPlot3dVisualizationOptions":
        return self._visualization_options

    @builtins.property
    def position(self) -> "scout_chartdefinition_api_Geo3dPosition":
        return self._position

    @builtins.property
    def orientation(self) -> "scout_chartdefinition_api_Geo3dOrientation":
        return self._orientation

    @builtins.property
    def sensors(self) -> Optional[List["scout_chartdefinition_api_Geo3dSensor"]]:
        return self._sensors


scout_chartdefinition_api_GeoPlot3d.__name__ = "GeoPlot3d"
scout_chartdefinition_api_GeoPlot3d.__qualname__ = "GeoPlot3d"
scout_chartdefinition_api_GeoPlot3d.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlot3dVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_GeoLine3dStyle),
            'model': ConjureFieldDefinition('model', OptionalTypeWrapper[scout_chartdefinition_api_Geo3dModel])
        }

    __slots__: List[str] = ['_color', '_line_style', '_model']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_GeoLine3dStyle", model: Optional["scout_chartdefinition_api_Geo3dModel"] = None) -> None:
        self._color = color
        self._line_style = line_style
        self._model = model

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_GeoLine3dStyle":
        return self._line_style

    @builtins.property
    def model(self) -> Optional["scout_chartdefinition_api_Geo3dModel"]:
        return self._model


scout_chartdefinition_api_GeoPlot3dVisualizationOptions.__name__ = "GeoPlot3dVisualizationOptions"
scout_chartdefinition_api_GeoPlot3dVisualizationOptions.__qualname__ = "GeoPlot3dVisualizationOptions"
scout_chartdefinition_api_GeoPlot3dVisualizationOptions.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotFromLatLong(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude_variable_name': ConjureFieldDefinition('latitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'longitude_variable_name': ConjureFieldDefinition('longitudeVariableName', scout_channelvariables_api_ChannelVariableName),
            'secondary_variables': ConjureFieldDefinition('secondaryVariables', OptionalTypeWrapper[List[scout_chartdefinition_api_GeoAdditionalVariable]]),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_chartdefinition_api_GeoPlotVisualizationOptions)
        }

    __slots__: List[str] = ['_latitude_variable_name', '_longitude_variable_name', '_secondary_variables', '_enabled', '_label', '_visualization_options']

    def __init__(self, latitude_variable_name: str, longitude_variable_name: str, visualization_options: "scout_chartdefinition_api_GeoPlotVisualizationOptions", enabled: Optional[bool] = None, label: Optional[str] = None, secondary_variables: Optional[List["scout_chartdefinition_api_GeoAdditionalVariable"]] = None) -> None:
        self._latitude_variable_name = latitude_variable_name
        self._longitude_variable_name = longitude_variable_name
        self._secondary_variables = secondary_variables
        self._enabled = enabled
        self._label = label
        self._visualization_options = visualization_options

    @builtins.property
    def latitude_variable_name(self) -> str:
        return self._latitude_variable_name

    @builtins.property
    def longitude_variable_name(self) -> str:
        return self._longitude_variable_name

    @builtins.property
    def secondary_variables(self) -> Optional[List["scout_chartdefinition_api_GeoAdditionalVariable"]]:
        """optional for backcompatibility
        """
        return self._secondary_variables

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def visualization_options(self) -> "scout_chartdefinition_api_GeoPlotVisualizationOptions":
        return self._visualization_options


scout_chartdefinition_api_GeoPlotFromLatLong.__name__ = "GeoPlotFromLatLong"
scout_chartdefinition_api_GeoPlotFromLatLong.__qualname__ = "GeoPlotFromLatLong"
scout_chartdefinition_api_GeoPlotFromLatLong.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visible': ConjureFieldDefinition('visible', bool),
            'variable_name': ConjureFieldDefinition('variableName', OptionalTypeWrapper[scout_channelvariables_api_ChannelVariableName])
        }

    __slots__: List[str] = ['_visible', '_variable_name']

    def __init__(self, visible: bool, variable_name: Optional[str] = None) -> None:
        self._visible = visible
        self._variable_name = variable_name

    @builtins.property
    def visible(self) -> bool:
        return self._visible

    @builtins.property
    def variable_name(self) -> Optional[str]:
        return self._variable_name


scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__name__ = "GeoPlotSecondaryVisibilityConfig"
scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__qualname__ = "GeoPlotSecondaryVisibilityConfig"
scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPlotVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_GeoLineStyle),
            'secondary_color_visualization': ConjureFieldDefinition('secondaryColorVisualization', OptionalTypeWrapper[scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig])
        }

    __slots__: List[str] = ['_color', '_line_style', '_secondary_color_visualization']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_GeoLineStyle", secondary_color_visualization: Optional["scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig"] = None) -> None:
        self._color = color
        self._line_style = line_style
        self._secondary_color_visualization = secondary_color_visualization

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_GeoLineStyle":
        return self._line_style

    @builtins.property
    def secondary_color_visualization(self) -> Optional["scout_chartdefinition_api_GeoPlotSecondaryVisibilityConfig"]:
        """If visible, overwrites any existing visualization options on the geo plot.
        """
        return self._secondary_color_visualization


scout_chartdefinition_api_GeoPlotVisualizationOptions.__name__ = "GeoPlotVisualizationOptions"
scout_chartdefinition_api_GeoPlotVisualizationOptions.__qualname__ = "GeoPlotVisualizationOptions"
scout_chartdefinition_api_GeoPlotVisualizationOptions.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoPoint(ConjureBeanType):
    """A static coordinate on the map
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'icon': ConjureFieldDefinition('icon', str),
            'latitude': ConjureFieldDefinition('latitude', float),
            'longitude': ConjureFieldDefinition('longitude', float),
            'variables': ConjureFieldDefinition('variables', List[scout_chartdefinition_api_GeoAdditionalVariable])
        }

    __slots__: List[str] = ['_label', '_icon', '_latitude', '_longitude', '_variables']

    def __init__(self, icon: str, latitude: float, longitude: float, variables: List["scout_chartdefinition_api_GeoAdditionalVariable"], label: Optional[str] = None) -> None:
        self._label = label
        self._icon = icon
        self._latitude = latitude
        self._longitude = longitude
        self._variables = variables

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def icon(self) -> str:
        return self._icon

    @builtins.property
    def latitude(self) -> float:
        return self._latitude

    @builtins.property
    def longitude(self) -> float:
        return self._longitude

    @builtins.property
    def variables(self) -> List["scout_chartdefinition_api_GeoAdditionalVariable"]:
        return self._variables


scout_chartdefinition_api_GeoPoint.__name__ = "GeoPoint"
scout_chartdefinition_api_GeoPoint.__qualname__ = "GeoPoint"
scout_chartdefinition_api_GeoPoint.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption(ConjureUnionType):
    """Specifies how values of a secondary channel should be visualized.
    """
    _as_colors: Optional["scout_chartdefinition_api_ValueToColorMap"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'as_colors': ConjureFieldDefinition('asColors', scout_chartdefinition_api_ValueToColorMap)
        }

    def __init__(
            self,
            as_colors: Optional["scout_chartdefinition_api_ValueToColorMap"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (as_colors is not None) != 1:
                raise ValueError('a union must contain a single member')

            if as_colors is not None:
                self._as_colors = as_colors
                self._type = 'asColors'

        elif type_of_union == 'asColors':
            if as_colors is None:
                raise ValueError('a union value must not be None')
            self._as_colors = as_colors
            self._type = 'asColors'

    @builtins.property
    def as_colors(self) -> Optional["scout_chartdefinition_api_ValueToColorMap"]:
        return self._as_colors

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'asColors' and self.as_colors is not None:
            return visitor._as_colors(self.as_colors)


scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__name__ = "GeoSecondaryPlotVisualizationOption"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__qualname__ = "GeoSecondaryPlotVisualizationOption"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOption.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor:

    @abstractmethod
    def _as_colors(self, as_colors: "scout_chartdefinition_api_ValueToColorMap") -> Any:
        pass


scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__name__ = "GeoSecondaryPlotVisualizationOptionVisitor"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__qualname__ = "GeoSecondaryPlotVisualizationOptionVisitor"
scout_chartdefinition_api_GeoSecondaryPlotVisualizationOptionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_GeoVizDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_GeoVizDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_GeoVizDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_GeoVizDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_GeoVizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_GeoVizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_GeoVizDefinition.__name__ = "GeoVizDefinition"
scout_chartdefinition_api_GeoVizDefinition.__qualname__ = "GeoVizDefinition"
scout_chartdefinition_api_GeoVizDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_GeoVizDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_GeoVizDefinitionVisitor.__name__ = "GeoVizDefinitionVisitor"
scout_chartdefinition_api_GeoVizDefinitionVisitor.__qualname__ = "GeoVizDefinitionVisitor"
scout_chartdefinition_api_GeoVizDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_GeoVizDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_GeoPlotFromLatLong]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'custom_features': ConjureFieldDefinition('customFeatures', List[scout_chartdefinition_api_GeoCustomFeature]),
            'base_tileset': ConjureFieldDefinition('baseTileset', OptionalTypeWrapper[scout_chartdefinition_api_GeoBaseTileset]),
            'additional_tileset': ConjureFieldDefinition('additionalTileset', OptionalTypeWrapper[scout_chartdefinition_api_GeoAdditionalTileset])
        }

    __slots__: List[str] = ['_plots', '_title', '_custom_features', '_base_tileset', '_additional_tileset']

    def __init__(self, custom_features: List["scout_chartdefinition_api_GeoCustomFeature"], plots: List["scout_chartdefinition_api_GeoPlotFromLatLong"], additional_tileset: Optional["scout_chartdefinition_api_GeoAdditionalTileset"] = None, base_tileset: Optional["scout_chartdefinition_api_GeoBaseTileset"] = None, title: Optional[str] = None) -> None:
        self._plots = plots
        self._title = title
        self._custom_features = custom_features
        self._base_tileset = base_tileset
        self._additional_tileset = additional_tileset

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_GeoPlotFromLatLong"]:
        return self._plots

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def custom_features(self) -> List["scout_chartdefinition_api_GeoCustomFeature"]:
        return self._custom_features

    @builtins.property
    def base_tileset(self) -> Optional["scout_chartdefinition_api_GeoBaseTileset"]:
        return self._base_tileset

    @builtins.property
    def additional_tileset(self) -> Optional["scout_chartdefinition_api_GeoAdditionalTileset"]:
        return self._additional_tileset


scout_chartdefinition_api_GeoVizDefinitionV1.__name__ = "GeoVizDefinitionV1"
scout_chartdefinition_api_GeoVizDefinitionV1.__qualname__ = "GeoVizDefinitionV1"
scout_chartdefinition_api_GeoVizDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_HistogramChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_HistogramChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_HistogramChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_HistogramChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_HistogramChartDefinition.__name__ = "HistogramChartDefinition"
scout_chartdefinition_api_HistogramChartDefinition.__qualname__ = "HistogramChartDefinition"
scout_chartdefinition_api_HistogramChartDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_HistogramChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_HistogramChartDefinitionVisitor.__name__ = "HistogramChartDefinitionVisitor"
scout_chartdefinition_api_HistogramChartDefinitionVisitor.__qualname__ = "HistogramChartDefinitionVisitor"
scout_chartdefinition_api_HistogramChartDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_HistogramPlot]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'display_settings': ConjureFieldDefinition('displaySettings', scout_chartdefinition_api_HistogramDisplaySettings),
            'numeric_bucket_strategy': ConjureFieldDefinition('numericBucketStrategy', OptionalTypeWrapper[scout_compute_api_NumericHistogramBucketStrategy]),
            'value_axis': ConjureFieldDefinition('valueAxis', OptionalTypeWrapper[scout_chartdefinition_api_ValueAxis])
        }

    __slots__: List[str] = ['_plots', '_title', '_display_settings', '_numeric_bucket_strategy', '_value_axis']

    def __init__(self, display_settings: "scout_chartdefinition_api_HistogramDisplaySettings", plots: List["scout_chartdefinition_api_HistogramPlot"], numeric_bucket_strategy: Optional["scout_compute_api_NumericHistogramBucketStrategy"] = None, title: Optional[str] = None, value_axis: Optional["scout_chartdefinition_api_ValueAxis"] = None) -> None:
        self._plots = plots
        self._title = title
        self._display_settings = display_settings
        self._numeric_bucket_strategy = numeric_bucket_strategy
        self._value_axis = value_axis

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_HistogramPlot"]:
        return self._plots

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def display_settings(self) -> "scout_chartdefinition_api_HistogramDisplaySettings":
        return self._display_settings

    @builtins.property
    def numeric_bucket_strategy(self) -> Optional["scout_compute_api_NumericHistogramBucketStrategy"]:
        return self._numeric_bucket_strategy

    @builtins.property
    def value_axis(self) -> Optional["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axis


scout_chartdefinition_api_HistogramChartDefinitionV1.__name__ = "HistogramChartDefinitionV1"
scout_chartdefinition_api_HistogramChartDefinitionV1.__qualname__ = "HistogramChartDefinitionV1"
scout_chartdefinition_api_HistogramChartDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramDisplaySettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stacked': ConjureFieldDefinition('stacked', bool),
            'sort': ConjureFieldDefinition('sort', scout_chartdefinition_api_HistogramSortOrder)
        }

    __slots__: List[str] = ['_stacked', '_sort']

    def __init__(self, sort: "scout_chartdefinition_api_HistogramSortOrder", stacked: bool) -> None:
        self._stacked = stacked
        self._sort = sort

    @builtins.property
    def stacked(self) -> bool:
        return self._stacked

    @builtins.property
    def sort(self) -> "scout_chartdefinition_api_HistogramSortOrder":
        return self._sort


scout_chartdefinition_api_HistogramDisplaySettings.__name__ = "HistogramDisplaySettings"
scout_chartdefinition_api_HistogramDisplaySettings.__qualname__ = "HistogramDisplaySettings"
scout_chartdefinition_api_HistogramDisplaySettings.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_color']

    def __init__(self, color: str, variable_name: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._color = color

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_HistogramPlot.__name__ = "HistogramPlot"
scout_chartdefinition_api_HistogramPlot.__qualname__ = "HistogramPlot"
scout_chartdefinition_api_HistogramPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_HistogramSortOrder(ConjureEnumType):
    """The order in which the histogram should be sorted.
Default is VALUE_ASCENDING.
    """

    VALUE_ASCENDING = 'VALUE_ASCENDING'
    '''VALUE_ASCENDING'''
    VALUE_DESCENDING = 'VALUE_DESCENDING'
    '''VALUE_DESCENDING'''
    FREQUENCY_ASCENDING = 'FREQUENCY_ASCENDING'
    '''FREQUENCY_ASCENDING'''
    FREQUENCY_DESCENDING = 'FREQUENCY_DESCENDING'
    '''FREQUENCY_DESCENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_HistogramSortOrder.__name__ = "HistogramSortOrder"
scout_chartdefinition_api_HistogramSortOrder.__qualname__ = "HistogramSortOrder"
scout_chartdefinition_api_HistogramSortOrder.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Layout(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plotly_layout': ConjureFieldDefinition('plotlyLayout', str)
        }

    __slots__: List[str] = ['_plotly_layout']

    def __init__(self, plotly_layout: str) -> None:
        self._plotly_layout = plotly_layout

    @builtins.property
    def plotly_layout(self) -> str:
        """The json layout definition according to plotly's schema
https://plotly.com/python/figure-structure/#the-toplevel-layout-attribute
        """
        return self._plotly_layout


scout_chartdefinition_api_Layout.__name__ = "Layout"
scout_chartdefinition_api_Layout.__qualname__ = "Layout"
scout_chartdefinition_api_Layout.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyle(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_LineStyleV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_LineStyleV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_LineStyleV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_LineStyleV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_LineStyleVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_LineStyleVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_LineStyle.__name__ = "LineStyle"
scout_chartdefinition_api_LineStyle.__qualname__ = "LineStyle"
scout_chartdefinition_api_LineStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyleVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_LineStyleV1") -> Any:
        pass


scout_chartdefinition_api_LineStyleVisitor.__name__ = "LineStyleVisitor"
scout_chartdefinition_api_LineStyleVisitor.__qualname__ = "LineStyleVisitor"
scout_chartdefinition_api_LineStyleVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineStyleV1(ConjureEnumType):

    SOLID = 'SOLID'
    '''SOLID'''
    DASH = 'DASH'
    '''DASH'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_LineStyleV1.__name__ = "LineStyleV1"
scout_chartdefinition_api_LineStyleV1.__qualname__ = "LineStyleV1"
scout_chartdefinition_api_LineStyleV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineThreshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_ThresholdLineStyle)
        }

    __slots__: List[str] = ['_value', '_label', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_ThresholdLineStyle", value: float, label: Optional[str] = None) -> None:
        self._value = value
        self._label = label
        self._color = color
        self._line_style = line_style

    @builtins.property
    def value(self) -> float:
        return self._value

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_ThresholdLineStyle":
        return self._line_style


scout_chartdefinition_api_LineThreshold.__name__ = "LineThreshold"
scout_chartdefinition_api_LineThreshold.__qualname__ = "LineThreshold"
scout_chartdefinition_api_LineThreshold.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LineThresholdGroup(ConjureBeanType):
    """Line thresholds are used to mark values or demarcate regions along a single axis.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'shading_config': ConjureFieldDefinition('shadingConfig', scout_chartdefinition_api_ThresholdShadingConfig),
            'lines': ConjureFieldDefinition('lines', List[scout_chartdefinition_api_LineThreshold]),
            'default_fill': ConjureFieldDefinition('defaultFill', OptionalTypeWrapper[scout_chartdefinition_api_DefaultFill])
        }

    __slots__: List[str] = ['_shading_config', '_lines', '_default_fill']

    def __init__(self, lines: List["scout_chartdefinition_api_LineThreshold"], shading_config: "scout_chartdefinition_api_ThresholdShadingConfig", default_fill: Optional["scout_chartdefinition_api_DefaultFill"] = None) -> None:
        self._shading_config = shading_config
        self._lines = lines
        self._default_fill = default_fill

    @builtins.property
    def shading_config(self) -> "scout_chartdefinition_api_ThresholdShadingConfig":
        return self._shading_config

    @builtins.property
    def lines(self) -> List["scout_chartdefinition_api_LineThreshold"]:
        return self._lines

    @builtins.property
    def default_fill(self) -> Optional["scout_chartdefinition_api_DefaultFill"]:
        """To supplement a set of line thresholds, the default fill configures how the remaining space (either
above or below) should be colored. Transparent if empty.
        """
        return self._default_fill


scout_chartdefinition_api_LineThresholdGroup.__name__ = "LineThresholdGroup"
scout_chartdefinition_api_LineThresholdGroup.__qualname__ = "LineThresholdGroup"
scout_chartdefinition_api_LineThresholdGroup.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LogChannel(ConjureBeanType):
    """A field to save additional column names on log panels with support for multiple variables
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'log_channel_variable_name': ConjureFieldDefinition('logChannelVariableName', scout_channelvariables_api_ChannelVariableName),
            'visible_log_column_names': ConjureFieldDefinition('visibleLogColumnNames', List[scout_chartdefinition_api_LogColumnName]),
            'tag_filters': ConjureFieldDefinition('tagFilters', scout_chartdefinition_api_LogTagFilter)
        }

    __slots__: List[str] = ['_log_channel_variable_name', '_visible_log_column_names', '_tag_filters']

    def __init__(self, log_channel_variable_name: str, tag_filters: Dict[str, List[str]], visible_log_column_names: List[str]) -> None:
        self._log_channel_variable_name = log_channel_variable_name
        self._visible_log_column_names = visible_log_column_names
        self._tag_filters = tag_filters

    @builtins.property
    def log_channel_variable_name(self) -> str:
        return self._log_channel_variable_name

    @builtins.property
    def visible_log_column_names(self) -> List[str]:
        return self._visible_log_column_names

    @builtins.property
    def tag_filters(self) -> Dict[str, List[str]]:
        return self._tag_filters


scout_chartdefinition_api_LogChannel.__name__ = "LogChannel"
scout_chartdefinition_api_LogChannel.__qualname__ = "LogChannel"
scout_chartdefinition_api_LogChannel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LogPanelDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_LogPanelDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_LogPanelDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_LogPanelDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_LogPanelDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_LogPanelDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_LogPanelDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_LogPanelDefinition.__name__ = "LogPanelDefinition"
scout_chartdefinition_api_LogPanelDefinition.__qualname__ = "LogPanelDefinition"
scout_chartdefinition_api_LogPanelDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LogPanelDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_LogPanelDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_LogPanelDefinitionVisitor.__name__ = "LogPanelDefinitionVisitor"
scout_chartdefinition_api_LogPanelDefinitionVisitor.__qualname__ = "LogPanelDefinitionVisitor"
scout_chartdefinition_api_LogPanelDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_LogPanelDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'log_channels': ConjureFieldDefinition('logChannels', List[scout_channelvariables_api_ChannelVariableName]),
            'log_channels_v2': ConjureFieldDefinition('logChannelsV2', OptionalTypeWrapper[List[scout_chartdefinition_api_LogChannel]])
        }

    __slots__: List[str] = ['_title', '_log_channels', '_log_channels_v2']

    def __init__(self, log_channels: List[str], log_channels_v2: Optional[List["scout_chartdefinition_api_LogChannel"]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._log_channels = log_channels
        self._log_channels_v2 = log_channels_v2

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def log_channels(self) -> List[str]:
        return self._log_channels

    @builtins.property
    def log_channels_v2(self) -> Optional[List["scout_chartdefinition_api_LogChannel"]]:
        return self._log_channels_v2


scout_chartdefinition_api_LogPanelDefinitionV1.__name__ = "LogPanelDefinitionV1"
scout_chartdefinition_api_LogPanelDefinitionV1.__qualname__ = "LogPanelDefinitionV1"
scout_chartdefinition_api_LogPanelDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode(ConjureEnumType):

    MAGNITUDE = 'MAGNITUDE'
    '''MAGNITUDE'''
    PHASE = 'PHASE'
    '''PHASE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode.__name__ = "MagnitudeAndPhaseDisplayMode"
scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode.__qualname__ = "MagnitudeAndPhaseDisplayMode"
scout_chartdefinition_api_MagnitudeAndPhaseDisplayMode.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_MaxDecimalPlaces(ConjureBeanType):
    """Format the number to a maximum number of decimal places, rounding numbers that have greater precision.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'places': ConjureFieldDefinition('places', int)
        }

    __slots__: List[str] = ['_places']

    def __init__(self, places: int) -> None:
        self._places = places

    @builtins.property
    def places(self) -> int:
        return self._places


scout_chartdefinition_api_MaxDecimalPlaces.__name__ = "MaxDecimalPlaces"
scout_chartdefinition_api_MaxDecimalPlaces.__qualname__ = "MaxDecimalPlaces"
scout_chartdefinition_api_MaxDecimalPlaces.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NeverConnectDisconnectedValues(ConjureBeanType):
    """This option indicates that disconnected values are never connected with a line.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_NeverConnectDisconnectedValues.__name__ = "NeverConnectDisconnectedValues"
scout_chartdefinition_api_NeverConnectDisconnectedValues.__qualname__ = "NeverConnectDisconnectedValues"
scout_chartdefinition_api_NeverConnectDisconnectedValues.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumberFormat(ConjureBeanType):
    """Number format for numeric cells, eg 1e4 | 10000 | 10,000.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sig_figs': ConjureFieldDefinition('sigFigs', OptionalTypeWrapper[int]),
            'display_option': ConjureFieldDefinition('displayOption', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormatDisplayOption]),
            'fixed_decimal_places': ConjureFieldDefinition('fixedDecimalPlaces', OptionalTypeWrapper[int]),
            'decimal_places': ConjureFieldDefinition('decimalPlaces', OptionalTypeWrapper[scout_chartdefinition_api_DecimalPlaces])
        }

    __slots__: List[str] = ['_sig_figs', '_display_option', '_fixed_decimal_places', '_decimal_places']

    def __init__(self, decimal_places: Optional["scout_chartdefinition_api_DecimalPlaces"] = None, display_option: Optional["scout_chartdefinition_api_NumberFormatDisplayOption"] = None, fixed_decimal_places: Optional[int] = None, sig_figs: Optional[int] = None) -> None:
        self._sig_figs = sig_figs
        self._display_option = display_option
        self._fixed_decimal_places = fixed_decimal_places
        self._decimal_places = decimal_places

    @builtins.property
    def sig_figs(self) -> Optional[int]:
        """Include the specified number of significant figures, rounding if needed.
        """
        return self._sig_figs

    @builtins.property
    def display_option(self) -> Optional["scout_chartdefinition_api_NumberFormatDisplayOption"]:
        """The base display format for the number.
        """
        return self._display_option

    @builtins.property
    def fixed_decimal_places(self) -> Optional[int]:
        return self._fixed_decimal_places

    @builtins.property
    def decimal_places(self) -> Optional["scout_chartdefinition_api_DecimalPlaces"]:
        """Options for formatting the decimal part of number.
        """
        return self._decimal_places


scout_chartdefinition_api_NumberFormat.__name__ = "NumberFormat"
scout_chartdefinition_api_NumberFormat.__qualname__ = "NumberFormat"
scout_chartdefinition_api_NumberFormat.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumberFormatDisplayOption(ConjureEnumType):

    SCIENTIFIC = 'SCIENTIFIC'
    '''SCIENTIFIC'''
    SUCCINCT = 'SUCCINCT'
    '''SUCCINCT'''
    LOCALE = 'LOCALE'
    '''LOCALE'''
    PLAIN = 'PLAIN'
    '''PLAIN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_NumberFormatDisplayOption.__name__ = "NumberFormatDisplayOption"
scout_chartdefinition_api_NumberFormatDisplayOption.__qualname__ = "NumberFormatDisplayOption"
scout_chartdefinition_api_NumberFormatDisplayOption.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericArrayCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_NumericArrayVisualisation]),
            'number_format': ConjureFieldDefinition('numberFormat', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormat])
        }

    __slots__: List[str] = ['_visualisation', '_number_format']

    def __init__(self, number_format: Optional["scout_chartdefinition_api_NumberFormat"] = None, visualisation: Optional["scout_chartdefinition_api_NumericArrayVisualisation"] = None) -> None:
        self._visualisation = visualisation
        self._number_format = number_format

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_NumericArrayVisualisation"]:
        return self._visualisation

    @builtins.property
    def number_format(self) -> Optional["scout_chartdefinition_api_NumberFormat"]:
        return self._number_format


scout_chartdefinition_api_NumericArrayCellConfig.__name__ = "NumericArrayCellConfig"
scout_chartdefinition_api_NumericArrayCellConfig.__qualname__ = "NumericArrayCellConfig"
scout_chartdefinition_api_NumericArrayCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericArrayRawVisualisation(ConjureBeanType):
    """A raw numeric array visualisation with optional coloring based on numeric thresholds.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_NumericArrayRawVisualisation.__name__ = "NumericArrayRawVisualisation"
scout_chartdefinition_api_NumericArrayRawVisualisation.__qualname__ = "NumericArrayRawVisualisation"
scout_chartdefinition_api_NumericArrayRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericArrayVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_NumericArrayRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_NumericArrayRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_NumericArrayRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_NumericArrayRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_NumericArrayVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_NumericArrayVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_NumericArrayVisualisation.__name__ = "NumericArrayVisualisation"
scout_chartdefinition_api_NumericArrayVisualisation.__qualname__ = "NumericArrayVisualisation"
scout_chartdefinition_api_NumericArrayVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericArrayVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_NumericArrayRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_NumericArrayVisualisationVisitor.__name__ = "NumericArrayVisualisationVisitor"
scout_chartdefinition_api_NumericArrayVisualisationVisitor.__qualname__ = "NumericArrayVisualisationVisitor"
scout_chartdefinition_api_NumericArrayVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericBarGaugeVisualisation(ConjureBeanType):
    """The settings for a bar gauge visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_threshold': ConjureFieldDefinition('lowThreshold', float),
            'high_threshold': ConjureFieldDefinition('highThreshold', float)
        }

    __slots__: List[str] = ['_low_threshold', '_high_threshold']

    def __init__(self, high_threshold: float, low_threshold: float) -> None:
        self._low_threshold = low_threshold
        self._high_threshold = high_threshold

    @builtins.property
    def low_threshold(self) -> float:
        return self._low_threshold

    @builtins.property
    def high_threshold(self) -> float:
        return self._high_threshold


scout_chartdefinition_api_NumericBarGaugeVisualisation.__name__ = "NumericBarGaugeVisualisation"
scout_chartdefinition_api_NumericBarGaugeVisualisation.__qualname__ = "NumericBarGaugeVisualisation"
scout_chartdefinition_api_NumericBarGaugeVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericBarVisualisationV2(ConjureBeanType):
    """A numeric visualisation that will fill the cell from left to right with a colored background
representing where the value falls inside a set range.
The lowest and highest values in the thresholds determine the start and end of the range.
Middle threshold values will still affect the cell's coloration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'thresholds': ConjureFieldDefinition('thresholds', OptionalTypeWrapper[List[scout_chartdefinition_api_Threshold]])
        }

    __slots__: List[str] = ['_thresholds']

    def __init__(self, thresholds: Optional[List["scout_chartdefinition_api_Threshold"]] = None) -> None:
        self._thresholds = thresholds

    @builtins.property
    def thresholds(self) -> Optional[List["scout_chartdefinition_api_Threshold"]]:
        """Modifies the visualisation based on the highest threshold value that
the computed value equals or surpasses. The lowest and highest value will determine
the 0% and 100% values of the bar.
        """
        return self._thresholds


scout_chartdefinition_api_NumericBarVisualisationV2.__name__ = "NumericBarVisualisationV2"
scout_chartdefinition_api_NumericBarVisualisationV2.__qualname__ = "NumericBarVisualisationV2"
scout_chartdefinition_api_NumericBarVisualisationV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_NumericValueVisualisationV2]),
            'number_format': ConjureFieldDefinition('numberFormat', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormat]),
            'group_by_sort': ConjureFieldDefinition('groupBySort', OptionalTypeWrapper[scout_chartdefinition_api_NumericGroupBySort])
        }

    __slots__: List[str] = ['_visualisation', '_number_format', '_group_by_sort']

    def __init__(self, group_by_sort: Optional["scout_chartdefinition_api_NumericGroupBySort"] = None, number_format: Optional["scout_chartdefinition_api_NumberFormat"] = None, visualisation: Optional["scout_chartdefinition_api_NumericValueVisualisationV2"] = None) -> None:
        self._visualisation = visualisation
        self._number_format = number_format
        self._group_by_sort = group_by_sort

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_NumericValueVisualisationV2"]:
        return self._visualisation

    @builtins.property
    def number_format(self) -> Optional["scout_chartdefinition_api_NumberFormat"]:
        return self._number_format

    @builtins.property
    def group_by_sort(self) -> Optional["scout_chartdefinition_api_NumericGroupBySort"]:
        """Sorting configuration for grouped data rendering in a cell.
If undefined, will sort alphabetically by grouping.
        """
        return self._group_by_sort


scout_chartdefinition_api_NumericCellConfig.__name__ = "NumericCellConfig"
scout_chartdefinition_api_NumericCellConfig.__qualname__ = "NumericCellConfig"
scout_chartdefinition_api_NumericCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericGroupBySort(ConjureUnionType):
    _value: Optional["scout_chartdefinition_api_ValueSort"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', scout_chartdefinition_api_ValueSort)
        }

    def __init__(
            self,
            value: Optional["scout_chartdefinition_api_ValueSort"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if value is not None:
                self._value = value
                self._type = 'value'

        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'

    @builtins.property
    def value(self) -> Optional["scout_chartdefinition_api_ValueSort"]:
        return self._value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_NumericGroupBySortVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_NumericGroupBySortVisitor'.format(visitor.__class__.__name__))
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)


scout_chartdefinition_api_NumericGroupBySort.__name__ = "NumericGroupBySort"
scout_chartdefinition_api_NumericGroupBySort.__qualname__ = "NumericGroupBySort"
scout_chartdefinition_api_NumericGroupBySort.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericGroupBySortVisitor:

    @abstractmethod
    def _value(self, value: "scout_chartdefinition_api_ValueSort") -> Any:
        pass


scout_chartdefinition_api_NumericGroupBySortVisitor.__name__ = "NumericGroupBySortVisitor"
scout_chartdefinition_api_NumericGroupBySortVisitor.__qualname__ = "NumericGroupBySortVisitor"
scout_chartdefinition_api_NumericGroupBySortVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericRawVisualisation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_NumericRawVisualisation.__name__ = "NumericRawVisualisation"
scout_chartdefinition_api_NumericRawVisualisation.__qualname__ = "NumericRawVisualisation"
scout_chartdefinition_api_NumericRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericRawVisualisationV2(ConjureBeanType):
    """A raw numeric visualisation with optional coloring based on numeric thresholds.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'thresholds': ConjureFieldDefinition('thresholds', OptionalTypeWrapper[List[scout_chartdefinition_api_Threshold]])
        }

    __slots__: List[str] = ['_thresholds']

    def __init__(self, thresholds: Optional[List["scout_chartdefinition_api_Threshold"]] = None) -> None:
        self._thresholds = thresholds

    @builtins.property
    def thresholds(self) -> Optional[List["scout_chartdefinition_api_Threshold"]]:
        """Modifies the visualisation based on the highest threshold value that
the computed value surpasses.
        """
        return self._thresholds


scout_chartdefinition_api_NumericRawVisualisationV2.__name__ = "NumericRawVisualisationV2"
scout_chartdefinition_api_NumericRawVisualisationV2.__qualname__ = "NumericRawVisualisationV2"
scout_chartdefinition_api_NumericRawVisualisationV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_NumericValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_NumericValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_NumericValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_NumericValueChannel.__name__ = "NumericValueChannel"
scout_chartdefinition_api_NumericValueChannel.__qualname__ = "NumericValueChannel"
scout_chartdefinition_api_NumericValueChannel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_NumericRawVisualisation"] = None
    _bar_gauge: Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_NumericRawVisualisation),
            'bar_gauge': ConjureFieldDefinition('barGauge', scout_chartdefinition_api_NumericBarGaugeVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_NumericRawVisualisation"] = None,
            bar_gauge: Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (bar_gauge is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if bar_gauge is not None:
                self._bar_gauge = bar_gauge
                self._type = 'barGauge'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'barGauge':
            if bar_gauge is None:
                raise ValueError('a union value must not be None')
            self._bar_gauge = bar_gauge
            self._type = 'barGauge'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_NumericRawVisualisation"]:
        return self._raw

    @builtins.property
    def bar_gauge(self) -> Optional["scout_chartdefinition_api_NumericBarGaugeVisualisation"]:
        return self._bar_gauge

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_NumericValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_NumericValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'barGauge' and self.bar_gauge is not None:
            return visitor._bar_gauge(self.bar_gauge)


scout_chartdefinition_api_NumericValueVisualisation.__name__ = "NumericValueVisualisation"
scout_chartdefinition_api_NumericValueVisualisation.__qualname__ = "NumericValueVisualisation"
scout_chartdefinition_api_NumericValueVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_NumericRawVisualisation") -> Any:
        pass

    @abstractmethod
    def _bar_gauge(self, bar_gauge: "scout_chartdefinition_api_NumericBarGaugeVisualisation") -> Any:
        pass


scout_chartdefinition_api_NumericValueVisualisationVisitor.__name__ = "NumericValueVisualisationVisitor"
scout_chartdefinition_api_NumericValueVisualisationVisitor.__qualname__ = "NumericValueVisualisationVisitor"
scout_chartdefinition_api_NumericValueVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisationV2(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_NumericRawVisualisationV2"] = None
    _bar: Optional["scout_chartdefinition_api_NumericBarVisualisationV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_NumericRawVisualisationV2),
            'bar': ConjureFieldDefinition('bar', scout_chartdefinition_api_NumericBarVisualisationV2)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_NumericRawVisualisationV2"] = None,
            bar: Optional["scout_chartdefinition_api_NumericBarVisualisationV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (bar is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if bar is not None:
                self._bar = bar
                self._type = 'bar'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'bar':
            if bar is None:
                raise ValueError('a union value must not be None')
            self._bar = bar
            self._type = 'bar'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_NumericRawVisualisationV2"]:
        return self._raw

    @builtins.property
    def bar(self) -> Optional["scout_chartdefinition_api_NumericBarVisualisationV2"]:
        return self._bar

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_NumericValueVisualisationV2Visitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_NumericValueVisualisationV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'bar' and self.bar is not None:
            return visitor._bar(self.bar)


scout_chartdefinition_api_NumericValueVisualisationV2.__name__ = "NumericValueVisualisationV2"
scout_chartdefinition_api_NumericValueVisualisationV2.__qualname__ = "NumericValueVisualisationV2"
scout_chartdefinition_api_NumericValueVisualisationV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_NumericValueVisualisationV2Visitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_NumericRawVisualisationV2") -> Any:
        pass

    @abstractmethod
    def _bar(self, bar: "scout_chartdefinition_api_NumericBarVisualisationV2") -> Any:
        pass


scout_chartdefinition_api_NumericValueVisualisationV2Visitor.__name__ = "NumericValueVisualisationV2Visitor"
scout_chartdefinition_api_NumericValueVisualisationV2Visitor.__qualname__ = "NumericValueVisualisationV2Visitor"
scout_chartdefinition_api_NumericValueVisualisationV2Visitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_OverlayScope(ConjureEnumType):

    ROW = 'ROW'
    '''ROW'''
    PANEL = 'PANEL'
    '''PANEL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_OverlayScope.__name__ = "OverlayScope"
scout_chartdefinition_api_OverlayScope.__qualname__ = "OverlayScope"
scout_chartdefinition_api_OverlayScope.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PanelBucketStrategy(ConjureUnionType):
    _auto: Optional["scout_chartdefinition_api_PanelBucketStrategyAuto"] = None
    _fixed: Optional["scout_chartdefinition_api_PanelBucketStrategyFixed"] = None
    _duration: Optional["scout_chartdefinition_api_PanelBucketStrategyDuration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'auto': ConjureFieldDefinition('auto', scout_chartdefinition_api_PanelBucketStrategyAuto),
            'fixed': ConjureFieldDefinition('fixed', scout_chartdefinition_api_PanelBucketStrategyFixed),
            'duration': ConjureFieldDefinition('duration', scout_chartdefinition_api_PanelBucketStrategyDuration)
        }

    def __init__(
            self,
            auto: Optional["scout_chartdefinition_api_PanelBucketStrategyAuto"] = None,
            fixed: Optional["scout_chartdefinition_api_PanelBucketStrategyFixed"] = None,
            duration: Optional["scout_chartdefinition_api_PanelBucketStrategyDuration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (auto is not None) + (fixed is not None) + (duration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if auto is not None:
                self._auto = auto
                self._type = 'auto'
            if fixed is not None:
                self._fixed = fixed
                self._type = 'fixed'
            if duration is not None:
                self._duration = duration
                self._type = 'duration'

        elif type_of_union == 'auto':
            if auto is None:
                raise ValueError('a union value must not be None')
            self._auto = auto
            self._type = 'auto'
        elif type_of_union == 'fixed':
            if fixed is None:
                raise ValueError('a union value must not be None')
            self._fixed = fixed
            self._type = 'fixed'
        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'

    @builtins.property
    def auto(self) -> Optional["scout_chartdefinition_api_PanelBucketStrategyAuto"]:
        return self._auto

    @builtins.property
    def fixed(self) -> Optional["scout_chartdefinition_api_PanelBucketStrategyFixed"]:
        return self._fixed

    @builtins.property
    def duration(self) -> Optional["scout_chartdefinition_api_PanelBucketStrategyDuration"]:
        return self._duration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_PanelBucketStrategyVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_PanelBucketStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'auto' and self.auto is not None:
            return visitor._auto(self.auto)
        if self._type == 'fixed' and self.fixed is not None:
            return visitor._fixed(self.fixed)
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)


scout_chartdefinition_api_PanelBucketStrategy.__name__ = "PanelBucketStrategy"
scout_chartdefinition_api_PanelBucketStrategy.__qualname__ = "PanelBucketStrategy"
scout_chartdefinition_api_PanelBucketStrategy.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PanelBucketStrategyVisitor:

    @abstractmethod
    def _auto(self, auto: "scout_chartdefinition_api_PanelBucketStrategyAuto") -> Any:
        pass

    @abstractmethod
    def _fixed(self, fixed: "scout_chartdefinition_api_PanelBucketStrategyFixed") -> Any:
        pass

    @abstractmethod
    def _duration(self, duration: "scout_chartdefinition_api_PanelBucketStrategyDuration") -> Any:
        pass


scout_chartdefinition_api_PanelBucketStrategyVisitor.__name__ = "PanelBucketStrategyVisitor"
scout_chartdefinition_api_PanelBucketStrategyVisitor.__qualname__ = "PanelBucketStrategyVisitor"
scout_chartdefinition_api_PanelBucketStrategyVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PanelBucketStrategyAuto(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_PanelBucketStrategyAuto.__name__ = "PanelBucketStrategyAuto"
scout_chartdefinition_api_PanelBucketStrategyAuto.__qualname__ = "PanelBucketStrategyAuto"
scout_chartdefinition_api_PanelBucketStrategyAuto.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PanelBucketStrategyDuration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_rids_api_UserDuration)
        }

    __slots__: List[str] = ['_duration']

    def __init__(self, duration: "scout_rids_api_UserDuration") -> None:
        self._duration = duration

    @builtins.property
    def duration(self) -> "scout_rids_api_UserDuration":
        return self._duration


scout_chartdefinition_api_PanelBucketStrategyDuration.__name__ = "PanelBucketStrategyDuration"
scout_chartdefinition_api_PanelBucketStrategyDuration.__qualname__ = "PanelBucketStrategyDuration"
scout_chartdefinition_api_PanelBucketStrategyDuration.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PanelBucketStrategyFixed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket_count': ConjureFieldDefinition('bucketCount', int)
        }

    __slots__: List[str] = ['_bucket_count']

    def __init__(self, bucket_count: int) -> None:
        self._bucket_count = bucket_count

    @builtins.property
    def bucket_count(self) -> int:
        return self._bucket_count


scout_chartdefinition_api_PanelBucketStrategyFixed.__name__ = "PanelBucketStrategyFixed"
scout_chartdefinition_api_PanelBucketStrategyFixed.__qualname__ = "PanelBucketStrategyFixed"
scout_chartdefinition_api_PanelBucketStrategyFixed.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PerRowFloatingLegends(ConjureBeanType):
    """Show a separate floating legend for the series in each row of the chart.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_PerRowFloatingLegends.__name__ = "PerRowFloatingLegends"
scout_chartdefinition_api_PerRowFloatingLegends.__qualname__ = "PerRowFloatingLegends"
scout_chartdefinition_api_PerRowFloatingLegends.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PersistAll(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_PersistAll.__name__ = "PersistAll"
scout_chartdefinition_api_PersistAll.__qualname__ = "PersistAll"
scout_chartdefinition_api_PersistAll.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PersistByValue(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'values': ConjureFieldDefinition('values', List[str])
        }

    __slots__: List[str] = ['_values']

    def __init__(self, values: List[str]) -> None:
        self._values = values

    @builtins.property
    def values(self) -> List[str]:
        return self._values


scout_chartdefinition_api_PersistByValue.__name__ = "PersistByValue"
scout_chartdefinition_api_PersistByValue.__qualname__ = "PersistByValue"
scout_chartdefinition_api_PersistByValue.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PersistValueOverlay(ConjureUnionType):
    _by_value: Optional["scout_chartdefinition_api_PersistByValue"] = None
    _all: Optional["scout_chartdefinition_api_PersistAll"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'by_value': ConjureFieldDefinition('byValue', scout_chartdefinition_api_PersistByValue),
            'all': ConjureFieldDefinition('all', scout_chartdefinition_api_PersistAll)
        }

    def __init__(
            self,
            by_value: Optional["scout_chartdefinition_api_PersistByValue"] = None,
            all: Optional["scout_chartdefinition_api_PersistAll"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (by_value is not None) + (all is not None) != 1:
                raise ValueError('a union must contain a single member')

            if by_value is not None:
                self._by_value = by_value
                self._type = 'byValue'
            if all is not None:
                self._all = all
                self._type = 'all'

        elif type_of_union == 'byValue':
            if by_value is None:
                raise ValueError('a union value must not be None')
            self._by_value = by_value
            self._type = 'byValue'
        elif type_of_union == 'all':
            if all is None:
                raise ValueError('a union value must not be None')
            self._all = all
            self._type = 'all'

    @builtins.property
    def by_value(self) -> Optional["scout_chartdefinition_api_PersistByValue"]:
        return self._by_value

    @builtins.property
    def all(self) -> Optional["scout_chartdefinition_api_PersistAll"]:
        return self._all

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_PersistValueOverlayVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_PersistValueOverlayVisitor'.format(visitor.__class__.__name__))
        if self._type == 'byValue' and self.by_value is not None:
            return visitor._by_value(self.by_value)
        if self._type == 'all' and self.all is not None:
            return visitor._all(self.all)


scout_chartdefinition_api_PersistValueOverlay.__name__ = "PersistValueOverlay"
scout_chartdefinition_api_PersistValueOverlay.__qualname__ = "PersistValueOverlay"
scout_chartdefinition_api_PersistValueOverlay.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PersistValueOverlayVisitor:

    @abstractmethod
    def _by_value(self, by_value: "scout_chartdefinition_api_PersistByValue") -> Any:
        pass

    @abstractmethod
    def _all(self, all: "scout_chartdefinition_api_PersistAll") -> Any:
        pass


scout_chartdefinition_api_PersistValueOverlayVisitor.__name__ = "PersistValueOverlayVisitor"
scout_chartdefinition_api_PersistValueOverlayVisitor.__qualname__ = "PersistValueOverlayVisitor"
scout_chartdefinition_api_PersistValueOverlayVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotColoringConfiguration(ConjureUnionType):
    _row_independent: Optional["scout_chartdefinition_api_RowIndependentPlotColoringConfiguration"] = None
    _row_shared: Optional["scout_chartdefinition_api_RowSharedPlotColoringConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'row_independent': ConjureFieldDefinition('rowIndependent', scout_chartdefinition_api_RowIndependentPlotColoringConfiguration),
            'row_shared': ConjureFieldDefinition('rowShared', scout_chartdefinition_api_RowSharedPlotColoringConfiguration)
        }

    def __init__(
            self,
            row_independent: Optional["scout_chartdefinition_api_RowIndependentPlotColoringConfiguration"] = None,
            row_shared: Optional["scout_chartdefinition_api_RowSharedPlotColoringConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (row_independent is not None) + (row_shared is not None) != 1:
                raise ValueError('a union must contain a single member')

            if row_independent is not None:
                self._row_independent = row_independent
                self._type = 'rowIndependent'
            if row_shared is not None:
                self._row_shared = row_shared
                self._type = 'rowShared'

        elif type_of_union == 'rowIndependent':
            if row_independent is None:
                raise ValueError('a union value must not be None')
            self._row_independent = row_independent
            self._type = 'rowIndependent'
        elif type_of_union == 'rowShared':
            if row_shared is None:
                raise ValueError('a union value must not be None')
            self._row_shared = row_shared
            self._type = 'rowShared'

    @builtins.property
    def row_independent(self) -> Optional["scout_chartdefinition_api_RowIndependentPlotColoringConfiguration"]:
        """Series plotted on each row is colored independently of series in other rows.
        """
        return self._row_independent

    @builtins.property
    def row_shared(self) -> Optional["scout_chartdefinition_api_RowSharedPlotColoringConfiguration"]:
        """Series plotted on each row will be colored using the same order of colors as the plots in the other rows
in the panel.
        """
        return self._row_shared

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_PlotColoringConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_PlotColoringConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'rowIndependent' and self.row_independent is not None:
            return visitor._row_independent(self.row_independent)
        if self._type == 'rowShared' and self.row_shared is not None:
            return visitor._row_shared(self.row_shared)


scout_chartdefinition_api_PlotColoringConfiguration.__name__ = "PlotColoringConfiguration"
scout_chartdefinition_api_PlotColoringConfiguration.__qualname__ = "PlotColoringConfiguration"
scout_chartdefinition_api_PlotColoringConfiguration.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotColoringConfigurationVisitor:

    @abstractmethod
    def _row_independent(self, row_independent: "scout_chartdefinition_api_RowIndependentPlotColoringConfiguration") -> Any:
        pass

    @abstractmethod
    def _row_shared(self, row_shared: "scout_chartdefinition_api_RowSharedPlotColoringConfiguration") -> Any:
        pass


scout_chartdefinition_api_PlotColoringConfigurationVisitor.__name__ = "PlotColoringConfigurationVisitor"
scout_chartdefinition_api_PlotColoringConfigurationVisitor.__qualname__ = "PlotColoringConfigurationVisitor"
scout_chartdefinition_api_PlotColoringConfigurationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotlyPanelDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_PlotlyPanelDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_PlotlyPanelDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_PlotlyPanelDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_PlotlyPanelDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_PlotlyPanelDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_PlotlyPanelDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_PlotlyPanelDefinition.__name__ = "PlotlyPanelDefinition"
scout_chartdefinition_api_PlotlyPanelDefinition.__qualname__ = "PlotlyPanelDefinition"
scout_chartdefinition_api_PlotlyPanelDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotlyPanelDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_PlotlyPanelDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_PlotlyPanelDefinitionVisitor.__name__ = "PlotlyPanelDefinitionVisitor"
scout_chartdefinition_api_PlotlyPanelDefinitionVisitor.__qualname__ = "PlotlyPanelDefinitionVisitor"
scout_chartdefinition_api_PlotlyPanelDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotlyPanelDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'preset': ConjureFieldDefinition('preset', OptionalTypeWrapper[scout_chartdefinition_api_PlotlyPreset]),
            'figure': ConjureFieldDefinition('figure', scout_chartdefinition_api_Figure)
        }

    __slots__: List[str] = ['_title', '_preset', '_figure']

    def __init__(self, figure: "scout_chartdefinition_api_Figure", preset: Optional["scout_chartdefinition_api_PlotlyPreset"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._preset = preset
        self._figure = figure

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def preset(self) -> Optional["scout_chartdefinition_api_PlotlyPreset"]:
        """A preset that will render a nominal-defined plotly figure with minimum necessary inputs
        """
        return self._preset

    @builtins.property
    def figure(self) -> "scout_chartdefinition_api_Figure":
        """The plotly instance definition, with extra fields for nominal-specific inputs
        """
        return self._figure


scout_chartdefinition_api_PlotlyPanelDefinitionV1.__name__ = "PlotlyPanelDefinitionV1"
scout_chartdefinition_api_PlotlyPanelDefinitionV1.__qualname__ = "PlotlyPanelDefinitionV1"
scout_chartdefinition_api_PlotlyPanelDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_PlotlyPreset(ConjureEnumType):

    SCATTER_3D = 'SCATTER_3D'
    '''SCATTER_3D'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_PlotlyPreset.__name__ = "PlotlyPreset"
scout_chartdefinition_api_PlotlyPreset.__qualname__ = "PlotlyPreset"
scout_chartdefinition_api_PlotlyPreset.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Position(ConjureEnumType):

    TOP = 'TOP'
    '''TOP'''
    BOTTOM = 'BOTTOM'
    '''BOTTOM'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_Position.__name__ = "Position"
scout_chartdefinition_api_Position.__qualname__ = "Position"
scout_chartdefinition_api_Position.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_ProcedureVizDefinitionV1"] = None
    _v2: Optional["scout_chartdefinition_api_ProcedureVizDefinitionV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_ProcedureVizDefinitionV1),
            'v2': ConjureFieldDefinition('v2', scout_chartdefinition_api_ProcedureVizDefinitionV2)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_ProcedureVizDefinitionV1"] = None,
            v2: Optional["scout_chartdefinition_api_ProcedureVizDefinitionV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) + (v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'
            if v2 is not None:
                self._v2 = v2
                self._type = 'v2'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'
        elif type_of_union == 'v2':
            if v2 is None:
                raise ValueError('a union value must not be None')
            self._v2 = v2
            self._type = 'v2'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_ProcedureVizDefinitionV1"]:
        return self._v1

    @builtins.property
    def v2(self) -> Optional["scout_chartdefinition_api_ProcedureVizDefinitionV2"]:
        return self._v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ProcedureVizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ProcedureVizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)
        if self._type == 'v2' and self.v2 is not None:
            return visitor._v2(self.v2)


scout_chartdefinition_api_ProcedureVizDefinition.__name__ = "ProcedureVizDefinition"
scout_chartdefinition_api_ProcedureVizDefinition.__qualname__ = "ProcedureVizDefinition"
scout_chartdefinition_api_ProcedureVizDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_ProcedureVizDefinitionV1") -> Any:
        pass

    @abstractmethod
    def _v2(self, v2: "scout_chartdefinition_api_ProcedureVizDefinitionV2") -> Any:
        pass


scout_chartdefinition_api_ProcedureVizDefinitionVisitor.__name__ = "ProcedureVizDefinitionVisitor"
scout_chartdefinition_api_ProcedureVizDefinitionVisitor.__qualname__ = "ProcedureVizDefinitionVisitor"
scout_chartdefinition_api_ProcedureVizDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'execution_rid': ConjureFieldDefinition('executionRid', OptionalTypeWrapper[api_rids_ProcedureExecutionRid])
        }

    __slots__: List[str] = ['_title', '_execution_rid']

    def __init__(self, execution_rid: Optional[str] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._execution_rid = execution_rid

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def execution_rid(self) -> Optional[str]:
        return self._execution_rid


scout_chartdefinition_api_ProcedureVizDefinitionV1.__name__ = "ProcedureVizDefinitionV1"
scout_chartdefinition_api_ProcedureVizDefinitionV1.__qualname__ = "ProcedureVizDefinitionV1"
scout_chartdefinition_api_ProcedureVizDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizDefinitionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'procedure': ConjureFieldDefinition('procedure', OptionalTypeWrapper[scout_chartdefinition_api_ProcedureVizId])
        }

    __slots__: List[str] = ['_title', '_procedure']

    def __init__(self, procedure: Optional["scout_chartdefinition_api_ProcedureVizId"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._procedure = procedure

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def procedure(self) -> Optional["scout_chartdefinition_api_ProcedureVizId"]:
        """A workbook can save either an execution or a template. Workbook templates should only use the latter.
        """
        return self._procedure


scout_chartdefinition_api_ProcedureVizDefinitionV2.__name__ = "ProcedureVizDefinitionV2"
scout_chartdefinition_api_ProcedureVizDefinitionV2.__qualname__ = "ProcedureVizDefinitionV2"
scout_chartdefinition_api_ProcedureVizDefinitionV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizId(ConjureUnionType):
    _execution_rid: Optional[str] = None
    _template_rid: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'execution_rid': ConjureFieldDefinition('executionRid', api_rids_ProcedureExecutionRid),
            'template_rid': ConjureFieldDefinition('templateRid', api_rids_ProcedureRid)
        }

    def __init__(
            self,
            execution_rid: Optional[str] = None,
            template_rid: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (execution_rid is not None) + (template_rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if execution_rid is not None:
                self._execution_rid = execution_rid
                self._type = 'executionRid'
            if template_rid is not None:
                self._template_rid = template_rid
                self._type = 'templateRid'

        elif type_of_union == 'executionRid':
            if execution_rid is None:
                raise ValueError('a union value must not be None')
            self._execution_rid = execution_rid
            self._type = 'executionRid'
        elif type_of_union == 'templateRid':
            if template_rid is None:
                raise ValueError('a union value must not be None')
            self._template_rid = template_rid
            self._type = 'templateRid'

    @builtins.property
    def execution_rid(self) -> Optional[str]:
        return self._execution_rid

    @builtins.property
    def template_rid(self) -> Optional[str]:
        return self._template_rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ProcedureVizIdVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ProcedureVizIdVisitor'.format(visitor.__class__.__name__))
        if self._type == 'executionRid' and self.execution_rid is not None:
            return visitor._execution_rid(self.execution_rid)
        if self._type == 'templateRid' and self.template_rid is not None:
            return visitor._template_rid(self.template_rid)


scout_chartdefinition_api_ProcedureVizId.__name__ = "ProcedureVizId"
scout_chartdefinition_api_ProcedureVizId.__qualname__ = "ProcedureVizId"
scout_chartdefinition_api_ProcedureVizId.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ProcedureVizIdVisitor:

    @abstractmethod
    def _execution_rid(self, execution_rid: str) -> Any:
        pass

    @abstractmethod
    def _template_rid(self, template_rid: str) -> Any:
        pass


scout_chartdefinition_api_ProcedureVizIdVisitor.__name__ = "ProcedureVizIdVisitor"
scout_chartdefinition_api_ProcedureVizIdVisitor.__qualname__ = "ProcedureVizIdVisitor"
scout_chartdefinition_api_ProcedureVizIdVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_RangeValueVisualisation]),
            'group_by_sort': ConjureFieldDefinition('groupBySort', OptionalTypeWrapper[scout_chartdefinition_api_RangeGroupBySort])
        }

    __slots__: List[str] = ['_visualisation', '_group_by_sort']

    def __init__(self, group_by_sort: Optional["scout_chartdefinition_api_RangeGroupBySort"] = None, visualisation: Optional["scout_chartdefinition_api_RangeValueVisualisation"] = None) -> None:
        self._visualisation = visualisation
        self._group_by_sort = group_by_sort

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_RangeValueVisualisation"]:
        return self._visualisation

    @builtins.property
    def group_by_sort(self) -> Optional["scout_chartdefinition_api_RangeGroupBySort"]:
        """Sorting configuration for grouped data rendering in a cell.
If undefined, will sort alphabetically by grouping.
        """
        return self._group_by_sort


scout_chartdefinition_api_RangeCellConfig.__name__ = "RangeCellConfig"
scout_chartdefinition_api_RangeCellConfig.__qualname__ = "RangeCellConfig"
scout_chartdefinition_api_RangeCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeGroupBySort(ConjureUnionType):
    _value: Optional["scout_chartdefinition_api_ValueSort"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', scout_chartdefinition_api_ValueSort)
        }

    def __init__(
            self,
            value: Optional["scout_chartdefinition_api_ValueSort"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if value is not None:
                self._value = value
                self._type = 'value'

        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'

    @builtins.property
    def value(self) -> Optional["scout_chartdefinition_api_ValueSort"]:
        return self._value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_RangeGroupBySortVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_RangeGroupBySortVisitor'.format(visitor.__class__.__name__))
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)


scout_chartdefinition_api_RangeGroupBySort.__name__ = "RangeGroupBySort"
scout_chartdefinition_api_RangeGroupBySort.__qualname__ = "RangeGroupBySort"
scout_chartdefinition_api_RangeGroupBySort.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeGroupBySortVisitor:

    @abstractmethod
    def _value(self, value: "scout_chartdefinition_api_ValueSort") -> Any:
        pass


scout_chartdefinition_api_RangeGroupBySortVisitor.__name__ = "RangeGroupBySortVisitor"
scout_chartdefinition_api_RangeGroupBySortVisitor.__qualname__ = "RangeGroupBySortVisitor"
scout_chartdefinition_api_RangeGroupBySortVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeRawVisualisation(ConjureBeanType):
    """The settings for a raw range visualisation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range_color': ConjureFieldDefinition('rangeColor', OptionalTypeWrapper[scout_api_HexColor]),
            'range_label': ConjureFieldDefinition('rangeLabel', OptionalTypeWrapper[str]),
            'no_range_color': ConjureFieldDefinition('noRangeColor', OptionalTypeWrapper[scout_api_HexColor]),
            'no_range_label': ConjureFieldDefinition('noRangeLabel', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_range_color', '_range_label', '_no_range_color', '_no_range_label']

    def __init__(self, no_range_color: Optional[str] = None, no_range_label: Optional[str] = None, range_color: Optional[str] = None, range_label: Optional[str] = None) -> None:
        self._range_color = range_color
        self._range_label = range_label
        self._no_range_color = no_range_color
        self._no_range_label = no_range_label

    @builtins.property
    def range_color(self) -> Optional[str]:
        return self._range_color

    @builtins.property
    def range_label(self) -> Optional[str]:
        """The string to display when the condition defined by the variable's function spec is met.
        """
        return self._range_label

    @builtins.property
    def no_range_color(self) -> Optional[str]:
        return self._no_range_color

    @builtins.property
    def no_range_label(self) -> Optional[str]:
        """The string to display when the condition defined by the variable's function spec is not met.
        """
        return self._no_range_label


scout_chartdefinition_api_RangeRawVisualisation.__name__ = "RangeRawVisualisation"
scout_chartdefinition_api_RangeRawVisualisation.__qualname__ = "RangeRawVisualisation"
scout_chartdefinition_api_RangeRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'visualisation': ConjureFieldDefinition('visualisation', scout_chartdefinition_api_RangeValueVisualisation)
        }

    __slots__: List[str] = ['_variable_name', '_visualisation']

    def __init__(self, variable_name: str, visualisation: "scout_chartdefinition_api_RangeValueVisualisation") -> None:
        self._variable_name = variable_name
        self._visualisation = visualisation

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def visualisation(self) -> "scout_chartdefinition_api_RangeValueVisualisation":
        return self._visualisation


scout_chartdefinition_api_RangeValueChannel.__name__ = "RangeValueChannel"
scout_chartdefinition_api_RangeValueChannel.__qualname__ = "RangeValueChannel"
scout_chartdefinition_api_RangeValueChannel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_RangeRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_RangeRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_RangeRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_RangeRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_RangeValueVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_RangeValueVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_RangeValueVisualisation.__name__ = "RangeValueVisualisation"
scout_chartdefinition_api_RangeValueVisualisation.__qualname__ = "RangeValueVisualisation"
scout_chartdefinition_api_RangeValueVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RangeValueVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_RangeRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_RangeValueVisualisationVisitor.__name__ = "RangeValueVisualisationVisitor"
scout_chartdefinition_api_RangeValueVisualisationVisitor.__qualname__ = "RangeValueVisualisationVisitor"
scout_chartdefinition_api_RangeValueVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RowIndependentPlotColoringConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_RowIndependentPlotColoringConfiguration.__name__ = "RowIndependentPlotColoringConfiguration"
scout_chartdefinition_api_RowIndependentPlotColoringConfiguration.__qualname__ = "RowIndependentPlotColoringConfiguration"
scout_chartdefinition_api_RowIndependentPlotColoringConfiguration.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_RowSharedPlotColoringConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_RowSharedPlotColoringConfiguration.__name__ = "RowSharedPlotColoringConfiguration"
scout_chartdefinition_api_RowSharedPlotColoringConfiguration.__qualname__ = "RowSharedPlotColoringConfiguration"
scout_chartdefinition_api_RowSharedPlotColoringConfiguration.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Scatter3dDecimationStrategy(ConjureEnumType):

    SPATIAL = 'SPATIAL'
    '''SPATIAL'''
    TEMPORAL = 'TEMPORAL'
    '''TEMPORAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_Scatter3dDecimationStrategy.__name__ = "Scatter3dDecimationStrategy"
scout_chartdefinition_api_Scatter3dDecimationStrategy.__qualname__ = "Scatter3dDecimationStrategy"
scout_chartdefinition_api_Scatter3dDecimationStrategy.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Scatter3dTraceComputeConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'decimation_strategy': ConjureFieldDefinition('decimationStrategy', OptionalTypeWrapper[scout_chartdefinition_api_Scatter3dDecimationStrategy])
        }

    __slots__: List[str] = ['_decimation_strategy']

    def __init__(self, decimation_strategy: Optional["scout_chartdefinition_api_Scatter3dDecimationStrategy"] = None) -> None:
        self._decimation_strategy = decimation_strategy

    @builtins.property
    def decimation_strategy(self) -> Optional["scout_chartdefinition_api_Scatter3dDecimationStrategy"]:
        """Bucket computed data points by their proximity in space or in time
        """
        return self._decimation_strategy


scout_chartdefinition_api_Scatter3dTraceComputeConfig.__name__ = "Scatter3dTraceComputeConfig"
scout_chartdefinition_api_Scatter3dTraceComputeConfig.__qualname__ = "Scatter3dTraceComputeConfig"
scout_chartdefinition_api_Scatter3dTraceComputeConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StalenessCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_StalenessVisualisation]),
            'group_by_sort': ConjureFieldDefinition('groupBySort', OptionalTypeWrapper[scout_chartdefinition_api_NumericGroupBySort])
        }

    __slots__: List[str] = ['_visualisation', '_group_by_sort']

    def __init__(self, group_by_sort: Optional["scout_chartdefinition_api_NumericGroupBySort"] = None, visualisation: Optional["scout_chartdefinition_api_StalenessVisualisation"] = None) -> None:
        self._visualisation = visualisation
        self._group_by_sort = group_by_sort

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_StalenessVisualisation"]:
        return self._visualisation

    @builtins.property
    def group_by_sort(self) -> Optional["scout_chartdefinition_api_NumericGroupBySort"]:
        """Sorting configuration for grouped data rendering in a cell.
If undefined, will sort alphabetically by grouping.
        """
        return self._group_by_sort


scout_chartdefinition_api_StalenessCellConfig.__name__ = "StalenessCellConfig"
scout_chartdefinition_api_StalenessCellConfig.__qualname__ = "StalenessCellConfig"
scout_chartdefinition_api_StalenessCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StalenessConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'threshold': ConjureFieldDefinition('threshold', scout_run_api_Duration),
            'connect_stale_points': ConjureFieldDefinition('connectStalePoints', bool)
        }

    __slots__: List[str] = ['_threshold', '_connect_stale_points']

    def __init__(self, connect_stale_points: bool, threshold: "scout_run_api_Duration") -> None:
        self._threshold = threshold
        self._connect_stale_points = connect_stale_points

    @builtins.property
    def threshold(self) -> "scout_run_api_Duration":
        """The duration above which points are considered stale. By default this is 1 second.
        """
        return self._threshold

    @builtins.property
    def connect_stale_points(self) -> bool:
        """Whether or not to visually connect stale points, i.e. points whose distance exceeds that of the configured threshold. By default this is true.
        """
        return self._connect_stale_points


scout_chartdefinition_api_StalenessConfiguration.__name__ = "StalenessConfiguration"
scout_chartdefinition_api_StalenessConfiguration.__qualname__ = "StalenessConfiguration"
scout_chartdefinition_api_StalenessConfiguration.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StalenessVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_NumericRawVisualisationV2"] = None
    _bar: Optional["scout_chartdefinition_api_NumericBarVisualisationV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_NumericRawVisualisationV2),
            'bar': ConjureFieldDefinition('bar', scout_chartdefinition_api_NumericBarVisualisationV2)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_NumericRawVisualisationV2"] = None,
            bar: Optional["scout_chartdefinition_api_NumericBarVisualisationV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (bar is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if bar is not None:
                self._bar = bar
                self._type = 'bar'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'bar':
            if bar is None:
                raise ValueError('a union value must not be None')
            self._bar = bar
            self._type = 'bar'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_NumericRawVisualisationV2"]:
        return self._raw

    @builtins.property
    def bar(self) -> Optional["scout_chartdefinition_api_NumericBarVisualisationV2"]:
        return self._bar

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_StalenessVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_StalenessVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'bar' and self.bar is not None:
            return visitor._bar(self.bar)


scout_chartdefinition_api_StalenessVisualisation.__name__ = "StalenessVisualisation"
scout_chartdefinition_api_StalenessVisualisation.__qualname__ = "StalenessVisualisation"
scout_chartdefinition_api_StalenessVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StalenessVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_NumericRawVisualisationV2") -> Any:
        pass

    @abstractmethod
    def _bar(self, bar: "scout_chartdefinition_api_NumericBarVisualisationV2") -> Any:
        pass


scout_chartdefinition_api_StalenessVisualisationVisitor.__name__ = "StalenessVisualisationVisitor"
scout_chartdefinition_api_StalenessVisualisationVisitor.__qualname__ = "StalenessVisualisationVisitor"
scout_chartdefinition_api_StalenessVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StructCellConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'visualisation': ConjureFieldDefinition('visualisation', OptionalTypeWrapper[scout_chartdefinition_api_StructVisualisation])
        }

    __slots__: List[str] = ['_visualisation']

    def __init__(self, visualisation: Optional["scout_chartdefinition_api_StructVisualisation"] = None) -> None:
        self._visualisation = visualisation

    @builtins.property
    def visualisation(self) -> Optional["scout_chartdefinition_api_StructVisualisation"]:
        return self._visualisation


scout_chartdefinition_api_StructCellConfig.__name__ = "StructCellConfig"
scout_chartdefinition_api_StructCellConfig.__qualname__ = "StructCellConfig"
scout_chartdefinition_api_StructCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StructRawVisualisation(ConjureBeanType):
    """A raw struct visualisation (renders the JSON as-is)
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_chartdefinition_api_StructRawVisualisation.__name__ = "StructRawVisualisation"
scout_chartdefinition_api_StructRawVisualisation.__qualname__ = "StructRawVisualisation"
scout_chartdefinition_api_StructRawVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StructVisualisation(ConjureUnionType):
    _raw: Optional["scout_chartdefinition_api_StructRawVisualisation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_chartdefinition_api_StructRawVisualisation)
        }

    def __init__(
            self,
            raw: Optional["scout_chartdefinition_api_StructRawVisualisation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_chartdefinition_api_StructRawVisualisation"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_StructVisualisationVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_StructVisualisationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_chartdefinition_api_StructVisualisation.__name__ = "StructVisualisation"
scout_chartdefinition_api_StructVisualisation.__qualname__ = "StructVisualisation"
scout_chartdefinition_api_StructVisualisation.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_StructVisualisationVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_chartdefinition_api_StructRawVisualisation") -> Any:
        pass


scout_chartdefinition_api_StructVisualisationVisitor.__name__ = "StructVisualisationVisitor"
scout_chartdefinition_api_StructVisualisationVisitor.__qualname__ = "StructVisualisationVisitor"
scout_chartdefinition_api_StructVisualisationVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Threshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'latch': ConjureFieldDefinition('latch', OptionalTypeWrapper[scout_chartdefinition_api_ThresholdLatch])
        }

    __slots__: List[str] = ['_value', '_color', '_label', '_latch']

    def __init__(self, color: str, value: float, label: Optional[str] = None, latch: Optional["scout_chartdefinition_api_ThresholdLatch"] = None) -> None:
        self._value = value
        self._color = color
        self._label = label
        self._latch = latch

    @builtins.property
    def value(self) -> float:
        """The minimum value a number must be to trigger the threshold color. If used in a staleness cell, this value is in milliseconds.
        """
        return self._value

    @builtins.property
    def color(self) -> str:
        """The color to apply to the cell when the threshold is active.
        """
        return self._color

    @builtins.property
    def label(self) -> Optional[str]:
        """A name for this threshold to display while editing.
        """
        return self._label

    @builtins.property
    def latch(self) -> Optional["scout_chartdefinition_api_ThresholdLatch"]:
        """Options for pinning an indicator that data was within the threshold range
while streaming.
        """
        return self._latch


scout_chartdefinition_api_Threshold.__name__ = "Threshold"
scout_chartdefinition_api_Threshold.__qualname__ = "Threshold"
scout_chartdefinition_api_Threshold.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdDisconnectedValues(ConjureBeanType):
    """NOTE this is deprecated and will be translated to NeverConnectDisconnectedValues by the frontend.
This option indicates the duration below which disconnected values will always be connected with a line.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_type']

    def __init__(self, type: "scout_run_api_Duration") -> None:
        self._type = type

    @builtins.property
    def type(self) -> "scout_run_api_Duration":
        return self._type


scout_chartdefinition_api_ThresholdDisconnectedValues.__name__ = "ThresholdDisconnectedValues"
scout_chartdefinition_api_ThresholdDisconnectedValues.__qualname__ = "ThresholdDisconnectedValues"
scout_chartdefinition_api_ThresholdDisconnectedValues.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdLatch(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enabled': ConjureFieldDefinition('enabled', bool)
        }

    __slots__: List[str] = ['_enabled']

    def __init__(self, enabled: bool) -> None:
        self._enabled = enabled

    @builtins.property
    def enabled(self) -> bool:
        return self._enabled


scout_chartdefinition_api_ThresholdLatch.__name__ = "ThresholdLatch"
scout_chartdefinition_api_ThresholdLatch.__qualname__ = "ThresholdLatch"
scout_chartdefinition_api_ThresholdLatch.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdLineStyle(ConjureEnumType):

    DOTTED = 'DOTTED'
    '''DOTTED'''
    SOLID = 'SOLID'
    '''SOLID'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_ThresholdLineStyle.__name__ = "ThresholdLineStyle"
scout_chartdefinition_api_ThresholdLineStyle.__qualname__ = "ThresholdLineStyle"
scout_chartdefinition_api_ThresholdLineStyle.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ThresholdShadingConfig(ConjureEnumType):
    """Specifies how areas of a plot should be shaded in relation to the defined threshold lines. Will eventually
include other shading configurations, like a buffer zone.
    """

    ABOVE = 'ABOVE'
    '''ABOVE'''
    BELOW = 'BELOW'
    '''BELOW'''
    NONE = 'NONE'
    '''NONE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_chartdefinition_api_ThresholdShadingConfig.__name__ = "ThresholdShadingConfig"
scout_chartdefinition_api_ThresholdShadingConfig.__qualname__ = "ThresholdShadingConfig"
scout_chartdefinition_api_ThresholdShadingConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_TimeSeriesChartDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_TimeSeriesChartDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_chartdefinition_api_TimeSeriesChartDefinition.__name__ = "TimeSeriesChartDefinition"
scout_chartdefinition_api_TimeSeriesChartDefinition.__qualname__ = "TimeSeriesChartDefinition"
scout_chartdefinition_api_TimeSeriesChartDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_TimeSeriesChartDefinitionV1") -> Any:
        pass


scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__name__ = "TimeSeriesChartDefinitionVisitor"
scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__qualname__ = "TimeSeriesChartDefinitionVisitor"
scout_chartdefinition_api_TimeSeriesChartDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesChartDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rows': ConjureFieldDefinition('rows', List[scout_chartdefinition_api_TimeSeriesRow]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'events': ConjureFieldDefinition('events', OptionalTypeWrapper[List[scout_chartdefinition_api_Event]]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'thresholds': ConjureFieldDefinition('thresholds', OptionalTypeWrapper[List[scout_chartdefinition_api_AxisThresholdVisualization]]),
            'disconnected_values': ConjureFieldDefinition('disconnectedValues', OptionalTypeWrapper[scout_chartdefinition_api_DisconnectedValueVisualization]),
            'staleness_configuration': ConjureFieldDefinition('stalenessConfiguration', OptionalTypeWrapper[scout_chartdefinition_api_StalenessConfiguration]),
            'plot_coloring_configuration': ConjureFieldDefinition('plotColoringConfiguration', OptionalTypeWrapper[scout_chartdefinition_api_PlotColoringConfiguration]),
            'bucket_strategy': ConjureFieldDefinition('bucketStrategy', OptionalTypeWrapper[scout_chartdefinition_api_PanelBucketStrategy]),
            'floating_legends_config': ConjureFieldDefinition('floatingLegendsConfig', OptionalTypeWrapper[scout_chartdefinition_api_FloatingLegendConfig])
        }

    __slots__: List[str] = ['_rows', '_comparison_run_groups', '_events', '_title', '_value_axes', '_thresholds', '_disconnected_values', '_staleness_configuration', '_plot_coloring_configuration', '_bucket_strategy', '_floating_legends_config']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], rows: List["scout_chartdefinition_api_TimeSeriesRow"], value_axes: List["scout_chartdefinition_api_ValueAxis"], bucket_strategy: Optional["scout_chartdefinition_api_PanelBucketStrategy"] = None, disconnected_values: Optional["scout_chartdefinition_api_DisconnectedValueVisualization"] = None, events: Optional[List["scout_chartdefinition_api_Event"]] = None, floating_legends_config: Optional["scout_chartdefinition_api_FloatingLegendConfig"] = None, plot_coloring_configuration: Optional["scout_chartdefinition_api_PlotColoringConfiguration"] = None, staleness_configuration: Optional["scout_chartdefinition_api_StalenessConfiguration"] = None, thresholds: Optional[List["scout_chartdefinition_api_AxisThresholdVisualization"]] = None, title: Optional[str] = None) -> None:
        self._rows = rows
        self._comparison_run_groups = comparison_run_groups
        self._events = events
        self._title = title
        self._value_axes = value_axes
        self._thresholds = thresholds
        self._disconnected_values = disconnected_values
        self._staleness_configuration = staleness_configuration
        self._plot_coloring_configuration = plot_coloring_configuration
        self._bucket_strategy = bucket_strategy
        self._floating_legends_config = floating_legends_config

    @builtins.property
    def rows(self) -> List["scout_chartdefinition_api_TimeSeriesRow"]:
        return self._rows

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def events(self) -> Optional[List["scout_chartdefinition_api_Event"]]:
        return self._events

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        return self._value_axes

    @builtins.property
    def thresholds(self) -> Optional[List["scout_chartdefinition_api_AxisThresholdVisualization"]]:
        return self._thresholds

    @builtins.property
    def disconnected_values(self) -> Optional["scout_chartdefinition_api_DisconnectedValueVisualization"]:
        """Determines when disconnected values should be connected. By default, they are always connected.
        """
        return self._disconnected_values

    @builtins.property
    def staleness_configuration(self) -> Optional["scout_chartdefinition_api_StalenessConfiguration"]:
        """Determines when to draw lines between points. By default, the staleness threshold is 1s and stale points are connected.
        """
        return self._staleness_configuration

    @builtins.property
    def plot_coloring_configuration(self) -> Optional["scout_chartdefinition_api_PlotColoringConfiguration"]:
        """Configuration for coloring time series plots in this chart. By default, plots are colored
independently between rows with a unique color if possible when created.
        """
        return self._plot_coloring_configuration

    @builtins.property
    def bucket_strategy(self) -> Optional["scout_chartdefinition_api_PanelBucketStrategy"]:
        """Custom bucket size to use when loading data.
        """
        return self._bucket_strategy

    @builtins.property
    def floating_legends_config(self) -> Optional["scout_chartdefinition_api_FloatingLegendConfig"]:
        """Config for showing floating legends in the chart. If undefined, defaults to hiding.
        """
        return self._floating_legends_config


scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__name__ = "TimeSeriesChartDefinitionV1"
scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__qualname__ = "TimeSeriesChartDefinitionV1"
scout_chartdefinition_api_TimeSeriesChartDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesEnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_chartdefinition_api_ColorStyle),
            'position': ConjureFieldDefinition('position', scout_chartdefinition_api_Position),
            'persist_value_overlays': ConjureFieldDefinition('persistValueOverlays', scout_chartdefinition_api_PersistValueOverlay),
            'overlay_scope': ConjureFieldDefinition('overlayScope', scout_chartdefinition_api_OverlayScope),
            'display_inline': ConjureFieldDefinition('displayInline', OptionalTypeWrapper[bool]),
            'display_style': ConjureFieldDefinition('displayStyle', OptionalTypeWrapper[scout_chartdefinition_api_EnumDisplayStyle])
        }

    __slots__: List[str] = ['_color', '_position', '_persist_value_overlays', '_overlay_scope', '_display_inline', '_display_style']

    def __init__(self, color: "scout_chartdefinition_api_ColorStyle", overlay_scope: "scout_chartdefinition_api_OverlayScope", persist_value_overlays: "scout_chartdefinition_api_PersistValueOverlay", position: "scout_chartdefinition_api_Position", display_inline: Optional[bool] = None, display_style: Optional["scout_chartdefinition_api_EnumDisplayStyle"] = None) -> None:
        self._color = color
        self._position = position
        self._persist_value_overlays = persist_value_overlays
        self._overlay_scope = overlay_scope
        self._display_inline = display_inline
        self._display_style = display_style

    @builtins.property
    def color(self) -> "scout_chartdefinition_api_ColorStyle":
        """How to color the value ranges
        """
        return self._color

    @builtins.property
    def position(self) -> "scout_chartdefinition_api_Position":
        """Where to place the plot within the row
        """
        return self._position

    @builtins.property
    def persist_value_overlays(self) -> "scout_chartdefinition_api_PersistValueOverlay":
        """Render certain values' full-row/full-panel color overlays
even when not interacting with the plot
        """
        return self._persist_value_overlays

    @builtins.property
    def overlay_scope(self) -> "scout_chartdefinition_api_OverlayScope":
        """How far to extend the overlay
        """
        return self._overlay_scope

    @builtins.property
    def display_inline(self) -> Optional[bool]:
        return self._display_inline

    @builtins.property
    def display_style(self) -> Optional["scout_chartdefinition_api_EnumDisplayStyle"]:
        """How to display the enum values on the chart
        """
        return self._display_style


scout_chartdefinition_api_TimeSeriesEnumPlot.__name__ = "TimeSeriesEnumPlot"
scout_chartdefinition_api_TimeSeriesEnumPlot.__qualname__ = "TimeSeriesEnumPlot"
scout_chartdefinition_api_TimeSeriesEnumPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesNumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_LineStyle") -> None:
        self._color = color
        self._line_style = line_style

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_TimeSeriesNumericPlot.__name__ = "TimeSeriesNumericPlot"
scout_chartdefinition_api_TimeSeriesNumericPlot.__qualname__ = "TimeSeriesNumericPlot"
scout_chartdefinition_api_TimeSeriesNumericPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'color': ConjureFieldDefinition('color', scout_api_HexColor),
            'line_style': ConjureFieldDefinition('lineStyle', scout_chartdefinition_api_LineStyle)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_y_axis_id', '_color', '_line_style']

    def __init__(self, color: str, line_style: "scout_chartdefinition_api_LineStyle", variable_name: str, y_axis_id: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._y_axis_id = y_axis_id
        self._color = color
        self._line_style = line_style

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def line_style(self) -> "scout_chartdefinition_api_LineStyle":
        return self._line_style


scout_chartdefinition_api_TimeSeriesPlot.__name__ = "TimeSeriesPlot"
scout_chartdefinition_api_TimeSeriesPlot.__qualname__ = "TimeSeriesPlot"
scout_chartdefinition_api_TimeSeriesPlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesPlotConfig(ConjureUnionType):
    _numeric: Optional["scout_chartdefinition_api_TimeSeriesNumericPlot"] = None
    _range: Optional["scout_chartdefinition_api_TimeSeriesRangePlot"] = None
    _enum: Optional["scout_chartdefinition_api_TimeSeriesEnumPlot"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_chartdefinition_api_TimeSeriesNumericPlot),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_TimeSeriesRangePlot),
            'enum': ConjureFieldDefinition('enum', scout_chartdefinition_api_TimeSeriesEnumPlot)
        }

    def __init__(
            self,
            numeric: Optional["scout_chartdefinition_api_TimeSeriesNumericPlot"] = None,
            range: Optional["scout_chartdefinition_api_TimeSeriesRangePlot"] = None,
            enum: Optional["scout_chartdefinition_api_TimeSeriesEnumPlot"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (range is not None) + (enum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if range is not None:
                self._range = range
                self._type = 'range'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'

    @builtins.property
    def numeric(self) -> Optional["scout_chartdefinition_api_TimeSeriesNumericPlot"]:
        return self._numeric

    @builtins.property
    def range(self) -> Optional["scout_chartdefinition_api_TimeSeriesRangePlot"]:
        return self._range

    @builtins.property
    def enum(self) -> Optional["scout_chartdefinition_api_TimeSeriesEnumPlot"]:
        return self._enum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_TimeSeriesPlotConfigVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_TimeSeriesPlotConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)


scout_chartdefinition_api_TimeSeriesPlotConfig.__name__ = "TimeSeriesPlotConfig"
scout_chartdefinition_api_TimeSeriesPlotConfig.__qualname__ = "TimeSeriesPlotConfig"
scout_chartdefinition_api_TimeSeriesPlotConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesPlotConfigVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_chartdefinition_api_TimeSeriesNumericPlot") -> Any:
        pass

    @abstractmethod
    def _range(self, range: "scout_chartdefinition_api_TimeSeriesRangePlot") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_chartdefinition_api_TimeSeriesEnumPlot") -> Any:
        pass


scout_chartdefinition_api_TimeSeriesPlotConfigVisitor.__name__ = "TimeSeriesPlotConfigVisitor"
scout_chartdefinition_api_TimeSeriesPlotConfigVisitor.__qualname__ = "TimeSeriesPlotConfigVisitor"
scout_chartdefinition_api_TimeSeriesPlotConfigVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesPlotV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', scout_channelvariables_api_ChannelVariableName),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool]),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'type': ConjureFieldDefinition('type', scout_chartdefinition_api_TimeSeriesPlotConfig)
        }

    __slots__: List[str] = ['_variable_name', '_enabled', '_y_axis_id', '_type']

    def __init__(self, type: "scout_chartdefinition_api_TimeSeriesPlotConfig", variable_name: str, y_axis_id: str, enabled: Optional[bool] = None) -> None:
        self._variable_name = variable_name
        self._enabled = enabled
        self._y_axis_id = y_axis_id
        self._type = type

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled

    @builtins.property
    def y_axis_id(self) -> str:
        return self._y_axis_id

    @builtins.property
    def type(self) -> "scout_chartdefinition_api_TimeSeriesPlotConfig":
        return self._type


scout_chartdefinition_api_TimeSeriesPlotV2.__name__ = "TimeSeriesPlotV2"
scout_chartdefinition_api_TimeSeriesPlotV2.__qualname__ = "TimeSeriesPlotV2"
scout_chartdefinition_api_TimeSeriesPlotV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesRangePlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_HexColor)
        }

    __slots__: List[str] = ['_color']

    def __init__(self, color: str) -> None:
        self._color = color

    @builtins.property
    def color(self) -> str:
        return self._color


scout_chartdefinition_api_TimeSeriesRangePlot.__name__ = "TimeSeriesRangePlot"
scout_chartdefinition_api_TimeSeriesRangePlot.__qualname__ = "TimeSeriesRangePlot"
scout_chartdefinition_api_TimeSeriesRangePlot.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TimeSeriesRow(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'plots': ConjureFieldDefinition('plots', List[scout_chartdefinition_api_TimeSeriesPlot]),
            'plots_v2': ConjureFieldDefinition('plotsV2', OptionalTypeWrapper[List[scout_chartdefinition_api_TimeSeriesPlotV2]]),
            'row_flex_size': ConjureFieldDefinition('rowFlexSize', float),
            'enabled': ConjureFieldDefinition('enabled', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_plots', '_plots_v2', '_row_flex_size', '_enabled']

    def __init__(self, plots: List["scout_chartdefinition_api_TimeSeriesPlot"], row_flex_size: float, enabled: Optional[bool] = None, plots_v2: Optional[List["scout_chartdefinition_api_TimeSeriesPlotV2"]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._plots = plots
        self._plots_v2 = plots_v2
        self._row_flex_size = row_flex_size
        self._enabled = enabled

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def plots(self) -> List["scout_chartdefinition_api_TimeSeriesPlot"]:
        return self._plots

    @builtins.property
    def plots_v2(self) -> Optional[List["scout_chartdefinition_api_TimeSeriesPlotV2"]]:
        return self._plots_v2

    @builtins.property
    def row_flex_size(self) -> float:
        return self._row_flex_size

    @builtins.property
    def enabled(self) -> Optional[bool]:
        return self._enabled


scout_chartdefinition_api_TimeSeriesRow.__name__ = "TimeSeriesRow"
scout_chartdefinition_api_TimeSeriesRow.__qualname__ = "TimeSeriesRow"
scout_chartdefinition_api_TimeSeriesRow.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_Trace(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plotly_trace': ConjureFieldDefinition('plotlyTrace', str),
            'compute': ConjureFieldDefinition('compute', OptionalTypeWrapper[scout_chartdefinition_api_TraceCompute])
        }

    __slots__: List[str] = ['_plotly_trace', '_compute']

    def __init__(self, plotly_trace: str, compute: Optional["scout_chartdefinition_api_TraceCompute"] = None) -> None:
        self._plotly_trace = plotly_trace
        self._compute = compute

    @builtins.property
    def plotly_trace(self) -> str:
        """The json trace definition according to plotly's schema
https://plotly.com/python/figure-structure/#the-toplevel-data-attribute
        """
        return self._plotly_trace

    @builtins.property
    def compute(self) -> Optional["scout_chartdefinition_api_TraceCompute"]:
        """Information needed to substitute computed data arrays into the trace
        """
        return self._compute


scout_chartdefinition_api_Trace.__name__ = "Trace"
scout_chartdefinition_api_Trace.__qualname__ = "Trace"
scout_chartdefinition_api_Trace.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TraceCompute(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'trace_channel_variables': ConjureFieldDefinition('traceChannelVariables', Dict[str, scout_channelvariables_api_ChannelVariableName]),
            'config': ConjureFieldDefinition('config', OptionalTypeWrapper[scout_chartdefinition_api_TraceComputeConfig])
        }

    __slots__: List[str] = ['_trace_channel_variables', '_config']

    def __init__(self, trace_channel_variables: Dict[str, str], config: Optional["scout_chartdefinition_api_TraceComputeConfig"] = None) -> None:
        self._trace_channel_variables = trace_channel_variables
        self._config = config

    @builtins.property
    def trace_channel_variables(self) -> Dict[str, str]:
        """A map of plotly trace variables to the channel variables that should load into them
        """
        return self._trace_channel_variables

    @builtins.property
    def config(self) -> Optional["scout_chartdefinition_api_TraceComputeConfig"]:
        return self._config


scout_chartdefinition_api_TraceCompute.__name__ = "TraceCompute"
scout_chartdefinition_api_TraceCompute.__qualname__ = "TraceCompute"
scout_chartdefinition_api_TraceCompute.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TraceComputeConfig(ConjureUnionType):
    _scatter3d: Optional["scout_chartdefinition_api_Scatter3dTraceComputeConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter3d': ConjureFieldDefinition('scatter3d', scout_chartdefinition_api_Scatter3dTraceComputeConfig)
        }

    def __init__(
            self,
            scatter3d: Optional["scout_chartdefinition_api_Scatter3dTraceComputeConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter3d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter3d is not None:
                self._scatter3d = scatter3d
                self._type = 'scatter3d'

        elif type_of_union == 'scatter3d':
            if scatter3d is None:
                raise ValueError('a union value must not be None')
            self._scatter3d = scatter3d
            self._type = 'scatter3d'

    @builtins.property
    def scatter3d(self) -> Optional["scout_chartdefinition_api_Scatter3dTraceComputeConfig"]:
        return self._scatter3d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_TraceComputeConfigVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_TraceComputeConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter3d' and self.scatter3d is not None:
            return visitor._scatter3d(self.scatter3d)


scout_chartdefinition_api_TraceComputeConfig.__name__ = "TraceComputeConfig"
scout_chartdefinition_api_TraceComputeConfig.__qualname__ = "TraceComputeConfig"
scout_chartdefinition_api_TraceComputeConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_TraceComputeConfigVisitor:

    @abstractmethod
    def _scatter3d(self, scatter3d: "scout_chartdefinition_api_Scatter3dTraceComputeConfig") -> Any:
        pass


scout_chartdefinition_api_TraceComputeConfigVisitor.__name__ = "TraceComputeConfigVisitor"
scout_chartdefinition_api_TraceComputeConfigVisitor.__qualname__ = "TraceComputeConfigVisitor"
scout_chartdefinition_api_TraceComputeConfigVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueAxis(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', str),
            'title': ConjureFieldDefinition('title', str),
            'display_options': ConjureFieldDefinition('displayOptions', scout_chartdefinition_api_AxisDisplayOptions),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_AxisRange),
            'limit': ConjureFieldDefinition('limit', scout_chartdefinition_api_AxisRange),
            'position': ConjureFieldDefinition('position', scout_chartdefinition_api_AxisPosition),
            'domain_type': ConjureFieldDefinition('domainType', scout_chartdefinition_api_AxisDomainType),
            'tick_number_format': ConjureFieldDefinition('tickNumberFormat', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormat]),
            'tooltip_number_format': ConjureFieldDefinition('tooltipNumberFormat', OptionalTypeWrapper[scout_chartdefinition_api_NumberFormat]),
            'reversed': ConjureFieldDefinition('reversed', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_id', '_title', '_display_options', '_range', '_limit', '_position', '_domain_type', '_tick_number_format', '_tooltip_number_format', '_reversed']

    def __init__(self, display_options: "scout_chartdefinition_api_AxisDisplayOptions", domain_type: "scout_chartdefinition_api_AxisDomainType", id: str, limit: "scout_chartdefinition_api_AxisRange", position: "scout_chartdefinition_api_AxisPosition", range: "scout_chartdefinition_api_AxisRange", title: str, reversed: Optional[bool] = None, tick_number_format: Optional["scout_chartdefinition_api_NumberFormat"] = None, tooltip_number_format: Optional["scout_chartdefinition_api_NumberFormat"] = None) -> None:
        self._id = id
        self._title = title
        self._display_options = display_options
        self._range = range
        self._limit = limit
        self._position = position
        self._domain_type = domain_type
        self._tick_number_format = tick_number_format
        self._tooltip_number_format = tooltip_number_format
        self._reversed = reversed

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def display_options(self) -> "scout_chartdefinition_api_AxisDisplayOptions":
        return self._display_options

    @builtins.property
    def range(self) -> "scout_chartdefinition_api_AxisRange":
        return self._range

    @builtins.property
    def limit(self) -> "scout_chartdefinition_api_AxisRange":
        return self._limit

    @builtins.property
    def position(self) -> "scout_chartdefinition_api_AxisPosition":
        return self._position

    @builtins.property
    def domain_type(self) -> "scout_chartdefinition_api_AxisDomainType":
        return self._domain_type

    @builtins.property
    def tick_number_format(self) -> Optional["scout_chartdefinition_api_NumberFormat"]:
        return self._tick_number_format

    @builtins.property
    def tooltip_number_format(self) -> Optional["scout_chartdefinition_api_NumberFormat"]:
        return self._tooltip_number_format

    @builtins.property
    def reversed(self) -> Optional[bool]:
        """Whether the axis direction is reversed. When true, larger values appear on the
opposite side (left for X axis, bottom for Y axis). Defaults to false.
        """
        return self._reversed


scout_chartdefinition_api_ValueAxis.__name__ = "ValueAxis"
scout_chartdefinition_api_ValueAxis.__qualname__ = "ValueAxis"
scout_chartdefinition_api_ValueAxis.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueSort(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool)
        }

    __slots__: List[str] = ['_is_descending']

    def __init__(self, is_descending: bool) -> None:
        self._is_descending = is_descending

    @builtins.property
    def is_descending(self) -> bool:
        """If true, numerics sort high to low, enums sort alphabetically descending, and ranges sort inRange groupings first.
If false, the opposite is true for each.
        """
        return self._is_descending


scout_chartdefinition_api_ValueSort.__name__ = "ValueSort"
scout_chartdefinition_api_ValueSort.__qualname__ = "ValueSort"
scout_chartdefinition_api_ValueSort.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableCell(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable_name': ConjureFieldDefinition('variableName', str),
            'uuid': ConjureFieldDefinition('uuid', OptionalTypeWrapper[str]),
            'config': ConjureFieldDefinition('config', scout_chartdefinition_api_ValueTableCellConfig)
        }

    __slots__: List[str] = ['_variable_name', '_uuid', '_config']

    def __init__(self, config: "scout_chartdefinition_api_ValueTableCellConfig", variable_name: str, uuid: Optional[str] = None) -> None:
        self._variable_name = variable_name
        self._uuid = uuid
        self._config = config

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def uuid(self) -> Optional[str]:
        return self._uuid

    @builtins.property
    def config(self) -> "scout_chartdefinition_api_ValueTableCellConfig":
        return self._config


scout_chartdefinition_api_ValueTableCell.__name__ = "ValueTableCell"
scout_chartdefinition_api_ValueTableCell.__qualname__ = "ValueTableCell"
scout_chartdefinition_api_ValueTableCell.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableCellConfig(ConjureUnionType):
    _numeric: Optional["scout_chartdefinition_api_NumericCellConfig"] = None
    _enum: Optional["scout_chartdefinition_api_EnumCellConfig"] = None
    _range: Optional["scout_chartdefinition_api_RangeCellConfig"] = None
    _bit_flag_map: Optional["scout_chartdefinition_api_BitFlagMapCellConfig"] = None
    _staleness: Optional["scout_chartdefinition_api_StalenessCellConfig"] = None
    _numeric_array: Optional["scout_chartdefinition_api_NumericArrayCellConfig"] = None
    _enum_array: Optional["scout_chartdefinition_api_EnumArrayCellConfig"] = None
    _struct: Optional["scout_chartdefinition_api_StructCellConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_chartdefinition_api_NumericCellConfig),
            'enum': ConjureFieldDefinition('enum', scout_chartdefinition_api_EnumCellConfig),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_RangeCellConfig),
            'bit_flag_map': ConjureFieldDefinition('bitFlagMap', scout_chartdefinition_api_BitFlagMapCellConfig),
            'staleness': ConjureFieldDefinition('staleness', scout_chartdefinition_api_StalenessCellConfig),
            'numeric_array': ConjureFieldDefinition('numericArray', scout_chartdefinition_api_NumericArrayCellConfig),
            'enum_array': ConjureFieldDefinition('enumArray', scout_chartdefinition_api_EnumArrayCellConfig),
            'struct': ConjureFieldDefinition('struct', scout_chartdefinition_api_StructCellConfig)
        }

    def __init__(
            self,
            numeric: Optional["scout_chartdefinition_api_NumericCellConfig"] = None,
            enum: Optional["scout_chartdefinition_api_EnumCellConfig"] = None,
            range: Optional["scout_chartdefinition_api_RangeCellConfig"] = None,
            bit_flag_map: Optional["scout_chartdefinition_api_BitFlagMapCellConfig"] = None,
            staleness: Optional["scout_chartdefinition_api_StalenessCellConfig"] = None,
            numeric_array: Optional["scout_chartdefinition_api_NumericArrayCellConfig"] = None,
            enum_array: Optional["scout_chartdefinition_api_EnumArrayCellConfig"] = None,
            struct: Optional["scout_chartdefinition_api_StructCellConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) + (range is not None) + (bit_flag_map is not None) + (staleness is not None) + (numeric_array is not None) + (enum_array is not None) + (struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if range is not None:
                self._range = range
                self._type = 'range'
            if bit_flag_map is not None:
                self._bit_flag_map = bit_flag_map
                self._type = 'bitFlagMap'
            if staleness is not None:
                self._staleness = staleness
                self._type = 'staleness'
            if numeric_array is not None:
                self._numeric_array = numeric_array
                self._type = 'numericArray'
            if enum_array is not None:
                self._enum_array = enum_array
                self._type = 'enumArray'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'
        elif type_of_union == 'bitFlagMap':
            if bit_flag_map is None:
                raise ValueError('a union value must not be None')
            self._bit_flag_map = bit_flag_map
            self._type = 'bitFlagMap'
        elif type_of_union == 'staleness':
            if staleness is None:
                raise ValueError('a union value must not be None')
            self._staleness = staleness
            self._type = 'staleness'
        elif type_of_union == 'numericArray':
            if numeric_array is None:
                raise ValueError('a union value must not be None')
            self._numeric_array = numeric_array
            self._type = 'numericArray'
        elif type_of_union == 'enumArray':
            if enum_array is None:
                raise ValueError('a union value must not be None')
            self._enum_array = enum_array
            self._type = 'enumArray'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'

    @builtins.property
    def numeric(self) -> Optional["scout_chartdefinition_api_NumericCellConfig"]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_chartdefinition_api_EnumCellConfig"]:
        return self._enum

    @builtins.property
    def range(self) -> Optional["scout_chartdefinition_api_RangeCellConfig"]:
        return self._range

    @builtins.property
    def bit_flag_map(self) -> Optional["scout_chartdefinition_api_BitFlagMapCellConfig"]:
        return self._bit_flag_map

    @builtins.property
    def staleness(self) -> Optional["scout_chartdefinition_api_StalenessCellConfig"]:
        return self._staleness

    @builtins.property
    def numeric_array(self) -> Optional["scout_chartdefinition_api_NumericArrayCellConfig"]:
        return self._numeric_array

    @builtins.property
    def enum_array(self) -> Optional["scout_chartdefinition_api_EnumArrayCellConfig"]:
        return self._enum_array

    @builtins.property
    def struct(self) -> Optional["scout_chartdefinition_api_StructCellConfig"]:
        return self._struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableCellConfigVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableCellConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)
        if self._type == 'bitFlagMap' and self.bit_flag_map is not None:
            return visitor._bit_flag_map(self.bit_flag_map)
        if self._type == 'staleness' and self.staleness is not None:
            return visitor._staleness(self.staleness)
        if self._type == 'numericArray' and self.numeric_array is not None:
            return visitor._numeric_array(self.numeric_array)
        if self._type == 'enumArray' and self.enum_array is not None:
            return visitor._enum_array(self.enum_array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)


scout_chartdefinition_api_ValueTableCellConfig.__name__ = "ValueTableCellConfig"
scout_chartdefinition_api_ValueTableCellConfig.__qualname__ = "ValueTableCellConfig"
scout_chartdefinition_api_ValueTableCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableCellConfigVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_chartdefinition_api_NumericCellConfig") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_chartdefinition_api_EnumCellConfig") -> Any:
        pass

    @abstractmethod
    def _range(self, range: "scout_chartdefinition_api_RangeCellConfig") -> Any:
        pass

    @abstractmethod
    def _bit_flag_map(self, bit_flag_map: "scout_chartdefinition_api_BitFlagMapCellConfig") -> Any:
        pass

    @abstractmethod
    def _staleness(self, staleness: "scout_chartdefinition_api_StalenessCellConfig") -> Any:
        pass

    @abstractmethod
    def _numeric_array(self, numeric_array: "scout_chartdefinition_api_NumericArrayCellConfig") -> Any:
        pass

    @abstractmethod
    def _enum_array(self, enum_array: "scout_chartdefinition_api_EnumArrayCellConfig") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: "scout_chartdefinition_api_StructCellConfig") -> Any:
        pass


scout_chartdefinition_api_ValueTableCellConfigVisitor.__name__ = "ValueTableCellConfigVisitor"
scout_chartdefinition_api_ValueTableCellConfigVisitor.__qualname__ = "ValueTableCellConfigVisitor"
scout_chartdefinition_api_ValueTableCellConfigVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableChannel(ConjureUnionType):
    _numeric: Optional["scout_chartdefinition_api_NumericValueChannel"] = None
    _enum: Optional["scout_chartdefinition_api_EnumValueChannel"] = None
    _range: Optional["scout_chartdefinition_api_RangeValueChannel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_chartdefinition_api_NumericValueChannel),
            'enum': ConjureFieldDefinition('enum', scout_chartdefinition_api_EnumValueChannel),
            'range': ConjureFieldDefinition('range', scout_chartdefinition_api_RangeValueChannel)
        }

    def __init__(
            self,
            numeric: Optional["scout_chartdefinition_api_NumericValueChannel"] = None,
            enum: Optional["scout_chartdefinition_api_EnumValueChannel"] = None,
            range: Optional["scout_chartdefinition_api_RangeValueChannel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) + (range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if range is not None:
                self._range = range
                self._type = 'range'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'

    @builtins.property
    def numeric(self) -> Optional["scout_chartdefinition_api_NumericValueChannel"]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_chartdefinition_api_EnumValueChannel"]:
        return self._enum

    @builtins.property
    def range(self) -> Optional["scout_chartdefinition_api_RangeValueChannel"]:
        return self._range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableChannelVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableChannelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)


scout_chartdefinition_api_ValueTableChannel.__name__ = "ValueTableChannel"
scout_chartdefinition_api_ValueTableChannel.__qualname__ = "ValueTableChannel"
scout_chartdefinition_api_ValueTableChannel.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableChannelVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_chartdefinition_api_NumericValueChannel") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_chartdefinition_api_EnumValueChannel") -> Any:
        pass

    @abstractmethod
    def _range(self, range: "scout_chartdefinition_api_RangeValueChannel") -> Any:
        pass


scout_chartdefinition_api_ValueTableChannelVisitor.__name__ = "ValueTableChannelVisitor"
scout_chartdefinition_api_ValueTableChannelVisitor.__qualname__ = "ValueTableChannelVisitor"
scout_chartdefinition_api_ValueTableChannelVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_ValueTableDefinitionV1"] = None
    _v2: Optional["scout_chartdefinition_api_ValueTableDefinitionV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_ValueTableDefinitionV1),
            'v2': ConjureFieldDefinition('v2', scout_chartdefinition_api_ValueTableDefinitionV2)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_ValueTableDefinitionV1"] = None,
            v2: Optional["scout_chartdefinition_api_ValueTableDefinitionV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) + (v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'
            if v2 is not None:
                self._v2 = v2
                self._type = 'v2'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'
        elif type_of_union == 'v2':
            if v2 is None:
                raise ValueError('a union value must not be None')
            self._v2 = v2
            self._type = 'v2'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_ValueTableDefinitionV1"]:
        return self._v1

    @builtins.property
    def v2(self) -> Optional["scout_chartdefinition_api_ValueTableDefinitionV2"]:
        return self._v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)
        if self._type == 'v2' and self.v2 is not None:
            return visitor._v2(self.v2)


scout_chartdefinition_api_ValueTableDefinition.__name__ = "ValueTableDefinition"
scout_chartdefinition_api_ValueTableDefinition.__qualname__ = "ValueTableDefinition"
scout_chartdefinition_api_ValueTableDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_ValueTableDefinitionV1") -> Any:
        pass

    @abstractmethod
    def _v2(self, v2: "scout_chartdefinition_api_ValueTableDefinitionV2") -> Any:
        pass


scout_chartdefinition_api_ValueTableDefinitionVisitor.__name__ = "ValueTableDefinitionVisitor"
scout_chartdefinition_api_ValueTableDefinitionVisitor.__qualname__ = "ValueTableDefinitionVisitor"
scout_chartdefinition_api_ValueTableDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'channels': ConjureFieldDefinition('channels', List[scout_chartdefinition_api_ValueTableChannel])
        }

    __slots__: List[str] = ['_title', '_channels']

    def __init__(self, channels: List["scout_chartdefinition_api_ValueTableChannel"], title: Optional[str] = None) -> None:
        self._title = title
        self._channels = channels

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def channels(self) -> List["scout_chartdefinition_api_ValueTableChannel"]:
        """Each channel to be displayed. Based on the data type, the visualisation
options and settings will be different.
        """
        return self._channels


scout_chartdefinition_api_ValueTableDefinitionV1.__name__ = "ValueTableDefinitionV1"
scout_chartdefinition_api_ValueTableDefinitionV1.__qualname__ = "ValueTableDefinitionV1"
scout_chartdefinition_api_ValueTableDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableDefinitionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'show_units': ConjureFieldDefinition('showUnits', OptionalTypeWrapper[bool]),
            'show_staleness_indicator': ConjureFieldDefinition('showStalenessIndicator', OptionalTypeWrapper[bool]),
            'layout': ConjureFieldDefinition('layout', scout_chartdefinition_api_ValueTableLayout),
            'staleness_indicator': ConjureFieldDefinition('stalenessIndicator', OptionalTypeWrapper[scout_chartdefinition_api_ValueTableStalenessConfig])
        }

    __slots__: List[str] = ['_title', '_show_units', '_show_staleness_indicator', '_layout', '_staleness_indicator']

    def __init__(self, layout: "scout_chartdefinition_api_ValueTableLayout", show_staleness_indicator: Optional[bool] = None, show_units: Optional[bool] = None, staleness_indicator: Optional["scout_chartdefinition_api_ValueTableStalenessConfig"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._show_units = show_units
        self._show_staleness_indicator = show_staleness_indicator
        self._layout = layout
        self._staleness_indicator = staleness_indicator

    @builtins.property
    def title(self) -> Optional[str]:
        """The display title of the panel.
        """
        return self._title

    @builtins.property
    def show_units(self) -> Optional[bool]:
        """If true, display units in the cells when available.
        """
        return self._show_units

    @builtins.property
    def show_staleness_indicator(self) -> Optional[bool]:
        """If true, display staleness indicator in the cells when available.
        """
        return self._show_staleness_indicator

    @builtins.property
    def layout(self) -> "scout_chartdefinition_api_ValueTableLayout":
        return self._layout

    @builtins.property
    def staleness_indicator(self) -> Optional["scout_chartdefinition_api_ValueTableStalenessConfig"]:
        """Configuration for showing staleness of values in the value table while streaming.
        """
        return self._staleness_indicator


scout_chartdefinition_api_ValueTableDefinitionV2.__name__ = "ValueTableDefinitionV2"
scout_chartdefinition_api_ValueTableDefinitionV2.__qualname__ = "ValueTableDefinitionV2"
scout_chartdefinition_api_ValueTableDefinitionV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableGridRowColumnConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'position': ConjureFieldDefinition('position', int),
            'header': ConjureFieldDefinition('header', OptionalTypeWrapper[str]),
            'cell_config': ConjureFieldDefinition('cellConfig', OptionalTypeWrapper[scout_chartdefinition_api_ValueTableMultiCellConfig])
        }

    __slots__: List[str] = ['_position', '_header', '_cell_config']

    def __init__(self, position: int, cell_config: Optional["scout_chartdefinition_api_ValueTableMultiCellConfig"] = None, header: Optional[str] = None) -> None:
        self._position = position
        self._header = header
        self._cell_config = cell_config

    @builtins.property
    def position(self) -> int:
        """The index of the row or column to apply this configuration to.
        """
        return self._position

    @builtins.property
    def header(self) -> Optional[str]:
        return self._header

    @builtins.property
    def cell_config(self) -> Optional["scout_chartdefinition_api_ValueTableMultiCellConfig"]:
        return self._cell_config


scout_chartdefinition_api_ValueTableGridRowColumnConfig.__name__ = "ValueTableGridRowColumnConfig"
scout_chartdefinition_api_ValueTableGridRowColumnConfig.__qualname__ = "ValueTableGridRowColumnConfig"
scout_chartdefinition_api_ValueTableGridRowColumnConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableGridValueTableCell(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'row': ConjureFieldDefinition('row', int),
            'column': ConjureFieldDefinition('column', int),
            'cell': ConjureFieldDefinition('cell', scout_chartdefinition_api_ValueTableCell)
        }

    __slots__: List[str] = ['_row', '_column', '_cell']

    def __init__(self, cell: "scout_chartdefinition_api_ValueTableCell", column: int, row: int) -> None:
        self._row = row
        self._column = column
        self._cell = cell

    @builtins.property
    def row(self) -> int:
        return self._row

    @builtins.property
    def column(self) -> int:
        return self._column

    @builtins.property
    def cell(self) -> "scout_chartdefinition_api_ValueTableCell":
        return self._cell


scout_chartdefinition_api_ValueTableGridValueTableCell.__name__ = "ValueTableGridValueTableCell"
scout_chartdefinition_api_ValueTableGridValueTableCell.__qualname__ = "ValueTableGridValueTableCell"
scout_chartdefinition_api_ValueTableGridValueTableCell.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableLayout(ConjureUnionType):
    _grid: Optional["scout_chartdefinition_api_ValueTableLayoutGrid"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'grid': ConjureFieldDefinition('grid', scout_chartdefinition_api_ValueTableLayoutGrid)
        }

    def __init__(
            self,
            grid: Optional["scout_chartdefinition_api_ValueTableLayoutGrid"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (grid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if grid is not None:
                self._grid = grid
                self._type = 'grid'

        elif type_of_union == 'grid':
            if grid is None:
                raise ValueError('a union value must not be None')
            self._grid = grid
            self._type = 'grid'

    @builtins.property
    def grid(self) -> Optional["scout_chartdefinition_api_ValueTableLayoutGrid"]:
        return self._grid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueTableLayoutVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueTableLayoutVisitor'.format(visitor.__class__.__name__))
        if self._type == 'grid' and self.grid is not None:
            return visitor._grid(self.grid)


scout_chartdefinition_api_ValueTableLayout.__name__ = "ValueTableLayout"
scout_chartdefinition_api_ValueTableLayout.__qualname__ = "ValueTableLayout"
scout_chartdefinition_api_ValueTableLayout.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableLayoutVisitor:

    @abstractmethod
    def _grid(self, grid: "scout_chartdefinition_api_ValueTableLayoutGrid") -> Any:
        pass


scout_chartdefinition_api_ValueTableLayoutVisitor.__name__ = "ValueTableLayoutVisitor"
scout_chartdefinition_api_ValueTableLayoutVisitor.__qualname__ = "ValueTableLayoutVisitor"
scout_chartdefinition_api_ValueTableLayoutVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableLayoutGrid(ConjureBeanType):
    """A 2D grid layout for the value table where cells are laid out in specific
rows and columns. Supports hierarchical cell visualisation configurations, favoring when present:
the cell's own definition, then the column's, then the row's, then the panel's.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'show_row_headers': ConjureFieldDefinition('showRowHeaders', OptionalTypeWrapper[bool]),
            'show_column_headers': ConjureFieldDefinition('showColumnHeaders', OptionalTypeWrapper[bool]),
            'show_cell_labels': ConjureFieldDefinition('showCellLabels', OptionalTypeWrapper[bool]),
            'grid_default_cell_configs': ConjureFieldDefinition('gridDefaultCellConfigs', scout_chartdefinition_api_ValueTableMultiCellConfig),
            'column_configs': ConjureFieldDefinition('columnConfigs', List[scout_chartdefinition_api_ValueTableGridRowColumnConfig]),
            'row_configs': ConjureFieldDefinition('rowConfigs', List[scout_chartdefinition_api_ValueTableGridRowColumnConfig]),
            'row_count': ConjureFieldDefinition('rowCount', int),
            'column_count': ConjureFieldDefinition('columnCount', int),
            'cells': ConjureFieldDefinition('cells', List[scout_chartdefinition_api_ValueTableGridValueTableCell])
        }

    __slots__: List[str] = ['_show_row_headers', '_show_column_headers', '_show_cell_labels', '_grid_default_cell_configs', '_column_configs', '_row_configs', '_row_count', '_column_count', '_cells']

    def __init__(self, cells: List["scout_chartdefinition_api_ValueTableGridValueTableCell"], column_configs: List["scout_chartdefinition_api_ValueTableGridRowColumnConfig"], column_count: int, grid_default_cell_configs: "scout_chartdefinition_api_ValueTableMultiCellConfig", row_configs: List["scout_chartdefinition_api_ValueTableGridRowColumnConfig"], row_count: int, show_cell_labels: Optional[bool] = None, show_column_headers: Optional[bool] = None, show_row_headers: Optional[bool] = None) -> None:
        self._show_row_headers = show_row_headers
        self._show_column_headers = show_column_headers
        self._show_cell_labels = show_cell_labels
        self._grid_default_cell_configs = grid_default_cell_configs
        self._column_configs = column_configs
        self._row_configs = row_configs
        self._row_count = row_count
        self._column_count = column_count
        self._cells = cells

    @builtins.property
    def show_row_headers(self) -> Optional[bool]:
        """If true, display row headers.
        """
        return self._show_row_headers

    @builtins.property
    def show_column_headers(self) -> Optional[bool]:
        """If true, display column headers.
        """
        return self._show_column_headers

    @builtins.property
    def show_cell_labels(self) -> Optional[bool]:
        """If true, display channel names in the cells.
        """
        return self._show_cell_labels

    @builtins.property
    def grid_default_cell_configs(self) -> "scout_chartdefinition_api_ValueTableMultiCellConfig":
        """Panel-level defaults for cell visualisations
        """
        return self._grid_default_cell_configs

    @builtins.property
    def column_configs(self) -> List["scout_chartdefinition_api_ValueTableGridRowColumnConfig"]:
        """Column-level configurations.
        """
        return self._column_configs

    @builtins.property
    def row_configs(self) -> List["scout_chartdefinition_api_ValueTableGridRowColumnConfig"]:
        """Row-level configurations.
        """
        return self._row_configs

    @builtins.property
    def row_count(self) -> int:
        return self._row_count

    @builtins.property
    def column_count(self) -> int:
        return self._column_count

    @builtins.property
    def cells(self) -> List["scout_chartdefinition_api_ValueTableGridValueTableCell"]:
        """An array of cells to display in the table.
        """
        return self._cells


scout_chartdefinition_api_ValueTableLayoutGrid.__name__ = "ValueTableLayoutGrid"
scout_chartdefinition_api_ValueTableLayoutGrid.__qualname__ = "ValueTableLayoutGrid"
scout_chartdefinition_api_ValueTableLayoutGrid.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableMultiCellConfig(ConjureBeanType):
    """Configurations for each type of cell in a grouping of heterogenous cells, such as
for a row, for a column, or for the entire grid.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range': ConjureFieldDefinition('range', OptionalTypeWrapper[scout_chartdefinition_api_RangeCellConfig]),
            'enum': ConjureFieldDefinition('enum', OptionalTypeWrapper[scout_chartdefinition_api_EnumCellConfig]),
            'numeric': ConjureFieldDefinition('numeric', OptionalTypeWrapper[scout_chartdefinition_api_NumericCellConfig]),
            'staleness': ConjureFieldDefinition('staleness', OptionalTypeWrapper[scout_chartdefinition_api_StalenessCellConfig]),
            'numeric_array': ConjureFieldDefinition('numericArray', OptionalTypeWrapper[scout_chartdefinition_api_NumericArrayCellConfig]),
            'enum_array': ConjureFieldDefinition('enumArray', OptionalTypeWrapper[scout_chartdefinition_api_EnumArrayCellConfig]),
            'struct': ConjureFieldDefinition('struct', OptionalTypeWrapper[scout_chartdefinition_api_StructCellConfig])
        }

    __slots__: List[str] = ['_range', '_enum', '_numeric', '_staleness', '_numeric_array', '_enum_array', '_struct']

    def __init__(self, enum: Optional["scout_chartdefinition_api_EnumCellConfig"] = None, enum_array: Optional["scout_chartdefinition_api_EnumArrayCellConfig"] = None, numeric: Optional["scout_chartdefinition_api_NumericCellConfig"] = None, numeric_array: Optional["scout_chartdefinition_api_NumericArrayCellConfig"] = None, range: Optional["scout_chartdefinition_api_RangeCellConfig"] = None, staleness: Optional["scout_chartdefinition_api_StalenessCellConfig"] = None, struct: Optional["scout_chartdefinition_api_StructCellConfig"] = None) -> None:
        self._range = range
        self._enum = enum
        self._numeric = numeric
        self._staleness = staleness
        self._numeric_array = numeric_array
        self._enum_array = enum_array
        self._struct = struct

    @builtins.property
    def range(self) -> Optional["scout_chartdefinition_api_RangeCellConfig"]:
        return self._range

    @builtins.property
    def enum(self) -> Optional["scout_chartdefinition_api_EnumCellConfig"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_chartdefinition_api_NumericCellConfig"]:
        return self._numeric

    @builtins.property
    def staleness(self) -> Optional["scout_chartdefinition_api_StalenessCellConfig"]:
        return self._staleness

    @builtins.property
    def numeric_array(self) -> Optional["scout_chartdefinition_api_NumericArrayCellConfig"]:
        return self._numeric_array

    @builtins.property
    def enum_array(self) -> Optional["scout_chartdefinition_api_EnumArrayCellConfig"]:
        return self._enum_array

    @builtins.property
    def struct(self) -> Optional["scout_chartdefinition_api_StructCellConfig"]:
        return self._struct


scout_chartdefinition_api_ValueTableMultiCellConfig.__name__ = "ValueTableMultiCellConfig"
scout_chartdefinition_api_ValueTableMultiCellConfig.__qualname__ = "ValueTableMultiCellConfig"
scout_chartdefinition_api_ValueTableMultiCellConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueTableStalenessConfig(ConjureBeanType):
    """Configuration for showing staleness of values while streaming
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'hide_staleness': ConjureFieldDefinition('hideStaleness', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_hide_staleness']

    def __init__(self, hide_staleness: Optional[bool] = None) -> None:
        self._hide_staleness = hide_staleness

    @builtins.property
    def hide_staleness(self) -> Optional[bool]:
        """If true, will not show any indication of staleness. Defaults to false
        """
        return self._hide_staleness


scout_chartdefinition_api_ValueTableStalenessConfig.__name__ = "ValueTableStalenessConfig"
scout_chartdefinition_api_ValueTableStalenessConfig.__qualname__ = "ValueTableStalenessConfig"
scout_chartdefinition_api_ValueTableStalenessConfig.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueToColorMap(ConjureUnionType):
    """Specifies an assignment of colors across several values.
    """
    _numeric: Optional[Dict[str, float]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', Dict[scout_api_HexColor, float])
        }

    def __init__(
            self,
            numeric: Optional[Dict[str, float]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def numeric(self) -> Optional[Dict[str, float]]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_ValueToColorMapVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_ValueToColorMapVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_chartdefinition_api_ValueToColorMap.__name__ = "ValueToColorMap"
scout_chartdefinition_api_ValueToColorMap.__qualname__ = "ValueToColorMap"
scout_chartdefinition_api_ValueToColorMap.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_ValueToColorMapVisitor:

    @abstractmethod
    def _numeric(self, numeric: Dict[str, float]) -> Any:
        pass


scout_chartdefinition_api_ValueToColorMapVisitor.__name__ = "ValueToColorMapVisitor"
scout_chartdefinition_api_ValueToColorMapVisitor.__qualname__ = "ValueToColorMapVisitor"
scout_chartdefinition_api_ValueToColorMapVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoPanelDataSource(ConjureBeanType):
    """Enhanced video panel data source to be compatible with multiple assets
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'ref_name': ConjureFieldDefinition('refName', scout_chartdefinition_api_DataSourceRefName)
        }

    __slots__: List[str] = ['_run_rid', '_asset_rid', '_ref_name']

    def __init__(self, asset_rid: str, ref_name: str, run_rid: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._asset_rid = asset_rid
        self._ref_name = ref_name

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def ref_name(self) -> str:
        return self._ref_name


scout_chartdefinition_api_VideoPanelDataSource.__name__ = "VideoPanelDataSource"
scout_chartdefinition_api_VideoPanelDataSource.__qualname__ = "VideoPanelDataSource"
scout_chartdefinition_api_VideoPanelDataSource.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinition(ConjureUnionType):
    _v1: Optional["scout_chartdefinition_api_VideoVizDefinitionV1"] = None
    _v2: Optional["scout_chartdefinition_api_VideoVizDefinitionV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_chartdefinition_api_VideoVizDefinitionV1),
            'v2': ConjureFieldDefinition('v2', scout_chartdefinition_api_VideoVizDefinitionV2)
        }

    def __init__(
            self,
            v1: Optional["scout_chartdefinition_api_VideoVizDefinitionV1"] = None,
            v2: Optional["scout_chartdefinition_api_VideoVizDefinitionV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) + (v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'
            if v2 is not None:
                self._v2 = v2
                self._type = 'v2'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'
        elif type_of_union == 'v2':
            if v2 is None:
                raise ValueError('a union value must not be None')
            self._v2 = v2
            self._type = 'v2'

    @builtins.property
    def v1(self) -> Optional["scout_chartdefinition_api_VideoVizDefinitionV1"]:
        return self._v1

    @builtins.property
    def v2(self) -> Optional["scout_chartdefinition_api_VideoVizDefinitionV2"]:
        return self._v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_VideoVizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_VideoVizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)
        if self._type == 'v2' and self.v2 is not None:
            return visitor._v2(self.v2)


scout_chartdefinition_api_VideoVizDefinition.__name__ = "VideoVizDefinition"
scout_chartdefinition_api_VideoVizDefinition.__qualname__ = "VideoVizDefinition"
scout_chartdefinition_api_VideoVizDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_chartdefinition_api_VideoVizDefinitionV1") -> Any:
        pass

    @abstractmethod
    def _v2(self, v2: "scout_chartdefinition_api_VideoVizDefinitionV2") -> Any:
        pass


scout_chartdefinition_api_VideoVizDefinitionVisitor.__name__ = "VideoVizDefinitionVisitor"
scout_chartdefinition_api_VideoVizDefinitionVisitor.__qualname__ = "VideoVizDefinitionVisitor"
scout_chartdefinition_api_VideoVizDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'events': ConjureFieldDefinition('events', OptionalTypeWrapper[List[scout_chartdefinition_api_Event]]),
            'comparison_run_groups': ConjureFieldDefinition('comparisonRunGroups', List[scout_comparisonrun_api_ComparisonRunGroup]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'ref_name': ConjureFieldDefinition('refName', OptionalTypeWrapper[scout_chartdefinition_api_DataSourceRefName]),
            'datasource': ConjureFieldDefinition('datasource', OptionalTypeWrapper[scout_chartdefinition_api_VideoPanelDataSource])
        }

    __slots__: List[str] = ['_events', '_comparison_run_groups', '_title', '_ref_name', '_datasource']

    def __init__(self, comparison_run_groups: List["scout_comparisonrun_api_ComparisonRunGroup"], datasource: Optional["scout_chartdefinition_api_VideoPanelDataSource"] = None, events: Optional[List["scout_chartdefinition_api_Event"]] = None, ref_name: Optional[str] = None, title: Optional[str] = None) -> None:
        self._events = events
        self._comparison_run_groups = comparison_run_groups
        self._title = title
        self._ref_name = ref_name
        self._datasource = datasource

    @builtins.property
    def events(self) -> Optional[List["scout_chartdefinition_api_Event"]]:
        return self._events

    @builtins.property
    def comparison_run_groups(self) -> List["scout_comparisonrun_api_ComparisonRunGroup"]:
        return self._comparison_run_groups

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def ref_name(self) -> Optional[str]:
        return self._ref_name

    @builtins.property
    def datasource(self) -> Optional["scout_chartdefinition_api_VideoPanelDataSource"]:
        return self._datasource


scout_chartdefinition_api_VideoVizDefinitionV1.__name__ = "VideoVizDefinitionV1"
scout_chartdefinition_api_VideoVizDefinitionV1.__qualname__ = "VideoVizDefinitionV1"
scout_chartdefinition_api_VideoVizDefinitionV1.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VideoVizDefinitionV2(ConjureBeanType):
    """Stores a video as a channel locator rather than the deprecated video datasource rid.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'channel': ConjureFieldDefinition('channel', scout_api_ChannelLocator)
        }

    __slots__: List[str] = ['_title', '_channel']

    def __init__(self, channel: "scout_api_ChannelLocator", title: Optional[str] = None) -> None:
        self._title = title
        self._channel = channel

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def channel(self) -> "scout_api_ChannelLocator":
        return self._channel


scout_chartdefinition_api_VideoVizDefinitionV2.__name__ = "VideoVizDefinitionV2"
scout_chartdefinition_api_VideoVizDefinitionV2.__qualname__ = "VideoVizDefinitionV2"
scout_chartdefinition_api_VideoVizDefinitionV2.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VizDefinition(ConjureUnionType):
    _cartesian: Optional["scout_chartdefinition_api_CartesianChartDefinition"] = None
    _checklist: Optional["scout_chartdefinition_api_ChecklistChartDefinition"] = None
    _frequency: Optional["scout_chartdefinition_api_FrequencyChartDefinition"] = None
    _geo: Optional["scout_chartdefinition_api_GeoVizDefinition"] = None
    _geo3d: Optional["scout_chartdefinition_api_Geo3dDefinition"] = None
    _histogram: Optional["scout_chartdefinition_api_HistogramChartDefinition"] = None
    _log: Optional["scout_chartdefinition_api_LogPanelDefinition"] = None
    _plotly: Optional["scout_chartdefinition_api_PlotlyPanelDefinition"] = None
    _time_series: Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"] = None
    _value_table: Optional["scout_chartdefinition_api_ValueTableDefinition"] = None
    _video: Optional["scout_chartdefinition_api_VideoVizDefinition"] = None
    _procedure: Optional["scout_chartdefinition_api_ProcedureVizDefinition"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cartesian': ConjureFieldDefinition('cartesian', scout_chartdefinition_api_CartesianChartDefinition),
            'checklist': ConjureFieldDefinition('checklist', scout_chartdefinition_api_ChecklistChartDefinition),
            'frequency': ConjureFieldDefinition('frequency', scout_chartdefinition_api_FrequencyChartDefinition),
            'geo': ConjureFieldDefinition('geo', scout_chartdefinition_api_GeoVizDefinition),
            'geo3d': ConjureFieldDefinition('geo3d', scout_chartdefinition_api_Geo3dDefinition),
            'histogram': ConjureFieldDefinition('histogram', scout_chartdefinition_api_HistogramChartDefinition),
            'log': ConjureFieldDefinition('log', scout_chartdefinition_api_LogPanelDefinition),
            'plotly': ConjureFieldDefinition('plotly', scout_chartdefinition_api_PlotlyPanelDefinition),
            'time_series': ConjureFieldDefinition('timeSeries', scout_chartdefinition_api_TimeSeriesChartDefinition),
            'value_table': ConjureFieldDefinition('valueTable', scout_chartdefinition_api_ValueTableDefinition),
            'video': ConjureFieldDefinition('video', scout_chartdefinition_api_VideoVizDefinition),
            'procedure': ConjureFieldDefinition('procedure', scout_chartdefinition_api_ProcedureVizDefinition)
        }

    def __init__(
            self,
            cartesian: Optional["scout_chartdefinition_api_CartesianChartDefinition"] = None,
            checklist: Optional["scout_chartdefinition_api_ChecklistChartDefinition"] = None,
            frequency: Optional["scout_chartdefinition_api_FrequencyChartDefinition"] = None,
            geo: Optional["scout_chartdefinition_api_GeoVizDefinition"] = None,
            geo3d: Optional["scout_chartdefinition_api_Geo3dDefinition"] = None,
            histogram: Optional["scout_chartdefinition_api_HistogramChartDefinition"] = None,
            log: Optional["scout_chartdefinition_api_LogPanelDefinition"] = None,
            plotly: Optional["scout_chartdefinition_api_PlotlyPanelDefinition"] = None,
            time_series: Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"] = None,
            value_table: Optional["scout_chartdefinition_api_ValueTableDefinition"] = None,
            video: Optional["scout_chartdefinition_api_VideoVizDefinition"] = None,
            procedure: Optional["scout_chartdefinition_api_ProcedureVizDefinition"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (cartesian is not None) + (checklist is not None) + (frequency is not None) + (geo is not None) + (geo3d is not None) + (histogram is not None) + (log is not None) + (plotly is not None) + (time_series is not None) + (value_table is not None) + (video is not None) + (procedure is not None) != 1:
                raise ValueError('a union must contain a single member')

            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if checklist is not None:
                self._checklist = checklist
                self._type = 'checklist'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if geo is not None:
                self._geo = geo
                self._type = 'geo'
            if geo3d is not None:
                self._geo3d = geo3d
                self._type = 'geo3d'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if log is not None:
                self._log = log
                self._type = 'log'
            if plotly is not None:
                self._plotly = plotly
                self._type = 'plotly'
            if time_series is not None:
                self._time_series = time_series
                self._type = 'timeSeries'
            if value_table is not None:
                self._value_table = value_table
                self._type = 'valueTable'
            if video is not None:
                self._video = video
                self._type = 'video'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'

        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'checklist':
            if checklist is None:
                raise ValueError('a union value must not be None')
            self._checklist = checklist
            self._type = 'checklist'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'geo':
            if geo is None:
                raise ValueError('a union value must not be None')
            self._geo = geo
            self._type = 'geo'
        elif type_of_union == 'geo3d':
            if geo3d is None:
                raise ValueError('a union value must not be None')
            self._geo3d = geo3d
            self._type = 'geo3d'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'log':
            if log is None:
                raise ValueError('a union value must not be None')
            self._log = log
            self._type = 'log'
        elif type_of_union == 'plotly':
            if plotly is None:
                raise ValueError('a union value must not be None')
            self._plotly = plotly
            self._type = 'plotly'
        elif type_of_union == 'timeSeries':
            if time_series is None:
                raise ValueError('a union value must not be None')
            self._time_series = time_series
            self._type = 'timeSeries'
        elif type_of_union == 'valueTable':
            if value_table is None:
                raise ValueError('a union value must not be None')
            self._value_table = value_table
            self._type = 'valueTable'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'

    @builtins.property
    def cartesian(self) -> Optional["scout_chartdefinition_api_CartesianChartDefinition"]:
        return self._cartesian

    @builtins.property
    def checklist(self) -> Optional["scout_chartdefinition_api_ChecklistChartDefinition"]:
        return self._checklist

    @builtins.property
    def frequency(self) -> Optional["scout_chartdefinition_api_FrequencyChartDefinition"]:
        return self._frequency

    @builtins.property
    def geo(self) -> Optional["scout_chartdefinition_api_GeoVizDefinition"]:
        return self._geo

    @builtins.property
    def geo3d(self) -> Optional["scout_chartdefinition_api_Geo3dDefinition"]:
        return self._geo3d

    @builtins.property
    def histogram(self) -> Optional["scout_chartdefinition_api_HistogramChartDefinition"]:
        return self._histogram

    @builtins.property
    def log(self) -> Optional["scout_chartdefinition_api_LogPanelDefinition"]:
        return self._log

    @builtins.property
    def plotly(self) -> Optional["scout_chartdefinition_api_PlotlyPanelDefinition"]:
        return self._plotly

    @builtins.property
    def time_series(self) -> Optional["scout_chartdefinition_api_TimeSeriesChartDefinition"]:
        return self._time_series

    @builtins.property
    def value_table(self) -> Optional["scout_chartdefinition_api_ValueTableDefinition"]:
        return self._value_table

    @builtins.property
    def video(self) -> Optional["scout_chartdefinition_api_VideoVizDefinition"]:
        return self._video

    @builtins.property
    def procedure(self) -> Optional["scout_chartdefinition_api_ProcedureVizDefinition"]:
        return self._procedure

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_chartdefinition_api_VizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_chartdefinition_api_VizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'checklist' and self.checklist is not None:
            return visitor._checklist(self.checklist)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'geo' and self.geo is not None:
            return visitor._geo(self.geo)
        if self._type == 'geo3d' and self.geo3d is not None:
            return visitor._geo3d(self.geo3d)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'log' and self.log is not None:
            return visitor._log(self.log)
        if self._type == 'plotly' and self.plotly is not None:
            return visitor._plotly(self.plotly)
        if self._type == 'timeSeries' and self.time_series is not None:
            return visitor._time_series(self.time_series)
        if self._type == 'valueTable' and self.value_table is not None:
            return visitor._value_table(self.value_table)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)


scout_chartdefinition_api_VizDefinition.__name__ = "VizDefinition"
scout_chartdefinition_api_VizDefinition.__qualname__ = "VizDefinition"
scout_chartdefinition_api_VizDefinition.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_chartdefinition_api_VizDefinitionVisitor:

    @abstractmethod
    def _cartesian(self, cartesian: "scout_chartdefinition_api_CartesianChartDefinition") -> Any:
        pass

    @abstractmethod
    def _checklist(self, checklist: "scout_chartdefinition_api_ChecklistChartDefinition") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_chartdefinition_api_FrequencyChartDefinition") -> Any:
        pass

    @abstractmethod
    def _geo(self, geo: "scout_chartdefinition_api_GeoVizDefinition") -> Any:
        pass

    @abstractmethod
    def _geo3d(self, geo3d: "scout_chartdefinition_api_Geo3dDefinition") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_chartdefinition_api_HistogramChartDefinition") -> Any:
        pass

    @abstractmethod
    def _log(self, log: "scout_chartdefinition_api_LogPanelDefinition") -> Any:
        pass

    @abstractmethod
    def _plotly(self, plotly: "scout_chartdefinition_api_PlotlyPanelDefinition") -> Any:
        pass

    @abstractmethod
    def _time_series(self, time_series: "scout_chartdefinition_api_TimeSeriesChartDefinition") -> Any:
        pass

    @abstractmethod
    def _value_table(self, value_table: "scout_chartdefinition_api_ValueTableDefinition") -> Any:
        pass

    @abstractmethod
    def _video(self, video: "scout_chartdefinition_api_VideoVizDefinition") -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: "scout_chartdefinition_api_ProcedureVizDefinition") -> Any:
        pass


scout_chartdefinition_api_VizDefinitionVisitor.__name__ = "VizDefinitionVisitor"
scout_chartdefinition_api_VizDefinitionVisitor.__qualname__ = "VizDefinitionVisitor"
scout_chartdefinition_api_VizDefinitionVisitor.__module__ = "nominal_api.scout_chartdefinition_api"


class scout_checklistexecution_api_AssetStreamConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration]),
            'evaluation_delay': ConjureFieldDefinition('evaluationDelay', scout_run_api_Duration),
            'recovery_delay': ConjureFieldDefinition('recoveryDelay', scout_run_api_Duration),
            'auto_create_events': ConjureFieldDefinition('autoCreateEvents', bool)
        }

    __slots__: List[str] = ['_notification_configurations', '_evaluation_delay', '_recovery_delay', '_auto_create_events']

    def __init__(self, auto_create_events: bool, evaluation_delay: "scout_run_api_Duration", notification_configurations: List["scout_integrations_api_NotificationConfiguration"], recovery_delay: "scout_run_api_Duration") -> None:
        self._notification_configurations = notification_configurations
        self._evaluation_delay = evaluation_delay
        self._recovery_delay = recovery_delay
        self._auto_create_events = auto_create_events

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        return self._notification_configurations

    @builtins.property
    def evaluation_delay(self) -> "scout_run_api_Duration":
        return self._evaluation_delay

    @builtins.property
    def recovery_delay(self) -> "scout_run_api_Duration":
        return self._recovery_delay

    @builtins.property
    def auto_create_events(self) -> bool:
        return self._auto_create_events


scout_checklistexecution_api_AssetStreamConfiguration.__name__ = "AssetStreamConfiguration"
scout_checklistexecution_api_AssetStreamConfiguration.__qualname__ = "AssetStreamConfiguration"
scout_checklistexecution_api_AssetStreamConfiguration.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchChecklistLiveStatusRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_checklistexecution_api_ChecklistLiveStatusRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["scout_checklistexecution_api_ChecklistLiveStatusRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["scout_checklistexecution_api_ChecklistLiveStatusRequest"]:
        return self._requests


scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__name__ = "BatchChecklistLiveStatusRequest"
scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__qualname__ = "BatchChecklistLiveStatusRequest"
scout_checklistexecution_api_BatchChecklistLiveStatusRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchChecklistLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_live_status_responses': ConjureFieldDefinition('checklistLiveStatusResponses', List[scout_checklistexecution_api_ChecklistLiveStatusResponse])
        }

    __slots__: List[str] = ['_checklist_live_status_responses']

    def __init__(self, checklist_live_status_responses: List["scout_checklistexecution_api_ChecklistLiveStatusResponse"]) -> None:
        self._checklist_live_status_responses = checklist_live_status_responses

    @builtins.property
    def checklist_live_status_responses(self) -> List["scout_checklistexecution_api_ChecklistLiveStatusResponse"]:
        return self._checklist_live_status_responses


scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__name__ = "BatchChecklistLiveStatusResponse"
scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__qualname__ = "BatchChecklistLiveStatusResponse"
scout_checklistexecution_api_BatchChecklistLiveStatusResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchGetStreamingChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rids': ConjureFieldDefinition('checklistRids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_checklist_rids']

    def __init__(self, checklist_rids: List[str]) -> None:
        self._checklist_rids = checklist_rids

    @builtins.property
    def checklist_rids(self) -> List[str]:
        return self._checklist_rids


scout_checklistexecution_api_BatchGetStreamingChecklistRequest.__name__ = "BatchGetStreamingChecklistRequest"
scout_checklistexecution_api_BatchGetStreamingChecklistRequest.__qualname__ = "BatchGetStreamingChecklistRequest"
scout_checklistexecution_api_BatchGetStreamingChecklistRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchGetStreamingChecklistResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'streaming_checklist_infos': ConjureFieldDefinition('streamingChecklistInfos', Dict[scout_rids_api_ChecklistRid, scout_checklistexecution_api_StreamingChecklistInfo])
        }

    __slots__: List[str] = ['_streaming_checklist_infos']

    def __init__(self, streaming_checklist_infos: Dict[str, "scout_checklistexecution_api_StreamingChecklistInfo"]) -> None:
        self._streaming_checklist_infos = streaming_checklist_infos

    @builtins.property
    def streaming_checklist_infos(self) -> Dict[str, "scout_checklistexecution_api_StreamingChecklistInfo"]:
        return self._streaming_checklist_infos


scout_checklistexecution_api_BatchGetStreamingChecklistResponse.__name__ = "BatchGetStreamingChecklistResponse"
scout_checklistexecution_api_BatchGetStreamingChecklistResponse.__qualname__ = "BatchGetStreamingChecklistResponse"
scout_checklistexecution_api_BatchGetStreamingChecklistResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchValidateChecklistResolutionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_checklistexecution_api_ValidateChecklistResolutionRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["scout_checklistexecution_api_ValidateChecklistResolutionRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["scout_checklistexecution_api_ValidateChecklistResolutionRequest"]:
        return self._requests


scout_checklistexecution_api_BatchValidateChecklistResolutionRequest.__name__ = "BatchValidateChecklistResolutionRequest"
scout_checklistexecution_api_BatchValidateChecklistResolutionRequest.__qualname__ = "BatchValidateChecklistResolutionRequest"
scout_checklistexecution_api_BatchValidateChecklistResolutionRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_BatchValidateChecklistResolutionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_results': ConjureFieldDefinition('checklistResults', List[scout_checklistexecution_api_ValidateChecklistResolutionResponse])
        }

    __slots__: List[str] = ['_checklist_results']

    def __init__(self, checklist_results: List["scout_checklistexecution_api_ValidateChecklistResolutionResponse"]) -> None:
        self._checklist_results = checklist_results

    @builtins.property
    def checklist_results(self) -> List["scout_checklistexecution_api_ValidateChecklistResolutionResponse"]:
        return self._checklist_results


scout_checklistexecution_api_BatchValidateChecklistResolutionResponse.__name__ = "BatchValidateChecklistResolutionResponse"
scout_checklistexecution_api_BatchValidateChecklistResolutionResponse.__qualname__ = "BatchValidateChecklistResolutionResponse"
scout_checklistexecution_api_BatchValidateChecklistResolutionResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChannelLocatorWithStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_locator': ConjureFieldDefinition('channelLocator', scout_api_ChannelLocator),
            'resolution_status': ConjureFieldDefinition('resolutionStatus', scout_checklistexecution_api_ChannelResolutionStatus)
        }

    __slots__: List[str] = ['_channel_locator', '_resolution_status']

    def __init__(self, channel_locator: "scout_api_ChannelLocator", resolution_status: "scout_checklistexecution_api_ChannelResolutionStatus") -> None:
        self._channel_locator = channel_locator
        self._resolution_status = resolution_status

    @builtins.property
    def channel_locator(self) -> "scout_api_ChannelLocator":
        return self._channel_locator

    @builtins.property
    def resolution_status(self) -> "scout_checklistexecution_api_ChannelResolutionStatus":
        return self._resolution_status


scout_checklistexecution_api_ChannelLocatorWithStatus.__name__ = "ChannelLocatorWithStatus"
scout_checklistexecution_api_ChannelLocatorWithStatus.__qualname__ = "ChannelLocatorWithStatus"
scout_checklistexecution_api_ChannelLocatorWithStatus.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChannelResolutionStatus(ConjureEnumType):

    RESOLVED = 'RESOLVED'
    '''RESOLVED'''
    UNRESOLVED = 'UNRESOLVED'
    '''UNRESOLVED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checklistexecution_api_ChannelResolutionStatus.__name__ = "ChannelResolutionStatus"
scout_checklistexecution_api_ChannelResolutionStatus.__qualname__ = "ChannelResolutionStatus"
scout_checklistexecution_api_ChannelResolutionStatus.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_checklistexecution_api_CheckStatus),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_parameter_index': ConjureFieldDefinition('checkParameterIndex', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_status', '_check_rid', '_check_parameter_index']

    def __init__(self, check_rid: str, status: "scout_checklistexecution_api_CheckStatus", check_parameter_index: Optional[int] = None) -> None:
        self._status = status
        self._check_rid = check_rid
        self._check_parameter_index = check_parameter_index

    @builtins.property
    def status(self) -> "scout_checklistexecution_api_CheckStatus":
        return self._status

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_parameter_index(self) -> Optional[int]:
        """Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_parameter_index


scout_checklistexecution_api_CheckLiveStatusResponse.__name__ = "CheckLiveStatusResponse"
scout_checklistexecution_api_CheckLiveStatusResponse.__qualname__ = "CheckLiveStatusResponse"
scout_checklistexecution_api_CheckLiveStatusResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckStatus(ConjureUnionType):
    _pass_: Optional["scout_checklistexecution_api_Pass"] = None
    _fail: Optional["scout_checklistexecution_api_Fail"] = None
    _invalid: Optional["scout_checklistexecution_api_Invalid"] = None
    _skipped: Optional["scout_checklistexecution_api_Skipped"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pass_': ConjureFieldDefinition('pass', scout_checklistexecution_api_Pass),
            'fail': ConjureFieldDefinition('fail', scout_checklistexecution_api_Fail),
            'invalid': ConjureFieldDefinition('invalid', scout_checklistexecution_api_Invalid),
            'skipped': ConjureFieldDefinition('skipped', scout_checklistexecution_api_Skipped)
        }

    def __init__(
            self,
            pass_: Optional["scout_checklistexecution_api_Pass"] = None,
            fail: Optional["scout_checklistexecution_api_Fail"] = None,
            invalid: Optional["scout_checklistexecution_api_Invalid"] = None,
            skipped: Optional["scout_checklistexecution_api_Skipped"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pass_ is not None) + (fail is not None) + (invalid is not None) + (skipped is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pass_ is not None:
                self._pass_ = pass_
                self._type = 'pass'
            if fail is not None:
                self._fail = fail
                self._type = 'fail'
            if invalid is not None:
                self._invalid = invalid
                self._type = 'invalid'
            if skipped is not None:
                self._skipped = skipped
                self._type = 'skipped'

        elif type_of_union == 'pass':
            if pass_ is None:
                raise ValueError('a union value must not be None')
            self._pass_ = pass_
            self._type = 'pass'
        elif type_of_union == 'fail':
            if fail is None:
                raise ValueError('a union value must not be None')
            self._fail = fail
            self._type = 'fail'
        elif type_of_union == 'invalid':
            if invalid is None:
                raise ValueError('a union value must not be None')
            self._invalid = invalid
            self._type = 'invalid'
        elif type_of_union == 'skipped':
            if skipped is None:
                raise ValueError('a union value must not be None')
            self._skipped = skipped
            self._type = 'skipped'

    @builtins.property
    def pass_(self) -> Optional["scout_checklistexecution_api_Pass"]:
        """The check was evaluated and is currently in state PASS.
        """
        return self._pass_

    @builtins.property
    def fail(self) -> Optional["scout_checklistexecution_api_Fail"]:
        """The check was evaluated and is currently in state FAIL.
        """
        return self._fail

    @builtins.property
    def invalid(self) -> Optional["scout_checklistexecution_api_Invalid"]:
        """The check was evaluated and is currently in state INVALID.
This signifies that the check could not be evaluated due to an internal error or
if an overly expensive computation was attempted.
        """
        return self._invalid

    @builtins.property
    def skipped(self) -> Optional["scout_checklistexecution_api_Skipped"]:
        """The check was skipped and was not evaluated.
This typically occurs when the check performs operations that are not supported in the streaming context,
or if the required channels could not be resolved.
        """
        return self._skipped

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_CheckStatusVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_CheckStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pass' and self.pass_ is not None:
            return visitor._pass(self.pass_)
        if self._type == 'fail' and self.fail is not None:
            return visitor._fail(self.fail)
        if self._type == 'invalid' and self.invalid is not None:
            return visitor._invalid(self.invalid)
        if self._type == 'skipped' and self.skipped is not None:
            return visitor._skipped(self.skipped)


scout_checklistexecution_api_CheckStatus.__name__ = "CheckStatus"
scout_checklistexecution_api_CheckStatus.__qualname__ = "CheckStatus"
scout_checklistexecution_api_CheckStatus.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_CheckStatusVisitor:

    @abstractmethod
    def _pass(self, pass_: "scout_checklistexecution_api_Pass") -> Any:
        pass

    @abstractmethod
    def _fail(self, fail: "scout_checklistexecution_api_Fail") -> Any:
        pass

    @abstractmethod
    def _invalid(self, invalid: "scout_checklistexecution_api_Invalid") -> Any:
        pass

    @abstractmethod
    def _skipped(self, skipped: "scout_checklistexecution_api_Skipped") -> Any:
        pass


scout_checklistexecution_api_CheckStatusVisitor.__name__ = "CheckStatusVisitor"
scout_checklistexecution_api_CheckStatusVisitor.__qualname__ = "CheckStatusVisitor"
scout_checklistexecution_api_CheckStatusVisitor.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistExecutionService(Service):
    """The Checklist Execution Service checks the status of checklist executions.
    """

    def checklist_live_status(self, auth_header: str, request: "scout_checklistexecution_api_BatchChecklistLiveStatusRequest") -> "scout_checklistexecution_api_BatchChecklistLiveStatusResponse":
        """For each request, get the latest status for each check in a streaming checklist against the given asset.
Requests with more than 10,000 checklists will be rejected.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/checklist-live-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_BatchChecklistLiveStatusResponse, self._return_none_for_unknown_union_types)

    def execute_streaming_checklist(self, auth_header: str, request: "scout_checklistexecution_api_ExecuteChecklistForAssetsRequest") -> None:
        """Triggers a checklist to run continuously against assets.
If the checklist is already running for the given asset, replace the existing configuration with the one specified by the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/execute-streaming-checklist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def list_streaming_checklist(self, auth_header: str, request: "scout_checklistexecution_api_ListStreamingChecklistRequest") -> "scout_checklistexecution_api_ListStreamingChecklistResponse":
        """Lists all running streaming checklists.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/list-streaming-checklists'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_ListStreamingChecklistResponse, self._return_none_for_unknown_union_types)

    def list_streaming_checklist_for_asset(self, auth_header: str, request: "scout_checklistexecution_api_ListStreamingChecklistForAssetRequest") -> "scout_checklistexecution_api_ListStreamingChecklistForAssetResponse":
        """Retrieves all streaming checklists for a given asset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/list-streaming-checklists-for-asset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_ListStreamingChecklistForAssetResponse, self._return_none_for_unknown_union_types)

    def get_streaming_checklist(self, auth_header: str, checklist_rid: str) -> "scout_checklistexecution_api_StreamingChecklistInfo":
        """Retrieves the set of assets and their execution configurations for a streaming checklist specified by the checklistRid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/get-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_StreamingChecklistInfo, self._return_none_for_unknown_union_types)

    def batch_get_streaming_checklist(self, auth_header: str, request: "scout_checklistexecution_api_BatchGetStreamingChecklistRequest") -> "scout_checklistexecution_api_BatchGetStreamingChecklistResponse":
        """Retrieves the set of assets and their execution configurations for all streaming checklists specified by the request.
If a streaming checklist is not found, it will not be included in the response.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/get-streaming-checklists'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_BatchGetStreamingChecklistResponse, self._return_none_for_unknown_union_types)

    def stop_streaming_checklist(self, auth_header: str, checklist_rid: str) -> None:
        """Stops the execution of a streaming checklist on all assets.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/stop-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def stop_streaming_checklist_for_assets(self, auth_header: str, request: "scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest") -> None:
        """Stops the execution of a streaming checklist for a given set of assets.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/stop-streaming-checklist-for-assets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def reload_streaming_checklist(self, auth_header: str, checklist_rid: str) -> None:
        """Reloads the state of the streaming checklist for the given checklistRid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/checklist-execution/reload-streaming-checklist/{checklistRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def validate_checklist_resolution(self, auth_header: str, request: "scout_checklistexecution_api_BatchValidateChecklistResolutionRequest") -> "scout_checklistexecution_api_BatchValidateChecklistResolutionResponse":
        """Validates that the channels referenced by the checklist can be resolved against the data sources.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/checklist-execution/validate-checklist-resolution'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checklistexecution_api_BatchValidateChecklistResolutionResponse, self._return_none_for_unknown_union_types)


scout_checklistexecution_api_ChecklistExecutionService.__name__ = "ChecklistExecutionService"
scout_checklistexecution_api_ChecklistExecutionService.__qualname__ = "ChecklistExecutionService"
scout_checklistexecution_api_ChecklistExecutionService.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatus(ConjureUnionType):
    _running: Optional["scout_checklistexecution_api_StreamingChecklistRunning"] = None
    _initializing: Optional["scout_checklistexecution_api_StreamingChecklistInitializing"] = None
    _failed: Optional["scout_checklistexecution_api_StreamingChecklistFailed"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'running': ConjureFieldDefinition('running', scout_checklistexecution_api_StreamingChecklistRunning),
            'initializing': ConjureFieldDefinition('initializing', scout_checklistexecution_api_StreamingChecklistInitializing),
            'failed': ConjureFieldDefinition('failed', scout_checklistexecution_api_StreamingChecklistFailed)
        }

    def __init__(
            self,
            running: Optional["scout_checklistexecution_api_StreamingChecklistRunning"] = None,
            initializing: Optional["scout_checklistexecution_api_StreamingChecklistInitializing"] = None,
            failed: Optional["scout_checklistexecution_api_StreamingChecklistFailed"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (running is not None) + (initializing is not None) + (failed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if running is not None:
                self._running = running
                self._type = 'running'
            if initializing is not None:
                self._initializing = initializing
                self._type = 'initializing'
            if failed is not None:
                self._failed = failed
                self._type = 'failed'

        elif type_of_union == 'running':
            if running is None:
                raise ValueError('a union value must not be None')
            self._running = running
            self._type = 'running'
        elif type_of_union == 'initializing':
            if initializing is None:
                raise ValueError('a union value must not be None')
            self._initializing = initializing
            self._type = 'initializing'
        elif type_of_union == 'failed':
            if failed is None:
                raise ValueError('a union value must not be None')
            self._failed = failed
            self._type = 'failed'

    @builtins.property
    def running(self) -> Optional["scout_checklistexecution_api_StreamingChecklistRunning"]:
        """The streaming checklist is currently executing against the asset.
        """
        return self._running

    @builtins.property
    def initializing(self) -> Optional["scout_checklistexecution_api_StreamingChecklistInitializing"]:
        """The streaming checklist is currently initializing against the asset.
        """
        return self._initializing

    @builtins.property
    def failed(self) -> Optional["scout_checklistexecution_api_StreamingChecklistFailed"]:
        """The streaming checklist failed unexpectedly. Please contact support.
        """
        return self._failed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_ChecklistLiveStatusVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_ChecklistLiveStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'running' and self.running is not None:
            return visitor._running(self.running)
        if self._type == 'initializing' and self.initializing is not None:
            return visitor._initializing(self.initializing)
        if self._type == 'failed' and self.failed is not None:
            return visitor._failed(self.failed)


scout_checklistexecution_api_ChecklistLiveStatus.__name__ = "ChecklistLiveStatus"
scout_checklistexecution_api_ChecklistLiveStatus.__qualname__ = "ChecklistLiveStatus"
scout_checklistexecution_api_ChecklistLiveStatus.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatusVisitor:

    @abstractmethod
    def _running(self, running: "scout_checklistexecution_api_StreamingChecklistRunning") -> Any:
        pass

    @abstractmethod
    def _initializing(self, initializing: "scout_checklistexecution_api_StreamingChecklistInitializing") -> Any:
        pass

    @abstractmethod
    def _failed(self, failed: "scout_checklistexecution_api_StreamingChecklistFailed") -> Any:
        pass


scout_checklistexecution_api_ChecklistLiveStatusVisitor.__name__ = "ChecklistLiveStatusVisitor"
scout_checklistexecution_api_ChecklistLiveStatusVisitor.__qualname__ = "ChecklistLiveStatusVisitor"
scout_checklistexecution_api_ChecklistLiveStatusVisitor.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatusRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid)
        }

    __slots__: List[str] = ['_checklist_rid', '_asset_rid']

    def __init__(self, asset_rid: str, checklist_rid: str) -> None:
        self._checklist_rid = checklist_rid
        self._asset_rid = asset_rid

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid


scout_checklistexecution_api_ChecklistLiveStatusRequest.__name__ = "ChecklistLiveStatusRequest"
scout_checklistexecution_api_ChecklistLiveStatusRequest.__qualname__ = "ChecklistLiveStatusRequest"
scout_checklistexecution_api_ChecklistLiveStatusRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ChecklistLiveStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'status': ConjureFieldDefinition('status', scout_checklistexecution_api_ChecklistLiveStatus)
        }

    __slots__: List[str] = ['_checklist_rid', '_asset_rid', '_status']

    def __init__(self, asset_rid: str, checklist_rid: str, status: "scout_checklistexecution_api_ChecklistLiveStatus") -> None:
        self._checklist_rid = checklist_rid
        self._asset_rid = asset_rid
        self._status = status

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def status(self) -> "scout_checklistexecution_api_ChecklistLiveStatus":
        return self._status


scout_checklistexecution_api_ChecklistLiveStatusResponse.__name__ = "ChecklistLiveStatusResponse"
scout_checklistexecution_api_ChecklistLiveStatusResponse.__qualname__ = "ChecklistLiveStatusResponse"
scout_checklistexecution_api_ChecklistLiveStatusResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Computing(ConjureBeanType):
    """The result is currently being computed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Computing.__name__ = "Computing"
scout_checklistexecution_api_Computing.__qualname__ = "Computing"
scout_checklistexecution_api_Computing.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ExecuteChecklistForAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_rids_api_ChecklistRid),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid]),
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration]),
            'evaluation_delay': ConjureFieldDefinition('evaluationDelay', scout_run_api_Duration),
            'recovery_delay': ConjureFieldDefinition('recoveryDelay', scout_run_api_Duration),
            'auto_create_events': ConjureFieldDefinition('autoCreateEvents', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_checklist', '_assets', '_notification_configurations', '_evaluation_delay', '_recovery_delay', '_auto_create_events']

    def __init__(self, assets: List[str], checklist: str, evaluation_delay: "scout_run_api_Duration", notification_configurations: List["scout_integrations_api_NotificationConfiguration"], recovery_delay: "scout_run_api_Duration", auto_create_events: Optional[bool] = None) -> None:
        self._checklist = checklist
        self._assets = assets
        self._notification_configurations = notification_configurations
        self._evaluation_delay = evaluation_delay
        self._recovery_delay = recovery_delay
        self._auto_create_events = auto_create_events

    @builtins.property
    def checklist(self) -> str:
        return self._checklist

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        """Checklist violations will be sent to the specified integrations. At least one integration must be specified.
        """
        return self._notification_configurations

    @builtins.property
    def evaluation_delay(self) -> "scout_run_api_Duration":
        """Delays the evaluation of the streaming checklist. This is useful for when data is delayed.
        """
        return self._evaluation_delay

    @builtins.property
    def recovery_delay(self) -> "scout_run_api_Duration":
        """Specifies the minimum amount of time that must pass before a check can recover from a failure.
Minimum value is 15 seconds.
        """
        return self._recovery_delay

    @builtins.property
    def auto_create_events(self) -> Optional[bool]:
        """The option to automatically create events for check status changes.
If true, events will be created when checks fail and recover.
Defaults to false if not specified.
        """
        return self._auto_create_events


scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__name__ = "ExecuteChecklistForAssetsRequest"
scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__qualname__ = "ExecuteChecklistForAssetsRequest"
scout_checklistexecution_api_ExecuteChecklistForAssetsRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Fail(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Fail.__name__ = "Fail"
scout_checklistexecution_api_Fail.__qualname__ = "Fail"
scout_checklistexecution_api_Fail.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Failure(ConjureBeanType):
    """The time range where a check was failing.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', OptionalTypeWrapper[api_Timestamp]),
            'end_exclusive': ConjureFieldDefinition('endExclusive', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive']

    def __init__(self, end_exclusive: Optional["api_Timestamp"] = None, start_inclusive: Optional["api_Timestamp"] = None) -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive

    @builtins.property
    def start_inclusive(self) -> Optional["api_Timestamp"]:
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> Optional["api_Timestamp"]:
        return self._end_exclusive


scout_checklistexecution_api_Failure.__name__ = "Failure"
scout_checklistexecution_api_Failure.__qualname__ = "Failure"
scout_checklistexecution_api_Failure.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Invalid(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Invalid.__name__ = "Invalid"
scout_checklistexecution_api_Invalid.__qualname__ = "Invalid"
scout_checklistexecution_api_Invalid.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_InvalidStreamingComputeNode(ConjureEnumType):

    POINT_PERSISTENCE = 'POINT_PERSISTENCE'
    '''POINT_PERSISTENCE'''
    CUMULATIVE_SUM = 'CUMULATIVE_SUM'
    '''CUMULATIVE_SUM'''
    INTEGRAL = 'INTEGRAL'
    '''INTEGRAL'''
    STALENESS_DETECTION = 'STALENESS_DETECTION'
    '''STALENESS_DETECTION'''
    LITERAL_RANGES = 'LITERAL_RANGES'
    '''LITERAL_RANGES'''
    TIME_RANGE_FILTER = 'TIME_RANGE_FILTER'
    '''TIME_RANGE_FILTER'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checklistexecution_api_InvalidStreamingComputeNode.__name__ = "InvalidStreamingComputeNode"
scout_checklistexecution_api_InvalidStreamingComputeNode.__qualname__ = "InvalidStreamingComputeNode"
scout_checklistexecution_api_InvalidStreamingComputeNode.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_LastFailure(ConjureUnionType):
    _not_computed: Optional["scout_checklistexecution_api_NotComputed"] = None
    _computing: Optional["scout_checklistexecution_api_Computing"] = None
    _no_previous_failure: Optional["scout_checklistexecution_api_NoPreviousFailure"] = None
    _failure: Optional["scout_checklistexecution_api_Failure"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_computed': ConjureFieldDefinition('notComputed', scout_checklistexecution_api_NotComputed),
            'computing': ConjureFieldDefinition('computing', scout_checklistexecution_api_Computing),
            'no_previous_failure': ConjureFieldDefinition('noPreviousFailure', scout_checklistexecution_api_NoPreviousFailure),
            'failure': ConjureFieldDefinition('failure', scout_checklistexecution_api_Failure)
        }

    def __init__(
            self,
            not_computed: Optional["scout_checklistexecution_api_NotComputed"] = None,
            computing: Optional["scout_checklistexecution_api_Computing"] = None,
            no_previous_failure: Optional["scout_checklistexecution_api_NoPreviousFailure"] = None,
            failure: Optional["scout_checklistexecution_api_Failure"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_computed is not None) + (computing is not None) + (no_previous_failure is not None) + (failure is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_computed is not None:
                self._not_computed = not_computed
                self._type = 'notComputed'
            if computing is not None:
                self._computing = computing
                self._type = 'computing'
            if no_previous_failure is not None:
                self._no_previous_failure = no_previous_failure
                self._type = 'noPreviousFailure'
            if failure is not None:
                self._failure = failure
                self._type = 'failure'

        elif type_of_union == 'notComputed':
            if not_computed is None:
                raise ValueError('a union value must not be None')
            self._not_computed = not_computed
            self._type = 'notComputed'
        elif type_of_union == 'computing':
            if computing is None:
                raise ValueError('a union value must not be None')
            self._computing = computing
            self._type = 'computing'
        elif type_of_union == 'noPreviousFailure':
            if no_previous_failure is None:
                raise ValueError('a union value must not be None')
            self._no_previous_failure = no_previous_failure
            self._type = 'noPreviousFailure'
        elif type_of_union == 'failure':
            if failure is None:
                raise ValueError('a union value must not be None')
            self._failure = failure
            self._type = 'failure'

    @builtins.property
    def not_computed(self) -> Optional["scout_checklistexecution_api_NotComputed"]:
        """The last failure time has not been computed, and is not currently being computed.
        """
        return self._not_computed

    @builtins.property
    def computing(self) -> Optional["scout_checklistexecution_api_Computing"]:
        """The last failure time is currently being computed. This may require evaluating the history
of data for the check, so could be slow depending on the data frequency and lookback period.
        """
        return self._computing

    @builtins.property
    def no_previous_failure(self) -> Optional["scout_checklistexecution_api_NoPreviousFailure"]:
        """No previous failure was found for the check.
        """
        return self._no_previous_failure

    @builtins.property
    def failure(self) -> Optional["scout_checklistexecution_api_Failure"]:
        """The most recent failure for the check.
        """
        return self._failure

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checklistexecution_api_LastFailureVisitor):
            raise ValueError('{} is not an instance of scout_checklistexecution_api_LastFailureVisitor'.format(visitor.__class__.__name__))
        if self._type == 'notComputed' and self.not_computed is not None:
            return visitor._not_computed(self.not_computed)
        if self._type == 'computing' and self.computing is not None:
            return visitor._computing(self.computing)
        if self._type == 'noPreviousFailure' and self.no_previous_failure is not None:
            return visitor._no_previous_failure(self.no_previous_failure)
        if self._type == 'failure' and self.failure is not None:
            return visitor._failure(self.failure)


scout_checklistexecution_api_LastFailure.__name__ = "LastFailure"
scout_checklistexecution_api_LastFailure.__qualname__ = "LastFailure"
scout_checklistexecution_api_LastFailure.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_LastFailureVisitor:

    @abstractmethod
    def _not_computed(self, not_computed: "scout_checklistexecution_api_NotComputed") -> Any:
        pass

    @abstractmethod
    def _computing(self, computing: "scout_checklistexecution_api_Computing") -> Any:
        pass

    @abstractmethod
    def _no_previous_failure(self, no_previous_failure: "scout_checklistexecution_api_NoPreviousFailure") -> Any:
        pass

    @abstractmethod
    def _failure(self, failure: "scout_checklistexecution_api_Failure") -> Any:
        pass


scout_checklistexecution_api_LastFailureVisitor.__name__ = "LastFailureVisitor"
scout_checklistexecution_api_LastFailureVisitor.__qualname__ = "LastFailureVisitor"
scout_checklistexecution_api_LastFailureVisitor.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ListStreamingChecklistForAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'page_token': ConjureFieldDefinition('pageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_asset_rid', '_page_size', '_page_token']

    def __init__(self, asset_rid: str, page_size: Optional[int] = None, page_token: Optional[str] = None) -> None:
        self._asset_rid = asset_rid
        self._page_size = page_size
        self._page_token = page_token

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
        """
        return self._page_size

    @builtins.property
    def page_token(self) -> Optional[str]:
        return self._page_token


scout_checklistexecution_api_ListStreamingChecklistForAssetRequest.__name__ = "ListStreamingChecklistForAssetRequest"
scout_checklistexecution_api_ListStreamingChecklistForAssetRequest.__qualname__ = "ListStreamingChecklistForAssetRequest"
scout_checklistexecution_api_ListStreamingChecklistForAssetRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ListStreamingChecklistForAssetResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklists': ConjureFieldDefinition('checklists', List[scout_rids_api_ChecklistRid]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_checklists', '_next_page_token']

    def __init__(self, checklists: List[str], next_page_token: Optional[str] = None) -> None:
        self._checklists = checklists
        self._next_page_token = next_page_token

    @builtins.property
    def checklists(self) -> List[str]:
        return self._checklists

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_checklistexecution_api_ListStreamingChecklistForAssetResponse.__name__ = "ListStreamingChecklistForAssetResponse"
scout_checklistexecution_api_ListStreamingChecklistForAssetResponse.__qualname__ = "ListStreamingChecklistForAssetResponse"
scout_checklistexecution_api_ListStreamingChecklistForAssetResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ListStreamingChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'workspaces': ConjureFieldDefinition('workspaces', List[api_rids_WorkspaceRid]),
            'page_token': ConjureFieldDefinition('pageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_page_size', '_workspaces', '_page_token']

    def __init__(self, workspaces: List[str], page_size: Optional[int] = None, page_token: Optional[str] = None) -> None:
        self._page_size = page_size
        self._workspaces = workspaces
        self._page_token = page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Page sizes greater than 10_000 will be rejected. Default pageSize is 100.
        """
        return self._page_size

    @builtins.property
    def workspaces(self) -> List[str]:
        return self._workspaces

    @builtins.property
    def page_token(self) -> Optional[str]:
        return self._page_token


scout_checklistexecution_api_ListStreamingChecklistRequest.__name__ = "ListStreamingChecklistRequest"
scout_checklistexecution_api_ListStreamingChecklistRequest.__qualname__ = "ListStreamingChecklistRequest"
scout_checklistexecution_api_ListStreamingChecklistRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ListStreamingChecklistResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklists': ConjureFieldDefinition('checklists', List[scout_rids_api_ChecklistRid]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_checklists', '_next_page_token']

    def __init__(self, checklists: List[str], next_page_token: Optional[str] = None) -> None:
        self._checklists = checklists
        self._next_page_token = next_page_token

    @builtins.property
    def checklists(self) -> List[str]:
        return self._checklists

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_checklistexecution_api_ListStreamingChecklistResponse.__name__ = "ListStreamingChecklistResponse"
scout_checklistexecution_api_ListStreamingChecklistResponse.__qualname__ = "ListStreamingChecklistResponse"
scout_checklistexecution_api_ListStreamingChecklistResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_NoPreviousFailure(ConjureBeanType):
    """No previous failure was computed for the check.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_NoPreviousFailure.__name__ = "NoPreviousFailure"
scout_checklistexecution_api_NoPreviousFailure.__qualname__ = "NoPreviousFailure"
scout_checklistexecution_api_NoPreviousFailure.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_NotComputed(ConjureBeanType):
    """The result has not been computed, and is not currently being computed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_NotComputed.__name__ = "NotComputed"
scout_checklistexecution_api_NotComputed.__qualname__ = "NotComputed"
scout_checklistexecution_api_NotComputed.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Pass(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Pass.__name__ = "Pass"
scout_checklistexecution_api_Pass.__qualname__ = "Pass"
scout_checklistexecution_api_Pass.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ResolvedCheckStatus(ConjureBeanType):
    """Provides the resolution status for the required channels for a check and the set of invalid streaming compute nodes present within the check's compute graph.
Uniqueness between checkRid and checkParameterIndex pairs is guaranteed.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_parameter_index': ConjureFieldDefinition('checkParameterIndex', OptionalTypeWrapper[int]),
            'invalid_streaming_compute_nodes': ConjureFieldDefinition('invalidStreamingComputeNodes', List[scout_checklistexecution_api_InvalidStreamingComputeNode]),
            'channels': ConjureFieldDefinition('channels', List[scout_checklistexecution_api_ChannelLocatorWithStatus])
        }

    __slots__: List[str] = ['_check_rid', '_check_parameter_index', '_invalid_streaming_compute_nodes', '_channels']

    def __init__(self, channels: List["scout_checklistexecution_api_ChannelLocatorWithStatus"], check_rid: str, invalid_streaming_compute_nodes: List["scout_checklistexecution_api_InvalidStreamingComputeNode"], check_parameter_index: Optional[int] = None) -> None:
        self._check_rid = check_rid
        self._check_parameter_index = check_parameter_index
        self._invalid_streaming_compute_nodes = invalid_streaming_compute_nodes
        self._channels = channels

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_parameter_index(self) -> Optional[int]:
        """Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_parameter_index

    @builtins.property
    def invalid_streaming_compute_nodes(self) -> List["scout_checklistexecution_api_InvalidStreamingComputeNode"]:
        return self._invalid_streaming_compute_nodes

    @builtins.property
    def channels(self) -> List["scout_checklistexecution_api_ChannelLocatorWithStatus"]:
        return self._channels


scout_checklistexecution_api_ResolvedCheckStatus.__name__ = "ResolvedCheckStatus"
scout_checklistexecution_api_ResolvedCheckStatus.__qualname__ = "ResolvedCheckStatus"
scout_checklistexecution_api_ResolvedCheckStatus.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_Skipped(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_Skipped.__name__ = "Skipped"
scout_checklistexecution_api_Skipped.__qualname__ = "Skipped"
scout_checklistexecution_api_Skipped.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_rids_api_ChecklistRid),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_checklist', '_assets']

    def __init__(self, assets: List[str], checklist: str) -> None:
        self._checklist = checklist
        self._assets = assets

    @builtins.property
    def checklist(self) -> str:
        return self._checklist

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets


scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__name__ = "StopStreamingChecklistForAssetsRequest"
scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__qualname__ = "StopStreamingChecklistForAssetsRequest"
scout_checklistexecution_api_StopStreamingChecklistForAssetsRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StreamingChecklistFailed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_StreamingChecklistFailed.__name__ = "StreamingChecklistFailed"
scout_checklistexecution_api_StreamingChecklistFailed.__qualname__ = "StreamingChecklistFailed"
scout_checklistexecution_api_StreamingChecklistFailed.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StreamingChecklistInfo(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_configurations': ConjureFieldDefinition('assetConfigurations', Dict[scout_rids_api_AssetRid, scout_checklistexecution_api_AssetStreamConfiguration])
        }

    __slots__: List[str] = ['_checklist_rid', '_asset_configurations']

    def __init__(self, asset_configurations: Dict[str, "scout_checklistexecution_api_AssetStreamConfiguration"], checklist_rid: str) -> None:
        self._checklist_rid = checklist_rid
        self._asset_configurations = asset_configurations

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_configurations(self) -> Dict[str, "scout_checklistexecution_api_AssetStreamConfiguration"]:
        return self._asset_configurations


scout_checklistexecution_api_StreamingChecklistInfo.__name__ = "StreamingChecklistInfo"
scout_checklistexecution_api_StreamingChecklistInfo.__qualname__ = "StreamingChecklistInfo"
scout_checklistexecution_api_StreamingChecklistInfo.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StreamingChecklistInitializing(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checklistexecution_api_StreamingChecklistInitializing.__name__ = "StreamingChecklistInitializing"
scout_checklistexecution_api_StreamingChecklistInitializing.__qualname__ = "StreamingChecklistInitializing"
scout_checklistexecution_api_StreamingChecklistInitializing.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_StreamingChecklistRunning(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit_id': ConjureFieldDefinition('commitId', scout_versioning_api_CommitId),
            'check_results': ConjureFieldDefinition('checkResults', List[scout_checklistexecution_api_CheckLiveStatusResponse])
        }

    __slots__: List[str] = ['_commit_id', '_check_results']

    def __init__(self, check_results: List["scout_checklistexecution_api_CheckLiveStatusResponse"], commit_id: str) -> None:
        self._commit_id = commit_id
        self._check_results = check_results

    @builtins.property
    def commit_id(self) -> str:
        """The commitId of the checklist that is currently executing.
        """
        return self._commit_id

    @builtins.property
    def check_results(self) -> List["scout_checklistexecution_api_CheckLiveStatusResponse"]:
        return self._check_results


scout_checklistexecution_api_StreamingChecklistRunning.__name__ = "StreamingChecklistRunning"
scout_checklistexecution_api_StreamingChecklistRunning.__qualname__ = "StreamingChecklistRunning"
scout_checklistexecution_api_StreamingChecklistRunning.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ValidateChecklistResolutionRequest(ConjureBeanType):
    """Validates that the channels referenced by the checklist can be resolved against the data sources.
If commit is not provided, the latest commit on main will be used.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'commit_id': ConjureFieldDefinition('commitId', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid)
        }

    __slots__: List[str] = ['_checklist_rid', '_commit_id', '_asset_rid']

    def __init__(self, asset_rid: str, checklist_rid: str, commit_id: Optional[str] = None) -> None:
        self._checklist_rid = checklist_rid
        self._commit_id = commit_id
        self._asset_rid = asset_rid

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def commit_id(self) -> Optional[str]:
        return self._commit_id

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid


scout_checklistexecution_api_ValidateChecklistResolutionRequest.__name__ = "ValidateChecklistResolutionRequest"
scout_checklistexecution_api_ValidateChecklistResolutionRequest.__qualname__ = "ValidateChecklistResolutionRequest"
scout_checklistexecution_api_ValidateChecklistResolutionRequest.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checklistexecution_api_ValidateChecklistResolutionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'resolution_status': ConjureFieldDefinition('resolutionStatus', List[scout_checklistexecution_api_ResolvedCheckStatus])
        }

    __slots__: List[str] = ['_checklist_rid', '_asset_rid', '_resolution_status']

    def __init__(self, asset_rid: str, checklist_rid: str, resolution_status: List["scout_checklistexecution_api_ResolvedCheckStatus"]) -> None:
        self._checklist_rid = checklist_rid
        self._asset_rid = asset_rid
        self._resolution_status = resolution_status

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def resolution_status(self) -> List["scout_checklistexecution_api_ResolvedCheckStatus"]:
        return self._resolution_status


scout_checklistexecution_api_ValidateChecklistResolutionResponse.__name__ = "ValidateChecklistResolutionResponse"
scout_checklistexecution_api_ValidateChecklistResolutionResponse.__qualname__ = "ValidateChecklistResolutionResponse"
scout_checklistexecution_api_ValidateChecklistResolutionResponse.__module__ = "nominal_api.scout_checklistexecution_api"


class scout_checks_api_ArchiveChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_ArchiveChecklistsRequest.__name__ = "ArchiveChecklistsRequest"
scout_checks_api_ArchiveChecklistsRequest.__qualname__ = "ArchiveChecklistsRequest"
scout_checks_api_ArchiveChecklistsRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_BatchGetChecklistMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_BatchGetChecklistMetadataRequest.__name__ = "BatchGetChecklistMetadataRequest"
scout_checks_api_BatchGetChecklistMetadataRequest.__qualname__ = "BatchGetChecklistMetadataRequest"
scout_checks_api_BatchGetChecklistMetadataRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_BatchGetChecklistMetadataResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', Dict[scout_rids_api_ChecklistRid, scout_checks_api_ChecklistMetadata])
        }

    __slots__: List[str] = ['_metadata']

    def __init__(self, metadata: Dict[str, "scout_checks_api_ChecklistMetadata"]) -> None:
        self._metadata = metadata

    @builtins.property
    def metadata(self) -> Dict[str, "scout_checks_api_ChecklistMetadata"]:
        return self._metadata


scout_checks_api_BatchGetChecklistMetadataResponse.__name__ = "BatchGetChecklistMetadataResponse"
scout_checks_api_BatchGetChecklistMetadataResponse.__qualname__ = "BatchGetChecklistMetadataResponse"
scout_checks_api_BatchGetChecklistMetadataResponse.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_BatchGetJobReportsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rids': ConjureFieldDefinition('jobRids', List[scout_checks_api_JobRid])
        }

    __slots__: List[str] = ['_job_rids']

    def __init__(self, job_rids: List[str]) -> None:
        self._job_rids = job_rids

    @builtins.property
    def job_rids(self) -> List[str]:
        return self._job_rids


scout_checks_api_BatchGetJobReportsRequest.__name__ = "BatchGetJobReportsRequest"
scout_checks_api_BatchGetJobReportsRequest.__qualname__ = "BatchGetJobReportsRequest"
scout_checks_api_BatchGetJobReportsRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_BatchGetJobReportsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rids_to_job_reports': ConjureFieldDefinition('jobRidsToJobReports', Dict[scout_checks_api_JobRid, scout_checks_api_JobReport])
        }

    __slots__: List[str] = ['_job_rids_to_job_reports']

    def __init__(self, job_rids_to_job_reports: Dict[str, "scout_checks_api_JobReport"]) -> None:
        self._job_rids_to_job_reports = job_rids_to_job_reports

    @builtins.property
    def job_rids_to_job_reports(self) -> Dict[str, "scout_checks_api_JobReport"]:
        return self._job_rids_to_job_reports


scout_checks_api_BatchGetJobReportsResponse.__name__ = "BatchGetJobReportsResponse"
scout_checks_api_BatchGetJobReportsResponse.__qualname__ = "BatchGetJobReportsResponse"
scout_checks_api_BatchGetJobReportsResponse.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_Check(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_CheckRid),
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', scout_rids_api_CheckLineageRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'generated_event_type': ConjureFieldDefinition('generatedEventType', event_EventType),
            'generated_event_labels': ConjureFieldDefinition('generatedEventLabels', OptionalTypeWrapper[List[api_Label]]),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedVizId]),
            'condition': ConjureFieldDefinition('condition', OptionalTypeWrapper[scout_checks_api_CheckCondition])
        }

    __slots__: List[str] = ['_rid', '_check_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_priority', '_generated_event_type', '_generated_event_labels', '_chart', '_condition']

    def __init__(self, check_lineage_rid: str, description: str, generated_event_type: "event_EventType", priority: "scout_api_Priority", rid: str, title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None, chart: Optional["scout_rids_api_VersionedVizId"] = None, condition: Optional["scout_checks_api_CheckCondition"] = None, generated_event_labels: Optional[List[str]] = None) -> None:
        self._rid = rid
        self._check_lineage_rid = check_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._priority = priority
        self._generated_event_type = generated_event_type
        self._generated_event_labels = generated_event_labels
        self._chart = chart
        self._condition = condition

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_lineage_rid(self) -> str:
        return self._check_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def priority(self) -> "scout_api_Priority":
        return self._priority

    @builtins.property
    def generated_event_type(self) -> "event_EventType":
        return self._generated_event_type

    @builtins.property
    def generated_event_labels(self) -> Optional[List[str]]:
        return self._generated_event_labels

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedVizId"]:
        return self._chart

    @builtins.property
    def condition(self) -> Optional["scout_checks_api_CheckCondition"]:
        """If omitted, this check represents a manual check.
        """
        return self._condition


scout_checks_api_Check.__name__ = "Check"
scout_checks_api_Check.__qualname__ = "Check"
scout_checks_api_Check.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CheckCondition(ConjureUnionType):
    _num_ranges: Optional["scout_checks_api_NumRangesConditionV1"] = None
    _num_ranges_v2: Optional["scout_checks_api_NumRangesConditionV2"] = None
    _num_ranges_v3: Optional["scout_checks_api_NumRangesConditionV3"] = None
    _parameterized_num_ranges_v1: Optional["scout_checks_api_ParameterizedNumRangesConditionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_ranges': ConjureFieldDefinition('numRanges', scout_checks_api_NumRangesConditionV1),
            'num_ranges_v2': ConjureFieldDefinition('numRangesV2', scout_checks_api_NumRangesConditionV2),
            'num_ranges_v3': ConjureFieldDefinition('numRangesV3', scout_checks_api_NumRangesConditionV3),
            'parameterized_num_ranges_v1': ConjureFieldDefinition('parameterizedNumRangesV1', scout_checks_api_ParameterizedNumRangesConditionV1)
        }

    def __init__(
            self,
            num_ranges: Optional["scout_checks_api_NumRangesConditionV1"] = None,
            num_ranges_v2: Optional["scout_checks_api_NumRangesConditionV2"] = None,
            num_ranges_v3: Optional["scout_checks_api_NumRangesConditionV3"] = None,
            parameterized_num_ranges_v1: Optional["scout_checks_api_ParameterizedNumRangesConditionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (num_ranges is not None) + (num_ranges_v2 is not None) + (num_ranges_v3 is not None) + (parameterized_num_ranges_v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if num_ranges is not None:
                self._num_ranges = num_ranges
                self._type = 'numRanges'
            if num_ranges_v2 is not None:
                self._num_ranges_v2 = num_ranges_v2
                self._type = 'numRangesV2'
            if num_ranges_v3 is not None:
                self._num_ranges_v3 = num_ranges_v3
                self._type = 'numRangesV3'
            if parameterized_num_ranges_v1 is not None:
                self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
                self._type = 'parameterizedNumRangesV1'

        elif type_of_union == 'numRanges':
            if num_ranges is None:
                raise ValueError('a union value must not be None')
            self._num_ranges = num_ranges
            self._type = 'numRanges'
        elif type_of_union == 'numRangesV2':
            if num_ranges_v2 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v2 = num_ranges_v2
            self._type = 'numRangesV2'
        elif type_of_union == 'numRangesV3':
            if num_ranges_v3 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v3 = num_ranges_v3
            self._type = 'numRangesV3'
        elif type_of_union == 'parameterizedNumRangesV1':
            if parameterized_num_ranges_v1 is None:
                raise ValueError('a union value must not be None')
            self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
            self._type = 'parameterizedNumRangesV1'

    @builtins.property
    def num_ranges(self) -> Optional["scout_checks_api_NumRangesConditionV1"]:
        return self._num_ranges

    @builtins.property
    def num_ranges_v2(self) -> Optional["scout_checks_api_NumRangesConditionV2"]:
        return self._num_ranges_v2

    @builtins.property
    def num_ranges_v3(self) -> Optional["scout_checks_api_NumRangesConditionV3"]:
        return self._num_ranges_v3

    @builtins.property
    def parameterized_num_ranges_v1(self) -> Optional["scout_checks_api_ParameterizedNumRangesConditionV1"]:
        return self._parameterized_num_ranges_v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_CheckConditionVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_CheckConditionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numRanges' and self.num_ranges is not None:
            return visitor._num_ranges(self.num_ranges)
        if self._type == 'numRangesV2' and self.num_ranges_v2 is not None:
            return visitor._num_ranges_v2(self.num_ranges_v2)
        if self._type == 'numRangesV3' and self.num_ranges_v3 is not None:
            return visitor._num_ranges_v3(self.num_ranges_v3)
        if self._type == 'parameterizedNumRangesV1' and self.parameterized_num_ranges_v1 is not None:
            return visitor._parameterized_num_ranges_v1(self.parameterized_num_ranges_v1)


scout_checks_api_CheckCondition.__name__ = "CheckCondition"
scout_checks_api_CheckCondition.__qualname__ = "CheckCondition"
scout_checks_api_CheckCondition.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CheckConditionVisitor:

    @abstractmethod
    def _num_ranges(self, num_ranges: "scout_checks_api_NumRangesConditionV1") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v2(self, num_ranges_v2: "scout_checks_api_NumRangesConditionV2") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v3(self, num_ranges_v3: "scout_checks_api_NumRangesConditionV3") -> Any:
        pass

    @abstractmethod
    def _parameterized_num_ranges_v1(self, parameterized_num_ranges_v1: "scout_checks_api_ParameterizedNumRangesConditionV1") -> Any:
        pass


scout_checks_api_CheckConditionVisitor.__name__ = "CheckConditionVisitor"
scout_checks_api_CheckConditionVisitor.__qualname__ = "CheckConditionVisitor"
scout_checks_api_CheckConditionVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CheckContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator]),
            'sub_function_variables': ConjureFieldDefinition('subFunctionVariables', OptionalTypeWrapper[Dict[scout_compute_api_FunctionReference, scout_checks_api_CheckContext]])
        }

    __slots__: List[str] = ['_variables', '_sub_function_variables']

    def __init__(self, variables: Dict[str, "scout_checks_api_VariableLocator"], sub_function_variables: Optional[Dict[str, "scout_checks_api_CheckContext"]] = None) -> None:
        self._variables = variables
        self._sub_function_variables = sub_function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables

    @builtins.property
    def sub_function_variables(self) -> Optional[Dict[str, "scout_checks_api_CheckContext"]]:
        return self._sub_function_variables


scout_checks_api_CheckContext.__name__ = "CheckContext"
scout_checks_api_CheckContext.__qualname__ = "CheckContext"
scout_checks_api_CheckContext.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CheckJobResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_datareview_api_Status),
            'failures': ConjureFieldDefinition('failures', List[scout_compute_api_Range]),
            'are_failures_decimated': ConjureFieldDefinition('areFailuresDecimated', bool)
        }

    __slots__: List[str] = ['_status', '_failures', '_are_failures_decimated']

    def __init__(self, are_failures_decimated: bool, failures: List["scout_compute_api_Range"], status: "scout_datareview_api_Status") -> None:
        self._status = status
        self._failures = failures
        self._are_failures_decimated = are_failures_decimated

    @builtins.property
    def status(self) -> "scout_datareview_api_Status":
        return self._status

    @builtins.property
    def failures(self) -> List["scout_compute_api_Range"]:
        return self._failures

    @builtins.property
    def are_failures_decimated(self) -> bool:
        return self._are_failures_decimated


scout_checks_api_CheckJobResult.__name__ = "CheckJobResult"
scout_checks_api_CheckJobResult.__qualname__ = "CheckJobResult"
scout_checks_api_CheckJobResult.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CheckJobSpec(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'asset_rid': ConjureFieldDefinition('assetRid', OptionalTypeWrapper[scout_rids_api_AssetRid]),
            'check_implementation_index': ConjureFieldDefinition('checkImplementationIndex', OptionalTypeWrapper[int]),
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', api_rids_AutomaticCheckEvaluationRid),
            'check_condition': ConjureFieldDefinition('checkCondition', scout_checks_api_CheckCondition),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_data_review_rid', '_check_rid', '_run_rid', '_asset_rid', '_check_implementation_index', '_check_evaluation_rid', '_check_condition', '_start', '_end', '_context']

    def __init__(self, check_condition: "scout_checks_api_CheckCondition", check_evaluation_rid: str, check_rid: str, context: "scout_compute_api_Context", data_review_rid: str, end: "api_Timestamp", start: "api_Timestamp", asset_rid: Optional[str] = None, check_implementation_index: Optional[int] = None, run_rid: Optional[str] = None) -> None:
        self._data_review_rid = data_review_rid
        self._check_rid = check_rid
        self._run_rid = run_rid
        self._asset_rid = asset_rid
        self._check_implementation_index = check_implementation_index
        self._check_evaluation_rid = check_evaluation_rid
        self._check_condition = check_condition
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> Optional[str]:
        return self._asset_rid

    @builtins.property
    def check_implementation_index(self) -> Optional[int]:
        """Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_implementation_index

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def check_condition(self) -> "scout_checks_api_CheckCondition":
        return self._check_condition

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_checks_api_CheckJobSpec.__name__ = "CheckJobSpec"
scout_checks_api_CheckJobSpec.__qualname__ = "CheckJobSpec"
scout_checks_api_CheckJobSpec.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistEntry(ConjureUnionType):
    _check: Optional["scout_checks_api_Check"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check': ConjureFieldDefinition('check', scout_checks_api_Check)
        }

    def __init__(
            self,
            check: Optional["scout_checks_api_Check"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check is not None:
                self._check = check
                self._type = 'check'

        elif type_of_union == 'check':
            if check is None:
                raise ValueError('a union value must not be None')
            self._check = check
            self._type = 'check'

    @builtins.property
    def check(self) -> Optional["scout_checks_api_Check"]:
        return self._check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_ChecklistEntryVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_ChecklistEntryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'check' and self.check is not None:
            return visitor._check(self.check)


scout_checks_api_ChecklistEntry.__name__ = "ChecklistEntry"
scout_checks_api_ChecklistEntry.__qualname__ = "ChecklistEntry"
scout_checks_api_ChecklistEntry.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistEntryVisitor:

    @abstractmethod
    def _check(self, check: "scout_checks_api_Check") -> Any:
        pass


scout_checks_api_ChecklistEntryVisitor.__name__ = "ChecklistEntryVisitor"
scout_checks_api_ChecklistEntryVisitor.__qualname__ = "ChecklistEntryVisitor"
scout_checks_api_ChecklistEntryVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'last_used': ConjureFieldDefinition('lastUsed', OptionalTypeWrapper[str]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool)
        }

    __slots__: List[str] = ['_author_rid', '_assignee_rid', '_title', '_description', '_created_at', '_properties', '_labels', '_last_used', '_is_archived', '_is_published']

    def __init__(self, assignee_rid: str, author_rid: str, created_at: str, description: str, is_archived: bool, is_published: bool, labels: List[str], properties: Dict[str, str], title: str, last_used: Optional[str] = None) -> None:
        self._author_rid = author_rid
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._created_at = created_at
        self._properties = properties
        self._labels = labels
        self._last_used = last_used
        self._is_archived = is_archived
        self._is_published = is_published

    @builtins.property
    def author_rid(self) -> str:
        return self._author_rid

    @builtins.property
    def assignee_rid(self) -> str:
        return self._assignee_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def last_used(self) -> Optional[str]:
        return self._last_used

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def is_published(self) -> bool:
        return self._is_published


scout_checks_api_ChecklistMetadata.__name__ = "ChecklistMetadata"
scout_checks_api_ChecklistMetadata.__qualname__ = "ChecklistMetadata"
scout_checks_api_ChecklistMetadata.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistRef(ConjureBeanType):
    """A reference to a checklist that may be pinned to a specific commit.
If commit is empty, this refers to "the latest commit on main".
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_rid', '_commit']

    def __init__(self, rid: str, commit: Optional[str] = None) -> None:
        self._rid = rid
        self._commit = commit

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def commit(self) -> Optional[str]:
        return self._commit


scout_checks_api_ChecklistRef.__name__ = "ChecklistRef"
scout_checks_api_ChecklistRef.__qualname__ = "ChecklistRef"
scout_checks_api_ChecklistRef.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistSearchQuery(ConjureUnionType):
    _and_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None
    _or_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _author_rid: Optional[str] = None
    _assignee_rid: Optional[str] = None
    _is_published: Optional[bool] = None
    _not_: Optional["scout_checks_api_ChecklistSearchQuery"] = None
    _workspace: Optional[str] = None
    _author_is_current_user: Optional[bool] = None
    _author_rids: Optional[List[str]] = None
    _is_archived: Optional[bool] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_checks_api_ChecklistSearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_checks_api_ChecklistSearchQuery]),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'is_published': ConjureFieldDefinition('isPublished', bool),
            'not_': ConjureFieldDefinition('not', scout_checks_api_ChecklistSearchQuery),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'author_is_current_user': ConjureFieldDefinition('authorIsCurrentUser', bool),
            'author_rids': ConjureFieldDefinition('authorRids', List[scout_rids_api_UserRid]),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    def __init__(
            self,
            and_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None,
            or_: Optional[List["scout_checks_api_ChecklistSearchQuery"]] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            author_rid: Optional[str] = None,
            assignee_rid: Optional[str] = None,
            is_published: Optional[bool] = None,
            not_: Optional["scout_checks_api_ChecklistSearchQuery"] = None,
            workspace: Optional[str] = None,
            author_is_current_user: Optional[bool] = None,
            author_rids: Optional[List[str]] = None,
            is_archived: Optional[bool] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (search_text is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (author_rid is not None) + (assignee_rid is not None) + (is_published is not None) + (not_ is not None) + (workspace is not None) + (author_is_current_user is not None) + (author_rids is not None) + (is_archived is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if author_rid is not None:
                self._author_rid = author_rid
                self._type = 'authorRid'
            if assignee_rid is not None:
                self._assignee_rid = assignee_rid
                self._type = 'assigneeRid'
            if is_published is not None:
                self._is_published = is_published
                self._type = 'isPublished'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if author_is_current_user is not None:
                self._author_is_current_user = author_is_current_user
                self._type = 'authorIsCurrentUser'
            if author_rids is not None:
                self._author_rids = author_rids
                self._type = 'authorRids'
            if is_archived is not None:
                self._is_archived = is_archived
                self._type = 'isArchived'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'authorRid':
            if author_rid is None:
                raise ValueError('a union value must not be None')
            self._author_rid = author_rid
            self._type = 'authorRid'
        elif type_of_union == 'assigneeRid':
            if assignee_rid is None:
                raise ValueError('a union value must not be None')
            self._assignee_rid = assignee_rid
            self._type = 'assigneeRid'
        elif type_of_union == 'isPublished':
            if is_published is None:
                raise ValueError('a union value must not be None')
            self._is_published = is_published
            self._type = 'isPublished'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'authorIsCurrentUser':
            if author_is_current_user is None:
                raise ValueError('a union value must not be None')
            self._author_is_current_user = author_is_current_user
            self._type = 'authorIsCurrentUser'
        elif type_of_union == 'authorRids':
            if author_rids is None:
                raise ValueError('a union value must not be None')
            self._author_rids = author_rids
            self._type = 'authorRids'
        elif type_of_union == 'isArchived':
            if is_archived is None:
                raise ValueError('a union value must not be None')
            self._is_archived = is_archived
            self._type = 'isArchived'

    @builtins.property
    def and_(self) -> Optional[List["scout_checks_api_ChecklistSearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_checks_api_ChecklistSearchQuery"]]:
        return self._or_

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def assignee_rid(self) -> Optional[str]:
        return self._assignee_rid

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published

    @builtins.property
    def not_(self) -> Optional["scout_checks_api_ChecklistSearchQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def author_is_current_user(self) -> Optional[bool]:
        return self._author_is_current_user

    @builtins.property
    def author_rids(self) -> Optional[List[str]]:
        return self._author_rids

    @builtins.property
    def is_archived(self) -> Optional[bool]:
        return self._is_archived

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_ChecklistSearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_ChecklistSearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'authorRid' and self.author_rid is not None:
            return visitor._author_rid(self.author_rid)
        if self._type == 'assigneeRid' and self.assignee_rid is not None:
            return visitor._assignee_rid(self.assignee_rid)
        if self._type == 'isPublished' and self.is_published is not None:
            return visitor._is_published(self.is_published)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'authorIsCurrentUser' and self.author_is_current_user is not None:
            return visitor._author_is_current_user(self.author_is_current_user)
        if self._type == 'authorRids' and self.author_rids is not None:
            return visitor._author_rids(self.author_rids)
        if self._type == 'isArchived' and self.is_archived is not None:
            return visitor._is_archived(self.is_archived)


scout_checks_api_ChecklistSearchQuery.__name__ = "ChecklistSearchQuery"
scout_checks_api_ChecklistSearchQuery.__qualname__ = "ChecklistSearchQuery"
scout_checks_api_ChecklistSearchQuery.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistSearchQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_checks_api_ChecklistSearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_checks_api_ChecklistSearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _author_rid(self, author_rid: str) -> Any:
        pass

    @abstractmethod
    def _assignee_rid(self, assignee_rid: str) -> Any:
        pass

    @abstractmethod
    def _is_published(self, is_published: bool) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_checks_api_ChecklistSearchQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _author_is_current_user(self, author_is_current_user: bool) -> Any:
        pass

    @abstractmethod
    def _author_rids(self, author_rids: List[str]) -> Any:
        pass

    @abstractmethod
    def _is_archived(self, is_archived: bool) -> Any:
        pass


scout_checks_api_ChecklistSearchQueryVisitor.__name__ = "ChecklistSearchQueryVisitor"
scout_checks_api_ChecklistSearchQueryVisitor.__qualname__ = "ChecklistSearchQueryVisitor"
scout_checks_api_ChecklistSearchQueryVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistService(Service):
    """The Checklist Service is responsible for managing checklists and checks.
A checklist is a collection of checks that can be executed against a set of data sources.
    """

    def create(self, auth_header: str, request: "scout_checks_api_CreateChecklistRequest") -> "scout_checks_api_VersionedChecklist":
        """Creates a new checklist with the provided checks.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def commit(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_CommitChecklistRequest", branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """Creates a permanent commit with a commit message. 
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you commit to an archived checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/{checklistRid}/commit'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def save_working_state(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_SaveChecklistRequest", branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """Creates a commit that may be compacted, e.g cleaned up and not exist anymore.
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you save to an archived checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/{checklistRid}/save-working-state'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def merge_to_main(self, auth_header: str, checklist_rid: str, request: "scout_checks_api_MergeToMainRequest") -> "scout_checks_api_VersionedChecklist":
        """Merges the given branch to the "main" branch.
Throws if the checklist or branch doesn't exist.
Throws if the latest commit doesn't match the provided id.
Throws if you merge with an archived checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/{checklistRid}/merge-to-main'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def update_data_source_ref_names(self, auth_header: str, checklist_rid: str, ref_name_updates: Dict[str, str], branch: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """Updates the data source ref names for all checks within a checklist.
Throws if the checklist doesn't exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
        }

        _path_params: Dict[str, str] = {
            'checklistRid': quote(str(_conjure_encoder.default(checklist_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(ref_name_updates)

        _path = '/scout/v1/checklists/{checklistRid}/update-ref-names'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_checks_api_UpdateChecklistMetadataRequest", rid: str) -> "scout_checks_api_ChecklistMetadata":
        """Updates the metadata of a checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/{rid}/update-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_ChecklistMetadata, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str, branch: Optional[str] = None, commit: Optional[str] = None) -> "scout_checks_api_VersionedChecklist":
        """Specify at most one of (branch, commit).
If neither is specified, branch = "main" is the default.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'branch': _conjure_encoder.default(branch),
            'commit': _conjure_encoder.default(commit),
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/checklists/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklist, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, checklist_refs: List["scout_checks_api_PinnedChecklistRef"] = None) -> List["scout_checks_api_VersionedChecklist"]:
        """Returns the pinned commit for each provided checklist reference.
        """
        checklist_refs = checklist_refs if checklist_refs is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(checklist_refs)

        _path = '/scout/v1/checklists/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_checks_api_VersionedChecklist], self._return_none_for_unknown_union_types)

    def batch_get_metadata(self, auth_header: str, request: "scout_checks_api_BatchGetChecklistMetadataRequest") -> "scout_checks_api_BatchGetChecklistMetadataResponse":
        """Returns the metadata for each provided checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/batch-get-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_BatchGetChecklistMetadataResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_checks_api_SearchChecklistsRequest") -> "scout_checks_api_VersionedChecklistPage":
        """Results will be the latest commit on main for each checklist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_VersionedChecklistPage, self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, request: "scout_checks_api_ArchiveChecklistsRequest") -> None:
        """Archives the provided checklists.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, request: "scout_checks_api_UnarchiveChecklistsRequest") -> None:
        """Unarchives the provided checklists.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/checklists/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_check(self, auth_header: str, rid: str) -> "scout_checks_api_Check":
        """Returns the check with the given rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v1/checklists/check/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_Check, self._return_none_for_unknown_union_types)

    def batch_get_checks(self, auth_header: str, rids: List[str] = None) -> List["scout_checks_api_Check"]:
        """Returns the checks with the given rids.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v1/checklists/check/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_checks_api_Check], self._return_none_for_unknown_union_types)

    def get_all_labels_and_properties(self, auth_header: str, workspaces: List[str] = None) -> "scout_checks_api_GetAllLabelsAndPropertiesResponse":
        """Returns all labels and properties.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v1/checklists/get-all-labels-properties'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_GetAllLabelsAndPropertiesResponse, self._return_none_for_unknown_union_types)


scout_checks_api_ChecklistService.__name__ = "ChecklistService"
scout_checks_api_ChecklistService.__qualname__ = "ChecklistService"
scout_checks_api_ChecklistService.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ChecklistVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName),
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'value': ConjureFieldDefinition('value', scout_checks_api_VariableLocator)
        }

    __slots__: List[str] = ['_name', '_display_name', '_value']

    def __init__(self, name: str, value: "scout_checks_api_VariableLocator", display_name: Optional[str] = None) -> None:
        self._name = name
        self._display_name = display_name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def value(self) -> "scout_checks_api_VariableLocator":
        return self._value


scout_checks_api_ChecklistVariable.__name__ = "ChecklistVariable"
scout_checks_api_ChecklistVariable.__qualname__ = "ChecklistVariable"
scout_checks_api_ChecklistVariable.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CommitChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit_message': ConjureFieldDefinition('commitMessage', str),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_UpdateChecklistEntryRequest]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_commit_message', '_checks', '_checklist_variables', '_latest_commit']

    def __init__(self, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_UpdateChecklistEntryRequest"], commit_message: str, latest_commit: Optional[str] = None) -> None:
        self._commit_message = commit_message
        self._checks = checks
        self._checklist_variables = checklist_variables
        self._latest_commit = latest_commit

    @builtins.property
    def commit_message(self) -> str:
        return self._commit_message

    @builtins.property
    def checks(self) -> List["scout_checks_api_UpdateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """Variables that can be used in checks. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_checks_api_CommitChecklistRequest.__name__ = "CommitChecklistRequest"
scout_checks_api_CommitChecklistRequest.__qualname__ = "CommitChecklistRequest"
scout_checks_api_CommitChecklistRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_Completed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'result': ConjureFieldDefinition('result', scout_checks_api_JobResult),
            'execution_start_time': ConjureFieldDefinition('executionStartTime', str),
            'execution_end_time': ConjureFieldDefinition('executionEndTime', str)
        }

    __slots__: List[str] = ['_result', '_execution_start_time', '_execution_end_time']

    def __init__(self, execution_end_time: str, execution_start_time: str, result: "scout_checks_api_JobResult") -> None:
        self._result = result
        self._execution_start_time = execution_start_time
        self._execution_end_time = execution_end_time

    @builtins.property
    def result(self) -> "scout_checks_api_JobResult":
        return self._result

    @builtins.property
    def execution_start_time(self) -> str:
        return self._execution_start_time

    @builtins.property
    def execution_end_time(self) -> str:
        return self._execution_end_time


scout_checks_api_Completed.__name__ = "Completed"
scout_checks_api_Completed.__qualname__ = "Completed"
scout_checks_api_Completed.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_checks_api_CheckContext)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_checks_api_CheckContext", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_checks_api_CheckContext":
        return self._context


scout_checks_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_checks_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_checks_api_ComputeNodeWithContext.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CreateCheckRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'generated_event_type': ConjureFieldDefinition('generatedEventType', OptionalTypeWrapper[event_EventType]),
            'generated_event_labels': ConjureFieldDefinition('generatedEventLabels', OptionalTypeWrapper[List[api_Label]]),
            'condition': ConjureFieldDefinition('condition', OptionalTypeWrapper[scout_checks_api_UnresolvedCheckCondition])
        }

    __slots__: List[str] = ['_check_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_priority', '_generated_event_type', '_generated_event_labels', '_condition']

    def __init__(self, description: str, priority: "scout_api_Priority", title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None, check_lineage_rid: Optional[str] = None, condition: Optional["scout_checks_api_UnresolvedCheckCondition"] = None, generated_event_labels: Optional[List[str]] = None, generated_event_type: Optional["event_EventType"] = None) -> None:
        self._check_lineage_rid = check_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._priority = priority
        self._generated_event_type = generated_event_type
        self._generated_event_labels = generated_event_labels
        self._condition = condition

    @builtins.property
    def check_lineage_rid(self) -> Optional[str]:
        """Identifies the lineage of checks this check belongs to. If not specified, a new lineage will be created.
This is named checkLineageRid for historical reasons but is actually a UUID.
        """
        return self._check_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def priority(self) -> "scout_api_Priority":
        return self._priority

    @builtins.property
    def generated_event_type(self) -> Optional["event_EventType"]:
        """The event type that will be used for events generated from an execution of this check.
If the check is executed through a data review, the event will have this type.
Defaults to ERROR.
        """
        return self._generated_event_type

    @builtins.property
    def generated_event_labels(self) -> Optional[List[str]]:
        return self._generated_event_labels

    @builtins.property
    def condition(self) -> Optional["scout_checks_api_UnresolvedCheckCondition"]:
        """This field should not be omitted.
        """
        return self._condition


scout_checks_api_CreateCheckRequest.__name__ = "CreateCheckRequest"
scout_checks_api_CreateCheckRequest.__qualname__ = "CreateCheckRequest"
scout_checks_api_CreateCheckRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CreateChecklistEntryRequest(ConjureUnionType):
    _create_check: Optional["scout_checks_api_CreateCheckRequest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_check': ConjureFieldDefinition('createCheck', scout_checks_api_CreateCheckRequest)
        }

    def __init__(
            self,
            create_check: Optional["scout_checks_api_CreateCheckRequest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_check is not None:
                self._create_check = create_check
                self._type = 'createCheck'

        elif type_of_union == 'createCheck':
            if create_check is None:
                raise ValueError('a union value must not be None')
            self._create_check = create_check
            self._type = 'createCheck'

    @builtins.property
    def create_check(self) -> Optional["scout_checks_api_CreateCheckRequest"]:
        return self._create_check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_CreateChecklistEntryRequestVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_CreateChecklistEntryRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createCheck' and self.create_check is not None:
            return visitor._create_check(self.create_check)


scout_checks_api_CreateChecklistEntryRequest.__name__ = "CreateChecklistEntryRequest"
scout_checks_api_CreateChecklistEntryRequest.__qualname__ = "CreateChecklistEntryRequest"
scout_checks_api_CreateChecklistEntryRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CreateChecklistEntryRequestVisitor:

    @abstractmethod
    def _create_check(self, create_check: "scout_checks_api_CreateCheckRequest") -> Any:
        pass


scout_checks_api_CreateChecklistEntryRequestVisitor.__name__ = "CreateChecklistEntryRequestVisitor"
scout_checks_api_CreateChecklistEntryRequestVisitor.__qualname__ = "CreateChecklistEntryRequestVisitor"
scout_checks_api_CreateChecklistEntryRequestVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_CreateChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit_message': ConjureFieldDefinition('commitMessage', str),
            'assignee_rid': ConjureFieldDefinition('assigneeRid', scout_rids_api_UserRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_CreateChecklistEntryRequest]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_commit_message', '_assignee_rid', '_title', '_description', '_checks', '_properties', '_labels', '_checklist_variables', '_is_published', '_workspace']

    def __init__(self, assignee_rid: str, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_CreateChecklistEntryRequest"], commit_message: str, description: str, labels: List[str], properties: Dict[str, str], title: str, is_published: Optional[bool] = None, workspace: Optional[str] = None) -> None:
        self._commit_message = commit_message
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._checks = checks
        self._properties = properties
        self._labels = labels
        self._checklist_variables = checklist_variables
        self._is_published = is_published
        self._workspace = workspace

    @builtins.property
    def commit_message(self) -> str:
        return self._commit_message

    @builtins.property
    def assignee_rid(self) -> str:
        return self._assignee_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def checks(self) -> List["scout_checks_api_CreateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """Variables that can be used in checks. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def is_published(self) -> Optional[bool]:
        """Default value is true.
        """
        return self._is_published

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the checklist. If not provided, the checklist will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


scout_checks_api_CreateChecklistRequest.__name__ = "CreateChecklistRequest"
scout_checks_api_CreateChecklistRequest.__qualname__ = "CreateChecklistRequest"
scout_checks_api_CreateChecklistRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_Failed(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'failure_message': ConjureFieldDefinition('failureMessage', OptionalTypeWrapper[str]),
            'execution_start_time': ConjureFieldDefinition('executionStartTime', OptionalTypeWrapper[str]),
            'execution_end_time': ConjureFieldDefinition('executionEndTime', str)
        }

    __slots__: List[str] = ['_failure_message', '_execution_start_time', '_execution_end_time']

    def __init__(self, execution_end_time: str, execution_start_time: Optional[str] = None, failure_message: Optional[str] = None) -> None:
        self._failure_message = failure_message
        self._execution_start_time = execution_start_time
        self._execution_end_time = execution_end_time

    @builtins.property
    def failure_message(self) -> Optional[str]:
        return self._failure_message

    @builtins.property
    def execution_start_time(self) -> Optional[str]:
        return self._execution_start_time

    @builtins.property
    def execution_end_time(self) -> str:
        return self._execution_end_time


scout_checks_api_Failed.__name__ = "Failed"
scout_checks_api_Failed.__qualname__ = "Failed"
scout_checks_api_Failed.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_Function(ConjureBeanType):
    """This function type is unsupported.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_FunctionRid),
            'function_lineage_rid': ConjureFieldDefinition('functionLineageRid', scout_rids_api_FunctionLineageRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'auto_generated_title': ConjureFieldDefinition('autoGeneratedTitle', OptionalTypeWrapper[str]),
            'auto_generated_description': ConjureFieldDefinition('autoGeneratedDescription', OptionalTypeWrapper[str]),
            'function_node': ConjureFieldDefinition('functionNode', scout_checks_api_FunctionNode)
        }

    __slots__: List[str] = ['_rid', '_function_lineage_rid', '_title', '_description', '_auto_generated_title', '_auto_generated_description', '_function_node']

    def __init__(self, description: str, function_lineage_rid: str, function_node: "scout_checks_api_FunctionNode", rid: str, title: str, auto_generated_description: Optional[str] = None, auto_generated_title: Optional[str] = None) -> None:
        self._rid = rid
        self._function_lineage_rid = function_lineage_rid
        self._title = title
        self._description = description
        self._auto_generated_title = auto_generated_title
        self._auto_generated_description = auto_generated_description
        self._function_node = function_node

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def function_lineage_rid(self) -> str:
        return self._function_lineage_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def auto_generated_title(self) -> Optional[str]:
        return self._auto_generated_title

    @builtins.property
    def auto_generated_description(self) -> Optional[str]:
        return self._auto_generated_description

    @builtins.property
    def function_node(self) -> "scout_checks_api_FunctionNode":
        return self._function_node


scout_checks_api_Function.__name__ = "Function"
scout_checks_api_Function.__qualname__ = "Function"
scout_checks_api_Function.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_FunctionNode(ConjureUnionType):
    _enum: Optional["scout_compute_api_EnumSeries"] = None
    _numeric: Optional["scout_compute_api_NumericSeries"] = None
    _ranges: Optional["scout_compute_api_RangeSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeries),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeries),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries)
        }

    def __init__(
            self,
            enum: Optional["scout_compute_api_EnumSeries"] = None,
            numeric: Optional["scout_compute_api_NumericSeries"] = None,
            ranges: Optional["scout_compute_api_RangeSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum is not None) + (numeric is not None) + (ranges is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'

        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeries"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeries"]:
        return self._numeric

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_RangeSeries"]:
        return self._ranges

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_FunctionNodeVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_FunctionNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)


scout_checks_api_FunctionNode.__name__ = "FunctionNode"
scout_checks_api_FunctionNode.__qualname__ = "FunctionNode"
scout_checks_api_FunctionNode.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_FunctionNodeVisitor:

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeries") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeries") -> Any:
        pass

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_RangeSeries") -> Any:
        pass


scout_checks_api_FunctionNodeVisitor.__name__ = "FunctionNodeVisitor"
scout_checks_api_FunctionNodeVisitor.__qualname__ = "FunctionNodeVisitor"
scout_checks_api_FunctionNodeVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_checks_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_checks_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_checks_api_GetAllLabelsAndPropertiesResponse.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_InProgress(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_checks_api_InProgress.__name__ = "InProgress"
scout_checks_api_InProgress.__qualname__ = "InProgress"
scout_checks_api_InProgress.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobReport(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_status': ConjureFieldDefinition('jobStatus', scout_checks_api_JobStatus),
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'submitted_at': ConjureFieldDefinition('submittedAt', str)
        }

    __slots__: List[str] = ['_job_status', '_job_rid', '_submitted_at']

    def __init__(self, job_rid: str, job_status: "scout_checks_api_JobStatus", submitted_at: str) -> None:
        self._job_status = job_status
        self._job_rid = job_rid
        self._submitted_at = submitted_at

    @builtins.property
    def job_status(self) -> "scout_checks_api_JobStatus":
        return self._job_status

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def submitted_at(self) -> str:
        return self._submitted_at


scout_checks_api_JobReport.__name__ = "JobReport"
scout_checks_api_JobReport.__qualname__ = "JobReport"
scout_checks_api_JobReport.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobResult(ConjureUnionType):
    _check_job_result: Optional["scout_checks_api_CheckJobResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_job_result': ConjureFieldDefinition('checkJobResult', scout_checks_api_CheckJobResult)
        }

    def __init__(
            self,
            check_job_result: Optional["scout_checks_api_CheckJobResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check_job_result is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check_job_result is not None:
                self._check_job_result = check_job_result
                self._type = 'checkJobResult'

        elif type_of_union == 'checkJobResult':
            if check_job_result is None:
                raise ValueError('a union value must not be None')
            self._check_job_result = check_job_result
            self._type = 'checkJobResult'

    @builtins.property
    def check_job_result(self) -> Optional["scout_checks_api_CheckJobResult"]:
        return self._check_job_result

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobResultVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checkJobResult' and self.check_job_result is not None:
            return visitor._check_job_result(self.check_job_result)


scout_checks_api_JobResult.__name__ = "JobResult"
scout_checks_api_JobResult.__qualname__ = "JobResult"
scout_checks_api_JobResult.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobResultVisitor:

    @abstractmethod
    def _check_job_result(self, check_job_result: "scout_checks_api_CheckJobResult") -> Any:
        pass


scout_checks_api_JobResultVisitor.__name__ = "JobResultVisitor"
scout_checks_api_JobResultVisitor.__qualname__ = "JobResultVisitor"
scout_checks_api_JobResultVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobSpec(ConjureUnionType):
    _check_v2: Optional["scout_checks_api_CheckJobSpec"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_v2': ConjureFieldDefinition('checkV2', scout_checks_api_CheckJobSpec)
        }

    def __init__(
            self,
            check_v2: Optional["scout_checks_api_CheckJobSpec"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (check_v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if check_v2 is not None:
                self._check_v2 = check_v2
                self._type = 'checkV2'

        elif type_of_union == 'checkV2':
            if check_v2 is None:
                raise ValueError('a union value must not be None')
            self._check_v2 = check_v2
            self._type = 'checkV2'

    @builtins.property
    def check_v2(self) -> Optional["scout_checks_api_CheckJobSpec"]:
        return self._check_v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobSpecVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobSpecVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checkV2' and self.check_v2 is not None:
            return visitor._check_v2(self.check_v2)


scout_checks_api_JobSpec.__name__ = "JobSpec"
scout_checks_api_JobSpec.__qualname__ = "JobSpec"
scout_checks_api_JobSpec.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobSpecVisitor:

    @abstractmethod
    def _check_v2(self, check_v2: "scout_checks_api_CheckJobSpec") -> Any:
        pass


scout_checks_api_JobSpecVisitor.__name__ = "JobSpecVisitor"
scout_checks_api_JobSpecVisitor.__qualname__ = "JobSpecVisitor"
scout_checks_api_JobSpecVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobStatus(ConjureUnionType):
    _in_progress: Optional["scout_checks_api_InProgress"] = None
    _completed: Optional["scout_checks_api_Completed"] = None
    _failed: Optional["scout_checks_api_Failed"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'in_progress': ConjureFieldDefinition('inProgress', scout_checks_api_InProgress),
            'completed': ConjureFieldDefinition('completed', scout_checks_api_Completed),
            'failed': ConjureFieldDefinition('failed', scout_checks_api_Failed)
        }

    def __init__(
            self,
            in_progress: Optional["scout_checks_api_InProgress"] = None,
            completed: Optional["scout_checks_api_Completed"] = None,
            failed: Optional["scout_checks_api_Failed"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (in_progress is not None) + (completed is not None) + (failed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'
            if completed is not None:
                self._completed = completed
                self._type = 'completed'
            if failed is not None:
                self._failed = failed
                self._type = 'failed'

        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'
        elif type_of_union == 'completed':
            if completed is None:
                raise ValueError('a union value must not be None')
            self._completed = completed
            self._type = 'completed'
        elif type_of_union == 'failed':
            if failed is None:
                raise ValueError('a union value must not be None')
            self._failed = failed
            self._type = 'failed'

    @builtins.property
    def in_progress(self) -> Optional["scout_checks_api_InProgress"]:
        return self._in_progress

    @builtins.property
    def completed(self) -> Optional["scout_checks_api_Completed"]:
        return self._completed

    @builtins.property
    def failed(self) -> Optional["scout_checks_api_Failed"]:
        return self._failed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_JobStatusVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_JobStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)
        if self._type == 'completed' and self.completed is not None:
            return visitor._completed(self.completed)
        if self._type == 'failed' and self.failed is not None:
            return visitor._failed(self.failed)


scout_checks_api_JobStatus.__name__ = "JobStatus"
scout_checks_api_JobStatus.__qualname__ = "JobStatus"
scout_checks_api_JobStatus.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_JobStatusVisitor:

    @abstractmethod
    def _in_progress(self, in_progress: "scout_checks_api_InProgress") -> Any:
        pass

    @abstractmethod
    def _completed(self, completed: "scout_checks_api_Completed") -> Any:
        pass

    @abstractmethod
    def _failed(self, failed: "scout_checks_api_Failed") -> Any:
        pass


scout_checks_api_JobStatusVisitor.__name__ = "JobStatusVisitor"
scout_checks_api_JobStatusVisitor.__qualname__ = "JobStatusVisitor"
scout_checks_api_JobStatusVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_MergeToMainRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit_on_main': ConjureFieldDefinition('latestCommitOnMain', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_branch_name', '_message', '_latest_commit_on_main']

    def __init__(self, branch_name: str, message: str, latest_commit_on_main: Optional[str] = None) -> None:
        self._branch_name = branch_name
        self._message = message
        self._latest_commit_on_main = latest_commit_on_main

    @builtins.property
    def branch_name(self) -> str:
        """If "main", the request will throw.
        """
        return self._branch_name

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit_on_main(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit_on_main


scout_checks_api_MergeToMainRequest.__name__ = "MergeToMainRequest"
scout_checks_api_MergeToMainRequest.__qualname__ = "MergeToMainRequest"
scout_checks_api_MergeToMainRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_api_ChannelLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_api_ChannelLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_api_ChannelLocator"]:
        return self._variables


scout_checks_api_NumRangesConditionV1.__name__ = "NumRangesConditionV1"
scout_checks_api_NumRangesConditionV1.__qualname__ = "NumRangesConditionV1"
scout_checks_api_NumRangesConditionV1.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_VariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables


scout_checks_api_NumRangesConditionV2.__name__ = "NumRangesConditionV2"
scout_checks_api_NumRangesConditionV2.__qualname__ = "NumRangesConditionV2"
scout_checks_api_NumRangesConditionV2.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_NumRangesConditionV3(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_VariableLocator]),
            'function_variables': ConjureFieldDefinition('functionVariables', OptionalTypeWrapper[Dict[scout_compute_api_FunctionReference, scout_checks_api_CheckContext]])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables', '_function_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_RangeSeries", threshold: int, variables: Dict[str, "scout_checks_api_VariableLocator"], function_variables: Optional[Dict[str, "scout_checks_api_CheckContext"]] = None) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_VariableLocator"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Optional[Dict[str, "scout_checks_api_CheckContext"]]:
        return self._function_variables


scout_checks_api_NumRangesConditionV3.__name__ = "NumRangesConditionV3"
scout_checks_api_NumRangesConditionV3.__qualname__ = "NumRangesConditionV3"
scout_checks_api_NumRangesConditionV3.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_ParameterizedNumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'implementations': ConjureFieldDefinition('implementations', List[scout_checks_api_CheckContext])
        }

    __slots__: List[str] = ['_ranges', '_implementations']

    def __init__(self, implementations: List["scout_checks_api_CheckContext"], ranges: "scout_compute_api_RangeSeries") -> None:
        self._ranges = ranges
        self._implementations = implementations

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def implementations(self) -> List["scout_checks_api_CheckContext"]:
        """Each permutation of check context in the list will be executed as a new a stand-alone check. Violations
produced will be associated with the context of the index.
        """
        return self._implementations


scout_checks_api_ParameterizedNumRangesConditionV1.__name__ = "ParameterizedNumRangesConditionV1"
scout_checks_api_ParameterizedNumRangesConditionV1.__qualname__ = "ParameterizedNumRangesConditionV1"
scout_checks_api_ParameterizedNumRangesConditionV1.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_PinnedChecklistRef(ConjureBeanType):
    """A reference to a checklist that is pinned to a specific commit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_rid', '_commit']

    def __init__(self, commit: str, rid: str) -> None:
        self._rid = rid
        self._commit = commit

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def commit(self) -> str:
        return self._commit


scout_checks_api_PinnedChecklistRef.__name__ = "PinnedChecklistRef"
scout_checks_api_PinnedChecklistRef.__qualname__ = "PinnedChecklistRef"
scout_checks_api_PinnedChecklistRef.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SaveChecklistRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_UpdateChecklistEntryRequest]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_UnresolvedChecklistVariable]),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_checks', '_checklist_variables', '_latest_commit']

    def __init__(self, checklist_variables: List["scout_checks_api_UnresolvedChecklistVariable"], checks: List["scout_checks_api_UpdateChecklistEntryRequest"], latest_commit: Optional[str] = None) -> None:
        self._checks = checks
        self._checklist_variables = checklist_variables
        self._latest_commit = latest_commit

    @builtins.property
    def checks(self) -> List["scout_checks_api_UpdateChecklistEntryRequest"]:
        return self._checks

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_UnresolvedChecklistVariable"]:
        """Variables that can be used in checks. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_checks_api_SaveChecklistRequest.__name__ = "SaveChecklistRequest"
scout_checks_api_SaveChecklistRequest.__qualname__ = "SaveChecklistRequest"
scout_checks_api_SaveChecklistRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SearchChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_checks_api_ChecklistSearchQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_checks_api_SortOptions]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size', '_archived_statuses']

    def __init__(self, query: "scout_checks_api_ChecklistSearchQuery", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["scout_checks_api_SortOptions"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "scout_checks_api_ChecklistSearchQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["scout_checks_api_SortOptions"]:
        """If not present, will sort by LAST_USED in descending order.
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        return self._archived_statuses


scout_checks_api_SearchChecklistsRequest.__name__ = "SearchChecklistsRequest"
scout_checks_api_SearchChecklistsRequest.__qualname__ = "SearchChecklistsRequest"
scout_checks_api_SearchChecklistsRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    LAST_USED = 'LAST_USED'
    '''LAST_USED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checks_api_SortField.__name__ = "SortField"
scout_checks_api_SortField.__qualname__ = "SortField"
scout_checks_api_SortField.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_checks_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_checks_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_checks_api_SortField":
        return self._field


scout_checks_api_SortOptions.__name__ = "SortOptions"
scout_checks_api_SortOptions.__qualname__ = "SortOptions"
scout_checks_api_SortOptions.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SubmitJobsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'jobs_to_execute': ConjureFieldDefinition('jobsToExecute', List[scout_checks_api_JobSpec])
        }

    __slots__: List[str] = ['_jobs_to_execute']

    def __init__(self, jobs_to_execute: List["scout_checks_api_JobSpec"]) -> None:
        self._jobs_to_execute = jobs_to_execute

    @builtins.property
    def jobs_to_execute(self) -> List["scout_checks_api_JobSpec"]:
        return self._jobs_to_execute


scout_checks_api_SubmitJobsRequest.__name__ = "SubmitJobsRequest"
scout_checks_api_SubmitJobsRequest.__qualname__ = "SubmitJobsRequest"
scout_checks_api_SubmitJobsRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SubmitJobsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'jobs': ConjureFieldDefinition('jobs', List[scout_checks_api_SubmittedJob])
        }

    __slots__: List[str] = ['_jobs']

    def __init__(self, jobs: List["scout_checks_api_SubmittedJob"]) -> None:
        self._jobs = jobs

    @builtins.property
    def jobs(self) -> List["scout_checks_api_SubmittedJob"]:
        return self._jobs


scout_checks_api_SubmitJobsResponse.__name__ = "SubmitJobsResponse"
scout_checks_api_SubmitJobsResponse.__qualname__ = "SubmitJobsResponse"
scout_checks_api_SubmitJobsResponse.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_SubmittedJob(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'job_spec': ConjureFieldDefinition('jobSpec', scout_checks_api_JobSpec)
        }

    __slots__: List[str] = ['_job_rid', '_job_spec']

    def __init__(self, job_rid: str, job_spec: "scout_checks_api_JobSpec") -> None:
        self._job_rid = job_rid
        self._job_spec = job_spec

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def job_spec(self) -> "scout_checks_api_JobSpec":
        return self._job_spec


scout_checks_api_SubmittedJob.__name__ = "SubmittedJob"
scout_checks_api_SubmittedJob.__qualname__ = "SubmittedJob"
scout_checks_api_SubmittedJob.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_TimestampLocator(ConjureEnumType):

    RUN_START = 'RUN_START'
    '''RUN_START'''
    RUN_END = 'RUN_END'
    '''RUN_END'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_checks_api_TimestampLocator.__name__ = "TimestampLocator"
scout_checks_api_TimestampLocator.__qualname__ = "TimestampLocator"
scout_checks_api_TimestampLocator.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnarchiveChecklistsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_ChecklistRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_checks_api_UnarchiveChecklistsRequest.__name__ = "UnarchiveChecklistsRequest"
scout_checks_api_UnarchiveChecklistsRequest.__qualname__ = "UnarchiveChecklistsRequest"
scout_checks_api_UnarchiveChecklistsRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedCheckCondition(ConjureUnionType):
    _num_ranges_v2: Optional["scout_checks_api_UnresolvedNumRangesConditionV2"] = None
    _num_ranges_v3: Optional["scout_checks_api_UnresolvedNumRangesConditionV3"] = None
    _parameterized_num_ranges_v1: Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_ranges_v2': ConjureFieldDefinition('numRangesV2', scout_checks_api_UnresolvedNumRangesConditionV2),
            'num_ranges_v3': ConjureFieldDefinition('numRangesV3', scout_checks_api_UnresolvedNumRangesConditionV3),
            'parameterized_num_ranges_v1': ConjureFieldDefinition('parameterizedNumRangesV1', scout_checks_api_UnresolvedParameterizedNumRangesConditionV1)
        }

    def __init__(
            self,
            num_ranges_v2: Optional["scout_checks_api_UnresolvedNumRangesConditionV2"] = None,
            num_ranges_v3: Optional["scout_checks_api_UnresolvedNumRangesConditionV3"] = None,
            parameterized_num_ranges_v1: Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (num_ranges_v2 is not None) + (num_ranges_v3 is not None) + (parameterized_num_ranges_v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if num_ranges_v2 is not None:
                self._num_ranges_v2 = num_ranges_v2
                self._type = 'numRangesV2'
            if num_ranges_v3 is not None:
                self._num_ranges_v3 = num_ranges_v3
                self._type = 'numRangesV3'
            if parameterized_num_ranges_v1 is not None:
                self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
                self._type = 'parameterizedNumRangesV1'

        elif type_of_union == 'numRangesV2':
            if num_ranges_v2 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v2 = num_ranges_v2
            self._type = 'numRangesV2'
        elif type_of_union == 'numRangesV3':
            if num_ranges_v3 is None:
                raise ValueError('a union value must not be None')
            self._num_ranges_v3 = num_ranges_v3
            self._type = 'numRangesV3'
        elif type_of_union == 'parameterizedNumRangesV1':
            if parameterized_num_ranges_v1 is None:
                raise ValueError('a union value must not be None')
            self._parameterized_num_ranges_v1 = parameterized_num_ranges_v1
            self._type = 'parameterizedNumRangesV1'

    @builtins.property
    def num_ranges_v2(self) -> Optional["scout_checks_api_UnresolvedNumRangesConditionV2"]:
        return self._num_ranges_v2

    @builtins.property
    def num_ranges_v3(self) -> Optional["scout_checks_api_UnresolvedNumRangesConditionV3"]:
        return self._num_ranges_v3

    @builtins.property
    def parameterized_num_ranges_v1(self) -> Optional["scout_checks_api_UnresolvedParameterizedNumRangesConditionV1"]:
        return self._parameterized_num_ranges_v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UnresolvedCheckConditionVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UnresolvedCheckConditionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numRangesV2' and self.num_ranges_v2 is not None:
            return visitor._num_ranges_v2(self.num_ranges_v2)
        if self._type == 'numRangesV3' and self.num_ranges_v3 is not None:
            return visitor._num_ranges_v3(self.num_ranges_v3)
        if self._type == 'parameterizedNumRangesV1' and self.parameterized_num_ranges_v1 is not None:
            return visitor._parameterized_num_ranges_v1(self.parameterized_num_ranges_v1)


scout_checks_api_UnresolvedCheckCondition.__name__ = "UnresolvedCheckCondition"
scout_checks_api_UnresolvedCheckCondition.__qualname__ = "UnresolvedCheckCondition"
scout_checks_api_UnresolvedCheckCondition.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedCheckConditionVisitor:

    @abstractmethod
    def _num_ranges_v2(self, num_ranges_v2: "scout_checks_api_UnresolvedNumRangesConditionV2") -> Any:
        pass

    @abstractmethod
    def _num_ranges_v3(self, num_ranges_v3: "scout_checks_api_UnresolvedNumRangesConditionV3") -> Any:
        pass

    @abstractmethod
    def _parameterized_num_ranges_v1(self, parameterized_num_ranges_v1: "scout_checks_api_UnresolvedParameterizedNumRangesConditionV1") -> Any:
        pass


scout_checks_api_UnresolvedCheckConditionVisitor.__name__ = "UnresolvedCheckConditionVisitor"
scout_checks_api_UnresolvedCheckConditionVisitor.__qualname__ = "UnresolvedCheckConditionVisitor"
scout_checks_api_UnresolvedCheckConditionVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedChecklistVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName),
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'value': ConjureFieldDefinition('value', scout_checks_api_UnresolvedVariableLocator)
        }

    __slots__: List[str] = ['_name', '_display_name', '_value']

    def __init__(self, name: str, value: "scout_checks_api_UnresolvedVariableLocator", display_name: Optional[str] = None) -> None:
        self._name = name
        self._display_name = display_name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def value(self) -> "scout_checks_api_UnresolvedVariableLocator":
        return self._value


scout_checks_api_UnresolvedChecklistVariable.__name__ = "UnresolvedChecklistVariable"
scout_checks_api_UnresolvedChecklistVariable.__qualname__ = "UnresolvedChecklistVariable"
scout_checks_api_UnresolvedChecklistVariable.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_checks_api_UnresolvedVariables)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_checks_api_UnresolvedVariables", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_checks_api_UnresolvedVariables":
        return self._context


scout_checks_api_UnresolvedComputeNodeWithContext.__name__ = "UnresolvedComputeNodeWithContext"
scout_checks_api_UnresolvedComputeNodeWithContext.__qualname__ = "UnresolvedComputeNodeWithContext"
scout_checks_api_UnresolvedComputeNodeWithContext.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedNumRangesConditionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_RangesNode),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_deprecated_RangesNode", threshold: int, variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        return self._variables


scout_checks_api_UnresolvedNumRangesConditionV2.__name__ = "UnresolvedNumRangesConditionV2"
scout_checks_api_UnresolvedNumRangesConditionV2.__qualname__ = "UnresolvedNumRangesConditionV2"
scout_checks_api_UnresolvedNumRangesConditionV2.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedNumRangesConditionV3(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'function_spec': ConjureFieldDefinition('functionSpec', object),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator])
        }

    __slots__: List[str] = ['_ranges', '_function_spec', '_threshold', '_operator', '_variables']

    def __init__(self, function_spec: Any, operator: "scout_compute_api_ThresholdOperator", ranges: "scout_compute_api_RangeSeries", threshold: int, variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._ranges = ranges
        self._function_spec = function_spec
        self._threshold = threshold
        self._operator = operator
        self._variables = variables

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def function_spec(self) -> Any:
        return self._function_spec

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        """Default overrides for the variables used in the check condition. These variables can be overridden
at checklist execution time.
        """
        return self._variables


scout_checks_api_UnresolvedNumRangesConditionV3.__name__ = "UnresolvedNumRangesConditionV3"
scout_checks_api_UnresolvedNumRangesConditionV3.__qualname__ = "UnresolvedNumRangesConditionV3"
scout_checks_api_UnresolvedNumRangesConditionV3.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedParameterizedNumRangesConditionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'implementations': ConjureFieldDefinition('implementations', List[scout_checks_api_UnresolvedVariables])
        }

    __slots__: List[str] = ['_ranges', '_implementations']

    def __init__(self, implementations: List["scout_checks_api_UnresolvedVariables"], ranges: "scout_compute_api_RangeSeries") -> None:
        self._ranges = ranges
        self._implementations = implementations

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def implementations(self) -> List["scout_checks_api_UnresolvedVariables"]:
        """Each permutation of check context in the list will be executed as a new a stand-alone check. Violations
produced will be associated with the context of the index.
        """
        return self._implementations


scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__name__ = "UnresolvedParameterizedNumRangesConditionV1"
scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__qualname__ = "UnresolvedParameterizedNumRangesConditionV1"
scout_checks_api_UnresolvedParameterizedNumRangesConditionV1.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedVariableLocator(ConjureUnionType):
    _checklist_variable: Optional[str] = None
    _compute_node: Optional["scout_checks_api_UnresolvedComputeNodeWithContext"] = None
    _series: Optional["scout_api_ChannelLocator"] = None
    _timestamp: Optional["scout_checks_api_TimestampLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_variable': ConjureFieldDefinition('checklistVariable', scout_compute_api_VariableName),
            'compute_node': ConjureFieldDefinition('computeNode', scout_checks_api_UnresolvedComputeNodeWithContext),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator),
            'timestamp': ConjureFieldDefinition('timestamp', scout_checks_api_TimestampLocator)
        }

    def __init__(
            self,
            checklist_variable: Optional[str] = None,
            compute_node: Optional["scout_checks_api_UnresolvedComputeNodeWithContext"] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            timestamp: Optional["scout_checks_api_TimestampLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (checklist_variable is not None) + (compute_node is not None) + (series is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if checklist_variable is not None:
                self._checklist_variable = checklist_variable
                self._type = 'checklistVariable'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if series is not None:
                self._series = series
                self._type = 'series'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'checklistVariable':
            if checklist_variable is None:
                raise ValueError('a union value must not be None')
            self._checklist_variable = checklist_variable
            self._type = 'checklistVariable'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def checklist_variable(self) -> Optional[str]:
        """A pointer to a variable in the checklist.
        """
        return self._checklist_variable

    @builtins.property
    def compute_node(self) -> Optional["scout_checks_api_UnresolvedComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    @builtins.property
    def timestamp(self) -> Optional["scout_checks_api_TimestampLocator"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UnresolvedVariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UnresolvedVariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checklistVariable' and self.checklist_variable is not None:
            return visitor._checklist_variable(self.checklist_variable)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_checks_api_UnresolvedVariableLocator.__name__ = "UnresolvedVariableLocator"
scout_checks_api_UnresolvedVariableLocator.__qualname__ = "UnresolvedVariableLocator"
scout_checks_api_UnresolvedVariableLocator.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedVariableLocatorVisitor:

    @abstractmethod
    def _checklist_variable(self, checklist_variable: str) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_checks_api_UnresolvedComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "scout_checks_api_TimestampLocator") -> Any:
        pass


scout_checks_api_UnresolvedVariableLocatorVisitor.__name__ = "UnresolvedVariableLocatorVisitor"
scout_checks_api_UnresolvedVariableLocatorVisitor.__qualname__ = "UnresolvedVariableLocatorVisitor"
scout_checks_api_UnresolvedVariableLocatorVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UnresolvedVariables(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_checks_api_UnresolvedVariableLocator])
        }

    __slots__: List[str] = ['_variables']

    def __init__(self, variables: Dict[str, "scout_checks_api_UnresolvedVariableLocator"]) -> None:
        self._variables = variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_checks_api_UnresolvedVariableLocator"]:
        return self._variables


scout_checks_api_UnresolvedVariables.__name__ = "UnresolvedVariables"
scout_checks_api_UnresolvedVariables.__qualname__ = "UnresolvedVariables"
scout_checks_api_UnresolvedVariables.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UpdateChecklistEntryRequest(ConjureUnionType):
    _create_check: Optional["scout_checks_api_CreateCheckRequest"] = None
    _check: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_check': ConjureFieldDefinition('createCheck', scout_checks_api_CreateCheckRequest),
            'check': ConjureFieldDefinition('check', scout_rids_api_CheckRid)
        }

    def __init__(
            self,
            create_check: Optional["scout_checks_api_CreateCheckRequest"] = None,
            check: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_check is not None) + (check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_check is not None:
                self._create_check = create_check
                self._type = 'createCheck'
            if check is not None:
                self._check = check
                self._type = 'check'

        elif type_of_union == 'createCheck':
            if create_check is None:
                raise ValueError('a union value must not be None')
            self._create_check = create_check
            self._type = 'createCheck'
        elif type_of_union == 'check':
            if check is None:
                raise ValueError('a union value must not be None')
            self._check = check
            self._type = 'check'

    @builtins.property
    def create_check(self) -> Optional["scout_checks_api_CreateCheckRequest"]:
        return self._create_check

    @builtins.property
    def check(self) -> Optional[str]:
        return self._check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_UpdateChecklistEntryRequestVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_UpdateChecklistEntryRequestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createCheck' and self.create_check is not None:
            return visitor._create_check(self.create_check)
        if self._type == 'check' and self.check is not None:
            return visitor._check(self.check)


scout_checks_api_UpdateChecklistEntryRequest.__name__ = "UpdateChecklistEntryRequest"
scout_checks_api_UpdateChecklistEntryRequest.__qualname__ = "UpdateChecklistEntryRequest"
scout_checks_api_UpdateChecklistEntryRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UpdateChecklistEntryRequestVisitor:

    @abstractmethod
    def _create_check(self, create_check: "scout_checks_api_CreateCheckRequest") -> Any:
        pass

    @abstractmethod
    def _check(self, check: str) -> Any:
        pass


scout_checks_api_UpdateChecklistEntryRequestVisitor.__name__ = "UpdateChecklistEntryRequestVisitor"
scout_checks_api_UpdateChecklistEntryRequestVisitor.__qualname__ = "UpdateChecklistEntryRequestVisitor"
scout_checks_api_UpdateChecklistEntryRequestVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_UpdateChecklistMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'assignee_rid': ConjureFieldDefinition('assigneeRid', OptionalTypeWrapper[scout_rids_api_UserRid]),
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_assignee_rid', '_title', '_description', '_properties', '_labels', '_is_published']

    def __init__(self, assignee_rid: Optional[str] = None, description: Optional[str] = None, is_published: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._assignee_rid = assignee_rid
        self._title = title
        self._description = description
        self._properties = properties
        self._labels = labels
        self._is_published = is_published

    @builtins.property
    def assignee_rid(self) -> Optional[str]:
        return self._assignee_rid

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published


scout_checks_api_UpdateChecklistMetadataRequest.__name__ = "UpdateChecklistMetadataRequest"
scout_checks_api_UpdateChecklistMetadataRequest.__qualname__ = "UpdateChecklistMetadataRequest"
scout_checks_api_UpdateChecklistMetadataRequest.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_VariableLocator(ConjureUnionType):
    _checklist_variable: Optional[str] = None
    _compute_node: Optional["scout_checks_api_ComputeNodeWithContext"] = None
    _series: Optional["scout_api_ChannelLocator"] = None
    _timestamp: Optional["scout_checks_api_TimestampLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_variable': ConjureFieldDefinition('checklistVariable', scout_compute_api_VariableName),
            'compute_node': ConjureFieldDefinition('computeNode', scout_checks_api_ComputeNodeWithContext),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator),
            'timestamp': ConjureFieldDefinition('timestamp', scout_checks_api_TimestampLocator)
        }

    def __init__(
            self,
            checklist_variable: Optional[str] = None,
            compute_node: Optional["scout_checks_api_ComputeNodeWithContext"] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            timestamp: Optional["scout_checks_api_TimestampLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (checklist_variable is not None) + (compute_node is not None) + (series is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if checklist_variable is not None:
                self._checklist_variable = checklist_variable
                self._type = 'checklistVariable'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if series is not None:
                self._series = series
                self._type = 'series'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'checklistVariable':
            if checklist_variable is None:
                raise ValueError('a union value must not be None')
            self._checklist_variable = checklist_variable
            self._type = 'checklistVariable'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def checklist_variable(self) -> Optional[str]:
        """A pointer to a checklist level variable.
        """
        return self._checklist_variable

    @builtins.property
    def compute_node(self) -> Optional["scout_checks_api_ComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    @builtins.property
    def timestamp(self) -> Optional["scout_checks_api_TimestampLocator"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_checks_api_VariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_checks_api_VariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'checklistVariable' and self.checklist_variable is not None:
            return visitor._checklist_variable(self.checklist_variable)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_checks_api_VariableLocator.__name__ = "VariableLocator"
scout_checks_api_VariableLocator.__qualname__ = "VariableLocator"
scout_checks_api_VariableLocator.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_VariableLocatorVisitor:

    @abstractmethod
    def _checklist_variable(self, checklist_variable: str) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_checks_api_ComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "scout_checks_api_TimestampLocator") -> Any:
        pass


scout_checks_api_VariableLocatorVisitor.__name__ = "VariableLocatorVisitor"
scout_checks_api_VariableLocatorVisitor.__qualname__ = "VariableLocatorVisitor"
scout_checks_api_VariableLocatorVisitor.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_VersionedChecklist(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_ChecklistRid),
            'metadata': ConjureFieldDefinition('metadata', scout_checks_api_ChecklistMetadata),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit),
            'functions': ConjureFieldDefinition('functions', OptionalTypeWrapper[List[scout_checks_api_Function]]),
            'checks': ConjureFieldDefinition('checks', List[scout_checks_api_ChecklistEntry]),
            'checklist_variables': ConjureFieldDefinition('checklistVariables', List[scout_checks_api_ChecklistVariable])
        }

    __slots__: List[str] = ['_rid', '_metadata', '_commit', '_functions', '_checks', '_checklist_variables']

    def __init__(self, checklist_variables: List["scout_checks_api_ChecklistVariable"], checks: List["scout_checks_api_ChecklistEntry"], commit: "scout_versioning_api_Commit", metadata: "scout_checks_api_ChecklistMetadata", rid: str, functions: Optional[List["scout_checks_api_Function"]] = None) -> None:
        self._rid = rid
        self._metadata = metadata
        self._commit = commit
        self._functions = functions
        self._checks = checks
        self._checklist_variables = checklist_variables

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_checks_api_ChecklistMetadata":
        return self._metadata

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit

    @builtins.property
    def functions(self) -> Optional[List["scout_checks_api_Function"]]:
        return self._functions

    @builtins.property
    def checks(self) -> List["scout_checks_api_ChecklistEntry"]:
        return self._checks

    @builtins.property
    def checklist_variables(self) -> List["scout_checks_api_ChecklistVariable"]:
        """Variables that can be used in checks. Variables are resolved in order of declaration.
If variable `a` depends on variable `b`, then `b` must be defined before `a` in the list.
        """
        return self._checklist_variables


scout_checks_api_VersionedChecklist.__name__ = "VersionedChecklist"
scout_checks_api_VersionedChecklist.__qualname__ = "VersionedChecklist"
scout_checks_api_VersionedChecklist.__module__ = "nominal_api.scout_checks_api"


class scout_checks_api_VersionedChecklistPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'values': ConjureFieldDefinition('values', List[scout_checks_api_VersionedChecklist]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_values', '_next_page_token']

    def __init__(self, values: List["scout_checks_api_VersionedChecklist"], next_page_token: Optional[str] = None) -> None:
        self._values = values
        self._next_page_token = next_page_token

    @builtins.property
    def values(self) -> List["scout_checks_api_VersionedChecklist"]:
        return self._values

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_checks_api_VersionedChecklistPage.__name__ = "VersionedChecklistPage"
scout_checks_api_VersionedChecklistPage.__qualname__ = "VersionedChecklistPage"
scout_checks_api_VersionedChecklistPage.__module__ = "nominal_api.scout_checks_api"


class scout_comparisonnotebook_api_AggregationType(ConjureUnionType):
    _max: Optional["scout_comparisonnotebook_api_Max"] = None
    _min: Optional["scout_comparisonnotebook_api_Min"] = None
    _mean: Optional["scout_comparisonnotebook_api_Mean"] = None
    _standard_deviation: Optional["scout_comparisonnotebook_api_StandardDeviation"] = None
    _count: Optional["scout_comparisonnotebook_api_Count"] = None
    _root_mean_square: Optional["scout_comparisonnotebook_api_RootMeanSquare"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max': ConjureFieldDefinition('max', scout_comparisonnotebook_api_Max),
            'min': ConjureFieldDefinition('min', scout_comparisonnotebook_api_Min),
            'mean': ConjureFieldDefinition('mean', scout_comparisonnotebook_api_Mean),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_comparisonnotebook_api_StandardDeviation),
            'count': ConjureFieldDefinition('count', scout_comparisonnotebook_api_Count),
            'root_mean_square': ConjureFieldDefinition('rootMeanSquare', scout_comparisonnotebook_api_RootMeanSquare)
        }

    def __init__(
            self,
            max: Optional["scout_comparisonnotebook_api_Max"] = None,
            min: Optional["scout_comparisonnotebook_api_Min"] = None,
            mean: Optional["scout_comparisonnotebook_api_Mean"] = None,
            standard_deviation: Optional["scout_comparisonnotebook_api_StandardDeviation"] = None,
            count: Optional["scout_comparisonnotebook_api_Count"] = None,
            root_mean_square: Optional["scout_comparisonnotebook_api_RootMeanSquare"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (max is not None) + (min is not None) + (mean is not None) + (standard_deviation is not None) + (count is not None) + (root_mean_square is not None) != 1:
                raise ValueError('a union must contain a single member')

            if max is not None:
                self._max = max
                self._type = 'max'
            if min is not None:
                self._min = min
                self._type = 'min'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'
            if count is not None:
                self._count = count
                self._type = 'count'
            if root_mean_square is not None:
                self._root_mean_square = root_mean_square
                self._type = 'rootMeanSquare'

        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'
        elif type_of_union == 'count':
            if count is None:
                raise ValueError('a union value must not be None')
            self._count = count
            self._type = 'count'
        elif type_of_union == 'rootMeanSquare':
            if root_mean_square is None:
                raise ValueError('a union value must not be None')
            self._root_mean_square = root_mean_square
            self._type = 'rootMeanSquare'

    @builtins.property
    def max(self) -> Optional["scout_comparisonnotebook_api_Max"]:
        return self._max

    @builtins.property
    def min(self) -> Optional["scout_comparisonnotebook_api_Min"]:
        return self._min

    @builtins.property
    def mean(self) -> Optional["scout_comparisonnotebook_api_Mean"]:
        return self._mean

    @builtins.property
    def standard_deviation(self) -> Optional["scout_comparisonnotebook_api_StandardDeviation"]:
        return self._standard_deviation

    @builtins.property
    def count(self) -> Optional["scout_comparisonnotebook_api_Count"]:
        return self._count

    @builtins.property
    def root_mean_square(self) -> Optional["scout_comparisonnotebook_api_RootMeanSquare"]:
        return self._root_mean_square

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_AggregationTypeVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_AggregationTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)
        if self._type == 'count' and self.count is not None:
            return visitor._count(self.count)
        if self._type == 'rootMeanSquare' and self.root_mean_square is not None:
            return visitor._root_mean_square(self.root_mean_square)


scout_comparisonnotebook_api_AggregationType.__name__ = "AggregationType"
scout_comparisonnotebook_api_AggregationType.__qualname__ = "AggregationType"
scout_comparisonnotebook_api_AggregationType.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_AggregationTypeVisitor:

    @abstractmethod
    def _max(self, max: "scout_comparisonnotebook_api_Max") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_comparisonnotebook_api_Min") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_comparisonnotebook_api_Mean") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_comparisonnotebook_api_StandardDeviation") -> Any:
        pass

    @abstractmethod
    def _count(self, count: "scout_comparisonnotebook_api_Count") -> Any:
        pass

    @abstractmethod
    def _root_mean_square(self, root_mean_square: "scout_comparisonnotebook_api_RootMeanSquare") -> Any:
        pass


scout_comparisonnotebook_api_AggregationTypeVisitor.__name__ = "AggregationTypeVisitor"
scout_comparisonnotebook_api_AggregationTypeVisitor.__qualname__ = "AggregationTypeVisitor"
scout_comparisonnotebook_api_AggregationTypeVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ChannelVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'variable_name': ConjureFieldDefinition('variableName', scout_comparisonnotebook_api_VariableName),
            'value': ConjureFieldDefinition('value', scout_comparisonnotebook_api_ComputeNodeWithContext),
            'data_scope': ConjureFieldDefinition('dataScope', scout_comparisonnotebook_api_ComparisonWorkbookDataScope)
        }

    __slots__: List[str] = ['_display_name', '_variable_name', '_value', '_data_scope']

    def __init__(self, data_scope: "scout_comparisonnotebook_api_ComparisonWorkbookDataScope", value: "scout_comparisonnotebook_api_ComputeNodeWithContext", variable_name: str, display_name: Optional[str] = None) -> None:
        self._display_name = display_name
        self._variable_name = variable_name
        self._value = value
        self._data_scope = data_scope

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def variable_name(self) -> str:
        return self._variable_name

    @builtins.property
    def value(self) -> "scout_comparisonnotebook_api_ComputeNodeWithContext":
        return self._value

    @builtins.property
    def data_scope(self) -> "scout_comparisonnotebook_api_ComparisonWorkbookDataScope":
        return self._data_scope


scout_comparisonnotebook_api_ChannelVariable.__name__ = "ChannelVariable"
scout_comparisonnotebook_api_ChannelVariable.__qualname__ = "ChannelVariable"
scout_comparisonnotebook_api_ChannelVariable.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ColorByVariableConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'aggregation_type': ConjureFieldDefinition('aggregationType', scout_comparisonnotebook_api_AggregationType),
            'lower_bound': ConjureFieldDefinition('lowerBound', float),
            'upper_bound': ConjureFieldDefinition('upperBound', float)
        }

    __slots__: List[str] = ['_locator', '_aggregation_type', '_lower_bound', '_upper_bound']

    def __init__(self, aggregation_type: "scout_comparisonnotebook_api_AggregationType", locator: "scout_comparisonnotebook_api_VariableLocator", lower_bound: float, upper_bound: float) -> None:
        self._locator = locator
        self._aggregation_type = aggregation_type
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def aggregation_type(self) -> "scout_comparisonnotebook_api_AggregationType":
        return self._aggregation_type

    @builtins.property
    def lower_bound(self) -> float:
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> float:
        return self._upper_bound


scout_comparisonnotebook_api_ColorByVariableConfiguration.__name__ = "ColorByVariableConfiguration"
scout_comparisonnotebook_api_ColorByVariableConfiguration.__qualname__ = "ColorByVariableConfiguration"
scout_comparisonnotebook_api_ColorByVariableConfiguration.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption(ConjureUnionType):
    _by_variable: Optional["scout_comparisonnotebook_api_ColorByVariableConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'by_variable': ConjureFieldDefinition('byVariable', scout_comparisonnotebook_api_ColorByVariableConfiguration)
        }

    def __init__(
            self,
            by_variable: Optional["scout_comparisonnotebook_api_ColorByVariableConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (by_variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if by_variable is not None:
                self._by_variable = by_variable
                self._type = 'byVariable'

        elif type_of_union == 'byVariable':
            if by_variable is None:
                raise ValueError('a union value must not be None')
            self._by_variable = by_variable
            self._type = 'byVariable'

    @builtins.property
    def by_variable(self) -> Optional["scout_comparisonnotebook_api_ColorByVariableConfiguration"]:
        return self._by_variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'byVariable' and self.by_variable is not None:
            return visitor._by_variable(self.by_variable)


scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption.__name__ = "ComparisonScatterPlotColoringOption"
scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption.__qualname__ = "ComparisonScatterPlotColoringOption"
scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor:

    @abstractmethod
    def _by_variable(self, by_variable: "scout_comparisonnotebook_api_ColorByVariableConfiguration") -> Any:
        pass


scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor.__name__ = "ComparisonScatterPlotColoringOptionVisitor"
scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor.__qualname__ = "ComparisonScatterPlotColoringOptionVisitor"
scout_comparisonnotebook_api_ComparisonScatterPlotColoringOptionVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotDefinition(ConjureUnionType):
    _v1: Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_comparisonnotebook_api_ComparisonScatterPlotDefinition.__name__ = "ComparisonScatterPlotDefinition"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinition.__qualname__ = "ComparisonScatterPlotDefinition"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinition.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1") -> Any:
        pass


scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor.__name__ = "ComparisonScatterPlotDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor.__qualname__ = "ComparisonScatterPlotDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1(ConjureBeanType):
    """an n x n array of scatter plots
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'range_aggregation': ConjureFieldDefinition('rangeAggregation', OptionalTypeWrapper[scout_comparisonnotebook_api_RangeAggregationDefinition]),
            'variables': ConjureFieldDefinition('variables', List[scout_comparisonnotebook_api_ComparisonScatterPlotVariable]),
            'axes': ConjureFieldDefinition('axes', List[scout_comparisonnotebook_api_ScatterPlotValueAxes]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', OptionalTypeWrapper[scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions])
        }

    __slots__: List[str] = ['_title', '_range_aggregation', '_variables', '_axes', '_visualization_options']

    def __init__(self, axes: List["scout_comparisonnotebook_api_ScatterPlotValueAxes"], variables: List["scout_comparisonnotebook_api_ComparisonScatterPlotVariable"], range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"] = None, title: Optional[str] = None, visualization_options: Optional["scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions"] = None) -> None:
        self._title = title
        self._range_aggregation = range_aggregation
        self._variables = variables
        self._axes = axes
        self._visualization_options = visualization_options

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def range_aggregation(self) -> Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"]:
        return self._range_aggregation

    @builtins.property
    def variables(self) -> List["scout_comparisonnotebook_api_ComparisonScatterPlotVariable"]:
        return self._variables

    @builtins.property
    def axes(self) -> List["scout_comparisonnotebook_api_ScatterPlotValueAxes"]:
        return self._axes

    @builtins.property
    def visualization_options(self) -> Optional["scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions"]:
        """optional for backcompatibility.
        """
        return self._visualization_options


scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1.__name__ = "ComparisonScatterPlotDefinitionV1"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1.__qualname__ = "ComparisonScatterPlotDefinitionV1"
scout_comparisonnotebook_api_ComparisonScatterPlotDefinitionV1.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_axis_id': ConjureFieldDefinition('xAxisId', scout_chartdefinition_api_AxisId),
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'aggregation_type': ConjureFieldDefinition('aggregationType', scout_comparisonnotebook_api_AggregationType)
        }

    __slots__: List[str] = ['_x_axis_id', '_y_axis_id', '_locator', '_aggregation_type']

    def __init__(self, aggregation_type: "scout_comparisonnotebook_api_AggregationType", locator: "scout_comparisonnotebook_api_VariableLocator", x_axis_id: str, y_axis_id: str) -> None:
        self._x_axis_id = x_axis_id
        self._y_axis_id = y_axis_id
        self._locator = locator
        self._aggregation_type = aggregation_type

    @builtins.property
    def x_axis_id(self) -> str:
        """the axisId when the variable is used as the x variable.
        """
        return self._x_axis_id

    @builtins.property
    def y_axis_id(self) -> str:
        """the axisId when the variable is used as the y variable.
        """
        return self._y_axis_id

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def aggregation_type(self) -> "scout_comparisonnotebook_api_AggregationType":
        return self._aggregation_type


scout_comparisonnotebook_api_ComparisonScatterPlotVariable.__name__ = "ComparisonScatterPlotVariable"
scout_comparisonnotebook_api_ComparisonScatterPlotVariable.__qualname__ = "ComparisonScatterPlotVariable"
scout_comparisonnotebook_api_ComparisonScatterPlotVariable.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'coloring': ConjureFieldDefinition('coloring', scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption)
        }

    __slots__: List[str] = ['_coloring']

    def __init__(self, coloring: "scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption") -> None:
        self._coloring = coloring

    @builtins.property
    def coloring(self) -> "scout_comparisonnotebook_api_ComparisonScatterPlotColoringOption":
        return self._coloring


scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions.__name__ = "ComparisonScatterPlotVizOptions"
scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions.__qualname__ = "ComparisonScatterPlotVizOptions"
scout_comparisonnotebook_api_ComparisonScatterPlotVizOptions.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumn(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions),
            'aggregation_type': ConjureFieldDefinition('aggregationType', OptionalTypeWrapper[scout_comparisonnotebook_api_AggregationType])
        }

    __slots__: List[str] = ['_title', '_locator', '_visualization_options', '_aggregation_type']

    def __init__(self, locator: "scout_comparisonnotebook_api_VariableLocator", visualization_options: "scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions", aggregation_type: Optional["scout_comparisonnotebook_api_AggregationType"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._locator = locator
        self._visualization_options = visualization_options
        self._aggregation_type = aggregation_type

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def visualization_options(self) -> "scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions":
        return self._visualization_options

    @builtins.property
    def aggregation_type(self) -> Optional["scout_comparisonnotebook_api_AggregationType"]:
        """optional for backcompatibility.
        """
        return self._aggregation_type


scout_comparisonnotebook_api_ComparisonTableColumn.__name__ = "ComparisonTableColumn"
scout_comparisonnotebook_api_ComparisonTableColumn.__qualname__ = "ComparisonTableColumn"
scout_comparisonnotebook_api_ComparisonTableColumn.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumnOptions(ConjureEnumType):

    AXIS = 'AXIS'
    '''AXIS'''
    BARS = 'BARS'
    '''BARS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_comparisonnotebook_api_ComparisonTableColumnOptions.__name__ = "ComparisonTableColumnOptions"
scout_comparisonnotebook_api_ComparisonTableColumnOptions.__qualname__ = "ComparisonTableColumnOptions"
scout_comparisonnotebook_api_ComparisonTableColumnOptions.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', scout_comparisonnotebook_api_ComparisonTableColumnOptions)
        }

    __slots__: List[str] = ['_format']

    def __init__(self, format: "scout_comparisonnotebook_api_ComparisonTableColumnOptions") -> None:
        self._format = format

    @builtins.property
    def format(self) -> "scout_comparisonnotebook_api_ComparisonTableColumnOptions":
        return self._format


scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__name__ = "ComparisonTableColumnVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__qualname__ = "ComparisonTableColumnVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableColumnVisualizationOptions.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinition(ConjureUnionType):
    _v1: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"] = None
    _v2: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV2"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_comparisonnotebook_api_ComparisonTableDefinitionV1),
            'v2': ConjureFieldDefinition('v2', scout_comparisonnotebook_api_ComparisonTableDefinitionV2)
        }

    def __init__(
            self,
            v1: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"] = None,
            v2: Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV2"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) + (v2 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'
            if v2 is not None:
                self._v2 = v2
                self._type = 'v2'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'
        elif type_of_union == 'v2':
            if v2 is None:
                raise ValueError('a union value must not be None')
            self._v2 = v2
            self._type = 'v2'

    @builtins.property
    def v1(self) -> Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV1"]:
        return self._v1

    @builtins.property
    def v2(self) -> Optional["scout_comparisonnotebook_api_ComparisonTableDefinitionV2"]:
        return self._v2

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)
        if self._type == 'v2' and self.v2 is not None:
            return visitor._v2(self.v2)


scout_comparisonnotebook_api_ComparisonTableDefinition.__name__ = "ComparisonTableDefinition"
scout_comparisonnotebook_api_ComparisonTableDefinition.__qualname__ = "ComparisonTableDefinition"
scout_comparisonnotebook_api_ComparisonTableDefinition.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_comparisonnotebook_api_ComparisonTableDefinitionV1") -> Any:
        pass

    @abstractmethod
    def _v2(self, v2: "scout_comparisonnotebook_api_ComparisonTableDefinitionV2") -> Any:
        pass


scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__name__ = "ComparisonTableDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__qualname__ = "ComparisonTableDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTableDefinitionVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinitionV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'range_aggregations': ConjureFieldDefinition('rangeAggregations', List[scout_comparisonnotebook_api_VariableName]),
            'visualization_options': ConjureFieldDefinition('visualizationOptions', scout_comparisonnotebook_api_ComparisonTableVisualizationOptions),
            'columns': ConjureFieldDefinition('columns', List[scout_comparisonnotebook_api_ComparisonTableColumn])
        }

    __slots__: List[str] = ['_title', '_range_aggregations', '_visualization_options', '_columns']

    def __init__(self, columns: List["scout_comparisonnotebook_api_ComparisonTableColumn"], range_aggregations: List[str], visualization_options: "scout_comparisonnotebook_api_ComparisonTableVisualizationOptions", title: Optional[str] = None) -> None:
        self._title = title
        self._range_aggregations = range_aggregations
        self._visualization_options = visualization_options
        self._columns = columns

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def range_aggregations(self) -> List[str]:
        return self._range_aggregations

    @builtins.property
    def visualization_options(self) -> "scout_comparisonnotebook_api_ComparisonTableVisualizationOptions":
        return self._visualization_options

    @builtins.property
    def columns(self) -> List["scout_comparisonnotebook_api_ComparisonTableColumn"]:
        return self._columns


scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__name__ = "ComparisonTableDefinitionV1"
scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__qualname__ = "ComparisonTableDefinitionV1"
scout_comparisonnotebook_api_ComparisonTableDefinitionV1.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableDefinitionV2(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'range_aggregation': ConjureFieldDefinition('rangeAggregation', OptionalTypeWrapper[scout_comparisonnotebook_api_RangeAggregationDefinition]),
            'columns': ConjureFieldDefinition('columns', List[scout_comparisonnotebook_api_ComparisonTableColumn])
        }

    __slots__: List[str] = ['_title', '_range_aggregation', '_columns']

    def __init__(self, columns: List["scout_comparisonnotebook_api_ComparisonTableColumn"], range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._range_aggregation = range_aggregation
        self._columns = columns

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def range_aggregation(self) -> Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"]:
        return self._range_aggregation

    @builtins.property
    def columns(self) -> List["scout_comparisonnotebook_api_ComparisonTableColumn"]:
        return self._columns


scout_comparisonnotebook_api_ComparisonTableDefinitionV2.__name__ = "ComparisonTableDefinitionV2"
scout_comparisonnotebook_api_ComparisonTableDefinitionV2.__qualname__ = "ComparisonTableDefinitionV2"
scout_comparisonnotebook_api_ComparisonTableDefinitionV2.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTableVisualizationOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregation_colors': ConjureFieldDefinition('aggregationColors', Dict[scout_comparisonnotebook_api_VariableName, scout_api_HexColor])
        }

    __slots__: List[str] = ['_aggregation_colors']

    def __init__(self, aggregation_colors: Dict[str, str]) -> None:
        self._aggregation_colors = aggregation_colors

    @builtins.property
    def aggregation_colors(self) -> Dict[str, str]:
        return self._aggregation_colors


scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__name__ = "ComparisonTableVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__qualname__ = "ComparisonTableVisualizationOptions"
scout_comparisonnotebook_api_ComparisonTableVisualizationOptions.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption(ConjureEnumType):
    """The display option for the time series plot. A CAROUSEL display option means that each plot grouping 
is displayed one at a time, while a MULTIROW display option means that multiple plot groupings are displayed
simultaneously on different rows.
    """

    CAROUSEL = 'CAROUSEL'
    '''CAROUSEL'''
    MULTIROW = 'MULTIROW'
    '''MULTIROW'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption.__name__ = "ComparisonTimeSeriesDisplayOption"
scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption.__qualname__ = "ComparisonTimeSeriesDisplayOption"
scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy(ConjureEnumType):
    """The group by option for the time series plot. A RANGE group by option means that all channels on the
same time range are plotted together, while a VARIABLE group by option means that all time ranges 
for the same channel are plotted together.
    """

    RANGE = 'RANGE'
    '''RANGE'''
    VARIABLE = 'VARIABLE'
    '''VARIABLE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy.__name__ = "ComparisonTimeSeriesGroupBy"
scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy.__qualname__ = "ComparisonTimeSeriesGroupBy"
scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition(ConjureUnionType):
    _v1: Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1)
        }

    def __init__(
            self,
            v1: Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition.__name__ = "ComparisonTimeSeriesPlotDefinition"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition.__qualname__ = "ComparisonTimeSeriesPlotDefinition"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1") -> Any:
        pass


scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor.__name__ = "ComparisonTimeSeriesPlotDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor.__qualname__ = "ComparisonTimeSeriesPlotDefinitionVisitor"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1(ConjureBeanType):
    """a cross-range time series plot with 
configurable range and channel groupings
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'range_aggregation': ConjureFieldDefinition('rangeAggregation', OptionalTypeWrapper[scout_comparisonnotebook_api_RangeAggregationDefinition]),
            'variables': ConjureFieldDefinition('variables', List[scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable]),
            'value_axes': ConjureFieldDefinition('valueAxes', List[scout_chartdefinition_api_ValueAxis]),
            'group_by': ConjureFieldDefinition('groupBy', scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy),
            'display_option': ConjureFieldDefinition('displayOption', scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption)
        }

    __slots__: List[str] = ['_title', '_range_aggregation', '_variables', '_value_axes', '_group_by', '_display_option']

    def __init__(self, display_option: "scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption", group_by: "scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy", value_axes: List["scout_chartdefinition_api_ValueAxis"], variables: List["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable"], range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._range_aggregation = range_aggregation
        self._variables = variables
        self._value_axes = value_axes
        self._group_by = group_by
        self._display_option = display_option

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def range_aggregation(self) -> Optional["scout_comparisonnotebook_api_RangeAggregationDefinition"]:
        return self._range_aggregation

    @builtins.property
    def variables(self) -> List["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable"]:
        return self._variables

    @builtins.property
    def value_axes(self) -> List["scout_chartdefinition_api_ValueAxis"]:
        """a list of value ranges, where each variable is assigned to a y-axis
        """
        return self._value_axes

    @builtins.property
    def group_by(self) -> "scout_comparisonnotebook_api_ComparisonTimeSeriesGroupBy":
        return self._group_by

    @builtins.property
    def display_option(self) -> "scout_comparisonnotebook_api_ComparisonTimeSeriesDisplayOption":
        return self._display_option


scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1.__name__ = "ComparisonTimeSeriesPlotDefinitionV1"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1.__qualname__ = "ComparisonTimeSeriesPlotDefinitionV1"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinitionV1.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'y_axis_id': ConjureFieldDefinition('yAxisId', scout_chartdefinition_api_AxisId),
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator)
        }

    __slots__: List[str] = ['_y_axis_id', '_locator']

    def __init__(self, locator: "scout_comparisonnotebook_api_VariableLocator", y_axis_id: str) -> None:
        self._y_axis_id = y_axis_id
        self._locator = locator

    @builtins.property
    def y_axis_id(self) -> str:
        """the axisId when the variable is used as the y variable.
        """
        return self._y_axis_id

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator


scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable.__name__ = "ComparisonTimeSeriesPlotVariable"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable.__qualname__ = "ComparisonTimeSeriesPlotVariable"
scout_comparisonnotebook_api_ComparisonTimeSeriesPlotVariable.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookContent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_variables': ConjureFieldDefinition('channelVariables', scout_comparisonnotebook_api_ComparisonChannelVariableMap),
            'charts': ConjureFieldDefinition('charts', scout_comparisonnotebook_api_ComparisonVizDefinitionMap)
        }

    __slots__: List[str] = ['_channel_variables', '_charts']

    def __init__(self, channel_variables: Dict[str, "scout_comparisonnotebook_api_ChannelVariable"], charts: Dict[str, "scout_comparisonnotebook_api_VizDefinition"]) -> None:
        self._channel_variables = channel_variables
        self._charts = charts

    @builtins.property
    def channel_variables(self) -> Dict[str, "scout_comparisonnotebook_api_ChannelVariable"]:
        return self._channel_variables

    @builtins.property
    def charts(self) -> Dict[str, "scout_comparisonnotebook_api_VizDefinition"]:
        """visualizations. Charts is a legacy term.
        """
        return self._charts


scout_comparisonnotebook_api_ComparisonWorkbookContent.__name__ = "ComparisonWorkbookContent"
scout_comparisonnotebook_api_ComparisonWorkbookContent.__qualname__ = "ComparisonWorkbookContent"
scout_comparisonnotebook_api_ComparisonWorkbookContent.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_comparisonnotebook_api_VariableName, scout_comparisonnotebook_api_VariableLocator])
        }

    __slots__: List[str] = ['_variables']

    def __init__(self, variables: Dict[str, "scout_comparisonnotebook_api_VariableLocator"]) -> None:
        self._variables = variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_comparisonnotebook_api_VariableLocator"]:
        return self._variables


scout_comparisonnotebook_api_ComparisonWorkbookContext.__name__ = "ComparisonWorkbookContext"
scout_comparisonnotebook_api_ComparisonWorkbookContext.__qualname__ = "ComparisonWorkbookContext"
scout_comparisonnotebook_api_ComparisonWorkbookContext.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookDataScope(ConjureUnionType):
    _runs: Optional[List[str]] = None
    _assets: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'runs': ConjureFieldDefinition('runs', List[scout_run_api_RunRid]),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    def __init__(
            self,
            runs: Optional[List[str]] = None,
            assets: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (runs is not None) + (assets is not None) != 1:
                raise ValueError('a union must contain a single member')

            if runs is not None:
                self._runs = runs
                self._type = 'runs'
            if assets is not None:
                self._assets = assets
                self._type = 'assets'

        elif type_of_union == 'runs':
            if runs is None:
                raise ValueError('a union value must not be None')
            self._runs = runs
            self._type = 'runs'
        elif type_of_union == 'assets':
            if assets is None:
                raise ValueError('a union value must not be None')
            self._assets = assets
            self._type = 'assets'

    @builtins.property
    def runs(self) -> Optional[List[str]]:
        return self._runs

    @builtins.property
    def assets(self) -> Optional[List[str]]:
        return self._assets

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'runs' and self.runs is not None:
            return visitor._runs(self.runs)
        if self._type == 'assets' and self.assets is not None:
            return visitor._assets(self.assets)


scout_comparisonnotebook_api_ComparisonWorkbookDataScope.__name__ = "ComparisonWorkbookDataScope"
scout_comparisonnotebook_api_ComparisonWorkbookDataScope.__qualname__ = "ComparisonWorkbookDataScope"
scout_comparisonnotebook_api_ComparisonWorkbookDataScope.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor:

    @abstractmethod
    def _runs(self, runs: List[str]) -> Any:
        pass

    @abstractmethod
    def _assets(self, assets: List[str]) -> Any:
        pass


scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor.__name__ = "ComparisonWorkbookDataScopeVisitor"
scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor.__qualname__ = "ComparisonWorkbookDataScopeVisitor"
scout_comparisonnotebook_api_ComparisonWorkbookDataScopeVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_comparisonnotebook_api_ComparisonWorkbookContext),
            'supplemental_context': ConjureFieldDefinition('supplementalContext', scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext)
        }

    __slots__: List[str] = ['_compute_node', '_context', '_supplemental_context']

    def __init__(self, compute_node: "scout_compute_api_ComputeNode", context: "scout_comparisonnotebook_api_ComparisonWorkbookContext", supplemental_context: "scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext") -> None:
        self._compute_node = compute_node
        self._context = context
        self._supplemental_context = supplemental_context

    @builtins.property
    def compute_node(self) -> "scout_compute_api_ComputeNode":
        return self._compute_node

    @builtins.property
    def context(self) -> "scout_comparisonnotebook_api_ComparisonWorkbookContext":
        return self._context

    @builtins.property
    def supplemental_context(self) -> "scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext":
        return self._supplemental_context


scout_comparisonnotebook_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_comparisonnotebook_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_comparisonnotebook_api_ComputeNodeWithContext.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Count(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Count.__name__ = "Count"
scout_comparisonnotebook_api_Count.__qualname__ = "Count"
scout_comparisonnotebook_api_Count.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Max(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Max.__name__ = "Max"
scout_comparisonnotebook_api_Max.__qualname__ = "Max"
scout_comparisonnotebook_api_Max.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Mean(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Mean.__name__ = "Mean"
scout_comparisonnotebook_api_Mean.__qualname__ = "Mean"
scout_comparisonnotebook_api_Mean.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_Min(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_Min.__name__ = "Min"
scout_comparisonnotebook_api_Min.__qualname__ = "Min"
scout_comparisonnotebook_api_Min.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_RangeAggregationContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables_to_aggregate': ConjureFieldDefinition('variablesToAggregate', List[scout_comparisonnotebook_api_VariableWithAggregation])
        }

    __slots__: List[str] = ['_variables_to_aggregate']

    def __init__(self, variables_to_aggregate: List["scout_comparisonnotebook_api_VariableWithAggregation"]) -> None:
        self._variables_to_aggregate = variables_to_aggregate

    @builtins.property
    def variables_to_aggregate(self) -> List["scout_comparisonnotebook_api_VariableWithAggregation"]:
        return self._variables_to_aggregate


scout_comparisonnotebook_api_RangeAggregationContext.__name__ = "RangeAggregationContext"
scout_comparisonnotebook_api_RangeAggregationContext.__qualname__ = "RangeAggregationContext"
scout_comparisonnotebook_api_RangeAggregationContext.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_RangeAggregationDefinition(ConjureBeanType):
    """Every range aggregation must be defined by a data scope and set of conditions. This type should be used by
every comparison workbook viz definition.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scope': ConjureFieldDefinition('dataScope', scout_comparisonnotebook_api_ComparisonWorkbookDataScope),
            'condition': ConjureFieldDefinition('condition', scout_comparisonnotebook_api_ComputeNodeWithContext),
            'time_window': ConjureFieldDefinition('timeWindow', OptionalTypeWrapper[scout_comparisonnotebook_api_TimeWindow])
        }

    __slots__: List[str] = ['_data_scope', '_condition', '_time_window']

    def __init__(self, condition: "scout_comparisonnotebook_api_ComputeNodeWithContext", data_scope: "scout_comparisonnotebook_api_ComparisonWorkbookDataScope", time_window: Optional["scout_comparisonnotebook_api_TimeWindow"] = None) -> None:
        self._data_scope = data_scope
        self._condition = condition
        self._time_window = time_window

    @builtins.property
    def data_scope(self) -> "scout_comparisonnotebook_api_ComparisonWorkbookDataScope":
        return self._data_scope

    @builtins.property
    def condition(self) -> "scout_comparisonnotebook_api_ComputeNodeWithContext":
        return self._condition

    @builtins.property
    def time_window(self) -> Optional["scout_comparisonnotebook_api_TimeWindow"]:
        """determines the window of data included in the visualization. Currently only applied on assets.
        """
        return self._time_window


scout_comparisonnotebook_api_RangeAggregationDefinition.__name__ = "RangeAggregationDefinition"
scout_comparisonnotebook_api_RangeAggregationDefinition.__qualname__ = "RangeAggregationDefinition"
scout_comparisonnotebook_api_RangeAggregationDefinition.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_RootMeanSquare(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_RootMeanSquare.__name__ = "RootMeanSquare"
scout_comparisonnotebook_api_RootMeanSquare.__qualname__ = "RootMeanSquare"
scout_comparisonnotebook_api_RootMeanSquare.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_ScatterPlotValueAxes(ConjureBeanType):
    """specifies the axes configurations for a given x and y axis.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_axis': ConjureFieldDefinition('xAxis', scout_chartdefinition_api_ValueAxis),
            'y_axis': ConjureFieldDefinition('yAxis', scout_chartdefinition_api_ValueAxis)
        }

    __slots__: List[str] = ['_x_axis', '_y_axis']

    def __init__(self, x_axis: "scout_chartdefinition_api_ValueAxis", y_axis: "scout_chartdefinition_api_ValueAxis") -> None:
        self._x_axis = x_axis
        self._y_axis = y_axis

    @builtins.property
    def x_axis(self) -> "scout_chartdefinition_api_ValueAxis":
        return self._x_axis

    @builtins.property
    def y_axis(self) -> "scout_chartdefinition_api_ValueAxis":
        return self._y_axis


scout_comparisonnotebook_api_ScatterPlotValueAxes.__name__ = "ScatterPlotValueAxes"
scout_comparisonnotebook_api_ScatterPlotValueAxes.__qualname__ = "ScatterPlotValueAxes"
scout_comparisonnotebook_api_ScatterPlotValueAxes.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_StandardDeviation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonnotebook_api_StandardDeviation.__name__ = "StandardDeviation"
scout_comparisonnotebook_api_StandardDeviation.__qualname__ = "StandardDeviation"
scout_comparisonnotebook_api_StandardDeviation.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext(ConjureUnionType):
    """This is used to allow variables to specify additional context that does not fit well into the general shape of
a compute node. For example, a range aggregation variable represents a bulk computation across several inputs,
whose context is specified here instead.
    """
    _none: Optional["api_Empty"] = None
    _range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationContext"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'none': ConjureFieldDefinition('none', api_Empty),
            'range_aggregation': ConjureFieldDefinition('rangeAggregation', scout_comparisonnotebook_api_RangeAggregationContext)
        }

    def __init__(
            self,
            none: Optional["api_Empty"] = None,
            range_aggregation: Optional["scout_comparisonnotebook_api_RangeAggregationContext"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (none is not None) + (range_aggregation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if none is not None:
                self._none = none
                self._type = 'none'
            if range_aggregation is not None:
                self._range_aggregation = range_aggregation
                self._type = 'rangeAggregation'

        elif type_of_union == 'none':
            if none is None:
                raise ValueError('a union value must not be None')
            self._none = none
            self._type = 'none'
        elif type_of_union == 'rangeAggregation':
            if range_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_aggregation = range_aggregation
            self._type = 'rangeAggregation'

    @builtins.property
    def none(self) -> Optional["api_Empty"]:
        return self._none

    @builtins.property
    def range_aggregation(self) -> Optional["scout_comparisonnotebook_api_RangeAggregationContext"]:
        return self._range_aggregation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor'.format(visitor.__class__.__name__))
        if self._type == 'none' and self.none is not None:
            return visitor._none(self.none)
        if self._type == 'rangeAggregation' and self.range_aggregation is not None:
            return visitor._range_aggregation(self.range_aggregation)


scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__name__ = "SupplementalComparisonWorkbookContext"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__qualname__ = "SupplementalComparisonWorkbookContext"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContext.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor:

    @abstractmethod
    def _none(self, none: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _range_aggregation(self, range_aggregation: "scout_comparisonnotebook_api_RangeAggregationContext") -> Any:
        pass


scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__name__ = "SupplementalComparisonWorkbookContextVisitor"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__qualname__ = "SupplementalComparisonWorkbookContextVisitor"
scout_comparisonnotebook_api_SupplementalComparisonWorkbookContextVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_TimeWindow(ConjureUnionType):
    _relative: Optional["scout_run_api_Duration"] = None
    _fixed: Optional["scout_comparisonnotebook_api_TimestampedRange"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative': ConjureFieldDefinition('relative', scout_run_api_Duration),
            'fixed': ConjureFieldDefinition('fixed', scout_comparisonnotebook_api_TimestampedRange)
        }

    def __init__(
            self,
            relative: Optional["scout_run_api_Duration"] = None,
            fixed: Optional["scout_comparisonnotebook_api_TimestampedRange"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (relative is not None) + (fixed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if relative is not None:
                self._relative = relative
                self._type = 'relative'
            if fixed is not None:
                self._fixed = fixed
                self._type = 'fixed'

        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'
        elif type_of_union == 'fixed':
            if fixed is None:
                raise ValueError('a union value must not be None')
            self._fixed = fixed
            self._type = 'fixed'

    @builtins.property
    def relative(self) -> Optional["scout_run_api_Duration"]:
        return self._relative

    @builtins.property
    def fixed(self) -> Optional["scout_comparisonnotebook_api_TimestampedRange"]:
        return self._fixed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_TimeWindowVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_TimeWindowVisitor'.format(visitor.__class__.__name__))
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)
        if self._type == 'fixed' and self.fixed is not None:
            return visitor._fixed(self.fixed)


scout_comparisonnotebook_api_TimeWindow.__name__ = "TimeWindow"
scout_comparisonnotebook_api_TimeWindow.__qualname__ = "TimeWindow"
scout_comparisonnotebook_api_TimeWindow.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_TimeWindowVisitor:

    @abstractmethod
    def _relative(self, relative: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _fixed(self, fixed: "scout_comparisonnotebook_api_TimestampedRange") -> Any:
        pass


scout_comparisonnotebook_api_TimeWindowVisitor.__name__ = "TimeWindowVisitor"
scout_comparisonnotebook_api_TimeWindowVisitor.__qualname__ = "TimeWindowVisitor"
scout_comparisonnotebook_api_TimeWindowVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_TimestampedRange(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[api_Timestamp]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: Optional["api_Timestamp"] = None, start: Optional["api_Timestamp"] = None) -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> Optional["api_Timestamp"]:
        return self._start

    @builtins.property
    def end(self) -> Optional["api_Timestamp"]:
        return self._end


scout_comparisonnotebook_api_TimestampedRange.__name__ = "TimestampedRange"
scout_comparisonnotebook_api_TimestampedRange.__qualname__ = "TimestampedRange"
scout_comparisonnotebook_api_TimestampedRange.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableLocator(ConjureUnionType):
    _comparison_workbook_variable: Optional[str] = None
    _series: Optional["scout_api_ChannelLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comparison_workbook_variable': ConjureFieldDefinition('comparisonWorkbookVariable', scout_comparisonnotebook_api_VariableName),
            'series': ConjureFieldDefinition('series', scout_api_ChannelLocator)
        }

    def __init__(
            self,
            comparison_workbook_variable: Optional[str] = None,
            series: Optional["scout_api_ChannelLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (comparison_workbook_variable is not None) + (series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if comparison_workbook_variable is not None:
                self._comparison_workbook_variable = comparison_workbook_variable
                self._type = 'comparisonWorkbookVariable'
            if series is not None:
                self._series = series
                self._type = 'series'

        elif type_of_union == 'comparisonWorkbookVariable':
            if comparison_workbook_variable is None:
                raise ValueError('a union value must not be None')
            self._comparison_workbook_variable = comparison_workbook_variable
            self._type = 'comparisonWorkbookVariable'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'

    @builtins.property
    def comparison_workbook_variable(self) -> Optional[str]:
        return self._comparison_workbook_variable

    @builtins.property
    def series(self) -> Optional["scout_api_ChannelLocator"]:
        return self._series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_VariableLocatorVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_VariableLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'comparisonWorkbookVariable' and self.comparison_workbook_variable is not None:
            return visitor._comparison_workbook_variable(self.comparison_workbook_variable)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)


scout_comparisonnotebook_api_VariableLocator.__name__ = "VariableLocator"
scout_comparisonnotebook_api_VariableLocator.__qualname__ = "VariableLocator"
scout_comparisonnotebook_api_VariableLocator.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableLocatorVisitor:

    @abstractmethod
    def _comparison_workbook_variable(self, comparison_workbook_variable: str) -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_api_ChannelLocator") -> Any:
        pass


scout_comparisonnotebook_api_VariableLocatorVisitor.__name__ = "VariableLocatorVisitor"
scout_comparisonnotebook_api_VariableLocatorVisitor.__qualname__ = "VariableLocatorVisitor"
scout_comparisonnotebook_api_VariableLocatorVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VariableWithAggregation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'locator': ConjureFieldDefinition('locator', scout_comparisonnotebook_api_VariableLocator),
            'aggregation_type': ConjureFieldDefinition('aggregationType', scout_comparisonnotebook_api_AggregationType)
        }

    __slots__: List[str] = ['_locator', '_aggregation_type']

    def __init__(self, aggregation_type: "scout_comparisonnotebook_api_AggregationType", locator: "scout_comparisonnotebook_api_VariableLocator") -> None:
        self._locator = locator
        self._aggregation_type = aggregation_type

    @builtins.property
    def locator(self) -> "scout_comparisonnotebook_api_VariableLocator":
        return self._locator

    @builtins.property
    def aggregation_type(self) -> "scout_comparisonnotebook_api_AggregationType":
        return self._aggregation_type


scout_comparisonnotebook_api_VariableWithAggregation.__name__ = "VariableWithAggregation"
scout_comparisonnotebook_api_VariableWithAggregation.__qualname__ = "VariableWithAggregation"
scout_comparisonnotebook_api_VariableWithAggregation.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VizDefinition(ConjureUnionType):
    _table: Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"] = None
    _scatter: Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinition"] = None
    _time_series: Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', scout_comparisonnotebook_api_ComparisonTableDefinition),
            'scatter': ConjureFieldDefinition('scatter', scout_comparisonnotebook_api_ComparisonScatterPlotDefinition),
            'time_series': ConjureFieldDefinition('timeSeries', scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition)
        }

    def __init__(
            self,
            table: Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"] = None,
            scatter: Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinition"] = None,
            time_series: Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) + (scatter is not None) + (time_series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'
            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'
            if time_series is not None:
                self._time_series = time_series
                self._type = 'timeSeries'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'
        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'
        elif type_of_union == 'timeSeries':
            if time_series is None:
                raise ValueError('a union value must not be None')
            self._time_series = time_series
            self._type = 'timeSeries'

    @builtins.property
    def table(self) -> Optional["scout_comparisonnotebook_api_ComparisonTableDefinition"]:
        return self._table

    @builtins.property
    def scatter(self) -> Optional["scout_comparisonnotebook_api_ComparisonScatterPlotDefinition"]:
        return self._scatter

    @builtins.property
    def time_series(self) -> Optional["scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition"]:
        return self._time_series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonnotebook_api_VizDefinitionVisitor):
            raise ValueError('{} is not an instance of scout_comparisonnotebook_api_VizDefinitionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)
        if self._type == 'timeSeries' and self.time_series is not None:
            return visitor._time_series(self.time_series)


scout_comparisonnotebook_api_VizDefinition.__name__ = "VizDefinition"
scout_comparisonnotebook_api_VizDefinition.__qualname__ = "VizDefinition"
scout_comparisonnotebook_api_VizDefinition.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonnotebook_api_VizDefinitionVisitor:

    @abstractmethod
    def _table(self, table: "scout_comparisonnotebook_api_ComparisonTableDefinition") -> Any:
        pass

    @abstractmethod
    def _scatter(self, scatter: "scout_comparisonnotebook_api_ComparisonScatterPlotDefinition") -> Any:
        pass

    @abstractmethod
    def _time_series(self, time_series: "scout_comparisonnotebook_api_ComparisonTimeSeriesPlotDefinition") -> Any:
        pass


scout_comparisonnotebook_api_VizDefinitionVisitor.__name__ = "VizDefinitionVisitor"
scout_comparisonnotebook_api_VizDefinitionVisitor.__qualname__ = "VizDefinitionVisitor"
scout_comparisonnotebook_api_VizDefinitionVisitor.__module__ = "nominal_api.scout_comparisonnotebook_api"


class scout_comparisonrun_api_ComparisonRun(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'enabled': ConjureFieldDefinition('enabled', bool),
            'offset_override': ConjureFieldDefinition('offsetOverride', OptionalTypeWrapper[scout_comparisonrun_api_Offset])
        }

    __slots__: List[str] = ['_run_rid', '_enabled', '_offset_override']

    def __init__(self, enabled: bool, run_rid: str, offset_override: Optional["scout_comparisonrun_api_Offset"] = None) -> None:
        self._run_rid = run_rid
        self._enabled = enabled
        self._offset_override = offset_override

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def enabled(self) -> bool:
        return self._enabled

    @builtins.property
    def offset_override(self) -> Optional["scout_comparisonrun_api_Offset"]:
        return self._offset_override


scout_comparisonrun_api_ComparisonRun.__name__ = "ComparisonRun"
scout_comparisonrun_api_ComparisonRun.__qualname__ = "ComparisonRun"
scout_comparisonrun_api_ComparisonRun.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_ComparisonRunGroup(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'uuid': ConjureFieldDefinition('uuid', str),
            'name': ConjureFieldDefinition('name', str),
            'offset': ConjureFieldDefinition('offset', scout_comparisonrun_api_Offset),
            'offset_anchor': ConjureFieldDefinition('offsetAnchor', scout_comparisonrun_api_OffsetAnchor),
            'runs': ConjureFieldDefinition('runs', List[scout_comparisonrun_api_ComparisonRun]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_api_HexColor])
        }

    __slots__: List[str] = ['_uuid', '_name', '_offset', '_offset_anchor', '_runs', '_color']

    def __init__(self, name: str, offset: "scout_comparisonrun_api_Offset", offset_anchor: "scout_comparisonrun_api_OffsetAnchor", runs: List["scout_comparisonrun_api_ComparisonRun"], uuid: str, color: Optional[str] = None) -> None:
        self._uuid = uuid
        self._name = name
        self._offset = offset
        self._offset_anchor = offset_anchor
        self._runs = runs
        self._color = color

    @builtins.property
    def uuid(self) -> str:
        return self._uuid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def offset(self) -> "scout_comparisonrun_api_Offset":
        return self._offset

    @builtins.property
    def offset_anchor(self) -> "scout_comparisonrun_api_OffsetAnchor":
        return self._offset_anchor

    @builtins.property
    def runs(self) -> List["scout_comparisonrun_api_ComparisonRun"]:
        return self._runs

    @builtins.property
    def color(self) -> Optional[str]:
        return self._color


scout_comparisonrun_api_ComparisonRunGroup.__name__ = "ComparisonRunGroup"
scout_comparisonrun_api_ComparisonRunGroup.__qualname__ = "ComparisonRunGroup"
scout_comparisonrun_api_ComparisonRunGroup.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_Offset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', int),
            'unit': ConjureFieldDefinition('unit', api_TimeUnit)
        }

    __slots__: List[str] = ['_value', '_unit']

    def __init__(self, unit: "api_TimeUnit", value: int) -> None:
        self._value = value
        self._unit = unit

    @builtins.property
    def value(self) -> int:
        return self._value

    @builtins.property
    def unit(self) -> "api_TimeUnit":
        return self._unit


scout_comparisonrun_api_Offset.__name__ = "Offset"
scout_comparisonrun_api_Offset.__qualname__ = "Offset"
scout_comparisonrun_api_Offset.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetAnchor(ConjureUnionType):
    _run: Optional["scout_comparisonrun_api_OffsetRunAnchor"] = None
    _series: Optional["scout_comparisonrun_api_OffsetSeriesAnchor"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_comparisonrun_api_OffsetRunAnchor),
            'series': ConjureFieldDefinition('series', scout_comparisonrun_api_OffsetSeriesAnchor)
        }

    def __init__(
            self,
            run: Optional["scout_comparisonrun_api_OffsetRunAnchor"] = None,
            series: Optional["scout_comparisonrun_api_OffsetSeriesAnchor"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (run is not None) + (series is not None) != 1:
                raise ValueError('a union must contain a single member')

            if run is not None:
                self._run = run
                self._type = 'run'
            if series is not None:
                self._series = series
                self._type = 'series'

        elif type_of_union == 'run':
            if run is None:
                raise ValueError('a union value must not be None')
            self._run = run
            self._type = 'run'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'

    @builtins.property
    def run(self) -> Optional["scout_comparisonrun_api_OffsetRunAnchor"]:
        return self._run

    @builtins.property
    def series(self) -> Optional["scout_comparisonrun_api_OffsetSeriesAnchor"]:
        return self._series

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_comparisonrun_api_OffsetAnchorVisitor):
            raise ValueError('{} is not an instance of scout_comparisonrun_api_OffsetAnchorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'run' and self.run is not None:
            return visitor._run(self.run)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)


scout_comparisonrun_api_OffsetAnchor.__name__ = "OffsetAnchor"
scout_comparisonrun_api_OffsetAnchor.__qualname__ = "OffsetAnchor"
scout_comparisonrun_api_OffsetAnchor.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetAnchorVisitor:

    @abstractmethod
    def _run(self, run: "scout_comparisonrun_api_OffsetRunAnchor") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_comparisonrun_api_OffsetSeriesAnchor") -> Any:
        pass


scout_comparisonrun_api_OffsetAnchorVisitor.__name__ = "OffsetAnchorVisitor"
scout_comparisonrun_api_OffsetAnchorVisitor.__qualname__ = "OffsetAnchorVisitor"
scout_comparisonrun_api_OffsetAnchorVisitor.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetRunAnchor(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_comparisonrun_api_OffsetRunAnchor.__name__ = "OffsetRunAnchor"
scout_comparisonrun_api_OffsetRunAnchor.__qualname__ = "OffsetRunAnchor"
scout_comparisonrun_api_OffsetRunAnchor.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_comparisonrun_api_OffsetSeriesAnchor(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_variable': ConjureFieldDefinition('seriesVariable', scout_channelvariables_api_ChannelVariableName)
        }

    __slots__: List[str] = ['_series_variable']

    def __init__(self, series_variable: str) -> None:
        self._series_variable = series_variable

    @builtins.property
    def series_variable(self) -> str:
        return self._series_variable


scout_comparisonrun_api_OffsetSeriesAnchor.__name__ = "OffsetSeriesAnchor"
scout_comparisonrun_api_OffsetSeriesAnchor.__qualname__ = "OffsetSeriesAnchor"
scout_comparisonrun_api_OffsetSeriesAnchor.__module__ = "nominal_api.scout_comparisonrun_api"


class scout_compute_api_AbsoluteThreshold(ConjureBeanType):
    """Threshold defined as a real number corresponding the unit of a series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_value']

    def __init__(self, value: "scout_compute_api_DoubleConstant") -> None:
        self._value = value

    @builtins.property
    def value(self) -> "scout_compute_api_DoubleConstant":
        return self._value


scout_compute_api_AbsoluteThreshold.__name__ = "AbsoluteThreshold"
scout_compute_api_AbsoluteThreshold.__qualname__ = "AbsoluteThreshold"
scout_compute_api_AbsoluteThreshold.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AbsoluteTimestampSeries(ConjureBeanType):
    """Replaces values in a series with the absolute timestamps.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Series),
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit)
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_api_Series", time_unit: "api_TimeUnit") -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_Series":
        return self._input

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        """The time unit used to define the output values. Throws an error if nanosecond or finer.
        """
        return self._time_unit


scout_compute_api_AbsoluteTimestampSeries.__name__ = "AbsoluteTimestampSeries"
scout_compute_api_AbsoluteTimestampSeries.__qualname__ = "AbsoluteTimestampSeries"
scout_compute_api_AbsoluteTimestampSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AfterPersistenceWindow(ConjureBeanType):
    """The first point in the output range will be the first point after the condition has been true
for the min duration and min points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_AfterPersistenceWindow.__name__ = "AfterPersistenceWindow"
scout_compute_api_AfterPersistenceWindow.__qualname__ = "AfterPersistenceWindow"
scout_compute_api_AfterPersistenceWindow.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AggregateEnumSeries(ConjureBeanType):
    """Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'function': ConjureFieldDefinition('function', scout_compute_api_EnumAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_EnumAggregationFunction", input: "scout_compute_api_EnumSeries") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_EnumAggregationFunction":
        return self._function


scout_compute_api_AggregateEnumSeries.__name__ = "AggregateEnumSeries"
scout_compute_api_AggregateEnumSeries.__qualname__ = "AggregateEnumSeries"
scout_compute_api_AggregateEnumSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AggregateNumericSeries(ConjureBeanType):
    """Aggregates values with duplicate timestamps in the input series values into a single value using the specified aggregation function.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'function': ConjureFieldDefinition('function', scout_compute_api_NumericAggregationFunction),
            'group_by_tags': ConjureFieldDefinition('groupByTags', List[scout_compute_api_StringConstant]),
            'aggregate_by_all_groupings': ConjureFieldDefinition('aggregateByAllGroupings', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_input', '_function', '_group_by_tags', '_aggregate_by_all_groupings']

    def __init__(self, function: "scout_compute_api_NumericAggregationFunction", group_by_tags: List["scout_compute_api_StringConstant"], input: "scout_compute_api_NumericSeries", aggregate_by_all_groupings: Optional[bool] = None) -> None:
        self._input = input
        self._function = function
        self._group_by_tags = group_by_tags
        self._aggregate_by_all_groupings = aggregate_by_all_groupings

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_NumericAggregationFunction":
        return self._function

    @builtins.property
    def group_by_tags(self) -> List["scout_compute_api_StringConstant"]:
        """Tags to group by for the aggregation.
If left empty, the tags to group by will be equivalent to those in the input series.
If specified, the result will be grouped ONLY by the specified tags.
The tags specified here MUST be a (non-strict) subset of the input series's group by tags.
        """
        return self._group_by_tags

    @builtins.property
    def aggregate_by_all_groupings(self) -> Optional[bool]:
        """This field's purpose is to distinguish between the two flavors of groupByTags being empty. It has no
effect when groupByTags is non-empty.
When true and groupByTags is empty, aggregate across all series in the input.
When false and groupByTags is empty, the result will be grouped by the same tags as the input series.
        """
        return self._aggregate_by_all_groupings


scout_compute_api_AggregateNumericSeries.__name__ = "AggregateNumericSeries"
scout_compute_api_AggregateNumericSeries.__qualname__ = "AggregateNumericSeries"
scout_compute_api_AggregateNumericSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AggregateUnderRangesSeries(ConjureBeanType):
    """Aggregates the input series under the ranges in the provided ranges series, and outputs a new series with one 
point at the start of each range, where the value is the aggregation result. If a range has no points, no 
point will be produced for it. If a range has no start, the point produced for it will be at the
start of the compute request range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_ranges', '_operation']

    def __init__(self, input: "scout_compute_api_NumericSeries", operation: "scout_compute_api_NumericAggregationFunction", ranges: "scout_compute_api_RangeSeries") -> None:
        self._input = input
        self._ranges = ranges
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericAggregationFunction":
        return self._operation


scout_compute_api_AggregateUnderRangesSeries.__name__ = "AggregateUnderRangesSeries"
scout_compute_api_AggregateUnderRangesSeries.__qualname__ = "AggregateUnderRangesSeries"
scout_compute_api_AggregateUnderRangesSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AllowNegativeValues(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_AllowNegativeValues.__name__ = "AllowNegativeValues"
scout_compute_api_AllowNegativeValues.__qualname__ = "AllowNegativeValues"
scout_compute_api_AllowNegativeValues.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ApproximateThresholdOperator(ConjureEnumType):

    EQUAL_TO = 'EQUAL_TO'
    '''EQUAL_TO'''
    NOT_EQUAL_TO = 'NOT_EQUAL_TO'
    '''NOT_EQUAL_TO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_ApproximateThresholdOperator.__name__ = "ApproximateThresholdOperator"
scout_compute_api_ApproximateThresholdOperator.__qualname__ = "ApproximateThresholdOperator"
scout_compute_api_ApproximateThresholdOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ApproximateThresholdRanges(ConjureBeanType):
    """Produces a list of ranges for which the threshold condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DoubleConstant),
            'tolerance': ConjureFieldDefinition('tolerance', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ApproximateThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_tolerance', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", operator: "scout_compute_api_ApproximateThresholdOperator", threshold: "scout_compute_api_DoubleConstant", tolerance: "scout_compute_api_DoubleConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._tolerance = tolerance
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DoubleConstant":
        return self._threshold

    @builtins.property
    def tolerance(self) -> "scout_compute_api_DoubleConstant":
        return self._tolerance

    @builtins.property
    def operator(self) -> "scout_compute_api_ApproximateThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_ApproximateThresholdRanges.__name__ = "ApproximateThresholdRanges"
scout_compute_api_ApproximateThresholdRanges.__qualname__ = "ApproximateThresholdRanges"
scout_compute_api_ApproximateThresholdRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArithmeticSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_api_NumericSeries]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_ArithmeticSeries.__name__ = "ArithmeticSeries"
scout_compute_api_ArithmeticSeries.__qualname__ = "ArithmeticSeries"
scout_compute_api_ArithmeticSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArraySeries(ConjureUnionType):
    _numeric1d: Optional["scout_compute_api_Numeric1dArraySeries"] = None
    _enum1d: Optional["scout_compute_api_Enum1dArraySeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric1d': ConjureFieldDefinition('numeric1d', scout_compute_api_Numeric1dArraySeries),
            'enum1d': ConjureFieldDefinition('enum1d', scout_compute_api_Enum1dArraySeries)
        }

    def __init__(
            self,
            numeric1d: Optional["scout_compute_api_Numeric1dArraySeries"] = None,
            enum1d: Optional["scout_compute_api_Enum1dArraySeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric1d is not None) + (enum1d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric1d is not None:
                self._numeric1d = numeric1d
                self._type = 'numeric1d'
            if enum1d is not None:
                self._enum1d = enum1d
                self._type = 'enum1d'

        elif type_of_union == 'numeric1d':
            if numeric1d is None:
                raise ValueError('a union value must not be None')
            self._numeric1d = numeric1d
            self._type = 'numeric1d'
        elif type_of_union == 'enum1d':
            if enum1d is None:
                raise ValueError('a union value must not be None')
            self._enum1d = enum1d
            self._type = 'enum1d'

    @builtins.property
    def numeric1d(self) -> Optional["scout_compute_api_Numeric1dArraySeries"]:
        return self._numeric1d

    @builtins.property
    def enum1d(self) -> Optional["scout_compute_api_Enum1dArraySeries"]:
        return self._enum1d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ArraySeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ArraySeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric1d' and self.numeric1d is not None:
            return visitor._numeric1d(self.numeric1d)
        if self._type == 'enum1d' and self.enum1d is not None:
            return visitor._enum1d(self.enum1d)


scout_compute_api_ArraySeries.__name__ = "ArraySeries"
scout_compute_api_ArraySeries.__qualname__ = "ArraySeries"
scout_compute_api_ArraySeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArraySeriesVisitor:

    @abstractmethod
    def _numeric1d(self, numeric1d: "scout_compute_api_Numeric1dArraySeries") -> Any:
        pass

    @abstractmethod
    def _enum1d(self, enum1d: "scout_compute_api_Enum1dArraySeries") -> Any:
        pass


scout_compute_api_ArraySeriesVisitor.__name__ = "ArraySeriesVisitor"
scout_compute_api_ArraySeriesVisitor.__qualname__ = "ArraySeriesVisitor"
scout_compute_api_ArraySeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowArrayPlot(ConjureUnionType):
    _bucketed_numeric: Optional["scout_compute_api_BucketedNumericArrayPlot"] = None
    _bucketed_enum: Optional["scout_compute_api_BucketedEnumArrayPlot"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucketed_numeric': ConjureFieldDefinition('bucketedNumeric', scout_compute_api_BucketedNumericArrayPlot),
            'bucketed_enum': ConjureFieldDefinition('bucketedEnum', scout_compute_api_BucketedEnumArrayPlot)
        }

    def __init__(
            self,
            bucketed_numeric: Optional["scout_compute_api_BucketedNumericArrayPlot"] = None,
            bucketed_enum: Optional["scout_compute_api_BucketedEnumArrayPlot"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucketed_numeric is not None) + (bucketed_enum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucketed_numeric is not None:
                self._bucketed_numeric = bucketed_numeric
                self._type = 'bucketedNumeric'
            if bucketed_enum is not None:
                self._bucketed_enum = bucketed_enum
                self._type = 'bucketedEnum'

        elif type_of_union == 'bucketedNumeric':
            if bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._bucketed_numeric = bucketed_numeric
            self._type = 'bucketedNumeric'
        elif type_of_union == 'bucketedEnum':
            if bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._bucketed_enum = bucketed_enum
            self._type = 'bucketedEnum'

    @builtins.property
    def bucketed_numeric(self) -> Optional["scout_compute_api_BucketedNumericArrayPlot"]:
        return self._bucketed_numeric

    @builtins.property
    def bucketed_enum(self) -> Optional["scout_compute_api_BucketedEnumArrayPlot"]:
        return self._bucketed_enum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ArrowArrayPlotVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ArrowArrayPlotVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucketedNumeric' and self.bucketed_numeric is not None:
            return visitor._bucketed_numeric(self.bucketed_numeric)
        if self._type == 'bucketedEnum' and self.bucketed_enum is not None:
            return visitor._bucketed_enum(self.bucketed_enum)


scout_compute_api_ArrowArrayPlot.__name__ = "ArrowArrayPlot"
scout_compute_api_ArrowArrayPlot.__qualname__ = "ArrowArrayPlot"
scout_compute_api_ArrowArrayPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowArrayPlotVisitor:

    @abstractmethod
    def _bucketed_numeric(self, bucketed_numeric: "scout_compute_api_BucketedNumericArrayPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_enum(self, bucketed_enum: "scout_compute_api_BucketedEnumArrayPlot") -> Any:
        pass


scout_compute_api_ArrowArrayPlotVisitor.__name__ = "ArrowArrayPlotVisitor"
scout_compute_api_ArrowArrayPlotVisitor.__qualname__ = "ArrowArrayPlotVisitor"
scout_compute_api_ArrowArrayPlotVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowBucketedEnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for BucketedEnumPlot
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowBucketedEnumPlot.__name__ = "ArrowBucketedEnumPlot"
scout_compute_api_ArrowBucketedEnumPlot.__qualname__ = "ArrowBucketedEnumPlot"
scout_compute_api_ArrowBucketedEnumPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowBucketedNumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for BucketedNumericPlot
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowBucketedNumericPlot.__name__ = "ArrowBucketedNumericPlot"
scout_compute_api_ArrowBucketedNumericPlot.__qualname__ = "ArrowBucketedNumericPlot"
scout_compute_api_ArrowBucketedNumericPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowBucketedStructPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for bucketed struct plot
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowBucketedStructPlot.__name__ = "ArrowBucketedStructPlot"
scout_compute_api_ArrowBucketedStructPlot.__qualname__ = "ArrowBucketedStructPlot"
scout_compute_api_ArrowBucketedStructPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowEnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for EnumPlot
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowEnumPlot.__name__ = "ArrowEnumPlot"
scout_compute_api_ArrowEnumPlot.__qualname__ = "ArrowEnumPlot"
scout_compute_api_ArrowEnumPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowFullResolutionPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for the first n rows of a full resolution plot sorted by timestamp.
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowFullResolutionPlot.__name__ = "ArrowFullResolutionPlot"
scout_compute_api_ArrowFullResolutionPlot.__qualname__ = "ArrowFullResolutionPlot"
scout_compute_api_ArrowFullResolutionPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ArrowNumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for NumericPlot
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_ArrowNumericPlot.__name__ = "ArrowNumericPlot"
scout_compute_api_ArrowNumericPlot.__qualname__ = "ArrowNumericPlot"
scout_compute_api_ArrowNumericPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_AssetChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_rid': ConjureFieldDefinition('assetRid', scout_compute_api_StringConstant),
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_compute_api_StringConstant),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_StringConstant),
            'additional_tags': ConjureFieldDefinition('additionalTags', Dict[str, scout_compute_api_StringConstant]),
            'additional_tag_filters': ConjureFieldDefinition('additionalTagFilters', OptionalTypeWrapper[scout_compute_api_TagFilters]),
            'tags_to_group_by': ConjureFieldDefinition('tagsToGroupBy', List[str]),
            'group_by_tags': ConjureFieldDefinition('groupByTags', List[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_asset_rid', '_data_scope_name', '_channel', '_additional_tags', '_additional_tag_filters', '_tags_to_group_by', '_group_by_tags']

    def __init__(self, additional_tags: Dict[str, "scout_compute_api_StringConstant"], asset_rid: "scout_compute_api_StringConstant", channel: "scout_compute_api_StringConstant", data_scope_name: "scout_compute_api_StringConstant", group_by_tags: List["scout_compute_api_StringConstant"], tags_to_group_by: List[str], additional_tag_filters: Optional["scout_compute_api_TagFilters"] = None) -> None:
        self._asset_rid = asset_rid
        self._data_scope_name = data_scope_name
        self._channel = channel
        self._additional_tags = additional_tags
        self._additional_tag_filters = additional_tag_filters
        self._tags_to_group_by = tags_to_group_by
        self._group_by_tags = group_by_tags

    @builtins.property
    def asset_rid(self) -> "scout_compute_api_StringConstant":
        return self._asset_rid

    @builtins.property
    def data_scope_name(self) -> "scout_compute_api_StringConstant":
        """Used to disambiguate when multiple data scopes within this asset contain channels with the same name.
        """
        return self._data_scope_name

    @builtins.property
    def channel(self) -> "scout_compute_api_StringConstant":
        return self._channel

    @builtins.property
    def additional_tags(self) -> Dict[str, "scout_compute_api_StringConstant"]:
        return self._additional_tags

    @builtins.property
    def additional_tag_filters(self) -> Optional["scout_compute_api_TagFilters"]:
        """Tags to filter the channel by, in addition to tag filters defined for a given Asset data scope. Throws on 
collisions with tag keys already defined for the given Asset data scope. Only returns points that match 
both sets of tag filters. For log series, include arg filters here in addition to tag filters.
        """
        return self._additional_tag_filters

    @builtins.property
    def tags_to_group_by(self) -> List[str]:
        return self._tags_to_group_by

    @builtins.property
    def group_by_tags(self) -> List["scout_compute_api_StringConstant"]:
        """Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
        """
        return self._group_by_tags


scout_compute_api_AssetChannel.__name__ = "AssetChannel"
scout_compute_api_AssetChannel.__qualname__ = "AssetChannel"
scout_compute_api_AssetChannel.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Average(ConjureBeanType):
    """A average that gives the same weight to each observation inside the time window
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Average.__name__ = "Average"
scout_compute_api_Average.__qualname__ = "Average"
scout_compute_api_Average.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BandPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_passband_frequency': ConjureFieldDefinition('lowPassbandFrequency', scout_compute_api_DoubleConstant),
            'high_passband_frequency': ConjureFieldDefinition('highPassbandFrequency', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_low_passband_frequency', '_high_passband_frequency']

    def __init__(self, high_passband_frequency: "scout_compute_api_DoubleConstant", low_passband_frequency: "scout_compute_api_DoubleConstant") -> None:
        self._low_passband_frequency = low_passband_frequency
        self._high_passband_frequency = high_passband_frequency

    @builtins.property
    def low_passband_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._low_passband_frequency

    @builtins.property
    def high_passband_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._high_passband_frequency


scout_compute_api_BandPassConfiguration.__name__ = "BandPassConfiguration"
scout_compute_api_BandPassConfiguration.__qualname__ = "BandPassConfiguration"
scout_compute_api_BandPassConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BandStopConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_stopband_frequency': ConjureFieldDefinition('lowStopbandFrequency', scout_compute_api_DoubleConstant),
            'high_stopband_frequency': ConjureFieldDefinition('highStopbandFrequency', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_low_stopband_frequency', '_high_stopband_frequency']

    def __init__(self, high_stopband_frequency: "scout_compute_api_DoubleConstant", low_stopband_frequency: "scout_compute_api_DoubleConstant") -> None:
        self._low_stopband_frequency = low_stopband_frequency
        self._high_stopband_frequency = high_stopband_frequency

    @builtins.property
    def low_stopband_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._low_stopband_frequency

    @builtins.property
    def high_stopband_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._high_stopband_frequency


scout_compute_api_BandStopConfiguration.__name__ = "BandStopConfiguration"
scout_compute_api_BandStopConfiguration.__qualname__ = "BandStopConfiguration"
scout_compute_api_BandStopConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BatchComputeUnitResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_compute_api_ComputeUnitResult])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["scout_compute_api_ComputeUnitResult"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["scout_compute_api_ComputeUnitResult"]:
        return self._results


scout_compute_api_BatchComputeUnitResult.__name__ = "BatchComputeUnitResult"
scout_compute_api_BatchComputeUnitResult.__qualname__ = "BatchComputeUnitResult"
scout_compute_api_BatchComputeUnitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BatchComputeUnitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_compute_api_ComputeUnitsRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["scout_compute_api_ComputeUnitsRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["scout_compute_api_ComputeUnitsRequest"]:
        return self._requests


scout_compute_api_BatchComputeUnitsRequest.__name__ = "BatchComputeUnitsRequest"
scout_compute_api_BatchComputeUnitsRequest.__qualname__ = "BatchComputeUnitsRequest"
scout_compute_api_BatchComputeUnitsRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BatchComputeWithUnitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_compute_api_ComputeNodeRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["scout_compute_api_ComputeNodeRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["scout_compute_api_ComputeNodeRequest"]:
        return self._requests


scout_compute_api_BatchComputeWithUnitsRequest.__name__ = "BatchComputeWithUnitsRequest"
scout_compute_api_BatchComputeWithUnitsRequest.__qualname__ = "BatchComputeWithUnitsRequest"
scout_compute_api_BatchComputeWithUnitsRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BatchComputeWithUnitsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_compute_api_ComputeWithUnitsResult])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["scout_compute_api_ComputeWithUnitsResult"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["scout_compute_api_ComputeWithUnitsResult"]:
        return self._results


scout_compute_api_BatchComputeWithUnitsResponse.__name__ = "BatchComputeWithUnitsResponse"
scout_compute_api_BatchComputeWithUnitsResponse.__qualname__ = "BatchComputeWithUnitsResponse"
scout_compute_api_BatchComputeWithUnitsResponse.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BinaryArithmeticOperation(ConjureEnumType):

    ATAN2 = 'ATAN2'
    '''ATAN2'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_BinaryArithmeticOperation.__name__ = "BinaryArithmeticOperation"
scout_compute_api_BinaryArithmeticOperation.__qualname__ = "BinaryArithmeticOperation"
scout_compute_api_BinaryArithmeticOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BinaryArithmeticSeries(ConjureBeanType):
    """Applies a point-wise transformation to a pair of series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input1': ConjureFieldDefinition('input1', scout_compute_api_NumericSeries),
            'input2': ConjureFieldDefinition('input2', scout_compute_api_NumericSeries),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_BinaryArithmeticOperation),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input1', '_input2', '_operation', '_interpolation_configuration']

    def __init__(self, input1: "scout_compute_api_NumericSeries", input2: "scout_compute_api_NumericSeries", operation: "scout_compute_api_BinaryArithmeticOperation", interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._input1 = input1
        self._input2 = input2
        self._operation = operation
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input1(self) -> "scout_compute_api_NumericSeries":
        return self._input1

    @builtins.property
    def input2(self) -> "scout_compute_api_NumericSeries":
        return self._input2

    @builtins.property
    def operation(self) -> "scout_compute_api_BinaryArithmeticOperation":
        return self._operation

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_BinaryArithmeticSeries.__name__ = "BinaryArithmeticSeries"
scout_compute_api_BinaryArithmeticSeries.__qualname__ = "BinaryArithmeticSeries"
scout_compute_api_BinaryArithmeticSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitAndFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitAndFunction.__name__ = "BitAndFunction"
scout_compute_api_BitAndFunction.__qualname__ = "BitAndFunction"
scout_compute_api_BitAndFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitOperationFunction(ConjureUnionType):
    _and_: Optional["scout_compute_api_BitAndFunction"] = None
    _or_: Optional["scout_compute_api_BitOrFunction"] = None
    _xor: Optional["scout_compute_api_BitXorFunction"] = None
    _shift_right: Optional["scout_compute_api_BitShiftRightFunction"] = None
    _shift_left: Optional["scout_compute_api_BitShiftLeftFunction"] = None
    _bit_test: Optional["scout_compute_api_BitTestFunction"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', scout_compute_api_BitAndFunction),
            'or_': ConjureFieldDefinition('or', scout_compute_api_BitOrFunction),
            'xor': ConjureFieldDefinition('xor', scout_compute_api_BitXorFunction),
            'shift_right': ConjureFieldDefinition('shiftRight', scout_compute_api_BitShiftRightFunction),
            'shift_left': ConjureFieldDefinition('shiftLeft', scout_compute_api_BitShiftLeftFunction),
            'bit_test': ConjureFieldDefinition('bitTest', scout_compute_api_BitTestFunction)
        }

    def __init__(
            self,
            and_: Optional["scout_compute_api_BitAndFunction"] = None,
            or_: Optional["scout_compute_api_BitOrFunction"] = None,
            xor: Optional["scout_compute_api_BitXorFunction"] = None,
            shift_right: Optional["scout_compute_api_BitShiftRightFunction"] = None,
            shift_left: Optional["scout_compute_api_BitShiftLeftFunction"] = None,
            bit_test: Optional["scout_compute_api_BitTestFunction"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (xor is not None) + (shift_right is not None) + (shift_left is not None) + (bit_test is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if xor is not None:
                self._xor = xor
                self._type = 'xor'
            if shift_right is not None:
                self._shift_right = shift_right
                self._type = 'shiftRight'
            if shift_left is not None:
                self._shift_left = shift_left
                self._type = 'shiftLeft'
            if bit_test is not None:
                self._bit_test = bit_test
                self._type = 'bitTest'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'xor':
            if xor is None:
                raise ValueError('a union value must not be None')
            self._xor = xor
            self._type = 'xor'
        elif type_of_union == 'shiftRight':
            if shift_right is None:
                raise ValueError('a union value must not be None')
            self._shift_right = shift_right
            self._type = 'shiftRight'
        elif type_of_union == 'shiftLeft':
            if shift_left is None:
                raise ValueError('a union value must not be None')
            self._shift_left = shift_left
            self._type = 'shiftLeft'
        elif type_of_union == 'bitTest':
            if bit_test is None:
                raise ValueError('a union value must not be None')
            self._bit_test = bit_test
            self._type = 'bitTest'

    @builtins.property
    def and_(self) -> Optional["scout_compute_api_BitAndFunction"]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional["scout_compute_api_BitOrFunction"]:
        return self._or_

    @builtins.property
    def xor(self) -> Optional["scout_compute_api_BitXorFunction"]:
        return self._xor

    @builtins.property
    def shift_right(self) -> Optional["scout_compute_api_BitShiftRightFunction"]:
        return self._shift_right

    @builtins.property
    def shift_left(self) -> Optional["scout_compute_api_BitShiftLeftFunction"]:
        return self._shift_left

    @builtins.property
    def bit_test(self) -> Optional["scout_compute_api_BitTestFunction"]:
        return self._bit_test

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_BitOperationFunctionVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_BitOperationFunctionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'xor' and self.xor is not None:
            return visitor._xor(self.xor)
        if self._type == 'shiftRight' and self.shift_right is not None:
            return visitor._shift_right(self.shift_right)
        if self._type == 'shiftLeft' and self.shift_left is not None:
            return visitor._shift_left(self.shift_left)
        if self._type == 'bitTest' and self.bit_test is not None:
            return visitor._bit_test(self.bit_test)


scout_compute_api_BitOperationFunction.__name__ = "BitOperationFunction"
scout_compute_api_BitOperationFunction.__qualname__ = "BitOperationFunction"
scout_compute_api_BitOperationFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitOperationFunctionVisitor:

    @abstractmethod
    def _and(self, and_: "scout_compute_api_BitAndFunction") -> Any:
        pass

    @abstractmethod
    def _or(self, or_: "scout_compute_api_BitOrFunction") -> Any:
        pass

    @abstractmethod
    def _xor(self, xor: "scout_compute_api_BitXorFunction") -> Any:
        pass

    @abstractmethod
    def _shift_right(self, shift_right: "scout_compute_api_BitShiftRightFunction") -> Any:
        pass

    @abstractmethod
    def _shift_left(self, shift_left: "scout_compute_api_BitShiftLeftFunction") -> Any:
        pass

    @abstractmethod
    def _bit_test(self, bit_test: "scout_compute_api_BitTestFunction") -> Any:
        pass


scout_compute_api_BitOperationFunctionVisitor.__name__ = "BitOperationFunctionVisitor"
scout_compute_api_BitOperationFunctionVisitor.__qualname__ = "BitOperationFunctionVisitor"
scout_compute_api_BitOperationFunctionVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitOperationSeries(ConjureBeanType):
    """Casts input series values to long before applying the bitwise operation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_api_NumericSeries") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_api_BitOperationSeries.__name__ = "BitOperationSeries"
scout_compute_api_BitOperationSeries.__qualname__ = "BitOperationSeries"
scout_compute_api_BitOperationSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitOrFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitOrFunction.__name__ = "BitOrFunction"
scout_compute_api_BitOrFunction.__qualname__ = "BitOrFunction"
scout_compute_api_BitOrFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitShiftLeftFunction(ConjureBeanType):
    """Shifts the bits in each value left according to the given operand.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitShiftLeftFunction.__name__ = "BitShiftLeftFunction"
scout_compute_api_BitShiftLeftFunction.__qualname__ = "BitShiftLeftFunction"
scout_compute_api_BitShiftLeftFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitShiftRightFunction(ConjureBeanType):
    """Right shifts the bits in each value right according to the given operand.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitShiftRightFunction.__name__ = "BitShiftRightFunction"
scout_compute_api_BitShiftRightFunction.__qualname__ = "BitShiftRightFunction"
scout_compute_api_BitShiftRightFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitTestFunction(ConjureBeanType):
    """Returns the bit at the specified index, where the right-most bit has index 0.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'index': ConjureFieldDefinition('index', int)
        }

    __slots__: List[str] = ['_index']

    def __init__(self, index: int) -> None:
        self._index = index

    @builtins.property
    def index(self) -> int:
        return self._index


scout_compute_api_BitTestFunction.__name__ = "BitTestFunction"
scout_compute_api_BitTestFunction.__qualname__ = "BitTestFunction"
scout_compute_api_BitTestFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BitXorFunction(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operand': ConjureFieldDefinition('operand', int)
        }

    __slots__: List[str] = ['_operand']

    def __init__(self, operand: int) -> None:
        self._operand = operand

    @builtins.property
    def operand(self) -> int:
        return self._operand


scout_compute_api_BitXorFunction.__name__ = "BitXorFunction"
scout_compute_api_BitXorFunction.__qualname__ = "BitXorFunction"
scout_compute_api_BitXorFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Bode(ConjureBeanType):
    """Returns the bode magnitude and phase of a system's frequency response.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'output': ConjureFieldDefinition('output', scout_compute_api_NumericSeries),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_input', '_output', '_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase']

    def __init__(self, input: "scout_compute_api_NumericSeries", output: "scout_compute_api_NumericSeries", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._input = input
        self._output = output
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def output(self) -> "scout_compute_api_NumericSeries":
        return self._output

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        """The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_20 if not specified.
        """
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        """The type of the output frequency. Defaults to LINEAR if not specified.
        """
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        """Unwrap the phase of the output. Defaults to true if not specified.
        """
        return self._unwrap_phase


scout_compute_api_Bode.__name__ = "Bode"
scout_compute_api_Bode.__qualname__ = "Bode"
scout_compute_api_Bode.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedCartesian3dPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_Cartesian3dBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_Cartesian3dBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_Cartesian3dBucket"]:
        return self._buckets


scout_compute_api_BucketedCartesian3dPlot.__name__ = "BucketedCartesian3dPlot"
scout_compute_api_BucketedCartesian3dPlot.__qualname__ = "BucketedCartesian3dPlot"
scout_compute_api_BucketedCartesian3dPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedCartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_CartesianBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_CartesianBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_CartesianBucket"]:
        return self._buckets


scout_compute_api_BucketedCartesianPlot.__name__ = "BucketedCartesianPlot"
scout_compute_api_BucketedCartesianPlot.__qualname__ = "BucketedCartesianPlot"
scout_compute_api_BucketedCartesianPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedEnumArrayPlot(ConjureBeanType):
    """The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for a bucketed N-dimensional enum array plot.
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_BucketedEnumArrayPlot.__name__ = "BucketedEnumArrayPlot"
scout_compute_api_BucketedEnumArrayPlot.__qualname__ = "BucketedEnumArrayPlot"
scout_compute_api_BucketedEnumArrayPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedEnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_EnumBucket]),
            'categories': ConjureFieldDefinition('categories', List[str])
        }

    __slots__: List[str] = ['_timestamps', '_buckets', '_categories']

    def __init__(self, buckets: List["scout_compute_api_EnumBucket"], categories: List[str], timestamps: List["api_Timestamp"]) -> None:
        self._timestamps = timestamps
        self._buckets = buckets
        self._categories = categories

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """The end of the bucket, exclusive.
        """
        return self._timestamps

    @builtins.property
    def buckets(self) -> List["scout_compute_api_EnumBucket"]:
        return self._buckets

    @builtins.property
    def categories(self) -> List[str]:
        return self._categories


scout_compute_api_BucketedEnumPlot.__name__ = "BucketedEnumPlot"
scout_compute_api_BucketedEnumPlot.__qualname__ = "BucketedEnumPlot"
scout_compute_api_BucketedEnumPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedNumericArrayPlot(ConjureBeanType):
    """The array is flattened out into a an arrow stream of bucketed primitive results, with an extra column to
indicate the index of the array that the bucket corresponds to.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow_binary': ConjureFieldDefinition('arrowBinary', BinaryType),
            'group_by_keys': ConjureFieldDefinition('groupByKeys', OptionalTypeWrapper[List[str]])
        }

    __slots__: List[str] = ['_arrow_binary', '_group_by_keys']

    def __init__(self, arrow_binary: Any, group_by_keys: Optional[List[str]] = None) -> None:
        self._arrow_binary = arrow_binary
        self._group_by_keys = group_by_keys

    @builtins.property
    def arrow_binary(self) -> Any:
        """The raw binary containing Arrow IPC stream for a bucketed N-dimensional numeric array plot.
        """
        return self._arrow_binary

    @builtins.property
    def group_by_keys(self) -> Optional[List[str]]:
        """This field specifies the tags that the final output is grouped by. When you combine multiple channels, 
this list represents the superset of all group by keys used across every individual channel.
        """
        return self._group_by_keys


scout_compute_api_BucketedNumericArrayPlot.__name__ = "BucketedNumericArrayPlot"
scout_compute_api_BucketedNumericArrayPlot.__qualname__ = "BucketedNumericArrayPlot"
scout_compute_api_BucketedNumericArrayPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_BucketedNumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_NumericBucket])
        }

    __slots__: List[str] = ['_timestamps', '_buckets']

    def __init__(self, buckets: List["scout_compute_api_NumericBucket"], timestamps: List["api_Timestamp"]) -> None:
        self._timestamps = timestamps
        self._buckets = buckets

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """The end of the bucket, exclusive.
        """
        return self._timestamps

    @builtins.property
    def buckets(self) -> List["scout_compute_api_NumericBucket"]:
        return self._buckets


scout_compute_api_BucketedNumericPlot.__name__ = "BucketedNumericPlot"
scout_compute_api_BucketedNumericPlot.__qualname__ = "BucketedNumericPlot"
scout_compute_api_BucketedNumericPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian(ConjureUnionType):
    _scatter: Optional["scout_compute_api_Scatter"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_Scatter)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_api_Scatter"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_api_Scatter"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_CartesianVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_CartesianVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_api_Cartesian.__name__ = "Cartesian"
scout_compute_api_Cartesian.__qualname__ = "Cartesian"
scout_compute_api_Cartesian.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CartesianVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_api_Scatter") -> Any:
        pass


scout_compute_api_CartesianVisitor.__name__ = "CartesianVisitor"
scout_compute_api_CartesianVisitor.__qualname__ = "CartesianVisitor"
scout_compute_api_CartesianVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian3d(ConjureUnionType):
    _scatter3d: Optional["scout_compute_api_Scatter3d"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter3d': ConjureFieldDefinition('scatter3d', scout_compute_api_Scatter3d)
        }

    def __init__(
            self,
            scatter3d: Optional["scout_compute_api_Scatter3d"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter3d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter3d is not None:
                self._scatter3d = scatter3d
                self._type = 'scatter3d'

        elif type_of_union == 'scatter3d':
            if scatter3d is None:
                raise ValueError('a union value must not be None')
            self._scatter3d = scatter3d
            self._type = 'scatter3d'

    @builtins.property
    def scatter3d(self) -> Optional["scout_compute_api_Scatter3d"]:
        return self._scatter3d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_Cartesian3dVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_Cartesian3dVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter3d' and self.scatter3d is not None:
            return visitor._scatter3d(self.scatter3d)


scout_compute_api_Cartesian3d.__name__ = "Cartesian3d"
scout_compute_api_Cartesian3d.__qualname__ = "Cartesian3d"
scout_compute_api_Cartesian3d.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian3dVisitor:

    @abstractmethod
    def _scatter3d(self, scatter3d: "scout_compute_api_Scatter3d") -> Any:
        pass


scout_compute_api_Cartesian3dVisitor.__name__ = "Cartesian3dVisitor"
scout_compute_api_Cartesian3dVisitor.__qualname__ = "Cartesian3dVisitor"
scout_compute_api_Cartesian3dVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian3dBounds(ConjureBeanType):
    """Min/max bounds of an XYZ Cartesian plot, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', scout_compute_api_DoubleConstant),
            'max_x': ConjureFieldDefinition('maxX', scout_compute_api_DoubleConstant),
            'min_y': ConjureFieldDefinition('minY', scout_compute_api_DoubleConstant),
            'max_y': ConjureFieldDefinition('maxY', scout_compute_api_DoubleConstant),
            'min_z': ConjureFieldDefinition('minZ', scout_compute_api_DoubleConstant),
            'max_z': ConjureFieldDefinition('maxZ', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y', '_min_z', '_max_z']

    def __init__(self, max_x: "scout_compute_api_DoubleConstant", max_y: "scout_compute_api_DoubleConstant", max_z: "scout_compute_api_DoubleConstant", min_x: "scout_compute_api_DoubleConstant", min_y: "scout_compute_api_DoubleConstant", min_z: "scout_compute_api_DoubleConstant") -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y
        self._min_z = min_z
        self._max_z = max_z

    @builtins.property
    def min_x(self) -> "scout_compute_api_DoubleConstant":
        return self._min_x

    @builtins.property
    def max_x(self) -> "scout_compute_api_DoubleConstant":
        return self._max_x

    @builtins.property
    def min_y(self) -> "scout_compute_api_DoubleConstant":
        return self._min_y

    @builtins.property
    def max_y(self) -> "scout_compute_api_DoubleConstant":
        return self._max_y

    @builtins.property
    def min_z(self) -> "scout_compute_api_DoubleConstant":
        return self._min_z

    @builtins.property
    def max_z(self) -> "scout_compute_api_DoubleConstant":
        return self._max_z


scout_compute_api_Cartesian3dBounds.__name__ = "Cartesian3dBounds"
scout_compute_api_Cartesian3dBounds.__qualname__ = "Cartesian3dBounds"
scout_compute_api_Cartesian3dBounds.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian3dBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', OptionalTypeWrapper[float]),
            'max_x': ConjureFieldDefinition('maxX', OptionalTypeWrapper[float]),
            'mean_x': ConjureFieldDefinition('meanX', float),
            'min_y': ConjureFieldDefinition('minY', OptionalTypeWrapper[float]),
            'max_y': ConjureFieldDefinition('maxY', OptionalTypeWrapper[float]),
            'mean_y': ConjureFieldDefinition('meanY', float),
            'min_z': ConjureFieldDefinition('minZ', OptionalTypeWrapper[float]),
            'max_z': ConjureFieldDefinition('maxZ', OptionalTypeWrapper[float]),
            'mean_z': ConjureFieldDefinition('meanZ', float),
            'min_x_point': ConjureFieldDefinition('minXPoint', scout_compute_api_Point3d),
            'max_x_point': ConjureFieldDefinition('maxXPoint', scout_compute_api_Point3d),
            'min_y_point': ConjureFieldDefinition('minYPoint', scout_compute_api_Point3d),
            'max_y_point': ConjureFieldDefinition('maxYPoint', scout_compute_api_Point3d),
            'min_z_point': ConjureFieldDefinition('minZPoint', scout_compute_api_Point3d),
            'max_z_point': ConjureFieldDefinition('maxZPoint', scout_compute_api_Point3d),
            'min_timestamp': ConjureFieldDefinition('minTimestamp', api_Timestamp),
            'max_timestamp': ConjureFieldDefinition('maxTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_mean_x', '_min_y', '_max_y', '_mean_y', '_min_z', '_max_z', '_mean_z', '_min_x_point', '_max_x_point', '_min_y_point', '_max_y_point', '_min_z_point', '_max_z_point', '_min_timestamp', '_max_timestamp', '_count']

    def __init__(self, count: int, max_timestamp: "api_Timestamp", max_x_point: "scout_compute_api_Point3d", max_y_point: "scout_compute_api_Point3d", max_z_point: "scout_compute_api_Point3d", mean_x: float, mean_y: float, mean_z: float, min_timestamp: "api_Timestamp", min_x_point: "scout_compute_api_Point3d", min_y_point: "scout_compute_api_Point3d", min_z_point: "scout_compute_api_Point3d", max_x: Optional[float] = None, max_y: Optional[float] = None, max_z: Optional[float] = None, min_x: Optional[float] = None, min_y: Optional[float] = None, min_z: Optional[float] = None) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._mean_x = mean_x
        self._min_y = min_y
        self._max_y = max_y
        self._mean_y = mean_y
        self._min_z = min_z
        self._max_z = max_z
        self._mean_z = mean_z
        self._min_x_point = min_x_point
        self._max_x_point = max_x_point
        self._min_y_point = min_y_point
        self._max_y_point = max_y_point
        self._min_z_point = min_z_point
        self._max_z_point = max_z_point
        self._min_timestamp = min_timestamp
        self._max_timestamp = max_timestamp
        self._count = count

    @builtins.property
    def min_x(self) -> Optional[float]:
        return self._min_x

    @builtins.property
    def max_x(self) -> Optional[float]:
        return self._max_x

    @builtins.property
    def mean_x(self) -> float:
        return self._mean_x

    @builtins.property
    def min_y(self) -> Optional[float]:
        return self._min_y

    @builtins.property
    def max_y(self) -> Optional[float]:
        return self._max_y

    @builtins.property
    def mean_y(self) -> float:
        return self._mean_y

    @builtins.property
    def min_z(self) -> Optional[float]:
        return self._min_z

    @builtins.property
    def max_z(self) -> Optional[float]:
        return self._max_z

    @builtins.property
    def mean_z(self) -> float:
        return self._mean_z

    @builtins.property
    def min_x_point(self) -> "scout_compute_api_Point3d":
        return self._min_x_point

    @builtins.property
    def max_x_point(self) -> "scout_compute_api_Point3d":
        return self._max_x_point

    @builtins.property
    def min_y_point(self) -> "scout_compute_api_Point3d":
        return self._min_y_point

    @builtins.property
    def max_y_point(self) -> "scout_compute_api_Point3d":
        return self._max_y_point

    @builtins.property
    def min_z_point(self) -> "scout_compute_api_Point3d":
        return self._min_z_point

    @builtins.property
    def max_z_point(self) -> "scout_compute_api_Point3d":
        return self._max_z_point

    @builtins.property
    def min_timestamp(self) -> "api_Timestamp":
        return self._min_timestamp

    @builtins.property
    def max_timestamp(self) -> "api_Timestamp":
        return self._max_timestamp

    @builtins.property
    def count(self) -> int:
        return self._count


scout_compute_api_Cartesian3dBucket.__name__ = "Cartesian3dBucket"
scout_compute_api_Cartesian3dBucket.__qualname__ = "Cartesian3dBucket"
scout_compute_api_Cartesian3dBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cartesian3dUnitResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_UnitResult),
            'y': ConjureFieldDefinition('y', scout_compute_api_UnitResult),
            'z': ConjureFieldDefinition('z', scout_compute_api_UnitResult)
        }

    __slots__: List[str] = ['_x', '_y', '_z']

    def __init__(self, x: "scout_compute_api_UnitResult", y: "scout_compute_api_UnitResult", z: "scout_compute_api_UnitResult") -> None:
        self._x = x
        self._y = y
        self._z = z

    @builtins.property
    def x(self) -> "scout_compute_api_UnitResult":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_UnitResult":
        return self._y

    @builtins.property
    def z(self) -> "scout_compute_api_UnitResult":
        return self._z


scout_compute_api_Cartesian3dUnitResult.__name__ = "Cartesian3dUnitResult"
scout_compute_api_Cartesian3dUnitResult.__qualname__ = "Cartesian3dUnitResult"
scout_compute_api_Cartesian3dUnitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CartesianBounds(ConjureBeanType):
    """Min/max bounds of an XY Cartesian plot, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', scout_compute_api_DoubleConstant),
            'max_x': ConjureFieldDefinition('maxX', scout_compute_api_DoubleConstant),
            'min_y': ConjureFieldDefinition('minY', scout_compute_api_DoubleConstant),
            'max_y': ConjureFieldDefinition('maxY', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: "scout_compute_api_DoubleConstant", max_y: "scout_compute_api_DoubleConstant", min_x: "scout_compute_api_DoubleConstant", min_y: "scout_compute_api_DoubleConstant") -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> "scout_compute_api_DoubleConstant":
        return self._min_x

    @builtins.property
    def max_x(self) -> "scout_compute_api_DoubleConstant":
        return self._max_x

    @builtins.property
    def min_y(self) -> "scout_compute_api_DoubleConstant":
        return self._min_y

    @builtins.property
    def max_y(self) -> "scout_compute_api_DoubleConstant":
        return self._max_y


scout_compute_api_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_api_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_api_CartesianBounds.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CartesianBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float),
            'min_timestamp': ConjureFieldDefinition('minTimestamp', api_Timestamp),
            'max_timestamp': ConjureFieldDefinition('maxTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y', '_min_timestamp', '_max_timestamp', '_count']

    def __init__(self, count: int, max_timestamp: "api_Timestamp", max_x: float, max_y: float, min_timestamp: "api_Timestamp", min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y
        self._min_timestamp = min_timestamp
        self._max_timestamp = max_timestamp
        self._count = count

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y

    @builtins.property
    def min_timestamp(self) -> "api_Timestamp":
        return self._min_timestamp

    @builtins.property
    def max_timestamp(self) -> "api_Timestamp":
        return self._max_timestamp

    @builtins.property
    def count(self) -> int:
        return self._count


scout_compute_api_CartesianBucket.__name__ = "CartesianBucket"
scout_compute_api_CartesianBucket.__qualname__ = "CartesianBucket"
scout_compute_api_CartesianBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CartesianPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'x_values': ConjureFieldDefinition('xValues', List[float]),
            'y_values': ConjureFieldDefinition('yValues', List[float])
        }

    __slots__: List[str] = ['_timestamps', '_x_values', '_y_values']

    def __init__(self, timestamps: List["api_Timestamp"], x_values: List[float], y_values: List[float]) -> None:
        self._timestamps = timestamps
        self._x_values = x_values
        self._y_values = y_values

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def x_values(self) -> List[float]:
        return self._x_values

    @builtins.property
    def y_values(self) -> List[float]:
        return self._y_values


scout_compute_api_CartesianPlot.__name__ = "CartesianPlot"
scout_compute_api_CartesianPlot.__qualname__ = "CartesianPlot"
scout_compute_api_CartesianPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CartesianUnitResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_UnitResult),
            'y': ConjureFieldDefinition('y', scout_compute_api_UnitResult)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_UnitResult", y: "scout_compute_api_UnitResult") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_UnitResult":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_UnitResult":
        return self._y


scout_compute_api_CartesianUnitResult.__name__ = "CartesianUnitResult"
scout_compute_api_CartesianUnitResult.__qualname__ = "CartesianUnitResult"
scout_compute_api_CartesianUnitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ChannelSeries(ConjureUnionType):
    _data_source: Optional["scout_compute_api_DataSourceChannel"] = None
    _asset: Optional["scout_compute_api_AssetChannel"] = None
    _run: Optional["scout_compute_api_RunChannel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', scout_compute_api_DataSourceChannel),
            'asset': ConjureFieldDefinition('asset', scout_compute_api_AssetChannel),
            'run': ConjureFieldDefinition('run', scout_compute_api_RunChannel)
        }

    def __init__(
            self,
            data_source: Optional["scout_compute_api_DataSourceChannel"] = None,
            asset: Optional["scout_compute_api_AssetChannel"] = None,
            run: Optional["scout_compute_api_RunChannel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (data_source is not None) + (asset is not None) + (run is not None) != 1:
                raise ValueError('a union must contain a single member')

            if data_source is not None:
                self._data_source = data_source
                self._type = 'dataSource'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if run is not None:
                self._run = run
                self._type = 'run'

        elif type_of_union == 'dataSource':
            if data_source is None:
                raise ValueError('a union value must not be None')
            self._data_source = data_source
            self._type = 'dataSource'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'run':
            if run is None:
                raise ValueError('a union value must not be None')
            self._run = run
            self._type = 'run'

    @builtins.property
    def data_source(self) -> Optional["scout_compute_api_DataSourceChannel"]:
        return self._data_source

    @builtins.property
    def asset(self) -> Optional["scout_compute_api_AssetChannel"]:
        return self._asset

    @builtins.property
    def run(self) -> Optional["scout_compute_api_RunChannel"]:
        return self._run

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ChannelSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ChannelSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataSource' and self.data_source is not None:
            return visitor._data_source(self.data_source)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'run' and self.run is not None:
            return visitor._run(self.run)


scout_compute_api_ChannelSeries.__name__ = "ChannelSeries"
scout_compute_api_ChannelSeries.__qualname__ = "ChannelSeries"
scout_compute_api_ChannelSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ChannelSeriesVisitor:

    @abstractmethod
    def _data_source(self, data_source: "scout_compute_api_DataSourceChannel") -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: "scout_compute_api_AssetChannel") -> Any:
        pass

    @abstractmethod
    def _run(self, run: "scout_compute_api_RunChannel") -> Any:
        pass


scout_compute_api_ChannelSeriesVisitor.__name__ = "ChannelSeriesVisitor"
scout_compute_api_ChannelSeriesVisitor.__qualname__ = "ChannelSeriesVisitor"
scout_compute_api_ChannelSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CompactEnumPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', int)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: int) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> int:
        return self._value


scout_compute_api_CompactEnumPoint.__name__ = "CompactEnumPoint"
scout_compute_api_CompactEnumPoint.__qualname__ = "CompactEnumPoint"
scout_compute_api_CompactEnumPoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputableNode(ConjureUnionType):
    _ranges: Optional["scout_compute_api_SummarizeRanges"] = None
    _series: Optional["scout_compute_api_SummarizeSeries"] = None
    _value: Optional["scout_compute_api_SelectValue"] = None
    _cartesian: Optional["scout_compute_api_SummarizeCartesian"] = None
    _cartesian3d: Optional["scout_compute_api_SummarizeCartesian3d"] = None
    _frequency: Optional["scout_compute_api_FrequencyDomain"] = None
    _frequency_v2: Optional["scout_compute_api_FrequencyDomainV2"] = None
    _histogram: Optional["scout_compute_api_Histogram"] = None
    _curve: Optional["scout_compute_api_CurveFit"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_SummarizeRanges),
            'series': ConjureFieldDefinition('series', scout_compute_api_SummarizeSeries),
            'value': ConjureFieldDefinition('value', scout_compute_api_SelectValue),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_SummarizeCartesian),
            'cartesian3d': ConjureFieldDefinition('cartesian3d', scout_compute_api_SummarizeCartesian3d),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_api_FrequencyDomain),
            'frequency_v2': ConjureFieldDefinition('frequencyV2', scout_compute_api_FrequencyDomainV2),
            'histogram': ConjureFieldDefinition('histogram', scout_compute_api_Histogram),
            'curve': ConjureFieldDefinition('curve', scout_compute_api_CurveFit)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_api_SummarizeRanges"] = None,
            series: Optional["scout_compute_api_SummarizeSeries"] = None,
            value: Optional["scout_compute_api_SelectValue"] = None,
            cartesian: Optional["scout_compute_api_SummarizeCartesian"] = None,
            cartesian3d: Optional["scout_compute_api_SummarizeCartesian3d"] = None,
            frequency: Optional["scout_compute_api_FrequencyDomain"] = None,
            frequency_v2: Optional["scout_compute_api_FrequencyDomainV2"] = None,
            histogram: Optional["scout_compute_api_Histogram"] = None,
            curve: Optional["scout_compute_api_CurveFit"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (cartesian3d is not None) + (frequency is not None) + (frequency_v2 is not None) + (histogram is not None) + (curve is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if cartesian3d is not None:
                self._cartesian3d = cartesian3d
                self._type = 'cartesian3d'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if frequency_v2 is not None:
                self._frequency_v2 = frequency_v2
                self._type = 'frequencyV2'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if curve is not None:
                self._curve = curve
                self._type = 'curve'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'cartesian3d':
            if cartesian3d is None:
                raise ValueError('a union value must not be None')
            self._cartesian3d = cartesian3d
            self._type = 'cartesian3d'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'frequencyV2':
            if frequency_v2 is None:
                raise ValueError('a union value must not be None')
            self._frequency_v2 = frequency_v2
            self._type = 'frequencyV2'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'curve':
            if curve is None:
                raise ValueError('a union value must not be None')
            self._curve = curve
            self._type = 'curve'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_SummarizeRanges"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_api_SummarizeSeries"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_api_SelectValue"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_SummarizeCartesian"]:
        return self._cartesian

    @builtins.property
    def cartesian3d(self) -> Optional["scout_compute_api_SummarizeCartesian3d"]:
        return self._cartesian3d

    @builtins.property
    def frequency(self) -> Optional["scout_compute_api_FrequencyDomain"]:
        return self._frequency

    @builtins.property
    def frequency_v2(self) -> Optional["scout_compute_api_FrequencyDomainV2"]:
        return self._frequency_v2

    @builtins.property
    def histogram(self) -> Optional["scout_compute_api_Histogram"]:
        return self._histogram

    @builtins.property
    def curve(self) -> Optional["scout_compute_api_CurveFit"]:
        return self._curve

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputableNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputableNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'cartesian3d' and self.cartesian3d is not None:
            return visitor._cartesian3d(self.cartesian3d)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'frequencyV2' and self.frequency_v2 is not None:
            return visitor._frequency_v2(self.frequency_v2)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'curve' and self.curve is not None:
            return visitor._curve(self.curve)


scout_compute_api_ComputableNode.__name__ = "ComputableNode"
scout_compute_api_ComputableNode.__qualname__ = "ComputableNode"
scout_compute_api_ComputableNode.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputableNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_SummarizeRanges") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_api_SummarizeSeries") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_api_SelectValue") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_SummarizeCartesian") -> Any:
        pass

    @abstractmethod
    def _cartesian3d(self, cartesian3d: "scout_compute_api_SummarizeCartesian3d") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_api_FrequencyDomain") -> Any:
        pass

    @abstractmethod
    def _frequency_v2(self, frequency_v2: "scout_compute_api_FrequencyDomainV2") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_compute_api_Histogram") -> Any:
        pass

    @abstractmethod
    def _curve(self, curve: "scout_compute_api_CurveFit") -> Any:
        pass


scout_compute_api_ComputableNodeVisitor.__name__ = "ComputableNodeVisitor"
scout_compute_api_ComputableNodeVisitor.__qualname__ = "ComputableNodeVisitor"
scout_compute_api_ComputableNodeVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNode(ConjureUnionType):
    _enum: Optional["scout_compute_api_EnumSeries"] = None
    _numeric: Optional["scout_compute_api_NumericSeries"] = None
    _log: Optional["scout_compute_api_LogSeries"] = None
    _ranges: Optional["scout_compute_api_RangeSeries"] = None
    _array: Optional["scout_compute_api_ArraySeries"] = None
    _struct: Optional["scout_compute_api_StructSeries"] = None
    _curve_fit: Optional["scout_compute_api_CurveFit"] = None
    _raw: Optional["scout_compute_api_Reference"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeries),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeries),
            'log': ConjureFieldDefinition('log', scout_compute_api_LogSeries),
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'array': ConjureFieldDefinition('array', scout_compute_api_ArraySeries),
            'struct': ConjureFieldDefinition('struct', scout_compute_api_StructSeries),
            'curve_fit': ConjureFieldDefinition('curveFit', scout_compute_api_CurveFit),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference)
        }

    def __init__(
            self,
            enum: Optional["scout_compute_api_EnumSeries"] = None,
            numeric: Optional["scout_compute_api_NumericSeries"] = None,
            log: Optional["scout_compute_api_LogSeries"] = None,
            ranges: Optional["scout_compute_api_RangeSeries"] = None,
            array: Optional["scout_compute_api_ArraySeries"] = None,
            struct: Optional["scout_compute_api_StructSeries"] = None,
            curve_fit: Optional["scout_compute_api_CurveFit"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (enum is not None) + (numeric is not None) + (log is not None) + (ranges is not None) + (array is not None) + (struct is not None) + (curve_fit is not None) + (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if log is not None:
                self._log = log
                self._type = 'log'
            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if array is not None:
                self._array = array
                self._type = 'array'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'
            if curve_fit is not None:
                self._curve_fit = curve_fit
                self._type = 'curveFit'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'log':
            if log is None:
                raise ValueError('a union value must not be None')
            self._log = log
            self._type = 'log'
        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'
        elif type_of_union == 'curveFit':
            if curve_fit is None:
                raise ValueError('a union value must not be None')
            self._curve_fit = curve_fit
            self._type = 'curveFit'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeries"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeries"]:
        return self._numeric

    @builtins.property
    def log(self) -> Optional["scout_compute_api_LogSeries"]:
        return self._log

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_RangeSeries"]:
        return self._ranges

    @builtins.property
    def array(self) -> Optional["scout_compute_api_ArraySeries"]:
        return self._array

    @builtins.property
    def struct(self) -> Optional["scout_compute_api_StructSeries"]:
        return self._struct

    @builtins.property
    def curve_fit(self) -> Optional["scout_compute_api_CurveFit"]:
        return self._curve_fit

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'log' and self.log is not None:
            return visitor._log(self.log)
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)
        if self._type == 'curveFit' and self.curve_fit is not None:
            return visitor._curve_fit(self.curve_fit)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_compute_api_ComputeNode.__name__ = "ComputeNode"
scout_compute_api_ComputeNode.__qualname__ = "ComputeNode"
scout_compute_api_ComputeNode.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeVisitor:

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeries") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeries") -> Any:
        pass

    @abstractmethod
    def _log(self, log: "scout_compute_api_LogSeries") -> Any:
        pass

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_RangeSeries") -> Any:
        pass

    @abstractmethod
    def _array(self, array: "scout_compute_api_ArraySeries") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: "scout_compute_api_StructSeries") -> Any:
        pass

    @abstractmethod
    def _curve_fit(self, curve_fit: "scout_compute_api_CurveFit") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass


scout_compute_api_ComputeNodeVisitor.__name__ = "ComputeNodeVisitor"
scout_compute_api_ComputeNodeVisitor.__qualname__ = "ComputeNodeVisitor"
scout_compute_api_ComputeNodeVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeFromReferenceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'reference_ts': ConjureFieldDefinition('referenceTs', api_Timestamp),
            'page_size': ConjureFieldDefinition('pageSize', int),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_reference_ts', '_page_size', '_context']

    def __init__(self, context: "scout_compute_api_Context", node: "scout_compute_api_ComputableNode", page_size: int, reference_ts: "api_Timestamp") -> None:
        self._node = node
        self._reference_ts = reference_ts
        self._page_size = page_size
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def reference_ts(self) -> "api_Timestamp":
        return self._reference_ts

    @builtins.property
    def page_size(self) -> int:
        return self._page_size

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeNodeFromReferenceRequest.__name__ = "ComputeNodeFromReferenceRequest"
scout_compute_api_ComputeNodeFromReferenceRequest.__qualname__ = "ComputeNodeFromReferenceRequest"
scout_compute_api_ComputeNodeFromReferenceRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_start', '_end', '_context']

    def __init__(self, context: "scout_compute_api_Context", end: "api_Timestamp", node: "scout_compute_api_ComputableNode", start: "api_Timestamp") -> None:
        self._node = node
        self._start = start
        self._end = end
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeNodeRequest.__name__ = "ComputeNodeRequest"
scout_compute_api_ComputeNodeRequest.__qualname__ = "ComputeNodeRequest"
scout_compute_api_ComputeNodeRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeResponse(ConjureUnionType):
    _range: Optional[List["scout_compute_api_Range"]] = None
    _ranges_summary: Optional["scout_compute_api_RangesSummary"] = None
    _range_value: Optional[Optional["scout_compute_api_Range"]] = None
    _numeric: Optional["scout_compute_api_NumericPlot"] = None
    _bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None
    _numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None
    _single_point: Optional[Optional["scout_compute_api_SinglePoint"]] = None
    _arrow_numeric: Optional["scout_compute_api_ArrowNumericPlot"] = None
    _arrow_bucketed_numeric: Optional["scout_compute_api_ArrowBucketedNumericPlot"] = None
    _enum: Optional["scout_compute_api_EnumPlot"] = None
    _enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None
    _bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None
    _arrow_enum: Optional["scout_compute_api_ArrowEnumPlot"] = None
    _arrow_bucketed_enum: Optional["scout_compute_api_ArrowBucketedEnumPlot"] = None
    _paged_log: Optional["scout_compute_api_PagedLogPlot"] = None
    _log_point: Optional[Optional["scout_compute_api_LogPoint"]] = None
    _cartesian: Optional["scout_compute_api_CartesianPlot"] = None
    _bucketed_cartesian: Optional["scout_compute_api_BucketedCartesianPlot"] = None
    _bucketed_cartesian3d: Optional["scout_compute_api_BucketedCartesian3dPlot"] = None
    _frequency_domain: Optional["scout_compute_api_FrequencyDomainPlot"] = None
    _frequency_domain_v2: Optional["scout_compute_api_FrequencyDomainPlotV2"] = None
    _numeric_histogram: Optional["scout_compute_api_NumericHistogramPlot"] = None
    _enum_histogram: Optional["scout_compute_api_EnumHistogramPlot"] = None
    _curve_fit: Optional["scout_compute_api_CurveFitResult"] = None
    _grouped: Optional["scout_compute_api_GroupedComputeNodeResponses"] = None
    _array: Optional["scout_compute_api_ArrowArrayPlot"] = None
    _bucketed_struct: Optional["scout_compute_api_ArrowBucketedStructPlot"] = None
    _full_resolution: Optional["scout_compute_api_ArrowFullResolutionPlot"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range': ConjureFieldDefinition('range', List[scout_compute_api_Range]),
            'ranges_summary': ConjureFieldDefinition('rangesSummary', scout_compute_api_RangesSummary),
            'range_value': ConjureFieldDefinition('rangeValue', OptionalTypeWrapper[scout_compute_api_Range]),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericPlot),
            'bucketed_numeric': ConjureFieldDefinition('bucketedNumeric', scout_compute_api_BucketedNumericPlot),
            'numeric_point': ConjureFieldDefinition('numericPoint', OptionalTypeWrapper[scout_compute_api_NumericPoint]),
            'single_point': ConjureFieldDefinition('singlePoint', OptionalTypeWrapper[scout_compute_api_SinglePoint]),
            'arrow_numeric': ConjureFieldDefinition('arrowNumeric', scout_compute_api_ArrowNumericPlot),
            'arrow_bucketed_numeric': ConjureFieldDefinition('arrowBucketedNumeric', scout_compute_api_ArrowBucketedNumericPlot),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumPlot),
            'enum_point': ConjureFieldDefinition('enumPoint', OptionalTypeWrapper[scout_compute_api_EnumPoint]),
            'bucketed_enum': ConjureFieldDefinition('bucketedEnum', scout_compute_api_BucketedEnumPlot),
            'arrow_enum': ConjureFieldDefinition('arrowEnum', scout_compute_api_ArrowEnumPlot),
            'arrow_bucketed_enum': ConjureFieldDefinition('arrowBucketedEnum', scout_compute_api_ArrowBucketedEnumPlot),
            'paged_log': ConjureFieldDefinition('pagedLog', scout_compute_api_PagedLogPlot),
            'log_point': ConjureFieldDefinition('logPoint', OptionalTypeWrapper[scout_compute_api_LogPoint]),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_CartesianPlot),
            'bucketed_cartesian': ConjureFieldDefinition('bucketedCartesian', scout_compute_api_BucketedCartesianPlot),
            'bucketed_cartesian3d': ConjureFieldDefinition('bucketedCartesian3d', scout_compute_api_BucketedCartesian3dPlot),
            'frequency_domain': ConjureFieldDefinition('frequencyDomain', scout_compute_api_FrequencyDomainPlot),
            'frequency_domain_v2': ConjureFieldDefinition('frequencyDomainV2', scout_compute_api_FrequencyDomainPlotV2),
            'numeric_histogram': ConjureFieldDefinition('numericHistogram', scout_compute_api_NumericHistogramPlot),
            'enum_histogram': ConjureFieldDefinition('enumHistogram', scout_compute_api_EnumHistogramPlot),
            'curve_fit': ConjureFieldDefinition('curveFit', scout_compute_api_CurveFitResult),
            'grouped': ConjureFieldDefinition('grouped', scout_compute_api_GroupedComputeNodeResponses),
            'array': ConjureFieldDefinition('array', scout_compute_api_ArrowArrayPlot),
            'bucketed_struct': ConjureFieldDefinition('bucketedStruct', scout_compute_api_ArrowBucketedStructPlot),
            'full_resolution': ConjureFieldDefinition('fullResolution', scout_compute_api_ArrowFullResolutionPlot)
        }

    def __init__(
            self,
            range: Optional[List["scout_compute_api_Range"]] = None,
            ranges_summary: Optional["scout_compute_api_RangesSummary"] = None,
            range_value: Optional[Optional["scout_compute_api_Range"]] = None,
            numeric: Optional["scout_compute_api_NumericPlot"] = None,
            bucketed_numeric: Optional["scout_compute_api_BucketedNumericPlot"] = None,
            numeric_point: Optional[Optional["scout_compute_api_NumericPoint"]] = None,
            single_point: Optional[Optional["scout_compute_api_SinglePoint"]] = None,
            arrow_numeric: Optional["scout_compute_api_ArrowNumericPlot"] = None,
            arrow_bucketed_numeric: Optional["scout_compute_api_ArrowBucketedNumericPlot"] = None,
            enum: Optional["scout_compute_api_EnumPlot"] = None,
            enum_point: Optional[Optional["scout_compute_api_EnumPoint"]] = None,
            bucketed_enum: Optional["scout_compute_api_BucketedEnumPlot"] = None,
            arrow_enum: Optional["scout_compute_api_ArrowEnumPlot"] = None,
            arrow_bucketed_enum: Optional["scout_compute_api_ArrowBucketedEnumPlot"] = None,
            paged_log: Optional["scout_compute_api_PagedLogPlot"] = None,
            log_point: Optional[Optional["scout_compute_api_LogPoint"]] = None,
            cartesian: Optional["scout_compute_api_CartesianPlot"] = None,
            bucketed_cartesian: Optional["scout_compute_api_BucketedCartesianPlot"] = None,
            bucketed_cartesian3d: Optional["scout_compute_api_BucketedCartesian3dPlot"] = None,
            frequency_domain: Optional["scout_compute_api_FrequencyDomainPlot"] = None,
            frequency_domain_v2: Optional["scout_compute_api_FrequencyDomainPlotV2"] = None,
            numeric_histogram: Optional["scout_compute_api_NumericHistogramPlot"] = None,
            enum_histogram: Optional["scout_compute_api_EnumHistogramPlot"] = None,
            curve_fit: Optional["scout_compute_api_CurveFitResult"] = None,
            grouped: Optional["scout_compute_api_GroupedComputeNodeResponses"] = None,
            array: Optional["scout_compute_api_ArrowArrayPlot"] = None,
            bucketed_struct: Optional["scout_compute_api_ArrowBucketedStructPlot"] = None,
            full_resolution: Optional["scout_compute_api_ArrowFullResolutionPlot"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (range is not None) + (ranges_summary is not None) + (range_value is not None) + (numeric is not None) + (bucketed_numeric is not None) + (numeric_point is not None) + (single_point is not None) + (arrow_numeric is not None) + (arrow_bucketed_numeric is not None) + (enum is not None) + (enum_point is not None) + (bucketed_enum is not None) + (arrow_enum is not None) + (arrow_bucketed_enum is not None) + (paged_log is not None) + (log_point is not None) + (cartesian is not None) + (bucketed_cartesian is not None) + (bucketed_cartesian3d is not None) + (frequency_domain is not None) + (frequency_domain_v2 is not None) + (numeric_histogram is not None) + (enum_histogram is not None) + (curve_fit is not None) + (grouped is not None) + (array is not None) + (bucketed_struct is not None) + (full_resolution is not None) != 1:
                raise ValueError('a union must contain a single member')

            if range is not None:
                self._range = range
                self._type = 'range'
            if ranges_summary is not None:
                self._ranges_summary = ranges_summary
                self._type = 'rangesSummary'
            if range_value is not None:
                self._range_value = range_value
                self._type = 'rangeValue'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if bucketed_numeric is not None:
                self._bucketed_numeric = bucketed_numeric
                self._type = 'bucketedNumeric'
            if numeric_point is not None:
                self._numeric_point = numeric_point
                self._type = 'numericPoint'
            if single_point is not None:
                self._single_point = single_point
                self._type = 'singlePoint'
            if arrow_numeric is not None:
                self._arrow_numeric = arrow_numeric
                self._type = 'arrowNumeric'
            if arrow_bucketed_numeric is not None:
                self._arrow_bucketed_numeric = arrow_bucketed_numeric
                self._type = 'arrowBucketedNumeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if enum_point is not None:
                self._enum_point = enum_point
                self._type = 'enumPoint'
            if bucketed_enum is not None:
                self._bucketed_enum = bucketed_enum
                self._type = 'bucketedEnum'
            if arrow_enum is not None:
                self._arrow_enum = arrow_enum
                self._type = 'arrowEnum'
            if arrow_bucketed_enum is not None:
                self._arrow_bucketed_enum = arrow_bucketed_enum
                self._type = 'arrowBucketedEnum'
            if paged_log is not None:
                self._paged_log = paged_log
                self._type = 'pagedLog'
            if log_point is not None:
                self._log_point = log_point
                self._type = 'logPoint'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if bucketed_cartesian is not None:
                self._bucketed_cartesian = bucketed_cartesian
                self._type = 'bucketedCartesian'
            if bucketed_cartesian3d is not None:
                self._bucketed_cartesian3d = bucketed_cartesian3d
                self._type = 'bucketedCartesian3d'
            if frequency_domain is not None:
                self._frequency_domain = frequency_domain
                self._type = 'frequencyDomain'
            if frequency_domain_v2 is not None:
                self._frequency_domain_v2 = frequency_domain_v2
                self._type = 'frequencyDomainV2'
            if numeric_histogram is not None:
                self._numeric_histogram = numeric_histogram
                self._type = 'numericHistogram'
            if enum_histogram is not None:
                self._enum_histogram = enum_histogram
                self._type = 'enumHistogram'
            if curve_fit is not None:
                self._curve_fit = curve_fit
                self._type = 'curveFit'
            if grouped is not None:
                self._grouped = grouped
                self._type = 'grouped'
            if array is not None:
                self._array = array
                self._type = 'array'
            if bucketed_struct is not None:
                self._bucketed_struct = bucketed_struct
                self._type = 'bucketedStruct'
            if full_resolution is not None:
                self._full_resolution = full_resolution
                self._type = 'fullResolution'

        elif type_of_union == 'range':
            if range is None:
                raise ValueError('a union value must not be None')
            self._range = range
            self._type = 'range'
        elif type_of_union == 'rangesSummary':
            if ranges_summary is None:
                raise ValueError('a union value must not be None')
            self._ranges_summary = ranges_summary
            self._type = 'rangesSummary'
        elif type_of_union == 'rangeValue':
            if range_value is None:
                raise ValueError('a union value must not be None')
            self._range_value = range_value
            self._type = 'rangeValue'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'bucketedNumeric':
            if bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._bucketed_numeric = bucketed_numeric
            self._type = 'bucketedNumeric'
        elif type_of_union == 'numericPoint':
            if numeric_point is None:
                raise ValueError('a union value must not be None')
            self._numeric_point = numeric_point
            self._type = 'numericPoint'
        elif type_of_union == 'singlePoint':
            if single_point is None:
                raise ValueError('a union value must not be None')
            self._single_point = single_point
            self._type = 'singlePoint'
        elif type_of_union == 'arrowNumeric':
            if arrow_numeric is None:
                raise ValueError('a union value must not be None')
            self._arrow_numeric = arrow_numeric
            self._type = 'arrowNumeric'
        elif type_of_union == 'arrowBucketedNumeric':
            if arrow_bucketed_numeric is None:
                raise ValueError('a union value must not be None')
            self._arrow_bucketed_numeric = arrow_bucketed_numeric
            self._type = 'arrowBucketedNumeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'enumPoint':
            if enum_point is None:
                raise ValueError('a union value must not be None')
            self._enum_point = enum_point
            self._type = 'enumPoint'
        elif type_of_union == 'bucketedEnum':
            if bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._bucketed_enum = bucketed_enum
            self._type = 'bucketedEnum'
        elif type_of_union == 'arrowEnum':
            if arrow_enum is None:
                raise ValueError('a union value must not be None')
            self._arrow_enum = arrow_enum
            self._type = 'arrowEnum'
        elif type_of_union == 'arrowBucketedEnum':
            if arrow_bucketed_enum is None:
                raise ValueError('a union value must not be None')
            self._arrow_bucketed_enum = arrow_bucketed_enum
            self._type = 'arrowBucketedEnum'
        elif type_of_union == 'pagedLog':
            if paged_log is None:
                raise ValueError('a union value must not be None')
            self._paged_log = paged_log
            self._type = 'pagedLog'
        elif type_of_union == 'logPoint':
            if log_point is None:
                raise ValueError('a union value must not be None')
            self._log_point = log_point
            self._type = 'logPoint'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'bucketedCartesian':
            if bucketed_cartesian is None:
                raise ValueError('a union value must not be None')
            self._bucketed_cartesian = bucketed_cartesian
            self._type = 'bucketedCartesian'
        elif type_of_union == 'bucketedCartesian3d':
            if bucketed_cartesian3d is None:
                raise ValueError('a union value must not be None')
            self._bucketed_cartesian3d = bucketed_cartesian3d
            self._type = 'bucketedCartesian3d'
        elif type_of_union == 'frequencyDomain':
            if frequency_domain is None:
                raise ValueError('a union value must not be None')
            self._frequency_domain = frequency_domain
            self._type = 'frequencyDomain'
        elif type_of_union == 'frequencyDomainV2':
            if frequency_domain_v2 is None:
                raise ValueError('a union value must not be None')
            self._frequency_domain_v2 = frequency_domain_v2
            self._type = 'frequencyDomainV2'
        elif type_of_union == 'numericHistogram':
            if numeric_histogram is None:
                raise ValueError('a union value must not be None')
            self._numeric_histogram = numeric_histogram
            self._type = 'numericHistogram'
        elif type_of_union == 'enumHistogram':
            if enum_histogram is None:
                raise ValueError('a union value must not be None')
            self._enum_histogram = enum_histogram
            self._type = 'enumHistogram'
        elif type_of_union == 'curveFit':
            if curve_fit is None:
                raise ValueError('a union value must not be None')
            self._curve_fit = curve_fit
            self._type = 'curveFit'
        elif type_of_union == 'grouped':
            if grouped is None:
                raise ValueError('a union value must not be None')
            self._grouped = grouped
            self._type = 'grouped'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'bucketedStruct':
            if bucketed_struct is None:
                raise ValueError('a union value must not be None')
            self._bucketed_struct = bucketed_struct
            self._type = 'bucketedStruct'
        elif type_of_union == 'fullResolution':
            if full_resolution is None:
                raise ValueError('a union value must not be None')
            self._full_resolution = full_resolution
            self._type = 'fullResolution'

    @builtins.property
    def range(self) -> Optional[List["scout_compute_api_Range"]]:
        return self._range

    @builtins.property
    def ranges_summary(self) -> Optional["scout_compute_api_RangesSummary"]:
        return self._ranges_summary

    @builtins.property
    def range_value(self) -> Optional[Optional["scout_compute_api_Range"]]:
        return self._range_value

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericPlot"]:
        return self._numeric

    @builtins.property
    def bucketed_numeric(self) -> Optional["scout_compute_api_BucketedNumericPlot"]:
        return self._bucketed_numeric

    @builtins.property
    def numeric_point(self) -> Optional[Optional["scout_compute_api_NumericPoint"]]:
        return self._numeric_point

    @builtins.property
    def single_point(self) -> Optional[Optional["scout_compute_api_SinglePoint"]]:
        return self._single_point

    @builtins.property
    def arrow_numeric(self) -> Optional["scout_compute_api_ArrowNumericPlot"]:
        return self._arrow_numeric

    @builtins.property
    def arrow_bucketed_numeric(self) -> Optional["scout_compute_api_ArrowBucketedNumericPlot"]:
        return self._arrow_bucketed_numeric

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumPlot"]:
        return self._enum

    @builtins.property
    def enum_point(self) -> Optional[Optional["scout_compute_api_EnumPoint"]]:
        return self._enum_point

    @builtins.property
    def bucketed_enum(self) -> Optional["scout_compute_api_BucketedEnumPlot"]:
        return self._bucketed_enum

    @builtins.property
    def arrow_enum(self) -> Optional["scout_compute_api_ArrowEnumPlot"]:
        return self._arrow_enum

    @builtins.property
    def arrow_bucketed_enum(self) -> Optional["scout_compute_api_ArrowBucketedEnumPlot"]:
        return self._arrow_bucketed_enum

    @builtins.property
    def paged_log(self) -> Optional["scout_compute_api_PagedLogPlot"]:
        return self._paged_log

    @builtins.property
    def log_point(self) -> Optional[Optional["scout_compute_api_LogPoint"]]:
        return self._log_point

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_CartesianPlot"]:
        return self._cartesian

    @builtins.property
    def bucketed_cartesian(self) -> Optional["scout_compute_api_BucketedCartesianPlot"]:
        return self._bucketed_cartesian

    @builtins.property
    def bucketed_cartesian3d(self) -> Optional["scout_compute_api_BucketedCartesian3dPlot"]:
        return self._bucketed_cartesian3d

    @builtins.property
    def frequency_domain(self) -> Optional["scout_compute_api_FrequencyDomainPlot"]:
        return self._frequency_domain

    @builtins.property
    def frequency_domain_v2(self) -> Optional["scout_compute_api_FrequencyDomainPlotV2"]:
        return self._frequency_domain_v2

    @builtins.property
    def numeric_histogram(self) -> Optional["scout_compute_api_NumericHistogramPlot"]:
        return self._numeric_histogram

    @builtins.property
    def enum_histogram(self) -> Optional["scout_compute_api_EnumHistogramPlot"]:
        return self._enum_histogram

    @builtins.property
    def curve_fit(self) -> Optional["scout_compute_api_CurveFitResult"]:
        return self._curve_fit

    @builtins.property
    def grouped(self) -> Optional["scout_compute_api_GroupedComputeNodeResponses"]:
        return self._grouped

    @builtins.property
    def array(self) -> Optional["scout_compute_api_ArrowArrayPlot"]:
        return self._array

    @builtins.property
    def bucketed_struct(self) -> Optional["scout_compute_api_ArrowBucketedStructPlot"]:
        return self._bucketed_struct

    @builtins.property
    def full_resolution(self) -> Optional["scout_compute_api_ArrowFullResolutionPlot"]:
        return self._full_resolution

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeNodeResponseVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeNodeResponseVisitor'.format(visitor.__class__.__name__))
        if self._type == 'range' and self.range is not None:
            return visitor._range(self.range)
        if self._type == 'rangesSummary' and self.ranges_summary is not None:
            return visitor._ranges_summary(self.ranges_summary)
        if self._type == 'rangeValue' and self.range_value is not None:
            return visitor._range_value(self.range_value)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'bucketedNumeric' and self.bucketed_numeric is not None:
            return visitor._bucketed_numeric(self.bucketed_numeric)
        if self._type == 'numericPoint' and self.numeric_point is not None:
            return visitor._numeric_point(self.numeric_point)
        if self._type == 'singlePoint' and self.single_point is not None:
            return visitor._single_point(self.single_point)
        if self._type == 'arrowNumeric' and self.arrow_numeric is not None:
            return visitor._arrow_numeric(self.arrow_numeric)
        if self._type == 'arrowBucketedNumeric' and self.arrow_bucketed_numeric is not None:
            return visitor._arrow_bucketed_numeric(self.arrow_bucketed_numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'enumPoint' and self.enum_point is not None:
            return visitor._enum_point(self.enum_point)
        if self._type == 'bucketedEnum' and self.bucketed_enum is not None:
            return visitor._bucketed_enum(self.bucketed_enum)
        if self._type == 'arrowEnum' and self.arrow_enum is not None:
            return visitor._arrow_enum(self.arrow_enum)
        if self._type == 'arrowBucketedEnum' and self.arrow_bucketed_enum is not None:
            return visitor._arrow_bucketed_enum(self.arrow_bucketed_enum)
        if self._type == 'pagedLog' and self.paged_log is not None:
            return visitor._paged_log(self.paged_log)
        if self._type == 'logPoint' and self.log_point is not None:
            return visitor._log_point(self.log_point)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'bucketedCartesian' and self.bucketed_cartesian is not None:
            return visitor._bucketed_cartesian(self.bucketed_cartesian)
        if self._type == 'bucketedCartesian3d' and self.bucketed_cartesian3d is not None:
            return visitor._bucketed_cartesian3d(self.bucketed_cartesian3d)
        if self._type == 'frequencyDomain' and self.frequency_domain is not None:
            return visitor._frequency_domain(self.frequency_domain)
        if self._type == 'frequencyDomainV2' and self.frequency_domain_v2 is not None:
            return visitor._frequency_domain_v2(self.frequency_domain_v2)
        if self._type == 'numericHistogram' and self.numeric_histogram is not None:
            return visitor._numeric_histogram(self.numeric_histogram)
        if self._type == 'enumHistogram' and self.enum_histogram is not None:
            return visitor._enum_histogram(self.enum_histogram)
        if self._type == 'curveFit' and self.curve_fit is not None:
            return visitor._curve_fit(self.curve_fit)
        if self._type == 'grouped' and self.grouped is not None:
            return visitor._grouped(self.grouped)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'bucketedStruct' and self.bucketed_struct is not None:
            return visitor._bucketed_struct(self.bucketed_struct)
        if self._type == 'fullResolution' and self.full_resolution is not None:
            return visitor._full_resolution(self.full_resolution)


scout_compute_api_ComputeNodeResponse.__name__ = "ComputeNodeResponse"
scout_compute_api_ComputeNodeResponse.__qualname__ = "ComputeNodeResponse"
scout_compute_api_ComputeNodeResponse.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeResponseVisitor:

    @abstractmethod
    def _range(self, range: List["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _ranges_summary(self, ranges_summary: "scout_compute_api_RangesSummary") -> Any:
        pass

    @abstractmethod
    def _range_value(self, range_value: Optional["scout_compute_api_Range"]) -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_numeric(self, bucketed_numeric: "scout_compute_api_BucketedNumericPlot") -> Any:
        pass

    @abstractmethod
    def _numeric_point(self, numeric_point: Optional["scout_compute_api_NumericPoint"]) -> Any:
        pass

    @abstractmethod
    def _single_point(self, single_point: Optional["scout_compute_api_SinglePoint"]) -> Any:
        pass

    @abstractmethod
    def _arrow_numeric(self, arrow_numeric: "scout_compute_api_ArrowNumericPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_bucketed_numeric(self, arrow_bucketed_numeric: "scout_compute_api_ArrowBucketedNumericPlot") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumPlot") -> Any:
        pass

    @abstractmethod
    def _enum_point(self, enum_point: Optional["scout_compute_api_EnumPoint"]) -> Any:
        pass

    @abstractmethod
    def _bucketed_enum(self, bucketed_enum: "scout_compute_api_BucketedEnumPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_enum(self, arrow_enum: "scout_compute_api_ArrowEnumPlot") -> Any:
        pass

    @abstractmethod
    def _arrow_bucketed_enum(self, arrow_bucketed_enum: "scout_compute_api_ArrowBucketedEnumPlot") -> Any:
        pass

    @abstractmethod
    def _paged_log(self, paged_log: "scout_compute_api_PagedLogPlot") -> Any:
        pass

    @abstractmethod
    def _log_point(self, log_point: Optional["scout_compute_api_LogPoint"]) -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_CartesianPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_cartesian(self, bucketed_cartesian: "scout_compute_api_BucketedCartesianPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_cartesian3d(self, bucketed_cartesian3d: "scout_compute_api_BucketedCartesian3dPlot") -> Any:
        pass

    @abstractmethod
    def _frequency_domain(self, frequency_domain: "scout_compute_api_FrequencyDomainPlot") -> Any:
        pass

    @abstractmethod
    def _frequency_domain_v2(self, frequency_domain_v2: "scout_compute_api_FrequencyDomainPlotV2") -> Any:
        pass

    @abstractmethod
    def _numeric_histogram(self, numeric_histogram: "scout_compute_api_NumericHistogramPlot") -> Any:
        pass

    @abstractmethod
    def _enum_histogram(self, enum_histogram: "scout_compute_api_EnumHistogramPlot") -> Any:
        pass

    @abstractmethod
    def _curve_fit(self, curve_fit: "scout_compute_api_CurveFitResult") -> Any:
        pass

    @abstractmethod
    def _grouped(self, grouped: "scout_compute_api_GroupedComputeNodeResponses") -> Any:
        pass

    @abstractmethod
    def _array(self, array: "scout_compute_api_ArrowArrayPlot") -> Any:
        pass

    @abstractmethod
    def _bucketed_struct(self, bucketed_struct: "scout_compute_api_ArrowBucketedStructPlot") -> Any:
        pass

    @abstractmethod
    def _full_resolution(self, full_resolution: "scout_compute_api_ArrowFullResolutionPlot") -> Any:
        pass


scout_compute_api_ComputeNodeResponseVisitor.__name__ = "ComputeNodeResponseVisitor"
scout_compute_api_ComputeNodeResponseVisitor.__qualname__ = "ComputeNodeResponseVisitor"
scout_compute_api_ComputeNodeResponseVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeResult(ConjureUnionType):
    _success: Optional["scout_compute_api_ComputeNodeResponse"] = None
    _error: Optional["scout_compute_api_ErrorResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_compute_api_ComputeNodeResponse),
            'error': ConjureFieldDefinition('error', scout_compute_api_ErrorResult)
        }

    def __init__(
            self,
            success: Optional["scout_compute_api_ComputeNodeResponse"] = None,
            error: Optional["scout_compute_api_ErrorResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def success(self) -> Optional["scout_compute_api_ComputeNodeResponse"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_compute_api_ErrorResult"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeNodeResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeNodeResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


scout_compute_api_ComputeNodeResult.__name__ = "ComputeNodeResult"
scout_compute_api_ComputeNodeResult.__qualname__ = "ComputeNodeResult"
scout_compute_api_ComputeNodeResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeResultVisitor:

    @abstractmethod
    def _success(self, success: "scout_compute_api_ComputeNodeResponse") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_compute_api_ErrorResult") -> Any:
        pass


scout_compute_api_ComputeNodeResultVisitor.__name__ = "ComputeNodeResultVisitor"
scout_compute_api_ComputeNodeResultVisitor.__qualname__ = "ComputeNodeResultVisitor"
scout_compute_api_ComputeNodeResultVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeNodeWithContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_node': ConjureFieldDefinition('seriesNode', scout_compute_api_ComputeNode),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_series_node', '_context']

    def __init__(self, context: "scout_compute_api_Context", series_node: "scout_compute_api_ComputeNode") -> None:
        self._series_node = series_node
        self._context = context

    @builtins.property
    def series_node(self) -> "scout_compute_api_ComputeNode":
        return self._series_node

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeNodeWithContext.__name__ = "ComputeNodeWithContext"
scout_compute_api_ComputeNodeWithContext.__qualname__ = "ComputeNodeWithContext"
scout_compute_api_ComputeNodeWithContext.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeService(Service):
    """The Compute Service provides the ability to compute the output of compute graphs.
    """

    def compute(self, auth_header: str, request: "scout_compute_api_ComputeNodeRequest") -> "scout_compute_api_ComputeNodeResponse":
        """Computes the output of the compute graph specified by a ComputeNodeRequest.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/compute'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ComputeNodeResponse, self._return_none_for_unknown_union_types)

    def parameterized_compute(self, auth_header: str, request: "scout_compute_api_ParameterizedComputeNodeRequest") -> "scout_compute_api_ParameterizedComputeNodeResponse":
        """Computes the output of the compute graph specified by a ParameterizedComputeNodeRequest. A parameterized 
compute request supports multiple values for a single variable, supplied by the ParameterizedContext.
Results are returned in the same order of the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/compute/parameterized'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ParameterizedComputeNodeResponse, self._return_none_for_unknown_union_types)

    def compute_units(self, auth_header: str, request: "scout_compute_api_ComputeUnitsRequest") -> "scout_compute_api_ComputeUnitResult":
        """Returns the resulting unit for the output of a compute graph. If the resulting unit is equivalent to exactly
one existing unit in the system, it will be returned (for example, a series in Coulombs divided by a series
in Volts will return an output of Farads). If the output does not have units (for example, a range output,)
the unit result will return noUnitAvailable, and if the computation was not successful, corresponding errors
are returned.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/compute/units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ComputeUnitResult, self._return_none_for_unknown_union_types)

    def batch_compute_with_units(self, auth_header: str, request: "scout_compute_api_BatchComputeWithUnitsRequest") -> "scout_compute_api_BatchComputeWithUnitsResponse":
        """Computes the output of compute graphs specified by BatchComputeNodeRequest. Results are returned in the same
order as the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/compute/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_BatchComputeWithUnitsResponse, self._return_none_for_unknown_union_types)

    def batch_compute_units(self, auth_header: str, request: "scout_compute_api_BatchComputeUnitsRequest") -> "scout_compute_api_BatchComputeUnitResult":
        """Same as computeUnits, however this endpoint functions on a batch of requests for wire efficiency purposes. An
extra note is that this method will serialize underlying conjure errors into the BatchComputeUnitResult type,
meaning callers are required to check for errors explicitly (rather than relying on exceptions being thrown).
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/compute/batch-units'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_BatchComputeUnitResult, self._return_none_for_unknown_union_types)

    def compute_with_units(self, auth_header: str, request: "scout_compute_api_ComputeNodeRequest") -> "scout_compute_api_ComputeWithUnitsResponse":
        """Computes the output of the compute graph specified by a ComputeNodeRequest, as well as providing the resulting 
unit for the output of a compute graph. If the resulting unit is equivalent to exactly one existing unit in the 
system, it will be returned (for example, a series in Coulombs divided by a series in Volts will return an 
output of Farads). If the output does not have units (for example, a range output,) the unit result will return 
noUnitAvailable, and if the computation was not successful, corresponding errors are returned.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/compute/v2/computeWithUnits'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_compute_api_ComputeWithUnitsResponse, self._return_none_for_unknown_union_types)


scout_compute_api_ComputeService.__name__ = "ComputeService"
scout_compute_api_ComputeService.__qualname__ = "ComputeService"
scout_compute_api_ComputeService.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeUnitResult(ConjureUnionType):
    _single: Optional["scout_compute_api_UnitResult"] = None
    _cartesian: Optional["scout_compute_api_CartesianUnitResult"] = None
    _cartesian3d: Optional["scout_compute_api_Cartesian3dUnitResult"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single': ConjureFieldDefinition('single', scout_compute_api_UnitResult),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_CartesianUnitResult),
            'cartesian3d': ConjureFieldDefinition('cartesian3d', scout_compute_api_Cartesian3dUnitResult)
        }

    def __init__(
            self,
            single: Optional["scout_compute_api_UnitResult"] = None,
            cartesian: Optional["scout_compute_api_CartesianUnitResult"] = None,
            cartesian3d: Optional["scout_compute_api_Cartesian3dUnitResult"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single is not None) + (cartesian is not None) + (cartesian3d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single is not None:
                self._single = single
                self._type = 'single'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if cartesian3d is not None:
                self._cartesian3d = cartesian3d
                self._type = 'cartesian3d'

        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'cartesian3d':
            if cartesian3d is None:
                raise ValueError('a union value must not be None')
            self._cartesian3d = cartesian3d
            self._type = 'cartesian3d'

    @builtins.property
    def single(self) -> Optional["scout_compute_api_UnitResult"]:
        return self._single

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_CartesianUnitResult"]:
        return self._cartesian

    @builtins.property
    def cartesian3d(self) -> Optional["scout_compute_api_Cartesian3dUnitResult"]:
        return self._cartesian3d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ComputeUnitResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ComputeUnitResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'cartesian3d' and self.cartesian3d is not None:
            return visitor._cartesian3d(self.cartesian3d)


scout_compute_api_ComputeUnitResult.__name__ = "ComputeUnitResult"
scout_compute_api_ComputeUnitResult.__qualname__ = "ComputeUnitResult"
scout_compute_api_ComputeUnitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeUnitResultVisitor:

    @abstractmethod
    def _single(self, single: "scout_compute_api_UnitResult") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_CartesianUnitResult") -> Any:
        pass

    @abstractmethod
    def _cartesian3d(self, cartesian3d: "scout_compute_api_Cartesian3dUnitResult") -> Any:
        pass


scout_compute_api_ComputeUnitResultVisitor.__name__ = "ComputeUnitResultVisitor"
scout_compute_api_ComputeUnitResultVisitor.__qualname__ = "ComputeUnitResultVisitor"
scout_compute_api_ComputeUnitResultVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeUnitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_node', '_context']

    def __init__(self, context: "scout_compute_api_Context", node: "scout_compute_api_ComputableNode") -> None:
        self._node = node
        self._context = context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_compute_api_ComputeUnitsRequest.__name__ = "ComputeUnitsRequest"
scout_compute_api_ComputeUnitsRequest.__qualname__ = "ComputeUnitsRequest"
scout_compute_api_ComputeUnitsRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeWithUnitsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_result': ConjureFieldDefinition('computeResult', scout_compute_api_ComputeNodeResponse),
            'compute_unit': ConjureFieldDefinition('computeUnit', scout_compute_api_ComputeUnitResult)
        }

    __slots__: List[str] = ['_compute_result', '_compute_unit']

    def __init__(self, compute_result: "scout_compute_api_ComputeNodeResponse", compute_unit: "scout_compute_api_ComputeUnitResult") -> None:
        self._compute_result = compute_result
        self._compute_unit = compute_unit

    @builtins.property
    def compute_result(self) -> "scout_compute_api_ComputeNodeResponse":
        return self._compute_result

    @builtins.property
    def compute_unit(self) -> "scout_compute_api_ComputeUnitResult":
        return self._compute_unit


scout_compute_api_ComputeWithUnitsResponse.__name__ = "ComputeWithUnitsResponse"
scout_compute_api_ComputeWithUnitsResponse.__qualname__ = "ComputeWithUnitsResponse"
scout_compute_api_ComputeWithUnitsResponse.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ComputeWithUnitsResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'compute_result': ConjureFieldDefinition('computeResult', scout_compute_api_ComputeNodeResult),
            'unit_result': ConjureFieldDefinition('unitResult', scout_compute_api_ComputeUnitResult)
        }

    __slots__: List[str] = ['_compute_result', '_unit_result']

    def __init__(self, compute_result: "scout_compute_api_ComputeNodeResult", unit_result: "scout_compute_api_ComputeUnitResult") -> None:
        self._compute_result = compute_result
        self._unit_result = unit_result

    @builtins.property
    def compute_result(self) -> "scout_compute_api_ComputeNodeResult":
        return self._compute_result

    @builtins.property
    def unit_result(self) -> "scout_compute_api_ComputeUnitResult":
        return self._unit_result


scout_compute_api_ComputeWithUnitsResult.__name__ = "ComputeWithUnitsResult"
scout_compute_api_ComputeWithUnitsResult.__qualname__ = "ComputeWithUnitsResult"
scout_compute_api_ComputeWithUnitsResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Context(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'function_variables': ConjureFieldDefinition('functionVariables', OptionalTypeWrapper[Dict[scout_compute_api_FunctionReference, scout_compute_api_FunctionVariables]])
        }

    __slots__: List[str] = ['_variables', '_function_variables']

    def __init__(self, variables: Dict[str, "scout_compute_api_VariableValue"], function_variables: Optional[Dict[str, "scout_compute_api_FunctionVariables"]] = None) -> None:
        self._variables = variables
        self._function_variables = function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def function_variables(self) -> Optional[Dict[str, "scout_compute_api_FunctionVariables"]]:
        return self._function_variables


scout_compute_api_Context.__name__ = "Context"
scout_compute_api_Context.__qualname__ = "Context"
scout_compute_api_Context.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Count(ConjureBeanType):
    """The number of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Count.__name__ = "Count"
scout_compute_api_Count.__qualname__ = "Count"
scout_compute_api_Count.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Cpsd(ConjureBeanType):
    """Returns the cross-spectral density magnitude and phase of the two input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_NumericSeries),
            'y': ConjureFieldDefinition('y', scout_compute_api_NumericSeries),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool]),
            'output_phase_unit': ConjureFieldDefinition('outputPhaseUnit', OptionalTypeWrapper[scout_compute_api_OutputPhaseUnit])
        }

    __slots__: List[str] = ['_x', '_y', '_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase', '_output_phase_unit']

    def __init__(self, x: "scout_compute_api_NumericSeries", y: "scout_compute_api_NumericSeries", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, output_phase_unit: Optional["scout_compute_api_OutputPhaseUnit"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._x = x
        self._y = y
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase
        self._output_phase_unit = output_phase_unit

    @builtins.property
    def x(self) -> "scout_compute_api_NumericSeries":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_NumericSeries":
        return self._y

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        """The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified.
        """
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        """The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency type
may also rescale the magnitude of the output in order to ensure the density of the output is consistent.
        """
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        """Unwrap the phase of the output. Defaults to true if not specified.
        """
        return self._unwrap_phase

    @builtins.property
    def output_phase_unit(self) -> Optional["scout_compute_api_OutputPhaseUnit"]:
        """The unit of the output phase. Defaults to RADIANS if not specified.
        """
        return self._output_phase_unit


scout_compute_api_Cpsd.__name__ = "Cpsd"
scout_compute_api_Cpsd.__qualname__ = "Cpsd"
scout_compute_api_Cpsd.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CumulativeSumSeries(ConjureBeanType):
    """Calculates the running total of the series values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_TimestampConstant)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_api_NumericSeries", start_timestamp: "scout_compute_api_TimestampConstant") -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._start_timestamp


scout_compute_api_CumulativeSumSeries.__name__ = "CumulativeSumSeries"
scout_compute_api_CumulativeSumSeries.__qualname__ = "CumulativeSumSeries"
scout_compute_api_CumulativeSumSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'curve_fit_plot_type': ConjureFieldDefinition('curveFitPlotType', scout_compute_api_CurveFitPlotType),
            'curve_fit_details': ConjureFieldDefinition('curveFitDetails', scout_compute_api_CurveFitDetails),
            'curve_fit_options': ConjureFieldDefinition('curveFitOptions', scout_compute_api_CurveFitOptions)
        }

    __slots__: List[str] = ['_curve_fit_plot_type', '_curve_fit_details', '_curve_fit_options']

    def __init__(self, curve_fit_details: "scout_compute_api_CurveFitDetails", curve_fit_options: "scout_compute_api_CurveFitOptions", curve_fit_plot_type: "scout_compute_api_CurveFitPlotType") -> None:
        self._curve_fit_plot_type = curve_fit_plot_type
        self._curve_fit_details = curve_fit_details
        self._curve_fit_options = curve_fit_options

    @builtins.property
    def curve_fit_plot_type(self) -> "scout_compute_api_CurveFitPlotType":
        return self._curve_fit_plot_type

    @builtins.property
    def curve_fit_details(self) -> "scout_compute_api_CurveFitDetails":
        return self._curve_fit_details

    @builtins.property
    def curve_fit_options(self) -> "scout_compute_api_CurveFitOptions":
        return self._curve_fit_options


scout_compute_api_CurveFit.__name__ = "CurveFit"
scout_compute_api_CurveFit.__qualname__ = "CurveFit"
scout_compute_api_CurveFit.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitDetails(ConjureUnionType):
    _exponential: Optional["scout_compute_api_ExponentialCurve"] = None
    _logarithmic: Optional["scout_compute_api_LogarithmicCurve"] = None
    _polynomial: Optional["scout_compute_api_PolynomialCurve"] = None
    _power: Optional["scout_compute_api_PowerCurve"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'exponential': ConjureFieldDefinition('exponential', scout_compute_api_ExponentialCurve),
            'logarithmic': ConjureFieldDefinition('logarithmic', scout_compute_api_LogarithmicCurve),
            'polynomial': ConjureFieldDefinition('polynomial', scout_compute_api_PolynomialCurve),
            'power': ConjureFieldDefinition('power', scout_compute_api_PowerCurve)
        }

    def __init__(
            self,
            exponential: Optional["scout_compute_api_ExponentialCurve"] = None,
            logarithmic: Optional["scout_compute_api_LogarithmicCurve"] = None,
            polynomial: Optional["scout_compute_api_PolynomialCurve"] = None,
            power: Optional["scout_compute_api_PowerCurve"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (exponential is not None) + (logarithmic is not None) + (polynomial is not None) + (power is not None) != 1:
                raise ValueError('a union must contain a single member')

            if exponential is not None:
                self._exponential = exponential
                self._type = 'exponential'
            if logarithmic is not None:
                self._logarithmic = logarithmic
                self._type = 'logarithmic'
            if polynomial is not None:
                self._polynomial = polynomial
                self._type = 'polynomial'
            if power is not None:
                self._power = power
                self._type = 'power'

        elif type_of_union == 'exponential':
            if exponential is None:
                raise ValueError('a union value must not be None')
            self._exponential = exponential
            self._type = 'exponential'
        elif type_of_union == 'logarithmic':
            if logarithmic is None:
                raise ValueError('a union value must not be None')
            self._logarithmic = logarithmic
            self._type = 'logarithmic'
        elif type_of_union == 'polynomial':
            if polynomial is None:
                raise ValueError('a union value must not be None')
            self._polynomial = polynomial
            self._type = 'polynomial'
        elif type_of_union == 'power':
            if power is None:
                raise ValueError('a union value must not be None')
            self._power = power
            self._type = 'power'

    @builtins.property
    def exponential(self) -> Optional["scout_compute_api_ExponentialCurve"]:
        return self._exponential

    @builtins.property
    def logarithmic(self) -> Optional["scout_compute_api_LogarithmicCurve"]:
        return self._logarithmic

    @builtins.property
    def polynomial(self) -> Optional["scout_compute_api_PolynomialCurve"]:
        return self._polynomial

    @builtins.property
    def power(self) -> Optional["scout_compute_api_PowerCurve"]:
        return self._power

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_CurveFitDetailsVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_CurveFitDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'exponential' and self.exponential is not None:
            return visitor._exponential(self.exponential)
        if self._type == 'logarithmic' and self.logarithmic is not None:
            return visitor._logarithmic(self.logarithmic)
        if self._type == 'polynomial' and self.polynomial is not None:
            return visitor._polynomial(self.polynomial)
        if self._type == 'power' and self.power is not None:
            return visitor._power(self.power)


scout_compute_api_CurveFitDetails.__name__ = "CurveFitDetails"
scout_compute_api_CurveFitDetails.__qualname__ = "CurveFitDetails"
scout_compute_api_CurveFitDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitDetailsVisitor:

    @abstractmethod
    def _exponential(self, exponential: "scout_compute_api_ExponentialCurve") -> Any:
        pass

    @abstractmethod
    def _logarithmic(self, logarithmic: "scout_compute_api_LogarithmicCurve") -> Any:
        pass

    @abstractmethod
    def _polynomial(self, polynomial: "scout_compute_api_PolynomialCurve") -> Any:
        pass

    @abstractmethod
    def _power(self, power: "scout_compute_api_PowerCurve") -> Any:
        pass


scout_compute_api_CurveFitDetailsVisitor.__name__ = "CurveFitDetailsVisitor"
scout_compute_api_CurveFitDetailsVisitor.__qualname__ = "CurveFitDetailsVisitor"
scout_compute_api_CurveFitDetailsVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', scout_compute_api_TimestampConstant),
            'end_time': ConjureFieldDefinition('endTime', scout_compute_api_TimestampConstant)
        }

    __slots__: List[str] = ['_start_time', '_end_time']

    def __init__(self, end_time: "scout_compute_api_TimestampConstant", start_time: "scout_compute_api_TimestampConstant") -> None:
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def start_time(self) -> "scout_compute_api_TimestampConstant":
        return self._start_time

    @builtins.property
    def end_time(self) -> "scout_compute_api_TimestampConstant":
        return self._end_time


scout_compute_api_CurveFitOptions.__name__ = "CurveFitOptions"
scout_compute_api_CurveFitOptions.__qualname__ = "CurveFitOptions"
scout_compute_api_CurveFitOptions.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitPlotType(ConjureUnionType):
    _time_series: Optional["scout_compute_api_TimeSeriesCurveFit"] = None
    _scatter: Optional["scout_compute_api_ScatterCurveFit"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_series': ConjureFieldDefinition('timeSeries', scout_compute_api_TimeSeriesCurveFit),
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_ScatterCurveFit)
        }

    def __init__(
            self,
            time_series: Optional["scout_compute_api_TimeSeriesCurveFit"] = None,
            scatter: Optional["scout_compute_api_ScatterCurveFit"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_series is not None) + (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_series is not None:
                self._time_series = time_series
                self._type = 'timeSeries'
            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'timeSeries':
            if time_series is None:
                raise ValueError('a union value must not be None')
            self._time_series = time_series
            self._type = 'timeSeries'
        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def time_series(self) -> Optional["scout_compute_api_TimeSeriesCurveFit"]:
        return self._time_series

    @builtins.property
    def scatter(self) -> Optional["scout_compute_api_ScatterCurveFit"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_CurveFitPlotTypeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_CurveFitPlotTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeSeries' and self.time_series is not None:
            return visitor._time_series(self.time_series)
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_api_CurveFitPlotType.__name__ = "CurveFitPlotType"
scout_compute_api_CurveFitPlotType.__qualname__ = "CurveFitPlotType"
scout_compute_api_CurveFitPlotType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitPlotTypeVisitor:

    @abstractmethod
    def _time_series(self, time_series: "scout_compute_api_TimeSeriesCurveFit") -> Any:
        pass

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_api_ScatterCurveFit") -> Any:
        pass


scout_compute_api_CurveFitPlotTypeVisitor.__name__ = "CurveFitPlotTypeVisitor"
scout_compute_api_CurveFitPlotTypeVisitor.__qualname__ = "CurveFitPlotTypeVisitor"
scout_compute_api_CurveFitPlotTypeVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveFitResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'r2': ConjureFieldDefinition('r2', float),
            'curve_result_details': ConjureFieldDefinition('curveResultDetails', scout_compute_api_CurveResultDetails)
        }

    __slots__: List[str] = ['_r2', '_curve_result_details']

    def __init__(self, curve_result_details: "scout_compute_api_CurveResultDetails", r2: float) -> None:
        self._r2 = r2
        self._curve_result_details = curve_result_details

    @builtins.property
    def r2(self) -> float:
        """R^2 (coefficient of determination) for the fit curve, a normalized measure of how well the curve fits the data.
Usually ranges from 0 to 1, with higher indicating better fit (points closer to fit line).
        """
        return self._r2

    @builtins.property
    def curve_result_details(self) -> "scout_compute_api_CurveResultDetails":
        """Description of the fit curve.
        """
        return self._curve_result_details


scout_compute_api_CurveFitResult.__name__ = "CurveFitResult"
scout_compute_api_CurveFitResult.__qualname__ = "CurveFitResult"
scout_compute_api_CurveFitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveResultDetails(ConjureUnionType):
    _exponential: Optional["scout_compute_api_ExponentialResultDetails"] = None
    _logarithmic: Optional["scout_compute_api_LogarithmicResultDetails"] = None
    _polynomial: Optional["scout_compute_api_PolynomialResultDetails"] = None
    _power: Optional["scout_compute_api_PowerResultDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'exponential': ConjureFieldDefinition('exponential', scout_compute_api_ExponentialResultDetails),
            'logarithmic': ConjureFieldDefinition('logarithmic', scout_compute_api_LogarithmicResultDetails),
            'polynomial': ConjureFieldDefinition('polynomial', scout_compute_api_PolynomialResultDetails),
            'power': ConjureFieldDefinition('power', scout_compute_api_PowerResultDetails)
        }

    def __init__(
            self,
            exponential: Optional["scout_compute_api_ExponentialResultDetails"] = None,
            logarithmic: Optional["scout_compute_api_LogarithmicResultDetails"] = None,
            polynomial: Optional["scout_compute_api_PolynomialResultDetails"] = None,
            power: Optional["scout_compute_api_PowerResultDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (exponential is not None) + (logarithmic is not None) + (polynomial is not None) + (power is not None) != 1:
                raise ValueError('a union must contain a single member')

            if exponential is not None:
                self._exponential = exponential
                self._type = 'exponential'
            if logarithmic is not None:
                self._logarithmic = logarithmic
                self._type = 'logarithmic'
            if polynomial is not None:
                self._polynomial = polynomial
                self._type = 'polynomial'
            if power is not None:
                self._power = power
                self._type = 'power'

        elif type_of_union == 'exponential':
            if exponential is None:
                raise ValueError('a union value must not be None')
            self._exponential = exponential
            self._type = 'exponential'
        elif type_of_union == 'logarithmic':
            if logarithmic is None:
                raise ValueError('a union value must not be None')
            self._logarithmic = logarithmic
            self._type = 'logarithmic'
        elif type_of_union == 'polynomial':
            if polynomial is None:
                raise ValueError('a union value must not be None')
            self._polynomial = polynomial
            self._type = 'polynomial'
        elif type_of_union == 'power':
            if power is None:
                raise ValueError('a union value must not be None')
            self._power = power
            self._type = 'power'

    @builtins.property
    def exponential(self) -> Optional["scout_compute_api_ExponentialResultDetails"]:
        return self._exponential

    @builtins.property
    def logarithmic(self) -> Optional["scout_compute_api_LogarithmicResultDetails"]:
        return self._logarithmic

    @builtins.property
    def polynomial(self) -> Optional["scout_compute_api_PolynomialResultDetails"]:
        return self._polynomial

    @builtins.property
    def power(self) -> Optional["scout_compute_api_PowerResultDetails"]:
        return self._power

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_CurveResultDetailsVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_CurveResultDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'exponential' and self.exponential is not None:
            return visitor._exponential(self.exponential)
        if self._type == 'logarithmic' and self.logarithmic is not None:
            return visitor._logarithmic(self.logarithmic)
        if self._type == 'polynomial' and self.polynomial is not None:
            return visitor._polynomial(self.polynomial)
        if self._type == 'power' and self.power is not None:
            return visitor._power(self.power)


scout_compute_api_CurveResultDetails.__name__ = "CurveResultDetails"
scout_compute_api_CurveResultDetails.__qualname__ = "CurveResultDetails"
scout_compute_api_CurveResultDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_CurveResultDetailsVisitor:

    @abstractmethod
    def _exponential(self, exponential: "scout_compute_api_ExponentialResultDetails") -> Any:
        pass

    @abstractmethod
    def _logarithmic(self, logarithmic: "scout_compute_api_LogarithmicResultDetails") -> Any:
        pass

    @abstractmethod
    def _polynomial(self, polynomial: "scout_compute_api_PolynomialResultDetails") -> Any:
        pass

    @abstractmethod
    def _power(self, power: "scout_compute_api_PowerResultDetails") -> Any:
        pass


scout_compute_api_CurveResultDetailsVisitor.__name__ = "CurveResultDetailsVisitor"
scout_compute_api_CurveResultDetailsVisitor.__qualname__ = "CurveResultDetailsVisitor"
scout_compute_api_CurveResultDetailsVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DataSourceAndChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'channel': ConjureFieldDefinition('channel', str)
        }

    __slots__: List[str] = ['_data_source_rid', '_channel']

    def __init__(self, channel: str, data_source_rid: str) -> None:
        self._data_source_rid = data_source_rid
        self._channel = channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel


scout_compute_api_DataSourceAndChannel.__name__ = "DataSourceAndChannel"
scout_compute_api_DataSourceAndChannel.__qualname__ = "DataSourceAndChannel"
scout_compute_api_DataSourceAndChannel.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DataSourceChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', scout_compute_api_StringConstant),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_StringConstant),
            'tags': ConjureFieldDefinition('tags', Dict[str, scout_compute_api_StringConstant]),
            'tag_filters': ConjureFieldDefinition('tagFilters', OptionalTypeWrapper[scout_compute_api_TagFilters]),
            'tags_to_group_by': ConjureFieldDefinition('tagsToGroupBy', List[str]),
            'group_by_tags': ConjureFieldDefinition('groupByTags', List[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_data_source_rid', '_channel', '_tags', '_tag_filters', '_tags_to_group_by', '_group_by_tags']

    def __init__(self, channel: "scout_compute_api_StringConstant", data_source_rid: "scout_compute_api_StringConstant", group_by_tags: List["scout_compute_api_StringConstant"], tags: Dict[str, "scout_compute_api_StringConstant"], tags_to_group_by: List[str], tag_filters: Optional["scout_compute_api_TagFilters"] = None) -> None:
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._tags = tags
        self._tag_filters = tag_filters
        self._tags_to_group_by = tags_to_group_by
        self._group_by_tags = group_by_tags

    @builtins.property
    def data_source_rid(self) -> "scout_compute_api_StringConstant":
        return self._data_source_rid

    @builtins.property
    def channel(self) -> "scout_compute_api_StringConstant":
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, "scout_compute_api_StringConstant"]:
        return self._tags

    @builtins.property
    def tag_filters(self) -> Optional["scout_compute_api_TagFilters"]:
        """Tags to filter the channel by. Only returns points from the channel where tag values match the provided
expression. For log series, include arg filters here in addition to tag filters.
        """
        return self._tag_filters

    @builtins.property
    def tags_to_group_by(self) -> List[str]:
        return self._tags_to_group_by

    @builtins.property
    def group_by_tags(self) -> List["scout_compute_api_StringConstant"]:
        """Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
        """
        return self._group_by_tags


scout_compute_api_DataSourceChannel.__name__ = "DataSourceChannel"
scout_compute_api_DataSourceChannel.__qualname__ = "DataSourceChannel"
scout_compute_api_DataSourceChannel.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DecimateStrategy(ConjureUnionType):
    _resolution: Optional["scout_compute_api_DecimateWithResolution"] = None
    _buckets: Optional["scout_compute_api_DecimateWithBuckets"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resolution': ConjureFieldDefinition('resolution', scout_compute_api_DecimateWithResolution),
            'buckets': ConjureFieldDefinition('buckets', scout_compute_api_DecimateWithBuckets)
        }

    def __init__(
            self,
            resolution: Optional["scout_compute_api_DecimateWithResolution"] = None,
            buckets: Optional["scout_compute_api_DecimateWithBuckets"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (resolution is not None) + (buckets is not None) != 1:
                raise ValueError('a union must contain a single member')

            if resolution is not None:
                self._resolution = resolution
                self._type = 'resolution'
            if buckets is not None:
                self._buckets = buckets
                self._type = 'buckets'

        elif type_of_union == 'resolution':
            if resolution is None:
                raise ValueError('a union value must not be None')
            self._resolution = resolution
            self._type = 'resolution'
        elif type_of_union == 'buckets':
            if buckets is None:
                raise ValueError('a union value must not be None')
            self._buckets = buckets
            self._type = 'buckets'

    @builtins.property
    def resolution(self) -> Optional["scout_compute_api_DecimateWithResolution"]:
        return self._resolution

    @builtins.property
    def buckets(self) -> Optional["scout_compute_api_DecimateWithBuckets"]:
        return self._buckets

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DecimateStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DecimateStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'resolution' and self.resolution is not None:
            return visitor._resolution(self.resolution)
        if self._type == 'buckets' and self.buckets is not None:
            return visitor._buckets(self.buckets)


scout_compute_api_DecimateStrategy.__name__ = "DecimateStrategy"
scout_compute_api_DecimateStrategy.__qualname__ = "DecimateStrategy"
scout_compute_api_DecimateStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DecimateStrategyVisitor:

    @abstractmethod
    def _resolution(self, resolution: "scout_compute_api_DecimateWithResolution") -> Any:
        pass

    @abstractmethod
    def _buckets(self, buckets: "scout_compute_api_DecimateWithBuckets") -> Any:
        pass


scout_compute_api_DecimateStrategyVisitor.__name__ = "DecimateStrategyVisitor"
scout_compute_api_DecimateStrategyVisitor.__qualname__ = "DecimateStrategyVisitor"
scout_compute_api_DecimateStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DecimateWithBuckets(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', int)
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: int) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> int:
        """Number of points to generate in the output series.
        """
        return self._buckets


scout_compute_api_DecimateWithBuckets.__name__ = "DecimateWithBuckets"
scout_compute_api_DecimateWithBuckets.__qualname__ = "DecimateWithBuckets"
scout_compute_api_DecimateWithBuckets.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DecimateWithResolution(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_resolution']

    def __init__(self, resolution: int) -> None:
        self._resolution = resolution

    @builtins.property
    def resolution(self) -> int:
        """Resolution of the output series specifying time interval between decimated points.
Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.
        """
        return self._resolution


scout_compute_api_DecimateWithResolution.__name__ = "DecimateWithResolution"
scout_compute_api_DecimateWithResolution.__qualname__ = "DecimateWithResolution"
scout_compute_api_DecimateWithResolution.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DerivativeSeries(ConjureBeanType):
    """Calculates the rate of change between subsequent points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        """Time unit used to calculate the derivative. Defaults to seconds if not specified.
        """
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        """Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
        """
        return self._negative_values_configuration


scout_compute_api_DerivativeSeries.__name__ = "DerivativeSeries"
scout_compute_api_DerivativeSeries.__qualname__ = "DerivativeSeries"
scout_compute_api_DerivativeSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DerivedSeries(ConjureUnionType):
    """Represents a derived series within a compute graph.
This is a series that is derived from a function within a module.
    """
    _function: Optional["scout_compute_api_FunctionDerivedSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'function': ConjureFieldDefinition('function', scout_compute_api_FunctionDerivedSeries)
        }

    def __init__(
            self,
            function: Optional["scout_compute_api_FunctionDerivedSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (function is not None) != 1:
                raise ValueError('a union must contain a single member')

            if function is not None:
                self._function = function
                self._type = 'function'

        elif type_of_union == 'function':
            if function is None:
                raise ValueError('a union value must not be None')
            self._function = function
            self._type = 'function'

    @builtins.property
    def function(self) -> Optional["scout_compute_api_FunctionDerivedSeries"]:
        return self._function

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DerivedSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DerivedSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'function' and self.function is not None:
            return visitor._function(self.function)


scout_compute_api_DerivedSeries.__name__ = "DerivedSeries"
scout_compute_api_DerivedSeries.__qualname__ = "DerivedSeries"
scout_compute_api_DerivedSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DerivedSeriesVisitor:

    @abstractmethod
    def _function(self, function: "scout_compute_api_FunctionDerivedSeries") -> Any:
        pass


scout_compute_api_DerivedSeriesVisitor.__name__ = "DerivedSeriesVisitor"
scout_compute_api_DerivedSeriesVisitor.__qualname__ = "DerivedSeriesVisitor"
scout_compute_api_DerivedSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DetrendType(ConjureEnumType):
    """The type of detrending to apply to the signal. When absent, will default to the detrend behavior for that function.
    """

    CONSTANT = 'CONSTANT'
    '''CONSTANT'''
    LINEAR = 'LINEAR'
    '''LINEAR'''
    NO_OP = 'NO_OP'
    '''NO_OP'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_DetrendType.__name__ = "DetrendType"
scout_compute_api_DetrendType.__qualname__ = "DetrendType"
scout_compute_api_DetrendType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DoubleConstant(ConjureUnionType):
    _literal: Optional[float] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', float),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[float] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[float]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DoubleConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DoubleConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_DoubleConstant.__name__ = "DoubleConstant"
scout_compute_api_DoubleConstant.__qualname__ = "DoubleConstant"
scout_compute_api_DoubleConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DoubleConstantVisitor:

    @abstractmethod
    def _literal(self, literal: float) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_DoubleConstantVisitor.__name__ = "DoubleConstantVisitor"
scout_compute_api_DoubleConstantVisitor.__qualname__ = "DoubleConstantVisitor"
scout_compute_api_DoubleConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DriverSeries3d(ConjureEnumType):

    X = 'X'
    '''X'''
    Y = 'Y'
    '''Y'''
    Z = 'Z'
    '''Z'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_DriverSeries3d.__name__ = "DriverSeries3d"
scout_compute_api_DriverSeries3d.__qualname__ = "DriverSeries3d"
scout_compute_api_DriverSeries3d.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DurationConstant(ConjureUnionType):
    _literal: Optional["scout_run_api_Duration"] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', scout_run_api_Duration),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional["scout_run_api_Duration"] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional["scout_run_api_Duration"]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_DurationConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_DurationConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_DurationConstant.__name__ = "DurationConstant"
scout_compute_api_DurationConstant.__qualname__ = "DurationConstant"
scout_compute_api_DurationConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DurationConstantVisitor:

    @abstractmethod
    def _literal(self, literal: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_DurationConstantVisitor.__name__ = "DurationConstantVisitor"
scout_compute_api_DurationConstantVisitor.__qualname__ = "DurationConstantVisitor"
scout_compute_api_DurationConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_DurationFilterRanges(ConjureBeanType):
    """Filters a list of ranges down to only those satisfying a threshold condition on the range's duration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangeSeries),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DurationConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'unbounded_behavior': ConjureFieldDefinition('unboundedBehavior', OptionalTypeWrapper[scout_compute_api_UnboundedBehavior])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_unbounded_behavior']

    def __init__(self, input: "scout_compute_api_RangeSeries", operator: "scout_compute_api_ThresholdOperator", threshold: "scout_compute_api_DurationConstant", unbounded_behavior: Optional["scout_compute_api_UnboundedBehavior"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._unbounded_behavior = unbounded_behavior

    @builtins.property
    def input(self) -> "scout_compute_api_RangeSeries":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DurationConstant":
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def unbounded_behavior(self) -> Optional["scout_compute_api_UnboundedBehavior"]:
        return self._unbounded_behavior


scout_compute_api_DurationFilterRanges.__name__ = "DurationFilterRanges"
scout_compute_api_DurationFilterRanges.__qualname__ = "DurationFilterRanges"
scout_compute_api_DurationFilterRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Enum1dArraySeries(ConjureUnionType):
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries)
        }

    def __init__(
            self,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (raw is not None) + (derived is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_Enum1dArraySeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_Enum1dArraySeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)


scout_compute_api_Enum1dArraySeries.__name__ = "Enum1dArraySeries"
scout_compute_api_Enum1dArraySeries.__qualname__ = "Enum1dArraySeries"
scout_compute_api_Enum1dArraySeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Enum1dArraySeriesVisitor:

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass


scout_compute_api_Enum1dArraySeriesVisitor.__name__ = "Enum1dArraySeriesVisitor"
scout_compute_api_Enum1dArraySeriesVisitor.__qualname__ = "Enum1dArraySeriesVisitor"
scout_compute_api_Enum1dArraySeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumAggregationFunction(ConjureEnumType):

    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumAggregationFunction.__name__ = "EnumAggregationFunction"
scout_compute_api_EnumAggregationFunction.__qualname__ = "EnumAggregationFunction"
scout_compute_api_EnumAggregationFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'histogram': ConjureFieldDefinition('histogram', Dict[int, int]),
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_CompactEnumPoint),
            'last_point': ConjureFieldDefinition('lastPoint', OptionalTypeWrapper[scout_compute_api_CompactEnumPoint])
        }

    __slots__: List[str] = ['_histogram', '_first_point', '_last_point']

    def __init__(self, first_point: "scout_compute_api_CompactEnumPoint", histogram: Dict[int, int], last_point: Optional["scout_compute_api_CompactEnumPoint"] = None) -> None:
        self._histogram = histogram
        self._first_point = first_point
        self._last_point = last_point

    @builtins.property
    def histogram(self) -> Dict[int, int]:
        """The map of values within the bucket to their frequency.
        """
        return self._histogram

    @builtins.property
    def first_point(self) -> "scout_compute_api_CompactEnumPoint":
        return self._first_point

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_CompactEnumPoint"]:
        """Will be empty if the bucket only has a single point.
        """
        return self._last_point


scout_compute_api_EnumBucket.__name__ = "EnumBucket"
scout_compute_api_EnumBucket.__qualname__ = "EnumBucket"
scout_compute_api_EnumBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumConstantResampleInterpolationConfiguration(ConjureBeanType):
    """Fills all empty resample intervals with a single constant value.

If a resampled time interval (bucket) contains no data points from the input, it will
be assigned the specified 'constant' as a default value. This applies to gaps at the start of the 
series, between data points, and at the end.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'constant': ConjureFieldDefinition('constant', scout_compute_api_StringConstant)
        }

    __slots__: List[str] = ['_constant']

    def __init__(self, constant: "scout_compute_api_StringConstant") -> None:
        self._constant = constant

    @builtins.property
    def constant(self) -> "scout_compute_api_StringConstant":
        return self._constant


scout_compute_api_EnumConstantResampleInterpolationConfiguration.__name__ = "EnumConstantResampleInterpolationConfiguration"
scout_compute_api_EnumConstantResampleInterpolationConfiguration.__qualname__ = "EnumConstantResampleInterpolationConfiguration"
scout_compute_api_EnumConstantResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumCountDuplicateSeries(ConjureBeanType):
    """Counts the number of points along each timestamp in the input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_EnumSeries])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_EnumSeries"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_EnumSeries"]:
        return self._inputs


scout_compute_api_EnumCountDuplicateSeries.__name__ = "EnumCountDuplicateSeries"
scout_compute_api_EnumCountDuplicateSeries.__qualname__ = "EnumCountDuplicateSeries"
scout_compute_api_EnumCountDuplicateSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumFilterOperator(ConjureEnumType):

    IS_IN = 'IS_IN'
    '''IS_IN'''
    IS_NOT_IN = 'IS_NOT_IN'
    '''IS_NOT_IN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumFilterOperator.__name__ = "EnumFilterOperator"
scout_compute_api_EnumFilterOperator.__qualname__ = "EnumFilterOperator"
scout_compute_api_EnumFilterOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumFilterRanges(ConjureBeanType):
    """Produces a list of ranges for which the filter condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', scout_compute_api_StringSetConstant),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_EnumSeries", operator: "scout_compute_api_EnumFilterOperator", values: "scout_compute_api_StringSetConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> "scout_compute_api_StringSetConstant":
        return self._values

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_EnumFilterRanges.__name__ = "EnumFilterRanges"
scout_compute_api_EnumFilterRanges.__qualname__ = "EnumFilterRanges"
scout_compute_api_EnumFilterRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumFilterTransformationSeries(ConjureBeanType):
    """Outputs the values of the enum plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'filter': ConjureFieldDefinition('filter', scout_compute_api_RangeSeries)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_api_RangeSeries", input: "scout_compute_api_EnumSeries") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_api_RangeSeries":
        return self._filter


scout_compute_api_EnumFilterTransformationSeries.__name__ = "EnumFilterTransformationSeries"
scout_compute_api_EnumFilterTransformationSeries.__qualname__ = "EnumFilterTransformationSeries"
scout_compute_api_EnumFilterTransformationSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumHistogramBucket(ConjureBeanType):
    """A bucket in an enum histogram representing all the counts
for a specific enumerated value, across all input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', str),
            'counts_by_channel': ConjureFieldDefinition('countsByChannel', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount])
        }

    __slots__: List[str] = ['_value', '_counts_by_channel']

    def __init__(self, counts_by_channel: Dict[str, "scout_compute_api_HistogramChannelCount"], value: str) -> None:
        self._value = value
        self._counts_by_channel = counts_by_channel

    @builtins.property
    def value(self) -> str:
        """The value of the enum as a string
        """
        return self._value

    @builtins.property
    def counts_by_channel(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._counts_by_channel


scout_compute_api_EnumHistogramBucket.__name__ = "EnumHistogramBucket"
scout_compute_api_EnumHistogramBucket.__qualname__ = "EnumHistogramBucket"
scout_compute_api_EnumHistogramBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_api_EnumSeries])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: Dict[str, "scout_compute_api_EnumSeries"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_EnumSeries"]:
        return self._inputs


scout_compute_api_EnumHistogramNode.__name__ = "EnumHistogramNode"
scout_compute_api_EnumHistogramNode.__qualname__ = "EnumHistogramNode"
scout_compute_api_EnumHistogramNode.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumHistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_EnumHistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_EnumHistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_EnumHistogramBucket"]:
        return self._buckets


scout_compute_api_EnumHistogramPlot.__name__ = "EnumHistogramPlot"
scout_compute_api_EnumHistogramPlot.__qualname__ = "EnumHistogramPlot"
scout_compute_api_EnumHistogramPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', List[int]),
            'categories': ConjureFieldDefinition('categories', List[str])
        }

    __slots__: List[str] = ['_timestamps', '_values', '_categories']

    def __init__(self, categories: List[str], timestamps: List["api_Timestamp"], values: List[int]) -> None:
        self._timestamps = timestamps
        self._values = values
        self._categories = categories

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def values(self) -> List[int]:
        return self._values

    @builtins.property
    def categories(self) -> List[str]:
        return self._categories


scout_compute_api_EnumPlot.__name__ = "EnumPlot"
scout_compute_api_EnumPlot.__qualname__ = "EnumPlot"
scout_compute_api_EnumPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: str) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> str:
        return self._value


scout_compute_api_EnumPoint.__name__ = "EnumPoint"
scout_compute_api_EnumPoint.__qualname__ = "EnumPoint"
scout_compute_api_EnumPoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumResampleConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interval': ConjureFieldDefinition('interval', scout_compute_api_DurationConstant),
            'interpolation': ConjureFieldDefinition('interpolation', OptionalTypeWrapper[scout_compute_api_EnumResampleInterpolationConfiguration])
        }

    __slots__: List[str] = ['_interval', '_interpolation']

    def __init__(self, interval: "scout_compute_api_DurationConstant", interpolation: Optional["scout_compute_api_EnumResampleInterpolationConfiguration"] = None) -> None:
        self._interval = interval
        self._interpolation = interpolation

    @builtins.property
    def interval(self) -> "scout_compute_api_DurationConstant":
        """Interval between resampled points
        """
        return self._interval

    @builtins.property
    def interpolation(self) -> Optional["scout_compute_api_EnumResampleInterpolationConfiguration"]:
        """Interpolation strategy to use (defaults to forward fill).
        """
        return self._interpolation


scout_compute_api_EnumResampleConfiguration.__name__ = "EnumResampleConfiguration"
scout_compute_api_EnumResampleConfiguration.__qualname__ = "EnumResampleConfiguration"
scout_compute_api_EnumResampleConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumResampleInterpolationConfiguration(ConjureUnionType):
    _forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None
    _constant_resample_interpolation_configuration: Optional["scout_compute_api_EnumConstantResampleInterpolationConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_resample_interpolation_configuration': ConjureFieldDefinition('forwardFillResampleInterpolationConfiguration', scout_compute_api_ForwardFillResampleInterpolationConfiguration),
            'constant_resample_interpolation_configuration': ConjureFieldDefinition('constantResampleInterpolationConfiguration', scout_compute_api_EnumConstantResampleInterpolationConfiguration)
        }

    def __init__(
            self,
            forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None,
            constant_resample_interpolation_configuration: Optional["scout_compute_api_EnumConstantResampleInterpolationConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_resample_interpolation_configuration is not None) + (constant_resample_interpolation_configuration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_resample_interpolation_configuration is not None:
                self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
                self._type = 'forwardFillResampleInterpolationConfiguration'
            if constant_resample_interpolation_configuration is not None:
                self._constant_resample_interpolation_configuration = constant_resample_interpolation_configuration
                self._type = 'constantResampleInterpolationConfiguration'

        elif type_of_union == 'forwardFillResampleInterpolationConfiguration':
            if forward_fill_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
            self._type = 'forwardFillResampleInterpolationConfiguration'
        elif type_of_union == 'constantResampleInterpolationConfiguration':
            if constant_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._constant_resample_interpolation_configuration = constant_resample_interpolation_configuration
            self._type = 'constantResampleInterpolationConfiguration'

    @builtins.property
    def forward_fill_resample_interpolation_configuration(self) -> Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"]:
        return self._forward_fill_resample_interpolation_configuration

    @builtins.property
    def constant_resample_interpolation_configuration(self) -> Optional["scout_compute_api_EnumConstantResampleInterpolationConfiguration"]:
        return self._constant_resample_interpolation_configuration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_EnumResampleInterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_EnumResampleInterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillResampleInterpolationConfiguration' and self.forward_fill_resample_interpolation_configuration is not None:
            return visitor._forward_fill_resample_interpolation_configuration(self.forward_fill_resample_interpolation_configuration)
        if self._type == 'constantResampleInterpolationConfiguration' and self.constant_resample_interpolation_configuration is not None:
            return visitor._constant_resample_interpolation_configuration(self.constant_resample_interpolation_configuration)


scout_compute_api_EnumResampleInterpolationConfiguration.__name__ = "EnumResampleInterpolationConfiguration"
scout_compute_api_EnumResampleInterpolationConfiguration.__qualname__ = "EnumResampleInterpolationConfiguration"
scout_compute_api_EnumResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumResampleInterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_resample_interpolation_configuration(self, forward_fill_resample_interpolation_configuration: "scout_compute_api_ForwardFillResampleInterpolationConfiguration") -> Any:
        pass

    @abstractmethod
    def _constant_resample_interpolation_configuration(self, constant_resample_interpolation_configuration: "scout_compute_api_EnumConstantResampleInterpolationConfiguration") -> Any:
        pass


scout_compute_api_EnumResampleInterpolationConfigurationVisitor.__name__ = "EnumResampleInterpolationConfigurationVisitor"
scout_compute_api_EnumResampleInterpolationConfigurationVisitor.__qualname__ = "EnumResampleInterpolationConfigurationVisitor"
scout_compute_api_EnumResampleInterpolationConfigurationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumResampleSeries(ConjureBeanType):
    """Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_api_EnumResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_api_EnumSeries", resample_configuration: "scout_compute_api_EnumResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_api_EnumResampleConfiguration":
        """The interval at which to resample the series and interpolation strategy
        """
        return self._resample_configuration


scout_compute_api_EnumResampleSeries.__name__ = "EnumResampleSeries"
scout_compute_api_EnumResampleSeries.__qualname__ = "EnumResampleSeries"
scout_compute_api_EnumResampleSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumSeries(ConjureUnionType):
    _aggregate: Optional["scout_compute_api_AggregateEnumSeries"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _resample: Optional["scout_compute_api_EnumResampleSeries"] = None
    _time_range_filter: Optional["scout_compute_api_EnumTimeRangeFilterSeries"] = None
    _time_shift: Optional["scout_compute_api_EnumTimeShiftSeries"] = None
    _union: Optional["scout_compute_api_EnumUnionSeries"] = None
    _filter_transformation: Optional["scout_compute_api_EnumFilterTransformationSeries"] = None
    _value_map: Optional["scout_compute_api_ValueMapSeries"] = None
    _select1d_array_index: Optional["scout_compute_api_SelectIndexFrom1dEnumArraySeries"] = None
    _extract_from_struct: Optional["scout_compute_api_ExtractEnumFromStructSeries"] = None
    _event_aggregation: Optional["scout_compute_api_EventsEnumSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_api_AggregateEnumSeries),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'resample': ConjureFieldDefinition('resample', scout_compute_api_EnumResampleSeries),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_EnumTimeRangeFilterSeries),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_EnumTimeShiftSeries),
            'union': ConjureFieldDefinition('union', scout_compute_api_EnumUnionSeries),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_api_EnumFilterTransformationSeries),
            'value_map': ConjureFieldDefinition('valueMap', scout_compute_api_ValueMapSeries),
            'select1d_array_index': ConjureFieldDefinition('select1dArrayIndex', scout_compute_api_SelectIndexFrom1dEnumArraySeries),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_api_ExtractEnumFromStructSeries),
            'event_aggregation': ConjureFieldDefinition('eventAggregation', scout_compute_api_EventsEnumSeries)
        }

    def __init__(
            self,
            aggregate: Optional["scout_compute_api_AggregateEnumSeries"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            resample: Optional["scout_compute_api_EnumResampleSeries"] = None,
            time_range_filter: Optional["scout_compute_api_EnumTimeRangeFilterSeries"] = None,
            time_shift: Optional["scout_compute_api_EnumTimeShiftSeries"] = None,
            union: Optional["scout_compute_api_EnumUnionSeries"] = None,
            filter_transformation: Optional["scout_compute_api_EnumFilterTransformationSeries"] = None,
            value_map: Optional["scout_compute_api_ValueMapSeries"] = None,
            select1d_array_index: Optional["scout_compute_api_SelectIndexFrom1dEnumArraySeries"] = None,
            extract_from_struct: Optional["scout_compute_api_ExtractEnumFromStructSeries"] = None,
            event_aggregation: Optional["scout_compute_api_EventsEnumSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (aggregate is not None) + (raw is not None) + (channel is not None) + (derived is not None) + (resample is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (filter_transformation is not None) + (value_map is not None) + (select1d_array_index is not None) + (extract_from_struct is not None) + (event_aggregation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'
            if value_map is not None:
                self._value_map = value_map
                self._type = 'valueMap'
            if select1d_array_index is not None:
                self._select1d_array_index = select1d_array_index
                self._type = 'select1dArrayIndex'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'
            if event_aggregation is not None:
                self._event_aggregation = event_aggregation
                self._type = 'eventAggregation'

        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'
        elif type_of_union == 'valueMap':
            if value_map is None:
                raise ValueError('a union value must not be None')
            self._value_map = value_map
            self._type = 'valueMap'
        elif type_of_union == 'select1dArrayIndex':
            if select1d_array_index is None:
                raise ValueError('a union value must not be None')
            self._select1d_array_index = select1d_array_index
            self._type = 'select1dArrayIndex'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'
        elif type_of_union == 'eventAggregation':
            if event_aggregation is None:
                raise ValueError('a union value must not be None')
            self._event_aggregation = event_aggregation
            self._type = 'eventAggregation'

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_api_AggregateEnumSeries"]:
        return self._aggregate

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def resample(self) -> Optional["scout_compute_api_EnumResampleSeries"]:
        return self._resample

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_EnumTimeRangeFilterSeries"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_EnumTimeShiftSeries"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_EnumUnionSeries"]:
        return self._union

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_api_EnumFilterTransformationSeries"]:
        return self._filter_transformation

    @builtins.property
    def value_map(self) -> Optional["scout_compute_api_ValueMapSeries"]:
        return self._value_map

    @builtins.property
    def select1d_array_index(self) -> Optional["scout_compute_api_SelectIndexFrom1dEnumArraySeries"]:
        return self._select1d_array_index

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_api_ExtractEnumFromStructSeries"]:
        return self._extract_from_struct

    @builtins.property
    def event_aggregation(self) -> Optional["scout_compute_api_EventsEnumSeries"]:
        return self._event_aggregation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_EnumSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_EnumSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)
        if self._type == 'valueMap' and self.value_map is not None:
            return visitor._value_map(self.value_map)
        if self._type == 'select1dArrayIndex' and self.select1d_array_index is not None:
            return visitor._select1d_array_index(self.select1d_array_index)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)
        if self._type == 'eventAggregation' and self.event_aggregation is not None:
            return visitor._event_aggregation(self.event_aggregation)


scout_compute_api_EnumSeries.__name__ = "EnumSeries"
scout_compute_api_EnumSeries.__qualname__ = "EnumSeries"
scout_compute_api_EnumSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumSeriesVisitor:

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_api_AggregateEnumSeries") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_api_EnumResampleSeries") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_EnumTimeRangeFilterSeries") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_EnumTimeShiftSeries") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_EnumUnionSeries") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_api_EnumFilterTransformationSeries") -> Any:
        pass

    @abstractmethod
    def _value_map(self, value_map: "scout_compute_api_ValueMapSeries") -> Any:
        pass

    @abstractmethod
    def _select1d_array_index(self, select1d_array_index: "scout_compute_api_SelectIndexFrom1dEnumArraySeries") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_api_ExtractEnumFromStructSeries") -> Any:
        pass

    @abstractmethod
    def _event_aggregation(self, event_aggregation: "scout_compute_api_EventsEnumSeries") -> Any:
        pass


scout_compute_api_EnumSeriesVisitor.__name__ = "EnumSeriesVisitor"
scout_compute_api_EnumSeriesVisitor.__qualname__ = "EnumSeriesVisitor"
scout_compute_api_EnumSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumSeriesEqualityRanges(ConjureBeanType):
    """Produces a list of ranges for which provided enum series are all equal (or are not all equal).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_EnumSeries]),
            'equality_operator': ConjureFieldDefinition('equalityOperator', scout_compute_api_EqualityOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input', '_equality_operator', '_persistence_window_configuration', '_interpolation_configuration']

    def __init__(self, equality_operator: "scout_compute_api_EqualityOperator", input: List["scout_compute_api_EnumSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None, persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._equality_operator = equality_operator
        self._persistence_window_configuration = persistence_window_configuration
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input(self) -> List["scout_compute_api_EnumSeries"]:
        return self._input

    @builtins.property
    def equality_operator(self) -> "scout_compute_api_EqualityOperator":
        return self._equality_operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_EnumSeriesEqualityRanges.__name__ = "EnumSeriesEqualityRanges"
scout_compute_api_EnumSeriesEqualityRanges.__qualname__ = "EnumSeriesEqualityRanges"
scout_compute_api_EnumSeriesEqualityRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumTimeRangeFilterSeries(ConjureBeanType):
    """Filters the series to points within the specified time range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_EnumSeries", end_time: Optional["scout_compute_api_TimestampConstant"] = None, start_time: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Represents the start time (inclusive) of the time range.
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Represents the end time (inclusive) of the time range.
        """
        return self._end_time


scout_compute_api_EnumTimeRangeFilterSeries.__name__ = "EnumTimeRangeFilterSeries"
scout_compute_api_EnumTimeRangeFilterSeries.__qualname__ = "EnumTimeRangeFilterSeries"
scout_compute_api_EnumTimeRangeFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumTimeShiftSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", input: "scout_compute_api_EnumSeries") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_EnumTimeShiftSeries.__name__ = "EnumTimeShiftSeries"
scout_compute_api_EnumTimeShiftSeries.__qualname__ = "EnumTimeShiftSeries"
scout_compute_api_EnumTimeShiftSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumToNumericSeries(ConjureBeanType):
    """Maps an enumerated series to a numeric series by mapping each string value to a double.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_EnumSeries),
            'mapping': ConjureFieldDefinition('mapping', Dict[str, scout_compute_api_DoubleConstant]),
            'default_value': ConjureFieldDefinition('defaultValue', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_input', '_mapping', '_default_value']

    def __init__(self, input: "scout_compute_api_EnumSeries", mapping: Dict[str, "scout_compute_api_DoubleConstant"], default_value: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._input = input
        self._mapping = mapping
        self._default_value = default_value

    @builtins.property
    def input(self) -> "scout_compute_api_EnumSeries":
        return self._input

    @builtins.property
    def mapping(self) -> Dict[str, "scout_compute_api_DoubleConstant"]:
        """The mapping from enum values to doubles.
        """
        return self._mapping

    @builtins.property
    def default_value(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """The value to use for enum values not present in the mapping. If not specified, points with unmapped
enum values will be dropped.
        """
        return self._default_value


scout_compute_api_EnumToNumericSeries.__name__ = "EnumToNumericSeries"
scout_compute_api_EnumToNumericSeries.__qualname__ = "EnumToNumericSeries"
scout_compute_api_EnumToNumericSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumUnionOperation(ConjureEnumType):

    THROW = 'THROW'
    '''THROW'''
    MAX = 'MAX'
    '''MAX'''
    MIN = 'MIN'
    '''MIN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EnumUnionOperation.__name__ = "EnumUnionOperation"
scout_compute_api_EnumUnionOperation.__qualname__ = "EnumUnionOperation"
scout_compute_api_EnumUnionOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EnumUnionSeries(ConjureBeanType):
    """Combines multiple enum series together and outputs a single series. The strategy to merge input values
with the same timestamp together is specified in the operation field.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_EnumSeries]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_EnumSeries"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_EnumSeries"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        """The strategy to merge points with duplicate timestamps.
        """
        return self._operation


scout_compute_api_EnumUnionSeries.__name__ = "EnumUnionSeries"
scout_compute_api_EnumUnionSeries.__qualname__ = "EnumUnionSeries"
scout_compute_api_EnumUnionSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EqualityOperator(ConjureEnumType):

    ALL_EQUAL = 'ALL_EQUAL'
    '''ALL_EQUAL'''
    NOT_ALL_EQUAL = 'NOT_ALL_EQUAL'
    '''NOT_ALL_EQUAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_EqualityOperator.__name__ = "EqualityOperator"
scout_compute_api_EqualityOperator.__qualname__ = "EqualityOperator"
scout_compute_api_EqualityOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ErrorResult(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', scout_compute_api_ErrorType),
            'code': ConjureFieldDefinition('code', scout_compute_api_ErrorCode)
        }

    __slots__: List[str] = ['_error_type', '_code']

    def __init__(self, code: int, error_type: str) -> None:
        self._error_type = error_type
        self._code = code

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def code(self) -> int:
        return self._code


scout_compute_api_ErrorResult.__name__ = "ErrorResult"
scout_compute_api_ErrorResult.__qualname__ = "ErrorResult"
scout_compute_api_ErrorResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EventsEnumSeries(ConjureBeanType):
    """Queries events and emits an enum series where each data point corresponds to an event and the enum value is
derived from a single event field (property, label, etc).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_rids_api_ComputeEventQuery),
            'value_source': ConjureFieldDefinition('valueSource', scout_compute_api_EventsEnumValueSource)
        }

    __slots__: List[str] = ['_query', '_value_source']

    def __init__(self, query: "scout_rids_api_ComputeEventQuery", value_source: "scout_compute_api_EventsEnumValueSource") -> None:
        self._query = query
        self._value_source = value_source

    @builtins.property
    def query(self) -> "scout_rids_api_ComputeEventQuery":
        return self._query

    @builtins.property
    def value_source(self) -> "scout_compute_api_EventsEnumValueSource":
        return self._value_source


scout_compute_api_EventsEnumSeries.__name__ = "EventsEnumSeries"
scout_compute_api_EventsEnumSeries.__qualname__ = "EventsEnumSeries"
scout_compute_api_EventsEnumSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EventsEnumValueSource(ConjureUnionType):
    _property: Optional["scout_compute_api_StringConstant"] = None
    _level: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'property': ConjureFieldDefinition('property', scout_compute_api_StringConstant),
            'level': ConjureFieldDefinition('level', api_Empty)
        }

    def __init__(
            self,
            property: Optional["scout_compute_api_StringConstant"] = None,
            level: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (property is not None) + (level is not None) != 1:
                raise ValueError('a union must contain a single member')

            if property is not None:
                self._property = property
                self._type = 'property'
            if level is not None:
                self._level = level
                self._type = 'level'

        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'level':
            if level is None:
                raise ValueError('a union value must not be None')
            self._level = level
            self._type = 'level'

    @builtins.property
    def property(self) -> Optional["scout_compute_api_StringConstant"]:
        """Name of the event property whose value should be used as the enum value.
        """
        return self._property

    @builtins.property
    def level(self) -> Optional["api_Empty"]:
        """The event level (INFO, FLAG, VIOLATION, SUCCESS). This field corresponds to the event type.
        """
        return self._level

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_EventsEnumValueSourceVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_EventsEnumValueSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'level' and self.level is not None:
            return visitor._level(self.level)


scout_compute_api_EventsEnumValueSource.__name__ = "EventsEnumValueSource"
scout_compute_api_EventsEnumValueSource.__qualname__ = "EventsEnumValueSource"
scout_compute_api_EventsEnumValueSource.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EventsEnumValueSourceVisitor:

    @abstractmethod
    def _property(self, property: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _level(self, level: "api_Empty") -> Any:
        pass


scout_compute_api_EventsEnumValueSourceVisitor.__name__ = "EventsEnumValueSourceVisitor"
scout_compute_api_EventsEnumValueSourceVisitor.__qualname__ = "EventsEnumValueSourceVisitor"
scout_compute_api_EventsEnumValueSourceVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_EventsSearchRanges(ConjureBeanType):
    """Produces a range series with a range for each event matching the query.
Throws if there are more than 1,000 results.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_rids_api_ComputeEventQuery)
        }

    __slots__: List[str] = ['_query']

    def __init__(self, query: "scout_rids_api_ComputeEventQuery") -> None:
        self._query = query

    @builtins.property
    def query(self) -> "scout_rids_api_ComputeEventQuery":
        return self._query


scout_compute_api_EventsSearchRanges.__name__ = "EventsSearchRanges"
scout_compute_api_EventsSearchRanges.__qualname__ = "EventsSearchRanges"
scout_compute_api_EventsSearchRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExcludeNegativeValues(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ExcludeNegativeValues.__name__ = "ExcludeNegativeValues"
scout_compute_api_ExcludeNegativeValues.__qualname__ = "ExcludeNegativeValues"
scout_compute_api_ExcludeNegativeValues.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExponentialCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ExponentialCurve.__name__ = "ExponentialCurve"
scout_compute_api_ExponentialCurve.__qualname__ = "ExponentialCurve"
scout_compute_api_ExponentialCurve.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExponentialResultDetails(ConjureBeanType):
    """y = a * e^(b * x)
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'a': ConjureFieldDefinition('a', float),
            'b': ConjureFieldDefinition('b', float)
        }

    __slots__: List[str] = ['_a', '_b']

    def __init__(self, a: float, b: float) -> None:
        self._a = a
        self._b = b

    @builtins.property
    def a(self) -> float:
        return self._a

    @builtins.property
    def b(self) -> float:
        return self._b


scout_compute_api_ExponentialResultDetails.__name__ = "ExponentialResultDetails"
scout_compute_api_ExponentialResultDetails.__qualname__ = "ExponentialResultDetails"
scout_compute_api_ExponentialResultDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExtractEnumFromStructSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_StructSeries),
            'field_path': ConjureFieldDefinition('fieldPath', List[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_input', '_field_path']

    def __init__(self, field_path: List["scout_compute_api_StringConstant"], input: "scout_compute_api_StructSeries") -> None:
        self._input = input
        self._field_path = field_path

    @builtins.property
    def input(self) -> "scout_compute_api_StructSeries":
        return self._input

    @builtins.property
    def field_path(self) -> List["scout_compute_api_StringConstant"]:
        """Path to the field to extract as an enum series. Nested fields are separated by periods and field names cannot contain periods.
Will filter out invalid paths and paths to sub structures.
        """
        return self._field_path


scout_compute_api_ExtractEnumFromStructSeries.__name__ = "ExtractEnumFromStructSeries"
scout_compute_api_ExtractEnumFromStructSeries.__qualname__ = "ExtractEnumFromStructSeries"
scout_compute_api_ExtractEnumFromStructSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExtractNumericFromStructSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_StructSeries),
            'field_path': ConjureFieldDefinition('fieldPath', List[scout_compute_api_StringConstant]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[scout_compute_api_NumericDataType])
        }

    __slots__: List[str] = ['_input', '_field_path', '_data_type']

    def __init__(self, field_path: List["scout_compute_api_StringConstant"], input: "scout_compute_api_StructSeries", data_type: Optional["scout_compute_api_NumericDataType"] = None) -> None:
        self._input = input
        self._field_path = field_path
        self._data_type = data_type

    @builtins.property
    def input(self) -> "scout_compute_api_StructSeries":
        return self._input

    @builtins.property
    def field_path(self) -> List["scout_compute_api_StringConstant"]:
        """Path to the field to extract as a numeric series. Nested fields are separated by periods and field names cannot contain periods.
Will filter out invalid paths and values that cannot be converted to the specified type.
        """
        return self._field_path

    @builtins.property
    def data_type(self) -> Optional["scout_compute_api_NumericDataType"]:
        """The type the numeric data will be cast to, defaults to FLOAT64
        """
        return self._data_type


scout_compute_api_ExtractNumericFromStructSeries.__name__ = "ExtractNumericFromStructSeries"
scout_compute_api_ExtractNumericFromStructSeries.__qualname__ = "ExtractNumericFromStructSeries"
scout_compute_api_ExtractNumericFromStructSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ExtractStructFromStructSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_StructSeries),
            'field_path': ConjureFieldDefinition('fieldPath', List[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_input', '_field_path']

    def __init__(self, field_path: List["scout_compute_api_StringConstant"], input: "scout_compute_api_StructSeries") -> None:
        self._input = input
        self._field_path = field_path

    @builtins.property
    def input(self) -> "scout_compute_api_StructSeries":
        return self._input

    @builtins.property
    def field_path(self) -> List["scout_compute_api_StringConstant"]:
        """Path to the field to extract as a struct. Nested fields are separated by periods and field names cannot contain periods.
Returns an empty struct if the path is invalid or does not resolve to a valid JSON struct.
        """
        return self._field_path


scout_compute_api_ExtractStructFromStructSeries.__name__ = "ExtractStructFromStructSeries"
scout_compute_api_ExtractStructFromStructSeries.__qualname__ = "ExtractStructFromStructSeries"
scout_compute_api_ExtractStructFromStructSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Fft(ConjureBeanType):
    """Returns the single sided amplitude spectrum of the input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'window': ConjureFieldDefinition('window', OptionalTypeWrapper[scout_compute_api_FftWindow])
        }

    __slots__: List[str] = ['_input', '_window']

    def __init__(self, input: "scout_compute_api_NumericSeries", window: Optional["scout_compute_api_FftWindow"] = None) -> None:
        self._input = input
        self._window = window

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def window(self) -> Optional["scout_compute_api_FftWindow"]:
        """Window function applied to the input series. Defaults to RECT is not specified.
        """
        return self._window


scout_compute_api_Fft.__name__ = "Fft"
scout_compute_api_Fft.__qualname__ = "Fft"
scout_compute_api_Fft.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FftWindow(ConjureEnumType):

    BLACKMAN = 'BLACKMAN'
    '''BLACKMAN'''
    HANN = 'HANN'
    '''HANN'''
    HAMMING = 'HAMMING'
    '''HAMMING'''
    RECT = 'RECT'
    '''RECT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_FftWindow.__name__ = "FftWindow"
scout_compute_api_FftWindow.__qualname__ = "FftWindow"
scout_compute_api_FftWindow.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FilterByExpressionSeries(ConjureBeanType):
    """Keeps points from the base series where the boolean expression evaluates to true. Only outputs timestamps 
where all input series have an entry for that timestamp, or a value can be filled using the interpolation 
configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'base': ConjureFieldDefinition('base', scout_compute_api_LocalVariableName),
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_api_NumericSeries]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_base', '_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, base: str, expression: str, inputs: Dict[str, "scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._base = base
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def base(self) -> str:
        """The variable name for the series that will be returned by this filter. The expression can filter points 
conditional on multiple series. The base defines which series' points will be returned after applying all the filters.
        """
        return self._base

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_NumericSeries"]:
        """A map containing all the numeric series present in the expression.
        """
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        """An expression that evaluates to a boolean. For example - a > 5.
        """
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_FilterByExpressionSeries.__name__ = "FilterByExpressionSeries"
scout_compute_api_FilterByExpressionSeries.__qualname__ = "FilterByExpressionSeries"
scout_compute_api_FilterByExpressionSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FirstPointMatchingCondition(ConjureBeanType):
    """The first point in the output range will be the first point where the condition evaluates to true.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_FirstPointMatchingCondition.__name__ = "FirstPointMatchingCondition"
scout_compute_api_FirstPointMatchingCondition.__qualname__ = "FirstPointMatchingCondition"
scout_compute_api_FirstPointMatchingCondition.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ForwardFillInterpolation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interpolation_radius': ConjureFieldDefinition('interpolationRadius', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_interpolation_radius']

    def __init__(self, interpolation_radius: "scout_compute_api_DurationConstant") -> None:
        self._interpolation_radius = interpolation_radius

    @builtins.property
    def interpolation_radius(self) -> "scout_compute_api_DurationConstant":
        return self._interpolation_radius


scout_compute_api_ForwardFillInterpolation.__name__ = "ForwardFillInterpolation"
scout_compute_api_ForwardFillInterpolation.__qualname__ = "ForwardFillInterpolation"
scout_compute_api_ForwardFillInterpolation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ForwardFillResampleInterpolationConfiguration(ConjureBeanType):
    """Forward fill interpolation for resampling. Rounds the earliest and latest timestamp up to the nearest interval
multiple and generates timestamps at the given interval between the new earliest and latest timestamps.
For every timestamp in the resampled timestamps, takes the last known value before the timestamp as the value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_ForwardFillResampleInterpolationConfiguration.__name__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_api_ForwardFillResampleInterpolationConfiguration.__qualname__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_api_ForwardFillResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomain(ConjureUnionType):
    _fft: Optional["scout_compute_api_Fft"] = None
    _periodogram: Optional["scout_compute_api_Periodogram"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_api_Fft),
            'periodogram': ConjureFieldDefinition('periodogram', scout_compute_api_Periodogram)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_api_Fft"] = None,
            periodogram: Optional["scout_compute_api_Periodogram"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) + (periodogram is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'
            if periodogram is not None:
                self._periodogram = periodogram
                self._type = 'periodogram'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'
        elif type_of_union == 'periodogram':
            if periodogram is None:
                raise ValueError('a union value must not be None')
            self._periodogram = periodogram
            self._type = 'periodogram'

    @builtins.property
    def fft(self) -> Optional["scout_compute_api_Fft"]:
        return self._fft

    @builtins.property
    def periodogram(self) -> Optional["scout_compute_api_Periodogram"]:
        return self._periodogram

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FrequencyDomainVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_FrequencyDomainVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)
        if self._type == 'periodogram' and self.periodogram is not None:
            return visitor._periodogram(self.periodogram)


scout_compute_api_FrequencyDomain.__name__ = "FrequencyDomain"
scout_compute_api_FrequencyDomain.__qualname__ = "FrequencyDomain"
scout_compute_api_FrequencyDomain.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_api_Fft") -> Any:
        pass

    @abstractmethod
    def _periodogram(self, periodogram: "scout_compute_api_Periodogram") -> Any:
        pass


scout_compute_api_FrequencyDomainVisitor.__name__ = "FrequencyDomainVisitor"
scout_compute_api_FrequencyDomainVisitor.__qualname__ = "FrequencyDomainVisitor"
scout_compute_api_FrequencyDomainVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'frequencies': ConjureFieldDefinition('frequencies', List[float]),
            'amplitudes': ConjureFieldDefinition('amplitudes', List[float])
        }

    __slots__: List[str] = ['_frequencies', '_amplitudes']

    def __init__(self, amplitudes: List[float], frequencies: List[float]) -> None:
        self._frequencies = frequencies
        self._amplitudes = amplitudes

    @builtins.property
    def frequencies(self) -> List[float]:
        return self._frequencies

    @builtins.property
    def amplitudes(self) -> List[float]:
        return self._amplitudes


scout_compute_api_FrequencyDomainPlot.__name__ = "FrequencyDomainPlot"
scout_compute_api_FrequencyDomainPlot.__qualname__ = "FrequencyDomainPlot"
scout_compute_api_FrequencyDomainPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlotComplex(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'frequencies': ConjureFieldDefinition('frequencies', List[float]),
            'real': ConjureFieldDefinition('real', List[float]),
            'imaginary': ConjureFieldDefinition('imaginary', List[float])
        }

    __slots__: List[str] = ['_frequencies', '_real', '_imaginary']

    def __init__(self, frequencies: List[float], imaginary: List[float], real: List[float]) -> None:
        self._frequencies = frequencies
        self._real = real
        self._imaginary = imaginary

    @builtins.property
    def frequencies(self) -> List[float]:
        return self._frequencies

    @builtins.property
    def real(self) -> List[float]:
        return self._real

    @builtins.property
    def imaginary(self) -> List[float]:
        return self._imaginary


scout_compute_api_FrequencyDomainPlotComplex.__name__ = "FrequencyDomainPlotComplex"
scout_compute_api_FrequencyDomainPlotComplex.__qualname__ = "FrequencyDomainPlotComplex"
scout_compute_api_FrequencyDomainPlotComplex.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'frequencies': ConjureFieldDefinition('frequencies', List[float]),
            'magnitudes': ConjureFieldDefinition('magnitudes', List[float]),
            'phases': ConjureFieldDefinition('phases', List[float])
        }

    __slots__: List[str] = ['_frequencies', '_magnitudes', '_phases']

    def __init__(self, frequencies: List[float], magnitudes: List[float], phases: List[float]) -> None:
        self._frequencies = frequencies
        self._magnitudes = magnitudes
        self._phases = phases

    @builtins.property
    def frequencies(self) -> List[float]:
        return self._frequencies

    @builtins.property
    def magnitudes(self) -> List[float]:
        return self._magnitudes

    @builtins.property
    def phases(self) -> List[float]:
        return self._phases


scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase.__name__ = "FrequencyDomainPlotMagnitudeAndPhase"
scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase.__qualname__ = "FrequencyDomainPlotMagnitudeAndPhase"
scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlotV2(ConjureUnionType):
    _real: Optional["scout_compute_api_FrequencyDomainPlot"] = None
    _complex: Optional["scout_compute_api_FrequencyDomainPlotComplex"] = None
    _magnitude_and_phase: Optional["scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'real': ConjureFieldDefinition('real', scout_compute_api_FrequencyDomainPlot),
            'complex': ConjureFieldDefinition('complex', scout_compute_api_FrequencyDomainPlotComplex),
            'magnitude_and_phase': ConjureFieldDefinition('magnitudeAndPhase', scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase)
        }

    def __init__(
            self,
            real: Optional["scout_compute_api_FrequencyDomainPlot"] = None,
            complex: Optional["scout_compute_api_FrequencyDomainPlotComplex"] = None,
            magnitude_and_phase: Optional["scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (real is not None) + (complex is not None) + (magnitude_and_phase is not None) != 1:
                raise ValueError('a union must contain a single member')

            if real is not None:
                self._real = real
                self._type = 'real'
            if complex is not None:
                self._complex = complex
                self._type = 'complex'
            if magnitude_and_phase is not None:
                self._magnitude_and_phase = magnitude_and_phase
                self._type = 'magnitudeAndPhase'

        elif type_of_union == 'real':
            if real is None:
                raise ValueError('a union value must not be None')
            self._real = real
            self._type = 'real'
        elif type_of_union == 'complex':
            if complex is None:
                raise ValueError('a union value must not be None')
            self._complex = complex
            self._type = 'complex'
        elif type_of_union == 'magnitudeAndPhase':
            if magnitude_and_phase is None:
                raise ValueError('a union value must not be None')
            self._magnitude_and_phase = magnitude_and_phase
            self._type = 'magnitudeAndPhase'

    @builtins.property
    def real(self) -> Optional["scout_compute_api_FrequencyDomainPlot"]:
        return self._real

    @builtins.property
    def complex(self) -> Optional["scout_compute_api_FrequencyDomainPlotComplex"]:
        return self._complex

    @builtins.property
    def magnitude_and_phase(self) -> Optional["scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase"]:
        return self._magnitude_and_phase

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FrequencyDomainPlotV2Visitor):
            raise ValueError('{} is not an instance of scout_compute_api_FrequencyDomainPlotV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'real' and self.real is not None:
            return visitor._real(self.real)
        if self._type == 'complex' and self.complex is not None:
            return visitor._complex(self.complex)
        if self._type == 'magnitudeAndPhase' and self.magnitude_and_phase is not None:
            return visitor._magnitude_and_phase(self.magnitude_and_phase)


scout_compute_api_FrequencyDomainPlotV2.__name__ = "FrequencyDomainPlotV2"
scout_compute_api_FrequencyDomainPlotV2.__qualname__ = "FrequencyDomainPlotV2"
scout_compute_api_FrequencyDomainPlotV2.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainPlotV2Visitor:

    @abstractmethod
    def _real(self, real: "scout_compute_api_FrequencyDomainPlot") -> Any:
        pass

    @abstractmethod
    def _complex(self, complex: "scout_compute_api_FrequencyDomainPlotComplex") -> Any:
        pass

    @abstractmethod
    def _magnitude_and_phase(self, magnitude_and_phase: "scout_compute_api_FrequencyDomainPlotMagnitudeAndPhase") -> Any:
        pass


scout_compute_api_FrequencyDomainPlotV2Visitor.__name__ = "FrequencyDomainPlotV2Visitor"
scout_compute_api_FrequencyDomainPlotV2Visitor.__qualname__ = "FrequencyDomainPlotV2Visitor"
scout_compute_api_FrequencyDomainPlotV2Visitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainV2(ConjureUnionType):
    _fft: Optional["scout_compute_api_Fft"] = None
    _psd: Optional["scout_compute_api_Psd"] = None
    _cpsd: Optional["scout_compute_api_Cpsd"] = None
    _nyquist: Optional["scout_compute_api_Nyquist"] = None
    _bode: Optional["scout_compute_api_Bode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_api_Fft),
            'psd': ConjureFieldDefinition('psd', scout_compute_api_Psd),
            'cpsd': ConjureFieldDefinition('cpsd', scout_compute_api_Cpsd),
            'nyquist': ConjureFieldDefinition('nyquist', scout_compute_api_Nyquist),
            'bode': ConjureFieldDefinition('bode', scout_compute_api_Bode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_api_Fft"] = None,
            psd: Optional["scout_compute_api_Psd"] = None,
            cpsd: Optional["scout_compute_api_Cpsd"] = None,
            nyquist: Optional["scout_compute_api_Nyquist"] = None,
            bode: Optional["scout_compute_api_Bode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) + (psd is not None) + (cpsd is not None) + (nyquist is not None) + (bode is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'
            if psd is not None:
                self._psd = psd
                self._type = 'psd'
            if cpsd is not None:
                self._cpsd = cpsd
                self._type = 'cpsd'
            if nyquist is not None:
                self._nyquist = nyquist
                self._type = 'nyquist'
            if bode is not None:
                self._bode = bode
                self._type = 'bode'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'
        elif type_of_union == 'psd':
            if psd is None:
                raise ValueError('a union value must not be None')
            self._psd = psd
            self._type = 'psd'
        elif type_of_union == 'cpsd':
            if cpsd is None:
                raise ValueError('a union value must not be None')
            self._cpsd = cpsd
            self._type = 'cpsd'
        elif type_of_union == 'nyquist':
            if nyquist is None:
                raise ValueError('a union value must not be None')
            self._nyquist = nyquist
            self._type = 'nyquist'
        elif type_of_union == 'bode':
            if bode is None:
                raise ValueError('a union value must not be None')
            self._bode = bode
            self._type = 'bode'

    @builtins.property
    def fft(self) -> Optional["scout_compute_api_Fft"]:
        return self._fft

    @builtins.property
    def psd(self) -> Optional["scout_compute_api_Psd"]:
        return self._psd

    @builtins.property
    def cpsd(self) -> Optional["scout_compute_api_Cpsd"]:
        return self._cpsd

    @builtins.property
    def nyquist(self) -> Optional["scout_compute_api_Nyquist"]:
        return self._nyquist

    @builtins.property
    def bode(self) -> Optional["scout_compute_api_Bode"]:
        return self._bode

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FrequencyDomainV2Visitor):
            raise ValueError('{} is not an instance of scout_compute_api_FrequencyDomainV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)
        if self._type == 'psd' and self.psd is not None:
            return visitor._psd(self.psd)
        if self._type == 'cpsd' and self.cpsd is not None:
            return visitor._cpsd(self.cpsd)
        if self._type == 'nyquist' and self.nyquist is not None:
            return visitor._nyquist(self.nyquist)
        if self._type == 'bode' and self.bode is not None:
            return visitor._bode(self.bode)


scout_compute_api_FrequencyDomainV2.__name__ = "FrequencyDomainV2"
scout_compute_api_FrequencyDomainV2.__qualname__ = "FrequencyDomainV2"
scout_compute_api_FrequencyDomainV2.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FrequencyDomainV2Visitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_api_Fft") -> Any:
        pass

    @abstractmethod
    def _psd(self, psd: "scout_compute_api_Psd") -> Any:
        pass

    @abstractmethod
    def _cpsd(self, cpsd: "scout_compute_api_Cpsd") -> Any:
        pass

    @abstractmethod
    def _nyquist(self, nyquist: "scout_compute_api_Nyquist") -> Any:
        pass

    @abstractmethod
    def _bode(self, bode: "scout_compute_api_Bode") -> Any:
        pass


scout_compute_api_FrequencyDomainV2Visitor.__name__ = "FrequencyDomainV2Visitor"
scout_compute_api_FrequencyDomainV2Visitor.__qualname__ = "FrequencyDomainV2Visitor"
scout_compute_api_FrequencyDomainV2Visitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FunctionDerivedSeries(ConjureBeanType):
    """A reference to a derived series resulting from applying a function to a set of arguments.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'module_name': ConjureFieldDefinition('moduleName', scout_compute_api_StringConstant),
            'function_name': ConjureFieldDefinition('functionName', scout_compute_api_StringConstant),
            'version_reference': ConjureFieldDefinition('versionReference', scout_compute_api_ModuleVersionReference),
            'function_args': ConjureFieldDefinition('functionArgs', Dict[scout_compute_api_FunctionParameterName, scout_compute_api_FunctionParameterValue])
        }

    __slots__: List[str] = ['_module_name', '_function_name', '_version_reference', '_function_args']

    def __init__(self, function_args: Dict[str, "scout_compute_api_FunctionParameterValue"], function_name: "scout_compute_api_StringConstant", module_name: "scout_compute_api_StringConstant", version_reference: "scout_compute_api_ModuleVersionReference") -> None:
        self._module_name = module_name
        self._function_name = function_name
        self._version_reference = version_reference
        self._function_args = function_args

    @builtins.property
    def module_name(self) -> "scout_compute_api_StringConstant":
        return self._module_name

    @builtins.property
    def function_name(self) -> "scout_compute_api_StringConstant":
        return self._function_name

    @builtins.property
    def version_reference(self) -> "scout_compute_api_ModuleVersionReference":
        return self._version_reference

    @builtins.property
    def function_args(self) -> Dict[str, "scout_compute_api_FunctionParameterValue"]:
        """Map of function input names to their values. The function inputs must match the function's parameter
names and types. An input must be specified for each of the referenced function's parameters.
        """
        return self._function_args


scout_compute_api_FunctionDerivedSeries.__name__ = "FunctionDerivedSeries"
scout_compute_api_FunctionDerivedSeries.__qualname__ = "FunctionDerivedSeries"
scout_compute_api_FunctionDerivedSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FunctionParameterValue(ConjureUnionType):
    _variable: Optional[str] = None
    _value: Optional["scout_compute_api_VariableValue"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName),
            'value': ConjureFieldDefinition('value', scout_compute_api_VariableValue)
        }

    def __init__(
            self,
            variable: Optional[str] = None,
            value: Optional["scout_compute_api_VariableValue"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (variable is not None) + (value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if variable is not None:
                self._variable = variable
                self._type = 'variable'
            if value is not None:
                self._value = value
                self._type = 'value'

        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    @builtins.property
    def value(self) -> Optional["scout_compute_api_VariableValue"]:
        return self._value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_FunctionParameterValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_FunctionParameterValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)


scout_compute_api_FunctionParameterValue.__name__ = "FunctionParameterValue"
scout_compute_api_FunctionParameterValue.__qualname__ = "FunctionParameterValue"
scout_compute_api_FunctionParameterValue.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FunctionParameterValueVisitor:

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_api_VariableValue") -> Any:
        pass


scout_compute_api_FunctionParameterValueVisitor.__name__ = "FunctionParameterValueVisitor"
scout_compute_api_FunctionParameterValueVisitor.__qualname__ = "FunctionParameterValueVisitor"
scout_compute_api_FunctionParameterValueVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_FunctionVariables(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'sub_function_variables': ConjureFieldDefinition('subFunctionVariables', Dict[scout_compute_api_FunctionReference, scout_compute_api_FunctionVariables])
        }

    __slots__: List[str] = ['_variables', '_sub_function_variables']

    def __init__(self, sub_function_variables: Dict[str, "scout_compute_api_FunctionVariables"], variables: Dict[str, "scout_compute_api_VariableValue"]) -> None:
        self._variables = variables
        self._sub_function_variables = sub_function_variables

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def sub_function_variables(self) -> Dict[str, "scout_compute_api_FunctionVariables"]:
        return self._sub_function_variables


scout_compute_api_FunctionVariables.__name__ = "FunctionVariables"
scout_compute_api_FunctionVariables.__qualname__ = "FunctionVariables"
scout_compute_api_FunctionVariables.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_GroupedComputeNodeResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'grouping': ConjureFieldDefinition('grouping', scout_compute_api_Grouping),
            'response': ConjureFieldDefinition('response', scout_compute_api_ComputeNodeResponse)
        }

    __slots__: List[str] = ['_grouping', '_response']

    def __init__(self, grouping: "scout_compute_api_Grouping", response: "scout_compute_api_ComputeNodeResponse") -> None:
        self._grouping = grouping
        self._response = response

    @builtins.property
    def grouping(self) -> "scout_compute_api_Grouping":
        return self._grouping

    @builtins.property
    def response(self) -> "scout_compute_api_ComputeNodeResponse":
        return self._response


scout_compute_api_GroupedComputeNodeResponse.__name__ = "GroupedComputeNodeResponse"
scout_compute_api_GroupedComputeNodeResponse.__qualname__ = "GroupedComputeNodeResponse"
scout_compute_api_GroupedComputeNodeResponse.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_GroupedComputeNodeResponses(ConjureBeanType):
    """Contains a `ComputeNodeResponse` for each applicable grouping along with metadata describing the grouping.
All the contained `ComputeNodeResponse`s are guaranteed to be of the same type.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[scout_compute_api_GroupedComputeNodeResponse])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["scout_compute_api_GroupedComputeNodeResponse"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["scout_compute_api_GroupedComputeNodeResponse"]:
        return self._responses


scout_compute_api_GroupedComputeNodeResponses.__name__ = "GroupedComputeNodeResponses"
scout_compute_api_GroupedComputeNodeResponses.__qualname__ = "GroupedComputeNodeResponses"
scout_compute_api_GroupedComputeNodeResponses.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Grouping(ConjureUnionType):
    _tags_with_values: Optional[Dict[str, str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tags_with_values': ConjureFieldDefinition('tagsWithValues', Dict[str, str])
        }

    def __init__(
            self,
            tags_with_values: Optional[Dict[str, str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (tags_with_values is not None) != 1:
                raise ValueError('a union must contain a single member')

            if tags_with_values is not None:
                self._tags_with_values = tags_with_values
                self._type = 'tagsWithValues'

        elif type_of_union == 'tagsWithValues':
            if tags_with_values is None:
                raise ValueError('a union value must not be None')
            self._tags_with_values = tags_with_values
            self._type = 'tagsWithValues'

    @builtins.property
    def tags_with_values(self) -> Optional[Dict[str, str]]:
        """A grouping identified by a specific instantiation of tag keys and values.
        """
        return self._tags_with_values

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_GroupingVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_GroupingVisitor'.format(visitor.__class__.__name__))
        if self._type == 'tagsWithValues' and self.tags_with_values is not None:
            return visitor._tags_with_values(self.tags_with_values)


scout_compute_api_Grouping.__name__ = "Grouping"
scout_compute_api_Grouping.__qualname__ = "Grouping"
scout_compute_api_Grouping.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_GroupingVisitor:

    @abstractmethod
    def _tags_with_values(self, tags_with_values: Dict[str, str]) -> Any:
        pass


scout_compute_api_GroupingVisitor.__name__ = "GroupingVisitor"
scout_compute_api_GroupingVisitor.__qualname__ = "GroupingVisitor"
scout_compute_api_GroupingVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_HighPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cutoff_frequency': ConjureFieldDefinition('cutoffFrequency', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_cutoff_frequency']

    def __init__(self, cutoff_frequency: "scout_compute_api_DoubleConstant") -> None:
        self._cutoff_frequency = cutoff_frequency

    @builtins.property
    def cutoff_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._cutoff_frequency


scout_compute_api_HighPassConfiguration.__name__ = "HighPassConfiguration"
scout_compute_api_HighPassConfiguration.__qualname__ = "HighPassConfiguration"
scout_compute_api_HighPassConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Histogram(ConjureUnionType):
    _numeric: Optional["scout_compute_api_NumericHistogramNode"] = None
    _enum: Optional["scout_compute_api_EnumHistogramNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericHistogramNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumHistogramNode)
        }

    def __init__(
            self,
            numeric: Optional["scout_compute_api_NumericHistogramNode"] = None,
            enum: Optional["scout_compute_api_EnumHistogramNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericHistogramNode"]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumHistogramNode"]:
        return self._enum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_HistogramVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_HistogramVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)


scout_compute_api_Histogram.__name__ = "Histogram"
scout_compute_api_Histogram.__qualname__ = "Histogram"
scout_compute_api_Histogram.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_HistogramVisitor:

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericHistogramNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumHistogramNode") -> Any:
        pass


scout_compute_api_HistogramVisitor.__name__ = "HistogramVisitor"
scout_compute_api_HistogramVisitor.__qualname__ = "HistogramVisitor"
scout_compute_api_HistogramVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_HistogramChannelCount(ConjureBeanType):
    """The count of the value in the bucket for the specific channel.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_count']

    def __init__(self, count: int) -> None:
        self._count = count

    @builtins.property
    def count(self) -> int:
        return self._count


scout_compute_api_HistogramChannelCount.__name__ = "HistogramChannelCount"
scout_compute_api_HistogramChannelCount.__qualname__ = "HistogramChannelCount"
scout_compute_api_HistogramChannelCount.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_IncompatibleUnitOperation(ConjureBeanType):
    """Attempted an incompatible operation of units.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnitOperation),
            'units': ConjureFieldDefinition('units', List[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_operation', '_units']

    def __init__(self, operation: "scout_compute_api_UnitOperation", units: List[str]) -> None:
        self._operation = operation
        self._units = units

    @builtins.property
    def operation(self) -> "scout_compute_api_UnitOperation":
        return self._operation

    @builtins.property
    def units(self) -> List[str]:
        return self._units


scout_compute_api_IncompatibleUnitOperation.__name__ = "IncompatibleUnitOperation"
scout_compute_api_IncompatibleUnitOperation.__qualname__ = "IncompatibleUnitOperation"
scout_compute_api_IncompatibleUnitOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_IntegerConstant(ConjureUnionType):
    _literal: Optional[int] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', int),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[int] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[int]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_IntegerConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_IntegerConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_IntegerConstant.__name__ = "IntegerConstant"
scout_compute_api_IntegerConstant.__qualname__ = "IntegerConstant"
scout_compute_api_IntegerConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_IntegerConstantVisitor:

    @abstractmethod
    def _literal(self, literal: int) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_IntegerConstantVisitor.__name__ = "IntegerConstantVisitor"
scout_compute_api_IntegerConstantVisitor.__qualname__ = "IntegerConstantVisitor"
scout_compute_api_IntegerConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_IntegralSeries(ConjureBeanType):
    """Calculates the running sum of the area underneath a series using the trapezoidal rule.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_TimestampConstant),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_start_timestamp', '_time_unit']

    def __init__(self, input: "scout_compute_api_NumericSeries", start_timestamp: "scout_compute_api_TimestampConstant", time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._start_timestamp = start_timestamp
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._start_timestamp

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        """Time unit used to calculate the integral. Defaults to seconds if not specified.
        """
        return self._time_unit


scout_compute_api_IntegralSeries.__name__ = "IntegralSeries"
scout_compute_api_IntegralSeries.__qualname__ = "IntegralSeries"
scout_compute_api_IntegralSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_InterpolationConfiguration(ConjureUnionType):
    _forward_fill_interpolation: Optional["scout_compute_api_ForwardFillInterpolation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_interpolation': ConjureFieldDefinition('forwardFillInterpolation', scout_compute_api_ForwardFillInterpolation)
        }

    def __init__(
            self,
            forward_fill_interpolation: Optional["scout_compute_api_ForwardFillInterpolation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_interpolation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_interpolation is not None:
                self._forward_fill_interpolation = forward_fill_interpolation
                self._type = 'forwardFillInterpolation'

        elif type_of_union == 'forwardFillInterpolation':
            if forward_fill_interpolation is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_interpolation = forward_fill_interpolation
            self._type = 'forwardFillInterpolation'

    @builtins.property
    def forward_fill_interpolation(self) -> Optional["scout_compute_api_ForwardFillInterpolation"]:
        return self._forward_fill_interpolation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_InterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_InterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillInterpolation' and self.forward_fill_interpolation is not None:
            return visitor._forward_fill_interpolation(self.forward_fill_interpolation)


scout_compute_api_InterpolationConfiguration.__name__ = "InterpolationConfiguration"
scout_compute_api_InterpolationConfiguration.__qualname__ = "InterpolationConfiguration"
scout_compute_api_InterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_InterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_interpolation(self, forward_fill_interpolation: "scout_compute_api_ForwardFillInterpolation") -> Any:
        pass


scout_compute_api_InterpolationConfigurationVisitor.__name__ = "InterpolationConfigurationVisitor"
scout_compute_api_InterpolationConfigurationVisitor.__qualname__ = "InterpolationConfigurationVisitor"
scout_compute_api_InterpolationConfigurationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_IntersectRanges(ConjureBeanType):
    """The FE should try to pass in inputs in the order in which they should be
evaluated for optimization's sake. Alternatively, we can let the user select
preconditions which they know to be cheaper to compute, which we will evaluate
first.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_RangeSeries])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_RangeSeries"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_RangeSeries"]:
        return self._inputs


scout_compute_api_IntersectRanges.__name__ = "IntersectRanges"
scout_compute_api_IntersectRanges.__qualname__ = "IntersectRanges"
scout_compute_api_IntersectRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LatLongPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'latitude': ConjureFieldDefinition('latitude', float),
            'longitude': ConjureFieldDefinition('longitude', float)
        }

    __slots__: List[str] = ['_latitude', '_longitude']

    def __init__(self, latitude: float, longitude: float) -> None:
        self._latitude = latitude
        self._longitude = longitude

    @builtins.property
    def latitude(self) -> float:
        return self._latitude

    @builtins.property
    def longitude(self) -> float:
        return self._longitude


scout_compute_api_LatLongPoint.__name__ = "LatLongPoint"
scout_compute_api_LatLongPoint.__qualname__ = "LatLongPoint"
scout_compute_api_LatLongPoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LiteralRange(ConjureBeanType):
    """A literal range of values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp']

    def __init__(self, end_timestamp: Optional["scout_compute_api_TimestampConstant"] = None, start_timestamp: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def start_timestamp(self) -> Optional["scout_compute_api_TimestampConstant"]:
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> Optional["scout_compute_api_TimestampConstant"]:
        return self._end_timestamp


scout_compute_api_LiteralRange.__name__ = "LiteralRange"
scout_compute_api_LiteralRange.__qualname__ = "LiteralRange"
scout_compute_api_LiteralRange.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LiteralRanges(ConjureBeanType):
    """A list of literal ranges.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal_ranges': ConjureFieldDefinition('literalRanges', List[scout_compute_api_LiteralRange])
        }

    __slots__: List[str] = ['_literal_ranges']

    def __init__(self, literal_ranges: List["scout_compute_api_LiteralRange"]) -> None:
        self._literal_ranges = literal_ranges

    @builtins.property
    def literal_ranges(self) -> List["scout_compute_api_LiteralRange"]:
        return self._literal_ranges


scout_compute_api_LiteralRanges.__name__ = "LiteralRanges"
scout_compute_api_LiteralRanges.__qualname__ = "LiteralRanges"
scout_compute_api_LiteralRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogExactMatchCaseInsensitiveFilter(ConjureBeanType):
    """Filters points such that the log message in each point contains an exact case-insensitive match of the
provided token.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'token': ConjureFieldDefinition('token', str)
        }

    __slots__: List[str] = ['_token']

    def __init__(self, token: str) -> None:
        self._token = token

    @builtins.property
    def token(self) -> str:
        return self._token


scout_compute_api_LogExactMatchCaseInsensitiveFilter.__name__ = "LogExactMatchCaseInsensitiveFilter"
scout_compute_api_LogExactMatchCaseInsensitiveFilter.__qualname__ = "LogExactMatchCaseInsensitiveFilter"
scout_compute_api_LogExactMatchCaseInsensitiveFilter.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogFilterOperator(ConjureUnionType):
    _regex_filter: Optional["scout_compute_api_LogRegexFilterOperator"] = None
    _exact_match_case_insensitive_filter: Optional["scout_compute_api_LogExactMatchCaseInsensitiveFilter"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'regex_filter': ConjureFieldDefinition('regexFilter', scout_compute_api_LogRegexFilterOperator),
            'exact_match_case_insensitive_filter': ConjureFieldDefinition('exactMatchCaseInsensitiveFilter', scout_compute_api_LogExactMatchCaseInsensitiveFilter)
        }

    def __init__(
            self,
            regex_filter: Optional["scout_compute_api_LogRegexFilterOperator"] = None,
            exact_match_case_insensitive_filter: Optional["scout_compute_api_LogExactMatchCaseInsensitiveFilter"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (regex_filter is not None) + (exact_match_case_insensitive_filter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if regex_filter is not None:
                self._regex_filter = regex_filter
                self._type = 'regexFilter'
            if exact_match_case_insensitive_filter is not None:
                self._exact_match_case_insensitive_filter = exact_match_case_insensitive_filter
                self._type = 'exactMatchCaseInsensitiveFilter'

        elif type_of_union == 'regexFilter':
            if regex_filter is None:
                raise ValueError('a union value must not be None')
            self._regex_filter = regex_filter
            self._type = 'regexFilter'
        elif type_of_union == 'exactMatchCaseInsensitiveFilter':
            if exact_match_case_insensitive_filter is None:
                raise ValueError('a union value must not be None')
            self._exact_match_case_insensitive_filter = exact_match_case_insensitive_filter
            self._type = 'exactMatchCaseInsensitiveFilter'

    @builtins.property
    def regex_filter(self) -> Optional["scout_compute_api_LogRegexFilterOperator"]:
        return self._regex_filter

    @builtins.property
    def exact_match_case_insensitive_filter(self) -> Optional["scout_compute_api_LogExactMatchCaseInsensitiveFilter"]:
        return self._exact_match_case_insensitive_filter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_LogFilterOperatorVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_LogFilterOperatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'regexFilter' and self.regex_filter is not None:
            return visitor._regex_filter(self.regex_filter)
        if self._type == 'exactMatchCaseInsensitiveFilter' and self.exact_match_case_insensitive_filter is not None:
            return visitor._exact_match_case_insensitive_filter(self.exact_match_case_insensitive_filter)


scout_compute_api_LogFilterOperator.__name__ = "LogFilterOperator"
scout_compute_api_LogFilterOperator.__qualname__ = "LogFilterOperator"
scout_compute_api_LogFilterOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogFilterOperatorVisitor:

    @abstractmethod
    def _regex_filter(self, regex_filter: "scout_compute_api_LogRegexFilterOperator") -> Any:
        pass

    @abstractmethod
    def _exact_match_case_insensitive_filter(self, exact_match_case_insensitive_filter: "scout_compute_api_LogExactMatchCaseInsensitiveFilter") -> Any:
        pass


scout_compute_api_LogFilterOperatorVisitor.__name__ = "LogFilterOperatorVisitor"
scout_compute_api_LogFilterOperatorVisitor.__qualname__ = "LogFilterOperatorVisitor"
scout_compute_api_LogFilterOperatorVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogFilterSeries(ConjureBeanType):
    """Outputs only values of the log plot that satisfy the filter.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_LogSeries),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_LogFilterOperator)
        }

    __slots__: List[str] = ['_input', '_operator']

    def __init__(self, input: "scout_compute_api_LogSeries", operator: "scout_compute_api_LogFilterOperator") -> None:
        self._input = input
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_LogSeries":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_LogFilterOperator":
        return self._operator


scout_compute_api_LogFilterSeries.__name__ = "LogFilterSeries"
scout_compute_api_LogFilterSeries.__qualname__ = "LogFilterSeries"
scout_compute_api_LogFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', scout_compute_api_LogValue)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: "scout_compute_api_LogValue") -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> "scout_compute_api_LogValue":
        return self._value


scout_compute_api_LogPoint.__name__ = "LogPoint"
scout_compute_api_LogPoint.__qualname__ = "LogPoint"
scout_compute_api_LogPoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogRegexFilterOperator(ConjureBeanType):
    """Filters points such that the log message in each point matches the given re2 regular expression.
Regular expression syntax: https://github.com/google/re2/wiki/Syntax.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'regex': ConjureFieldDefinition('regex', str)
        }

    __slots__: List[str] = ['_regex']

    def __init__(self, regex: str) -> None:
        self._regex = regex

    @builtins.property
    def regex(self) -> str:
        return self._regex


scout_compute_api_LogRegexFilterOperator.__name__ = "LogRegexFilterOperator"
scout_compute_api_LogRegexFilterOperator.__qualname__ = "LogRegexFilterOperator"
scout_compute_api_LogRegexFilterOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogSeries(ConjureUnionType):
    _raw: Optional["scout_compute_api_Reference"] = None
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _union: Optional["scout_compute_api_LogUnionSeries"] = None
    _filter: Optional["scout_compute_api_LogFilterSeries"] = None
    _time_shift: Optional["scout_compute_api_LogTimeShiftSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'union': ConjureFieldDefinition('union', scout_compute_api_LogUnionSeries),
            'filter': ConjureFieldDefinition('filter', scout_compute_api_LogFilterSeries),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_LogTimeShiftSeries)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_Reference"] = None,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            union: Optional["scout_compute_api_LogUnionSeries"] = None,
            filter: Optional["scout_compute_api_LogFilterSeries"] = None,
            time_shift: Optional["scout_compute_api_LogTimeShiftSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (channel is not None) + (derived is not None) + (union is not None) + (filter is not None) + (time_shift is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if union is not None:
                self._union = union
                self._type = 'union'
            if filter is not None:
                self._filter = filter
                self._type = 'filter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'filter':
            if filter is None:
                raise ValueError('a union value must not be None')
            self._filter = filter
            self._type = 'filter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def union(self) -> Optional["scout_compute_api_LogUnionSeries"]:
        return self._union

    @builtins.property
    def filter(self) -> Optional["scout_compute_api_LogFilterSeries"]:
        return self._filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_LogTimeShiftSeries"]:
        return self._time_shift

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_LogSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_LogSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'filter' and self.filter is not None:
            return visitor._filter(self.filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)


scout_compute_api_LogSeries.__name__ = "LogSeries"
scout_compute_api_LogSeries.__qualname__ = "LogSeries"
scout_compute_api_LogSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogSeriesVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_LogUnionSeries") -> Any:
        pass

    @abstractmethod
    def _filter(self, filter: "scout_compute_api_LogFilterSeries") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_LogTimeShiftSeries") -> Any:
        pass


scout_compute_api_LogSeriesVisitor.__name__ = "LogSeriesVisitor"
scout_compute_api_LogSeriesVisitor.__qualname__ = "LogSeriesVisitor"
scout_compute_api_LogSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogTimeShiftSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_LogSeries),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", input: "scout_compute_api_LogSeries") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_LogSeries":
        return self._input

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_LogTimeShiftSeries.__name__ = "LogTimeShiftSeries"
scout_compute_api_LogTimeShiftSeries.__qualname__ = "LogTimeShiftSeries"
scout_compute_api_LogTimeShiftSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogUnionOperation(ConjureEnumType):

    KEEP_ALL = 'KEEP_ALL'
    '''KEEP_ALL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_LogUnionOperation.__name__ = "LogUnionOperation"
scout_compute_api_LogUnionOperation.__qualname__ = "LogUnionOperation"
scout_compute_api_LogUnionOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogUnionSeries(ConjureBeanType):
    """Combines multiple log series together and outputs a single series. The strategy to merge input values with the
same timestamp together is specified in the operation field.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_LogSeries]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_LogUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_LogSeries"], operation: "scout_compute_api_LogUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_LogSeries"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_LogUnionOperation":
        """The strategy to merge points with duplicate timestamps.
        """
        return self._operation


scout_compute_api_LogUnionSeries.__name__ = "LogUnionSeries"
scout_compute_api_LogUnionSeries.__qualname__ = "LogUnionSeries"
scout_compute_api_LogUnionSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogValue(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str),
            'args': ConjureFieldDefinition('args', Dict[str, str]),
            'id': ConjureFieldDefinition('id', str)
        }

    __slots__: List[str] = ['_message', '_args', '_id']

    def __init__(self, args: Dict[str, str], id: str, message: str) -> None:
        self._message = message
        self._args = args
        self._id = id

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def args(self) -> Dict[str, str]:
        return self._args

    @builtins.property
    def id(self) -> str:
        return self._id


scout_compute_api_LogValue.__name__ = "LogValue"
scout_compute_api_LogValue.__qualname__ = "LogValue"
scout_compute_api_LogValue.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogarithmicCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_LogarithmicCurve.__name__ = "LogarithmicCurve"
scout_compute_api_LogarithmicCurve.__qualname__ = "LogarithmicCurve"
scout_compute_api_LogarithmicCurve.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LogarithmicResultDetails(ConjureBeanType):
    """y = a * ln(x) + b
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'a': ConjureFieldDefinition('a', float),
            'b': ConjureFieldDefinition('b', float)
        }

    __slots__: List[str] = ['_a', '_b']

    def __init__(self, a: float, b: float) -> None:
        self._a = a
        self._b = b

    @builtins.property
    def a(self) -> float:
        return self._a

    @builtins.property
    def b(self) -> float:
        return self._b


scout_compute_api_LogarithmicResultDetails.__name__ = "LogarithmicResultDetails"
scout_compute_api_LogarithmicResultDetails.__qualname__ = "LogarithmicResultDetails"
scout_compute_api_LogarithmicResultDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_LowPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cutoff_frequency': ConjureFieldDefinition('cutoffFrequency', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_cutoff_frequency']

    def __init__(self, cutoff_frequency: "scout_compute_api_DoubleConstant") -> None:
        self._cutoff_frequency = cutoff_frequency

    @builtins.property
    def cutoff_frequency(self) -> "scout_compute_api_DoubleConstant":
        return self._cutoff_frequency


scout_compute_api_LowPassConfiguration.__name__ = "LowPassConfiguration"
scout_compute_api_LowPassConfiguration.__qualname__ = "LowPassConfiguration"
scout_compute_api_LowPassConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MagnitudeScaling(ConjureEnumType):

    LINEAR = 'LINEAR'
    '''LINEAR'''
    MAGNITUDE_DB_10 = 'MAGNITUDE_DB_10'
    '''MAGNITUDE_DB_10'''
    MAGNITUDE_DB_20 = 'MAGNITUDE_DB_20'
    '''MAGNITUDE_DB_20'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_MagnitudeScaling.__name__ = "MagnitudeScaling"
scout_compute_api_MagnitudeScaling.__qualname__ = "MagnitudeScaling"
scout_compute_api_MagnitudeScaling.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MaxSeries(ConjureBeanType):
    """For every timestamp specified in the input series, outputs a value that is the maximum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeries]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MaxSeries.__name__ = "MaxSeries"
scout_compute_api_MaxSeries.__qualname__ = "MaxSeries"
scout_compute_api_MaxSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Maximum(ConjureBeanType):
    """The maximum value of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Maximum.__name__ = "Maximum"
scout_compute_api_Maximum.__qualname__ = "Maximum"
scout_compute_api_Maximum.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MeanSeries(ConjureBeanType):
    """For every timestamp specified in the input series, outputs a value that is the mean for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeries]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MeanSeries.__name__ = "MeanSeries"
scout_compute_api_MeanSeries.__qualname__ = "MeanSeries"
scout_compute_api_MeanSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MinMaxThresholdOperator(ConjureEnumType):

    OUTSIDE_BOUNDS = 'OUTSIDE_BOUNDS'
    '''OUTSIDE_BOUNDS'''
    OUTSIDE_OR_EQUAL_TO_BOUNDS = 'OUTSIDE_OR_EQUAL_TO_BOUNDS'
    '''OUTSIDE_OR_EQUAL_TO_BOUNDS'''
    INSIDE_BOUNDS = 'INSIDE_BOUNDS'
    '''INSIDE_BOUNDS'''
    INSIDE_OR_EQUAL_TO_BOUNDS = 'INSIDE_OR_EQUAL_TO_BOUNDS'
    '''INSIDE_OR_EQUAL_TO_BOUNDS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_MinMaxThresholdOperator.__name__ = "MinMaxThresholdOperator"
scout_compute_api_MinMaxThresholdOperator.__qualname__ = "MinMaxThresholdOperator"
scout_compute_api_MinMaxThresholdOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MinMaxThresholdRanges(ConjureBeanType):
    """Produces a list of ranges for which the threshold condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'lower_bound': ConjureFieldDefinition('lowerBound', scout_compute_api_DoubleConstant),
            'upper_bound': ConjureFieldDefinition('upperBound', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_MinMaxThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_lower_bound', '_upper_bound', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", lower_bound: "scout_compute_api_DoubleConstant", operator: "scout_compute_api_MinMaxThresholdOperator", upper_bound: "scout_compute_api_DoubleConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def lower_bound(self) -> "scout_compute_api_DoubleConstant":
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> "scout_compute_api_DoubleConstant":
        return self._upper_bound

    @builtins.property
    def operator(self) -> "scout_compute_api_MinMaxThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_MinMaxThresholdRanges.__name__ = "MinMaxThresholdRanges"
scout_compute_api_MinMaxThresholdRanges.__qualname__ = "MinMaxThresholdRanges"
scout_compute_api_MinMaxThresholdRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_MinSeries(ConjureBeanType):
    """For every timestamp specified in the input series, outputs a value that is the minimum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeries]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_MinSeries.__name__ = "MinSeries"
scout_compute_api_MinSeries.__qualname__ = "MinSeries"
scout_compute_api_MinSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Minimum(ConjureBeanType):
    """The minimum value of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Minimum.__name__ = "Minimum"
scout_compute_api_Minimum.__qualname__ = "Minimum"
scout_compute_api_Minimum.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ModuleVersionReference(ConjureUnionType):
    _pinned: Optional["scout_compute_api_PinnedModuleVersionReference"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pinned': ConjureFieldDefinition('pinned', scout_compute_api_PinnedModuleVersionReference)
        }

    def __init__(
            self,
            pinned: Optional["scout_compute_api_PinnedModuleVersionReference"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pinned is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pinned is not None:
                self._pinned = pinned
                self._type = 'pinned'

        elif type_of_union == 'pinned':
            if pinned is None:
                raise ValueError('a union value must not be None')
            self._pinned = pinned
            self._type = 'pinned'

    @builtins.property
    def pinned(self) -> Optional["scout_compute_api_PinnedModuleVersionReference"]:
        return self._pinned

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ModuleVersionReferenceVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ModuleVersionReferenceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pinned' and self.pinned is not None:
            return visitor._pinned(self.pinned)


scout_compute_api_ModuleVersionReference.__name__ = "ModuleVersionReference"
scout_compute_api_ModuleVersionReference.__qualname__ = "ModuleVersionReference"
scout_compute_api_ModuleVersionReference.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ModuleVersionReferenceVisitor:

    @abstractmethod
    def _pinned(self, pinned: "scout_compute_api_PinnedModuleVersionReference") -> Any:
        pass


scout_compute_api_ModuleVersionReferenceVisitor.__name__ = "ModuleVersionReferenceVisitor"
scout_compute_api_ModuleVersionReferenceVisitor.__qualname__ = "ModuleVersionReferenceVisitor"
scout_compute_api_ModuleVersionReferenceVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NegativeValueConfiguration(ConjureUnionType):
    _allow_negative_values: Optional["scout_compute_api_AllowNegativeValues"] = None
    _set_negative_values_to_zero: Optional["scout_compute_api_SetNegativeValuesToZero"] = None
    _exclude_negative_values: Optional["scout_compute_api_ExcludeNegativeValues"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'allow_negative_values': ConjureFieldDefinition('allowNegativeValues', scout_compute_api_AllowNegativeValues),
            'set_negative_values_to_zero': ConjureFieldDefinition('setNegativeValuesToZero', scout_compute_api_SetNegativeValuesToZero),
            'exclude_negative_values': ConjureFieldDefinition('excludeNegativeValues', scout_compute_api_ExcludeNegativeValues)
        }

    def __init__(
            self,
            allow_negative_values: Optional["scout_compute_api_AllowNegativeValues"] = None,
            set_negative_values_to_zero: Optional["scout_compute_api_SetNegativeValuesToZero"] = None,
            exclude_negative_values: Optional["scout_compute_api_ExcludeNegativeValues"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (allow_negative_values is not None) + (set_negative_values_to_zero is not None) + (exclude_negative_values is not None) != 1:
                raise ValueError('a union must contain a single member')

            if allow_negative_values is not None:
                self._allow_negative_values = allow_negative_values
                self._type = 'allowNegativeValues'
            if set_negative_values_to_zero is not None:
                self._set_negative_values_to_zero = set_negative_values_to_zero
                self._type = 'setNegativeValuesToZero'
            if exclude_negative_values is not None:
                self._exclude_negative_values = exclude_negative_values
                self._type = 'excludeNegativeValues'

        elif type_of_union == 'allowNegativeValues':
            if allow_negative_values is None:
                raise ValueError('a union value must not be None')
            self._allow_negative_values = allow_negative_values
            self._type = 'allowNegativeValues'
        elif type_of_union == 'setNegativeValuesToZero':
            if set_negative_values_to_zero is None:
                raise ValueError('a union value must not be None')
            self._set_negative_values_to_zero = set_negative_values_to_zero
            self._type = 'setNegativeValuesToZero'
        elif type_of_union == 'excludeNegativeValues':
            if exclude_negative_values is None:
                raise ValueError('a union value must not be None')
            self._exclude_negative_values = exclude_negative_values
            self._type = 'excludeNegativeValues'

    @builtins.property
    def allow_negative_values(self) -> Optional["scout_compute_api_AllowNegativeValues"]:
        """Include negative output values
        """
        return self._allow_negative_values

    @builtins.property
    def set_negative_values_to_zero(self) -> Optional["scout_compute_api_SetNegativeValuesToZero"]:
        """Set negative output values to zero
        """
        return self._set_negative_values_to_zero

    @builtins.property
    def exclude_negative_values(self) -> Optional["scout_compute_api_ExcludeNegativeValues"]:
        """Exclude points with negative output values
        """
        return self._exclude_negative_values

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NegativeValueConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NegativeValueConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'allowNegativeValues' and self.allow_negative_values is not None:
            return visitor._allow_negative_values(self.allow_negative_values)
        if self._type == 'setNegativeValuesToZero' and self.set_negative_values_to_zero is not None:
            return visitor._set_negative_values_to_zero(self.set_negative_values_to_zero)
        if self._type == 'excludeNegativeValues' and self.exclude_negative_values is not None:
            return visitor._exclude_negative_values(self.exclude_negative_values)


scout_compute_api_NegativeValueConfiguration.__name__ = "NegativeValueConfiguration"
scout_compute_api_NegativeValueConfiguration.__qualname__ = "NegativeValueConfiguration"
scout_compute_api_NegativeValueConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NegativeValueConfigurationVisitor:

    @abstractmethod
    def _allow_negative_values(self, allow_negative_values: "scout_compute_api_AllowNegativeValues") -> Any:
        pass

    @abstractmethod
    def _set_negative_values_to_zero(self, set_negative_values_to_zero: "scout_compute_api_SetNegativeValuesToZero") -> Any:
        pass

    @abstractmethod
    def _exclude_negative_values(self, exclude_negative_values: "scout_compute_api_ExcludeNegativeValues") -> Any:
        pass


scout_compute_api_NegativeValueConfigurationVisitor.__name__ = "NegativeValueConfigurationVisitor"
scout_compute_api_NegativeValueConfigurationVisitor.__qualname__ = "NegativeValueConfigurationVisitor"
scout_compute_api_NegativeValueConfigurationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NotRanges(ConjureBeanType):
    """The not ranges node will invert the ranges, filling the negative space in time.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangeSeries)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_RangeSeries") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_RangeSeries":
        return self._input


scout_compute_api_NotRanges.__name__ = "NotRanges"
scout_compute_api_NotRanges.__qualname__ = "NotRanges"
scout_compute_api_NotRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Numeric1dArraySeries(ConjureUnionType):
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries)
        }

    def __init__(
            self,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (raw is not None) + (derived is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_Numeric1dArraySeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_Numeric1dArraySeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)


scout_compute_api_Numeric1dArraySeries.__name__ = "Numeric1dArraySeries"
scout_compute_api_Numeric1dArraySeries.__qualname__ = "Numeric1dArraySeries"
scout_compute_api_Numeric1dArraySeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Numeric1dArraySeriesVisitor:

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass


scout_compute_api_Numeric1dArraySeriesVisitor.__name__ = "Numeric1dArraySeriesVisitor"
scout_compute_api_Numeric1dArraySeriesVisitor.__qualname__ = "Numeric1dArraySeriesVisitor"
scout_compute_api_Numeric1dArraySeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericAggregationFunction(ConjureEnumType):

    SUM = 'SUM'
    '''SUM'''
    MEAN = 'MEAN'
    '''MEAN'''
    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    COUNT = 'COUNT'
    '''COUNT'''
    STANDARD_DEVIATION = 'STANDARD_DEVIATION'
    '''STANDARD_DEVIATION'''
    ROOT_MEAN_SQUARE = 'ROOT_MEAN_SQUARE'
    '''ROOT_MEAN_SQUARE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericAggregationFunction.__name__ = "NumericAggregationFunction"
scout_compute_api_NumericAggregationFunction.__qualname__ = "NumericAggregationFunction"
scout_compute_api_NumericAggregationFunction.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericApproximateFilterSeries(ConjureBeanType):
    """Outputs the values of the numeric plot value that are approximately equal to the threshold value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DoubleConstant),
            'tolerance': ConjureFieldDefinition('tolerance', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ApproximateThresholdOperator)
        }

    __slots__: List[str] = ['_input', '_threshold', '_tolerance', '_operator']

    def __init__(self, input: "scout_compute_api_NumericSeries", operator: "scout_compute_api_ApproximateThresholdOperator", threshold: "scout_compute_api_DoubleConstant", tolerance: "scout_compute_api_DoubleConstant") -> None:
        self._input = input
        self._threshold = threshold
        self._tolerance = tolerance
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DoubleConstant":
        return self._threshold

    @builtins.property
    def tolerance(self) -> "scout_compute_api_DoubleConstant":
        return self._tolerance

    @builtins.property
    def operator(self) -> "scout_compute_api_ApproximateThresholdOperator":
        return self._operator


scout_compute_api_NumericApproximateFilterSeries.__name__ = "NumericApproximateFilterSeries"
scout_compute_api_NumericApproximateFilterSeries.__qualname__ = "NumericApproximateFilterSeries"
scout_compute_api_NumericApproximateFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min': ConjureFieldDefinition('min', float),
            'max': ConjureFieldDefinition('max', float),
            'mean': ConjureFieldDefinition('mean', float),
            'count': ConjureFieldDefinition('count', int),
            'variance': ConjureFieldDefinition('variance', float),
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_NumericPoint),
            'last_point': ConjureFieldDefinition('lastPoint', OptionalTypeWrapper[scout_compute_api_NumericPoint])
        }

    __slots__: List[str] = ['_min', '_max', '_mean', '_count', '_variance', '_first_point', '_last_point']

    def __init__(self, count: int, first_point: "scout_compute_api_NumericPoint", max: float, mean: float, min: float, variance: float, last_point: Optional["scout_compute_api_NumericPoint"] = None) -> None:
        self._min = min
        self._max = max
        self._mean = mean
        self._count = count
        self._variance = variance
        self._first_point = first_point
        self._last_point = last_point

    @builtins.property
    def min(self) -> float:
        return self._min

    @builtins.property
    def max(self) -> float:
        return self._max

    @builtins.property
    def mean(self) -> float:
        return self._mean

    @builtins.property
    def count(self) -> int:
        return self._count

    @builtins.property
    def variance(self) -> float:
        """The population variance of the bucket. If the bucket has only one value, this will be 0.
        """
        return self._variance

    @builtins.property
    def first_point(self) -> "scout_compute_api_NumericPoint":
        return self._first_point

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_NumericPoint"]:
        """Will be empty if the bucket only has a single point.
        """
        return self._last_point


scout_compute_api_NumericBucket.__name__ = "NumericBucket"
scout_compute_api_NumericBucket.__qualname__ = "NumericBucket"
scout_compute_api_NumericBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericConstantResampleInterpolationConfiguration(ConjureBeanType):
    """Fills all empty resample intervals with a single constant value.

If a resampled time interval (bucket) contains no data points from the input, it will
be assigned the specified 'constant' as a default value. This applies to gaps at the start of the 
series, between data points, and at the end.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'constant': ConjureFieldDefinition('constant', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_constant']

    def __init__(self, constant: "scout_compute_api_DoubleConstant") -> None:
        self._constant = constant

    @builtins.property
    def constant(self) -> "scout_compute_api_DoubleConstant":
        return self._constant


scout_compute_api_NumericConstantResampleInterpolationConfiguration.__name__ = "NumericConstantResampleInterpolationConfiguration"
scout_compute_api_NumericConstantResampleInterpolationConfiguration.__qualname__ = "NumericConstantResampleInterpolationConfiguration"
scout_compute_api_NumericConstantResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericDataType(ConjureEnumType):
    """Supported numeric data types for value casting.
    """

    INT64 = 'INT64'
    '''INT64'''
    FLOAT64 = 'FLOAT64'
    '''FLOAT64'''
    UINT64 = 'UINT64'
    '''UINT64'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericDataType.__name__ = "NumericDataType"
scout_compute_api_NumericDataType.__qualname__ = "NumericDataType"
scout_compute_api_NumericDataType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericFilterTransformationSeries(ConjureBeanType):
    """Outputs the values of the numeric plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'filter': ConjureFieldDefinition('filter', scout_compute_api_RangeSeries)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_api_RangeSeries", input: "scout_compute_api_NumericSeries") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_api_RangeSeries":
        return self._filter


scout_compute_api_NumericFilterTransformationSeries.__name__ = "NumericFilterTransformationSeries"
scout_compute_api_NumericFilterTransformationSeries.__qualname__ = "NumericFilterTransformationSeries"
scout_compute_api_NumericFilterTransformationSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucket(ConjureBeanType):
    """A bucket in a numeric histogram representing a range of values,
and the counts of values in that range across all input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'lower_bound': ConjureFieldDefinition('lowerBound', float),
            'upper_bound': ConjureFieldDefinition('upperBound', float),
            'counts_by_channel': ConjureFieldDefinition('countsByChannel', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount]),
            'buckets': ConjureFieldDefinition('buckets', Dict[scout_compute_api_VariableName, scout_compute_api_HistogramChannelCount])
        }

    __slots__: List[str] = ['_lower_bound', '_upper_bound', '_counts_by_channel', '_buckets']

    def __init__(self, buckets: Dict[str, "scout_compute_api_HistogramChannelCount"], counts_by_channel: Dict[str, "scout_compute_api_HistogramChannelCount"], lower_bound: float, upper_bound: float) -> None:
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._counts_by_channel = counts_by_channel
        self._buckets = buckets

    @builtins.property
    def lower_bound(self) -> float:
        """The lower bound of the bucket, inclusive
        """
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> float:
        """The upper bound of the bucket, exclusive
        """
        return self._upper_bound

    @builtins.property
    def counts_by_channel(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._counts_by_channel

    @builtins.property
    def buckets(self) -> Dict[str, "scout_compute_api_HistogramChannelCount"]:
        return self._buckets


scout_compute_api_NumericHistogramBucket.__name__ = "NumericHistogramBucket"
scout_compute_api_NumericHistogramBucket.__qualname__ = "NumericHistogramBucket"
scout_compute_api_NumericHistogramBucket.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketStrategy(ConjureUnionType):
    _bucket_count: Optional["scout_compute_api_IntegerConstant"] = None
    _bucket_width_and_offset: Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket_count': ConjureFieldDefinition('bucketCount', scout_compute_api_IntegerConstant),
            'bucket_width_and_offset': ConjureFieldDefinition('bucketWidthAndOffset', scout_compute_api_NumericHistogramBucketWidthAndOffset)
        }

    def __init__(
            self,
            bucket_count: Optional["scout_compute_api_IntegerConstant"] = None,
            bucket_width_and_offset: Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket_count is not None) + (bucket_width_and_offset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket_count is not None:
                self._bucket_count = bucket_count
                self._type = 'bucketCount'
            if bucket_width_and_offset is not None:
                self._bucket_width_and_offset = bucket_width_and_offset
                self._type = 'bucketWidthAndOffset'

        elif type_of_union == 'bucketCount':
            if bucket_count is None:
                raise ValueError('a union value must not be None')
            self._bucket_count = bucket_count
            self._type = 'bucketCount'
        elif type_of_union == 'bucketWidthAndOffset':
            if bucket_width_and_offset is None:
                raise ValueError('a union value must not be None')
            self._bucket_width_and_offset = bucket_width_and_offset
            self._type = 'bucketWidthAndOffset'

    @builtins.property
    def bucket_count(self) -> Optional["scout_compute_api_IntegerConstant"]:
        """The number of buckets to use in the histogram. Width is automatically calculated from the range
of the input series, with the lower and upper bounds of the histogram being multiples of the width.
        """
        return self._bucket_count

    @builtins.property
    def bucket_width_and_offset(self) -> Optional["scout_compute_api_NumericHistogramBucketWidthAndOffset"]:
        return self._bucket_width_and_offset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NumericHistogramBucketStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NumericHistogramBucketStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucketCount' and self.bucket_count is not None:
            return visitor._bucket_count(self.bucket_count)
        if self._type == 'bucketWidthAndOffset' and self.bucket_width_and_offset is not None:
            return visitor._bucket_width_and_offset(self.bucket_width_and_offset)


scout_compute_api_NumericHistogramBucketStrategy.__name__ = "NumericHistogramBucketStrategy"
scout_compute_api_NumericHistogramBucketStrategy.__qualname__ = "NumericHistogramBucketStrategy"
scout_compute_api_NumericHistogramBucketStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketStrategyVisitor:

    @abstractmethod
    def _bucket_count(self, bucket_count: "scout_compute_api_IntegerConstant") -> Any:
        pass

    @abstractmethod
    def _bucket_width_and_offset(self, bucket_width_and_offset: "scout_compute_api_NumericHistogramBucketWidthAndOffset") -> Any:
        pass


scout_compute_api_NumericHistogramBucketStrategyVisitor.__name__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_api_NumericHistogramBucketStrategyVisitor.__qualname__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_api_NumericHistogramBucketStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramBucketWidthAndOffset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'width': ConjureFieldDefinition('width', scout_compute_api_DoubleConstant),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_width', '_offset']

    def __init__(self, width: "scout_compute_api_DoubleConstant", offset: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._width = width
        self._offset = offset

    @builtins.property
    def width(self) -> "scout_compute_api_DoubleConstant":
        """The width of each bucket. If offset is not specified, the left and right bounds of each bucket
are multiples of the width. If offset is specified, the left and right bounds of each bucket are
shifted right by the offset value.
        """
        return self._width

    @builtins.property
    def offset(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """The rightward shift to apply to the left and right bounds of each bucket. If not specified, 
the offset will be 0. The offset must be non-negative.
        """
        return self._offset


scout_compute_api_NumericHistogramBucketWidthAndOffset.__name__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_api_NumericHistogramBucketWidthAndOffset.__qualname__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_api_NumericHistogramBucketWidthAndOffset.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_api_NumericSeries]),
            'bucket_strategy': ConjureFieldDefinition('bucketStrategy', OptionalTypeWrapper[scout_compute_api_NumericHistogramBucketStrategy])
        }

    __slots__: List[str] = ['_inputs', '_bucket_strategy']

    def __init__(self, inputs: Dict[str, "scout_compute_api_NumericSeries"], bucket_strategy: Optional["scout_compute_api_NumericHistogramBucketStrategy"] = None) -> None:
        self._inputs = inputs
        self._bucket_strategy = bucket_strategy

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def bucket_strategy(self) -> Optional["scout_compute_api_NumericHistogramBucketStrategy"]:
        return self._bucket_strategy


scout_compute_api_NumericHistogramNode.__name__ = "NumericHistogramNode"
scout_compute_api_NumericHistogramNode.__qualname__ = "NumericHistogramNode"
scout_compute_api_NumericHistogramNode.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericHistogramPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_compute_api_NumericHistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_compute_api_NumericHistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_compute_api_NumericHistogramBucket"]:
        return self._buckets


scout_compute_api_NumericHistogramPlot.__name__ = "NumericHistogramPlot"
scout_compute_api_NumericHistogramPlot.__qualname__ = "NumericHistogramPlot"
scout_compute_api_NumericHistogramPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericOutputField(ConjureEnumType):

    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    MEAN = 'MEAN'
    '''MEAN'''
    COUNT = 'COUNT'
    '''COUNT'''
    VARIANCE = 'VARIANCE'
    '''VARIANCE'''
    FIRST_POINT = 'FIRST_POINT'
    '''FIRST_POINT'''
    LAST_POINT = 'LAST_POINT'
    '''LAST_POINT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericOutputField.__name__ = "NumericOutputField"
scout_compute_api_NumericOutputField.__qualname__ = "NumericOutputField"
scout_compute_api_NumericOutputField.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', List[float])
        }

    __slots__: List[str] = ['_timestamps', '_values']

    def __init__(self, timestamps: List["api_Timestamp"], values: List[float]) -> None:
        self._timestamps = timestamps
        self._values = values

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def values(self) -> List[float]:
        return self._values


scout_compute_api_NumericPlot.__name__ = "NumericPlot"
scout_compute_api_NumericPlot.__qualname__ = "NumericPlot"
scout_compute_api_NumericPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: float) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> float:
        return self._value


scout_compute_api_NumericPoint.__name__ = "NumericPoint"
scout_compute_api_NumericPoint.__qualname__ = "NumericPoint"
scout_compute_api_NumericPoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericResampleConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interval': ConjureFieldDefinition('interval', scout_compute_api_DurationConstant),
            'interpolation': ConjureFieldDefinition('interpolation', OptionalTypeWrapper[scout_compute_api_NumericResampleInterpolationConfiguration])
        }

    __slots__: List[str] = ['_interval', '_interpolation']

    def __init__(self, interval: "scout_compute_api_DurationConstant", interpolation: Optional["scout_compute_api_NumericResampleInterpolationConfiguration"] = None) -> None:
        self._interval = interval
        self._interpolation = interpolation

    @builtins.property
    def interval(self) -> "scout_compute_api_DurationConstant":
        """Interval between resampled points
        """
        return self._interval

    @builtins.property
    def interpolation(self) -> Optional["scout_compute_api_NumericResampleInterpolationConfiguration"]:
        """Interpolation strategy to use (defaults to forward fill).
        """
        return self._interpolation


scout_compute_api_NumericResampleConfiguration.__name__ = "NumericResampleConfiguration"
scout_compute_api_NumericResampleConfiguration.__qualname__ = "NumericResampleConfiguration"
scout_compute_api_NumericResampleConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericResampleInterpolationConfiguration(ConjureUnionType):
    _forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None
    _constant_resample_interpolation_configuration: Optional["scout_compute_api_NumericConstantResampleInterpolationConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_resample_interpolation_configuration': ConjureFieldDefinition('forwardFillResampleInterpolationConfiguration', scout_compute_api_ForwardFillResampleInterpolationConfiguration),
            'constant_resample_interpolation_configuration': ConjureFieldDefinition('constantResampleInterpolationConfiguration', scout_compute_api_NumericConstantResampleInterpolationConfiguration)
        }

    def __init__(
            self,
            forward_fill_resample_interpolation_configuration: Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"] = None,
            constant_resample_interpolation_configuration: Optional["scout_compute_api_NumericConstantResampleInterpolationConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_resample_interpolation_configuration is not None) + (constant_resample_interpolation_configuration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_resample_interpolation_configuration is not None:
                self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
                self._type = 'forwardFillResampleInterpolationConfiguration'
            if constant_resample_interpolation_configuration is not None:
                self._constant_resample_interpolation_configuration = constant_resample_interpolation_configuration
                self._type = 'constantResampleInterpolationConfiguration'

        elif type_of_union == 'forwardFillResampleInterpolationConfiguration':
            if forward_fill_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
            self._type = 'forwardFillResampleInterpolationConfiguration'
        elif type_of_union == 'constantResampleInterpolationConfiguration':
            if constant_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._constant_resample_interpolation_configuration = constant_resample_interpolation_configuration
            self._type = 'constantResampleInterpolationConfiguration'

    @builtins.property
    def forward_fill_resample_interpolation_configuration(self) -> Optional["scout_compute_api_ForwardFillResampleInterpolationConfiguration"]:
        return self._forward_fill_resample_interpolation_configuration

    @builtins.property
    def constant_resample_interpolation_configuration(self) -> Optional["scout_compute_api_NumericConstantResampleInterpolationConfiguration"]:
        return self._constant_resample_interpolation_configuration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NumericResampleInterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NumericResampleInterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillResampleInterpolationConfiguration' and self.forward_fill_resample_interpolation_configuration is not None:
            return visitor._forward_fill_resample_interpolation_configuration(self.forward_fill_resample_interpolation_configuration)
        if self._type == 'constantResampleInterpolationConfiguration' and self.constant_resample_interpolation_configuration is not None:
            return visitor._constant_resample_interpolation_configuration(self.constant_resample_interpolation_configuration)


scout_compute_api_NumericResampleInterpolationConfiguration.__name__ = "NumericResampleInterpolationConfiguration"
scout_compute_api_NumericResampleInterpolationConfiguration.__qualname__ = "NumericResampleInterpolationConfiguration"
scout_compute_api_NumericResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericResampleInterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_resample_interpolation_configuration(self, forward_fill_resample_interpolation_configuration: "scout_compute_api_ForwardFillResampleInterpolationConfiguration") -> Any:
        pass

    @abstractmethod
    def _constant_resample_interpolation_configuration(self, constant_resample_interpolation_configuration: "scout_compute_api_NumericConstantResampleInterpolationConfiguration") -> Any:
        pass


scout_compute_api_NumericResampleInterpolationConfigurationVisitor.__name__ = "NumericResampleInterpolationConfigurationVisitor"
scout_compute_api_NumericResampleInterpolationConfigurationVisitor.__qualname__ = "NumericResampleInterpolationConfigurationVisitor"
scout_compute_api_NumericResampleInterpolationConfigurationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericResampleSeries(ConjureBeanType):
    """Resamples the input series to a new resolution using interpolation.
Outputs data for timestamps corresponding to the defined frequency. Based on interpolation strategy,
determines range of timestamps to output data for and interpolates values where necessary.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_api_NumericResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", resample_configuration: "scout_compute_api_NumericResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_api_NumericResampleConfiguration":
        """The interpolation strategy and interval at which to resample the series
        """
        return self._resample_configuration


scout_compute_api_NumericResampleSeries.__name__ = "NumericResampleSeries"
scout_compute_api_NumericResampleSeries.__qualname__ = "NumericResampleSeries"
scout_compute_api_NumericResampleSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericSeries(ConjureUnionType):
    _aggregate: Optional["scout_compute_api_AggregateNumericSeries"] = None
    _arithmetic: Optional["scout_compute_api_ArithmeticSeries"] = None
    _bit_operation: Optional["scout_compute_api_BitOperationSeries"] = None
    _count_duplicate: Optional["scout_compute_api_EnumCountDuplicateSeries"] = None
    _cumulative_sum: Optional["scout_compute_api_CumulativeSumSeries"] = None
    _derivative: Optional["scout_compute_api_DerivativeSeries"] = None
    _integral: Optional["scout_compute_api_IntegralSeries"] = None
    _max: Optional["scout_compute_api_MaxSeries"] = None
    _mean: Optional["scout_compute_api_MeanSeries"] = None
    _min: Optional["scout_compute_api_MinSeries"] = None
    _offset: Optional["scout_compute_api_OffsetSeries"] = None
    _product: Optional["scout_compute_api_ProductSeries"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _resample: Optional["scout_compute_api_NumericResampleSeries"] = None
    _rolling_operation: Optional["scout_compute_api_RollingOperationSeries"] = None
    _signal_filter: Optional["scout_compute_api_SignalFilterSeries"] = None
    _sum: Optional["scout_compute_api_SumSeries"] = None
    _scale: Optional["scout_compute_api_ScaleSeries"] = None
    _time_difference: Optional["scout_compute_api_TimeDifferenceSeries"] = None
    _absolute_timestamp: Optional["scout_compute_api_AbsoluteTimestampSeries"] = None
    _time_range_filter: Optional["scout_compute_api_NumericTimeRangeFilterSeries"] = None
    _time_shift: Optional["scout_compute_api_NumericTimeShiftSeries"] = None
    _unary_arithmetic: Optional["scout_compute_api_UnaryArithmeticSeries"] = None
    _binary_arithmetic: Optional["scout_compute_api_BinaryArithmeticSeries"] = None
    _union: Optional["scout_compute_api_NumericUnionSeries"] = None
    _unit_conversion: Optional["scout_compute_api_UnitConversionSeries"] = None
    _value_difference: Optional["scout_compute_api_ValueDifferenceSeries"] = None
    _filter_transformation: Optional["scout_compute_api_NumericFilterTransformationSeries"] = None
    _threshold_filter: Optional["scout_compute_api_NumericThresholdFilterSeries"] = None
    _approximate_filter: Optional["scout_compute_api_NumericApproximateFilterSeries"] = None
    _select1d_array_index: Optional["scout_compute_api_SelectIndexFrom1dNumericArraySeries"] = None
    _select_newest_points: Optional["scout_compute_api_SelectNewestPointsSeries"] = None
    _aggregate_under_ranges: Optional["scout_compute_api_AggregateUnderRangesSeries"] = None
    _filter_by_expression: Optional["scout_compute_api_FilterByExpressionSeries"] = None
    _enum_to_numeric: Optional["scout_compute_api_EnumToNumericSeries"] = None
    _refprop: Optional["scout_compute_api_RefpropSeries"] = None
    _extract_from_struct: Optional["scout_compute_api_ExtractNumericFromStructSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_api_AggregateNumericSeries),
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_api_ArithmeticSeries),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_api_BitOperationSeries),
            'count_duplicate': ConjureFieldDefinition('countDuplicate', scout_compute_api_EnumCountDuplicateSeries),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_api_CumulativeSumSeries),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_api_DerivativeSeries),
            'integral': ConjureFieldDefinition('integral', scout_compute_api_IntegralSeries),
            'max': ConjureFieldDefinition('max', scout_compute_api_MaxSeries),
            'mean': ConjureFieldDefinition('mean', scout_compute_api_MeanSeries),
            'min': ConjureFieldDefinition('min', scout_compute_api_MinSeries),
            'offset': ConjureFieldDefinition('offset', scout_compute_api_OffsetSeries),
            'product': ConjureFieldDefinition('product', scout_compute_api_ProductSeries),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'resample': ConjureFieldDefinition('resample', scout_compute_api_NumericResampleSeries),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_api_RollingOperationSeries),
            'signal_filter': ConjureFieldDefinition('signalFilter', scout_compute_api_SignalFilterSeries),
            'sum': ConjureFieldDefinition('sum', scout_compute_api_SumSeries),
            'scale': ConjureFieldDefinition('scale', scout_compute_api_ScaleSeries),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_api_TimeDifferenceSeries),
            'absolute_timestamp': ConjureFieldDefinition('absoluteTimestamp', scout_compute_api_AbsoluteTimestampSeries),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_NumericTimeRangeFilterSeries),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_NumericTimeShiftSeries),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_api_UnaryArithmeticSeries),
            'binary_arithmetic': ConjureFieldDefinition('binaryArithmetic', scout_compute_api_BinaryArithmeticSeries),
            'union': ConjureFieldDefinition('union', scout_compute_api_NumericUnionSeries),
            'unit_conversion': ConjureFieldDefinition('unitConversion', scout_compute_api_UnitConversionSeries),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_api_ValueDifferenceSeries),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_api_NumericFilterTransformationSeries),
            'threshold_filter': ConjureFieldDefinition('thresholdFilter', scout_compute_api_NumericThresholdFilterSeries),
            'approximate_filter': ConjureFieldDefinition('approximateFilter', scout_compute_api_NumericApproximateFilterSeries),
            'select1d_array_index': ConjureFieldDefinition('select1dArrayIndex', scout_compute_api_SelectIndexFrom1dNumericArraySeries),
            'select_newest_points': ConjureFieldDefinition('selectNewestPoints', scout_compute_api_SelectNewestPointsSeries),
            'aggregate_under_ranges': ConjureFieldDefinition('aggregateUnderRanges', scout_compute_api_AggregateUnderRangesSeries),
            'filter_by_expression': ConjureFieldDefinition('filterByExpression', scout_compute_api_FilterByExpressionSeries),
            'enum_to_numeric': ConjureFieldDefinition('enumToNumeric', scout_compute_api_EnumToNumericSeries),
            'refprop': ConjureFieldDefinition('refprop', scout_compute_api_RefpropSeries),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_api_ExtractNumericFromStructSeries)
        }

    def __init__(
            self,
            aggregate: Optional["scout_compute_api_AggregateNumericSeries"] = None,
            arithmetic: Optional["scout_compute_api_ArithmeticSeries"] = None,
            bit_operation: Optional["scout_compute_api_BitOperationSeries"] = None,
            count_duplicate: Optional["scout_compute_api_EnumCountDuplicateSeries"] = None,
            cumulative_sum: Optional["scout_compute_api_CumulativeSumSeries"] = None,
            derivative: Optional["scout_compute_api_DerivativeSeries"] = None,
            integral: Optional["scout_compute_api_IntegralSeries"] = None,
            max: Optional["scout_compute_api_MaxSeries"] = None,
            mean: Optional["scout_compute_api_MeanSeries"] = None,
            min: Optional["scout_compute_api_MinSeries"] = None,
            offset: Optional["scout_compute_api_OffsetSeries"] = None,
            product: Optional["scout_compute_api_ProductSeries"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            resample: Optional["scout_compute_api_NumericResampleSeries"] = None,
            rolling_operation: Optional["scout_compute_api_RollingOperationSeries"] = None,
            signal_filter: Optional["scout_compute_api_SignalFilterSeries"] = None,
            sum: Optional["scout_compute_api_SumSeries"] = None,
            scale: Optional["scout_compute_api_ScaleSeries"] = None,
            time_difference: Optional["scout_compute_api_TimeDifferenceSeries"] = None,
            absolute_timestamp: Optional["scout_compute_api_AbsoluteTimestampSeries"] = None,
            time_range_filter: Optional["scout_compute_api_NumericTimeRangeFilterSeries"] = None,
            time_shift: Optional["scout_compute_api_NumericTimeShiftSeries"] = None,
            unary_arithmetic: Optional["scout_compute_api_UnaryArithmeticSeries"] = None,
            binary_arithmetic: Optional["scout_compute_api_BinaryArithmeticSeries"] = None,
            union: Optional["scout_compute_api_NumericUnionSeries"] = None,
            unit_conversion: Optional["scout_compute_api_UnitConversionSeries"] = None,
            value_difference: Optional["scout_compute_api_ValueDifferenceSeries"] = None,
            filter_transformation: Optional["scout_compute_api_NumericFilterTransformationSeries"] = None,
            threshold_filter: Optional["scout_compute_api_NumericThresholdFilterSeries"] = None,
            approximate_filter: Optional["scout_compute_api_NumericApproximateFilterSeries"] = None,
            select1d_array_index: Optional["scout_compute_api_SelectIndexFrom1dNumericArraySeries"] = None,
            select_newest_points: Optional["scout_compute_api_SelectNewestPointsSeries"] = None,
            aggregate_under_ranges: Optional["scout_compute_api_AggregateUnderRangesSeries"] = None,
            filter_by_expression: Optional["scout_compute_api_FilterByExpressionSeries"] = None,
            enum_to_numeric: Optional["scout_compute_api_EnumToNumericSeries"] = None,
            refprop: Optional["scout_compute_api_RefpropSeries"] = None,
            extract_from_struct: Optional["scout_compute_api_ExtractNumericFromStructSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (aggregate is not None) + (arithmetic is not None) + (bit_operation is not None) + (count_duplicate is not None) + (cumulative_sum is not None) + (derivative is not None) + (integral is not None) + (max is not None) + (mean is not None) + (min is not None) + (offset is not None) + (product is not None) + (raw is not None) + (channel is not None) + (derived is not None) + (resample is not None) + (rolling_operation is not None) + (signal_filter is not None) + (sum is not None) + (scale is not None) + (time_difference is not None) + (absolute_timestamp is not None) + (time_range_filter is not None) + (time_shift is not None) + (unary_arithmetic is not None) + (binary_arithmetic is not None) + (union is not None) + (unit_conversion is not None) + (value_difference is not None) + (filter_transformation is not None) + (threshold_filter is not None) + (approximate_filter is not None) + (select1d_array_index is not None) + (select_newest_points is not None) + (aggregate_under_ranges is not None) + (filter_by_expression is not None) + (enum_to_numeric is not None) + (refprop is not None) + (extract_from_struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if count_duplicate is not None:
                self._count_duplicate = count_duplicate
                self._type = 'countDuplicate'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if integral is not None:
                self._integral = integral
                self._type = 'integral'
            if max is not None:
                self._max = max
                self._type = 'max'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if min is not None:
                self._min = min
                self._type = 'min'
            if offset is not None:
                self._offset = offset
                self._type = 'offset'
            if product is not None:
                self._product = product
                self._type = 'product'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if signal_filter is not None:
                self._signal_filter = signal_filter
                self._type = 'signalFilter'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'
            if scale is not None:
                self._scale = scale
                self._type = 'scale'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if absolute_timestamp is not None:
                self._absolute_timestamp = absolute_timestamp
                self._type = 'absoluteTimestamp'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if binary_arithmetic is not None:
                self._binary_arithmetic = binary_arithmetic
                self._type = 'binaryArithmetic'
            if union is not None:
                self._union = union
                self._type = 'union'
            if unit_conversion is not None:
                self._unit_conversion = unit_conversion
                self._type = 'unitConversion'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'
            if threshold_filter is not None:
                self._threshold_filter = threshold_filter
                self._type = 'thresholdFilter'
            if approximate_filter is not None:
                self._approximate_filter = approximate_filter
                self._type = 'approximateFilter'
            if select1d_array_index is not None:
                self._select1d_array_index = select1d_array_index
                self._type = 'select1dArrayIndex'
            if select_newest_points is not None:
                self._select_newest_points = select_newest_points
                self._type = 'selectNewestPoints'
            if aggregate_under_ranges is not None:
                self._aggregate_under_ranges = aggregate_under_ranges
                self._type = 'aggregateUnderRanges'
            if filter_by_expression is not None:
                self._filter_by_expression = filter_by_expression
                self._type = 'filterByExpression'
            if enum_to_numeric is not None:
                self._enum_to_numeric = enum_to_numeric
                self._type = 'enumToNumeric'
            if refprop is not None:
                self._refprop = refprop
                self._type = 'refprop'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'

        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'countDuplicate':
            if count_duplicate is None:
                raise ValueError('a union value must not be None')
            self._count_duplicate = count_duplicate
            self._type = 'countDuplicate'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'integral':
            if integral is None:
                raise ValueError('a union value must not be None')
            self._integral = integral
            self._type = 'integral'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'offset':
            if offset is None:
                raise ValueError('a union value must not be None')
            self._offset = offset
            self._type = 'offset'
        elif type_of_union == 'product':
            if product is None:
                raise ValueError('a union value must not be None')
            self._product = product
            self._type = 'product'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'signalFilter':
            if signal_filter is None:
                raise ValueError('a union value must not be None')
            self._signal_filter = signal_filter
            self._type = 'signalFilter'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'
        elif type_of_union == 'scale':
            if scale is None:
                raise ValueError('a union value must not be None')
            self._scale = scale
            self._type = 'scale'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'absoluteTimestamp':
            if absolute_timestamp is None:
                raise ValueError('a union value must not be None')
            self._absolute_timestamp = absolute_timestamp
            self._type = 'absoluteTimestamp'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'binaryArithmetic':
            if binary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._binary_arithmetic = binary_arithmetic
            self._type = 'binaryArithmetic'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'unitConversion':
            if unit_conversion is None:
                raise ValueError('a union value must not be None')
            self._unit_conversion = unit_conversion
            self._type = 'unitConversion'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'
        elif type_of_union == 'thresholdFilter':
            if threshold_filter is None:
                raise ValueError('a union value must not be None')
            self._threshold_filter = threshold_filter
            self._type = 'thresholdFilter'
        elif type_of_union == 'approximateFilter':
            if approximate_filter is None:
                raise ValueError('a union value must not be None')
            self._approximate_filter = approximate_filter
            self._type = 'approximateFilter'
        elif type_of_union == 'select1dArrayIndex':
            if select1d_array_index is None:
                raise ValueError('a union value must not be None')
            self._select1d_array_index = select1d_array_index
            self._type = 'select1dArrayIndex'
        elif type_of_union == 'selectNewestPoints':
            if select_newest_points is None:
                raise ValueError('a union value must not be None')
            self._select_newest_points = select_newest_points
            self._type = 'selectNewestPoints'
        elif type_of_union == 'aggregateUnderRanges':
            if aggregate_under_ranges is None:
                raise ValueError('a union value must not be None')
            self._aggregate_under_ranges = aggregate_under_ranges
            self._type = 'aggregateUnderRanges'
        elif type_of_union == 'filterByExpression':
            if filter_by_expression is None:
                raise ValueError('a union value must not be None')
            self._filter_by_expression = filter_by_expression
            self._type = 'filterByExpression'
        elif type_of_union == 'enumToNumeric':
            if enum_to_numeric is None:
                raise ValueError('a union value must not be None')
            self._enum_to_numeric = enum_to_numeric
            self._type = 'enumToNumeric'
        elif type_of_union == 'refprop':
            if refprop is None:
                raise ValueError('a union value must not be None')
            self._refprop = refprop
            self._type = 'refprop'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_api_AggregateNumericSeries"]:
        return self._aggregate

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_api_ArithmeticSeries"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_api_BitOperationSeries"]:
        return self._bit_operation

    @builtins.property
    def count_duplicate(self) -> Optional["scout_compute_api_EnumCountDuplicateSeries"]:
        return self._count_duplicate

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_api_CumulativeSumSeries"]:
        return self._cumulative_sum

    @builtins.property
    def derivative(self) -> Optional["scout_compute_api_DerivativeSeries"]:
        return self._derivative

    @builtins.property
    def integral(self) -> Optional["scout_compute_api_IntegralSeries"]:
        return self._integral

    @builtins.property
    def max(self) -> Optional["scout_compute_api_MaxSeries"]:
        return self._max

    @builtins.property
    def mean(self) -> Optional["scout_compute_api_MeanSeries"]:
        return self._mean

    @builtins.property
    def min(self) -> Optional["scout_compute_api_MinSeries"]:
        return self._min

    @builtins.property
    def offset(self) -> Optional["scout_compute_api_OffsetSeries"]:
        return self._offset

    @builtins.property
    def product(self) -> Optional["scout_compute_api_ProductSeries"]:
        return self._product

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def resample(self) -> Optional["scout_compute_api_NumericResampleSeries"]:
        return self._resample

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_api_RollingOperationSeries"]:
        return self._rolling_operation

    @builtins.property
    def signal_filter(self) -> Optional["scout_compute_api_SignalFilterSeries"]:
        return self._signal_filter

    @builtins.property
    def sum(self) -> Optional["scout_compute_api_SumSeries"]:
        return self._sum

    @builtins.property
    def scale(self) -> Optional["scout_compute_api_ScaleSeries"]:
        return self._scale

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_api_TimeDifferenceSeries"]:
        return self._time_difference

    @builtins.property
    def absolute_timestamp(self) -> Optional["scout_compute_api_AbsoluteTimestampSeries"]:
        return self._absolute_timestamp

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_NumericTimeRangeFilterSeries"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_NumericTimeShiftSeries"]:
        return self._time_shift

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_api_UnaryArithmeticSeries"]:
        return self._unary_arithmetic

    @builtins.property
    def binary_arithmetic(self) -> Optional["scout_compute_api_BinaryArithmeticSeries"]:
        return self._binary_arithmetic

    @builtins.property
    def union(self) -> Optional["scout_compute_api_NumericUnionSeries"]:
        return self._union

    @builtins.property
    def unit_conversion(self) -> Optional["scout_compute_api_UnitConversionSeries"]:
        return self._unit_conversion

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_api_ValueDifferenceSeries"]:
        return self._value_difference

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_api_NumericFilterTransformationSeries"]:
        return self._filter_transformation

    @builtins.property
    def threshold_filter(self) -> Optional["scout_compute_api_NumericThresholdFilterSeries"]:
        return self._threshold_filter

    @builtins.property
    def approximate_filter(self) -> Optional["scout_compute_api_NumericApproximateFilterSeries"]:
        return self._approximate_filter

    @builtins.property
    def select1d_array_index(self) -> Optional["scout_compute_api_SelectIndexFrom1dNumericArraySeries"]:
        return self._select1d_array_index

    @builtins.property
    def select_newest_points(self) -> Optional["scout_compute_api_SelectNewestPointsSeries"]:
        return self._select_newest_points

    @builtins.property
    def aggregate_under_ranges(self) -> Optional["scout_compute_api_AggregateUnderRangesSeries"]:
        return self._aggregate_under_ranges

    @builtins.property
    def filter_by_expression(self) -> Optional["scout_compute_api_FilterByExpressionSeries"]:
        return self._filter_by_expression

    @builtins.property
    def enum_to_numeric(self) -> Optional["scout_compute_api_EnumToNumericSeries"]:
        return self._enum_to_numeric

    @builtins.property
    def refprop(self) -> Optional["scout_compute_api_RefpropSeries"]:
        return self._refprop

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_api_ExtractNumericFromStructSeries"]:
        return self._extract_from_struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_NumericSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_NumericSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'countDuplicate' and self.count_duplicate is not None:
            return visitor._count_duplicate(self.count_duplicate)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'integral' and self.integral is not None:
            return visitor._integral(self.integral)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'offset' and self.offset is not None:
            return visitor._offset(self.offset)
        if self._type == 'product' and self.product is not None:
            return visitor._product(self.product)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'signalFilter' and self.signal_filter is not None:
            return visitor._signal_filter(self.signal_filter)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)
        if self._type == 'scale' and self.scale is not None:
            return visitor._scale(self.scale)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'absoluteTimestamp' and self.absolute_timestamp is not None:
            return visitor._absolute_timestamp(self.absolute_timestamp)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'binaryArithmetic' and self.binary_arithmetic is not None:
            return visitor._binary_arithmetic(self.binary_arithmetic)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'unitConversion' and self.unit_conversion is not None:
            return visitor._unit_conversion(self.unit_conversion)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)
        if self._type == 'thresholdFilter' and self.threshold_filter is not None:
            return visitor._threshold_filter(self.threshold_filter)
        if self._type == 'approximateFilter' and self.approximate_filter is not None:
            return visitor._approximate_filter(self.approximate_filter)
        if self._type == 'select1dArrayIndex' and self.select1d_array_index is not None:
            return visitor._select1d_array_index(self.select1d_array_index)
        if self._type == 'selectNewestPoints' and self.select_newest_points is not None:
            return visitor._select_newest_points(self.select_newest_points)
        if self._type == 'aggregateUnderRanges' and self.aggregate_under_ranges is not None:
            return visitor._aggregate_under_ranges(self.aggregate_under_ranges)
        if self._type == 'filterByExpression' and self.filter_by_expression is not None:
            return visitor._filter_by_expression(self.filter_by_expression)
        if self._type == 'enumToNumeric' and self.enum_to_numeric is not None:
            return visitor._enum_to_numeric(self.enum_to_numeric)
        if self._type == 'refprop' and self.refprop is not None:
            return visitor._refprop(self.refprop)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)


scout_compute_api_NumericSeries.__name__ = "NumericSeries"
scout_compute_api_NumericSeries.__qualname__ = "NumericSeries"
scout_compute_api_NumericSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericSeriesVisitor:

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_api_AggregateNumericSeries") -> Any:
        pass

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_api_ArithmeticSeries") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_api_BitOperationSeries") -> Any:
        pass

    @abstractmethod
    def _count_duplicate(self, count_duplicate: "scout_compute_api_EnumCountDuplicateSeries") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_api_CumulativeSumSeries") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_api_DerivativeSeries") -> Any:
        pass

    @abstractmethod
    def _integral(self, integral: "scout_compute_api_IntegralSeries") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_MaxSeries") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_compute_api_MeanSeries") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_MinSeries") -> Any:
        pass

    @abstractmethod
    def _offset(self, offset: "scout_compute_api_OffsetSeries") -> Any:
        pass

    @abstractmethod
    def _product(self, product: "scout_compute_api_ProductSeries") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_api_NumericResampleSeries") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_api_RollingOperationSeries") -> Any:
        pass

    @abstractmethod
    def _signal_filter(self, signal_filter: "scout_compute_api_SignalFilterSeries") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_api_SumSeries") -> Any:
        pass

    @abstractmethod
    def _scale(self, scale: "scout_compute_api_ScaleSeries") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_api_TimeDifferenceSeries") -> Any:
        pass

    @abstractmethod
    def _absolute_timestamp(self, absolute_timestamp: "scout_compute_api_AbsoluteTimestampSeries") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_NumericTimeRangeFilterSeries") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_NumericTimeShiftSeries") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_api_UnaryArithmeticSeries") -> Any:
        pass

    @abstractmethod
    def _binary_arithmetic(self, binary_arithmetic: "scout_compute_api_BinaryArithmeticSeries") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_NumericUnionSeries") -> Any:
        pass

    @abstractmethod
    def _unit_conversion(self, unit_conversion: "scout_compute_api_UnitConversionSeries") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_api_ValueDifferenceSeries") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_api_NumericFilterTransformationSeries") -> Any:
        pass

    @abstractmethod
    def _threshold_filter(self, threshold_filter: "scout_compute_api_NumericThresholdFilterSeries") -> Any:
        pass

    @abstractmethod
    def _approximate_filter(self, approximate_filter: "scout_compute_api_NumericApproximateFilterSeries") -> Any:
        pass

    @abstractmethod
    def _select1d_array_index(self, select1d_array_index: "scout_compute_api_SelectIndexFrom1dNumericArraySeries") -> Any:
        pass

    @abstractmethod
    def _select_newest_points(self, select_newest_points: "scout_compute_api_SelectNewestPointsSeries") -> Any:
        pass

    @abstractmethod
    def _aggregate_under_ranges(self, aggregate_under_ranges: "scout_compute_api_AggregateUnderRangesSeries") -> Any:
        pass

    @abstractmethod
    def _filter_by_expression(self, filter_by_expression: "scout_compute_api_FilterByExpressionSeries") -> Any:
        pass

    @abstractmethod
    def _enum_to_numeric(self, enum_to_numeric: "scout_compute_api_EnumToNumericSeries") -> Any:
        pass

    @abstractmethod
    def _refprop(self, refprop: "scout_compute_api_RefpropSeries") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_api_ExtractNumericFromStructSeries") -> Any:
        pass


scout_compute_api_NumericSeriesVisitor.__name__ = "NumericSeriesVisitor"
scout_compute_api_NumericSeriesVisitor.__qualname__ = "NumericSeriesVisitor"
scout_compute_api_NumericSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericThresholdFilterSeries(ConjureBeanType):
    """Outputs only the values of the numeric plot value that satisfy the threshold condition.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator)
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator']

    def __init__(self, input: "scout_compute_api_NumericSeries", operator: "scout_compute_api_ThresholdOperator", threshold: "scout_compute_api_DoubleConstant") -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DoubleConstant":
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator


scout_compute_api_NumericThresholdFilterSeries.__name__ = "NumericThresholdFilterSeries"
scout_compute_api_NumericThresholdFilterSeries.__qualname__ = "NumericThresholdFilterSeries"
scout_compute_api_NumericThresholdFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericTimeRangeFilterSeries(ConjureBeanType):
    """Filters the series to points within the specified time range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_NumericSeries", end_time: Optional["scout_compute_api_TimestampConstant"] = None, start_time: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Represents the start time (inclusive) of the time range.
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Represents the end time (inclusive) of the time range.
        """
        return self._end_time


scout_compute_api_NumericTimeRangeFilterSeries.__name__ = "NumericTimeRangeFilterSeries"
scout_compute_api_NumericTimeRangeFilterSeries.__qualname__ = "NumericTimeRangeFilterSeries"
scout_compute_api_NumericTimeRangeFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericTimeShiftSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", input: "scout_compute_api_NumericSeries") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_NumericTimeShiftSeries.__name__ = "NumericTimeShiftSeries"
scout_compute_api_NumericTimeShiftSeries.__qualname__ = "NumericTimeShiftSeries"
scout_compute_api_NumericTimeShiftSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericUnionOperation(ConjureEnumType):

    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    MEAN = 'MEAN'
    '''MEAN'''
    SUM = 'SUM'
    '''SUM'''
    COUNT = 'COUNT'
    '''COUNT'''
    STANDARD_DEVIATION = 'STANDARD_DEVIATION'
    '''STANDARD_DEVIATION'''
    ROOT_MEAN_SQUARE = 'ROOT_MEAN_SQUARE'
    '''ROOT_MEAN_SQUARE'''
    THROW = 'THROW'
    '''THROW'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_NumericUnionOperation.__name__ = "NumericUnionOperation"
scout_compute_api_NumericUnionOperation.__qualname__ = "NumericUnionOperation"
scout_compute_api_NumericUnionOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_NumericUnionSeries(ConjureBeanType):
    """Combines multiple numeric series together and outputs a single series. If the same timestamp is duplicated in
multiple input series, the output series will contain a single point with this timestamp. The strategy to
merge input values with the same timestamp together is specified in the operation field.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_NumericSeries]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_NumericSeries"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_NumericSeries"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        """The strategy to merge points with duplicate timestamps.
        """
        return self._operation


scout_compute_api_NumericUnionSeries.__name__ = "NumericUnionSeries"
scout_compute_api_NumericUnionSeries.__qualname__ = "NumericUnionSeries"
scout_compute_api_NumericUnionSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Nyquist(ConjureBeanType):
    """Returns a complex-valued frequency response, H(f), of the input series to the output series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'output': ConjureFieldDefinition('output', scout_compute_api_NumericSeries),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions])
        }

    __slots__: List[str] = ['_input', '_output', '_stft_options']

    def __init__(self, input: "scout_compute_api_NumericSeries", output: "scout_compute_api_NumericSeries", stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._input = input
        self._output = output
        self._stft_options = stft_options

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def output(self) -> "scout_compute_api_NumericSeries":
        return self._output

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options


scout_compute_api_Nyquist.__name__ = "Nyquist"
scout_compute_api_Nyquist.__qualname__ = "Nyquist"
scout_compute_api_Nyquist.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OffsetSeries(ConjureBeanType):
    """For every timestamp specified in the input series, offset it by a constant factor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'scalar': ConjureFieldDefinition('scalar', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_input', '_scalar']

    def __init__(self, input: "scout_compute_api_NumericSeries", scalar: "scout_compute_api_DoubleConstant") -> None:
        self._input = input
        self._scalar = scalar

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def scalar(self) -> "scout_compute_api_DoubleConstant":
        """The constant to add to each point
        """
        return self._scalar


scout_compute_api_OffsetSeries.__name__ = "OffsetSeries"
scout_compute_api_OffsetSeries.__qualname__ = "OffsetSeries"
scout_compute_api_OffsetSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OnChangeRanges(ConjureBeanType):
    """Produces a list of ranges for each point that has a different value to the previous point.
A range will have identical start and end times.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Series)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_Series") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_Series":
        return self._input


scout_compute_api_OnChangeRanges.__name__ = "OnChangeRanges"
scout_compute_api_OnChangeRanges.__qualname__ = "OnChangeRanges"
scout_compute_api_OnChangeRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OutputFormat(ConjureEnumType):

    ARROW_V3 = 'ARROW_V3'
    '''ARROW_V3'''
    LEGACY = 'LEGACY'
    '''LEGACY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_OutputFormat.__name__ = "OutputFormat"
scout_compute_api_OutputFormat.__qualname__ = "OutputFormat"
scout_compute_api_OutputFormat.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OutputFrequencyType(ConjureEnumType):

    LINEAR = 'LINEAR'
    '''LINEAR'''
    ANGULAR = 'ANGULAR'
    '''ANGULAR'''
    NORMALIZED_LINEAR = 'NORMALIZED_LINEAR'
    '''NORMALIZED_LINEAR'''
    NORMALIZED_ANGULAR = 'NORMALIZED_ANGULAR'
    '''NORMALIZED_ANGULAR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_OutputFrequencyType.__name__ = "OutputFrequencyType"
scout_compute_api_OutputFrequencyType.__qualname__ = "OutputFrequencyType"
scout_compute_api_OutputFrequencyType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OutputPhaseUnit(ConjureEnumType):

    RADIANS = 'RADIANS'
    '''RADIANS'''
    DEGREES = 'DEGREES'
    '''DEGREES'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_OutputPhaseUnit.__name__ = "OutputPhaseUnit"
scout_compute_api_OutputPhaseUnit.__qualname__ = "OutputPhaseUnit"
scout_compute_api_OutputPhaseUnit.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OutputRangeStart(ConjureUnionType):
    _first_point_matching_condition: Optional["scout_compute_api_FirstPointMatchingCondition"] = None
    _after_persistence_window: Optional["scout_compute_api_AfterPersistenceWindow"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point_matching_condition': ConjureFieldDefinition('firstPointMatchingCondition', scout_compute_api_FirstPointMatchingCondition),
            'after_persistence_window': ConjureFieldDefinition('afterPersistenceWindow', scout_compute_api_AfterPersistenceWindow)
        }

    def __init__(
            self,
            first_point_matching_condition: Optional["scout_compute_api_FirstPointMatchingCondition"] = None,
            after_persistence_window: Optional["scout_compute_api_AfterPersistenceWindow"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point_matching_condition is not None) + (after_persistence_window is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point_matching_condition is not None:
                self._first_point_matching_condition = first_point_matching_condition
                self._type = 'firstPointMatchingCondition'
            if after_persistence_window is not None:
                self._after_persistence_window = after_persistence_window
                self._type = 'afterPersistenceWindow'

        elif type_of_union == 'firstPointMatchingCondition':
            if first_point_matching_condition is None:
                raise ValueError('a union value must not be None')
            self._first_point_matching_condition = first_point_matching_condition
            self._type = 'firstPointMatchingCondition'
        elif type_of_union == 'afterPersistenceWindow':
            if after_persistence_window is None:
                raise ValueError('a union value must not be None')
            self._after_persistence_window = after_persistence_window
            self._type = 'afterPersistenceWindow'

    @builtins.property
    def first_point_matching_condition(self) -> Optional["scout_compute_api_FirstPointMatchingCondition"]:
        """The first point in the output range will be the first point where the condition evaluates to true.
        """
        return self._first_point_matching_condition

    @builtins.property
    def after_persistence_window(self) -> Optional["scout_compute_api_AfterPersistenceWindow"]:
        """The output range will contain points where the condition has been true
for at least the min duration and min points.
        """
        return self._after_persistence_window

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_OutputRangeStartVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_OutputRangeStartVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPointMatchingCondition' and self.first_point_matching_condition is not None:
            return visitor._first_point_matching_condition(self.first_point_matching_condition)
        if self._type == 'afterPersistenceWindow' and self.after_persistence_window is not None:
            return visitor._after_persistence_window(self.after_persistence_window)


scout_compute_api_OutputRangeStart.__name__ = "OutputRangeStart"
scout_compute_api_OutputRangeStart.__qualname__ = "OutputRangeStart"
scout_compute_api_OutputRangeStart.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_OutputRangeStartVisitor:

    @abstractmethod
    def _first_point_matching_condition(self, first_point_matching_condition: "scout_compute_api_FirstPointMatchingCondition") -> Any:
        pass

    @abstractmethod
    def _after_persistence_window(self, after_persistence_window: "scout_compute_api_AfterPersistenceWindow") -> Any:
        pass


scout_compute_api_OutputRangeStartVisitor.__name__ = "OutputRangeStartVisitor"
scout_compute_api_OutputRangeStartVisitor.__qualname__ = "OutputRangeStartVisitor"
scout_compute_api_OutputRangeStartVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PaddedRanges(ConjureBeanType):
    """Expands ranges durations by adding temporal padding to the start, end, or both sides. Note that if the input
ranges contain a RangeValue, it will be dropped.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangeSeries),
            'padding': ConjureFieldDefinition('padding', scout_compute_api_DurationConstant),
            'padding_configuration': ConjureFieldDefinition('paddingConfiguration', OptionalTypeWrapper[scout_compute_api_RangePaddingConfiguration])
        }

    __slots__: List[str] = ['_input', '_padding', '_padding_configuration']

    def __init__(self, input: "scout_compute_api_RangeSeries", padding: "scout_compute_api_DurationConstant", padding_configuration: Optional["scout_compute_api_RangePaddingConfiguration"] = None) -> None:
        self._input = input
        self._padding = padding
        self._padding_configuration = padding_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_RangeSeries":
        return self._input

    @builtins.property
    def padding(self) -> "scout_compute_api_DurationConstant":
        return self._padding

    @builtins.property
    def padding_configuration(self) -> Optional["scout_compute_api_RangePaddingConfiguration"]:
        """Configuration for how to apply padding to the ranges. Defaults to PAD_START_AND_END if not specified.
        """
        return self._padding_configuration


scout_compute_api_PaddedRanges.__name__ = "PaddedRanges"
scout_compute_api_PaddedRanges.__qualname__ = "PaddedRanges"
scout_compute_api_PaddedRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PageInfo(ConjureBeanType):
    """Specification of a page for a series. Returns raw undecimated points beginning nearest to the given page
token, advancing pageSize points in the time direction specified by the sign of the page size.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'page_token': ConjureFieldDefinition('pageToken', OptionalTypeWrapper[scout_compute_api_PageToken]),
            'page_size': ConjureFieldDefinition('pageSize', int)
        }

    __slots__: List[str] = ['_page_token', '_page_size']

    def __init__(self, page_size: int, page_token: Optional["scout_compute_api_PageToken"] = None) -> None:
        self._page_token = page_token
        self._page_size = page_size

    @builtins.property
    def page_token(self) -> Optional["scout_compute_api_PageToken"]:
        return self._page_token

    @builtins.property
    def page_size(self) -> int:
        return self._page_size


scout_compute_api_PageInfo.__name__ = "PageInfo"
scout_compute_api_PageInfo.__qualname__ = "PageInfo"
scout_compute_api_PageInfo.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PageStrategy(ConjureUnionType):
    _page_info: Optional["scout_compute_api_PageInfo"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'page_info': ConjureFieldDefinition('pageInfo', scout_compute_api_PageInfo)
        }

    def __init__(
            self,
            page_info: Optional["scout_compute_api_PageInfo"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (page_info is not None) != 1:
                raise ValueError('a union must contain a single member')

            if page_info is not None:
                self._page_info = page_info
                self._type = 'pageInfo'

        elif type_of_union == 'pageInfo':
            if page_info is None:
                raise ValueError('a union value must not be None')
            self._page_info = page_info
            self._type = 'pageInfo'

    @builtins.property
    def page_info(self) -> Optional["scout_compute_api_PageInfo"]:
        return self._page_info

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_PageStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_PageStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pageInfo' and self.page_info is not None:
            return visitor._page_info(self.page_info)


scout_compute_api_PageStrategy.__name__ = "PageStrategy"
scout_compute_api_PageStrategy.__qualname__ = "PageStrategy"
scout_compute_api_PageStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PageStrategyVisitor:

    @abstractmethod
    def _page_info(self, page_info: "scout_compute_api_PageInfo") -> Any:
        pass


scout_compute_api_PageStrategyVisitor.__name__ = "PageStrategyVisitor"
scout_compute_api_PageStrategyVisitor.__qualname__ = "PageStrategyVisitor"
scout_compute_api_PageStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PageToken(ConjureUnionType):
    _timestamp_and_id: Optional["scout_compute_api_TimestampAndId"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_and_id': ConjureFieldDefinition('timestampAndId', scout_compute_api_TimestampAndId)
        }

    def __init__(
            self,
            timestamp_and_id: Optional["scout_compute_api_TimestampAndId"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timestamp_and_id is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timestamp_and_id is not None:
                self._timestamp_and_id = timestamp_and_id
                self._type = 'timestampAndId'

        elif type_of_union == 'timestampAndId':
            if timestamp_and_id is None:
                raise ValueError('a union value must not be None')
            self._timestamp_and_id = timestamp_and_id
            self._type = 'timestampAndId'

    @builtins.property
    def timestamp_and_id(self) -> Optional["scout_compute_api_TimestampAndId"]:
        return self._timestamp_and_id

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_PageTokenVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_PageTokenVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timestampAndId' and self.timestamp_and_id is not None:
            return visitor._timestamp_and_id(self.timestamp_and_id)


scout_compute_api_PageToken.__name__ = "PageToken"
scout_compute_api_PageToken.__qualname__ = "PageToken"
scout_compute_api_PageToken.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PageTokenVisitor:

    @abstractmethod
    def _timestamp_and_id(self, timestamp_and_id: "scout_compute_api_TimestampAndId") -> Any:
        pass


scout_compute_api_PageTokenVisitor.__name__ = "PageTokenVisitor"
scout_compute_api_PageTokenVisitor.__qualname__ = "PageTokenVisitor"
scout_compute_api_PageTokenVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PagedLogPlot(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', List[scout_compute_api_LogValue]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[scout_compute_api_PageToken])
        }

    __slots__: List[str] = ['_timestamps', '_values', '_next_page_token']

    def __init__(self, timestamps: List["api_Timestamp"], values: List["scout_compute_api_LogValue"], next_page_token: Optional["scout_compute_api_PageToken"] = None) -> None:
        self._timestamps = timestamps
        self._values = values
        self._next_page_token = next_page_token

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        return self._timestamps

    @builtins.property
    def values(self) -> List["scout_compute_api_LogValue"]:
        return self._values

    @builtins.property
    def next_page_token(self) -> Optional["scout_compute_api_PageToken"]:
        """The token to retrieve the next page of logs in the direction originally requested (exclusive - not
included in these results). May be empty if there are no further logs in the requested time range in the
direction originally requested.
        """
        return self._next_page_token


scout_compute_api_PagedLogPlot.__name__ = "PagedLogPlot"
scout_compute_api_PagedLogPlot.__qualname__ = "PagedLogPlot"
scout_compute_api_PagedLogPlot.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ParameterInput(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'variables': ConjureFieldDefinition('variables', Dict[scout_compute_api_VariableName, scout_compute_api_VariableValue]),
            'time_range': ConjureFieldDefinition('timeRange', OptionalTypeWrapper[scout_compute_api_Range])
        }

    __slots__: List[str] = ['_variables', '_time_range']

    def __init__(self, variables: Dict[str, "scout_compute_api_VariableValue"], time_range: Optional["scout_compute_api_Range"] = None) -> None:
        self._variables = variables
        self._time_range = time_range

    @builtins.property
    def variables(self) -> Dict[str, "scout_compute_api_VariableValue"]:
        return self._variables

    @builtins.property
    def time_range(self) -> Optional["scout_compute_api_Range"]:
        """Overrides the start and end time of the compute request. If either the start or end are not present, we
default back to the start/end specified in the request.
        """
        return self._time_range


scout_compute_api_ParameterInput.__name__ = "ParameterInput"
scout_compute_api_ParameterInput.__qualname__ = "ParameterInput"
scout_compute_api_ParameterInput.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'node': ConjureFieldDefinition('node', scout_compute_api_ComputableNode),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context),
            'parameterized_context': ConjureFieldDefinition('parameterizedContext', scout_compute_api_ParameterizedContext)
        }

    __slots__: List[str] = ['_node', '_start', '_end', '_context', '_parameterized_context']

    def __init__(self, context: "scout_compute_api_Context", end: "api_Timestamp", node: "scout_compute_api_ComputableNode", parameterized_context: "scout_compute_api_ParameterizedContext", start: "api_Timestamp") -> None:
        self._node = node
        self._start = start
        self._end = end
        self._context = context
        self._parameterized_context = parameterized_context

    @builtins.property
    def node(self) -> "scout_compute_api_ComputableNode":
        return self._node

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context

    @builtins.property
    def parameterized_context(self) -> "scout_compute_api_ParameterizedContext":
        """Specifies how certain variables should be parameterized. If a variable name appears in both the context
and the parameterized context, it will be treated as parameterized.
        """
        return self._parameterized_context


scout_compute_api_ParameterizedComputeNodeRequest.__name__ = "ParameterizedComputeNodeRequest"
scout_compute_api_ParameterizedComputeNodeRequest.__qualname__ = "ParameterizedComputeNodeRequest"
scout_compute_api_ParameterizedComputeNodeRequest.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ParameterizedComputeNodeResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_compute_api_ComputeNodeResult])
        }

    __slots__: List[str] = ['_results']

    def __init__(self, results: List["scout_compute_api_ComputeNodeResult"]) -> None:
        self._results = results

    @builtins.property
    def results(self) -> List["scout_compute_api_ComputeNodeResult"]:
        return self._results


scout_compute_api_ParameterizedComputeNodeResponse.__name__ = "ParameterizedComputeNodeResponse"
scout_compute_api_ParameterizedComputeNodeResponse.__qualname__ = "ParameterizedComputeNodeResponse"
scout_compute_api_ParameterizedComputeNodeResponse.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ParameterizedContext(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'parameter_inputs': ConjureFieldDefinition('parameterInputs', List[scout_compute_api_ParameterInput])
        }

    __slots__: List[str] = ['_parameter_inputs']

    def __init__(self, parameter_inputs: List["scout_compute_api_ParameterInput"]) -> None:
        self._parameter_inputs = parameter_inputs

    @builtins.property
    def parameter_inputs(self) -> List["scout_compute_api_ParameterInput"]:
        """Each parameter input provides a satisfying set of values for the parameterized compute node.
        """
        return self._parameter_inputs


scout_compute_api_ParameterizedContext.__name__ = "ParameterizedContext"
scout_compute_api_ParameterizedContext.__qualname__ = "ParameterizedContext"
scout_compute_api_ParameterizedContext.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PeakRanges(ConjureBeanType):
    """Produces a list of ranges for each point that is greater than its neighbors.
Peaks at edges are discarded, and continuous, multivalue, flat peaks will return all values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'returns_peaks': ConjureFieldDefinition('returnsPeaks', OptionalTypeWrapper[bool]),
            'return_type': ConjureFieldDefinition('returnType', OptionalTypeWrapper[scout_compute_api_PeakType]),
            'minimum_prominence': ConjureFieldDefinition('minimumProminence', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_input', '_returns_peaks', '_return_type', '_minimum_prominence']

    def __init__(self, input: "scout_compute_api_NumericSeries", minimum_prominence: Optional["scout_compute_api_DoubleConstant"] = None, return_type: Optional["scout_compute_api_PeakType"] = None, returns_peaks: Optional[bool] = None) -> None:
        self._input = input
        self._returns_peaks = returns_peaks
        self._return_type = return_type
        self._minimum_prominence = minimum_prominence

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def returns_peaks(self) -> Optional[bool]:
        """True if returning peaks, else troughs.
        """
        return self._returns_peaks

    @builtins.property
    def return_type(self) -> Optional["scout_compute_api_PeakType"]:
        """Optional for backcompatibility.
        """
        return self._return_type

    @builtins.property
    def minimum_prominence(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """The minimum topographic prominence for an extrema to be returned.
Prominence is the minimum vertical distance needed to travel from an extrema to one of greater magnitude.
        """
        return self._minimum_prominence


scout_compute_api_PeakRanges.__name__ = "PeakRanges"
scout_compute_api_PeakRanges.__qualname__ = "PeakRanges"
scout_compute_api_PeakRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PeakType(ConjureEnumType):

    PEAK = 'PEAK'
    '''PEAK'''
    TROUGH = 'TROUGH'
    '''TROUGH'''
    BOTH = 'BOTH'
    '''BOTH'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_PeakType.__name__ = "PeakType"
scout_compute_api_PeakType.__qualname__ = "PeakType"
scout_compute_api_PeakType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PercentageThreshold(ConjureBeanType):
    """Threshold defined as the percentage of a given value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', scout_compute_api_DoubleConstant)
        }

    __slots__: List[str] = ['_value']

    def __init__(self, value: "scout_compute_api_DoubleConstant") -> None:
        self._value = value

    @builtins.property
    def value(self) -> "scout_compute_api_DoubleConstant":
        return self._value


scout_compute_api_PercentageThreshold.__name__ = "PercentageThreshold"
scout_compute_api_PercentageThreshold.__qualname__ = "PercentageThreshold"
scout_compute_api_PercentageThreshold.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Periodogram(ConjureBeanType):
    """Returns the spectral density estimate (i.e. PSD) of the input series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'method': ConjureFieldDefinition('method', scout_compute_api_PeriodogramMethod)
        }

    __slots__: List[str] = ['_input', '_method']

    def __init__(self, input: "scout_compute_api_NumericSeries", method: "scout_compute_api_PeriodogramMethod") -> None:
        self._input = input
        self._method = method

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def method(self) -> "scout_compute_api_PeriodogramMethod":
        return self._method


scout_compute_api_Periodogram.__name__ = "Periodogram"
scout_compute_api_Periodogram.__qualname__ = "Periodogram"
scout_compute_api_Periodogram.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PeriodogramMethod(ConjureEnumType):

    WELCH_BLACKMAN = 'WELCH_BLACKMAN'
    '''WELCH_BLACKMAN'''
    WELCH_HANN = 'WELCH_HANN'
    '''WELCH_HANN'''
    WELCH_HAMMING = 'WELCH_HAMMING'
    '''WELCH_HAMMING'''
    WELCH_RECT = 'WELCH_RECT'
    '''WELCH_RECT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_PeriodogramMethod.__name__ = "PeriodogramMethod"
scout_compute_api_PeriodogramMethod.__qualname__ = "PeriodogramMethod"
scout_compute_api_PeriodogramMethod.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PersistenceWindowConfiguration(ConjureBeanType):
    """Configures how long a condition has to be true for to output a time range, and what to use as the
start of the output range. For a point to be included in the output time range, both the minPoints and
minDuration conditions must be satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[scout_compute_api_IntegerConstant]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_compute_api_DurationConstant]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_compute_api_DurationConstant"] = None, min_points: Optional["scout_compute_api_IntegerConstant"] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional["scout_compute_api_IntegerConstant"]:
        """The minimum number of points for which this condition be must satisfied to include the time range in the
output. Must be non-negative. If not present, will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_compute_api_DurationConstant"]:
        """The minimum number of points for which this condition must be satisfied to include the time range in the
output. Must be non-negative. If not present, will default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        """Which point to use as the start of the output range. Defaults to firstPointMatchingCondition if not specified.
        """
        return self._output_range_start


scout_compute_api_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_api_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_api_PersistenceWindowConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PinnedModuleVersionReference(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'version': ConjureFieldDefinition('version', scout_compute_api_StringConstant)
        }

    __slots__: List[str] = ['_version']

    def __init__(self, version: "scout_compute_api_StringConstant") -> None:
        self._version = version

    @builtins.property
    def version(self) -> "scout_compute_api_StringConstant":
        return self._version


scout_compute_api_PinnedModuleVersionReference.__name__ = "PinnedModuleVersionReference"
scout_compute_api_PinnedModuleVersionReference.__qualname__ = "PinnedModuleVersionReference"
scout_compute_api_PinnedModuleVersionReference.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Point3d(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', float),
            'y': ConjureFieldDefinition('y', float),
            'z': ConjureFieldDefinition('z', float),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_x', '_y', '_z', '_timestamp']

    def __init__(self, timestamp: "api_Timestamp", x: float, y: float, z: float) -> None:
        self._x = x
        self._y = y
        self._z = z
        self._timestamp = timestamp

    @builtins.property
    def x(self) -> float:
        return self._x

    @builtins.property
    def y(self) -> float:
        return self._y

    @builtins.property
    def z(self) -> float:
        return self._z

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp


scout_compute_api_Point3d.__name__ = "Point3d"
scout_compute_api_Point3d.__qualname__ = "Point3d"
scout_compute_api_Point3d.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PolynomialCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'degree': ConjureFieldDefinition('degree', scout_compute_api_IntegerConstant),
            'intercept': ConjureFieldDefinition('intercept', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_degree', '_intercept']

    def __init__(self, degree: "scout_compute_api_IntegerConstant", intercept: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._degree = degree
        self._intercept = intercept

    @builtins.property
    def degree(self) -> "scout_compute_api_IntegerConstant":
        """The highest allowable degree of the fit polynomial.
        """
        return self._degree

    @builtins.property
    def intercept(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """The y-value at the point x (or t) = 0. If omitted, the y-intercept will also be fit to the data.
        """
        return self._intercept


scout_compute_api_PolynomialCurve.__name__ = "PolynomialCurve"
scout_compute_api_PolynomialCurve.__qualname__ = "PolynomialCurve"
scout_compute_api_PolynomialCurve.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PolynomialResultDetails(ConjureBeanType):
    """y = sum( a_i * x^i ) for i in 0...len(a)
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'a': ConjureFieldDefinition('a', List[float])
        }

    __slots__: List[str] = ['_a']

    def __init__(self, a: List[float]) -> None:
        self._a = a

    @builtins.property
    def a(self) -> List[float]:
        return self._a


scout_compute_api_PolynomialResultDetails.__name__ = "PolynomialResultDetails"
scout_compute_api_PolynomialResultDetails.__qualname__ = "PolynomialResultDetails"
scout_compute_api_PolynomialResultDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PowerCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_PowerCurve.__name__ = "PowerCurve"
scout_compute_api_PowerCurve.__qualname__ = "PowerCurve"
scout_compute_api_PowerCurve.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_PowerResultDetails(ConjureBeanType):
    """y = a * x^b
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'a': ConjureFieldDefinition('a', float),
            'b': ConjureFieldDefinition('b', float)
        }

    __slots__: List[str] = ['_a', '_b']

    def __init__(self, a: float, b: float) -> None:
        self._a = a
        self._b = b

    @builtins.property
    def a(self) -> float:
        return self._a

    @builtins.property
    def b(self) -> float:
        return self._b


scout_compute_api_PowerResultDetails.__name__ = "PowerResultDetails"
scout_compute_api_PowerResultDetails.__qualname__ = "PowerResultDetails"
scout_compute_api_PowerResultDetails.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ProductSeries(ConjureBeanType):
    """For every timestamp specified in the input series, outputs a value that is the product for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeries]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_ProductSeries.__name__ = "ProductSeries"
scout_compute_api_ProductSeries.__qualname__ = "ProductSeries"
scout_compute_api_ProductSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Psd(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType])
        }

    __slots__: List[str] = ['_input', '_stft_options', '_magnitude_scaling', '_output_frequency_type']

    def __init__(self, input: "scout_compute_api_NumericSeries", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._input = input
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        """The scaling to apply to the output magnitude. Defaults to MAGNITUDE_DB_10 if not specified.
        """
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        """The type of the output frequency. Defaults to LINEAR if not specified. Changing the output frequency unit
may also rescale the magnitude of the output in order to ensure the density of the output is consistent.
        """
        return self._output_frequency_type


scout_compute_api_Psd.__name__ = "Psd"
scout_compute_api_Psd.__qualname__ = "Psd"
scout_compute_api_Psd.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Range(ConjureBeanType):
    """The end represents the first timestamp that does not belong to the range. If absent, there is no known
end to the range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[api_Timestamp]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[api_Timestamp]),
            'value': ConjureFieldDefinition('value', OptionalTypeWrapper[scout_compute_api_RangeValue])
        }

    __slots__: List[str] = ['_start', '_end', '_value']

    def __init__(self, end: Optional["api_Timestamp"] = None, start: Optional["api_Timestamp"] = None, value: Optional["scout_compute_api_RangeValue"] = None) -> None:
        self._start = start
        self._end = end
        self._value = value

    @builtins.property
    def start(self) -> Optional["api_Timestamp"]:
        return self._start

    @builtins.property
    def end(self) -> Optional["api_Timestamp"]:
        return self._end

    @builtins.property
    def value(self) -> Optional["scout_compute_api_RangeValue"]:
        return self._value


scout_compute_api_Range.__name__ = "Range"
scout_compute_api_Range.__qualname__ = "Range"
scout_compute_api_Range.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeAggregation(ConjureBeanType):
    """An aggregation value representing combined aggregation metrics for data over a range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'average': ConjureFieldDefinition('average', float),
            'min': ConjureFieldDefinition('min', float),
            'max': ConjureFieldDefinition('max', float),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', float),
            'count': ConjureFieldDefinition('count', float),
            'sum': ConjureFieldDefinition('sum', float),
            'root_mean_square': ConjureFieldDefinition('rootMeanSquare', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_average', '_min', '_max', '_standard_deviation', '_count', '_sum', '_root_mean_square']

    def __init__(self, average: float, count: float, max: float, min: float, standard_deviation: float, sum: float, root_mean_square: Optional[float] = None) -> None:
        self._average = average
        self._min = min
        self._max = max
        self._standard_deviation = standard_deviation
        self._count = count
        self._sum = sum
        self._root_mean_square = root_mean_square

    @builtins.property
    def average(self) -> float:
        return self._average

    @builtins.property
    def min(self) -> float:
        return self._min

    @builtins.property
    def max(self) -> float:
        return self._max

    @builtins.property
    def standard_deviation(self) -> float:
        return self._standard_deviation

    @builtins.property
    def count(self) -> float:
        return self._count

    @builtins.property
    def sum(self) -> float:
        return self._sum

    @builtins.property
    def root_mean_square(self) -> Optional[float]:
        return self._root_mean_square


scout_compute_api_RangeAggregation.__name__ = "RangeAggregation"
scout_compute_api_RangeAggregation.__qualname__ = "RangeAggregation"
scout_compute_api_RangeAggregation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeAggregationOperation(ConjureUnionType):
    _sum: Optional["scout_compute_api_Summation"] = None
    _root_mean_square: Optional["scout_compute_api_RootMeanSquare"] = None
    _average: Optional["scout_compute_api_Average"] = None
    _min: Optional["scout_compute_api_Minimum"] = None
    _max: Optional["scout_compute_api_Maximum"] = None
    _standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None
    _count: Optional["scout_compute_api_Count"] = None
    _all: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sum': ConjureFieldDefinition('sum', scout_compute_api_Summation),
            'root_mean_square': ConjureFieldDefinition('rootMeanSquare', scout_compute_api_RootMeanSquare),
            'average': ConjureFieldDefinition('average', scout_compute_api_Average),
            'min': ConjureFieldDefinition('min', scout_compute_api_Minimum),
            'max': ConjureFieldDefinition('max', scout_compute_api_Maximum),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_compute_api_StandardDeviation),
            'count': ConjureFieldDefinition('count', scout_compute_api_Count),
            'all': ConjureFieldDefinition('all', api_Empty)
        }

    def __init__(
            self,
            sum: Optional["scout_compute_api_Summation"] = None,
            root_mean_square: Optional["scout_compute_api_RootMeanSquare"] = None,
            average: Optional["scout_compute_api_Average"] = None,
            min: Optional["scout_compute_api_Minimum"] = None,
            max: Optional["scout_compute_api_Maximum"] = None,
            standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None,
            count: Optional["scout_compute_api_Count"] = None,
            all: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (sum is not None) + (root_mean_square is not None) + (average is not None) + (min is not None) + (max is not None) + (standard_deviation is not None) + (count is not None) + (all is not None) != 1:
                raise ValueError('a union must contain a single member')

            if sum is not None:
                self._sum = sum
                self._type = 'sum'
            if root_mean_square is not None:
                self._root_mean_square = root_mean_square
                self._type = 'rootMeanSquare'
            if average is not None:
                self._average = average
                self._type = 'average'
            if min is not None:
                self._min = min
                self._type = 'min'
            if max is not None:
                self._max = max
                self._type = 'max'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'
            if count is not None:
                self._count = count
                self._type = 'count'
            if all is not None:
                self._all = all
                self._type = 'all'

        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'
        elif type_of_union == 'rootMeanSquare':
            if root_mean_square is None:
                raise ValueError('a union value must not be None')
            self._root_mean_square = root_mean_square
            self._type = 'rootMeanSquare'
        elif type_of_union == 'average':
            if average is None:
                raise ValueError('a union value must not be None')
            self._average = average
            self._type = 'average'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'
        elif type_of_union == 'count':
            if count is None:
                raise ValueError('a union value must not be None')
            self._count = count
            self._type = 'count'
        elif type_of_union == 'all':
            if all is None:
                raise ValueError('a union value must not be None')
            self._all = all
            self._type = 'all'

    @builtins.property
    def sum(self) -> Optional["scout_compute_api_Summation"]:
        return self._sum

    @builtins.property
    def root_mean_square(self) -> Optional["scout_compute_api_RootMeanSquare"]:
        return self._root_mean_square

    @builtins.property
    def average(self) -> Optional["scout_compute_api_Average"]:
        return self._average

    @builtins.property
    def min(self) -> Optional["scout_compute_api_Minimum"]:
        return self._min

    @builtins.property
    def max(self) -> Optional["scout_compute_api_Maximum"]:
        return self._max

    @builtins.property
    def standard_deviation(self) -> Optional["scout_compute_api_StandardDeviation"]:
        return self._standard_deviation

    @builtins.property
    def count(self) -> Optional["scout_compute_api_Count"]:
        return self._count

    @builtins.property
    def all(self) -> Optional["api_Empty"]:
        return self._all

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangeAggregationOperationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangeAggregationOperationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)
        if self._type == 'rootMeanSquare' and self.root_mean_square is not None:
            return visitor._root_mean_square(self.root_mean_square)
        if self._type == 'average' and self.average is not None:
            return visitor._average(self.average)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)
        if self._type == 'count' and self.count is not None:
            return visitor._count(self.count)
        if self._type == 'all' and self.all is not None:
            return visitor._all(self.all)


scout_compute_api_RangeAggregationOperation.__name__ = "RangeAggregationOperation"
scout_compute_api_RangeAggregationOperation.__qualname__ = "RangeAggregationOperation"
scout_compute_api_RangeAggregationOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeAggregationOperationVisitor:

    @abstractmethod
    def _sum(self, sum: "scout_compute_api_Summation") -> Any:
        pass

    @abstractmethod
    def _root_mean_square(self, root_mean_square: "scout_compute_api_RootMeanSquare") -> Any:
        pass

    @abstractmethod
    def _average(self, average: "scout_compute_api_Average") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_Minimum") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_Maximum") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_compute_api_StandardDeviation") -> Any:
        pass

    @abstractmethod
    def _count(self, count: "scout_compute_api_Count") -> Any:
        pass

    @abstractmethod
    def _all(self, all: "api_Empty") -> Any:
        pass


scout_compute_api_RangeAggregationOperationVisitor.__name__ = "RangeAggregationOperationVisitor"
scout_compute_api_RangeAggregationOperationVisitor.__qualname__ = "RangeAggregationOperationVisitor"
scout_compute_api_RangeAggregationOperationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeMap(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'output': ConjureFieldDefinition('output', scout_compute_api_StringConstant)
        }

    __slots__: List[str] = ['_start', '_end', '_output']

    def __init__(self, output: "scout_compute_api_StringConstant", end: Optional["scout_compute_api_DoubleConstant"] = None, start: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._start = start
        self._end = end
        self._output = output

    @builtins.property
    def start(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Inclusive start value. If not specified, the start is the prior range's end value, or negative infinity.
        """
        return self._start

    @builtins.property
    def end(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Exclusive end value. If not specified, the end value is the next range's start value, or positive infinity.
        """
        return self._end

    @builtins.property
    def output(self) -> "scout_compute_api_StringConstant":
        """The value to map to if the input value is within the range.
        """
        return self._output


scout_compute_api_RangeMap.__name__ = "RangeMap"
scout_compute_api_RangeMap.__qualname__ = "RangeMap"
scout_compute_api_RangeMap.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangePaddingConfiguration(ConjureEnumType):

    PAD_START = 'PAD_START'
    '''PAD_START'''
    PAD_END = 'PAD_END'
    '''PAD_END'''
    PAD_START_AND_END = 'PAD_START_AND_END'
    '''PAD_START_AND_END'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_RangePaddingConfiguration.__name__ = "RangePaddingConfiguration"
scout_compute_api_RangePaddingConfiguration.__qualname__ = "RangePaddingConfiguration"
scout_compute_api_RangePaddingConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeSeries(ConjureUnionType):
    _approximate_threshold: Optional["scout_compute_api_ApproximateThresholdRanges"] = None
    _duration_filter: Optional["scout_compute_api_DurationFilterRanges"] = None
    _enum_filter: Optional["scout_compute_api_EnumFilterRanges"] = None
    _enum_series_equality_ranges_node: Optional["scout_compute_api_EnumSeriesEqualityRanges"] = None
    _events_search: Optional["scout_compute_api_EventsSearchRanges"] = None
    _intersect_range: Optional["scout_compute_api_IntersectRanges"] = None
    _literal_ranges: Optional["scout_compute_api_LiteralRanges"] = None
    _min_max_threshold: Optional["scout_compute_api_MinMaxThresholdRanges"] = None
    _not_: Optional["scout_compute_api_NotRanges"] = None
    _on_change: Optional["scout_compute_api_OnChangeRanges"] = None
    _peak: Optional["scout_compute_api_PeakRanges"] = None
    _range_numeric_aggregation: Optional["scout_compute_api_RangesNumericAggregation"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _series_crossover_ranges_node: Optional["scout_compute_api_SeriesCrossoverRanges"] = None
    _series_equality_ranges_node: Optional["scout_compute_api_SeriesEqualityRanges"] = None
    _stability_detection: Optional["scout_compute_api_StabilityDetectionRanges"] = None
    _stale_range: Optional["scout_compute_api_StaleRanges"] = None
    _threshold: Optional["scout_compute_api_ThresholdingRanges"] = None
    _union_range: Optional["scout_compute_api_UnionRanges"] = None
    _padded_ranges: Optional["scout_compute_api_PaddedRanges"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'approximate_threshold': ConjureFieldDefinition('approximateThreshold', scout_compute_api_ApproximateThresholdRanges),
            'duration_filter': ConjureFieldDefinition('durationFilter', scout_compute_api_DurationFilterRanges),
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_api_EnumFilterRanges),
            'enum_series_equality_ranges_node': ConjureFieldDefinition('enumSeriesEqualityRangesNode', scout_compute_api_EnumSeriesEqualityRanges),
            'events_search': ConjureFieldDefinition('eventsSearch', scout_compute_api_EventsSearchRanges),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_api_IntersectRanges),
            'literal_ranges': ConjureFieldDefinition('literalRanges', scout_compute_api_LiteralRanges),
            'min_max_threshold': ConjureFieldDefinition('minMaxThreshold', scout_compute_api_MinMaxThresholdRanges),
            'not_': ConjureFieldDefinition('not', scout_compute_api_NotRanges),
            'on_change': ConjureFieldDefinition('onChange', scout_compute_api_OnChangeRanges),
            'peak': ConjureFieldDefinition('peak', scout_compute_api_PeakRanges),
            'range_numeric_aggregation': ConjureFieldDefinition('rangeNumericAggregation', scout_compute_api_RangesNumericAggregation),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'series_crossover_ranges_node': ConjureFieldDefinition('seriesCrossoverRangesNode', scout_compute_api_SeriesCrossoverRanges),
            'series_equality_ranges_node': ConjureFieldDefinition('seriesEqualityRangesNode', scout_compute_api_SeriesEqualityRanges),
            'stability_detection': ConjureFieldDefinition('stabilityDetection', scout_compute_api_StabilityDetectionRanges),
            'stale_range': ConjureFieldDefinition('staleRange', scout_compute_api_StaleRanges),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_ThresholdingRanges),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_api_UnionRanges),
            'padded_ranges': ConjureFieldDefinition('paddedRanges', scout_compute_api_PaddedRanges)
        }

    def __init__(
            self,
            approximate_threshold: Optional["scout_compute_api_ApproximateThresholdRanges"] = None,
            duration_filter: Optional["scout_compute_api_DurationFilterRanges"] = None,
            enum_filter: Optional["scout_compute_api_EnumFilterRanges"] = None,
            enum_series_equality_ranges_node: Optional["scout_compute_api_EnumSeriesEqualityRanges"] = None,
            events_search: Optional["scout_compute_api_EventsSearchRanges"] = None,
            intersect_range: Optional["scout_compute_api_IntersectRanges"] = None,
            literal_ranges: Optional["scout_compute_api_LiteralRanges"] = None,
            min_max_threshold: Optional["scout_compute_api_MinMaxThresholdRanges"] = None,
            not_: Optional["scout_compute_api_NotRanges"] = None,
            on_change: Optional["scout_compute_api_OnChangeRanges"] = None,
            peak: Optional["scout_compute_api_PeakRanges"] = None,
            range_numeric_aggregation: Optional["scout_compute_api_RangesNumericAggregation"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            series_crossover_ranges_node: Optional["scout_compute_api_SeriesCrossoverRanges"] = None,
            series_equality_ranges_node: Optional["scout_compute_api_SeriesEqualityRanges"] = None,
            stability_detection: Optional["scout_compute_api_StabilityDetectionRanges"] = None,
            stale_range: Optional["scout_compute_api_StaleRanges"] = None,
            threshold: Optional["scout_compute_api_ThresholdingRanges"] = None,
            union_range: Optional["scout_compute_api_UnionRanges"] = None,
            padded_ranges: Optional["scout_compute_api_PaddedRanges"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (approximate_threshold is not None) + (duration_filter is not None) + (enum_filter is not None) + (enum_series_equality_ranges_node is not None) + (events_search is not None) + (intersect_range is not None) + (literal_ranges is not None) + (min_max_threshold is not None) + (not_ is not None) + (on_change is not None) + (peak is not None) + (range_numeric_aggregation is not None) + (raw is not None) + (derived is not None) + (series_crossover_ranges_node is not None) + (series_equality_ranges_node is not None) + (stability_detection is not None) + (stale_range is not None) + (threshold is not None) + (union_range is not None) + (padded_ranges is not None) != 1:
                raise ValueError('a union must contain a single member')

            if approximate_threshold is not None:
                self._approximate_threshold = approximate_threshold
                self._type = 'approximateThreshold'
            if duration_filter is not None:
                self._duration_filter = duration_filter
                self._type = 'durationFilter'
            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if enum_series_equality_ranges_node is not None:
                self._enum_series_equality_ranges_node = enum_series_equality_ranges_node
                self._type = 'enumSeriesEqualityRangesNode'
            if events_search is not None:
                self._events_search = events_search
                self._type = 'eventsSearch'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'
            if literal_ranges is not None:
                self._literal_ranges = literal_ranges
                self._type = 'literalRanges'
            if min_max_threshold is not None:
                self._min_max_threshold = min_max_threshold
                self._type = 'minMaxThreshold'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if peak is not None:
                self._peak = peak
                self._type = 'peak'
            if range_numeric_aggregation is not None:
                self._range_numeric_aggregation = range_numeric_aggregation
                self._type = 'rangeNumericAggregation'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if series_crossover_ranges_node is not None:
                self._series_crossover_ranges_node = series_crossover_ranges_node
                self._type = 'seriesCrossoverRangesNode'
            if series_equality_ranges_node is not None:
                self._series_equality_ranges_node = series_equality_ranges_node
                self._type = 'seriesEqualityRangesNode'
            if stability_detection is not None:
                self._stability_detection = stability_detection
                self._type = 'stabilityDetection'
            if stale_range is not None:
                self._stale_range = stale_range
                self._type = 'staleRange'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if padded_ranges is not None:
                self._padded_ranges = padded_ranges
                self._type = 'paddedRanges'

        elif type_of_union == 'approximateThreshold':
            if approximate_threshold is None:
                raise ValueError('a union value must not be None')
            self._approximate_threshold = approximate_threshold
            self._type = 'approximateThreshold'
        elif type_of_union == 'durationFilter':
            if duration_filter is None:
                raise ValueError('a union value must not be None')
            self._duration_filter = duration_filter
            self._type = 'durationFilter'
        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'enumSeriesEqualityRangesNode':
            if enum_series_equality_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._enum_series_equality_ranges_node = enum_series_equality_ranges_node
            self._type = 'enumSeriesEqualityRangesNode'
        elif type_of_union == 'eventsSearch':
            if events_search is None:
                raise ValueError('a union value must not be None')
            self._events_search = events_search
            self._type = 'eventsSearch'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'
        elif type_of_union == 'literalRanges':
            if literal_ranges is None:
                raise ValueError('a union value must not be None')
            self._literal_ranges = literal_ranges
            self._type = 'literalRanges'
        elif type_of_union == 'minMaxThreshold':
            if min_max_threshold is None:
                raise ValueError('a union value must not be None')
            self._min_max_threshold = min_max_threshold
            self._type = 'minMaxThreshold'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'peak':
            if peak is None:
                raise ValueError('a union value must not be None')
            self._peak = peak
            self._type = 'peak'
        elif type_of_union == 'rangeNumericAggregation':
            if range_numeric_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_numeric_aggregation = range_numeric_aggregation
            self._type = 'rangeNumericAggregation'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'seriesCrossoverRangesNode':
            if series_crossover_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_crossover_ranges_node = series_crossover_ranges_node
            self._type = 'seriesCrossoverRangesNode'
        elif type_of_union == 'seriesEqualityRangesNode':
            if series_equality_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_equality_ranges_node = series_equality_ranges_node
            self._type = 'seriesEqualityRangesNode'
        elif type_of_union == 'stabilityDetection':
            if stability_detection is None:
                raise ValueError('a union value must not be None')
            self._stability_detection = stability_detection
            self._type = 'stabilityDetection'
        elif type_of_union == 'staleRange':
            if stale_range is None:
                raise ValueError('a union value must not be None')
            self._stale_range = stale_range
            self._type = 'staleRange'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'paddedRanges':
            if padded_ranges is None:
                raise ValueError('a union value must not be None')
            self._padded_ranges = padded_ranges
            self._type = 'paddedRanges'

    @builtins.property
    def approximate_threshold(self) -> Optional["scout_compute_api_ApproximateThresholdRanges"]:
        return self._approximate_threshold

    @builtins.property
    def duration_filter(self) -> Optional["scout_compute_api_DurationFilterRanges"]:
        return self._duration_filter

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_api_EnumFilterRanges"]:
        return self._enum_filter

    @builtins.property
    def enum_series_equality_ranges_node(self) -> Optional["scout_compute_api_EnumSeriesEqualityRanges"]:
        return self._enum_series_equality_ranges_node

    @builtins.property
    def events_search(self) -> Optional["scout_compute_api_EventsSearchRanges"]:
        return self._events_search

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_api_IntersectRanges"]:
        return self._intersect_range

    @builtins.property
    def literal_ranges(self) -> Optional["scout_compute_api_LiteralRanges"]:
        return self._literal_ranges

    @builtins.property
    def min_max_threshold(self) -> Optional["scout_compute_api_MinMaxThresholdRanges"]:
        """Computes ranges where the input time series matches a filter defined by lower and upper bounds, and an operator.
        """
        return self._min_max_threshold

    @builtins.property
    def not_(self) -> Optional["scout_compute_api_NotRanges"]:
        return self._not_

    @builtins.property
    def on_change(self) -> Optional["scout_compute_api_OnChangeRanges"]:
        return self._on_change

    @builtins.property
    def peak(self) -> Optional["scout_compute_api_PeakRanges"]:
        return self._peak

    @builtins.property
    def range_numeric_aggregation(self) -> Optional["scout_compute_api_RangesNumericAggregation"]:
        return self._range_numeric_aggregation

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def series_crossover_ranges_node(self) -> Optional["scout_compute_api_SeriesCrossoverRanges"]:
        return self._series_crossover_ranges_node

    @builtins.property
    def series_equality_ranges_node(self) -> Optional["scout_compute_api_SeriesEqualityRanges"]:
        return self._series_equality_ranges_node

    @builtins.property
    def stability_detection(self) -> Optional["scout_compute_api_StabilityDetectionRanges"]:
        return self._stability_detection

    @builtins.property
    def stale_range(self) -> Optional["scout_compute_api_StaleRanges"]:
        return self._stale_range

    @builtins.property
    def threshold(self) -> Optional["scout_compute_api_ThresholdingRanges"]:
        """Computes ranges where the input time series matches a filter defined by a single threshold and an operator.
        """
        return self._threshold

    @builtins.property
    def union_range(self) -> Optional["scout_compute_api_UnionRanges"]:
        return self._union_range

    @builtins.property
    def padded_ranges(self) -> Optional["scout_compute_api_PaddedRanges"]:
        return self._padded_ranges

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangeSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangeSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'approximateThreshold' and self.approximate_threshold is not None:
            return visitor._approximate_threshold(self.approximate_threshold)
        if self._type == 'durationFilter' and self.duration_filter is not None:
            return visitor._duration_filter(self.duration_filter)
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'enumSeriesEqualityRangesNode' and self.enum_series_equality_ranges_node is not None:
            return visitor._enum_series_equality_ranges_node(self.enum_series_equality_ranges_node)
        if self._type == 'eventsSearch' and self.events_search is not None:
            return visitor._events_search(self.events_search)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)
        if self._type == 'literalRanges' and self.literal_ranges is not None:
            return visitor._literal_ranges(self.literal_ranges)
        if self._type == 'minMaxThreshold' and self.min_max_threshold is not None:
            return visitor._min_max_threshold(self.min_max_threshold)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'peak' and self.peak is not None:
            return visitor._peak(self.peak)
        if self._type == 'rangeNumericAggregation' and self.range_numeric_aggregation is not None:
            return visitor._range_numeric_aggregation(self.range_numeric_aggregation)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'seriesCrossoverRangesNode' and self.series_crossover_ranges_node is not None:
            return visitor._series_crossover_ranges_node(self.series_crossover_ranges_node)
        if self._type == 'seriesEqualityRangesNode' and self.series_equality_ranges_node is not None:
            return visitor._series_equality_ranges_node(self.series_equality_ranges_node)
        if self._type == 'stabilityDetection' and self.stability_detection is not None:
            return visitor._stability_detection(self.stability_detection)
        if self._type == 'staleRange' and self.stale_range is not None:
            return visitor._stale_range(self.stale_range)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'paddedRanges' and self.padded_ranges is not None:
            return visitor._padded_ranges(self.padded_ranges)


scout_compute_api_RangeSeries.__name__ = "RangeSeries"
scout_compute_api_RangeSeries.__qualname__ = "RangeSeries"
scout_compute_api_RangeSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeSeriesVisitor:

    @abstractmethod
    def _approximate_threshold(self, approximate_threshold: "scout_compute_api_ApproximateThresholdRanges") -> Any:
        pass

    @abstractmethod
    def _duration_filter(self, duration_filter: "scout_compute_api_DurationFilterRanges") -> Any:
        pass

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_api_EnumFilterRanges") -> Any:
        pass

    @abstractmethod
    def _enum_series_equality_ranges_node(self, enum_series_equality_ranges_node: "scout_compute_api_EnumSeriesEqualityRanges") -> Any:
        pass

    @abstractmethod
    def _events_search(self, events_search: "scout_compute_api_EventsSearchRanges") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_api_IntersectRanges") -> Any:
        pass

    @abstractmethod
    def _literal_ranges(self, literal_ranges: "scout_compute_api_LiteralRanges") -> Any:
        pass

    @abstractmethod
    def _min_max_threshold(self, min_max_threshold: "scout_compute_api_MinMaxThresholdRanges") -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_compute_api_NotRanges") -> Any:
        pass

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_api_OnChangeRanges") -> Any:
        pass

    @abstractmethod
    def _peak(self, peak: "scout_compute_api_PeakRanges") -> Any:
        pass

    @abstractmethod
    def _range_numeric_aggregation(self, range_numeric_aggregation: "scout_compute_api_RangesNumericAggregation") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _series_crossover_ranges_node(self, series_crossover_ranges_node: "scout_compute_api_SeriesCrossoverRanges") -> Any:
        pass

    @abstractmethod
    def _series_equality_ranges_node(self, series_equality_ranges_node: "scout_compute_api_SeriesEqualityRanges") -> Any:
        pass

    @abstractmethod
    def _stability_detection(self, stability_detection: "scout_compute_api_StabilityDetectionRanges") -> Any:
        pass

    @abstractmethod
    def _stale_range(self, stale_range: "scout_compute_api_StaleRanges") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_api_ThresholdingRanges") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_api_UnionRanges") -> Any:
        pass

    @abstractmethod
    def _padded_ranges(self, padded_ranges: "scout_compute_api_PaddedRanges") -> Any:
        pass


scout_compute_api_RangeSeriesVisitor.__name__ = "RangeSeriesVisitor"
scout_compute_api_RangeSeriesVisitor.__qualname__ = "RangeSeriesVisitor"
scout_compute_api_RangeSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeSummary(ConjureBeanType):
    """Summary of a set of ranges
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'range': ConjureFieldDefinition('range', scout_compute_api_Range),
            'sub_range_count': ConjureFieldDefinition('subRangeCount', int)
        }

    __slots__: List[str] = ['_range', '_sub_range_count']

    def __init__(self, range: "scout_compute_api_Range", sub_range_count: int) -> None:
        self._range = range
        self._sub_range_count = sub_range_count

    @builtins.property
    def range(self) -> "scout_compute_api_Range":
        """The range representing the minimum start and maximum end times of the ranges.
        """
        return self._range

    @builtins.property
    def sub_range_count(self) -> int:
        """The number of ranges found within this time range.
        """
        return self._sub_range_count


scout_compute_api_RangeSummary.__name__ = "RangeSummary"
scout_compute_api_RangeSummary.__qualname__ = "RangeSummary"
scout_compute_api_RangeSummary.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeValue(ConjureUnionType):
    """A value attached to a range. If there are no relevant data points in the range, this will be noPointsInRange
for the range; otherwise, an Aggregation will be returned if this is produced by getting multiple aggregation
values over a range (i.e. aggregating for all metrics over a range), and will be a double otherwise for
singular values (i.e. aggregating for just the sum of data values over a range).
    """
    _double: Optional[float] = None
    _aggregation: Optional["scout_compute_api_RangeAggregation"] = None
    _no_points_in_range: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', float),
            'aggregation': ConjureFieldDefinition('aggregation', scout_compute_api_RangeAggregation),
            'no_points_in_range': ConjureFieldDefinition('noPointsInRange', api_Empty)
        }

    def __init__(
            self,
            double: Optional[float] = None,
            aggregation: Optional["scout_compute_api_RangeAggregation"] = None,
            no_points_in_range: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (aggregation is not None) + (no_points_in_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if aggregation is not None:
                self._aggregation = aggregation
                self._type = 'aggregation'
            if no_points_in_range is not None:
                self._no_points_in_range = no_points_in_range
                self._type = 'noPointsInRange'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'aggregation':
            if aggregation is None:
                raise ValueError('a union value must not be None')
            self._aggregation = aggregation
            self._type = 'aggregation'
        elif type_of_union == 'noPointsInRange':
            if no_points_in_range is None:
                raise ValueError('a union value must not be None')
            self._no_points_in_range = no_points_in_range
            self._type = 'noPointsInRange'

    @builtins.property
    def double(self) -> Optional[float]:
        return self._double

    @builtins.property
    def aggregation(self) -> Optional["scout_compute_api_RangeAggregation"]:
        return self._aggregation

    @builtins.property
    def no_points_in_range(self) -> Optional["api_Empty"]:
        return self._no_points_in_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RangeValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RangeValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'aggregation' and self.aggregation is not None:
            return visitor._aggregation(self.aggregation)
        if self._type == 'noPointsInRange' and self.no_points_in_range is not None:
            return visitor._no_points_in_range(self.no_points_in_range)


scout_compute_api_RangeValue.__name__ = "RangeValue"
scout_compute_api_RangeValue.__qualname__ = "RangeValue"
scout_compute_api_RangeValue.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangeValueVisitor:

    @abstractmethod
    def _double(self, double: float) -> Any:
        pass

    @abstractmethod
    def _aggregation(self, aggregation: "scout_compute_api_RangeAggregation") -> Any:
        pass

    @abstractmethod
    def _no_points_in_range(self, no_points_in_range: "api_Empty") -> Any:
        pass


scout_compute_api_RangeValueVisitor.__name__ = "RangeValueVisitor"
scout_compute_api_RangeValueVisitor.__qualname__ = "RangeValueVisitor"
scout_compute_api_RangeValueVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangesNumericAggregation(ConjureBeanType):
    """Aggregates the values of a numeric series at each range specified by the input ranges.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_RangeSeries),
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_RangeAggregationOperation)
        }

    __slots__: List[str] = ['_ranges', '_input', '_operation']

    def __init__(self, input: "scout_compute_api_NumericSeries", operation: "scout_compute_api_RangeAggregationOperation", ranges: "scout_compute_api_RangeSeries") -> None:
        self._ranges = ranges
        self._input = input
        self._operation = operation

    @builtins.property
    def ranges(self) -> "scout_compute_api_RangeSeries":
        return self._ranges

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_RangeAggregationOperation":
        return self._operation


scout_compute_api_RangesNumericAggregation.__name__ = "RangesNumericAggregation"
scout_compute_api_RangesNumericAggregation.__qualname__ = "RangesNumericAggregation"
scout_compute_api_RangesNumericAggregation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RangesSummary(ConjureBeanType):
    """A summary of the ranges returned from a SummarizeRanges request. Returned when the number of ranges
found is above a threshold.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges_summary': ConjureFieldDefinition('rangesSummary', List[scout_compute_api_RangeSummary])
        }

    __slots__: List[str] = ['_ranges_summary']

    def __init__(self, ranges_summary: List["scout_compute_api_RangeSummary"]) -> None:
        self._ranges_summary = ranges_summary

    @builtins.property
    def ranges_summary(self) -> List["scout_compute_api_RangeSummary"]:
        return self._ranges_summary


scout_compute_api_RangesSummary.__name__ = "RangesSummary"
scout_compute_api_RangesSummary.__qualname__ = "RangesSummary"
scout_compute_api_RangesSummary.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Reference(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_compute_api_Reference.__name__ = "Reference"
scout_compute_api_Reference.__qualname__ = "Reference"
scout_compute_api_Reference.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RefpropProperty(ConjureEnumType):
    """Supported properties for REFPROP calculations
    """

    TEMPERATURE = 'TEMPERATURE'
    '''TEMPERATURE'''
    PRESSURE = 'PRESSURE'
    '''PRESSURE'''
    MASS_DENSITY = 'MASS_DENSITY'
    '''MASS_DENSITY'''
    MASS_SPECIFIC_ENTHALPY = 'MASS_SPECIFIC_ENTHALPY'
    '''MASS_SPECIFIC_ENTHALPY'''
    MASS_SPECIFIC_INTERNAL_ENERGY = 'MASS_SPECIFIC_INTERNAL_ENERGY'
    '''MASS_SPECIFIC_INTERNAL_ENERGY'''
    MASS_SPECIFIC_ENTROPY = 'MASS_SPECIFIC_ENTROPY'
    '''MASS_SPECIFIC_ENTROPY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_RefpropProperty.__name__ = "RefpropProperty"
scout_compute_api_RefpropProperty.__qualname__ = "RefpropProperty"
scout_compute_api_RefpropProperty.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RefpropSeries(ConjureBeanType):
    """Computes the output property given input properties for the substance using REFPROP. Initial implementation
only expects two input properties.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_RefpropProperty, scout_compute_api_NumericSeries]),
            'output_property': ConjureFieldDefinition('outputProperty', scout_compute_api_RefpropProperty),
            'substance': ConjureFieldDefinition('substance', scout_compute_api_RefpropSubstance),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_output_property', '_substance', '_interpolation_configuration']

    def __init__(self, inputs: Dict["scout_compute_api_RefpropProperty", "scout_compute_api_NumericSeries"], output_property: "scout_compute_api_RefpropProperty", substance: "scout_compute_api_RefpropSubstance", interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._output_property = output_property
        self._substance = substance
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> Dict["scout_compute_api_RefpropProperty", "scout_compute_api_NumericSeries"]:
        """A map that maps a REFPROP property to its numeric series.
        """
        return self._inputs

    @builtins.property
    def output_property(self) -> "scout_compute_api_RefpropProperty":
        """The desired output property. This should not be one of the input properties.
        """
        return self._output_property

    @builtins.property
    def substance(self) -> "scout_compute_api_RefpropSubstance":
        """The substance for REFPROP calculations.
        """
        return self._substance

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        return self._interpolation_configuration


scout_compute_api_RefpropSeries.__name__ = "RefpropSeries"
scout_compute_api_RefpropSeries.__qualname__ = "RefpropSeries"
scout_compute_api_RefpropSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RefpropSubstance(ConjureEnumType):
    """Supported substances for REFPROP calculations
    """

    NITROGEN = 'NITROGEN'
    '''NITROGEN'''
    OXYGEN = 'OXYGEN'
    '''OXYGEN'''
    HELIUM = 'HELIUM'
    '''HELIUM'''
    HYDROGEN = 'HYDROGEN'
    '''HYDROGEN'''
    METHANE = 'METHANE'
    '''METHANE'''
    PROPANE = 'PROPANE'
    '''PROPANE'''
    BUTANE = 'BUTANE'
    '''BUTANE'''
    WATER = 'WATER'
    '''WATER'''
    XENON = 'XENON'
    '''XENON'''
    AIR = 'AIR'
    '''AIR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_RefpropSubstance.__name__ = "RefpropSubstance"
scout_compute_api_RefpropSubstance.__qualname__ = "RefpropSubstance"
scout_compute_api_RefpropSubstance.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RollingOperationSeries(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'window': ConjureFieldDefinition('window', scout_compute_api_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_api_NumericSeries", operator: "scout_compute_api_RollingOperator", window: "scout_compute_api_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_api_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_api_RollingOperationSeries.__name__ = "RollingOperationSeries"
scout_compute_api_RollingOperationSeries.__qualname__ = "RollingOperationSeries"
scout_compute_api_RollingOperationSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RollingOperator(ConjureUnionType):
    _average: Optional["scout_compute_api_Average"] = None
    _count: Optional["scout_compute_api_Count"] = None
    _min: Optional["scout_compute_api_Minimum"] = None
    _max: Optional["scout_compute_api_Maximum"] = None
    _standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None
    _sum: Optional["scout_compute_api_Sum"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'average': ConjureFieldDefinition('average', scout_compute_api_Average),
            'count': ConjureFieldDefinition('count', scout_compute_api_Count),
            'min': ConjureFieldDefinition('min', scout_compute_api_Minimum),
            'max': ConjureFieldDefinition('max', scout_compute_api_Maximum),
            'standard_deviation': ConjureFieldDefinition('standardDeviation', scout_compute_api_StandardDeviation),
            'sum': ConjureFieldDefinition('sum', scout_compute_api_Sum)
        }

    def __init__(
            self,
            average: Optional["scout_compute_api_Average"] = None,
            count: Optional["scout_compute_api_Count"] = None,
            min: Optional["scout_compute_api_Minimum"] = None,
            max: Optional["scout_compute_api_Maximum"] = None,
            standard_deviation: Optional["scout_compute_api_StandardDeviation"] = None,
            sum: Optional["scout_compute_api_Sum"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (average is not None) + (count is not None) + (min is not None) + (max is not None) + (standard_deviation is not None) + (sum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if average is not None:
                self._average = average
                self._type = 'average'
            if count is not None:
                self._count = count
                self._type = 'count'
            if min is not None:
                self._min = min
                self._type = 'min'
            if max is not None:
                self._max = max
                self._type = 'max'
            if standard_deviation is not None:
                self._standard_deviation = standard_deviation
                self._type = 'standardDeviation'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'

        elif type_of_union == 'average':
            if average is None:
                raise ValueError('a union value must not be None')
            self._average = average
            self._type = 'average'
        elif type_of_union == 'count':
            if count is None:
                raise ValueError('a union value must not be None')
            self._count = count
            self._type = 'count'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'standardDeviation':
            if standard_deviation is None:
                raise ValueError('a union value must not be None')
            self._standard_deviation = standard_deviation
            self._type = 'standardDeviation'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'

    @builtins.property
    def average(self) -> Optional["scout_compute_api_Average"]:
        return self._average

    @builtins.property
    def count(self) -> Optional["scout_compute_api_Count"]:
        return self._count

    @builtins.property
    def min(self) -> Optional["scout_compute_api_Minimum"]:
        return self._min

    @builtins.property
    def max(self) -> Optional["scout_compute_api_Maximum"]:
        return self._max

    @builtins.property
    def standard_deviation(self) -> Optional["scout_compute_api_StandardDeviation"]:
        return self._standard_deviation

    @builtins.property
    def sum(self) -> Optional["scout_compute_api_Sum"]:
        return self._sum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_RollingOperatorVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_RollingOperatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'average' and self.average is not None:
            return visitor._average(self.average)
        if self._type == 'count' and self.count is not None:
            return visitor._count(self.count)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'standardDeviation' and self.standard_deviation is not None:
            return visitor._standard_deviation(self.standard_deviation)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)


scout_compute_api_RollingOperator.__name__ = "RollingOperator"
scout_compute_api_RollingOperator.__qualname__ = "RollingOperator"
scout_compute_api_RollingOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RollingOperatorVisitor:

    @abstractmethod
    def _average(self, average: "scout_compute_api_Average") -> Any:
        pass

    @abstractmethod
    def _count(self, count: "scout_compute_api_Count") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_api_Minimum") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_api_Maximum") -> Any:
        pass

    @abstractmethod
    def _standard_deviation(self, standard_deviation: "scout_compute_api_StandardDeviation") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_api_Sum") -> Any:
        pass


scout_compute_api_RollingOperatorVisitor.__name__ = "RollingOperatorVisitor"
scout_compute_api_RollingOperatorVisitor.__qualname__ = "RollingOperatorVisitor"
scout_compute_api_RollingOperatorVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RootMeanSquare(ConjureBeanType):
    """The root mean square of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_RootMeanSquare.__name__ = "RootMeanSquare"
scout_compute_api_RootMeanSquare.__qualname__ = "RootMeanSquare"
scout_compute_api_RootMeanSquare.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_RunChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_compute_api_StringConstant),
            'asset_rid': ConjureFieldDefinition('assetRid', OptionalTypeWrapper[scout_compute_api_StringConstant]),
            'data_scope_name': ConjureFieldDefinition('dataScopeName', scout_compute_api_StringConstant),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_StringConstant),
            'additional_tags': ConjureFieldDefinition('additionalTags', Dict[str, scout_compute_api_StringConstant]),
            'additional_tag_filters': ConjureFieldDefinition('additionalTagFilters', OptionalTypeWrapper[scout_compute_api_TagFilters]),
            'tags_to_group_by': ConjureFieldDefinition('tagsToGroupBy', List[str]),
            'group_by_tags': ConjureFieldDefinition('groupByTags', List[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_run_rid', '_asset_rid', '_data_scope_name', '_channel', '_additional_tags', '_additional_tag_filters', '_tags_to_group_by', '_group_by_tags']

    def __init__(self, additional_tags: Dict[str, "scout_compute_api_StringConstant"], channel: "scout_compute_api_StringConstant", data_scope_name: "scout_compute_api_StringConstant", group_by_tags: List["scout_compute_api_StringConstant"], run_rid: "scout_compute_api_StringConstant", tags_to_group_by: List[str], additional_tag_filters: Optional["scout_compute_api_TagFilters"] = None, asset_rid: Optional["scout_compute_api_StringConstant"] = None) -> None:
        self._run_rid = run_rid
        self._asset_rid = asset_rid
        self._data_scope_name = data_scope_name
        self._channel = channel
        self._additional_tags = additional_tags
        self._additional_tag_filters = additional_tag_filters
        self._tags_to_group_by = tags_to_group_by
        self._group_by_tags = group_by_tags

    @builtins.property
    def run_rid(self) -> "scout_compute_api_StringConstant":
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> Optional["scout_compute_api_StringConstant"]:
        """Used to disambiguate when multiple assets within this run contain data scopes with the same name.
If not specified for a run with multiple assets, an error will be thrown.
        """
        return self._asset_rid

    @builtins.property
    def data_scope_name(self) -> "scout_compute_api_StringConstant":
        """Used to disambiguate when multiple data scopes within this run contain channels with the same name.
        """
        return self._data_scope_name

    @builtins.property
    def channel(self) -> "scout_compute_api_StringConstant":
        return self._channel

    @builtins.property
    def additional_tags(self) -> Dict[str, "scout_compute_api_StringConstant"]:
        return self._additional_tags

    @builtins.property
    def additional_tag_filters(self) -> Optional["scout_compute_api_TagFilters"]:
        """Tags to filter the channel by, in addition to tag filters defined for a given Run data scope. Throws on 
collisions with tag keys already defined for the given Run data scope. Only returns points that match 
both sets of tag filters. For log series, include arg filters here in addition to tag filters.
        """
        return self._additional_tag_filters

    @builtins.property
    def tags_to_group_by(self) -> List[str]:
        return self._tags_to_group_by

    @builtins.property
    def group_by_tags(self) -> List["scout_compute_api_StringConstant"]:
        """Tags that the channel should be grouped by. If this is non-empty a grouped result will be returned
with an entry for each grouping. Only one of tagsToGroupBy and groupByTags should be specified.
        """
        return self._group_by_tags


scout_compute_api_RunChannel.__name__ = "RunChannel"
scout_compute_api_RunChannel.__qualname__ = "RunChannel"
scout_compute_api_RunChannel.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScaleSeries(ConjureBeanType):
    """For every timestamp specified in the input series, multiply it by a constant factor.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'scalar': ConjureFieldDefinition('scalar', scout_compute_api_DoubleConstant),
            'scalar_unit': ConjureFieldDefinition('scalarUnit', OptionalTypeWrapper[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_input', '_scalar', '_scalar_unit']

    def __init__(self, input: "scout_compute_api_NumericSeries", scalar: "scout_compute_api_DoubleConstant", scalar_unit: Optional[str] = None) -> None:
        self._input = input
        self._scalar = scalar
        self._scalar_unit = scalar_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def scalar(self) -> "scout_compute_api_DoubleConstant":
        """The constant to multiply each point by
        """
        return self._scalar

    @builtins.property
    def scalar_unit(self) -> Optional[str]:
        """The units of the scalar to multiply by. If empty, the scalar is considered unit-less.
        """
        return self._scalar_unit


scout_compute_api_ScaleSeries.__name__ = "ScaleSeries"
scout_compute_api_ScaleSeries.__qualname__ = "ScaleSeries"
scout_compute_api_ScaleSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Scatter(ConjureBeanType):
    """A scatter plot comprised of the values from one input series on the x-axis
and values from another input series on the y-axis, for all points within a requested time range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_NumericSeries),
            'y': ConjureFieldDefinition('y', scout_compute_api_NumericSeries)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_NumericSeries", y: "scout_compute_api_NumericSeries") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_NumericSeries":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_NumericSeries":
        return self._y


scout_compute_api_Scatter.__name__ = "Scatter"
scout_compute_api_Scatter.__qualname__ = "Scatter"
scout_compute_api_Scatter.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Scatter3d(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_NumericSeries),
            'y': ConjureFieldDefinition('y', scout_compute_api_NumericSeries),
            'z': ConjureFieldDefinition('z', scout_compute_api_NumericSeries),
            'driver_series': ConjureFieldDefinition('driverSeries', OptionalTypeWrapper[scout_compute_api_DriverSeries3d])
        }

    __slots__: List[str] = ['_x', '_y', '_z', '_driver_series']

    def __init__(self, x: "scout_compute_api_NumericSeries", y: "scout_compute_api_NumericSeries", z: "scout_compute_api_NumericSeries", driver_series: Optional["scout_compute_api_DriverSeries3d"] = None) -> None:
        self._x = x
        self._y = y
        self._z = z
        self._driver_series = driver_series

    @builtins.property
    def x(self) -> "scout_compute_api_NumericSeries":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_NumericSeries":
        return self._y

    @builtins.property
    def z(self) -> "scout_compute_api_NumericSeries":
        return self._z

    @builtins.property
    def driver_series(self) -> Optional["scout_compute_api_DriverSeries3d"]:
        return self._driver_series


scout_compute_api_Scatter3d.__name__ = "Scatter3d"
scout_compute_api_Scatter3d.__qualname__ = "Scatter3d"
scout_compute_api_Scatter3d.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScatterCurveFit(ConjureBeanType):
    """Fits a curve to the scatter between two series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_Scatter),
            'options': ConjureFieldDefinition('options', scout_compute_api_ScatterFitOptions)
        }

    __slots__: List[str] = ['_scatter', '_options']

    def __init__(self, options: "scout_compute_api_ScatterFitOptions", scatter: "scout_compute_api_Scatter") -> None:
        self._scatter = scatter
        self._options = options

    @builtins.property
    def scatter(self) -> "scout_compute_api_Scatter":
        """The x and y series to fit to.
        """
        return self._scatter

    @builtins.property
    def options(self) -> "scout_compute_api_ScatterFitOptions":
        return self._options


scout_compute_api_ScatterCurveFit.__name__ = "ScatterCurveFit"
scout_compute_api_ScatterCurveFit.__qualname__ = "ScatterCurveFit"
scout_compute_api_ScatterCurveFit.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScatterFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'max_x': ConjureFieldDefinition('maxX', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'min_y': ConjureFieldDefinition('minY', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'max_y': ConjureFieldDefinition('maxY', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: Optional["scout_compute_api_DoubleConstant"] = None, max_y: Optional["scout_compute_api_DoubleConstant"] = None, min_x: Optional["scout_compute_api_DoubleConstant"] = None, min_y: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Inclusive lower bound on the x values to fit to. If omitted, does not set a bound
(equivalent to setting this to the minimum x value among all points in the time range).
        """
        return self._min_x

    @builtins.property
    def max_x(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Inclusive upper bound on the x values to fit to. If omitted, does not set a bound
(equivalent to setting this to the maximum x value among all points in the time range).
        """
        return self._max_x

    @builtins.property
    def min_y(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Inclusive lower bound on the y values to fit to. If omitted, does not set a bound
(equivalent to setting this to the minimum y value among all points in the time range).
        """
        return self._min_y

    @builtins.property
    def max_y(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """Inclusive upper bound on the y values to fit to. If omitted, does not set a bound
(equivalent to setting this to the maximum y value among all points in the time range).
        """
        return self._max_y


scout_compute_api_ScatterFitOptions.__name__ = "ScatterFitOptions"
scout_compute_api_ScatterFitOptions.__qualname__ = "ScatterFitOptions"
scout_compute_api_ScatterFitOptions.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScatterSummarizationStrategy(ConjureUnionType):
    _spatial: Optional["scout_compute_api_SpatialDecimateStrategy"] = None
    _temporal: Optional["scout_compute_api_TemporalDecimateStrategy"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'spatial': ConjureFieldDefinition('spatial', scout_compute_api_SpatialDecimateStrategy),
            'temporal': ConjureFieldDefinition('temporal', scout_compute_api_TemporalDecimateStrategy)
        }

    def __init__(
            self,
            spatial: Optional["scout_compute_api_SpatialDecimateStrategy"] = None,
            temporal: Optional["scout_compute_api_TemporalDecimateStrategy"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (spatial is not None) + (temporal is not None) != 1:
                raise ValueError('a union must contain a single member')

            if spatial is not None:
                self._spatial = spatial
                self._type = 'spatial'
            if temporal is not None:
                self._temporal = temporal
                self._type = 'temporal'

        elif type_of_union == 'spatial':
            if spatial is None:
                raise ValueError('a union value must not be None')
            self._spatial = spatial
            self._type = 'spatial'
        elif type_of_union == 'temporal':
            if temporal is None:
                raise ValueError('a union value must not be None')
            self._temporal = temporal
            self._type = 'temporal'

    @builtins.property
    def spatial(self) -> Optional["scout_compute_api_SpatialDecimateStrategy"]:
        return self._spatial

    @builtins.property
    def temporal(self) -> Optional["scout_compute_api_TemporalDecimateStrategy"]:
        return self._temporal

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ScatterSummarizationStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ScatterSummarizationStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'spatial' and self.spatial is not None:
            return visitor._spatial(self.spatial)
        if self._type == 'temporal' and self.temporal is not None:
            return visitor._temporal(self.temporal)


scout_compute_api_ScatterSummarizationStrategy.__name__ = "ScatterSummarizationStrategy"
scout_compute_api_ScatterSummarizationStrategy.__qualname__ = "ScatterSummarizationStrategy"
scout_compute_api_ScatterSummarizationStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScatterSummarizationStrategyVisitor:

    @abstractmethod
    def _spatial(self, spatial: "scout_compute_api_SpatialDecimateStrategy") -> Any:
        pass

    @abstractmethod
    def _temporal(self, temporal: "scout_compute_api_TemporalDecimateStrategy") -> Any:
        pass


scout_compute_api_ScatterSummarizationStrategyVisitor.__name__ = "ScatterSummarizationStrategyVisitor"
scout_compute_api_ScatterSummarizationStrategyVisitor.__qualname__ = "ScatterSummarizationStrategyVisitor"
scout_compute_api_ScatterSummarizationStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ScatterTemporalAggregation(ConjureEnumType):

    MEAN = 'MEAN'
    '''MEAN'''
    MIN = 'MIN'
    '''MIN'''
    MAX = 'MAX'
    '''MAX'''
    FIRST = 'FIRST'
    '''FIRST'''
    LAST = 'LAST'
    '''LAST'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_ScatterTemporalAggregation.__name__ = "ScatterTemporalAggregation"
scout_compute_api_ScatterTemporalAggregation.__qualname__ = "ScatterTemporalAggregation"
scout_compute_api_ScatterTemporalAggregation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SelectIndexFrom1dEnumArraySeries(ConjureBeanType):
    """For each timestamp, selects a single enum value from the 1D enum array at the specified index. If the index
is out of bounds for an array at a given timestamp, it is omitted.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Enum1dArraySeries),
            'index': ConjureFieldDefinition('index', scout_compute_api_IntegerConstant)
        }

    __slots__: List[str] = ['_input', '_index']

    def __init__(self, index: "scout_compute_api_IntegerConstant", input: "scout_compute_api_Enum1dArraySeries") -> None:
        self._input = input
        self._index = index

    @builtins.property
    def input(self) -> "scout_compute_api_Enum1dArraySeries":
        return self._input

    @builtins.property
    def index(self) -> "scout_compute_api_IntegerConstant":
        return self._index


scout_compute_api_SelectIndexFrom1dEnumArraySeries.__name__ = "SelectIndexFrom1dEnumArraySeries"
scout_compute_api_SelectIndexFrom1dEnumArraySeries.__qualname__ = "SelectIndexFrom1dEnumArraySeries"
scout_compute_api_SelectIndexFrom1dEnumArraySeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SelectIndexFrom1dNumericArraySeries(ConjureBeanType):
    """For each timestamp, selects a single numeric value from the 1D numeric array at the specified index. If the 
index is out of bounds for an array at a given timestamp, it is omitted.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Numeric1dArraySeries),
            'index': ConjureFieldDefinition('index', scout_compute_api_IntegerConstant)
        }

    __slots__: List[str] = ['_input', '_index']

    def __init__(self, index: "scout_compute_api_IntegerConstant", input: "scout_compute_api_Numeric1dArraySeries") -> None:
        self._input = input
        self._index = index

    @builtins.property
    def input(self) -> "scout_compute_api_Numeric1dArraySeries":
        return self._input

    @builtins.property
    def index(self) -> "scout_compute_api_IntegerConstant":
        return self._index


scout_compute_api_SelectIndexFrom1dNumericArraySeries.__name__ = "SelectIndexFrom1dNumericArraySeries"
scout_compute_api_SelectIndexFrom1dNumericArraySeries.__qualname__ = "SelectIndexFrom1dNumericArraySeries"
scout_compute_api_SelectIndexFrom1dNumericArraySeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SelectNewestPointsSeries(ConjureBeanType):
    """Select the most recent N points from the input series by timestamp.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'num_points': ConjureFieldDefinition('numPoints', scout_compute_api_IntegerConstant)
        }

    __slots__: List[str] = ['_input', '_num_points']

    def __init__(self, input: "scout_compute_api_NumericSeries", num_points: "scout_compute_api_IntegerConstant") -> None:
        self._input = input
        self._num_points = num_points

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def num_points(self) -> "scout_compute_api_IntegerConstant":
        return self._num_points


scout_compute_api_SelectNewestPointsSeries.__name__ = "SelectNewestPointsSeries"
scout_compute_api_SelectNewestPointsSeries.__qualname__ = "SelectNewestPointsSeries"
scout_compute_api_SelectNewestPointsSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SelectValue(ConjureUnionType):
    _first_point: Optional["scout_compute_api_Series"] = None
    _first_value_point: Optional["scout_compute_api_Series"] = None
    _first_range: Optional["scout_compute_api_RangeSeries"] = None
    _last_point: Optional["scout_compute_api_Series"] = None
    _last_value_point: Optional["scout_compute_api_Series"] = None
    _last_range: Optional["scout_compute_api_RangeSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_Series),
            'first_value_point': ConjureFieldDefinition('firstValuePoint', scout_compute_api_Series),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_api_RangeSeries),
            'last_point': ConjureFieldDefinition('lastPoint', scout_compute_api_Series),
            'last_value_point': ConjureFieldDefinition('lastValuePoint', scout_compute_api_Series),
            'last_range': ConjureFieldDefinition('lastRange', scout_compute_api_RangeSeries)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_api_Series"] = None,
            first_value_point: Optional["scout_compute_api_Series"] = None,
            first_range: Optional["scout_compute_api_RangeSeries"] = None,
            last_point: Optional["scout_compute_api_Series"] = None,
            last_value_point: Optional["scout_compute_api_Series"] = None,
            last_range: Optional["scout_compute_api_RangeSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_value_point is not None) + (first_range is not None) + (last_point is not None) + (last_value_point is not None) + (last_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_value_point is not None:
                self._first_value_point = first_value_point
                self._type = 'firstValuePoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'
            if last_point is not None:
                self._last_point = last_point
                self._type = 'lastPoint'
            if last_value_point is not None:
                self._last_value_point = last_value_point
                self._type = 'lastValuePoint'
            if last_range is not None:
                self._last_range = last_range
                self._type = 'lastRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstValuePoint':
            if first_value_point is None:
                raise ValueError('a union value must not be None')
            self._first_value_point = first_value_point
            self._type = 'firstValuePoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'
        elif type_of_union == 'lastPoint':
            if last_point is None:
                raise ValueError('a union value must not be None')
            self._last_point = last_point
            self._type = 'lastPoint'
        elif type_of_union == 'lastValuePoint':
            if last_value_point is None:
                raise ValueError('a union value must not be None')
            self._last_value_point = last_value_point
            self._type = 'lastValuePoint'
        elif type_of_union == 'lastRange':
            if last_range is None:
                raise ValueError('a union value must not be None')
            self._last_range = last_range
            self._type = 'lastRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_api_Series"]:
        return self._first_point

    @builtins.property
    def first_value_point(self) -> Optional["scout_compute_api_Series"]:
        return self._first_value_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_api_RangeSeries"]:
        return self._first_range

    @builtins.property
    def last_point(self) -> Optional["scout_compute_api_Series"]:
        return self._last_point

    @builtins.property
    def last_value_point(self) -> Optional["scout_compute_api_Series"]:
        return self._last_value_point

    @builtins.property
    def last_range(self) -> Optional["scout_compute_api_RangeSeries"]:
        return self._last_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SelectValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SelectValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstValuePoint' and self.first_value_point is not None:
            return visitor._first_value_point(self.first_value_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)
        if self._type == 'lastPoint' and self.last_point is not None:
            return visitor._last_point(self.last_point)
        if self._type == 'lastValuePoint' and self.last_value_point is not None:
            return visitor._last_value_point(self.last_value_point)
        if self._type == 'lastRange' and self.last_range is not None:
            return visitor._last_range(self.last_range)


scout_compute_api_SelectValue.__name__ = "SelectValue"
scout_compute_api_SelectValue.__qualname__ = "SelectValue"
scout_compute_api_SelectValue.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SelectValueVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_api_Series") -> Any:
        pass

    @abstractmethod
    def _first_value_point(self, first_value_point: "scout_compute_api_Series") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_api_RangeSeries") -> Any:
        pass

    @abstractmethod
    def _last_point(self, last_point: "scout_compute_api_Series") -> Any:
        pass

    @abstractmethod
    def _last_value_point(self, last_value_point: "scout_compute_api_Series") -> Any:
        pass

    @abstractmethod
    def _last_range(self, last_range: "scout_compute_api_RangeSeries") -> Any:
        pass


scout_compute_api_SelectValueVisitor.__name__ = "SelectValueVisitor"
scout_compute_api_SelectValueVisitor.__qualname__ = "SelectValueVisitor"
scout_compute_api_SelectValueVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Series(ConjureUnionType):
    _raw: Optional["scout_compute_api_Reference"] = None
    _enum: Optional["scout_compute_api_EnumSeries"] = None
    _numeric: Optional["scout_compute_api_NumericSeries"] = None
    _log: Optional["scout_compute_api_LogSeries"] = None
    _array: Optional["scout_compute_api_ArraySeries"] = None
    _struct: Optional["scout_compute_api_StructSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_EnumSeries),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_NumericSeries),
            'log': ConjureFieldDefinition('log', scout_compute_api_LogSeries),
            'array': ConjureFieldDefinition('array', scout_compute_api_ArraySeries),
            'struct': ConjureFieldDefinition('struct', scout_compute_api_StructSeries)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_Reference"] = None,
            enum: Optional["scout_compute_api_EnumSeries"] = None,
            numeric: Optional["scout_compute_api_NumericSeries"] = None,
            log: Optional["scout_compute_api_LogSeries"] = None,
            array: Optional["scout_compute_api_ArraySeries"] = None,
            struct: Optional["scout_compute_api_StructSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) + (log is not None) + (array is not None) + (struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if log is not None:
                self._log = log
                self._type = 'log'
            if array is not None:
                self._array = array
                self._type = 'array'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'log':
            if log is None:
                raise ValueError('a union value must not be None')
            self._log = log
            self._type = 'log'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_EnumSeries"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_NumericSeries"]:
        return self._numeric

    @builtins.property
    def log(self) -> Optional["scout_compute_api_LogSeries"]:
        return self._log

    @builtins.property
    def array(self) -> Optional["scout_compute_api_ArraySeries"]:
        return self._array

    @builtins.property
    def struct(self) -> Optional["scout_compute_api_StructSeries"]:
        return self._struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'log' and self.log is not None:
            return visitor._log(self.log)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)


scout_compute_api_Series.__name__ = "Series"
scout_compute_api_Series.__qualname__ = "Series"
scout_compute_api_Series.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SeriesVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_EnumSeries") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_NumericSeries") -> Any:
        pass

    @abstractmethod
    def _log(self, log: "scout_compute_api_LogSeries") -> Any:
        pass

    @abstractmethod
    def _array(self, array: "scout_compute_api_ArraySeries") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: "scout_compute_api_StructSeries") -> Any:
        pass


scout_compute_api_SeriesVisitor.__name__ = "SeriesVisitor"
scout_compute_api_SeriesVisitor.__qualname__ = "SeriesVisitor"
scout_compute_api_SeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SeriesCrossoverRanges(ConjureBeanType):
    """Produces a list of zero-duration ranges at the first point where two series cross over one another
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input_a': ConjureFieldDefinition('inputA', scout_compute_api_NumericSeries),
            'input_b': ConjureFieldDefinition('inputB', scout_compute_api_NumericSeries)
        }

    __slots__: List[str] = ['_input_a', '_input_b']

    def __init__(self, input_a: "scout_compute_api_NumericSeries", input_b: "scout_compute_api_NumericSeries") -> None:
        self._input_a = input_a
        self._input_b = input_b

    @builtins.property
    def input_a(self) -> "scout_compute_api_NumericSeries":
        return self._input_a

    @builtins.property
    def input_b(self) -> "scout_compute_api_NumericSeries":
        return self._input_b


scout_compute_api_SeriesCrossoverRanges.__name__ = "SeriesCrossoverRanges"
scout_compute_api_SeriesCrossoverRanges.__qualname__ = "SeriesCrossoverRanges"
scout_compute_api_SeriesCrossoverRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SeriesEqualityRanges(ConjureBeanType):
    """Produces a list of ranges for which provided series are all equal (or are not all equal).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_NumericSeries]),
            'equality_operator': ConjureFieldDefinition('equalityOperator', scout_compute_api_EqualityOperator),
            'tolerance': ConjureFieldDefinition('tolerance', OptionalTypeWrapper[scout_compute_api_DoubleConstant]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_input', '_equality_operator', '_tolerance', '_persistence_window_configuration', '_interpolation_configuration']

    def __init__(self, equality_operator: "scout_compute_api_EqualityOperator", input: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None, persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None, tolerance: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._input = input
        self._equality_operator = equality_operator
        self._tolerance = tolerance
        self._persistence_window_configuration = persistence_window_configuration
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input(self) -> List["scout_compute_api_NumericSeries"]:
        return self._input

    @builtins.property
    def equality_operator(self) -> "scout_compute_api_EqualityOperator":
        return self._equality_operator

    @builtins.property
    def tolerance(self) -> Optional["scout_compute_api_DoubleConstant"]:
        return self._tolerance

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_SeriesEqualityRanges.__name__ = "SeriesEqualityRanges"
scout_compute_api_SeriesEqualityRanges.__qualname__ = "SeriesEqualityRanges"
scout_compute_api_SeriesEqualityRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SetNegativeValuesToZero(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_SetNegativeValuesToZero.__name__ = "SetNegativeValuesToZero"
scout_compute_api_SetNegativeValuesToZero.__qualname__ = "SetNegativeValuesToZero"
scout_compute_api_SetNegativeValuesToZero.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SignalFilterConfiguration(ConjureUnionType):
    _low_pass: Optional["scout_compute_api_LowPassConfiguration"] = None
    _high_pass: Optional["scout_compute_api_HighPassConfiguration"] = None
    _band_pass: Optional["scout_compute_api_BandPassConfiguration"] = None
    _band_stop: Optional["scout_compute_api_BandStopConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_pass': ConjureFieldDefinition('lowPass', scout_compute_api_LowPassConfiguration),
            'high_pass': ConjureFieldDefinition('highPass', scout_compute_api_HighPassConfiguration),
            'band_pass': ConjureFieldDefinition('bandPass', scout_compute_api_BandPassConfiguration),
            'band_stop': ConjureFieldDefinition('bandStop', scout_compute_api_BandStopConfiguration)
        }

    def __init__(
            self,
            low_pass: Optional["scout_compute_api_LowPassConfiguration"] = None,
            high_pass: Optional["scout_compute_api_HighPassConfiguration"] = None,
            band_pass: Optional["scout_compute_api_BandPassConfiguration"] = None,
            band_stop: Optional["scout_compute_api_BandStopConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (low_pass is not None) + (high_pass is not None) + (band_pass is not None) + (band_stop is not None) != 1:
                raise ValueError('a union must contain a single member')

            if low_pass is not None:
                self._low_pass = low_pass
                self._type = 'lowPass'
            if high_pass is not None:
                self._high_pass = high_pass
                self._type = 'highPass'
            if band_pass is not None:
                self._band_pass = band_pass
                self._type = 'bandPass'
            if band_stop is not None:
                self._band_stop = band_stop
                self._type = 'bandStop'

        elif type_of_union == 'lowPass':
            if low_pass is None:
                raise ValueError('a union value must not be None')
            self._low_pass = low_pass
            self._type = 'lowPass'
        elif type_of_union == 'highPass':
            if high_pass is None:
                raise ValueError('a union value must not be None')
            self._high_pass = high_pass
            self._type = 'highPass'
        elif type_of_union == 'bandPass':
            if band_pass is None:
                raise ValueError('a union value must not be None')
            self._band_pass = band_pass
            self._type = 'bandPass'
        elif type_of_union == 'bandStop':
            if band_stop is None:
                raise ValueError('a union value must not be None')
            self._band_stop = band_stop
            self._type = 'bandStop'

    @builtins.property
    def low_pass(self) -> Optional["scout_compute_api_LowPassConfiguration"]:
        return self._low_pass

    @builtins.property
    def high_pass(self) -> Optional["scout_compute_api_HighPassConfiguration"]:
        return self._high_pass

    @builtins.property
    def band_pass(self) -> Optional["scout_compute_api_BandPassConfiguration"]:
        return self._band_pass

    @builtins.property
    def band_stop(self) -> Optional["scout_compute_api_BandStopConfiguration"]:
        return self._band_stop

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SignalFilterConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SignalFilterConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'lowPass' and self.low_pass is not None:
            return visitor._low_pass(self.low_pass)
        if self._type == 'highPass' and self.high_pass is not None:
            return visitor._high_pass(self.high_pass)
        if self._type == 'bandPass' and self.band_pass is not None:
            return visitor._band_pass(self.band_pass)
        if self._type == 'bandStop' and self.band_stop is not None:
            return visitor._band_stop(self.band_stop)


scout_compute_api_SignalFilterConfiguration.__name__ = "SignalFilterConfiguration"
scout_compute_api_SignalFilterConfiguration.__qualname__ = "SignalFilterConfiguration"
scout_compute_api_SignalFilterConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SignalFilterConfigurationVisitor:

    @abstractmethod
    def _low_pass(self, low_pass: "scout_compute_api_LowPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _high_pass(self, high_pass: "scout_compute_api_HighPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _band_pass(self, band_pass: "scout_compute_api_BandPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _band_stop(self, band_stop: "scout_compute_api_BandStopConfiguration") -> Any:
        pass


scout_compute_api_SignalFilterConfigurationVisitor.__name__ = "SignalFilterConfigurationVisitor"
scout_compute_api_SignalFilterConfigurationVisitor.__qualname__ = "SignalFilterConfigurationVisitor"
scout_compute_api_SignalFilterConfigurationVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SignalFilterSeries(ConjureBeanType):
    """Applies IIR-based signal filtering to input series. Includes low-pass, high-pass, band-pass, and band-stop
filters. Currently supports variable-order bidirectional Butterworth filters, with fixed-size padding based
on SciPy output.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'signal_filter_configuration': ConjureFieldDefinition('signalFilterConfiguration', scout_compute_api_SignalFilterConfiguration),
            'order': ConjureFieldDefinition('order', scout_compute_api_IntegerConstant),
            'sampling_frequency': ConjureFieldDefinition('samplingFrequency', OptionalTypeWrapper[scout_compute_api_DoubleConstant])
        }

    __slots__: List[str] = ['_input', '_signal_filter_configuration', '_order', '_sampling_frequency']

    def __init__(self, input: "scout_compute_api_NumericSeries", order: "scout_compute_api_IntegerConstant", signal_filter_configuration: "scout_compute_api_SignalFilterConfiguration", sampling_frequency: Optional["scout_compute_api_DoubleConstant"] = None) -> None:
        self._input = input
        self._signal_filter_configuration = signal_filter_configuration
        self._order = order
        self._sampling_frequency = sampling_frequency

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def signal_filter_configuration(self) -> "scout_compute_api_SignalFilterConfiguration":
        """Filter type and cutoff frequencies.
        """
        return self._signal_filter_configuration

    @builtins.property
    def order(self) -> "scout_compute_api_IntegerConstant":
        """Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters.
        """
        return self._order

    @builtins.property
    def sampling_frequency(self) -> Optional["scout_compute_api_DoubleConstant"]:
        """The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies.
        """
        return self._sampling_frequency


scout_compute_api_SignalFilterSeries.__name__ = "SignalFilterSeries"
scout_compute_api_SignalFilterSeries.__qualname__ = "SignalFilterSeries"
scout_compute_api_SignalFilterSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SinglePoint(ConjureBeanType):
    """Return type representing a single point value.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', scout_compute_api_Value),
            'precision_loss': ConjureFieldDefinition('precisionLoss', bool)
        }

    __slots__: List[str] = ['_timestamp', '_value', '_precision_loss']

    def __init__(self, precision_loss: bool, timestamp: "api_Timestamp", value: "scout_compute_api_Value") -> None:
        self._timestamp = timestamp
        self._value = value
        self._precision_loss = precision_loss

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> "scout_compute_api_Value":
        return self._value

    @builtins.property
    def precision_loss(self) -> bool:
        """Returns true if the result required downcasting to a type with less precision, 
for example if the input series was Int64 and the result is a Float64.
        """
        return self._precision_loss


scout_compute_api_SinglePoint.__name__ = "SinglePoint"
scout_compute_api_SinglePoint.__qualname__ = "SinglePoint"
scout_compute_api_SinglePoint.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SpatialDecimateStrategy(ConjureBeanType):
    """Decimate by spatial trees.
Creates buckets by bisecting on each dimension, creating quadrants for 2d scatter and octants for 3d scatter.
Continues subdividing by prioritizing larger undivided buckets until reaching the max amount of buckets.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_SpatialDecimateStrategy.__name__ = "SpatialDecimateStrategy"
scout_compute_api_SpatialDecimateStrategy.__qualname__ = "SpatialDecimateStrategy"
scout_compute_api_SpatialDecimateStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StabilityDetectionRanges(ConjureBeanType):
    """Outputs a set of ranges where the input series is stable. For each point, the min and max are calculated over 
the specified lookback window, including the current point. A point is considered stable if its value does 
not deviate from the calculated min and the max by more than the threshold and the total number of points
within the window is at least the specified amount. The threshold can be either fixed values or percentages 
of the value. The lookback window must be strictly positive. The minimum points threshold defaults to 2.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'window_configuration': ConjureFieldDefinition('windowConfiguration', scout_compute_api_StabilityWindowConfiguration),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_Threshold)
        }

    __slots__: List[str] = ['_input', '_window_configuration', '_threshold']

    def __init__(self, input: "scout_compute_api_NumericSeries", threshold: "scout_compute_api_Threshold", window_configuration: "scout_compute_api_StabilityWindowConfiguration") -> None:
        self._input = input
        self._window_configuration = window_configuration
        self._threshold = threshold

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def window_configuration(self) -> "scout_compute_api_StabilityWindowConfiguration":
        return self._window_configuration

    @builtins.property
    def threshold(self) -> "scout_compute_api_Threshold":
        return self._threshold


scout_compute_api_StabilityDetectionRanges.__name__ = "StabilityDetectionRanges"
scout_compute_api_StabilityDetectionRanges.__qualname__ = "StabilityDetectionRanges"
scout_compute_api_StabilityDetectionRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StabilityWindowConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[scout_compute_api_IntegerConstant]),
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    __slots__: List[str] = ['_min_points', '_duration']

    def __init__(self, duration: "scout_compute_api_DurationConstant", min_points: Optional["scout_compute_api_IntegerConstant"] = None) -> None:
        self._min_points = min_points
        self._duration = duration

    @builtins.property
    def min_points(self) -> Optional["scout_compute_api_IntegerConstant"]:
        """The minimum number of points within the window to create a stable range. Must be non-negative. If not 
present, will default to 2.
        """
        return self._min_points

    @builtins.property
    def duration(self) -> "scout_compute_api_DurationConstant":
        return self._duration


scout_compute_api_StabilityWindowConfiguration.__name__ = "StabilityWindowConfiguration"
scout_compute_api_StabilityWindowConfiguration.__qualname__ = "StabilityWindowConfiguration"
scout_compute_api_StabilityWindowConfiguration.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StaleRanges(ConjureBeanType):
    """Produces a list of ranges for which data does not exist for the specified duration or longer. Increases 
window size by the specified staleness threshold on both ends to capture edge cases of data not currently 
in view.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Series),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DurationConstant),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', OptionalTypeWrapper[scout_compute_api_TimestampConstant]),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', OptionalTypeWrapper[scout_compute_api_TimestampConstant])
        }

    __slots__: List[str] = ['_input', '_threshold', '_start_timestamp', '_end_timestamp']

    def __init__(self, input: "scout_compute_api_Series", threshold: "scout_compute_api_DurationConstant", end_timestamp: Optional["scout_compute_api_TimestampConstant"] = None, start_timestamp: Optional["scout_compute_api_TimestampConstant"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_Series":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DurationConstant":
        return self._threshold

    @builtins.property
    def start_timestamp(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """The start timestamp of the range. If not specified, staleness will automatically use view range start.
        """
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> Optional["scout_compute_api_TimestampConstant"]:
        return self._end_timestamp


scout_compute_api_StaleRanges.__name__ = "StaleRanges"
scout_compute_api_StaleRanges.__qualname__ = "StaleRanges"
scout_compute_api_StaleRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StandardDeviation(ConjureBeanType):
    """The standard deviation of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_StandardDeviation.__name__ = "StandardDeviation"
scout_compute_api_StandardDeviation.__qualname__ = "StandardDeviation"
scout_compute_api_StandardDeviation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StftOptions(ConjureBeanType):
    """Options for frequency analyses that are backed by short-time Fourier transforms.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'window': ConjureFieldDefinition('window', OptionalTypeWrapper[scout_compute_api_FftWindow]),
            'window_symmetry': ConjureFieldDefinition('windowSymmetry', OptionalTypeWrapper[scout_compute_api_WindowSymmetry]),
            'sampling_frequency': ConjureFieldDefinition('samplingFrequency', OptionalTypeWrapper[float]),
            'nperseg': ConjureFieldDefinition('nperseg', OptionalTypeWrapper[int]),
            'noverlap': ConjureFieldDefinition('noverlap', OptionalTypeWrapper[int]),
            'nfft': ConjureFieldDefinition('nfft', OptionalTypeWrapper[int]),
            'detrend': ConjureFieldDefinition('detrend', OptionalTypeWrapper[scout_compute_api_DetrendType])
        }

    __slots__: List[str] = ['_window', '_window_symmetry', '_sampling_frequency', '_nperseg', '_noverlap', '_nfft', '_detrend']

    def __init__(self, detrend: Optional["scout_compute_api_DetrendType"] = None, nfft: Optional[int] = None, noverlap: Optional[int] = None, nperseg: Optional[int] = None, sampling_frequency: Optional[float] = None, window: Optional["scout_compute_api_FftWindow"] = None, window_symmetry: Optional["scout_compute_api_WindowSymmetry"] = None) -> None:
        self._window = window
        self._window_symmetry = window_symmetry
        self._sampling_frequency = sampling_frequency
        self._nperseg = nperseg
        self._noverlap = noverlap
        self._nfft = nfft
        self._detrend = detrend

    @builtins.property
    def window(self) -> Optional["scout_compute_api_FftWindow"]:
        """Window function type to use
        """
        return self._window

    @builtins.property
    def window_symmetry(self) -> Optional["scout_compute_api_WindowSymmetry"]:
        """Either DFT_EVEN or SYMMETRIC
        """
        return self._window_symmetry

    @builtins.property
    def sampling_frequency(self) -> Optional[float]:
        """Sampling frequency of the series in Hz. If absent, will calculate using the input series.
        """
        return self._sampling_frequency

    @builtins.property
    def nperseg(self) -> Optional[int]:
        """Number of points per window segment.
        """
        return self._nperseg

    @builtins.property
    def noverlap(self) -> Optional[int]:
        """Number of points of overlap between windows. Must be less than nperseg.
        """
        return self._noverlap

    @builtins.property
    def nfft(self) -> Optional[int]:
        """Number of points to use in the FFT. Must be greater than or equal to nperseg.
        """
        return self._nfft

    @builtins.property
    def detrend(self) -> Optional["scout_compute_api_DetrendType"]:
        """Detrend the points in each window segment. If absent, will use the default detrend for that function.
        """
        return self._detrend


scout_compute_api_StftOptions.__name__ = "StftOptions"
scout_compute_api_StftOptions.__qualname__ = "StftOptions"
scout_compute_api_StftOptions.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StringConstant(ConjureUnionType):
    _literal: Optional[str] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', str),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[str] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[str]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_StringConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_StringConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_StringConstant.__name__ = "StringConstant"
scout_compute_api_StringConstant.__qualname__ = "StringConstant"
scout_compute_api_StringConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StringConstantVisitor:

    @abstractmethod
    def _literal(self, literal: str) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_StringConstantVisitor.__name__ = "StringConstantVisitor"
scout_compute_api_StringConstantVisitor.__qualname__ = "StringConstantVisitor"
scout_compute_api_StringConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StringSetConstant(ConjureUnionType):
    _literal: Optional[List[str]] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', List[str]),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional[List[str]] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional[List[str]]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_StringSetConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_StringSetConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_StringSetConstant.__name__ = "StringSetConstant"
scout_compute_api_StringSetConstant.__qualname__ = "StringSetConstant"
scout_compute_api_StringSetConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StringSetConstantVisitor:

    @abstractmethod
    def _literal(self, literal: List[str]) -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_StringSetConstantVisitor.__name__ = "StringSetConstantVisitor"
scout_compute_api_StringSetConstantVisitor.__qualname__ = "StringSetConstantVisitor"
scout_compute_api_StringSetConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StructSeries(ConjureUnionType):
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _raw: Optional["scout_compute_api_Reference"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _extract_from_struct: Optional["scout_compute_api_ExtractStructFromStructSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_api_ExtractStructFromStructSeries)
        }

    def __init__(
            self,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            raw: Optional["scout_compute_api_Reference"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            extract_from_struct: Optional["scout_compute_api_ExtractStructFromStructSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (raw is not None) + (derived is not None) + (extract_from_struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_api_ExtractStructFromStructSeries"]:
        return self._extract_from_struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_StructSeriesVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_StructSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)


scout_compute_api_StructSeries.__name__ = "StructSeries"
scout_compute_api_StructSeries.__qualname__ = "StructSeries"
scout_compute_api_StructSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_StructSeriesVisitor:

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_api_ExtractStructFromStructSeries") -> Any:
        pass


scout_compute_api_StructSeriesVisitor.__name__ = "StructSeriesVisitor"
scout_compute_api_StructSeriesVisitor.__qualname__ = "StructSeriesVisitor"
scout_compute_api_StructSeriesVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Sum(ConjureBeanType):
    """The sum of point values inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Sum.__name__ = "Sum"
scout_compute_api_Sum.__qualname__ = "Sum"
scout_compute_api_Sum.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SumSeries(ConjureBeanType):
    """For every timestamp specified in the input series, outputs a value that is the sum for that timestamp
across all input series.
Only outputs timestamps where all input series have an entry for that timestamp, or a value can be filled
using the interpolation configuration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_NumericSeries]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', OptionalTypeWrapper[scout_compute_api_InterpolationConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_api_NumericSeries"], interpolation_configuration: Optional["scout_compute_api_InterpolationConfiguration"] = None) -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_api_NumericSeries"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> Optional["scout_compute_api_InterpolationConfiguration"]:
        """Defaults to forward fill interpolation with a 1s interpolation radius
        """
        return self._interpolation_configuration


scout_compute_api_SumSeries.__name__ = "SumSeries"
scout_compute_api_SumSeries.__qualname__ = "SumSeries"
scout_compute_api_SumSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizationStrategy(ConjureUnionType):
    _decimate: Optional["scout_compute_api_DecimateStrategy"] = None
    _page: Optional["scout_compute_api_PageStrategy"] = None
    _truncate: Optional["scout_compute_api_TruncateStrategy"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'decimate': ConjureFieldDefinition('decimate', scout_compute_api_DecimateStrategy),
            'page': ConjureFieldDefinition('page', scout_compute_api_PageStrategy),
            'truncate': ConjureFieldDefinition('truncate', scout_compute_api_TruncateStrategy)
        }

    def __init__(
            self,
            decimate: Optional["scout_compute_api_DecimateStrategy"] = None,
            page: Optional["scout_compute_api_PageStrategy"] = None,
            truncate: Optional["scout_compute_api_TruncateStrategy"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (decimate is not None) + (page is not None) + (truncate is not None) != 1:
                raise ValueError('a union must contain a single member')

            if decimate is not None:
                self._decimate = decimate
                self._type = 'decimate'
            if page is not None:
                self._page = page
                self._type = 'page'
            if truncate is not None:
                self._truncate = truncate
                self._type = 'truncate'

        elif type_of_union == 'decimate':
            if decimate is None:
                raise ValueError('a union value must not be None')
            self._decimate = decimate
            self._type = 'decimate'
        elif type_of_union == 'page':
            if page is None:
                raise ValueError('a union value must not be None')
            self._page = page
            self._type = 'page'
        elif type_of_union == 'truncate':
            if truncate is None:
                raise ValueError('a union value must not be None')
            self._truncate = truncate
            self._type = 'truncate'

    @builtins.property
    def decimate(self) -> Optional["scout_compute_api_DecimateStrategy"]:
        return self._decimate

    @builtins.property
    def page(self) -> Optional["scout_compute_api_PageStrategy"]:
        """Paging is only valid for log series.
        """
        return self._page

    @builtins.property
    def truncate(self) -> Optional["scout_compute_api_TruncateStrategy"]:
        return self._truncate

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_SummarizationStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_SummarizationStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'decimate' and self.decimate is not None:
            return visitor._decimate(self.decimate)
        if self._type == 'page' and self.page is not None:
            return visitor._page(self.page)
        if self._type == 'truncate' and self.truncate is not None:
            return visitor._truncate(self.truncate)


scout_compute_api_SummarizationStrategy.__name__ = "SummarizationStrategy"
scout_compute_api_SummarizationStrategy.__qualname__ = "SummarizationStrategy"
scout_compute_api_SummarizationStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizationStrategyVisitor:

    @abstractmethod
    def _decimate(self, decimate: "scout_compute_api_DecimateStrategy") -> Any:
        pass

    @abstractmethod
    def _page(self, page: "scout_compute_api_PageStrategy") -> Any:
        pass

    @abstractmethod
    def _truncate(self, truncate: "scout_compute_api_TruncateStrategy") -> Any:
        pass


scout_compute_api_SummarizationStrategyVisitor.__name__ = "SummarizationStrategyVisitor"
scout_compute_api_SummarizationStrategyVisitor.__qualname__ = "SummarizationStrategyVisitor"
scout_compute_api_SummarizationStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizeCartesian(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Cartesian),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_CartesianBounds]),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', OptionalTypeWrapper[scout_compute_api_ScatterSummarizationStrategy]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_bounds', '_summarization_strategy', '_max_points']

    def __init__(self, input: "scout_compute_api_Cartesian", bounds: Optional["scout_compute_api_CartesianBounds"] = None, max_points: Optional[int] = None, summarization_strategy: Optional["scout_compute_api_ScatterSummarizationStrategy"] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._summarization_strategy = summarization_strategy
        self._max_points = max_points

    @builtins.property
    def input(self) -> "scout_compute_api_Cartesian":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def summarization_strategy(self) -> Optional["scout_compute_api_ScatterSummarizationStrategy"]:
        """The summarization strategy to use when there are more than `maxPoints`. Defaults to spatial.
        """
        return self._summarization_strategy

    @builtins.property
    def max_points(self) -> Optional[int]:
        """The maximum number of points to return in the response. If more points are found, a BucketedCartesianPlot
will be returned. Maximum is 10,000. Defaults to 2,000 if not specified.
        """
        return self._max_points


scout_compute_api_SummarizeCartesian.__name__ = "SummarizeCartesian"
scout_compute_api_SummarizeCartesian.__qualname__ = "SummarizeCartesian"
scout_compute_api_SummarizeCartesian.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizeCartesian3d(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Cartesian3d),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_Cartesian3dBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int]),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', OptionalTypeWrapper[scout_compute_api_ScatterSummarizationStrategy])
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points', '_summarization_strategy']

    def __init__(self, input: "scout_compute_api_Cartesian3d", bounds: Optional["scout_compute_api_Cartesian3dBounds"] = None, max_points: Optional[int] = None, summarization_strategy: Optional["scout_compute_api_ScatterSummarizationStrategy"] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points
        self._summarization_strategy = summarization_strategy

    @builtins.property
    def input(self) -> "scout_compute_api_Cartesian3d":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_Cartesian3dBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        """The maximum number of points to return in the response.
If more points are found, a BucketedCartesian3dPlot will be returned.
Maximum is 10,000. Defaults to 2,000 if not specified.
        """
        return self._max_points

    @builtins.property
    def summarization_strategy(self) -> Optional["scout_compute_api_ScatterSummarizationStrategy"]:
        """The strategy to use when summarizing the series. Only spatial decimation is supported.
        """
        return self._summarization_strategy


scout_compute_api_SummarizeCartesian3d.__name__ = "SummarizeCartesian3d"
scout_compute_api_SummarizeCartesian3d.__qualname__ = "SummarizeCartesian3d"
scout_compute_api_SummarizeCartesian3d.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizeRanges(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_RangeSeries),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_api_RangeSeries", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_api_RangeSeries":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        """The maximum number of ranges to return in the response. If more ranges are found, a RangesSummary
will be returned. Defaults to 2000 if not specified.
        """
        return self._max_ranges


scout_compute_api_SummarizeRanges.__name__ = "SummarizeRanges"
scout_compute_api_SummarizeRanges.__qualname__ = "SummarizeRanges"
scout_compute_api_SummarizeRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_SummarizeSeries(ConjureBeanType):
    """Summarizes the output of a series node. The output can be a numeric, enum, log, or cartesian series.
Summarization strategy should be specified.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Series),
            'output_format': ConjureFieldDefinition('outputFormat', OptionalTypeWrapper[scout_compute_api_OutputFormat]),
            'numeric_output_fields': ConjureFieldDefinition('numericOutputFields', OptionalTypeWrapper[List[scout_compute_api_NumericOutputField]]),
            'resolution': ConjureFieldDefinition('resolution', OptionalTypeWrapper[int]),
            'buckets': ConjureFieldDefinition('buckets', OptionalTypeWrapper[int]),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', OptionalTypeWrapper[scout_compute_api_SummarizationStrategy])
        }

    __slots__: List[str] = ['_input', '_output_format', '_numeric_output_fields', '_resolution', '_buckets', '_summarization_strategy']

    def __init__(self, input: "scout_compute_api_Series", buckets: Optional[int] = None, numeric_output_fields: Optional[List["scout_compute_api_NumericOutputField"]] = None, output_format: Optional["scout_compute_api_OutputFormat"] = None, resolution: Optional[int] = None, summarization_strategy: Optional["scout_compute_api_SummarizationStrategy"] = None) -> None:
        self._input = input
        self._output_format = output_format
        self._numeric_output_fields = numeric_output_fields
        self._resolution = resolution
        self._buckets = buckets
        self._summarization_strategy = summarization_strategy

    @builtins.property
    def input(self) -> "scout_compute_api_Series":
        return self._input

    @builtins.property
    def output_format(self) -> Optional["scout_compute_api_OutputFormat"]:
        """The output format of the response. Defaults to LEGACY.
        """
        return self._output_format

    @builtins.property
    def numeric_output_fields(self) -> Optional[List["scout_compute_api_NumericOutputField"]]:
        """The fields to output from the summarization. Applies only to Arrow format numeric series.
        """
        return self._numeric_output_fields

    @builtins.property
    def resolution(self) -> Optional[int]:
        """Resolution of the output series specifying time interval between decimated points.
Picoseconds for picosecond-granularity dataset, nanoseconds otherwise.
        """
        return self._resolution

    @builtins.property
    def buckets(self) -> Optional[int]:
        """Number of points to generate in the output series.
        """
        return self._buckets

    @builtins.property
    def summarization_strategy(self) -> Optional["scout_compute_api_SummarizationStrategy"]:
        """The strategy to use when summarizing the series.
        """
        return self._summarization_strategy


scout_compute_api_SummarizeSeries.__name__ = "SummarizeSeries"
scout_compute_api_SummarizeSeries.__qualname__ = "SummarizeSeries"
scout_compute_api_SummarizeSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Summation(ConjureBeanType):
    """The sum of points inside the time window.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_api_Summation.__name__ = "Summation"
scout_compute_api_Summation.__qualname__ = "Summation"
scout_compute_api_Summation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TagFilter(ConjureBeanType):
    """A filter on a single tag key and set of values. For an IN operator, the tag key must match at least one of the
values in the set. For a NOT_IN operator, it must not match any of the values in the set.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'key': ConjureFieldDefinition('key', scout_compute_api_StringConstant),
            'values': ConjureFieldDefinition('values', List[scout_compute_api_StringConstant]),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_TagFilterOperator)
        }

    __slots__: List[str] = ['_key', '_values', '_operator']

    def __init__(self, key: "scout_compute_api_StringConstant", operator: "scout_compute_api_TagFilterOperator", values: List["scout_compute_api_StringConstant"]) -> None:
        self._key = key
        self._values = values
        self._operator = operator

    @builtins.property
    def key(self) -> "scout_compute_api_StringConstant":
        return self._key

    @builtins.property
    def values(self) -> List["scout_compute_api_StringConstant"]:
        return self._values

    @builtins.property
    def operator(self) -> "scout_compute_api_TagFilterOperator":
        return self._operator


scout_compute_api_TagFilter.__name__ = "TagFilter"
scout_compute_api_TagFilter.__qualname__ = "TagFilter"
scout_compute_api_TagFilter.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TagFilterOperator(ConjureEnumType):

    IN = 'IN'
    '''IN'''
    NOT_IN = 'NOT_IN'
    '''NOT_IN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_TagFilterOperator.__name__ = "TagFilterOperator"
scout_compute_api_TagFilterOperator.__qualname__ = "TagFilterOperator"
scout_compute_api_TagFilterOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TagFilterValidationErrorType(ConjureEnumType):

    BOTH_TAGS_AND_TAG_FILTERS_PROVIDED = 'BOTH_TAGS_AND_TAG_FILTERS_PROVIDED'
    '''BOTH_TAGS_AND_TAG_FILTERS_PROVIDED'''
    EMPTY_FILTER_LIST = 'EMPTY_FILTER_LIST'
    '''EMPTY_FILTER_LIST'''
    EMPTY_TAG_VALUE_SET = 'EMPTY_TAG_VALUE_SET'
    '''EMPTY_TAG_VALUE_SET'''
    NESTED_AND_OPERATIONS = 'NESTED_AND_OPERATIONS'
    '''NESTED_AND_OPERATIONS'''
    DUPLICATE_TAG_KEY = 'DUPLICATE_TAG_KEY'
    '''DUPLICATE_TAG_KEY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_TagFilterValidationErrorType.__name__ = "TagFilterValidationErrorType"
scout_compute_api_TagFilterValidationErrorType.__qualname__ = "TagFilterValidationErrorType"
scout_compute_api_TagFilterValidationErrorType.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TagFilters(ConjureUnionType):
    """A set of tag filters to apply to a channel. Allows for combining filters on multiple tag keys, but throws if
any one tag key is specified in more than one filter.
    """
    _single: Optional["scout_compute_api_TagFilter"] = None
    _and_: Optional[List["scout_compute_api_TagFilters"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single': ConjureFieldDefinition('single', scout_compute_api_TagFilter),
            'and_': ConjureFieldDefinition('and', List[scout_compute_api_TagFilters])
        }

    def __init__(
            self,
            single: Optional["scout_compute_api_TagFilter"] = None,
            and_: Optional[List["scout_compute_api_TagFilters"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single is not None) + (and_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single is not None:
                self._single = single
                self._type = 'single'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'

        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'

    @builtins.property
    def single(self) -> Optional["scout_compute_api_TagFilter"]:
        return self._single

    @builtins.property
    def and_(self) -> Optional[List["scout_compute_api_TagFilters"]]:
        return self._and_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_TagFiltersVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_TagFiltersVisitor'.format(visitor.__class__.__name__))
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)


scout_compute_api_TagFilters.__name__ = "TagFilters"
scout_compute_api_TagFilters.__qualname__ = "TagFilters"
scout_compute_api_TagFilters.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TagFiltersVisitor:

    @abstractmethod
    def _single(self, single: "scout_compute_api_TagFilter") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_compute_api_TagFilters"]) -> Any:
        pass


scout_compute_api_TagFiltersVisitor.__name__ = "TagFiltersVisitor"
scout_compute_api_TagFiltersVisitor.__qualname__ = "TagFiltersVisitor"
scout_compute_api_TagFiltersVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TemporalDecimateStrategy(ConjureBeanType):
    """Buckets the input by time range into equally sized buckets.
The number of buckets is determined by the maxPoints parameter.
Returns a CartesianPlot.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_aggregation': ConjureFieldDefinition('xAggregation', scout_compute_api_ScatterTemporalAggregation),
            'y_aggregation': ConjureFieldDefinition('yAggregation', scout_compute_api_ScatterTemporalAggregation)
        }

    __slots__: List[str] = ['_x_aggregation', '_y_aggregation']

    def __init__(self, x_aggregation: "scout_compute_api_ScatterTemporalAggregation", y_aggregation: "scout_compute_api_ScatterTemporalAggregation") -> None:
        self._x_aggregation = x_aggregation
        self._y_aggregation = y_aggregation

    @builtins.property
    def x_aggregation(self) -> "scout_compute_api_ScatterTemporalAggregation":
        """The strategy to use for aggregating the x values in each bucket.
        """
        return self._x_aggregation

    @builtins.property
    def y_aggregation(self) -> "scout_compute_api_ScatterTemporalAggregation":
        """The strategy to use for aggregating the y values in each bucket.
        """
        return self._y_aggregation


scout_compute_api_TemporalDecimateStrategy.__name__ = "TemporalDecimateStrategy"
scout_compute_api_TemporalDecimateStrategy.__qualname__ = "TemporalDecimateStrategy"
scout_compute_api_TemporalDecimateStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Threshold(ConjureUnionType):
    _absolute: Optional["scout_compute_api_AbsoluteThreshold"] = None
    _percentage: Optional["scout_compute_api_PercentageThreshold"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'absolute': ConjureFieldDefinition('absolute', scout_compute_api_AbsoluteThreshold),
            'percentage': ConjureFieldDefinition('percentage', scout_compute_api_PercentageThreshold)
        }

    def __init__(
            self,
            absolute: Optional["scout_compute_api_AbsoluteThreshold"] = None,
            percentage: Optional["scout_compute_api_PercentageThreshold"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (absolute is not None) + (percentage is not None) != 1:
                raise ValueError('a union must contain a single member')

            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'
            if percentage is not None:
                self._percentage = percentage
                self._type = 'percentage'

        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'
        elif type_of_union == 'percentage':
            if percentage is None:
                raise ValueError('a union value must not be None')
            self._percentage = percentage
            self._type = 'percentage'

    @builtins.property
    def absolute(self) -> Optional["scout_compute_api_AbsoluteThreshold"]:
        return self._absolute

    @builtins.property
    def percentage(self) -> Optional["scout_compute_api_PercentageThreshold"]:
        return self._percentage

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ThresholdVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ThresholdVisitor'.format(visitor.__class__.__name__))
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)
        if self._type == 'percentage' and self.percentage is not None:
            return visitor._percentage(self.percentage)


scout_compute_api_Threshold.__name__ = "Threshold"
scout_compute_api_Threshold.__qualname__ = "Threshold"
scout_compute_api_Threshold.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ThresholdVisitor:

    @abstractmethod
    def _absolute(self, absolute: "scout_compute_api_AbsoluteThreshold") -> Any:
        pass

    @abstractmethod
    def _percentage(self, percentage: "scout_compute_api_PercentageThreshold") -> Any:
        pass


scout_compute_api_ThresholdVisitor.__name__ = "ThresholdVisitor"
scout_compute_api_ThresholdVisitor.__qualname__ = "ThresholdVisitor"
scout_compute_api_ThresholdVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ThresholdOperator(ConjureEnumType):

    GREATER_THAN = 'GREATER_THAN'
    '''GREATER_THAN'''
    GREATER_THAN_OR_EQUAL_TO = 'GREATER_THAN_OR_EQUAL_TO'
    '''GREATER_THAN_OR_EQUAL_TO'''
    LESS_THAN = 'LESS_THAN'
    '''LESS_THAN'''
    LESS_THAN_OR_EQUAL_TO = 'LESS_THAN_OR_EQUAL_TO'
    '''LESS_THAN_OR_EQUAL_TO'''
    EQUAL_TO = 'EQUAL_TO'
    '''EQUAL_TO'''
    NOT_EQUAL_TO = 'NOT_EQUAL_TO'
    '''NOT_EQUAL_TO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_ThresholdOperator.__name__ = "ThresholdOperator"
scout_compute_api_ThresholdOperator.__qualname__ = "ThresholdOperator"
scout_compute_api_ThresholdOperator.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ThresholdingRanges(ConjureBeanType):
    """Produces a list of ranges for which the threshold condition is satisfied.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_DoubleConstant),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", operator: "scout_compute_api_ThresholdOperator", threshold: "scout_compute_api_DoubleConstant", persistence_window_configuration: Optional["scout_compute_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_api_DoubleConstant":
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_ThresholdingRanges.__name__ = "ThresholdingRanges"
scout_compute_api_ThresholdingRanges.__qualname__ = "ThresholdingRanges"
scout_compute_api_ThresholdingRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimeDifferenceSeries(ConjureBeanType):
    """Outputs a new series where each value is the difference between the time of the current and previous points.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_Series),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_api_Series", time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_Series":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        """The time unit used to define the output values. Defaults to seconds if not specified.
        """
        return self._time_unit


scout_compute_api_TimeDifferenceSeries.__name__ = "TimeDifferenceSeries"
scout_compute_api_TimeDifferenceSeries.__qualname__ = "TimeDifferenceSeries"
scout_compute_api_TimeDifferenceSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimeSeriesCurveFit(ConjureBeanType):
    """Fits a curve to a series vs its timestamps.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_api_NumericSeries),
            'options': ConjureFieldDefinition('options', scout_compute_api_TimeSeriesFitOptions)
        }

    __slots__: List[str] = ['_series', '_options']

    def __init__(self, options: "scout_compute_api_TimeSeriesFitOptions", series: "scout_compute_api_NumericSeries") -> None:
        self._series = series
        self._options = options

    @builtins.property
    def series(self) -> "scout_compute_api_NumericSeries":
        """The series to fit. Timestamps will be used as x values and data as y values. The leftmost (earliest)
timestamp will be used as the value of 0, and all other timestamps will be relative to that.
        """
        return self._series

    @builtins.property
    def options(self) -> "scout_compute_api_TimeSeriesFitOptions":
        return self._options


scout_compute_api_TimeSeriesCurveFit.__name__ = "TimeSeriesCurveFit"
scout_compute_api_TimeSeriesCurveFit.__qualname__ = "TimeSeriesCurveFit"
scout_compute_api_TimeSeriesCurveFit.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimeSeriesFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        """Time unit used for the timestamps to fit against. Defaults to seconds if not specified.
        """
        return self._time_unit


scout_compute_api_TimeSeriesFitOptions.__name__ = "TimeSeriesFitOptions"
scout_compute_api_TimeSeriesFitOptions.__qualname__ = "TimeSeriesFitOptions"
scout_compute_api_TimeSeriesFitOptions.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimestampAndId(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'id': ConjureFieldDefinition('id', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_timestamp', '_id']

    def __init__(self, timestamp: "api_Timestamp", id: Optional[str] = None) -> None:
        self._timestamp = timestamp
        self._id = id

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def id(self) -> Optional[str]:
        return self._id


scout_compute_api_TimestampAndId.__name__ = "TimestampAndId"
scout_compute_api_TimestampAndId.__qualname__ = "TimestampAndId"
scout_compute_api_TimestampAndId.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimestampConstant(ConjureUnionType):
    _literal: Optional["api_Timestamp"] = None
    _variable: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', api_Timestamp),
            'variable': ConjureFieldDefinition('variable', scout_compute_api_VariableName)
        }

    def __init__(
            self,
            literal: Optional["api_Timestamp"] = None,
            variable: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (variable is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if variable is not None:
                self._variable = variable
                self._type = 'variable'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'variable':
            if variable is None:
                raise ValueError('a union value must not be None')
            self._variable = variable
            self._type = 'variable'

    @builtins.property
    def literal(self) -> Optional["api_Timestamp"]:
        return self._literal

    @builtins.property
    def variable(self) -> Optional[str]:
        return self._variable

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_TimestampConstantVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_TimestampConstantVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'variable' and self.variable is not None:
            return visitor._variable(self.variable)


scout_compute_api_TimestampConstant.__name__ = "TimestampConstant"
scout_compute_api_TimestampConstant.__qualname__ = "TimestampConstant"
scout_compute_api_TimestampConstant.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TimestampConstantVisitor:

    @abstractmethod
    def _literal(self, literal: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _variable(self, variable: str) -> Any:
        pass


scout_compute_api_TimestampConstantVisitor.__name__ = "TimestampConstantVisitor"
scout_compute_api_TimestampConstantVisitor.__qualname__ = "TimestampConstantVisitor"
scout_compute_api_TimestampConstantVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TruncateStrategy(ConjureUnionType):
    _max_points_to_return: Optional[int] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max_points_to_return': ConjureFieldDefinition('maxPointsToReturn', int)
        }

    def __init__(
            self,
            max_points_to_return: Optional[int] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (max_points_to_return is not None) != 1:
                raise ValueError('a union must contain a single member')

            if max_points_to_return is not None:
                self._max_points_to_return = max_points_to_return
                self._type = 'maxPointsToReturn'

        elif type_of_union == 'maxPointsToReturn':
            if max_points_to_return is None:
                raise ValueError('a union value must not be None')
            self._max_points_to_return = max_points_to_return
            self._type = 'maxPointsToReturn'

    @builtins.property
    def max_points_to_return(self) -> Optional[int]:
        """Maximum number of points to return before truncating, ordered by timestamp. Throws if greater than 10,000
        """
        return self._max_points_to_return

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_TruncateStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_TruncateStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'maxPointsToReturn' and self.max_points_to_return is not None:
            return visitor._max_points_to_return(self.max_points_to_return)


scout_compute_api_TruncateStrategy.__name__ = "TruncateStrategy"
scout_compute_api_TruncateStrategy.__qualname__ = "TruncateStrategy"
scout_compute_api_TruncateStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_TruncateStrategyVisitor:

    @abstractmethod
    def _max_points_to_return(self, max_points_to_return: int) -> Any:
        pass


scout_compute_api_TruncateStrategyVisitor.__name__ = "TruncateStrategyVisitor"
scout_compute_api_TruncateStrategyVisitor.__qualname__ = "TruncateStrategyVisitor"
scout_compute_api_TruncateStrategyVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnaryArithmeticOperation(ConjureEnumType):

    COS = 'COS'
    '''COS'''
    SIN = 'SIN'
    '''SIN'''
    TAN = 'TAN'
    '''TAN'''
    ABS = 'ABS'
    '''ABS'''
    ASIN = 'ASIN'
    '''ASIN'''
    ACOS = 'ACOS'
    '''ACOS'''
    LOG = 'LOG'
    '''LOG'''
    LN = 'LN'
    '''LN'''
    SQRT = 'SQRT'
    '''SQRT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_UnaryArithmeticOperation.__name__ = "UnaryArithmeticOperation"
scout_compute_api_UnaryArithmeticOperation.__qualname__ = "UnaryArithmeticOperation"
scout_compute_api_UnaryArithmeticOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnaryArithmeticSeries(ConjureBeanType):
    """Applies a point-wise transformation to a series. The transformation function is applied to every
individual data point.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_api_NumericSeries", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_api_UnaryArithmeticSeries.__name__ = "UnaryArithmeticSeries"
scout_compute_api_UnaryArithmeticSeries.__qualname__ = "UnaryArithmeticSeries"
scout_compute_api_UnaryArithmeticSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnboundedBehavior(ConjureEnumType):
    """Dictates how empty range bounds should be handled by the compute node. Defaults to INFINITY.
    """

    INFINITY = 'INFINITY'
    '''INFINITY'''
    WINDOW_BOUND = 'WINDOW_BOUND'
    '''WINDOW_BOUND'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_UnboundedBehavior.__name__ = "UnboundedBehavior"
scout_compute_api_UnboundedBehavior.__qualname__ = "UnboundedBehavior"
scout_compute_api_UnboundedBehavior.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnionRanges(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_RangeSeries])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_RangeSeries"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_RangeSeries"]:
        return self._inputs


scout_compute_api_UnionRanges.__name__ = "UnionRanges"
scout_compute_api_UnionRanges.__qualname__ = "UnionRanges"
scout_compute_api_UnionRanges.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitComputationError(ConjureUnionType):
    _incompatible_units_operation: Optional["scout_compute_api_IncompatibleUnitOperation"] = None
    _units_missing: Optional["scout_compute_api_UnitsMissing"] = None
    _error: Optional["api_SerializableError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'incompatible_units_operation': ConjureFieldDefinition('incompatibleUnitsOperation', scout_compute_api_IncompatibleUnitOperation),
            'units_missing': ConjureFieldDefinition('unitsMissing', scout_compute_api_UnitsMissing),
            'error': ConjureFieldDefinition('error', api_SerializableError)
        }

    def __init__(
            self,
            incompatible_units_operation: Optional["scout_compute_api_IncompatibleUnitOperation"] = None,
            units_missing: Optional["scout_compute_api_UnitsMissing"] = None,
            error: Optional["api_SerializableError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (incompatible_units_operation is not None) + (units_missing is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if incompatible_units_operation is not None:
                self._incompatible_units_operation = incompatible_units_operation
                self._type = 'incompatibleUnitsOperation'
            if units_missing is not None:
                self._units_missing = units_missing
                self._type = 'unitsMissing'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'incompatibleUnitsOperation':
            if incompatible_units_operation is None:
                raise ValueError('a union value must not be None')
            self._incompatible_units_operation = incompatible_units_operation
            self._type = 'incompatibleUnitsOperation'
        elif type_of_union == 'unitsMissing':
            if units_missing is None:
                raise ValueError('a union value must not be None')
            self._units_missing = units_missing
            self._type = 'unitsMissing'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def incompatible_units_operation(self) -> Optional["scout_compute_api_IncompatibleUnitOperation"]:
        return self._incompatible_units_operation

    @builtins.property
    def units_missing(self) -> Optional["scout_compute_api_UnitsMissing"]:
        return self._units_missing

    @builtins.property
    def error(self) -> Optional["api_SerializableError"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_UnitComputationErrorVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_UnitComputationErrorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'incompatibleUnitsOperation' and self.incompatible_units_operation is not None:
            return visitor._incompatible_units_operation(self.incompatible_units_operation)
        if self._type == 'unitsMissing' and self.units_missing is not None:
            return visitor._units_missing(self.units_missing)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


scout_compute_api_UnitComputationError.__name__ = "UnitComputationError"
scout_compute_api_UnitComputationError.__qualname__ = "UnitComputationError"
scout_compute_api_UnitComputationError.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitComputationErrorVisitor:

    @abstractmethod
    def _incompatible_units_operation(self, incompatible_units_operation: "scout_compute_api_IncompatibleUnitOperation") -> Any:
        pass

    @abstractmethod
    def _units_missing(self, units_missing: "scout_compute_api_UnitsMissing") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "api_SerializableError") -> Any:
        pass


scout_compute_api_UnitComputationErrorVisitor.__name__ = "UnitComputationErrorVisitor"
scout_compute_api_UnitComputationErrorVisitor.__qualname__ = "UnitComputationErrorVisitor"
scout_compute_api_UnitComputationErrorVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitConversionSeries(ConjureBeanType):
    """Convert the given series to a different unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'output_unit': ConjureFieldDefinition('outputUnit', scout_units_api_UnitSymbol)
        }

    __slots__: List[str] = ['_input', '_output_unit']

    def __init__(self, input: "scout_compute_api_NumericSeries", output_unit: str) -> None:
        self._input = input
        self._output_unit = output_unit

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def output_unit(self) -> str:
        return self._output_unit


scout_compute_api_UnitConversionSeries.__name__ = "UnitConversionSeries"
scout_compute_api_UnitConversionSeries.__qualname__ = "UnitConversionSeries"
scout_compute_api_UnitConversionSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitOperation(ConjureEnumType):

    UNIT_AS_EXPONENT = 'UNIT_AS_EXPONENT'
    '''UNIT_AS_EXPONENT'''
    NON_INTEGER_AS_EXPONENT = 'NON_INTEGER_AS_EXPONENT'
    '''NON_INTEGER_AS_EXPONENT'''
    FLOOR_DIVISION = 'FLOOR_DIVISION'
    '''FLOOR_DIVISION'''
    MODULO = 'MODULO'
    '''MODULO'''
    CROSSOVER_COMPARISON = 'CROSSOVER_COMPARISON'
    '''CROSSOVER_COMPARISON'''
    MAX = 'MAX'
    '''MAX'''
    MIN = 'MIN'
    '''MIN'''
    MEAN = 'MEAN'
    '''MEAN'''
    UNION = 'UNION'
    '''UNION'''
    ADDITION = 'ADDITION'
    '''ADDITION'''
    SUBTRACTION = 'SUBTRACTION'
    '''SUBTRACTION'''
    UNIT_CONVERSION = 'UNIT_CONVERSION'
    '''UNIT_CONVERSION'''
    COMPARISON = 'COMPARISON'
    '''COMPARISON'''
    TERNARY_OPERATOR = 'TERNARY_OPERATOR'
    '''TERNARY_OPERATOR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_UnitOperation.__name__ = "UnitOperation"
scout_compute_api_UnitOperation.__qualname__ = "UnitOperation"
scout_compute_api_UnitOperation.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitResult(ConjureUnionType):
    _success: Optional[str] = None
    _no_unit_available: Optional[List["scout_compute_api_UnitComputationError"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_units_api_UnitSymbol),
            'no_unit_available': ConjureFieldDefinition('noUnitAvailable', List[scout_compute_api_UnitComputationError])
        }

    def __init__(
            self,
            success: Optional[str] = None,
            no_unit_available: Optional[List["scout_compute_api_UnitComputationError"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (no_unit_available is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if no_unit_available is not None:
                self._no_unit_available = no_unit_available
                self._type = 'noUnitAvailable'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'noUnitAvailable':
            if no_unit_available is None:
                raise ValueError('a union value must not be None')
            self._no_unit_available = no_unit_available
            self._type = 'noUnitAvailable'

    @builtins.property
    def success(self) -> Optional[str]:
        return self._success

    @builtins.property
    def no_unit_available(self) -> Optional[List["scout_compute_api_UnitComputationError"]]:
        """The resulting values have no units associated. If this is because of an error, it is listed here.
        """
        return self._no_unit_available

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_UnitResultVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_UnitResultVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'noUnitAvailable' and self.no_unit_available is not None:
            return visitor._no_unit_available(self.no_unit_available)


scout_compute_api_UnitResult.__name__ = "UnitResult"
scout_compute_api_UnitResult.__qualname__ = "UnitResult"
scout_compute_api_UnitResult.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitResultVisitor:

    @abstractmethod
    def _success(self, success: str) -> Any:
        pass

    @abstractmethod
    def _no_unit_available(self, no_unit_available: List["scout_compute_api_UnitComputationError"]) -> Any:
        pass


scout_compute_api_UnitResultVisitor.__name__ = "UnitResultVisitor"
scout_compute_api_UnitResultVisitor.__qualname__ = "UnitResultVisitor"
scout_compute_api_UnitResultVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_UnitsMissing(ConjureBeanType):
    """At least one input is missing a unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_rids': ConjureFieldDefinition('seriesRids', List[api_LogicalSeriesRid]),
            'channels': ConjureFieldDefinition('channels', List[scout_compute_api_DataSourceAndChannel])
        }

    __slots__: List[str] = ['_series_rids', '_channels']

    def __init__(self, channels: List["scout_compute_api_DataSourceAndChannel"], series_rids: List[str]) -> None:
        self._series_rids = series_rids
        self._channels = channels

    @builtins.property
    def series_rids(self) -> List[str]:
        return self._series_rids

    @builtins.property
    def channels(self) -> List["scout_compute_api_DataSourceAndChannel"]:
        return self._channels


scout_compute_api_UnitsMissing.__name__ = "UnitsMissing"
scout_compute_api_UnitsMissing.__qualname__ = "UnitsMissing"
scout_compute_api_UnitsMissing.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Value(ConjureUnionType):
    """A single value. The type is dictated by the returned variant
    """
    _string_value: Optional[str] = None
    _float64_value: Optional[float] = None
    _int64_value: Optional[str] = None
    _array_value: Optional[List[Optional["scout_compute_api_Value"]]] = None
    _struct_value: Optional[Any] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'string_value': ConjureFieldDefinition('stringValue', str),
            'float64_value': ConjureFieldDefinition('float64Value', float),
            'int64_value': ConjureFieldDefinition('int64Value', str),
            'array_value': ConjureFieldDefinition('arrayValue', List[OptionalTypeWrapper[scout_compute_api_Value]]),
            'struct_value': ConjureFieldDefinition('structValue', object)
        }

    def __init__(
            self,
            string_value: Optional[str] = None,
            float64_value: Optional[float] = None,
            int64_value: Optional[str] = None,
            array_value: Optional[List[Optional["scout_compute_api_Value"]]] = None,
            struct_value: Optional[Any] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (string_value is not None) + (float64_value is not None) + (int64_value is not None) + (array_value is not None) + (struct_value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if string_value is not None:
                self._string_value = string_value
                self._type = 'stringValue'
            if float64_value is not None:
                self._float64_value = float64_value
                self._type = 'float64Value'
            if int64_value is not None:
                self._int64_value = int64_value
                self._type = 'int64Value'
            if array_value is not None:
                self._array_value = array_value
                self._type = 'arrayValue'
            if struct_value is not None:
                self._struct_value = struct_value
                self._type = 'structValue'

        elif type_of_union == 'stringValue':
            if string_value is None:
                raise ValueError('a union value must not be None')
            self._string_value = string_value
            self._type = 'stringValue'
        elif type_of_union == 'float64Value':
            if float64_value is None:
                raise ValueError('a union value must not be None')
            self._float64_value = float64_value
            self._type = 'float64Value'
        elif type_of_union == 'int64Value':
            if int64_value is None:
                raise ValueError('a union value must not be None')
            self._int64_value = int64_value
            self._type = 'int64Value'
        elif type_of_union == 'arrayValue':
            if array_value is None:
                raise ValueError('a union value must not be None')
            self._array_value = array_value
            self._type = 'arrayValue'
        elif type_of_union == 'structValue':
            if struct_value is None:
                raise ValueError('a union value must not be None')
            self._struct_value = struct_value
            self._type = 'structValue'

    @builtins.property
    def string_value(self) -> Optional[str]:
        return self._string_value

    @builtins.property
    def float64_value(self) -> Optional[float]:
        return self._float64_value

    @builtins.property
    def int64_value(self) -> Optional[str]:
        return self._int64_value

    @builtins.property
    def array_value(self) -> Optional[List[Optional["scout_compute_api_Value"]]]:
        return self._array_value

    @builtins.property
    def struct_value(self) -> Optional[Any]:
        """A JSON representation of the struct
        """
        return self._struct_value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_ValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_ValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'stringValue' and self.string_value is not None:
            return visitor._string_value(self.string_value)
        if self._type == 'float64Value' and self.float64_value is not None:
            return visitor._float64_value(self.float64_value)
        if self._type == 'int64Value' and self.int64_value is not None:
            return visitor._int64_value(self.int64_value)
        if self._type == 'arrayValue' and self.array_value is not None:
            return visitor._array_value(self.array_value)
        if self._type == 'structValue' and self.struct_value is not None:
            return visitor._struct_value(self.struct_value)


scout_compute_api_Value.__name__ = "Value"
scout_compute_api_Value.__qualname__ = "Value"
scout_compute_api_Value.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ValueVisitor:

    @abstractmethod
    def _string_value(self, string_value: str) -> Any:
        pass

    @abstractmethod
    def _float64_value(self, float64_value: float) -> Any:
        pass

    @abstractmethod
    def _int64_value(self, int64_value: str) -> Any:
        pass

    @abstractmethod
    def _array_value(self, array_value: List[Optional["scout_compute_api_Value"]]) -> Any:
        pass

    @abstractmethod
    def _struct_value(self, struct_value: Any) -> Any:
        pass


scout_compute_api_ValueVisitor.__name__ = "ValueVisitor"
scout_compute_api_ValueVisitor.__qualname__ = "ValueVisitor"
scout_compute_api_ValueVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ValueDifferenceSeries(ConjureBeanType):
    """Outputs a new series where each value is the difference between the values of the current and previous point.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_NumericSeries", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        """Defines the strategy for handling negative output values. Defaults to allowNegativeValues if not specified.
        """
        return self._negative_values_configuration


scout_compute_api_ValueDifferenceSeries.__name__ = "ValueDifferenceSeries"
scout_compute_api_ValueDifferenceSeries.__qualname__ = "ValueDifferenceSeries"
scout_compute_api_ValueDifferenceSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ValueMapSeries(ConjureBeanType):
    """Maps a continuous numeric series to a discrete enum series using the specified value ranges.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_NumericSeries),
            'mapping': ConjureFieldDefinition('mapping', List[scout_compute_api_RangeMap]),
            'default': ConjureFieldDefinition('default', OptionalTypeWrapper[scout_compute_api_StringConstant])
        }

    __slots__: List[str] = ['_input', '_mapping', '_default']

    def __init__(self, input: "scout_compute_api_NumericSeries", mapping: List["scout_compute_api_RangeMap"], default: Optional["scout_compute_api_StringConstant"] = None) -> None:
        self._input = input
        self._mapping = mapping
        self._default = default

    @builtins.property
    def input(self) -> "scout_compute_api_NumericSeries":
        """The input series to map to an enumerated series
        """
        return self._input

    @builtins.property
    def mapping(self) -> List["scout_compute_api_RangeMap"]:
        """The output of the first capturing range will be used. Ranges are start inclusive, end exclusive, must not overlap,
and increasing from lowest to highest. Ranges can be open ended to the edge of the next or prior range.
The first range can be open ended to negative infinity, and the last range can be open ended to positive infinity.
        """
        return self._mapping

    @builtins.property
    def default(self) -> Optional["scout_compute_api_StringConstant"]:
        """The default value if not captured by any range. If not specified, points will be filtered.
        """
        return self._default


scout_compute_api_ValueMapSeries.__name__ = "ValueMapSeries"
scout_compute_api_ValueMapSeries.__qualname__ = "ValueMapSeries"
scout_compute_api_ValueMapSeries.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_ValueStrategy(ConjureEnumType):

    FIRST = 'FIRST'
    '''FIRST'''
    LAST = 'LAST'
    '''LAST'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_ValueStrategy.__name__ = "ValueStrategy"
scout_compute_api_ValueStrategy.__qualname__ = "ValueStrategy"
scout_compute_api_ValueStrategy.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_VariableValue(ConjureUnionType):
    _double: Optional[float] = None
    _compute_node: Optional["scout_compute_api_ComputeNodeWithContext"] = None
    _duration: Optional["scout_run_api_Duration"] = None
    _integer: Optional[int] = None
    _channel: Optional["scout_compute_api_ChannelSeries"] = None
    _derived: Optional["scout_compute_api_DerivedSeries"] = None
    _string: Optional[str] = None
    _string_set: Optional[List[str]] = None
    _timestamp: Optional["api_Timestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', float),
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_ComputeNodeWithContext),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration),
            'integer': ConjureFieldDefinition('integer', int),
            'channel': ConjureFieldDefinition('channel', scout_compute_api_ChannelSeries),
            'derived': ConjureFieldDefinition('derived', scout_compute_api_DerivedSeries),
            'string': ConjureFieldDefinition('string', str),
            'string_set': ConjureFieldDefinition('stringSet', List[str]),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    def __init__(
            self,
            double: Optional[float] = None,
            compute_node: Optional["scout_compute_api_ComputeNodeWithContext"] = None,
            duration: Optional["scout_run_api_Duration"] = None,
            integer: Optional[int] = None,
            channel: Optional["scout_compute_api_ChannelSeries"] = None,
            derived: Optional["scout_compute_api_DerivedSeries"] = None,
            string: Optional[str] = None,
            string_set: Optional[List[str]] = None,
            timestamp: Optional["api_Timestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (compute_node is not None) + (duration is not None) + (integer is not None) + (channel is not None) + (derived is not None) + (string is not None) + (string_set is not None) + (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if compute_node is not None:
                self._compute_node = compute_node
                self._type = 'computeNode'
            if duration is not None:
                self._duration = duration
                self._type = 'duration'
            if integer is not None:
                self._integer = integer
                self._type = 'integer'
            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if derived is not None:
                self._derived = derived
                self._type = 'derived'
            if string is not None:
                self._string = string
                self._type = 'string'
            if string_set is not None:
                self._string_set = string_set
                self._type = 'stringSet'
            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'computeNode':
            if compute_node is None:
                raise ValueError('a union value must not be None')
            self._compute_node = compute_node
            self._type = 'computeNode'
        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'
        elif type_of_union == 'integer':
            if integer is None:
                raise ValueError('a union value must not be None')
            self._integer = integer
            self._type = 'integer'
        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'derived':
            if derived is None:
                raise ValueError('a union value must not be None')
            self._derived = derived
            self._type = 'derived'
        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'
        elif type_of_union == 'stringSet':
            if string_set is None:
                raise ValueError('a union value must not be None')
            self._string_set = string_set
            self._type = 'stringSet'
        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def double(self) -> Optional[float]:
        return self._double

    @builtins.property
    def compute_node(self) -> Optional["scout_compute_api_ComputeNodeWithContext"]:
        return self._compute_node

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    @builtins.property
    def integer(self) -> Optional[int]:
        return self._integer

    @builtins.property
    def channel(self) -> Optional["scout_compute_api_ChannelSeries"]:
        return self._channel

    @builtins.property
    def derived(self) -> Optional["scout_compute_api_DerivedSeries"]:
        return self._derived

    @builtins.property
    def string(self) -> Optional[str]:
        return self._string

    @builtins.property
    def string_set(self) -> Optional[List[str]]:
        return self._string_set

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_VariableValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_VariableValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'computeNode' and self.compute_node is not None:
            return visitor._compute_node(self.compute_node)
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)
        if self._type == 'integer' and self.integer is not None:
            return visitor._integer(self.integer)
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'derived' and self.derived is not None:
            return visitor._derived(self.derived)
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)
        if self._type == 'stringSet' and self.string_set is not None:
            return visitor._string_set(self.string_set)
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_compute_api_VariableValue.__name__ = "VariableValue"
scout_compute_api_VariableValue.__qualname__ = "VariableValue"
scout_compute_api_VariableValue.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_VariableValueVisitor:

    @abstractmethod
    def _double(self, double: float) -> Any:
        pass

    @abstractmethod
    def _compute_node(self, compute_node: "scout_compute_api_ComputeNodeWithContext") -> Any:
        pass

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass

    @abstractmethod
    def _integer(self, integer: int) -> Any:
        pass

    @abstractmethod
    def _channel(self, channel: "scout_compute_api_ChannelSeries") -> Any:
        pass

    @abstractmethod
    def _derived(self, derived: "scout_compute_api_DerivedSeries") -> Any:
        pass

    @abstractmethod
    def _string(self, string: str) -> Any:
        pass

    @abstractmethod
    def _string_set(self, string_set: List[str]) -> Any:
        pass

    @abstractmethod
    def _timestamp(self, timestamp: "api_Timestamp") -> Any:
        pass


scout_compute_api_VariableValueVisitor.__name__ = "VariableValueVisitor"
scout_compute_api_VariableValueVisitor.__qualname__ = "VariableValueVisitor"
scout_compute_api_VariableValueVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_Window(ConjureUnionType):
    _duration: Optional["scout_compute_api_DurationConstant"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_compute_api_DurationConstant)
        }

    def __init__(
            self,
            duration: Optional["scout_compute_api_DurationConstant"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration is not None:
                self._duration = duration
                self._type = 'duration'

        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'

    @builtins.property
    def duration(self) -> Optional["scout_compute_api_DurationConstant"]:
        return self._duration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_WindowVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_WindowVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)


scout_compute_api_Window.__name__ = "Window"
scout_compute_api_Window.__qualname__ = "Window"
scout_compute_api_Window.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_WindowVisitor:

    @abstractmethod
    def _duration(self, duration: "scout_compute_api_DurationConstant") -> Any:
        pass


scout_compute_api_WindowVisitor.__name__ = "WindowVisitor"
scout_compute_api_WindowVisitor.__qualname__ = "WindowVisitor"
scout_compute_api_WindowVisitor.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_WindowSymmetry(ConjureEnumType):

    DFT_EVEN = 'DFT_EVEN'
    '''DFT_EVEN'''
    SYMMETRIC = 'SYMMETRIC'
    '''SYMMETRIC'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_api_WindowSymmetry.__name__ = "WindowSymmetry"
scout_compute_api_WindowSymmetry.__qualname__ = "WindowSymmetry"
scout_compute_api_WindowSymmetry.__module__ = "nominal_api.scout_compute_api"


class scout_compute_api_deprecated_ArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_api_deprecated_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str)
        }

    __slots__: List[str] = ['_inputs', '_expression']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_api_deprecated_NumericSeriesNode"]) -> None:
        self._inputs = inputs
        self._expression = expression

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression


scout_compute_api_deprecated_ArithmeticSeriesNode.__name__ = "ArithmeticSeriesNode"
scout_compute_api_deprecated_ArithmeticSeriesNode.__qualname__ = "ArithmeticSeriesNode"
scout_compute_api_deprecated_ArithmeticSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_BitOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_api_deprecated_BitOperationSeriesNode.__name__ = "BitOperationSeriesNode"
scout_compute_api_deprecated_BitOperationSeriesNode.__qualname__ = "BitOperationSeriesNode"
scout_compute_api_deprecated_BitOperationSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianBounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: float, max_y: float, min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y


scout_compute_api_deprecated_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_api_deprecated_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_api_deprecated_CartesianBounds.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianNode(ConjureUnionType):
    _scatter: Optional["scout_compute_api_deprecated_ScatterNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_api_deprecated_ScatterNode)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_api_deprecated_ScatterNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_api_deprecated_ScatterNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_CartesianNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_CartesianNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_api_deprecated_CartesianNode.__name__ = "CartesianNode"
scout_compute_api_deprecated_CartesianNode.__qualname__ = "CartesianNode"
scout_compute_api_deprecated_CartesianNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CartesianNodeVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_api_deprecated_ScatterNode") -> Any:
        pass


scout_compute_api_deprecated_CartesianNodeVisitor.__name__ = "CartesianNodeVisitor"
scout_compute_api_deprecated_CartesianNodeVisitor.__qualname__ = "CartesianNodeVisitor"
scout_compute_api_deprecated_CartesianNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ComputableNode(ConjureUnionType):
    _ranges: Optional["scout_compute_api_deprecated_SummarizeRangesNode"] = None
    _series: Optional["scout_compute_api_deprecated_SummarizeSeriesNode"] = None
    _value: Optional["scout_compute_api_deprecated_SelectValueNode"] = None
    _cartesian: Optional["scout_compute_api_deprecated_SummarizeCartesianNode"] = None
    _frequency: Optional["scout_compute_api_deprecated_FrequencyDomainNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_api_deprecated_SummarizeRangesNode),
            'series': ConjureFieldDefinition('series', scout_compute_api_deprecated_SummarizeSeriesNode),
            'value': ConjureFieldDefinition('value', scout_compute_api_deprecated_SelectValueNode),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_api_deprecated_SummarizeCartesianNode),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_api_deprecated_FrequencyDomainNode)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_api_deprecated_SummarizeRangesNode"] = None,
            series: Optional["scout_compute_api_deprecated_SummarizeSeriesNode"] = None,
            value: Optional["scout_compute_api_deprecated_SelectValueNode"] = None,
            cartesian: Optional["scout_compute_api_deprecated_SummarizeCartesianNode"] = None,
            frequency: Optional["scout_compute_api_deprecated_FrequencyDomainNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (frequency is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_api_deprecated_SummarizeRangesNode"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_api_deprecated_SummarizeSeriesNode"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_api_deprecated_SelectValueNode"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_api_deprecated_SummarizeCartesianNode"]:
        return self._cartesian

    @builtins.property
    def frequency(self) -> Optional["scout_compute_api_deprecated_FrequencyDomainNode"]:
        return self._frequency

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_ComputableNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_ComputableNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)


scout_compute_api_deprecated_ComputableNode.__name__ = "ComputableNode"
scout_compute_api_deprecated_ComputableNode.__qualname__ = "ComputableNode"
scout_compute_api_deprecated_ComputableNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ComputableNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_api_deprecated_SummarizeRangesNode") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_api_deprecated_SummarizeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_api_deprecated_SelectValueNode") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_api_deprecated_SummarizeCartesianNode") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_api_deprecated_FrequencyDomainNode") -> Any:
        pass


scout_compute_api_deprecated_ComputableNodeVisitor.__name__ = "ComputableNodeVisitor"
scout_compute_api_deprecated_ComputableNodeVisitor.__qualname__ = "ComputableNodeVisitor"
scout_compute_api_deprecated_ComputableNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_CumulativeSumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', scout_compute_api_VariableName)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", start_timestamp: str) -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> str:
        return self._start_timestamp


scout_compute_api_deprecated_CumulativeSumSeriesNode.__name__ = "CumulativeSumSeriesNode"
scout_compute_api_deprecated_CumulativeSumSeriesNode.__qualname__ = "CumulativeSumSeriesNode"
scout_compute_api_deprecated_CumulativeSumSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_DerivativeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_api_deprecated_DerivativeSeriesNode.__name__ = "DerivativeSeriesNode"
scout_compute_api_deprecated_DerivativeSeriesNode.__qualname__ = "DerivativeSeriesNode"
scout_compute_api_deprecated_DerivativeSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumFilterRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', List[str]),
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_deprecated_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_min_points', '_min_duration', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_EnumSeriesNode", operator: "scout_compute_api_EnumFilterOperator", values: List[str], min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None, persistence_window_configuration: Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._min_points = min_points
        self._min_duration = min_duration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> List[str]:
        return self._values

    @builtins.property
    def min_points(self) -> Optional[int]:
        """The minimum number of points for which this condition is satisfied. Must be non-negative. If not present,
will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        """The minimum duration for which this condition is satisfied. Must be non-negative. If not present, will
default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_deprecated_EnumFilterRangesNode.__name__ = "EnumFilterRangesNode"
scout_compute_api_deprecated_EnumFilterRangesNode.__qualname__ = "EnumFilterRangesNode"
scout_compute_api_deprecated_EnumFilterRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_Reference"] = None
    _time_range_filter: Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_deprecated_EnumTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_deprecated_EnumUnionSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_Reference"] = None,
            time_range_filter: Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_deprecated_EnumTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_deprecated_EnumUnionSeriesNode"]:
        return self._union

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_EnumSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_EnumSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)


scout_compute_api_deprecated_EnumSeriesNode.__name__ = "EnumSeriesNode"
scout_compute_api_deprecated_EnumSeriesNode.__qualname__ = "EnumSeriesNode"
scout_compute_api_deprecated_EnumSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_deprecated_EnumTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_deprecated_EnumUnionSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_EnumSeriesNodeVisitor.__name__ = "EnumSeriesNodeVisitor"
scout_compute_api_deprecated_EnumSeriesNodeVisitor.__qualname__ = "EnumSeriesNodeVisitor"
scout_compute_api_deprecated_EnumSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_deprecated_EnumSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__name__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__qualname__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_EnumTimeRangeFilterSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_EnumSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_api_deprecated_EnumSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_EnumSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__name__ = "EnumTimeShiftSeriesNode"
scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__qualname__ = "EnumTimeShiftSeriesNode"
scout_compute_api_deprecated_EnumTimeShiftSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_EnumUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_deprecated_EnumSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_deprecated_EnumSeriesNode"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_deprecated_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        return self._operation


scout_compute_api_deprecated_EnumUnionSeriesNode.__name__ = "EnumUnionSeriesNode"
scout_compute_api_deprecated_EnumUnionSeriesNode.__qualname__ = "EnumUnionSeriesNode"
scout_compute_api_deprecated_EnumUnionSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FftNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input


scout_compute_api_deprecated_FftNode.__name__ = "FftNode"
scout_compute_api_deprecated_FftNode.__qualname__ = "FftNode"
scout_compute_api_deprecated_FftNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FrequencyDomainNode(ConjureUnionType):
    _fft: Optional["scout_compute_api_deprecated_FftNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_api_deprecated_FftNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_api_deprecated_FftNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'

    @builtins.property
    def fft(self) -> Optional["scout_compute_api_deprecated_FftNode"]:
        return self._fft

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_FrequencyDomainNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_FrequencyDomainNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)


scout_compute_api_deprecated_FrequencyDomainNode.__name__ = "FrequencyDomainNode"
scout_compute_api_deprecated_FrequencyDomainNode.__qualname__ = "FrequencyDomainNode"
scout_compute_api_deprecated_FrequencyDomainNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_FrequencyDomainNodeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_api_deprecated_FftNode") -> Any:
        pass


scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__name__ = "FrequencyDomainNodeVisitor"
scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__qualname__ = "FrequencyDomainNodeVisitor"
scout_compute_api_deprecated_FrequencyDomainNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_IntersectRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_deprecated_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_deprecated_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_deprecated_RangesNode"]:
        return self._inputs


scout_compute_api_deprecated_IntersectRangesNode.__name__ = "IntersectRangesNode"
scout_compute_api_deprecated_IntersectRangesNode.__qualname__ = "IntersectRangesNode"
scout_compute_api_deprecated_IntersectRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_Reference"] = None
    _arithmetic: Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"] = None
    _bit_operation: Optional["scout_compute_api_deprecated_BitOperationSeriesNode"] = None
    _cumulative_sum: Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"] = None
    _derivative: Optional["scout_compute_api_deprecated_DerivativeSeriesNode"] = None
    _rolling_operation: Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"] = None
    _unary_arithmetic: Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"] = None
    _time_difference: Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"] = None
    _value_difference: Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_api_deprecated_ArithmeticSeriesNode),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_api_deprecated_BitOperationSeriesNode),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_api_deprecated_CumulativeSumSeriesNode),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_api_deprecated_DerivativeSeriesNode),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_api_deprecated_RollingOperationSeriesNode),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_api_deprecated_UnaryArithmeticSeriesNode),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_api_deprecated_TimeDifferenceSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_api_deprecated_NumericTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_api_deprecated_NumericUnionSeriesNode),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_api_deprecated_ValueDifferenceSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_Reference"] = None,
            arithmetic: Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"] = None,
            bit_operation: Optional["scout_compute_api_deprecated_BitOperationSeriesNode"] = None,
            cumulative_sum: Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"] = None,
            derivative: Optional["scout_compute_api_deprecated_DerivativeSeriesNode"] = None,
            rolling_operation: Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"] = None,
            unary_arithmetic: Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"] = None,
            time_difference: Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"] = None,
            value_difference: Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (arithmetic is not None) + (bit_operation is not None) + (cumulative_sum is not None) + (derivative is not None) + (rolling_operation is not None) + (unary_arithmetic is not None) + (time_difference is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (value_difference is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_api_deprecated_ArithmeticSeriesNode"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_api_deprecated_BitOperationSeriesNode"]:
        return self._bit_operation

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_api_deprecated_CumulativeSumSeriesNode"]:
        return self._cumulative_sum

    @builtins.property
    def derivative(self) -> Optional["scout_compute_api_deprecated_DerivativeSeriesNode"]:
        return self._derivative

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_api_deprecated_RollingOperationSeriesNode"]:
        return self._rolling_operation

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_api_deprecated_UnaryArithmeticSeriesNode"]:
        return self._unary_arithmetic

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_api_deprecated_TimeDifferenceSeriesNode"]:
        return self._time_difference

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_api_deprecated_NumericTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_api_deprecated_NumericUnionSeriesNode"]:
        return self._union

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_api_deprecated_ValueDifferenceSeriesNode"]:
        return self._value_difference

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_NumericSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_NumericSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)


scout_compute_api_deprecated_NumericSeriesNode.__name__ = "NumericSeriesNode"
scout_compute_api_deprecated_NumericSeriesNode.__qualname__ = "NumericSeriesNode"
scout_compute_api_deprecated_NumericSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_api_deprecated_ArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_api_deprecated_BitOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_api_deprecated_CumulativeSumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_api_deprecated_DerivativeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_api_deprecated_RollingOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_api_deprecated_UnaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_api_deprecated_TimeDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_api_deprecated_NumericTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_api_deprecated_NumericUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_api_deprecated_ValueDifferenceSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_NumericSeriesNodeVisitor.__name__ = "NumericSeriesNodeVisitor"
scout_compute_api_deprecated_NumericSeriesNodeVisitor.__qualname__ = "NumericSeriesNodeVisitor"
scout_compute_api_deprecated_NumericSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__name__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__qualname__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_api_deprecated_NumericTimeRangeFilterSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__name__ = "NumericTimeShiftSeriesNode"
scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__qualname__ = "NumericTimeShiftSeriesNode"
scout_compute_api_deprecated_NumericTimeShiftSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_NumericUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_api_deprecated_NumericSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_api_deprecated_NumericSeriesNode"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        return self._operation


scout_compute_api_deprecated_NumericUnionSeriesNode.__name__ = "NumericUnionSeriesNode"
scout_compute_api_deprecated_NumericUnionSeriesNode.__qualname__ = "NumericUnionSeriesNode"
scout_compute_api_deprecated_NumericUnionSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_OnChangeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input


scout_compute_api_deprecated_OnChangeRangesNode.__name__ = "OnChangeRangesNode"
scout_compute_api_deprecated_OnChangeRangesNode.__qualname__ = "OnChangeRangesNode"
scout_compute_api_deprecated_OnChangeRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_PersistenceWindowConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional[int]:
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        return self._output_range_start


scout_compute_api_deprecated_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_api_deprecated_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_api_deprecated_PersistenceWindowConfiguration.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RangesNode(ConjureUnionType):
    _on_change: Optional["scout_compute_api_deprecated_OnChangeRangesNode"] = None
    _enum_filter: Optional["scout_compute_api_deprecated_EnumFilterRangesNode"] = None
    _threshold: Optional["scout_compute_api_deprecated_ThresholdingRangesNode"] = None
    _union_range: Optional["scout_compute_api_deprecated_UnionRangesNode"] = None
    _intersect_range: Optional["scout_compute_api_deprecated_IntersectRangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'on_change': ConjureFieldDefinition('onChange', scout_compute_api_deprecated_OnChangeRangesNode),
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_api_deprecated_EnumFilterRangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_api_deprecated_ThresholdingRangesNode),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_api_deprecated_UnionRangesNode),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_api_deprecated_IntersectRangesNode)
        }

    def __init__(
            self,
            on_change: Optional["scout_compute_api_deprecated_OnChangeRangesNode"] = None,
            enum_filter: Optional["scout_compute_api_deprecated_EnumFilterRangesNode"] = None,
            threshold: Optional["scout_compute_api_deprecated_ThresholdingRangesNode"] = None,
            union_range: Optional["scout_compute_api_deprecated_UnionRangesNode"] = None,
            intersect_range: Optional["scout_compute_api_deprecated_IntersectRangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (on_change is not None) + (enum_filter is not None) + (threshold is not None) + (union_range is not None) + (intersect_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'

        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'

    @builtins.property
    def on_change(self) -> Optional["scout_compute_api_deprecated_OnChangeRangesNode"]:
        return self._on_change

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_api_deprecated_EnumFilterRangesNode"]:
        return self._enum_filter

    @builtins.property
    def threshold(self) -> Optional["scout_compute_api_deprecated_ThresholdingRangesNode"]:
        return self._threshold

    @builtins.property
    def union_range(self) -> Optional["scout_compute_api_deprecated_UnionRangesNode"]:
        return self._union_range

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_api_deprecated_IntersectRangesNode"]:
        return self._intersect_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_RangesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_RangesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)


scout_compute_api_deprecated_RangesNode.__name__ = "RangesNode"
scout_compute_api_deprecated_RangesNode.__qualname__ = "RangesNode"
scout_compute_api_deprecated_RangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RangesNodeVisitor:

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_api_deprecated_OnChangeRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_api_deprecated_EnumFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_api_deprecated_ThresholdingRangesNode") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_api_deprecated_UnionRangesNode") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_api_deprecated_IntersectRangesNode") -> Any:
        pass


scout_compute_api_deprecated_RangesNodeVisitor.__name__ = "RangesNodeVisitor"
scout_compute_api_deprecated_RangesNodeVisitor.__qualname__ = "RangesNodeVisitor"
scout_compute_api_deprecated_RangesNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_RollingOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', scout_compute_api_deprecated_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operator: "scout_compute_api_RollingOperator", window: "scout_compute_api_deprecated_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_api_deprecated_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_api_deprecated_RollingOperationSeriesNode.__name__ = "RollingOperationSeriesNode"
scout_compute_api_deprecated_RollingOperationSeriesNode.__qualname__ = "RollingOperationSeriesNode"
scout_compute_api_deprecated_RollingOperationSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ScatterNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_api_deprecated_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_api_deprecated_NumericSeriesNode)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_api_deprecated_NumericSeriesNode", y: "scout_compute_api_deprecated_NumericSeriesNode") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._y


scout_compute_api_deprecated_ScatterNode.__name__ = "ScatterNode"
scout_compute_api_deprecated_ScatterNode.__qualname__ = "ScatterNode"
scout_compute_api_deprecated_ScatterNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SelectValueNode(ConjureUnionType):
    _first_point: Optional["scout_compute_api_deprecated_SeriesNode"] = None
    _first_range: Optional["scout_compute_api_deprecated_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_api_deprecated_SeriesNode),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_api_deprecated_RangesNode)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_api_deprecated_SeriesNode"] = None,
            first_range: Optional["scout_compute_api_deprecated_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_api_deprecated_SeriesNode"]:
        return self._first_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_api_deprecated_RangesNode"]:
        return self._first_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_SelectValueNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_SelectValueNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)


scout_compute_api_deprecated_SelectValueNode.__name__ = "SelectValueNode"
scout_compute_api_deprecated_SelectValueNode.__qualname__ = "SelectValueNode"
scout_compute_api_deprecated_SelectValueNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SelectValueNodeVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_api_deprecated_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_api_deprecated_RangesNode") -> Any:
        pass


scout_compute_api_deprecated_SelectValueNodeVisitor.__name__ = "SelectValueNodeVisitor"
scout_compute_api_deprecated_SelectValueNodeVisitor.__qualname__ = "SelectValueNodeVisitor"
scout_compute_api_deprecated_SelectValueNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_api_Reference"] = None
    _enum: Optional["scout_compute_api_deprecated_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_api_deprecated_NumericSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_api_Reference),
            'enum': ConjureFieldDefinition('enum', scout_compute_api_deprecated_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_api_deprecated_NumericSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_api_Reference"] = None,
            enum: Optional["scout_compute_api_deprecated_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_api_deprecated_NumericSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'

    @builtins.property
    def raw(self) -> Optional["scout_compute_api_Reference"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_api_deprecated_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_api_deprecated_NumericSeriesNode"]:
        return self._numeric

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_SeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_SeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)


scout_compute_api_deprecated_SeriesNode.__name__ = "SeriesNode"
scout_compute_api_deprecated_SeriesNode.__qualname__ = "SeriesNode"
scout_compute_api_deprecated_SeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_api_Reference") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_api_deprecated_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_api_deprecated_NumericSeriesNode") -> Any:
        pass


scout_compute_api_deprecated_SeriesNodeVisitor.__name__ = "SeriesNodeVisitor"
scout_compute_api_deprecated_SeriesNodeVisitor.__qualname__ = "SeriesNodeVisitor"
scout_compute_api_deprecated_SeriesNodeVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeCartesianNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_CartesianNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_api_deprecated_CartesianBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points']

    def __init__(self, input: "scout_compute_api_deprecated_CartesianNode", bounds: Optional["scout_compute_api_deprecated_CartesianBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_CartesianNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_api_deprecated_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        return self._max_points


scout_compute_api_deprecated_SummarizeCartesianNode.__name__ = "SummarizeCartesianNode"
scout_compute_api_deprecated_SummarizeCartesianNode.__qualname__ = "SummarizeCartesianNode"
scout_compute_api_deprecated_SummarizeCartesianNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_RangesNode),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_api_deprecated_RangesNode", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_RangesNode":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        return self._max_ranges


scout_compute_api_deprecated_SummarizeRangesNode.__name__ = "SummarizeRangesNode"
scout_compute_api_deprecated_SummarizeRangesNode.__qualname__ = "SummarizeRangesNode"
scout_compute_api_deprecated_SummarizeRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_SummarizeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode),
            'resolution': ConjureFieldDefinition('resolution', int)
        }

    __slots__: List[str] = ['_input', '_resolution']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode", resolution: int) -> None:
        self._input = input
        self._resolution = resolution

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input

    @builtins.property
    def resolution(self) -> int:
        return self._resolution


scout_compute_api_deprecated_SummarizeSeriesNode.__name__ = "SummarizeSeriesNode"
scout_compute_api_deprecated_SummarizeSeriesNode.__qualname__ = "SummarizeSeriesNode"
scout_compute_api_deprecated_SummarizeSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ThresholdingRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_api_deprecated_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_min_points', '_min_duration', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operator: "scout_compute_api_ThresholdOperator", threshold: float, min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None, persistence_window_configuration: Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._min_points = min_points
        self._min_duration = min_duration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> float:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def min_points(self) -> Optional[int]:
        """The minimum number of points for which this condition is satisfied. Must be non-negative. If not present,
will default to 1.
        """
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        """The minimum duration for which this condition is satisfied. Must be non-negative. If not present, will
default to 1 nanosecond.
        """
        return self._min_duration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_api_deprecated_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_api_deprecated_ThresholdingRangesNode.__name__ = "ThresholdingRangesNode"
scout_compute_api_deprecated_ThresholdingRangesNode.__qualname__ = "ThresholdingRangesNode"
scout_compute_api_deprecated_ThresholdingRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_TimeDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_api_deprecated_SeriesNode", time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit


scout_compute_api_deprecated_TimeDifferenceSeriesNode.__name__ = "TimeDifferenceSeriesNode"
scout_compute_api_deprecated_TimeDifferenceSeriesNode.__qualname__ = "TimeDifferenceSeriesNode"
scout_compute_api_deprecated_TimeDifferenceSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_UnaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__name__ = "UnaryArithmeticSeriesNode"
scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__qualname__ = "UnaryArithmeticSeriesNode"
scout_compute_api_deprecated_UnaryArithmeticSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_UnionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_api_deprecated_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_api_deprecated_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_api_deprecated_RangesNode"]:
        return self._inputs


scout_compute_api_deprecated_UnionRangesNode.__name__ = "UnionRangesNode"
scout_compute_api_deprecated_UnionRangesNode.__qualname__ = "UnionRangesNode"
scout_compute_api_deprecated_UnionRangesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_ValueDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_api_deprecated_NumericSeriesNode),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_api_deprecated_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_api_deprecated_NumericSeriesNode":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_api_deprecated_ValueDifferenceSeriesNode.__name__ = "ValueDifferenceSeriesNode"
scout_compute_api_deprecated_ValueDifferenceSeriesNode.__qualname__ = "ValueDifferenceSeriesNode"
scout_compute_api_deprecated_ValueDifferenceSeriesNode.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_VariableValue(ConjureUnionType):
    _timestamp: Optional["api_Timestamp"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp)
        }

    def __init__(
            self,
            timestamp: Optional["api_Timestamp"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timestamp is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timestamp is not None:
                self._timestamp = timestamp
                self._type = 'timestamp'

        elif type_of_union == 'timestamp':
            if timestamp is None:
                raise ValueError('a union value must not be None')
            self._timestamp = timestamp
            self._type = 'timestamp'

    @builtins.property
    def timestamp(self) -> Optional["api_Timestamp"]:
        return self._timestamp

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_VariableValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_VariableValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timestamp' and self.timestamp is not None:
            return visitor._timestamp(self.timestamp)


scout_compute_api_deprecated_VariableValue.__name__ = "VariableValue"
scout_compute_api_deprecated_VariableValue.__qualname__ = "VariableValue"
scout_compute_api_deprecated_VariableValue.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_VariableValueVisitor:

    @abstractmethod
    def _timestamp(self, timestamp: "api_Timestamp") -> Any:
        pass


scout_compute_api_deprecated_VariableValueVisitor.__name__ = "VariableValueVisitor"
scout_compute_api_deprecated_VariableValueVisitor.__qualname__ = "VariableValueVisitor"
scout_compute_api_deprecated_VariableValueVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_Window(ConjureUnionType):
    _duration: Optional["scout_run_api_Duration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    def __init__(
            self,
            duration: Optional["scout_run_api_Duration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration is not None:
                self._duration = duration
                self._type = 'duration'

        elif type_of_union == 'duration':
            if duration is None:
                raise ValueError('a union value must not be None')
            self._duration = duration
            self._type = 'duration'

    @builtins.property
    def duration(self) -> Optional["scout_run_api_Duration"]:
        return self._duration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_api_deprecated_WindowVisitor):
            raise ValueError('{} is not an instance of scout_compute_api_deprecated_WindowVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duration' and self.duration is not None:
            return visitor._duration(self.duration)


scout_compute_api_deprecated_Window.__name__ = "Window"
scout_compute_api_deprecated_Window.__qualname__ = "Window"
scout_compute_api_deprecated_Window.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_api_deprecated_WindowVisitor:

    @abstractmethod
    def _duration(self, duration: "scout_run_api_Duration") -> Any:
        pass


scout_compute_api_deprecated_WindowVisitor.__name__ = "WindowVisitor"
scout_compute_api_deprecated_WindowVisitor.__qualname__ = "WindowVisitor"
scout_compute_api_deprecated_WindowVisitor.__module__ = "nominal_api.scout_compute_api_deprecated"


class scout_compute_resolved_api_AbsoluteThreshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_value']

    def __init__(self, value: float) -> None:
        self._value = value

    @builtins.property
    def value(self) -> float:
        return self._value


scout_compute_resolved_api_AbsoluteThreshold.__name__ = "AbsoluteThreshold"
scout_compute_resolved_api_AbsoluteThreshold.__qualname__ = "AbsoluteThreshold"
scout_compute_resolved_api_AbsoluteThreshold.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_AbsoluteTimestampSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit)
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", time_unit: "api_TimeUnit") -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit


scout_compute_resolved_api_AbsoluteTimestampSeriesNode.__name__ = "AbsoluteTimestampSeriesNode"
scout_compute_resolved_api_AbsoluteTimestampSeriesNode.__qualname__ = "AbsoluteTimestampSeriesNode"
scout_compute_resolved_api_AbsoluteTimestampSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_AggregateEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'aggregation_function': ConjureFieldDefinition('aggregationFunction', scout_compute_api_EnumAggregationFunction)
        }

    __slots__: List[str] = ['_input', '_aggregation_function']

    def __init__(self, aggregation_function: "scout_compute_api_EnumAggregationFunction", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._aggregation_function = aggregation_function

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def aggregation_function(self) -> "scout_compute_api_EnumAggregationFunction":
        return self._aggregation_function


scout_compute_resolved_api_AggregateEnumSeriesNode.__name__ = "AggregateEnumSeriesNode"
scout_compute_resolved_api_AggregateEnumSeriesNode.__qualname__ = "AggregateEnumSeriesNode"
scout_compute_resolved_api_AggregateEnumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_AggregateNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'aggregation_function': ConjureFieldDefinition('aggregationFunction', scout_compute_api_NumericAggregationFunction),
            'group_by_tags': ConjureFieldDefinition('groupByTags', OptionalTypeWrapper[List[api_TagName]])
        }

    __slots__: List[str] = ['_input', '_aggregation_function', '_group_by_tags']

    def __init__(self, aggregation_function: "scout_compute_api_NumericAggregationFunction", input: "scout_compute_resolved_api_NumericSeriesNode", group_by_tags: Optional[List[str]] = None) -> None:
        self._input = input
        self._aggregation_function = aggregation_function
        self._group_by_tags = group_by_tags

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def aggregation_function(self) -> "scout_compute_api_NumericAggregationFunction":
        return self._aggregation_function

    @builtins.property
    def group_by_tags(self) -> Optional[List[str]]:
        """Present optional containing empty set means explicitly group by NO tags.
Empty optional means inherit tag groupings from input.
        """
        return self._group_by_tags


scout_compute_resolved_api_AggregateNumericSeriesNode.__name__ = "AggregateNumericSeriesNode"
scout_compute_resolved_api_AggregateNumericSeriesNode.__qualname__ = "AggregateNumericSeriesNode"
scout_compute_resolved_api_AggregateNumericSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_resolved_api_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, expression: str, inputs: Dict[str, "scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_ArithmeticSeriesNode.__name__ = "ArithmeticSeriesNode"
scout_compute_resolved_api_ArithmeticSeriesNode.__qualname__ = "ArithmeticSeriesNode"
scout_compute_resolved_api_ArithmeticSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ArraySeriesNode(ConjureUnionType):
    _numeric1d: Optional["scout_compute_resolved_api_NumericArraySeriesNode"] = None
    _enum1d: Optional["scout_compute_resolved_api_EnumArraySeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric1d': ConjureFieldDefinition('numeric1d', scout_compute_resolved_api_NumericArraySeriesNode),
            'enum1d': ConjureFieldDefinition('enum1d', scout_compute_resolved_api_EnumArraySeriesNode)
        }

    def __init__(
            self,
            numeric1d: Optional["scout_compute_resolved_api_NumericArraySeriesNode"] = None,
            enum1d: Optional["scout_compute_resolved_api_EnumArraySeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric1d is not None) + (enum1d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric1d is not None:
                self._numeric1d = numeric1d
                self._type = 'numeric1d'
            if enum1d is not None:
                self._enum1d = enum1d
                self._type = 'enum1d'

        elif type_of_union == 'numeric1d':
            if numeric1d is None:
                raise ValueError('a union value must not be None')
            self._numeric1d = numeric1d
            self._type = 'numeric1d'
        elif type_of_union == 'enum1d':
            if enum1d is None:
                raise ValueError('a union value must not be None')
            self._enum1d = enum1d
            self._type = 'enum1d'

    @builtins.property
    def numeric1d(self) -> Optional["scout_compute_resolved_api_NumericArraySeriesNode"]:
        return self._numeric1d

    @builtins.property
    def enum1d(self) -> Optional["scout_compute_resolved_api_EnumArraySeriesNode"]:
        return self._enum1d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ArraySeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ArraySeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric1d' and self.numeric1d is not None:
            return visitor._numeric1d(self.numeric1d)
        if self._type == 'enum1d' and self.enum1d is not None:
            return visitor._enum1d(self.enum1d)


scout_compute_resolved_api_ArraySeriesNode.__name__ = "ArraySeriesNode"
scout_compute_resolved_api_ArraySeriesNode.__qualname__ = "ArraySeriesNode"
scout_compute_resolved_api_ArraySeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ArraySeriesNodeVisitor:

    @abstractmethod
    def _numeric1d(self, numeric1d: "scout_compute_resolved_api_NumericArraySeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum1d(self, enum1d: "scout_compute_resolved_api_EnumArraySeriesNode") -> Any:
        pass


scout_compute_resolved_api_ArraySeriesNodeVisitor.__name__ = "ArraySeriesNodeVisitor"
scout_compute_resolved_api_ArraySeriesNodeVisitor.__qualname__ = "ArraySeriesNodeVisitor"
scout_compute_resolved_api_ArraySeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BandPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_passband_frequency': ConjureFieldDefinition('lowPassbandFrequency', float),
            'high_passband_frequency': ConjureFieldDefinition('highPassbandFrequency', float)
        }

    __slots__: List[str] = ['_low_passband_frequency', '_high_passband_frequency']

    def __init__(self, high_passband_frequency: float, low_passband_frequency: float) -> None:
        self._low_passband_frequency = low_passband_frequency
        self._high_passband_frequency = high_passband_frequency

    @builtins.property
    def low_passband_frequency(self) -> float:
        return self._low_passband_frequency

    @builtins.property
    def high_passband_frequency(self) -> float:
        return self._high_passband_frequency


scout_compute_resolved_api_BandPassConfiguration.__name__ = "BandPassConfiguration"
scout_compute_resolved_api_BandPassConfiguration.__qualname__ = "BandPassConfiguration"
scout_compute_resolved_api_BandPassConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BandStopConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_stopband_frequency': ConjureFieldDefinition('lowStopbandFrequency', float),
            'high_stopband_frequency': ConjureFieldDefinition('highStopbandFrequency', float)
        }

    __slots__: List[str] = ['_low_stopband_frequency', '_high_stopband_frequency']

    def __init__(self, high_stopband_frequency: float, low_stopband_frequency: float) -> None:
        self._low_stopband_frequency = low_stopband_frequency
        self._high_stopband_frequency = high_stopband_frequency

    @builtins.property
    def low_stopband_frequency(self) -> float:
        return self._low_stopband_frequency

    @builtins.property
    def high_stopband_frequency(self) -> float:
        return self._high_stopband_frequency


scout_compute_resolved_api_BandStopConfiguration.__name__ = "BandStopConfiguration"
scout_compute_resolved_api_BandStopConfiguration.__qualname__ = "BandStopConfiguration"
scout_compute_resolved_api_BandStopConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BinaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input1': ConjureFieldDefinition('input1', scout_compute_resolved_api_NumericSeriesNode),
            'input2': ConjureFieldDefinition('input2', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_BinaryArithmeticOperation),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_input1', '_input2', '_operation', '_interpolation_configuration']

    def __init__(self, input1: "scout_compute_resolved_api_NumericSeriesNode", input2: "scout_compute_resolved_api_NumericSeriesNode", interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration", operation: "scout_compute_api_BinaryArithmeticOperation") -> None:
        self._input1 = input1
        self._input2 = input2
        self._operation = operation
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def input1(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input1

    @builtins.property
    def input2(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input2

    @builtins.property
    def operation(self) -> "scout_compute_api_BinaryArithmeticOperation":
        return self._operation

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_BinaryArithmeticSeriesNode.__name__ = "BinaryArithmeticSeriesNode"
scout_compute_resolved_api_BinaryArithmeticSeriesNode.__qualname__ = "BinaryArithmeticSeriesNode"
scout_compute_resolved_api_BinaryArithmeticSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BitOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'function': ConjureFieldDefinition('function', scout_compute_api_BitOperationFunction)
        }

    __slots__: List[str] = ['_input', '_function']

    def __init__(self, function: "scout_compute_api_BitOperationFunction", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._function = function

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def function(self) -> "scout_compute_api_BitOperationFunction":
        return self._function


scout_compute_resolved_api_BitOperationSeriesNode.__name__ = "BitOperationSeriesNode"
scout_compute_resolved_api_BitOperationSeriesNode.__qualname__ = "BitOperationSeriesNode"
scout_compute_resolved_api_BitOperationSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_BodeNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'output': ConjureFieldDefinition('output', scout_compute_resolved_api_NumericSeriesNode),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_input', '_output', '_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", output: "scout_compute_resolved_api_NumericSeriesNode", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._input = input
        self._output = output
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def output(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._output

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        return self._unwrap_phase


scout_compute_resolved_api_BodeNode.__name__ = "BodeNode"
scout_compute_resolved_api_BodeNode.__qualname__ = "BodeNode"
scout_compute_resolved_api_BodeNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Cartesian3dBounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float),
            'min_z': ConjureFieldDefinition('minZ', float),
            'max_z': ConjureFieldDefinition('maxZ', float)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y', '_min_z', '_max_z']

    def __init__(self, max_x: float, max_y: float, max_z: float, min_x: float, min_y: float, min_z: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y
        self._min_z = min_z
        self._max_z = max_z

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y

    @builtins.property
    def min_z(self) -> float:
        return self._min_z

    @builtins.property
    def max_z(self) -> float:
        return self._max_z


scout_compute_resolved_api_Cartesian3dBounds.__name__ = "Cartesian3dBounds"
scout_compute_resolved_api_Cartesian3dBounds.__qualname__ = "Cartesian3dBounds"
scout_compute_resolved_api_Cartesian3dBounds.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Cartesian3dNode(ConjureUnionType):
    _scatter3d: Optional["scout_compute_resolved_api_Scatter3dNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter3d': ConjureFieldDefinition('scatter3d', scout_compute_resolved_api_Scatter3dNode)
        }

    def __init__(
            self,
            scatter3d: Optional["scout_compute_resolved_api_Scatter3dNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter3d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter3d is not None:
                self._scatter3d = scatter3d
                self._type = 'scatter3d'

        elif type_of_union == 'scatter3d':
            if scatter3d is None:
                raise ValueError('a union value must not be None')
            self._scatter3d = scatter3d
            self._type = 'scatter3d'

    @builtins.property
    def scatter3d(self) -> Optional["scout_compute_resolved_api_Scatter3dNode"]:
        return self._scatter3d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_Cartesian3dNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_Cartesian3dNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter3d' and self.scatter3d is not None:
            return visitor._scatter3d(self.scatter3d)


scout_compute_resolved_api_Cartesian3dNode.__name__ = "Cartesian3dNode"
scout_compute_resolved_api_Cartesian3dNode.__qualname__ = "Cartesian3dNode"
scout_compute_resolved_api_Cartesian3dNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Cartesian3dNodeVisitor:

    @abstractmethod
    def _scatter3d(self, scatter3d: "scout_compute_resolved_api_Scatter3dNode") -> Any:
        pass


scout_compute_resolved_api_Cartesian3dNodeVisitor.__name__ = "Cartesian3dNodeVisitor"
scout_compute_resolved_api_Cartesian3dNodeVisitor.__qualname__ = "Cartesian3dNodeVisitor"
scout_compute_resolved_api_Cartesian3dNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianBounds(ConjureBeanType):
    """Min/max bounds of an XY Cartesian plot, inclusive.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', float),
            'max_x': ConjureFieldDefinition('maxX', float),
            'min_y': ConjureFieldDefinition('minY', float),
            'max_y': ConjureFieldDefinition('maxY', float)
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: float, max_y: float, min_x: float, min_y: float) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> float:
        return self._min_x

    @builtins.property
    def max_x(self) -> float:
        return self._max_x

    @builtins.property
    def min_y(self) -> float:
        return self._min_y

    @builtins.property
    def max_y(self) -> float:
        return self._max_y


scout_compute_resolved_api_CartesianBounds.__name__ = "CartesianBounds"
scout_compute_resolved_api_CartesianBounds.__qualname__ = "CartesianBounds"
scout_compute_resolved_api_CartesianBounds.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianNode(ConjureUnionType):
    _scatter: Optional["scout_compute_resolved_api_ScatterNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_resolved_api_ScatterNode)
        }

    def __init__(
            self,
            scatter: Optional["scout_compute_resolved_api_ScatterNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def scatter(self) -> Optional["scout_compute_resolved_api_ScatterNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_CartesianNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_CartesianNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_resolved_api_CartesianNode.__name__ = "CartesianNode"
scout_compute_resolved_api_CartesianNode.__qualname__ = "CartesianNode"
scout_compute_resolved_api_CartesianNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CartesianNodeVisitor:

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_resolved_api_ScatterNode") -> Any:
        pass


scout_compute_resolved_api_CartesianNodeVisitor.__name__ = "CartesianNodeVisitor"
scout_compute_resolved_api_CartesianNodeVisitor.__qualname__ = "CartesianNodeVisitor"
scout_compute_resolved_api_CartesianNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ClickHouseSeriesResolutionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', OptionalTypeWrapper[scout_compute_resolved_api_TagFilters]),
            'tags_to_group_by': ConjureFieldDefinition('tagsToGroupBy', List[api_TagName]),
            'org_rid': ConjureFieldDefinition('orgRid', authentication_api_OrgRid)
        }

    __slots__: List[str] = ['_channel', '_tags', '_tags_to_group_by', '_org_rid']

    def __init__(self, channel: str, org_rid: str, tags_to_group_by: List[str], tags: Optional["scout_compute_resolved_api_TagFilters"] = None) -> None:
        self._channel = channel
        self._tags = tags
        self._tags_to_group_by = tags_to_group_by
        self._org_rid = org_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Optional["scout_compute_resolved_api_TagFilters"]:
        return self._tags

    @builtins.property
    def tags_to_group_by(self) -> List[str]:
        return self._tags_to_group_by

    @builtins.property
    def org_rid(self) -> str:
        return self._org_rid


scout_compute_resolved_api_ClickHouseSeriesResolutionDetails.__name__ = "ClickHouseSeriesResolutionDetails"
scout_compute_resolved_api_ClickHouseSeriesResolutionDetails.__qualname__ = "ClickHouseSeriesResolutionDetails"
scout_compute_resolved_api_ClickHouseSeriesResolutionDetails.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'constant': ConjureFieldDefinition('constant', scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue)
        }

    __slots__: List[str] = ['_constant']

    def __init__(self, constant: "scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue") -> None:
        self._constant = constant

    @builtins.property
    def constant(self) -> "scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue":
        return self._constant


scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration.__name__ = "ConstantDefaultValueResampleInterpolationConfiguration"
scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration.__qualname__ = "ConstantDefaultValueResampleInterpolationConfiguration"
scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CpsdNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_resolved_api_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_resolved_api_NumericSeriesNode),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType]),
            'unwrap_phase': ConjureFieldDefinition('unwrapPhase', OptionalTypeWrapper[bool]),
            'output_phase_unit': ConjureFieldDefinition('outputPhaseUnit', OptionalTypeWrapper[scout_compute_api_OutputPhaseUnit])
        }

    __slots__: List[str] = ['_x', '_y', '_stft_options', '_magnitude_scaling', '_output_frequency_type', '_unwrap_phase', '_output_phase_unit']

    def __init__(self, x: "scout_compute_resolved_api_NumericSeriesNode", y: "scout_compute_resolved_api_NumericSeriesNode", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, output_phase_unit: Optional["scout_compute_api_OutputPhaseUnit"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None, unwrap_phase: Optional[bool] = None) -> None:
        self._x = x
        self._y = y
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type
        self._unwrap_phase = unwrap_phase
        self._output_phase_unit = output_phase_unit

    @builtins.property
    def x(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._y

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type

    @builtins.property
    def unwrap_phase(self) -> Optional[bool]:
        return self._unwrap_phase

    @builtins.property
    def output_phase_unit(self) -> Optional["scout_compute_api_OutputPhaseUnit"]:
        return self._output_phase_unit


scout_compute_resolved_api_CpsdNode.__name__ = "CpsdNode"
scout_compute_resolved_api_CpsdNode.__qualname__ = "CpsdNode"
scout_compute_resolved_api_CpsdNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CumulativeSumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_input', '_start_timestamp']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", start_timestamp: "api_Timestamp") -> None:
        self._input = input
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp


scout_compute_resolved_api_CumulativeSumSeriesNode.__name__ = "CumulativeSumSeriesNode"
scout_compute_resolved_api_CumulativeSumSeriesNode.__qualname__ = "CumulativeSumSeriesNode"
scout_compute_resolved_api_CumulativeSumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitDetails(ConjureUnionType):
    _exponential: Optional["scout_compute_resolved_api_ExponentialCurve"] = None
    _logarithmic: Optional["scout_compute_resolved_api_LogarithmicCurve"] = None
    _polynomial: Optional["scout_compute_resolved_api_PolynomialCurve"] = None
    _power: Optional["scout_compute_resolved_api_PowerCurve"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'exponential': ConjureFieldDefinition('exponential', scout_compute_resolved_api_ExponentialCurve),
            'logarithmic': ConjureFieldDefinition('logarithmic', scout_compute_resolved_api_LogarithmicCurve),
            'polynomial': ConjureFieldDefinition('polynomial', scout_compute_resolved_api_PolynomialCurve),
            'power': ConjureFieldDefinition('power', scout_compute_resolved_api_PowerCurve)
        }

    def __init__(
            self,
            exponential: Optional["scout_compute_resolved_api_ExponentialCurve"] = None,
            logarithmic: Optional["scout_compute_resolved_api_LogarithmicCurve"] = None,
            polynomial: Optional["scout_compute_resolved_api_PolynomialCurve"] = None,
            power: Optional["scout_compute_resolved_api_PowerCurve"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (exponential is not None) + (logarithmic is not None) + (polynomial is not None) + (power is not None) != 1:
                raise ValueError('a union must contain a single member')

            if exponential is not None:
                self._exponential = exponential
                self._type = 'exponential'
            if logarithmic is not None:
                self._logarithmic = logarithmic
                self._type = 'logarithmic'
            if polynomial is not None:
                self._polynomial = polynomial
                self._type = 'polynomial'
            if power is not None:
                self._power = power
                self._type = 'power'

        elif type_of_union == 'exponential':
            if exponential is None:
                raise ValueError('a union value must not be None')
            self._exponential = exponential
            self._type = 'exponential'
        elif type_of_union == 'logarithmic':
            if logarithmic is None:
                raise ValueError('a union value must not be None')
            self._logarithmic = logarithmic
            self._type = 'logarithmic'
        elif type_of_union == 'polynomial':
            if polynomial is None:
                raise ValueError('a union value must not be None')
            self._polynomial = polynomial
            self._type = 'polynomial'
        elif type_of_union == 'power':
            if power is None:
                raise ValueError('a union value must not be None')
            self._power = power
            self._type = 'power'

    @builtins.property
    def exponential(self) -> Optional["scout_compute_resolved_api_ExponentialCurve"]:
        return self._exponential

    @builtins.property
    def logarithmic(self) -> Optional["scout_compute_resolved_api_LogarithmicCurve"]:
        return self._logarithmic

    @builtins.property
    def polynomial(self) -> Optional["scout_compute_resolved_api_PolynomialCurve"]:
        return self._polynomial

    @builtins.property
    def power(self) -> Optional["scout_compute_resolved_api_PowerCurve"]:
        return self._power

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_CurveFitDetailsVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_CurveFitDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'exponential' and self.exponential is not None:
            return visitor._exponential(self.exponential)
        if self._type == 'logarithmic' and self.logarithmic is not None:
            return visitor._logarithmic(self.logarithmic)
        if self._type == 'polynomial' and self.polynomial is not None:
            return visitor._polynomial(self.polynomial)
        if self._type == 'power' and self.power is not None:
            return visitor._power(self.power)


scout_compute_resolved_api_CurveFitDetails.__name__ = "CurveFitDetails"
scout_compute_resolved_api_CurveFitDetails.__qualname__ = "CurveFitDetails"
scout_compute_resolved_api_CurveFitDetails.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitDetailsVisitor:

    @abstractmethod
    def _exponential(self, exponential: "scout_compute_resolved_api_ExponentialCurve") -> Any:
        pass

    @abstractmethod
    def _logarithmic(self, logarithmic: "scout_compute_resolved_api_LogarithmicCurve") -> Any:
        pass

    @abstractmethod
    def _polynomial(self, polynomial: "scout_compute_resolved_api_PolynomialCurve") -> Any:
        pass

    @abstractmethod
    def _power(self, power: "scout_compute_resolved_api_PowerCurve") -> Any:
        pass


scout_compute_resolved_api_CurveFitDetailsVisitor.__name__ = "CurveFitDetailsVisitor"
scout_compute_resolved_api_CurveFitDetailsVisitor.__qualname__ = "CurveFitDetailsVisitor"
scout_compute_resolved_api_CurveFitDetailsVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'curve_fit_plot_type': ConjureFieldDefinition('curveFitPlotType', scout_compute_resolved_api_CurveFitPlotTypeNode),
            'curve_fit_details': ConjureFieldDefinition('curveFitDetails', scout_compute_resolved_api_CurveFitDetails),
            'curve_fit_options': ConjureFieldDefinition('curveFitOptions', scout_compute_resolved_api_CurveFitOptions)
        }

    __slots__: List[str] = ['_curve_fit_plot_type', '_curve_fit_details', '_curve_fit_options']

    def __init__(self, curve_fit_details: "scout_compute_resolved_api_CurveFitDetails", curve_fit_options: "scout_compute_resolved_api_CurveFitOptions", curve_fit_plot_type: "scout_compute_resolved_api_CurveFitPlotTypeNode") -> None:
        self._curve_fit_plot_type = curve_fit_plot_type
        self._curve_fit_details = curve_fit_details
        self._curve_fit_options = curve_fit_options

    @builtins.property
    def curve_fit_plot_type(self) -> "scout_compute_resolved_api_CurveFitPlotTypeNode":
        return self._curve_fit_plot_type

    @builtins.property
    def curve_fit_details(self) -> "scout_compute_resolved_api_CurveFitDetails":
        return self._curve_fit_details

    @builtins.property
    def curve_fit_options(self) -> "scout_compute_resolved_api_CurveFitOptions":
        return self._curve_fit_options


scout_compute_resolved_api_CurveFitNode.__name__ = "CurveFitNode"
scout_compute_resolved_api_CurveFitNode.__qualname__ = "CurveFitNode"
scout_compute_resolved_api_CurveFitNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', api_Timestamp),
            'end_time': ConjureFieldDefinition('endTime', api_Timestamp)
        }

    __slots__: List[str] = ['_start_time', '_end_time']

    def __init__(self, end_time: "api_Timestamp", start_time: "api_Timestamp") -> None:
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def start_time(self) -> "api_Timestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> "api_Timestamp":
        return self._end_time


scout_compute_resolved_api_CurveFitOptions.__name__ = "CurveFitOptions"
scout_compute_resolved_api_CurveFitOptions.__qualname__ = "CurveFitOptions"
scout_compute_resolved_api_CurveFitOptions.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitPlotTypeNode(ConjureUnionType):
    _time_series: Optional["scout_compute_resolved_api_TimeSeriesCurveFitNode"] = None
    _scatter: Optional["scout_compute_resolved_api_ScatterCurveFitNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_series': ConjureFieldDefinition('timeSeries', scout_compute_resolved_api_TimeSeriesCurveFitNode),
            'scatter': ConjureFieldDefinition('scatter', scout_compute_resolved_api_ScatterCurveFitNode)
        }

    def __init__(
            self,
            time_series: Optional["scout_compute_resolved_api_TimeSeriesCurveFitNode"] = None,
            scatter: Optional["scout_compute_resolved_api_ScatterCurveFitNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_series is not None) + (scatter is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_series is not None:
                self._time_series = time_series
                self._type = 'timeSeries'
            if scatter is not None:
                self._scatter = scatter
                self._type = 'scatter'

        elif type_of_union == 'timeSeries':
            if time_series is None:
                raise ValueError('a union value must not be None')
            self._time_series = time_series
            self._type = 'timeSeries'
        elif type_of_union == 'scatter':
            if scatter is None:
                raise ValueError('a union value must not be None')
            self._scatter = scatter
            self._type = 'scatter'

    @builtins.property
    def time_series(self) -> Optional["scout_compute_resolved_api_TimeSeriesCurveFitNode"]:
        return self._time_series

    @builtins.property
    def scatter(self) -> Optional["scout_compute_resolved_api_ScatterCurveFitNode"]:
        return self._scatter

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeSeries' and self.time_series is not None:
            return visitor._time_series(self.time_series)
        if self._type == 'scatter' and self.scatter is not None:
            return visitor._scatter(self.scatter)


scout_compute_resolved_api_CurveFitPlotTypeNode.__name__ = "CurveFitPlotTypeNode"
scout_compute_resolved_api_CurveFitPlotTypeNode.__qualname__ = "CurveFitPlotTypeNode"
scout_compute_resolved_api_CurveFitPlotTypeNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor:

    @abstractmethod
    def _time_series(self, time_series: "scout_compute_resolved_api_TimeSeriesCurveFitNode") -> Any:
        pass

    @abstractmethod
    def _scatter(self, scatter: "scout_compute_resolved_api_ScatterCurveFitNode") -> Any:
        pass


scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor.__name__ = "CurveFitPlotTypeNodeVisitor"
scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor.__qualname__ = "CurveFitPlotTypeNodeVisitor"
scout_compute_resolved_api_CurveFitPlotTypeNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_DerivativeSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit]),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_time_unit', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None, time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_resolved_api_DerivativeSeriesNode.__name__ = "DerivativeSeriesNode"
scout_compute_resolved_api_DerivativeSeriesNode.__qualname__ = "DerivativeSeriesNode"
scout_compute_resolved_api_DerivativeSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_DurationFilterRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_run_api_Duration),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'unbounded_behavior': ConjureFieldDefinition('unboundedBehavior', scout_compute_api_UnboundedBehavior)
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_unbounded_behavior']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode", operator: "scout_compute_api_ThresholdOperator", threshold: "scout_run_api_Duration", unbounded_behavior: "scout_compute_api_UnboundedBehavior") -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._unbounded_behavior = unbounded_behavior

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_run_api_Duration":
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def unbounded_behavior(self) -> "scout_compute_api_UnboundedBehavior":
        return self._unbounded_behavior


scout_compute_resolved_api_DurationFilterRangesNode.__name__ = "DurationFilterRangesNode"
scout_compute_resolved_api_DurationFilterRangesNode.__qualname__ = "DurationFilterRangesNode"
scout_compute_resolved_api_DurationFilterRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumArraySeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_ResolvedSeries)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_ResolvedSeries"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_EnumArraySeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_EnumArraySeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_compute_resolved_api_EnumArraySeriesNode.__name__ = "EnumArraySeriesNode"
scout_compute_resolved_api_EnumArraySeriesNode.__qualname__ = "EnumArraySeriesNode"
scout_compute_resolved_api_EnumArraySeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumArraySeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_ResolvedSeries") -> Any:
        pass


scout_compute_resolved_api_EnumArraySeriesNodeVisitor.__name__ = "EnumArraySeriesNodeVisitor"
scout_compute_resolved_api_EnumArraySeriesNodeVisitor.__qualname__ = "EnumArraySeriesNodeVisitor"
scout_compute_resolved_api_EnumArraySeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumCountDuplicateSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_EnumSeriesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_resolved_api_EnumSeriesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._inputs


scout_compute_resolved_api_EnumCountDuplicateSeriesNode.__name__ = "EnumCountDuplicateSeriesNode"
scout_compute_resolved_api_EnumCountDuplicateSeriesNode.__qualname__ = "EnumCountDuplicateSeriesNode"
scout_compute_resolved_api_EnumCountDuplicateSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumEqualityRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_EnumSeriesNode]),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EqualityOperator),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_inputs', '_operator', '_interpolation_configuration', '_persistence_window_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_EnumSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration", operator: "scout_compute_api_EqualityOperator", persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._inputs = inputs
        self._operator = operator
        self._interpolation_configuration = interpolation_configuration
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._inputs

    @builtins.property
    def operator(self) -> "scout_compute_api_EqualityOperator":
        return self._operator

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_EnumEqualityRangesNode.__name__ = "EnumEqualityRangesNode"
scout_compute_resolved_api_EnumEqualityRangesNode.__qualname__ = "EnumEqualityRangesNode"
scout_compute_resolved_api_EnumEqualityRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumFilterRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_EnumFilterOperator),
            'values': ConjureFieldDefinition('values', List[str]),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_operator', '_values', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", operator: "scout_compute_api_EnumFilterOperator", values: List[str], persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._operator = operator
        self._values = values
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_EnumFilterOperator":
        return self._operator

    @builtins.property
    def values(self) -> List[str]:
        return self._values

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_EnumFilterRangesNode.__name__ = "EnumFilterRangesNode"
scout_compute_resolved_api_EnumFilterRangesNode.__qualname__ = "EnumFilterRangesNode"
scout_compute_resolved_api_EnumFilterRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumFilterTransformationSeriesNode(ConjureBeanType):
    """Outputs the values of the enum plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_resolved_api_RangesNode", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_resolved_api_RangesNode":
        return self._filter


scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__name__ = "EnumFilterTransformationSeriesNode"
scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__qualname__ = "EnumFilterTransformationSeriesNode"
scout_compute_resolved_api_EnumFilterTransformationSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_resolved_api_EnumSeriesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: Dict[str, "scout_compute_resolved_api_EnumSeriesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_EnumSeriesNode"]:
        return self._inputs


scout_compute_resolved_api_EnumHistogramNode.__name__ = "EnumHistogramNode"
scout_compute_resolved_api_EnumHistogramNode.__qualname__ = "EnumHistogramNode"
scout_compute_resolved_api_EnumHistogramNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumResampleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_resolved_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", resample_configuration: "scout_compute_resolved_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_resolved_api_ResampleConfiguration":
        return self._resample_configuration


scout_compute_resolved_api_EnumResampleSeriesNode.__name__ = "EnumResampleSeriesNode"
scout_compute_resolved_api_EnumResampleSeriesNode.__qualname__ = "EnumResampleSeriesNode"
scout_compute_resolved_api_EnumResampleSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumSeriesNode(ConjureUnionType):
    _literal: Optional["scout_compute_resolved_api_LiteralEnumSeriesNode"] = None
    _raw: Optional["scout_compute_resolved_api_RawEnumSeriesNode"] = None
    _resample: Optional["scout_compute_resolved_api_EnumResampleSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"] = None
    _union: Optional["scout_compute_resolved_api_EnumUnionSeriesNode"] = None
    _aggregate: Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"] = None
    _value_map: Optional["scout_compute_resolved_api_ValueMapSeriesNode"] = None
    _array_select: Optional["scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode"] = None
    _extract_from_struct: Optional["scout_compute_resolved_api_ExtractEnumFromStructSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', scout_compute_resolved_api_LiteralEnumSeriesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawEnumSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_resolved_api_EnumResampleSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_resolved_api_EnumTimeShiftSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_resolved_api_EnumUnionSeriesNode),
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_resolved_api_AggregateEnumSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_resolved_api_EnumFilterTransformationSeriesNode),
            'value_map': ConjureFieldDefinition('valueMap', scout_compute_resolved_api_ValueMapSeriesNode),
            'array_select': ConjureFieldDefinition('arraySelect', scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_resolved_api_ExtractEnumFromStructSeriesNode)
        }

    def __init__(
            self,
            literal: Optional["scout_compute_resolved_api_LiteralEnumSeriesNode"] = None,
            raw: Optional["scout_compute_resolved_api_RawEnumSeriesNode"] = None,
            resample: Optional["scout_compute_resolved_api_EnumResampleSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"] = None,
            union: Optional["scout_compute_resolved_api_EnumUnionSeriesNode"] = None,
            aggregate: Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"] = None,
            value_map: Optional["scout_compute_resolved_api_ValueMapSeriesNode"] = None,
            array_select: Optional["scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode"] = None,
            extract_from_struct: Optional["scout_compute_resolved_api_ExtractEnumFromStructSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) + (raw is not None) + (resample is not None) + (time_range_filter is not None) + (time_shift is not None) + (union is not None) + (aggregate is not None) + (filter_transformation is not None) + (value_map is not None) + (array_select is not None) + (extract_from_struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if union is not None:
                self._union = union
                self._type = 'union'
            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'
            if value_map is not None:
                self._value_map = value_map
                self._type = 'valueMap'
            if array_select is not None:
                self._array_select = array_select
                self._type = 'arraySelect'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'
        elif type_of_union == 'valueMap':
            if value_map is None:
                raise ValueError('a union value must not be None')
            self._value_map = value_map
            self._type = 'valueMap'
        elif type_of_union == 'arraySelect':
            if array_select is None:
                raise ValueError('a union value must not be None')
            self._array_select = array_select
            self._type = 'arraySelect'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'

    @builtins.property
    def literal(self) -> Optional["scout_compute_resolved_api_LiteralEnumSeriesNode"]:
        return self._literal

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawEnumSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_resolved_api_EnumResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_resolved_api_EnumTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def union(self) -> Optional["scout_compute_resolved_api_EnumUnionSeriesNode"]:
        return self._union

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_resolved_api_AggregateEnumSeriesNode"]:
        return self._aggregate

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_resolved_api_EnumFilterTransformationSeriesNode"]:
        return self._filter_transformation

    @builtins.property
    def value_map(self) -> Optional["scout_compute_resolved_api_ValueMapSeriesNode"]:
        return self._value_map

    @builtins.property
    def array_select(self) -> Optional["scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode"]:
        return self._array_select

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_resolved_api_ExtractEnumFromStructSeriesNode"]:
        return self._extract_from_struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_EnumSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_EnumSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)
        if self._type == 'valueMap' and self.value_map is not None:
            return visitor._value_map(self.value_map)
        if self._type == 'arraySelect' and self.array_select is not None:
            return visitor._array_select(self.array_select)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)


scout_compute_resolved_api_EnumSeriesNode.__name__ = "EnumSeriesNode"
scout_compute_resolved_api_EnumSeriesNode.__qualname__ = "EnumSeriesNode"
scout_compute_resolved_api_EnumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumSeriesNodeVisitor:

    @abstractmethod
    def _literal(self, literal: "scout_compute_resolved_api_LiteralEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_resolved_api_EnumResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_resolved_api_EnumTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_resolved_api_EnumUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_resolved_api_AggregateEnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_resolved_api_EnumFilterTransformationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_map(self, value_map: "scout_compute_resolved_api_ValueMapSeriesNode") -> Any:
        pass

    @abstractmethod
    def _array_select(self, array_select: "scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_resolved_api_ExtractEnumFromStructSeriesNode") -> Any:
        pass


scout_compute_resolved_api_EnumSeriesNodeVisitor.__name__ = "EnumSeriesNodeVisitor"
scout_compute_resolved_api_EnumSeriesNodeVisitor.__qualname__ = "EnumSeriesNodeVisitor"
scout_compute_resolved_api_EnumSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__name__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__qualname__ = "EnumTimeRangeFilterSeriesNode"
scout_compute_resolved_api_EnumTimeRangeFilterSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_resolved_api_EnumSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_EnumTimeShiftSeriesNode.__name__ = "EnumTimeShiftSeriesNode"
scout_compute_resolved_api_EnumTimeShiftSeriesNode.__qualname__ = "EnumTimeShiftSeriesNode"
scout_compute_resolved_api_EnumTimeShiftSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumToNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumSeriesNode),
            'mapping': ConjureFieldDefinition('mapping', Dict[str, float]),
            'default_value': ConjureFieldDefinition('defaultValue', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_input', '_mapping', '_default_value']

    def __init__(self, input: "scout_compute_resolved_api_EnumSeriesNode", mapping: Dict[str, float], default_value: Optional[float] = None) -> None:
        self._input = input
        self._mapping = mapping
        self._default_value = default_value

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumSeriesNode":
        return self._input

    @builtins.property
    def mapping(self) -> Dict[str, float]:
        return self._mapping

    @builtins.property
    def default_value(self) -> Optional[float]:
        return self._default_value


scout_compute_resolved_api_EnumToNumericSeriesNode.__name__ = "EnumToNumericSeriesNode"
scout_compute_resolved_api_EnumToNumericSeriesNode.__qualname__ = "EnumToNumericSeriesNode"
scout_compute_resolved_api_EnumToNumericSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_EnumUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_resolved_api_EnumSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_EnumUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_resolved_api_EnumSeriesNode"], operation: "scout_compute_api_EnumUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_EnumUnionOperation":
        return self._operation


scout_compute_resolved_api_EnumUnionSeriesNode.__name__ = "EnumUnionSeriesNode"
scout_compute_resolved_api_EnumUnionSeriesNode.__qualname__ = "EnumUnionSeriesNode"
scout_compute_resolved_api_EnumUnionSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExponentialCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_resolved_api_ExponentialCurve.__name__ = "ExponentialCurve"
scout_compute_resolved_api_ExponentialCurve.__qualname__ = "ExponentialCurve"
scout_compute_resolved_api_ExponentialCurve.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExtractEnumFromStructSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_StructSeriesNode),
            'field_path': ConjureFieldDefinition('fieldPath', str)
        }

    __slots__: List[str] = ['_input', '_field_path']

    def __init__(self, field_path: str, input: "scout_compute_resolved_api_StructSeriesNode") -> None:
        self._input = input
        self._field_path = field_path

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_StructSeriesNode":
        return self._input

    @builtins.property
    def field_path(self) -> str:
        return self._field_path


scout_compute_resolved_api_ExtractEnumFromStructSeriesNode.__name__ = "ExtractEnumFromStructSeriesNode"
scout_compute_resolved_api_ExtractEnumFromStructSeriesNode.__qualname__ = "ExtractEnumFromStructSeriesNode"
scout_compute_resolved_api_ExtractEnumFromStructSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExtractNumericFromStructSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_StructSeriesNode),
            'field_path': ConjureFieldDefinition('fieldPath', str),
            'data_type': ConjureFieldDefinition('dataType', scout_compute_api_NumericDataType)
        }

    __slots__: List[str] = ['_input', '_field_path', '_data_type']

    def __init__(self, data_type: "scout_compute_api_NumericDataType", field_path: str, input: "scout_compute_resolved_api_StructSeriesNode") -> None:
        self._input = input
        self._field_path = field_path
        self._data_type = data_type

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_StructSeriesNode":
        return self._input

    @builtins.property
    def field_path(self) -> str:
        return self._field_path

    @builtins.property
    def data_type(self) -> "scout_compute_api_NumericDataType":
        return self._data_type


scout_compute_resolved_api_ExtractNumericFromStructSeriesNode.__name__ = "ExtractNumericFromStructSeriesNode"
scout_compute_resolved_api_ExtractNumericFromStructSeriesNode.__qualname__ = "ExtractNumericFromStructSeriesNode"
scout_compute_resolved_api_ExtractNumericFromStructSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExtractStructFromStructSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_StructSeriesNode),
            'field_path': ConjureFieldDefinition('fieldPath', str)
        }

    __slots__: List[str] = ['_input', '_field_path']

    def __init__(self, field_path: str, input: "scout_compute_resolved_api_StructSeriesNode") -> None:
        self._input = input
        self._field_path = field_path

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_StructSeriesNode":
        return self._input

    @builtins.property
    def field_path(self) -> str:
        return self._field_path


scout_compute_resolved_api_ExtractStructFromStructSeriesNode.__name__ = "ExtractStructFromStructSeriesNode"
scout_compute_resolved_api_ExtractStructFromStructSeriesNode.__qualname__ = "ExtractStructFromStructSeriesNode"
scout_compute_resolved_api_ExtractStructFromStructSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ExtremaRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'returns_peaks': ConjureFieldDefinition('returnsPeaks', bool),
            'minimum_prominence': ConjureFieldDefinition('minimumProminence', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_input', '_returns_peaks', '_minimum_prominence']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", returns_peaks: bool, minimum_prominence: Optional[float] = None) -> None:
        self._input = input
        self._returns_peaks = returns_peaks
        self._minimum_prominence = minimum_prominence

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def returns_peaks(self) -> bool:
        return self._returns_peaks

    @builtins.property
    def minimum_prominence(self) -> Optional[float]:
        return self._minimum_prominence


scout_compute_resolved_api_ExtremaRangesNode.__name__ = "ExtremaRangesNode"
scout_compute_resolved_api_ExtremaRangesNode.__qualname__ = "ExtremaRangesNode"
scout_compute_resolved_api_ExtremaRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FftNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', OptionalTypeWrapper[scout_compute_api_FftWindow])
        }

    __slots__: List[str] = ['_input', '_window']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", window: Optional["scout_compute_api_FftWindow"] = None) -> None:
        self._input = input
        self._window = window

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> Optional["scout_compute_api_FftWindow"]:
        return self._window


scout_compute_resolved_api_FftNode.__name__ = "FftNode"
scout_compute_resolved_api_FftNode.__qualname__ = "FftNode"
scout_compute_resolved_api_FftNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FilterByExpressionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'base': ConjureFieldDefinition('base', scout_compute_api_LocalVariableName),
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_LocalVariableName, scout_compute_resolved_api_NumericSeriesNode]),
            'expression': ConjureFieldDefinition('expression', str),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_base', '_inputs', '_expression', '_interpolation_configuration']

    def __init__(self, base: str, expression: str, inputs: Dict[str, "scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._base = base
        self._inputs = inputs
        self._expression = expression
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def base(self) -> str:
        return self._base

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def expression(self) -> str:
        return self._expression

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_FilterByExpressionSeriesNode.__name__ = "FilterByExpressionSeriesNode"
scout_compute_resolved_api_FilterByExpressionSeriesNode.__qualname__ = "FilterByExpressionSeriesNode"
scout_compute_resolved_api_FilterByExpressionSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ForwardFillInterpolation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interpolation_radius': ConjureFieldDefinition('interpolationRadius', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_interpolation_radius']

    def __init__(self, interpolation_radius: "scout_run_api_Duration") -> None:
        self._interpolation_radius = interpolation_radius

    @builtins.property
    def interpolation_radius(self) -> "scout_run_api_Duration":
        return self._interpolation_radius


scout_compute_resolved_api_ForwardFillInterpolation.__name__ = "ForwardFillInterpolation"
scout_compute_resolved_api_ForwardFillInterpolation.__qualname__ = "ForwardFillInterpolation"
scout_compute_resolved_api_ForwardFillInterpolation.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__name__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__qualname__ = "ForwardFillResampleInterpolationConfiguration"
scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNode(ConjureUnionType):
    _fft: Optional["scout_compute_resolved_api_FftNode"] = None
    _psd: Optional["scout_compute_resolved_api_PsdNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_resolved_api_FftNode),
            'psd': ConjureFieldDefinition('psd', scout_compute_resolved_api_PsdNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_resolved_api_FftNode"] = None,
            psd: Optional["scout_compute_resolved_api_PsdNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) + (psd is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'
            if psd is not None:
                self._psd = psd
                self._type = 'psd'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'
        elif type_of_union == 'psd':
            if psd is None:
                raise ValueError('a union value must not be None')
            self._psd = psd
            self._type = 'psd'

    @builtins.property
    def fft(self) -> Optional["scout_compute_resolved_api_FftNode"]:
        return self._fft

    @builtins.property
    def psd(self) -> Optional["scout_compute_resolved_api_PsdNode"]:
        return self._psd

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_FrequencyDomainNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_FrequencyDomainNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)
        if self._type == 'psd' and self.psd is not None:
            return visitor._psd(self.psd)


scout_compute_resolved_api_FrequencyDomainNode.__name__ = "FrequencyDomainNode"
scout_compute_resolved_api_FrequencyDomainNode.__qualname__ = "FrequencyDomainNode"
scout_compute_resolved_api_FrequencyDomainNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNodeVisitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_resolved_api_FftNode") -> Any:
        pass

    @abstractmethod
    def _psd(self, psd: "scout_compute_resolved_api_PsdNode") -> Any:
        pass


scout_compute_resolved_api_FrequencyDomainNodeVisitor.__name__ = "FrequencyDomainNodeVisitor"
scout_compute_resolved_api_FrequencyDomainNodeVisitor.__qualname__ = "FrequencyDomainNodeVisitor"
scout_compute_resolved_api_FrequencyDomainNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNodeV2(ConjureUnionType):
    _fft: Optional["scout_compute_resolved_api_FftNode"] = None
    _psd: Optional["scout_compute_resolved_api_PsdNode"] = None
    _cpsd: Optional["scout_compute_resolved_api_CpsdNode"] = None
    _nyquist: Optional["scout_compute_resolved_api_NyquistNode"] = None
    _bode: Optional["scout_compute_resolved_api_BodeNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fft': ConjureFieldDefinition('fft', scout_compute_resolved_api_FftNode),
            'psd': ConjureFieldDefinition('psd', scout_compute_resolved_api_PsdNode),
            'cpsd': ConjureFieldDefinition('cpsd', scout_compute_resolved_api_CpsdNode),
            'nyquist': ConjureFieldDefinition('nyquist', scout_compute_resolved_api_NyquistNode),
            'bode': ConjureFieldDefinition('bode', scout_compute_resolved_api_BodeNode)
        }

    def __init__(
            self,
            fft: Optional["scout_compute_resolved_api_FftNode"] = None,
            psd: Optional["scout_compute_resolved_api_PsdNode"] = None,
            cpsd: Optional["scout_compute_resolved_api_CpsdNode"] = None,
            nyquist: Optional["scout_compute_resolved_api_NyquistNode"] = None,
            bode: Optional["scout_compute_resolved_api_BodeNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (fft is not None) + (psd is not None) + (cpsd is not None) + (nyquist is not None) + (bode is not None) != 1:
                raise ValueError('a union must contain a single member')

            if fft is not None:
                self._fft = fft
                self._type = 'fft'
            if psd is not None:
                self._psd = psd
                self._type = 'psd'
            if cpsd is not None:
                self._cpsd = cpsd
                self._type = 'cpsd'
            if nyquist is not None:
                self._nyquist = nyquist
                self._type = 'nyquist'
            if bode is not None:
                self._bode = bode
                self._type = 'bode'

        elif type_of_union == 'fft':
            if fft is None:
                raise ValueError('a union value must not be None')
            self._fft = fft
            self._type = 'fft'
        elif type_of_union == 'psd':
            if psd is None:
                raise ValueError('a union value must not be None')
            self._psd = psd
            self._type = 'psd'
        elif type_of_union == 'cpsd':
            if cpsd is None:
                raise ValueError('a union value must not be None')
            self._cpsd = cpsd
            self._type = 'cpsd'
        elif type_of_union == 'nyquist':
            if nyquist is None:
                raise ValueError('a union value must not be None')
            self._nyquist = nyquist
            self._type = 'nyquist'
        elif type_of_union == 'bode':
            if bode is None:
                raise ValueError('a union value must not be None')
            self._bode = bode
            self._type = 'bode'

    @builtins.property
    def fft(self) -> Optional["scout_compute_resolved_api_FftNode"]:
        return self._fft

    @builtins.property
    def psd(self) -> Optional["scout_compute_resolved_api_PsdNode"]:
        return self._psd

    @builtins.property
    def cpsd(self) -> Optional["scout_compute_resolved_api_CpsdNode"]:
        return self._cpsd

    @builtins.property
    def nyquist(self) -> Optional["scout_compute_resolved_api_NyquistNode"]:
        return self._nyquist

    @builtins.property
    def bode(self) -> Optional["scout_compute_resolved_api_BodeNode"]:
        return self._bode

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_FrequencyDomainNodeV2Visitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_FrequencyDomainNodeV2Visitor'.format(visitor.__class__.__name__))
        if self._type == 'fft' and self.fft is not None:
            return visitor._fft(self.fft)
        if self._type == 'psd' and self.psd is not None:
            return visitor._psd(self.psd)
        if self._type == 'cpsd' and self.cpsd is not None:
            return visitor._cpsd(self.cpsd)
        if self._type == 'nyquist' and self.nyquist is not None:
            return visitor._nyquist(self.nyquist)
        if self._type == 'bode' and self.bode is not None:
            return visitor._bode(self.bode)


scout_compute_resolved_api_FrequencyDomainNodeV2.__name__ = "FrequencyDomainNodeV2"
scout_compute_resolved_api_FrequencyDomainNodeV2.__qualname__ = "FrequencyDomainNodeV2"
scout_compute_resolved_api_FrequencyDomainNodeV2.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_FrequencyDomainNodeV2Visitor:

    @abstractmethod
    def _fft(self, fft: "scout_compute_resolved_api_FftNode") -> Any:
        pass

    @abstractmethod
    def _psd(self, psd: "scout_compute_resolved_api_PsdNode") -> Any:
        pass

    @abstractmethod
    def _cpsd(self, cpsd: "scout_compute_resolved_api_CpsdNode") -> Any:
        pass

    @abstractmethod
    def _nyquist(self, nyquist: "scout_compute_resolved_api_NyquistNode") -> Any:
        pass

    @abstractmethod
    def _bode(self, bode: "scout_compute_resolved_api_BodeNode") -> Any:
        pass


scout_compute_resolved_api_FrequencyDomainNodeV2Visitor.__name__ = "FrequencyDomainNodeV2Visitor"
scout_compute_resolved_api_FrequencyDomainNodeV2Visitor.__qualname__ = "FrequencyDomainNodeV2Visitor"
scout_compute_resolved_api_FrequencyDomainNodeV2Visitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_HighPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cutoff_frequency': ConjureFieldDefinition('cutoffFrequency', float)
        }

    __slots__: List[str] = ['_cutoff_frequency']

    def __init__(self, cutoff_frequency: float) -> None:
        self._cutoff_frequency = cutoff_frequency

    @builtins.property
    def cutoff_frequency(self) -> float:
        return self._cutoff_frequency


scout_compute_resolved_api_HighPassConfiguration.__name__ = "HighPassConfiguration"
scout_compute_resolved_api_HighPassConfiguration.__qualname__ = "HighPassConfiguration"
scout_compute_resolved_api_HighPassConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_HistogramNode(ConjureUnionType):
    _numeric_histogram: Optional["scout_compute_resolved_api_NumericHistogramNode"] = None
    _enum_histogram: Optional["scout_compute_resolved_api_EnumHistogramNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric_histogram': ConjureFieldDefinition('numericHistogram', scout_compute_resolved_api_NumericHistogramNode),
            'enum_histogram': ConjureFieldDefinition('enumHistogram', scout_compute_resolved_api_EnumHistogramNode)
        }

    def __init__(
            self,
            numeric_histogram: Optional["scout_compute_resolved_api_NumericHistogramNode"] = None,
            enum_histogram: Optional["scout_compute_resolved_api_EnumHistogramNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric_histogram is not None) + (enum_histogram is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric_histogram is not None:
                self._numeric_histogram = numeric_histogram
                self._type = 'numericHistogram'
            if enum_histogram is not None:
                self._enum_histogram = enum_histogram
                self._type = 'enumHistogram'

        elif type_of_union == 'numericHistogram':
            if numeric_histogram is None:
                raise ValueError('a union value must not be None')
            self._numeric_histogram = numeric_histogram
            self._type = 'numericHistogram'
        elif type_of_union == 'enumHistogram':
            if enum_histogram is None:
                raise ValueError('a union value must not be None')
            self._enum_histogram = enum_histogram
            self._type = 'enumHistogram'

    @builtins.property
    def numeric_histogram(self) -> Optional["scout_compute_resolved_api_NumericHistogramNode"]:
        return self._numeric_histogram

    @builtins.property
    def enum_histogram(self) -> Optional["scout_compute_resolved_api_EnumHistogramNode"]:
        return self._enum_histogram

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_HistogramNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_HistogramNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numericHistogram' and self.numeric_histogram is not None:
            return visitor._numeric_histogram(self.numeric_histogram)
        if self._type == 'enumHistogram' and self.enum_histogram is not None:
            return visitor._enum_histogram(self.enum_histogram)


scout_compute_resolved_api_HistogramNode.__name__ = "HistogramNode"
scout_compute_resolved_api_HistogramNode.__qualname__ = "HistogramNode"
scout_compute_resolved_api_HistogramNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_HistogramNodeVisitor:

    @abstractmethod
    def _numeric_histogram(self, numeric_histogram: "scout_compute_resolved_api_NumericHistogramNode") -> Any:
        pass

    @abstractmethod
    def _enum_histogram(self, enum_histogram: "scout_compute_resolved_api_EnumHistogramNode") -> Any:
        pass


scout_compute_resolved_api_HistogramNodeVisitor.__name__ = "HistogramNodeVisitor"
scout_compute_resolved_api_HistogramNodeVisitor.__qualname__ = "HistogramNodeVisitor"
scout_compute_resolved_api_HistogramNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_IntegralSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_start_timestamp', '_time_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", start_timestamp: "api_Timestamp", time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._start_timestamp = start_timestamp
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit


scout_compute_resolved_api_IntegralSeriesNode.__name__ = "IntegralSeriesNode"
scout_compute_resolved_api_IntegralSeriesNode.__qualname__ = "IntegralSeriesNode"
scout_compute_resolved_api_IntegralSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_InterpolationConfiguration(ConjureUnionType):
    _forward_fill_interpolation: Optional["scout_compute_resolved_api_ForwardFillInterpolation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_interpolation': ConjureFieldDefinition('forwardFillInterpolation', scout_compute_resolved_api_ForwardFillInterpolation)
        }

    def __init__(
            self,
            forward_fill_interpolation: Optional["scout_compute_resolved_api_ForwardFillInterpolation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_interpolation is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_interpolation is not None:
                self._forward_fill_interpolation = forward_fill_interpolation
                self._type = 'forwardFillInterpolation'

        elif type_of_union == 'forwardFillInterpolation':
            if forward_fill_interpolation is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_interpolation = forward_fill_interpolation
            self._type = 'forwardFillInterpolation'

    @builtins.property
    def forward_fill_interpolation(self) -> Optional["scout_compute_resolved_api_ForwardFillInterpolation"]:
        return self._forward_fill_interpolation

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_InterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_InterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillInterpolation' and self.forward_fill_interpolation is not None:
            return visitor._forward_fill_interpolation(self.forward_fill_interpolation)


scout_compute_resolved_api_InterpolationConfiguration.__name__ = "InterpolationConfiguration"
scout_compute_resolved_api_InterpolationConfiguration.__qualname__ = "InterpolationConfiguration"
scout_compute_resolved_api_InterpolationConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_InterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_interpolation(self, forward_fill_interpolation: "scout_compute_resolved_api_ForwardFillInterpolation") -> Any:
        pass


scout_compute_resolved_api_InterpolationConfigurationVisitor.__name__ = "InterpolationConfigurationVisitor"
scout_compute_resolved_api_InterpolationConfigurationVisitor.__qualname__ = "InterpolationConfigurationVisitor"
scout_compute_resolved_api_InterpolationConfigurationVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_IntersectRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_resolved_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_RangesNode"]:
        return self._inputs


scout_compute_resolved_api_IntersectRangesNode.__name__ = "IntersectRangesNode"
scout_compute_resolved_api_IntersectRangesNode.__qualname__ = "IntersectRangesNode"
scout_compute_resolved_api_IntersectRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LiteralEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'points': ConjureFieldDefinition('points', List[scout_compute_api_EnumPoint])
        }

    __slots__: List[str] = ['_points']

    def __init__(self, points: List["scout_compute_api_EnumPoint"]) -> None:
        self._points = points

    @builtins.property
    def points(self) -> List["scout_compute_api_EnumPoint"]:
        return self._points


scout_compute_resolved_api_LiteralEnumSeriesNode.__name__ = "LiteralEnumSeriesNode"
scout_compute_resolved_api_LiteralEnumSeriesNode.__qualname__ = "LiteralEnumSeriesNode"
scout_compute_resolved_api_LiteralEnumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LiteralRange(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp']

    def __init__(self, end_timestamp: Optional["api_Timestamp"] = None, start_timestamp: Optional["api_Timestamp"] = None) -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def start_timestamp(self) -> Optional["api_Timestamp"]:
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> Optional["api_Timestamp"]:
        return self._end_timestamp


scout_compute_resolved_api_LiteralRange.__name__ = "LiteralRange"
scout_compute_resolved_api_LiteralRange.__qualname__ = "LiteralRange"
scout_compute_resolved_api_LiteralRange.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LiteralRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal_ranges': ConjureFieldDefinition('literalRanges', List[scout_compute_resolved_api_LiteralRange])
        }

    __slots__: List[str] = ['_literal_ranges']

    def __init__(self, literal_ranges: List["scout_compute_resolved_api_LiteralRange"]) -> None:
        self._literal_ranges = literal_ranges

    @builtins.property
    def literal_ranges(self) -> List["scout_compute_resolved_api_LiteralRange"]:
        return self._literal_ranges


scout_compute_resolved_api_LiteralRangesNode.__name__ = "LiteralRangesNode"
scout_compute_resolved_api_LiteralRangesNode.__qualname__ = "LiteralRangesNode"
scout_compute_resolved_api_LiteralRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_LogSeriesNode),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_LogFilterOperator)
        }

    __slots__: List[str] = ['_input', '_operator']

    def __init__(self, input: "scout_compute_resolved_api_LogSeriesNode", operator: "scout_compute_api_LogFilterOperator") -> None:
        self._input = input
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_LogSeriesNode":
        return self._input

    @builtins.property
    def operator(self) -> "scout_compute_api_LogFilterOperator":
        return self._operator


scout_compute_resolved_api_LogFilterSeriesNode.__name__ = "LogFilterSeriesNode"
scout_compute_resolved_api_LogFilterSeriesNode.__qualname__ = "LogFilterSeriesNode"
scout_compute_resolved_api_LogFilterSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_RawLogSeriesNode"] = None
    _union: Optional["scout_compute_resolved_api_LogUnionSeriesNode"] = None
    _filter: Optional["scout_compute_resolved_api_LogFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_resolved_api_LogTimeShiftSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawLogSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_resolved_api_LogUnionSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_resolved_api_LogFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_resolved_api_LogTimeShiftSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_RawLogSeriesNode"] = None,
            union: Optional["scout_compute_resolved_api_LogUnionSeriesNode"] = None,
            filter: Optional["scout_compute_resolved_api_LogFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_resolved_api_LogTimeShiftSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (union is not None) + (filter is not None) + (time_shift is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if union is not None:
                self._union = union
                self._type = 'union'
            if filter is not None:
                self._filter = filter
                self._type = 'filter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'filter':
            if filter is None:
                raise ValueError('a union value must not be None')
            self._filter = filter
            self._type = 'filter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawLogSeriesNode"]:
        return self._raw

    @builtins.property
    def union(self) -> Optional["scout_compute_resolved_api_LogUnionSeriesNode"]:
        return self._union

    @builtins.property
    def filter(self) -> Optional["scout_compute_resolved_api_LogFilterSeriesNode"]:
        return self._filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_resolved_api_LogTimeShiftSeriesNode"]:
        return self._time_shift

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_LogSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_LogSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'filter' and self.filter is not None:
            return visitor._filter(self.filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)


scout_compute_resolved_api_LogSeriesNode.__name__ = "LogSeriesNode"
scout_compute_resolved_api_LogSeriesNode.__qualname__ = "LogSeriesNode"
scout_compute_resolved_api_LogSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawLogSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_resolved_api_LogUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter(self, filter: "scout_compute_resolved_api_LogFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_resolved_api_LogTimeShiftSeriesNode") -> Any:
        pass


scout_compute_resolved_api_LogSeriesNodeVisitor.__name__ = "LogSeriesNodeVisitor"
scout_compute_resolved_api_LogSeriesNodeVisitor.__qualname__ = "LogSeriesNodeVisitor"
scout_compute_resolved_api_LogSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_LogSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_resolved_api_LogSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_LogSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_LogTimeShiftSeriesNode.__name__ = "LogTimeShiftSeriesNode"
scout_compute_resolved_api_LogTimeShiftSeriesNode.__qualname__ = "LogTimeShiftSeriesNode"
scout_compute_resolved_api_LogTimeShiftSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_resolved_api_LogSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_LogUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_resolved_api_LogSeriesNode"], operation: "scout_compute_api_LogUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_resolved_api_LogSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_LogUnionOperation":
        return self._operation


scout_compute_resolved_api_LogUnionSeriesNode.__name__ = "LogUnionSeriesNode"
scout_compute_resolved_api_LogUnionSeriesNode.__qualname__ = "LogUnionSeriesNode"
scout_compute_resolved_api_LogUnionSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LogarithmicCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_resolved_api_LogarithmicCurve.__name__ = "LogarithmicCurve"
scout_compute_resolved_api_LogarithmicCurve.__qualname__ = "LogarithmicCurve"
scout_compute_resolved_api_LogarithmicCurve.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_LowPassConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'cutoff_frequency': ConjureFieldDefinition('cutoffFrequency', float)
        }

    __slots__: List[str] = ['_cutoff_frequency']

    def __init__(self, cutoff_frequency: float) -> None:
        self._cutoff_frequency = cutoff_frequency

    @builtins.property
    def cutoff_frequency(self) -> float:
        return self._cutoff_frequency


scout_compute_resolved_api_LowPassConfiguration.__name__ = "LowPassConfiguration"
scout_compute_resolved_api_LowPassConfiguration.__qualname__ = "LowPassConfiguration"
scout_compute_resolved_api_LowPassConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MaxSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MaxSeriesNode.__name__ = "MaxSeriesNode"
scout_compute_resolved_api_MaxSeriesNode.__qualname__ = "MaxSeriesNode"
scout_compute_resolved_api_MaxSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MeanSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MeanSeriesNode.__name__ = "MeanSeriesNode"
scout_compute_resolved_api_MeanSeriesNode.__qualname__ = "MeanSeriesNode"
scout_compute_resolved_api_MeanSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MinMaxThresholdRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'lower_bound': ConjureFieldDefinition('lowerBound', float),
            'upper_bound': ConjureFieldDefinition('upperBound', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_MinMaxThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_lower_bound', '_upper_bound', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", lower_bound: float, operator: "scout_compute_api_MinMaxThresholdOperator", upper_bound: float, persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def lower_bound(self) -> float:
        return self._lower_bound

    @builtins.property
    def upper_bound(self) -> float:
        return self._upper_bound

    @builtins.property
    def operator(self) -> "scout_compute_api_MinMaxThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_MinMaxThresholdRangesNode.__name__ = "MinMaxThresholdRangesNode"
scout_compute_resolved_api_MinMaxThresholdRangesNode.__qualname__ = "MinMaxThresholdRangesNode"
scout_compute_resolved_api_MinMaxThresholdRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_MinSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_MinSeriesNode.__name__ = "MinSeriesNode"
scout_compute_resolved_api_MinSeriesNode.__qualname__ = "MinSeriesNode"
scout_compute_resolved_api_MinSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NominalStorageLocator(ConjureBeanType):
    """A storage locator for Nominal data in the per-org data tables.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_NominalDataSourceOrDatasetRid),
            'type': ConjureFieldDefinition('type', storage_series_api_NominalDataType),
            'details': ConjureFieldDefinition('details', scout_compute_resolved_api_ClickHouseSeriesResolutionDetails),
            'is_in_memory_streaming_enabled': ConjureFieldDefinition('isInMemoryStreamingEnabled', bool)
        }

    __slots__: List[str] = ['_data_source_rid', '_type', '_details', '_is_in_memory_streaming_enabled']

    def __init__(self, data_source_rid: str, details: "scout_compute_resolved_api_ClickHouseSeriesResolutionDetails", is_in_memory_streaming_enabled: bool, type: "storage_series_api_NominalDataType") -> None:
        self._data_source_rid = data_source_rid
        self._type = type
        self._details = details
        self._is_in_memory_streaming_enabled = is_in_memory_streaming_enabled

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def type(self) -> "storage_series_api_NominalDataType":
        return self._type

    @builtins.property
    def details(self) -> "scout_compute_resolved_api_ClickHouseSeriesResolutionDetails":
        return self._details

    @builtins.property
    def is_in_memory_streaming_enabled(self) -> bool:
        return self._is_in_memory_streaming_enabled


scout_compute_resolved_api_NominalStorageLocator.__name__ = "NominalStorageLocator"
scout_compute_resolved_api_NominalStorageLocator.__qualname__ = "NominalStorageLocator"
scout_compute_resolved_api_NominalStorageLocator.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NotRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input


scout_compute_resolved_api_NotRangesNode.__name__ = "NotRangesNode"
scout_compute_resolved_api_NotRangesNode.__qualname__ = "NotRangesNode"
scout_compute_resolved_api_NotRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericArraySeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_ResolvedSeries)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_ResolvedSeries"]:
        return self._raw

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_NumericArraySeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_NumericArraySeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)


scout_compute_resolved_api_NumericArraySeriesNode.__name__ = "NumericArraySeriesNode"
scout_compute_resolved_api_NumericArraySeriesNode.__qualname__ = "NumericArraySeriesNode"
scout_compute_resolved_api_NumericArraySeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericArraySeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_ResolvedSeries") -> Any:
        pass


scout_compute_resolved_api_NumericArraySeriesNodeVisitor.__name__ = "NumericArraySeriesNodeVisitor"
scout_compute_resolved_api_NumericArraySeriesNodeVisitor.__qualname__ = "NumericArraySeriesNodeVisitor"
scout_compute_resolved_api_NumericArraySeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericFilterTransformationSeriesNode(ConjureBeanType):
    """Outputs the values of the numeric plot value within the ranges specified by a ranges node
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'filter': ConjureFieldDefinition('filter', scout_compute_resolved_api_RangesNode)
        }

    __slots__: List[str] = ['_input', '_filter']

    def __init__(self, filter: "scout_compute_resolved_api_RangesNode", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._filter = filter

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def filter(self) -> "scout_compute_resolved_api_RangesNode":
        return self._filter


scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__name__ = "NumericFilterTransformationSeriesNode"
scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__qualname__ = "NumericFilterTransformationSeriesNode"
scout_compute_resolved_api_NumericFilterTransformationSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketStrategy(ConjureUnionType):
    _bucket_count: Optional[int] = None
    _bucket_width_and_offset: Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket_count': ConjureFieldDefinition('bucketCount', int),
            'bucket_width_and_offset': ConjureFieldDefinition('bucketWidthAndOffset', scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset)
        }

    def __init__(
            self,
            bucket_count: Optional[int] = None,
            bucket_width_and_offset: Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket_count is not None) + (bucket_width_and_offset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket_count is not None:
                self._bucket_count = bucket_count
                self._type = 'bucketCount'
            if bucket_width_and_offset is not None:
                self._bucket_width_and_offset = bucket_width_and_offset
                self._type = 'bucketWidthAndOffset'

        elif type_of_union == 'bucketCount':
            if bucket_count is None:
                raise ValueError('a union value must not be None')
            self._bucket_count = bucket_count
            self._type = 'bucketCount'
        elif type_of_union == 'bucketWidthAndOffset':
            if bucket_width_and_offset is None:
                raise ValueError('a union value must not be None')
            self._bucket_width_and_offset = bucket_width_and_offset
            self._type = 'bucketWidthAndOffset'

    @builtins.property
    def bucket_count(self) -> Optional[int]:
        return self._bucket_count

    @builtins.property
    def bucket_width_and_offset(self) -> Optional["scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset"]:
        return self._bucket_width_and_offset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucketCount' and self.bucket_count is not None:
            return visitor._bucket_count(self.bucket_count)
        if self._type == 'bucketWidthAndOffset' and self.bucket_width_and_offset is not None:
            return visitor._bucket_width_and_offset(self.bucket_width_and_offset)


scout_compute_resolved_api_NumericHistogramBucketStrategy.__name__ = "NumericHistogramBucketStrategy"
scout_compute_resolved_api_NumericHistogramBucketStrategy.__qualname__ = "NumericHistogramBucketStrategy"
scout_compute_resolved_api_NumericHistogramBucketStrategy.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor:

    @abstractmethod
    def _bucket_count(self, bucket_count: int) -> Any:
        pass

    @abstractmethod
    def _bucket_width_and_offset(self, bucket_width_and_offset: "scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset") -> Any:
        pass


scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__name__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__qualname__ = "NumericHistogramBucketStrategyVisitor"
scout_compute_resolved_api_NumericHistogramBucketStrategyVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'width': ConjureFieldDefinition('width', float),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_width', '_offset']

    def __init__(self, width: float, offset: Optional[float] = None) -> None:
        self._width = width
        self._offset = offset

    @builtins.property
    def width(self) -> float:
        return self._width

    @builtins.property
    def offset(self) -> Optional[float]:
        return self._offset


scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__name__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__qualname__ = "NumericHistogramBucketWidthAndOffset"
scout_compute_resolved_api_NumericHistogramBucketWidthAndOffset.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericHistogramNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', Dict[scout_compute_api_VariableName, scout_compute_resolved_api_NumericSeriesNode]),
            'bucket_strategy': ConjureFieldDefinition('bucketStrategy', OptionalTypeWrapper[scout_compute_resolved_api_NumericHistogramBucketStrategy])
        }

    __slots__: List[str] = ['_inputs', '_bucket_strategy']

    def __init__(self, inputs: Dict[str, "scout_compute_resolved_api_NumericSeriesNode"], bucket_strategy: Optional["scout_compute_resolved_api_NumericHistogramBucketStrategy"] = None) -> None:
        self._inputs = inputs
        self._bucket_strategy = bucket_strategy

    @builtins.property
    def inputs(self) -> Dict[str, "scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def bucket_strategy(self) -> Optional["scout_compute_resolved_api_NumericHistogramBucketStrategy"]:
        return self._bucket_strategy


scout_compute_resolved_api_NumericHistogramNode.__name__ = "NumericHistogramNode"
scout_compute_resolved_api_NumericHistogramNode.__qualname__ = "NumericHistogramNode"
scout_compute_resolved_api_NumericHistogramNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericResampleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'resample_configuration': ConjureFieldDefinition('resampleConfiguration', scout_compute_resolved_api_ResampleConfiguration)
        }

    __slots__: List[str] = ['_input', '_resample_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", resample_configuration: "scout_compute_resolved_api_ResampleConfiguration") -> None:
        self._input = input
        self._resample_configuration = resample_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def resample_configuration(self) -> "scout_compute_resolved_api_ResampleConfiguration":
        return self._resample_configuration


scout_compute_resolved_api_NumericResampleSeriesNode.__name__ = "NumericResampleSeriesNode"
scout_compute_resolved_api_NumericResampleSeriesNode.__qualname__ = "NumericResampleSeriesNode"
scout_compute_resolved_api_NumericResampleSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericSeriesNode(ConjureUnionType):
    _arithmetic: Optional["scout_compute_resolved_api_ArithmeticSeriesNode"] = None
    _bit_operation: Optional["scout_compute_resolved_api_BitOperationSeriesNode"] = None
    _count_duplicate: Optional["scout_compute_resolved_api_EnumCountDuplicateSeriesNode"] = None
    _cumulative_sum: Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"] = None
    _derivative: Optional["scout_compute_resolved_api_DerivativeSeriesNode"] = None
    _integral: Optional["scout_compute_resolved_api_IntegralSeriesNode"] = None
    _max: Optional["scout_compute_resolved_api_MaxSeriesNode"] = None
    _mean: Optional["scout_compute_resolved_api_MeanSeriesNode"] = None
    _min: Optional["scout_compute_resolved_api_MinSeriesNode"] = None
    _offset: Optional["scout_compute_resolved_api_OffsetSeriesNode"] = None
    _product: Optional["scout_compute_resolved_api_ProductSeriesNode"] = None
    _raw: Optional["scout_compute_resolved_api_RawNumericSeriesNode"] = None
    _resample: Optional["scout_compute_resolved_api_NumericResampleSeriesNode"] = None
    _rolling_operation: Optional["scout_compute_resolved_api_RollingOperationSeriesNode"] = None
    _aggregate: Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"] = None
    _signal_filter: Optional["scout_compute_resolved_api_SignalFilterSeriesNode"] = None
    _sum: Optional["scout_compute_resolved_api_SumSeriesNode"] = None
    _scale: Optional["scout_compute_resolved_api_ScaleSeriesNode"] = None
    _time_difference: Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"] = None
    _time_range_filter: Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"] = None
    _time_shift: Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"] = None
    _unary_arithmetic: Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"] = None
    _binary_arithmetic: Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"] = None
    _union: Optional["scout_compute_resolved_api_NumericUnionSeriesNode"] = None
    _unit_conversion: Optional["scout_compute_resolved_api_UnitConversionSeriesNode"] = None
    _value_difference: Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"] = None
    _filter_transformation: Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"] = None
    _threshold_filter: Optional["scout_compute_resolved_api_NumericThresholdFilterSeriesNode"] = None
    _array_select: Optional["scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode"] = None
    _absolute_timestamp: Optional["scout_compute_resolved_api_AbsoluteTimestampSeriesNode"] = None
    _newest_points: Optional["scout_compute_resolved_api_SelectNewestPointsSeriesNode"] = None
    _ranges_numeric_aggregation_to_numeric: Optional["scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode"] = None
    _filter_by_expression: Optional["scout_compute_resolved_api_FilterByExpressionSeriesNode"] = None
    _enum_to_numeric: Optional["scout_compute_resolved_api_EnumToNumericSeriesNode"] = None
    _refprop: Optional["scout_compute_resolved_api_RefpropSeriesNode"] = None
    _extract_from_struct: Optional["scout_compute_resolved_api_ExtractNumericFromStructSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arithmetic': ConjureFieldDefinition('arithmetic', scout_compute_resolved_api_ArithmeticSeriesNode),
            'bit_operation': ConjureFieldDefinition('bitOperation', scout_compute_resolved_api_BitOperationSeriesNode),
            'count_duplicate': ConjureFieldDefinition('countDuplicate', scout_compute_resolved_api_EnumCountDuplicateSeriesNode),
            'cumulative_sum': ConjureFieldDefinition('cumulativeSum', scout_compute_resolved_api_CumulativeSumSeriesNode),
            'derivative': ConjureFieldDefinition('derivative', scout_compute_resolved_api_DerivativeSeriesNode),
            'integral': ConjureFieldDefinition('integral', scout_compute_resolved_api_IntegralSeriesNode),
            'max': ConjureFieldDefinition('max', scout_compute_resolved_api_MaxSeriesNode),
            'mean': ConjureFieldDefinition('mean', scout_compute_resolved_api_MeanSeriesNode),
            'min': ConjureFieldDefinition('min', scout_compute_resolved_api_MinSeriesNode),
            'offset': ConjureFieldDefinition('offset', scout_compute_resolved_api_OffsetSeriesNode),
            'product': ConjureFieldDefinition('product', scout_compute_resolved_api_ProductSeriesNode),
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawNumericSeriesNode),
            'resample': ConjureFieldDefinition('resample', scout_compute_resolved_api_NumericResampleSeriesNode),
            'rolling_operation': ConjureFieldDefinition('rollingOperation', scout_compute_resolved_api_RollingOperationSeriesNode),
            'aggregate': ConjureFieldDefinition('aggregate', scout_compute_resolved_api_AggregateNumericSeriesNode),
            'signal_filter': ConjureFieldDefinition('signalFilter', scout_compute_resolved_api_SignalFilterSeriesNode),
            'sum': ConjureFieldDefinition('sum', scout_compute_resolved_api_SumSeriesNode),
            'scale': ConjureFieldDefinition('scale', scout_compute_resolved_api_ScaleSeriesNode),
            'time_difference': ConjureFieldDefinition('timeDifference', scout_compute_resolved_api_TimeDifferenceSeriesNode),
            'time_range_filter': ConjureFieldDefinition('timeRangeFilter', scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode),
            'time_shift': ConjureFieldDefinition('timeShift', scout_compute_resolved_api_NumericTimeShiftSeriesNode),
            'unary_arithmetic': ConjureFieldDefinition('unaryArithmetic', scout_compute_resolved_api_UnaryArithmeticSeriesNode),
            'binary_arithmetic': ConjureFieldDefinition('binaryArithmetic', scout_compute_resolved_api_BinaryArithmeticSeriesNode),
            'union': ConjureFieldDefinition('union', scout_compute_resolved_api_NumericUnionSeriesNode),
            'unit_conversion': ConjureFieldDefinition('unitConversion', scout_compute_resolved_api_UnitConversionSeriesNode),
            'value_difference': ConjureFieldDefinition('valueDifference', scout_compute_resolved_api_ValueDifferenceSeriesNode),
            'filter_transformation': ConjureFieldDefinition('filterTransformation', scout_compute_resolved_api_NumericFilterTransformationSeriesNode),
            'threshold_filter': ConjureFieldDefinition('thresholdFilter', scout_compute_resolved_api_NumericThresholdFilterSeriesNode),
            'array_select': ConjureFieldDefinition('arraySelect', scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode),
            'absolute_timestamp': ConjureFieldDefinition('absoluteTimestamp', scout_compute_resolved_api_AbsoluteTimestampSeriesNode),
            'newest_points': ConjureFieldDefinition('newestPoints', scout_compute_resolved_api_SelectNewestPointsSeriesNode),
            'ranges_numeric_aggregation_to_numeric': ConjureFieldDefinition('rangesNumericAggregationToNumeric', scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode),
            'filter_by_expression': ConjureFieldDefinition('filterByExpression', scout_compute_resolved_api_FilterByExpressionSeriesNode),
            'enum_to_numeric': ConjureFieldDefinition('enumToNumeric', scout_compute_resolved_api_EnumToNumericSeriesNode),
            'refprop': ConjureFieldDefinition('refprop', scout_compute_resolved_api_RefpropSeriesNode),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_resolved_api_ExtractNumericFromStructSeriesNode)
        }

    def __init__(
            self,
            arithmetic: Optional["scout_compute_resolved_api_ArithmeticSeriesNode"] = None,
            bit_operation: Optional["scout_compute_resolved_api_BitOperationSeriesNode"] = None,
            count_duplicate: Optional["scout_compute_resolved_api_EnumCountDuplicateSeriesNode"] = None,
            cumulative_sum: Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"] = None,
            derivative: Optional["scout_compute_resolved_api_DerivativeSeriesNode"] = None,
            integral: Optional["scout_compute_resolved_api_IntegralSeriesNode"] = None,
            max: Optional["scout_compute_resolved_api_MaxSeriesNode"] = None,
            mean: Optional["scout_compute_resolved_api_MeanSeriesNode"] = None,
            min: Optional["scout_compute_resolved_api_MinSeriesNode"] = None,
            offset: Optional["scout_compute_resolved_api_OffsetSeriesNode"] = None,
            product: Optional["scout_compute_resolved_api_ProductSeriesNode"] = None,
            raw: Optional["scout_compute_resolved_api_RawNumericSeriesNode"] = None,
            resample: Optional["scout_compute_resolved_api_NumericResampleSeriesNode"] = None,
            rolling_operation: Optional["scout_compute_resolved_api_RollingOperationSeriesNode"] = None,
            aggregate: Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"] = None,
            signal_filter: Optional["scout_compute_resolved_api_SignalFilterSeriesNode"] = None,
            sum: Optional["scout_compute_resolved_api_SumSeriesNode"] = None,
            scale: Optional["scout_compute_resolved_api_ScaleSeriesNode"] = None,
            time_difference: Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"] = None,
            time_range_filter: Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"] = None,
            time_shift: Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"] = None,
            unary_arithmetic: Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"] = None,
            binary_arithmetic: Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"] = None,
            union: Optional["scout_compute_resolved_api_NumericUnionSeriesNode"] = None,
            unit_conversion: Optional["scout_compute_resolved_api_UnitConversionSeriesNode"] = None,
            value_difference: Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"] = None,
            filter_transformation: Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"] = None,
            threshold_filter: Optional["scout_compute_resolved_api_NumericThresholdFilterSeriesNode"] = None,
            array_select: Optional["scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode"] = None,
            absolute_timestamp: Optional["scout_compute_resolved_api_AbsoluteTimestampSeriesNode"] = None,
            newest_points: Optional["scout_compute_resolved_api_SelectNewestPointsSeriesNode"] = None,
            ranges_numeric_aggregation_to_numeric: Optional["scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode"] = None,
            filter_by_expression: Optional["scout_compute_resolved_api_FilterByExpressionSeriesNode"] = None,
            enum_to_numeric: Optional["scout_compute_resolved_api_EnumToNumericSeriesNode"] = None,
            refprop: Optional["scout_compute_resolved_api_RefpropSeriesNode"] = None,
            extract_from_struct: Optional["scout_compute_resolved_api_ExtractNumericFromStructSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (arithmetic is not None) + (bit_operation is not None) + (count_duplicate is not None) + (cumulative_sum is not None) + (derivative is not None) + (integral is not None) + (max is not None) + (mean is not None) + (min is not None) + (offset is not None) + (product is not None) + (raw is not None) + (resample is not None) + (rolling_operation is not None) + (aggregate is not None) + (signal_filter is not None) + (sum is not None) + (scale is not None) + (time_difference is not None) + (time_range_filter is not None) + (time_shift is not None) + (unary_arithmetic is not None) + (binary_arithmetic is not None) + (union is not None) + (unit_conversion is not None) + (value_difference is not None) + (filter_transformation is not None) + (threshold_filter is not None) + (array_select is not None) + (absolute_timestamp is not None) + (newest_points is not None) + (ranges_numeric_aggregation_to_numeric is not None) + (filter_by_expression is not None) + (enum_to_numeric is not None) + (refprop is not None) + (extract_from_struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if arithmetic is not None:
                self._arithmetic = arithmetic
                self._type = 'arithmetic'
            if bit_operation is not None:
                self._bit_operation = bit_operation
                self._type = 'bitOperation'
            if count_duplicate is not None:
                self._count_duplicate = count_duplicate
                self._type = 'countDuplicate'
            if cumulative_sum is not None:
                self._cumulative_sum = cumulative_sum
                self._type = 'cumulativeSum'
            if derivative is not None:
                self._derivative = derivative
                self._type = 'derivative'
            if integral is not None:
                self._integral = integral
                self._type = 'integral'
            if max is not None:
                self._max = max
                self._type = 'max'
            if mean is not None:
                self._mean = mean
                self._type = 'mean'
            if min is not None:
                self._min = min
                self._type = 'min'
            if offset is not None:
                self._offset = offset
                self._type = 'offset'
            if product is not None:
                self._product = product
                self._type = 'product'
            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if resample is not None:
                self._resample = resample
                self._type = 'resample'
            if rolling_operation is not None:
                self._rolling_operation = rolling_operation
                self._type = 'rollingOperation'
            if aggregate is not None:
                self._aggregate = aggregate
                self._type = 'aggregate'
            if signal_filter is not None:
                self._signal_filter = signal_filter
                self._type = 'signalFilter'
            if sum is not None:
                self._sum = sum
                self._type = 'sum'
            if scale is not None:
                self._scale = scale
                self._type = 'scale'
            if time_difference is not None:
                self._time_difference = time_difference
                self._type = 'timeDifference'
            if time_range_filter is not None:
                self._time_range_filter = time_range_filter
                self._type = 'timeRangeFilter'
            if time_shift is not None:
                self._time_shift = time_shift
                self._type = 'timeShift'
            if unary_arithmetic is not None:
                self._unary_arithmetic = unary_arithmetic
                self._type = 'unaryArithmetic'
            if binary_arithmetic is not None:
                self._binary_arithmetic = binary_arithmetic
                self._type = 'binaryArithmetic'
            if union is not None:
                self._union = union
                self._type = 'union'
            if unit_conversion is not None:
                self._unit_conversion = unit_conversion
                self._type = 'unitConversion'
            if value_difference is not None:
                self._value_difference = value_difference
                self._type = 'valueDifference'
            if filter_transformation is not None:
                self._filter_transformation = filter_transformation
                self._type = 'filterTransformation'
            if threshold_filter is not None:
                self._threshold_filter = threshold_filter
                self._type = 'thresholdFilter'
            if array_select is not None:
                self._array_select = array_select
                self._type = 'arraySelect'
            if absolute_timestamp is not None:
                self._absolute_timestamp = absolute_timestamp
                self._type = 'absoluteTimestamp'
            if newest_points is not None:
                self._newest_points = newest_points
                self._type = 'newestPoints'
            if ranges_numeric_aggregation_to_numeric is not None:
                self._ranges_numeric_aggregation_to_numeric = ranges_numeric_aggregation_to_numeric
                self._type = 'rangesNumericAggregationToNumeric'
            if filter_by_expression is not None:
                self._filter_by_expression = filter_by_expression
                self._type = 'filterByExpression'
            if enum_to_numeric is not None:
                self._enum_to_numeric = enum_to_numeric
                self._type = 'enumToNumeric'
            if refprop is not None:
                self._refprop = refprop
                self._type = 'refprop'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'

        elif type_of_union == 'arithmetic':
            if arithmetic is None:
                raise ValueError('a union value must not be None')
            self._arithmetic = arithmetic
            self._type = 'arithmetic'
        elif type_of_union == 'bitOperation':
            if bit_operation is None:
                raise ValueError('a union value must not be None')
            self._bit_operation = bit_operation
            self._type = 'bitOperation'
        elif type_of_union == 'countDuplicate':
            if count_duplicate is None:
                raise ValueError('a union value must not be None')
            self._count_duplicate = count_duplicate
            self._type = 'countDuplicate'
        elif type_of_union == 'cumulativeSum':
            if cumulative_sum is None:
                raise ValueError('a union value must not be None')
            self._cumulative_sum = cumulative_sum
            self._type = 'cumulativeSum'
        elif type_of_union == 'derivative':
            if derivative is None:
                raise ValueError('a union value must not be None')
            self._derivative = derivative
            self._type = 'derivative'
        elif type_of_union == 'integral':
            if integral is None:
                raise ValueError('a union value must not be None')
            self._integral = integral
            self._type = 'integral'
        elif type_of_union == 'max':
            if max is None:
                raise ValueError('a union value must not be None')
            self._max = max
            self._type = 'max'
        elif type_of_union == 'mean':
            if mean is None:
                raise ValueError('a union value must not be None')
            self._mean = mean
            self._type = 'mean'
        elif type_of_union == 'min':
            if min is None:
                raise ValueError('a union value must not be None')
            self._min = min
            self._type = 'min'
        elif type_of_union == 'offset':
            if offset is None:
                raise ValueError('a union value must not be None')
            self._offset = offset
            self._type = 'offset'
        elif type_of_union == 'product':
            if product is None:
                raise ValueError('a union value must not be None')
            self._product = product
            self._type = 'product'
        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'resample':
            if resample is None:
                raise ValueError('a union value must not be None')
            self._resample = resample
            self._type = 'resample'
        elif type_of_union == 'rollingOperation':
            if rolling_operation is None:
                raise ValueError('a union value must not be None')
            self._rolling_operation = rolling_operation
            self._type = 'rollingOperation'
        elif type_of_union == 'aggregate':
            if aggregate is None:
                raise ValueError('a union value must not be None')
            self._aggregate = aggregate
            self._type = 'aggregate'
        elif type_of_union == 'signalFilter':
            if signal_filter is None:
                raise ValueError('a union value must not be None')
            self._signal_filter = signal_filter
            self._type = 'signalFilter'
        elif type_of_union == 'sum':
            if sum is None:
                raise ValueError('a union value must not be None')
            self._sum = sum
            self._type = 'sum'
        elif type_of_union == 'scale':
            if scale is None:
                raise ValueError('a union value must not be None')
            self._scale = scale
            self._type = 'scale'
        elif type_of_union == 'timeDifference':
            if time_difference is None:
                raise ValueError('a union value must not be None')
            self._time_difference = time_difference
            self._type = 'timeDifference'
        elif type_of_union == 'timeRangeFilter':
            if time_range_filter is None:
                raise ValueError('a union value must not be None')
            self._time_range_filter = time_range_filter
            self._type = 'timeRangeFilter'
        elif type_of_union == 'timeShift':
            if time_shift is None:
                raise ValueError('a union value must not be None')
            self._time_shift = time_shift
            self._type = 'timeShift'
        elif type_of_union == 'unaryArithmetic':
            if unary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._unary_arithmetic = unary_arithmetic
            self._type = 'unaryArithmetic'
        elif type_of_union == 'binaryArithmetic':
            if binary_arithmetic is None:
                raise ValueError('a union value must not be None')
            self._binary_arithmetic = binary_arithmetic
            self._type = 'binaryArithmetic'
        elif type_of_union == 'union':
            if union is None:
                raise ValueError('a union value must not be None')
            self._union = union
            self._type = 'union'
        elif type_of_union == 'unitConversion':
            if unit_conversion is None:
                raise ValueError('a union value must not be None')
            self._unit_conversion = unit_conversion
            self._type = 'unitConversion'
        elif type_of_union == 'valueDifference':
            if value_difference is None:
                raise ValueError('a union value must not be None')
            self._value_difference = value_difference
            self._type = 'valueDifference'
        elif type_of_union == 'filterTransformation':
            if filter_transformation is None:
                raise ValueError('a union value must not be None')
            self._filter_transformation = filter_transformation
            self._type = 'filterTransformation'
        elif type_of_union == 'thresholdFilter':
            if threshold_filter is None:
                raise ValueError('a union value must not be None')
            self._threshold_filter = threshold_filter
            self._type = 'thresholdFilter'
        elif type_of_union == 'arraySelect':
            if array_select is None:
                raise ValueError('a union value must not be None')
            self._array_select = array_select
            self._type = 'arraySelect'
        elif type_of_union == 'absoluteTimestamp':
            if absolute_timestamp is None:
                raise ValueError('a union value must not be None')
            self._absolute_timestamp = absolute_timestamp
            self._type = 'absoluteTimestamp'
        elif type_of_union == 'newestPoints':
            if newest_points is None:
                raise ValueError('a union value must not be None')
            self._newest_points = newest_points
            self._type = 'newestPoints'
        elif type_of_union == 'rangesNumericAggregationToNumeric':
            if ranges_numeric_aggregation_to_numeric is None:
                raise ValueError('a union value must not be None')
            self._ranges_numeric_aggregation_to_numeric = ranges_numeric_aggregation_to_numeric
            self._type = 'rangesNumericAggregationToNumeric'
        elif type_of_union == 'filterByExpression':
            if filter_by_expression is None:
                raise ValueError('a union value must not be None')
            self._filter_by_expression = filter_by_expression
            self._type = 'filterByExpression'
        elif type_of_union == 'enumToNumeric':
            if enum_to_numeric is None:
                raise ValueError('a union value must not be None')
            self._enum_to_numeric = enum_to_numeric
            self._type = 'enumToNumeric'
        elif type_of_union == 'refprop':
            if refprop is None:
                raise ValueError('a union value must not be None')
            self._refprop = refprop
            self._type = 'refprop'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'

    @builtins.property
    def arithmetic(self) -> Optional["scout_compute_resolved_api_ArithmeticSeriesNode"]:
        return self._arithmetic

    @builtins.property
    def bit_operation(self) -> Optional["scout_compute_resolved_api_BitOperationSeriesNode"]:
        return self._bit_operation

    @builtins.property
    def count_duplicate(self) -> Optional["scout_compute_resolved_api_EnumCountDuplicateSeriesNode"]:
        return self._count_duplicate

    @builtins.property
    def cumulative_sum(self) -> Optional["scout_compute_resolved_api_CumulativeSumSeriesNode"]:
        return self._cumulative_sum

    @builtins.property
    def derivative(self) -> Optional["scout_compute_resolved_api_DerivativeSeriesNode"]:
        return self._derivative

    @builtins.property
    def integral(self) -> Optional["scout_compute_resolved_api_IntegralSeriesNode"]:
        return self._integral

    @builtins.property
    def max(self) -> Optional["scout_compute_resolved_api_MaxSeriesNode"]:
        return self._max

    @builtins.property
    def mean(self) -> Optional["scout_compute_resolved_api_MeanSeriesNode"]:
        return self._mean

    @builtins.property
    def min(self) -> Optional["scout_compute_resolved_api_MinSeriesNode"]:
        return self._min

    @builtins.property
    def offset(self) -> Optional["scout_compute_resolved_api_OffsetSeriesNode"]:
        return self._offset

    @builtins.property
    def product(self) -> Optional["scout_compute_resolved_api_ProductSeriesNode"]:
        return self._product

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawNumericSeriesNode"]:
        return self._raw

    @builtins.property
    def resample(self) -> Optional["scout_compute_resolved_api_NumericResampleSeriesNode"]:
        return self._resample

    @builtins.property
    def rolling_operation(self) -> Optional["scout_compute_resolved_api_RollingOperationSeriesNode"]:
        return self._rolling_operation

    @builtins.property
    def aggregate(self) -> Optional["scout_compute_resolved_api_AggregateNumericSeriesNode"]:
        return self._aggregate

    @builtins.property
    def signal_filter(self) -> Optional["scout_compute_resolved_api_SignalFilterSeriesNode"]:
        return self._signal_filter

    @builtins.property
    def sum(self) -> Optional["scout_compute_resolved_api_SumSeriesNode"]:
        return self._sum

    @builtins.property
    def scale(self) -> Optional["scout_compute_resolved_api_ScaleSeriesNode"]:
        return self._scale

    @builtins.property
    def time_difference(self) -> Optional["scout_compute_resolved_api_TimeDifferenceSeriesNode"]:
        return self._time_difference

    @builtins.property
    def time_range_filter(self) -> Optional["scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode"]:
        return self._time_range_filter

    @builtins.property
    def time_shift(self) -> Optional["scout_compute_resolved_api_NumericTimeShiftSeriesNode"]:
        return self._time_shift

    @builtins.property
    def unary_arithmetic(self) -> Optional["scout_compute_resolved_api_UnaryArithmeticSeriesNode"]:
        return self._unary_arithmetic

    @builtins.property
    def binary_arithmetic(self) -> Optional["scout_compute_resolved_api_BinaryArithmeticSeriesNode"]:
        return self._binary_arithmetic

    @builtins.property
    def union(self) -> Optional["scout_compute_resolved_api_NumericUnionSeriesNode"]:
        return self._union

    @builtins.property
    def unit_conversion(self) -> Optional["scout_compute_resolved_api_UnitConversionSeriesNode"]:
        return self._unit_conversion

    @builtins.property
    def value_difference(self) -> Optional["scout_compute_resolved_api_ValueDifferenceSeriesNode"]:
        return self._value_difference

    @builtins.property
    def filter_transformation(self) -> Optional["scout_compute_resolved_api_NumericFilterTransformationSeriesNode"]:
        return self._filter_transformation

    @builtins.property
    def threshold_filter(self) -> Optional["scout_compute_resolved_api_NumericThresholdFilterSeriesNode"]:
        return self._threshold_filter

    @builtins.property
    def array_select(self) -> Optional["scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode"]:
        return self._array_select

    @builtins.property
    def absolute_timestamp(self) -> Optional["scout_compute_resolved_api_AbsoluteTimestampSeriesNode"]:
        return self._absolute_timestamp

    @builtins.property
    def newest_points(self) -> Optional["scout_compute_resolved_api_SelectNewestPointsSeriesNode"]:
        return self._newest_points

    @builtins.property
    def ranges_numeric_aggregation_to_numeric(self) -> Optional["scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode"]:
        return self._ranges_numeric_aggregation_to_numeric

    @builtins.property
    def filter_by_expression(self) -> Optional["scout_compute_resolved_api_FilterByExpressionSeriesNode"]:
        return self._filter_by_expression

    @builtins.property
    def enum_to_numeric(self) -> Optional["scout_compute_resolved_api_EnumToNumericSeriesNode"]:
        return self._enum_to_numeric

    @builtins.property
    def refprop(self) -> Optional["scout_compute_resolved_api_RefpropSeriesNode"]:
        return self._refprop

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_resolved_api_ExtractNumericFromStructSeriesNode"]:
        return self._extract_from_struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_NumericSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_NumericSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'arithmetic' and self.arithmetic is not None:
            return visitor._arithmetic(self.arithmetic)
        if self._type == 'bitOperation' and self.bit_operation is not None:
            return visitor._bit_operation(self.bit_operation)
        if self._type == 'countDuplicate' and self.count_duplicate is not None:
            return visitor._count_duplicate(self.count_duplicate)
        if self._type == 'cumulativeSum' and self.cumulative_sum is not None:
            return visitor._cumulative_sum(self.cumulative_sum)
        if self._type == 'derivative' and self.derivative is not None:
            return visitor._derivative(self.derivative)
        if self._type == 'integral' and self.integral is not None:
            return visitor._integral(self.integral)
        if self._type == 'max' and self.max is not None:
            return visitor._max(self.max)
        if self._type == 'mean' and self.mean is not None:
            return visitor._mean(self.mean)
        if self._type == 'min' and self.min is not None:
            return visitor._min(self.min)
        if self._type == 'offset' and self.offset is not None:
            return visitor._offset(self.offset)
        if self._type == 'product' and self.product is not None:
            return visitor._product(self.product)
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'resample' and self.resample is not None:
            return visitor._resample(self.resample)
        if self._type == 'rollingOperation' and self.rolling_operation is not None:
            return visitor._rolling_operation(self.rolling_operation)
        if self._type == 'aggregate' and self.aggregate is not None:
            return visitor._aggregate(self.aggregate)
        if self._type == 'signalFilter' and self.signal_filter is not None:
            return visitor._signal_filter(self.signal_filter)
        if self._type == 'sum' and self.sum is not None:
            return visitor._sum(self.sum)
        if self._type == 'scale' and self.scale is not None:
            return visitor._scale(self.scale)
        if self._type == 'timeDifference' and self.time_difference is not None:
            return visitor._time_difference(self.time_difference)
        if self._type == 'timeRangeFilter' and self.time_range_filter is not None:
            return visitor._time_range_filter(self.time_range_filter)
        if self._type == 'timeShift' and self.time_shift is not None:
            return visitor._time_shift(self.time_shift)
        if self._type == 'unaryArithmetic' and self.unary_arithmetic is not None:
            return visitor._unary_arithmetic(self.unary_arithmetic)
        if self._type == 'binaryArithmetic' and self.binary_arithmetic is not None:
            return visitor._binary_arithmetic(self.binary_arithmetic)
        if self._type == 'union' and self.union is not None:
            return visitor._union(self.union)
        if self._type == 'unitConversion' and self.unit_conversion is not None:
            return visitor._unit_conversion(self.unit_conversion)
        if self._type == 'valueDifference' and self.value_difference is not None:
            return visitor._value_difference(self.value_difference)
        if self._type == 'filterTransformation' and self.filter_transformation is not None:
            return visitor._filter_transformation(self.filter_transformation)
        if self._type == 'thresholdFilter' and self.threshold_filter is not None:
            return visitor._threshold_filter(self.threshold_filter)
        if self._type == 'arraySelect' and self.array_select is not None:
            return visitor._array_select(self.array_select)
        if self._type == 'absoluteTimestamp' and self.absolute_timestamp is not None:
            return visitor._absolute_timestamp(self.absolute_timestamp)
        if self._type == 'newestPoints' and self.newest_points is not None:
            return visitor._newest_points(self.newest_points)
        if self._type == 'rangesNumericAggregationToNumeric' and self.ranges_numeric_aggregation_to_numeric is not None:
            return visitor._ranges_numeric_aggregation_to_numeric(self.ranges_numeric_aggregation_to_numeric)
        if self._type == 'filterByExpression' and self.filter_by_expression is not None:
            return visitor._filter_by_expression(self.filter_by_expression)
        if self._type == 'enumToNumeric' and self.enum_to_numeric is not None:
            return visitor._enum_to_numeric(self.enum_to_numeric)
        if self._type == 'refprop' and self.refprop is not None:
            return visitor._refprop(self.refprop)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)


scout_compute_resolved_api_NumericSeriesNode.__name__ = "NumericSeriesNode"
scout_compute_resolved_api_NumericSeriesNode.__qualname__ = "NumericSeriesNode"
scout_compute_resolved_api_NumericSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericSeriesNodeVisitor:

    @abstractmethod
    def _arithmetic(self, arithmetic: "scout_compute_resolved_api_ArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _bit_operation(self, bit_operation: "scout_compute_resolved_api_BitOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _count_duplicate(self, count_duplicate: "scout_compute_resolved_api_EnumCountDuplicateSeriesNode") -> Any:
        pass

    @abstractmethod
    def _cumulative_sum(self, cumulative_sum: "scout_compute_resolved_api_CumulativeSumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _derivative(self, derivative: "scout_compute_resolved_api_DerivativeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _integral(self, integral: "scout_compute_resolved_api_IntegralSeriesNode") -> Any:
        pass

    @abstractmethod
    def _max(self, max: "scout_compute_resolved_api_MaxSeriesNode") -> Any:
        pass

    @abstractmethod
    def _mean(self, mean: "scout_compute_resolved_api_MeanSeriesNode") -> Any:
        pass

    @abstractmethod
    def _min(self, min: "scout_compute_resolved_api_MinSeriesNode") -> Any:
        pass

    @abstractmethod
    def _offset(self, offset: "scout_compute_resolved_api_OffsetSeriesNode") -> Any:
        pass

    @abstractmethod
    def _product(self, product: "scout_compute_resolved_api_ProductSeriesNode") -> Any:
        pass

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _resample(self, resample: "scout_compute_resolved_api_NumericResampleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _rolling_operation(self, rolling_operation: "scout_compute_resolved_api_RollingOperationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _aggregate(self, aggregate: "scout_compute_resolved_api_AggregateNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _signal_filter(self, signal_filter: "scout_compute_resolved_api_SignalFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _sum(self, sum: "scout_compute_resolved_api_SumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _scale(self, scale: "scout_compute_resolved_api_ScaleSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_difference(self, time_difference: "scout_compute_resolved_api_TimeDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_range_filter(self, time_range_filter: "scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _time_shift(self, time_shift: "scout_compute_resolved_api_NumericTimeShiftSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unary_arithmetic(self, unary_arithmetic: "scout_compute_resolved_api_UnaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _binary_arithmetic(self, binary_arithmetic: "scout_compute_resolved_api_BinaryArithmeticSeriesNode") -> Any:
        pass

    @abstractmethod
    def _union(self, union: "scout_compute_resolved_api_NumericUnionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _unit_conversion(self, unit_conversion: "scout_compute_resolved_api_UnitConversionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value_difference(self, value_difference: "scout_compute_resolved_api_ValueDifferenceSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_transformation(self, filter_transformation: "scout_compute_resolved_api_NumericFilterTransformationSeriesNode") -> Any:
        pass

    @abstractmethod
    def _threshold_filter(self, threshold_filter: "scout_compute_resolved_api_NumericThresholdFilterSeriesNode") -> Any:
        pass

    @abstractmethod
    def _array_select(self, array_select: "scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode") -> Any:
        pass

    @abstractmethod
    def _absolute_timestamp(self, absolute_timestamp: "scout_compute_resolved_api_AbsoluteTimestampSeriesNode") -> Any:
        pass

    @abstractmethod
    def _newest_points(self, newest_points: "scout_compute_resolved_api_SelectNewestPointsSeriesNode") -> Any:
        pass

    @abstractmethod
    def _ranges_numeric_aggregation_to_numeric(self, ranges_numeric_aggregation_to_numeric: "scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _filter_by_expression(self, filter_by_expression: "scout_compute_resolved_api_FilterByExpressionSeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum_to_numeric(self, enum_to_numeric: "scout_compute_resolved_api_EnumToNumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _refprop(self, refprop: "scout_compute_resolved_api_RefpropSeriesNode") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_resolved_api_ExtractNumericFromStructSeriesNode") -> Any:
        pass


scout_compute_resolved_api_NumericSeriesNodeVisitor.__name__ = "NumericSeriesNodeVisitor"
scout_compute_resolved_api_NumericSeriesNodeVisitor.__qualname__ = "NumericSeriesNodeVisitor"
scout_compute_resolved_api_NumericSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericThresholdFilterSeriesNode(ConjureBeanType):
    """Even though this could be implementing using a filter transformation, handling it alone gives
easier pushdown instead of indirecting through ranges nodes
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', float),
            'threshold_operator': ConjureFieldDefinition('thresholdOperator', scout_compute_api_ThresholdOperator)
        }

    __slots__: List[str] = ['_input', '_threshold', '_threshold_operator']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", threshold: float, threshold_operator: "scout_compute_api_ThresholdOperator") -> None:
        self._input = input
        self._threshold = threshold
        self._threshold_operator = threshold_operator

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> float:
        return self._threshold

    @builtins.property
    def threshold_operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._threshold_operator


scout_compute_resolved_api_NumericThresholdFilterSeriesNode.__name__ = "NumericThresholdFilterSeriesNode"
scout_compute_resolved_api_NumericThresholdFilterSeriesNode.__qualname__ = "NumericThresholdFilterSeriesNode"
scout_compute_resolved_api_NumericThresholdFilterSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[api_Timestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_start_time', '_end_time']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", end_time: Optional["api_Timestamp"] = None, start_time: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def start_time(self) -> Optional["api_Timestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["api_Timestamp"]:
        return self._end_time


scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__name__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__qualname__ = "NumericTimeRangeFilterSeriesNode"
scout_compute_resolved_api_NumericTimeRangeFilterSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericTimeShiftSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_input', '_duration']

    def __init__(self, duration: "scout_run_api_Duration", input: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input = input
        self._duration = duration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_NumericTimeShiftSeriesNode.__name__ = "NumericTimeShiftSeriesNode"
scout_compute_resolved_api_NumericTimeShiftSeriesNode.__qualname__ = "NumericTimeShiftSeriesNode"
scout_compute_resolved_api_NumericTimeShiftSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NumericUnionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', List[scout_compute_resolved_api_NumericSeriesNode]),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_NumericUnionOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: List["scout_compute_resolved_api_NumericSeriesNode"], operation: "scout_compute_api_NumericUnionOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_NumericUnionOperation":
        return self._operation


scout_compute_resolved_api_NumericUnionSeriesNode.__name__ = "NumericUnionSeriesNode"
scout_compute_resolved_api_NumericUnionSeriesNode.__qualname__ = "NumericUnionSeriesNode"
scout_compute_resolved_api_NumericUnionSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_NyquistNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'output': ConjureFieldDefinition('output', scout_compute_resolved_api_NumericSeriesNode),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions])
        }

    __slots__: List[str] = ['_input', '_output', '_stft_options']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", output: "scout_compute_resolved_api_NumericSeriesNode", stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._input = input
        self._output = output
        self._stft_options = stft_options

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def output(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._output

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options


scout_compute_resolved_api_NyquistNode.__name__ = "NyquistNode"
scout_compute_resolved_api_NyquistNode.__qualname__ = "NyquistNode"
scout_compute_resolved_api_NyquistNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_OffsetSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', float)
        }

    __slots__: List[str] = ['_input', '_scalar']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", scalar: float) -> None:
        self._input = input
        self._scalar = scalar

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> float:
        return self._scalar


scout_compute_resolved_api_OffsetSeriesNode.__name__ = "OffsetSeriesNode"
scout_compute_resolved_api_OffsetSeriesNode.__qualname__ = "OffsetSeriesNode"
scout_compute_resolved_api_OffsetSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_OnChangeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input


scout_compute_resolved_api_OnChangeRangesNode.__name__ = "OnChangeRangesNode"
scout_compute_resolved_api_OnChangeRangesNode.__qualname__ = "OnChangeRangesNode"
scout_compute_resolved_api_OnChangeRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PaddedRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode),
            'padding': ConjureFieldDefinition('padding', scout_run_api_Duration),
            'padding_configuration': ConjureFieldDefinition('paddingConfiguration', scout_compute_api_RangePaddingConfiguration)
        }

    __slots__: List[str] = ['_input', '_padding', '_padding_configuration']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode", padding: "scout_run_api_Duration", padding_configuration: "scout_compute_api_RangePaddingConfiguration") -> None:
        self._input = input
        self._padding = padding
        self._padding_configuration = padding_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input

    @builtins.property
    def padding(self) -> "scout_run_api_Duration":
        return self._padding

    @builtins.property
    def padding_configuration(self) -> "scout_compute_api_RangePaddingConfiguration":
        return self._padding_configuration


scout_compute_resolved_api_PaddedRangesNode.__name__ = "PaddedRangesNode"
scout_compute_resolved_api_PaddedRangesNode.__qualname__ = "PaddedRangesNode"
scout_compute_resolved_api_PaddedRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PercentageThreshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_value']

    def __init__(self, value: float) -> None:
        self._value = value

    @builtins.property
    def value(self) -> float:
        return self._value


scout_compute_resolved_api_PercentageThreshold.__name__ = "PercentageThreshold"
scout_compute_resolved_api_PercentageThreshold.__qualname__ = "PercentageThreshold"
scout_compute_resolved_api_PercentageThreshold.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PersistenceWindowConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_points': ConjureFieldDefinition('minPoints', OptionalTypeWrapper[int]),
            'min_duration': ConjureFieldDefinition('minDuration', OptionalTypeWrapper[scout_run_api_Duration]),
            'output_range_start': ConjureFieldDefinition('outputRangeStart', scout_compute_api_OutputRangeStart)
        }

    __slots__: List[str] = ['_min_points', '_min_duration', '_output_range_start']

    def __init__(self, output_range_start: "scout_compute_api_OutputRangeStart", min_duration: Optional["scout_run_api_Duration"] = None, min_points: Optional[int] = None) -> None:
        self._min_points = min_points
        self._min_duration = min_duration
        self._output_range_start = output_range_start

    @builtins.property
    def min_points(self) -> Optional[int]:
        return self._min_points

    @builtins.property
    def min_duration(self) -> Optional["scout_run_api_Duration"]:
        return self._min_duration

    @builtins.property
    def output_range_start(self) -> "scout_compute_api_OutputRangeStart":
        return self._output_range_start


scout_compute_resolved_api_PersistenceWindowConfiguration.__name__ = "PersistenceWindowConfiguration"
scout_compute_resolved_api_PersistenceWindowConfiguration.__qualname__ = "PersistenceWindowConfiguration"
scout_compute_resolved_api_PersistenceWindowConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PolynomialCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'degree': ConjureFieldDefinition('degree', int),
            'intercept': ConjureFieldDefinition('intercept', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_degree', '_intercept']

    def __init__(self, degree: int, intercept: Optional[float] = None) -> None:
        self._degree = degree
        self._intercept = intercept

    @builtins.property
    def degree(self) -> int:
        return self._degree

    @builtins.property
    def intercept(self) -> Optional[float]:
        return self._intercept


scout_compute_resolved_api_PolynomialCurve.__name__ = "PolynomialCurve"
scout_compute_resolved_api_PolynomialCurve.__qualname__ = "PolynomialCurve"
scout_compute_resolved_api_PolynomialCurve.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PowerCurve(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_compute_resolved_api_PowerCurve.__name__ = "PowerCurve"
scout_compute_resolved_api_PowerCurve.__qualname__ = "PowerCurve"
scout_compute_resolved_api_PowerCurve.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ProductSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_ProductSeriesNode.__name__ = "ProductSeriesNode"
scout_compute_resolved_api_ProductSeriesNode.__qualname__ = "ProductSeriesNode"
scout_compute_resolved_api_ProductSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_PsdNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'stft_options': ConjureFieldDefinition('stftOptions', OptionalTypeWrapper[scout_compute_api_StftOptions]),
            'magnitude_scaling': ConjureFieldDefinition('magnitudeScaling', OptionalTypeWrapper[scout_compute_api_MagnitudeScaling]),
            'output_frequency_type': ConjureFieldDefinition('outputFrequencyType', OptionalTypeWrapper[scout_compute_api_OutputFrequencyType])
        }

    __slots__: List[str] = ['_input', '_stft_options', '_magnitude_scaling', '_output_frequency_type']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", magnitude_scaling: Optional["scout_compute_api_MagnitudeScaling"] = None, output_frequency_type: Optional["scout_compute_api_OutputFrequencyType"] = None, stft_options: Optional["scout_compute_api_StftOptions"] = None) -> None:
        self._input = input
        self._stft_options = stft_options
        self._magnitude_scaling = magnitude_scaling
        self._output_frequency_type = output_frequency_type

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def stft_options(self) -> Optional["scout_compute_api_StftOptions"]:
        return self._stft_options

    @builtins.property
    def magnitude_scaling(self) -> Optional["scout_compute_api_MagnitudeScaling"]:
        return self._magnitude_scaling

    @builtins.property
    def output_frequency_type(self) -> Optional["scout_compute_api_OutputFrequencyType"]:
        return self._output_frequency_type


scout_compute_resolved_api_PsdNode.__name__ = "PsdNode"
scout_compute_resolved_api_PsdNode.__qualname__ = "PsdNode"
scout_compute_resolved_api_PsdNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangeMap(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[float]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[float]),
            'output': ConjureFieldDefinition('output', str)
        }

    __slots__: List[str] = ['_start', '_end', '_output']

    def __init__(self, output: str, end: Optional[float] = None, start: Optional[float] = None) -> None:
        self._start = start
        self._end = end
        self._output = output

    @builtins.property
    def start(self) -> Optional[float]:
        return self._start

    @builtins.property
    def end(self) -> Optional[float]:
        return self._end

    @builtins.property
    def output(self) -> str:
        return self._output


scout_compute_resolved_api_RangeMap.__name__ = "RangeMap"
scout_compute_resolved_api_RangeMap.__qualname__ = "RangeMap"
scout_compute_resolved_api_RangeMap.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNode(ConjureUnionType):
    _duration_filter: Optional["scout_compute_resolved_api_DurationFilterRangesNode"] = None
    _enum_equality: Optional["scout_compute_resolved_api_EnumEqualityRangesNode"] = None
    _enum_filter: Optional["scout_compute_resolved_api_EnumFilterRangesNode"] = None
    _extrema: Optional["scout_compute_resolved_api_ExtremaRangesNode"] = None
    _intersect_range: Optional["scout_compute_resolved_api_IntersectRangesNode"] = None
    _literal_ranges: Optional["scout_compute_resolved_api_LiteralRangesNode"] = None
    _min_max_threshold: Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"] = None
    _not_: Optional["scout_compute_resolved_api_NotRangesNode"] = None
    _on_change: Optional["scout_compute_resolved_api_OnChangeRangesNode"] = None
    _range_numeric_aggregation: Optional["scout_compute_resolved_api_RangesNumericAggregationNode"] = None
    _series_crossover_ranges_node: Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"] = None
    _stale_range: Optional["scout_compute_resolved_api_StaleRangesNode"] = None
    _stability_detection: Optional["scout_compute_resolved_api_StabilityDetectionRangesNode"] = None
    _threshold: Optional["scout_compute_resolved_api_ThresholdingRangesNode"] = None
    _union_range: Optional["scout_compute_resolved_api_UnionRangesNode"] = None
    _padded_ranges: Optional["scout_compute_resolved_api_PaddedRangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration_filter': ConjureFieldDefinition('durationFilter', scout_compute_resolved_api_DurationFilterRangesNode),
            'enum_equality': ConjureFieldDefinition('enumEquality', scout_compute_resolved_api_EnumEqualityRangesNode),
            'enum_filter': ConjureFieldDefinition('enumFilter', scout_compute_resolved_api_EnumFilterRangesNode),
            'extrema': ConjureFieldDefinition('extrema', scout_compute_resolved_api_ExtremaRangesNode),
            'intersect_range': ConjureFieldDefinition('intersectRange', scout_compute_resolved_api_IntersectRangesNode),
            'literal_ranges': ConjureFieldDefinition('literalRanges', scout_compute_resolved_api_LiteralRangesNode),
            'min_max_threshold': ConjureFieldDefinition('minMaxThreshold', scout_compute_resolved_api_MinMaxThresholdRangesNode),
            'not_': ConjureFieldDefinition('not', scout_compute_resolved_api_NotRangesNode),
            'on_change': ConjureFieldDefinition('onChange', scout_compute_resolved_api_OnChangeRangesNode),
            'range_numeric_aggregation': ConjureFieldDefinition('rangeNumericAggregation', scout_compute_resolved_api_RangesNumericAggregationNode),
            'series_crossover_ranges_node': ConjureFieldDefinition('seriesCrossoverRangesNode', scout_compute_resolved_api_SeriesCrossoverRangesNode),
            'stale_range': ConjureFieldDefinition('staleRange', scout_compute_resolved_api_StaleRangesNode),
            'stability_detection': ConjureFieldDefinition('stabilityDetection', scout_compute_resolved_api_StabilityDetectionRangesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_resolved_api_ThresholdingRangesNode),
            'union_range': ConjureFieldDefinition('unionRange', scout_compute_resolved_api_UnionRangesNode),
            'padded_ranges': ConjureFieldDefinition('paddedRanges', scout_compute_resolved_api_PaddedRangesNode)
        }

    def __init__(
            self,
            duration_filter: Optional["scout_compute_resolved_api_DurationFilterRangesNode"] = None,
            enum_equality: Optional["scout_compute_resolved_api_EnumEqualityRangesNode"] = None,
            enum_filter: Optional["scout_compute_resolved_api_EnumFilterRangesNode"] = None,
            extrema: Optional["scout_compute_resolved_api_ExtremaRangesNode"] = None,
            intersect_range: Optional["scout_compute_resolved_api_IntersectRangesNode"] = None,
            literal_ranges: Optional["scout_compute_resolved_api_LiteralRangesNode"] = None,
            min_max_threshold: Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"] = None,
            not_: Optional["scout_compute_resolved_api_NotRangesNode"] = None,
            on_change: Optional["scout_compute_resolved_api_OnChangeRangesNode"] = None,
            range_numeric_aggregation: Optional["scout_compute_resolved_api_RangesNumericAggregationNode"] = None,
            series_crossover_ranges_node: Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"] = None,
            stale_range: Optional["scout_compute_resolved_api_StaleRangesNode"] = None,
            stability_detection: Optional["scout_compute_resolved_api_StabilityDetectionRangesNode"] = None,
            threshold: Optional["scout_compute_resolved_api_ThresholdingRangesNode"] = None,
            union_range: Optional["scout_compute_resolved_api_UnionRangesNode"] = None,
            padded_ranges: Optional["scout_compute_resolved_api_PaddedRangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duration_filter is not None) + (enum_equality is not None) + (enum_filter is not None) + (extrema is not None) + (intersect_range is not None) + (literal_ranges is not None) + (min_max_threshold is not None) + (not_ is not None) + (on_change is not None) + (range_numeric_aggregation is not None) + (series_crossover_ranges_node is not None) + (stale_range is not None) + (stability_detection is not None) + (threshold is not None) + (union_range is not None) + (padded_ranges is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duration_filter is not None:
                self._duration_filter = duration_filter
                self._type = 'durationFilter'
            if enum_equality is not None:
                self._enum_equality = enum_equality
                self._type = 'enumEquality'
            if enum_filter is not None:
                self._enum_filter = enum_filter
                self._type = 'enumFilter'
            if extrema is not None:
                self._extrema = extrema
                self._type = 'extrema'
            if intersect_range is not None:
                self._intersect_range = intersect_range
                self._type = 'intersectRange'
            if literal_ranges is not None:
                self._literal_ranges = literal_ranges
                self._type = 'literalRanges'
            if min_max_threshold is not None:
                self._min_max_threshold = min_max_threshold
                self._type = 'minMaxThreshold'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if on_change is not None:
                self._on_change = on_change
                self._type = 'onChange'
            if range_numeric_aggregation is not None:
                self._range_numeric_aggregation = range_numeric_aggregation
                self._type = 'rangeNumericAggregation'
            if series_crossover_ranges_node is not None:
                self._series_crossover_ranges_node = series_crossover_ranges_node
                self._type = 'seriesCrossoverRangesNode'
            if stale_range is not None:
                self._stale_range = stale_range
                self._type = 'staleRange'
            if stability_detection is not None:
                self._stability_detection = stability_detection
                self._type = 'stabilityDetection'
            if threshold is not None:
                self._threshold = threshold
                self._type = 'threshold'
            if union_range is not None:
                self._union_range = union_range
                self._type = 'unionRange'
            if padded_ranges is not None:
                self._padded_ranges = padded_ranges
                self._type = 'paddedRanges'

        elif type_of_union == 'durationFilter':
            if duration_filter is None:
                raise ValueError('a union value must not be None')
            self._duration_filter = duration_filter
            self._type = 'durationFilter'
        elif type_of_union == 'enumEquality':
            if enum_equality is None:
                raise ValueError('a union value must not be None')
            self._enum_equality = enum_equality
            self._type = 'enumEquality'
        elif type_of_union == 'enumFilter':
            if enum_filter is None:
                raise ValueError('a union value must not be None')
            self._enum_filter = enum_filter
            self._type = 'enumFilter'
        elif type_of_union == 'extrema':
            if extrema is None:
                raise ValueError('a union value must not be None')
            self._extrema = extrema
            self._type = 'extrema'
        elif type_of_union == 'intersectRange':
            if intersect_range is None:
                raise ValueError('a union value must not be None')
            self._intersect_range = intersect_range
            self._type = 'intersectRange'
        elif type_of_union == 'literalRanges':
            if literal_ranges is None:
                raise ValueError('a union value must not be None')
            self._literal_ranges = literal_ranges
            self._type = 'literalRanges'
        elif type_of_union == 'minMaxThreshold':
            if min_max_threshold is None:
                raise ValueError('a union value must not be None')
            self._min_max_threshold = min_max_threshold
            self._type = 'minMaxThreshold'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'onChange':
            if on_change is None:
                raise ValueError('a union value must not be None')
            self._on_change = on_change
            self._type = 'onChange'
        elif type_of_union == 'rangeNumericAggregation':
            if range_numeric_aggregation is None:
                raise ValueError('a union value must not be None')
            self._range_numeric_aggregation = range_numeric_aggregation
            self._type = 'rangeNumericAggregation'
        elif type_of_union == 'seriesCrossoverRangesNode':
            if series_crossover_ranges_node is None:
                raise ValueError('a union value must not be None')
            self._series_crossover_ranges_node = series_crossover_ranges_node
            self._type = 'seriesCrossoverRangesNode'
        elif type_of_union == 'staleRange':
            if stale_range is None:
                raise ValueError('a union value must not be None')
            self._stale_range = stale_range
            self._type = 'staleRange'
        elif type_of_union == 'stabilityDetection':
            if stability_detection is None:
                raise ValueError('a union value must not be None')
            self._stability_detection = stability_detection
            self._type = 'stabilityDetection'
        elif type_of_union == 'threshold':
            if threshold is None:
                raise ValueError('a union value must not be None')
            self._threshold = threshold
            self._type = 'threshold'
        elif type_of_union == 'unionRange':
            if union_range is None:
                raise ValueError('a union value must not be None')
            self._union_range = union_range
            self._type = 'unionRange'
        elif type_of_union == 'paddedRanges':
            if padded_ranges is None:
                raise ValueError('a union value must not be None')
            self._padded_ranges = padded_ranges
            self._type = 'paddedRanges'

    @builtins.property
    def duration_filter(self) -> Optional["scout_compute_resolved_api_DurationFilterRangesNode"]:
        return self._duration_filter

    @builtins.property
    def enum_equality(self) -> Optional["scout_compute_resolved_api_EnumEqualityRangesNode"]:
        return self._enum_equality

    @builtins.property
    def enum_filter(self) -> Optional["scout_compute_resolved_api_EnumFilterRangesNode"]:
        return self._enum_filter

    @builtins.property
    def extrema(self) -> Optional["scout_compute_resolved_api_ExtremaRangesNode"]:
        return self._extrema

    @builtins.property
    def intersect_range(self) -> Optional["scout_compute_resolved_api_IntersectRangesNode"]:
        return self._intersect_range

    @builtins.property
    def literal_ranges(self) -> Optional["scout_compute_resolved_api_LiteralRangesNode"]:
        return self._literal_ranges

    @builtins.property
    def min_max_threshold(self) -> Optional["scout_compute_resolved_api_MinMaxThresholdRangesNode"]:
        return self._min_max_threshold

    @builtins.property
    def not_(self) -> Optional["scout_compute_resolved_api_NotRangesNode"]:
        return self._not_

    @builtins.property
    def on_change(self) -> Optional["scout_compute_resolved_api_OnChangeRangesNode"]:
        return self._on_change

    @builtins.property
    def range_numeric_aggregation(self) -> Optional["scout_compute_resolved_api_RangesNumericAggregationNode"]:
        return self._range_numeric_aggregation

    @builtins.property
    def series_crossover_ranges_node(self) -> Optional["scout_compute_resolved_api_SeriesCrossoverRangesNode"]:
        return self._series_crossover_ranges_node

    @builtins.property
    def stale_range(self) -> Optional["scout_compute_resolved_api_StaleRangesNode"]:
        return self._stale_range

    @builtins.property
    def stability_detection(self) -> Optional["scout_compute_resolved_api_StabilityDetectionRangesNode"]:
        return self._stability_detection

    @builtins.property
    def threshold(self) -> Optional["scout_compute_resolved_api_ThresholdingRangesNode"]:
        return self._threshold

    @builtins.property
    def union_range(self) -> Optional["scout_compute_resolved_api_UnionRangesNode"]:
        return self._union_range

    @builtins.property
    def padded_ranges(self) -> Optional["scout_compute_resolved_api_PaddedRangesNode"]:
        return self._padded_ranges

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_RangesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_RangesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'durationFilter' and self.duration_filter is not None:
            return visitor._duration_filter(self.duration_filter)
        if self._type == 'enumEquality' and self.enum_equality is not None:
            return visitor._enum_equality(self.enum_equality)
        if self._type == 'enumFilter' and self.enum_filter is not None:
            return visitor._enum_filter(self.enum_filter)
        if self._type == 'extrema' and self.extrema is not None:
            return visitor._extrema(self.extrema)
        if self._type == 'intersectRange' and self.intersect_range is not None:
            return visitor._intersect_range(self.intersect_range)
        if self._type == 'literalRanges' and self.literal_ranges is not None:
            return visitor._literal_ranges(self.literal_ranges)
        if self._type == 'minMaxThreshold' and self.min_max_threshold is not None:
            return visitor._min_max_threshold(self.min_max_threshold)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'onChange' and self.on_change is not None:
            return visitor._on_change(self.on_change)
        if self._type == 'rangeNumericAggregation' and self.range_numeric_aggregation is not None:
            return visitor._range_numeric_aggregation(self.range_numeric_aggregation)
        if self._type == 'seriesCrossoverRangesNode' and self.series_crossover_ranges_node is not None:
            return visitor._series_crossover_ranges_node(self.series_crossover_ranges_node)
        if self._type == 'staleRange' and self.stale_range is not None:
            return visitor._stale_range(self.stale_range)
        if self._type == 'stabilityDetection' and self.stability_detection is not None:
            return visitor._stability_detection(self.stability_detection)
        if self._type == 'threshold' and self.threshold is not None:
            return visitor._threshold(self.threshold)
        if self._type == 'unionRange' and self.union_range is not None:
            return visitor._union_range(self.union_range)
        if self._type == 'paddedRanges' and self.padded_ranges is not None:
            return visitor._padded_ranges(self.padded_ranges)


scout_compute_resolved_api_RangesNode.__name__ = "RangesNode"
scout_compute_resolved_api_RangesNode.__qualname__ = "RangesNode"
scout_compute_resolved_api_RangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNodeVisitor:

    @abstractmethod
    def _duration_filter(self, duration_filter: "scout_compute_resolved_api_DurationFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_equality(self, enum_equality: "scout_compute_resolved_api_EnumEqualityRangesNode") -> Any:
        pass

    @abstractmethod
    def _enum_filter(self, enum_filter: "scout_compute_resolved_api_EnumFilterRangesNode") -> Any:
        pass

    @abstractmethod
    def _extrema(self, extrema: "scout_compute_resolved_api_ExtremaRangesNode") -> Any:
        pass

    @abstractmethod
    def _intersect_range(self, intersect_range: "scout_compute_resolved_api_IntersectRangesNode") -> Any:
        pass

    @abstractmethod
    def _literal_ranges(self, literal_ranges: "scout_compute_resolved_api_LiteralRangesNode") -> Any:
        pass

    @abstractmethod
    def _min_max_threshold(self, min_max_threshold: "scout_compute_resolved_api_MinMaxThresholdRangesNode") -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_compute_resolved_api_NotRangesNode") -> Any:
        pass

    @abstractmethod
    def _on_change(self, on_change: "scout_compute_resolved_api_OnChangeRangesNode") -> Any:
        pass

    @abstractmethod
    def _range_numeric_aggregation(self, range_numeric_aggregation: "scout_compute_resolved_api_RangesNumericAggregationNode") -> Any:
        pass

    @abstractmethod
    def _series_crossover_ranges_node(self, series_crossover_ranges_node: "scout_compute_resolved_api_SeriesCrossoverRangesNode") -> Any:
        pass

    @abstractmethod
    def _stale_range(self, stale_range: "scout_compute_resolved_api_StaleRangesNode") -> Any:
        pass

    @abstractmethod
    def _stability_detection(self, stability_detection: "scout_compute_resolved_api_StabilityDetectionRangesNode") -> Any:
        pass

    @abstractmethod
    def _threshold(self, threshold: "scout_compute_resolved_api_ThresholdingRangesNode") -> Any:
        pass

    @abstractmethod
    def _union_range(self, union_range: "scout_compute_resolved_api_UnionRangesNode") -> Any:
        pass

    @abstractmethod
    def _padded_ranges(self, padded_ranges: "scout_compute_resolved_api_PaddedRangesNode") -> Any:
        pass


scout_compute_resolved_api_RangesNodeVisitor.__name__ = "RangesNodeVisitor"
scout_compute_resolved_api_RangesNodeVisitor.__qualname__ = "RangesNodeVisitor"
scout_compute_resolved_api_RangesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNumericAggregationNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_resolved_api_RangesNode),
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_RangeAggregationOperation)
        }

    __slots__: List[str] = ['_ranges', '_input', '_operation']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operation: "scout_compute_api_RangeAggregationOperation", ranges: "scout_compute_resolved_api_RangesNode") -> None:
        self._ranges = ranges
        self._input = input
        self._operation = operation

    @builtins.property
    def ranges(self) -> "scout_compute_resolved_api_RangesNode":
        return self._ranges

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_RangeAggregationOperation":
        return self._operation


scout_compute_resolved_api_RangesNumericAggregationNode.__name__ = "RangesNumericAggregationNode"
scout_compute_resolved_api_RangesNumericAggregationNode.__qualname__ = "RangesNumericAggregationNode"
scout_compute_resolved_api_RangesNumericAggregationNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNumericAggregationNode)
        }

    __slots__: List[str] = ['_input']

    def __init__(self, input: "scout_compute_resolved_api_RangesNumericAggregationNode") -> None:
        self._input = input

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNumericAggregationNode":
        return self._input


scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode.__name__ = "RangesNumericAggregationToNumericSeriesNode"
scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode.__qualname__ = "RangesNumericAggregationToNumericSeriesNode"
scout_compute_resolved_api_RangesNumericAggregationToNumericSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawEnumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_ResolvedSeries)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_resolved_api_ResolvedSeries") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_resolved_api_ResolvedSeries":
        return self._series


scout_compute_resolved_api_RawEnumSeriesNode.__name__ = "RawEnumSeriesNode"
scout_compute_resolved_api_RawEnumSeriesNode.__qualname__ = "RawEnumSeriesNode"
scout_compute_resolved_api_RawEnumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawLogSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_ResolvedSeries)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_resolved_api_ResolvedSeries") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_resolved_api_ResolvedSeries":
        return self._series


scout_compute_resolved_api_RawLogSeriesNode.__name__ = "RawLogSeriesNode"
scout_compute_resolved_api_RawLogSeriesNode.__qualname__ = "RawLogSeriesNode"
scout_compute_resolved_api_RawLogSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawNumericSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_ResolvedSeries)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_resolved_api_ResolvedSeries") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_resolved_api_ResolvedSeries":
        return self._series


scout_compute_resolved_api_RawNumericSeriesNode.__name__ = "RawNumericSeriesNode"
scout_compute_resolved_api_RawNumericSeriesNode.__qualname__ = "RawNumericSeriesNode"
scout_compute_resolved_api_RawNumericSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RawUntypedSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_ResolvedSeries)
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: "scout_compute_resolved_api_ResolvedSeries") -> None:
        self._series = series

    @builtins.property
    def series(self) -> "scout_compute_resolved_api_ResolvedSeries":
        return self._series


scout_compute_resolved_api_RawUntypedSeriesNode.__name__ = "RawUntypedSeriesNode"
scout_compute_resolved_api_RawUntypedSeriesNode.__qualname__ = "RawUntypedSeriesNode"
scout_compute_resolved_api_RawUntypedSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RefpropSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_input': ConjureFieldDefinition('firstInput', scout_compute_resolved_api_NumericSeriesNode),
            'second_input': ConjureFieldDefinition('secondInput', scout_compute_resolved_api_NumericSeriesNode),
            'first_property': ConjureFieldDefinition('firstProperty', scout_compute_api_RefpropProperty),
            'second_property': ConjureFieldDefinition('secondProperty', scout_compute_api_RefpropProperty),
            'output_property': ConjureFieldDefinition('outputProperty', scout_compute_api_RefpropProperty),
            'substance': ConjureFieldDefinition('substance', scout_compute_api_RefpropSubstance),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_first_input', '_second_input', '_first_property', '_second_property', '_output_property', '_substance', '_interpolation_configuration']

    def __init__(self, first_input: "scout_compute_resolved_api_NumericSeriesNode", first_property: "scout_compute_api_RefpropProperty", interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration", output_property: "scout_compute_api_RefpropProperty", second_input: "scout_compute_resolved_api_NumericSeriesNode", second_property: "scout_compute_api_RefpropProperty", substance: "scout_compute_api_RefpropSubstance") -> None:
        self._first_input = first_input
        self._second_input = second_input
        self._first_property = first_property
        self._second_property = second_property
        self._output_property = output_property
        self._substance = substance
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def first_input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._first_input

    @builtins.property
    def second_input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._second_input

    @builtins.property
    def first_property(self) -> "scout_compute_api_RefpropProperty":
        return self._first_property

    @builtins.property
    def second_property(self) -> "scout_compute_api_RefpropProperty":
        return self._second_property

    @builtins.property
    def output_property(self) -> "scout_compute_api_RefpropProperty":
        return self._output_property

    @builtins.property
    def substance(self) -> "scout_compute_api_RefpropSubstance":
        return self._substance

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_RefpropSeriesNode.__name__ = "RefpropSeriesNode"
scout_compute_resolved_api_RefpropSeriesNode.__qualname__ = "RefpropSeriesNode"
scout_compute_resolved_api_RefpropSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'interval': ConjureFieldDefinition('interval', scout_run_api_Duration),
            'interpolation': ConjureFieldDefinition('interpolation', scout_compute_resolved_api_ResampleInterpolationConfiguration)
        }

    __slots__: List[str] = ['_interval', '_interpolation']

    def __init__(self, interpolation: "scout_compute_resolved_api_ResampleInterpolationConfiguration", interval: "scout_run_api_Duration") -> None:
        self._interval = interval
        self._interpolation = interpolation

    @builtins.property
    def interval(self) -> "scout_run_api_Duration":
        return self._interval

    @builtins.property
    def interpolation(self) -> "scout_compute_resolved_api_ResampleInterpolationConfiguration":
        return self._interpolation


scout_compute_resolved_api_ResampleConfiguration.__name__ = "ResampleConfiguration"
scout_compute_resolved_api_ResampleConfiguration.__qualname__ = "ResampleConfiguration"
scout_compute_resolved_api_ResampleConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConfiguration(ConjureUnionType):
    _forward_fill_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"] = None
    _constant_default_value_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'forward_fill_resample_interpolation_configuration': ConjureFieldDefinition('forwardFillResampleInterpolationConfiguration', scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration),
            'constant_default_value_resample_interpolation_configuration': ConjureFieldDefinition('constantDefaultValueResampleInterpolationConfiguration', scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration)
        }

    def __init__(
            self,
            forward_fill_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"] = None,
            constant_default_value_resample_interpolation_configuration: Optional["scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (forward_fill_resample_interpolation_configuration is not None) + (constant_default_value_resample_interpolation_configuration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if forward_fill_resample_interpolation_configuration is not None:
                self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
                self._type = 'forwardFillResampleInterpolationConfiguration'
            if constant_default_value_resample_interpolation_configuration is not None:
                self._constant_default_value_resample_interpolation_configuration = constant_default_value_resample_interpolation_configuration
                self._type = 'constantDefaultValueResampleInterpolationConfiguration'

        elif type_of_union == 'forwardFillResampleInterpolationConfiguration':
            if forward_fill_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._forward_fill_resample_interpolation_configuration = forward_fill_resample_interpolation_configuration
            self._type = 'forwardFillResampleInterpolationConfiguration'
        elif type_of_union == 'constantDefaultValueResampleInterpolationConfiguration':
            if constant_default_value_resample_interpolation_configuration is None:
                raise ValueError('a union value must not be None')
            self._constant_default_value_resample_interpolation_configuration = constant_default_value_resample_interpolation_configuration
            self._type = 'constantDefaultValueResampleInterpolationConfiguration'

    @builtins.property
    def forward_fill_resample_interpolation_configuration(self) -> Optional["scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration"]:
        return self._forward_fill_resample_interpolation_configuration

    @builtins.property
    def constant_default_value_resample_interpolation_configuration(self) -> Optional["scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration"]:
        return self._constant_default_value_resample_interpolation_configuration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'forwardFillResampleInterpolationConfiguration' and self.forward_fill_resample_interpolation_configuration is not None:
            return visitor._forward_fill_resample_interpolation_configuration(self.forward_fill_resample_interpolation_configuration)
        if self._type == 'constantDefaultValueResampleInterpolationConfiguration' and self.constant_default_value_resample_interpolation_configuration is not None:
            return visitor._constant_default_value_resample_interpolation_configuration(self.constant_default_value_resample_interpolation_configuration)


scout_compute_resolved_api_ResampleInterpolationConfiguration.__name__ = "ResampleInterpolationConfiguration"
scout_compute_resolved_api_ResampleInterpolationConfiguration.__qualname__ = "ResampleInterpolationConfiguration"
scout_compute_resolved_api_ResampleInterpolationConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor:

    @abstractmethod
    def _forward_fill_resample_interpolation_configuration(self, forward_fill_resample_interpolation_configuration: "scout_compute_resolved_api_ForwardFillResampleInterpolationConfiguration") -> Any:
        pass

    @abstractmethod
    def _constant_default_value_resample_interpolation_configuration(self, constant_default_value_resample_interpolation_configuration: "scout_compute_resolved_api_ConstantDefaultValueResampleInterpolationConfiguration") -> Any:
        pass


scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__name__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__qualname__ = "ResampleInterpolationConfigurationVisitor"
scout_compute_resolved_api_ResampleInterpolationConfigurationVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue(ConjureUnionType):
    _numeric: Optional[float] = None
    _enum: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'numeric': ConjureFieldDefinition('numeric', float),
            'enum': ConjureFieldDefinition('enum', str)
        }

    def __init__(
            self,
            numeric: Optional[float] = None,
            enum: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (numeric is not None) + (enum is not None) != 1:
                raise ValueError('a union must contain a single member')

            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'

        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'

    @builtins.property
    def numeric(self) -> Optional[float]:
        return self._numeric

    @builtins.property
    def enum(self) -> Optional[str]:
        return self._enum

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)


scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue.__name__ = "ResampleInterpolationConstantDefaultValue"
scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue.__qualname__ = "ResampleInterpolationConstantDefaultValue"
scout_compute_resolved_api_ResampleInterpolationConstantDefaultValue.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor:

    @abstractmethod
    def _numeric(self, numeric: float) -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: str) -> Any:
        pass


scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor.__name__ = "ResampleInterpolationConstantDefaultValueVisitor"
scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor.__qualname__ = "ResampleInterpolationConstantDefaultValueVisitor"
scout_compute_resolved_api_ResampleInterpolationConstantDefaultValueVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResolvedNode(ConjureUnionType):
    _ranges: Optional["scout_compute_resolved_api_SummarizeRangesNode"] = None
    _series: Optional["scout_compute_resolved_api_SummarizeSeriesNode"] = None
    _value: Optional["scout_compute_resolved_api_SelectValueNode"] = None
    _cartesian: Optional["scout_compute_resolved_api_SummarizeCartesianNode"] = None
    _cartesian3d: Optional["scout_compute_resolved_api_SummarizeCartesian3dNode"] = None
    _frequency: Optional["scout_compute_resolved_api_FrequencyDomainNode"] = None
    _frequency_v2: Optional["scout_compute_resolved_api_FrequencyDomainNodeV2"] = None
    _histogram: Optional["scout_compute_resolved_api_HistogramNode"] = None
    _curve: Optional["scout_compute_resolved_api_CurveFitNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ranges': ConjureFieldDefinition('ranges', scout_compute_resolved_api_SummarizeRangesNode),
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_SummarizeSeriesNode),
            'value': ConjureFieldDefinition('value', scout_compute_resolved_api_SelectValueNode),
            'cartesian': ConjureFieldDefinition('cartesian', scout_compute_resolved_api_SummarizeCartesianNode),
            'cartesian3d': ConjureFieldDefinition('cartesian3d', scout_compute_resolved_api_SummarizeCartesian3dNode),
            'frequency': ConjureFieldDefinition('frequency', scout_compute_resolved_api_FrequencyDomainNode),
            'frequency_v2': ConjureFieldDefinition('frequencyV2', scout_compute_resolved_api_FrequencyDomainNodeV2),
            'histogram': ConjureFieldDefinition('histogram', scout_compute_resolved_api_HistogramNode),
            'curve': ConjureFieldDefinition('curve', scout_compute_resolved_api_CurveFitNode)
        }

    def __init__(
            self,
            ranges: Optional["scout_compute_resolved_api_SummarizeRangesNode"] = None,
            series: Optional["scout_compute_resolved_api_SummarizeSeriesNode"] = None,
            value: Optional["scout_compute_resolved_api_SelectValueNode"] = None,
            cartesian: Optional["scout_compute_resolved_api_SummarizeCartesianNode"] = None,
            cartesian3d: Optional["scout_compute_resolved_api_SummarizeCartesian3dNode"] = None,
            frequency: Optional["scout_compute_resolved_api_FrequencyDomainNode"] = None,
            frequency_v2: Optional["scout_compute_resolved_api_FrequencyDomainNodeV2"] = None,
            histogram: Optional["scout_compute_resolved_api_HistogramNode"] = None,
            curve: Optional["scout_compute_resolved_api_CurveFitNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ranges is not None) + (series is not None) + (value is not None) + (cartesian is not None) + (cartesian3d is not None) + (frequency is not None) + (frequency_v2 is not None) + (histogram is not None) + (curve is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ranges is not None:
                self._ranges = ranges
                self._type = 'ranges'
            if series is not None:
                self._series = series
                self._type = 'series'
            if value is not None:
                self._value = value
                self._type = 'value'
            if cartesian is not None:
                self._cartesian = cartesian
                self._type = 'cartesian'
            if cartesian3d is not None:
                self._cartesian3d = cartesian3d
                self._type = 'cartesian3d'
            if frequency is not None:
                self._frequency = frequency
                self._type = 'frequency'
            if frequency_v2 is not None:
                self._frequency_v2 = frequency_v2
                self._type = 'frequencyV2'
            if histogram is not None:
                self._histogram = histogram
                self._type = 'histogram'
            if curve is not None:
                self._curve = curve
                self._type = 'curve'

        elif type_of_union == 'ranges':
            if ranges is None:
                raise ValueError('a union value must not be None')
            self._ranges = ranges
            self._type = 'ranges'
        elif type_of_union == 'series':
            if series is None:
                raise ValueError('a union value must not be None')
            self._series = series
            self._type = 'series'
        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'
        elif type_of_union == 'cartesian':
            if cartesian is None:
                raise ValueError('a union value must not be None')
            self._cartesian = cartesian
            self._type = 'cartesian'
        elif type_of_union == 'cartesian3d':
            if cartesian3d is None:
                raise ValueError('a union value must not be None')
            self._cartesian3d = cartesian3d
            self._type = 'cartesian3d'
        elif type_of_union == 'frequency':
            if frequency is None:
                raise ValueError('a union value must not be None')
            self._frequency = frequency
            self._type = 'frequency'
        elif type_of_union == 'frequencyV2':
            if frequency_v2 is None:
                raise ValueError('a union value must not be None')
            self._frequency_v2 = frequency_v2
            self._type = 'frequencyV2'
        elif type_of_union == 'histogram':
            if histogram is None:
                raise ValueError('a union value must not be None')
            self._histogram = histogram
            self._type = 'histogram'
        elif type_of_union == 'curve':
            if curve is None:
                raise ValueError('a union value must not be None')
            self._curve = curve
            self._type = 'curve'

    @builtins.property
    def ranges(self) -> Optional["scout_compute_resolved_api_SummarizeRangesNode"]:
        return self._ranges

    @builtins.property
    def series(self) -> Optional["scout_compute_resolved_api_SummarizeSeriesNode"]:
        return self._series

    @builtins.property
    def value(self) -> Optional["scout_compute_resolved_api_SelectValueNode"]:
        return self._value

    @builtins.property
    def cartesian(self) -> Optional["scout_compute_resolved_api_SummarizeCartesianNode"]:
        return self._cartesian

    @builtins.property
    def cartesian3d(self) -> Optional["scout_compute_resolved_api_SummarizeCartesian3dNode"]:
        return self._cartesian3d

    @builtins.property
    def frequency(self) -> Optional["scout_compute_resolved_api_FrequencyDomainNode"]:
        return self._frequency

    @builtins.property
    def frequency_v2(self) -> Optional["scout_compute_resolved_api_FrequencyDomainNodeV2"]:
        return self._frequency_v2

    @builtins.property
    def histogram(self) -> Optional["scout_compute_resolved_api_HistogramNode"]:
        return self._histogram

    @builtins.property
    def curve(self) -> Optional["scout_compute_resolved_api_CurveFitNode"]:
        return self._curve

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ResolvedNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ResolvedNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ranges' and self.ranges is not None:
            return visitor._ranges(self.ranges)
        if self._type == 'series' and self.series is not None:
            return visitor._series(self.series)
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)
        if self._type == 'cartesian' and self.cartesian is not None:
            return visitor._cartesian(self.cartesian)
        if self._type == 'cartesian3d' and self.cartesian3d is not None:
            return visitor._cartesian3d(self.cartesian3d)
        if self._type == 'frequency' and self.frequency is not None:
            return visitor._frequency(self.frequency)
        if self._type == 'frequencyV2' and self.frequency_v2 is not None:
            return visitor._frequency_v2(self.frequency_v2)
        if self._type == 'histogram' and self.histogram is not None:
            return visitor._histogram(self.histogram)
        if self._type == 'curve' and self.curve is not None:
            return visitor._curve(self.curve)


scout_compute_resolved_api_ResolvedNode.__name__ = "ResolvedNode"
scout_compute_resolved_api_ResolvedNode.__qualname__ = "ResolvedNode"
scout_compute_resolved_api_ResolvedNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResolvedNodeVisitor:

    @abstractmethod
    def _ranges(self, ranges: "scout_compute_resolved_api_SummarizeRangesNode") -> Any:
        pass

    @abstractmethod
    def _series(self, series: "scout_compute_resolved_api_SummarizeSeriesNode") -> Any:
        pass

    @abstractmethod
    def _value(self, value: "scout_compute_resolved_api_SelectValueNode") -> Any:
        pass

    @abstractmethod
    def _cartesian(self, cartesian: "scout_compute_resolved_api_SummarizeCartesianNode") -> Any:
        pass

    @abstractmethod
    def _cartesian3d(self, cartesian3d: "scout_compute_resolved_api_SummarizeCartesian3dNode") -> Any:
        pass

    @abstractmethod
    def _frequency(self, frequency: "scout_compute_resolved_api_FrequencyDomainNode") -> Any:
        pass

    @abstractmethod
    def _frequency_v2(self, frequency_v2: "scout_compute_resolved_api_FrequencyDomainNodeV2") -> Any:
        pass

    @abstractmethod
    def _histogram(self, histogram: "scout_compute_resolved_api_HistogramNode") -> Any:
        pass

    @abstractmethod
    def _curve(self, curve: "scout_compute_resolved_api_CurveFitNode") -> Any:
        pass


scout_compute_resolved_api_ResolvedNodeVisitor.__name__ = "ResolvedNodeVisitor"
scout_compute_resolved_api_ResolvedNodeVisitor.__qualname__ = "ResolvedNodeVisitor"
scout_compute_resolved_api_ResolvedNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ResolvedSeries(ConjureBeanType):
    """A resolved series is a fully-formed read on a raw set of series. The data for series may be stored in the
Nominal database or externally.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'storage_locator': ConjureFieldDefinition('storageLocator', scout_compute_resolved_api_StorageLocator),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit])
        }

    __slots__: List[str] = ['_storage_locator', '_unit']

    def __init__(self, storage_locator: "scout_compute_resolved_api_StorageLocator", unit: Optional[str] = None) -> None:
        self._storage_locator = storage_locator
        self._unit = unit

    @builtins.property
    def storage_locator(self) -> "scout_compute_resolved_api_StorageLocator":
        return self._storage_locator

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit


scout_compute_resolved_api_ResolvedSeries.__name__ = "ResolvedSeries"
scout_compute_resolved_api_ResolvedSeries.__qualname__ = "ResolvedSeries"
scout_compute_resolved_api_ResolvedSeries.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_RollingOperationSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'window': ConjureFieldDefinition('window', scout_compute_resolved_api_Window),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_RollingOperator)
        }

    __slots__: List[str] = ['_input', '_window', '_operator']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operator: "scout_compute_api_RollingOperator", window: "scout_compute_resolved_api_Window") -> None:
        self._input = input
        self._window = window
        self._operator = operator

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def window(self) -> "scout_compute_resolved_api_Window":
        return self._window

    @builtins.property
    def operator(self) -> "scout_compute_api_RollingOperator":
        return self._operator


scout_compute_resolved_api_RollingOperationSeriesNode.__name__ = "RollingOperationSeriesNode"
scout_compute_resolved_api_RollingOperationSeriesNode.__qualname__ = "RollingOperationSeriesNode"
scout_compute_resolved_api_RollingOperationSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScaleSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'scalar': ConjureFieldDefinition('scalar', float),
            'scalar_unit': ConjureFieldDefinition('scalarUnit', OptionalTypeWrapper[scout_units_api_UnitSymbol])
        }

    __slots__: List[str] = ['_input', '_scalar', '_scalar_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", scalar: float, scalar_unit: Optional[str] = None) -> None:
        self._input = input
        self._scalar = scalar
        self._scalar_unit = scalar_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def scalar(self) -> float:
        return self._scalar

    @builtins.property
    def scalar_unit(self) -> Optional[str]:
        return self._scalar_unit


scout_compute_resolved_api_ScaleSeriesNode.__name__ = "ScaleSeriesNode"
scout_compute_resolved_api_ScaleSeriesNode.__qualname__ = "ScaleSeriesNode"
scout_compute_resolved_api_ScaleSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Scatter3dNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_resolved_api_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_resolved_api_NumericSeriesNode),
            'z': ConjureFieldDefinition('z', scout_compute_resolved_api_NumericSeriesNode),
            'driver_series': ConjureFieldDefinition('driverSeries', scout_compute_api_DriverSeries3d)
        }

    __slots__: List[str] = ['_x', '_y', '_z', '_driver_series']

    def __init__(self, driver_series: "scout_compute_api_DriverSeries3d", x: "scout_compute_resolved_api_NumericSeriesNode", y: "scout_compute_resolved_api_NumericSeriesNode", z: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._x = x
        self._y = y
        self._z = z
        self._driver_series = driver_series

    @builtins.property
    def x(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._y

    @builtins.property
    def z(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._z

    @builtins.property
    def driver_series(self) -> "scout_compute_api_DriverSeries3d":
        return self._driver_series


scout_compute_resolved_api_Scatter3dNode.__name__ = "Scatter3dNode"
scout_compute_resolved_api_Scatter3dNode.__qualname__ = "Scatter3dNode"
scout_compute_resolved_api_Scatter3dNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScatterCurveFitNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scatter': ConjureFieldDefinition('scatter', scout_compute_resolved_api_ScatterNode),
            'options': ConjureFieldDefinition('options', scout_compute_resolved_api_ScatterFitOptions)
        }

    __slots__: List[str] = ['_scatter', '_options']

    def __init__(self, options: "scout_compute_resolved_api_ScatterFitOptions", scatter: "scout_compute_resolved_api_ScatterNode") -> None:
        self._scatter = scatter
        self._options = options

    @builtins.property
    def scatter(self) -> "scout_compute_resolved_api_ScatterNode":
        return self._scatter

    @builtins.property
    def options(self) -> "scout_compute_resolved_api_ScatterFitOptions":
        return self._options


scout_compute_resolved_api_ScatterCurveFitNode.__name__ = "ScatterCurveFitNode"
scout_compute_resolved_api_ScatterCurveFitNode.__qualname__ = "ScatterCurveFitNode"
scout_compute_resolved_api_ScatterCurveFitNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScatterFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_x': ConjureFieldDefinition('minX', OptionalTypeWrapper[float]),
            'max_x': ConjureFieldDefinition('maxX', OptionalTypeWrapper[float]),
            'min_y': ConjureFieldDefinition('minY', OptionalTypeWrapper[float]),
            'max_y': ConjureFieldDefinition('maxY', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_min_x', '_max_x', '_min_y', '_max_y']

    def __init__(self, max_x: Optional[float] = None, max_y: Optional[float] = None, min_x: Optional[float] = None, min_y: Optional[float] = None) -> None:
        self._min_x = min_x
        self._max_x = max_x
        self._min_y = min_y
        self._max_y = max_y

    @builtins.property
    def min_x(self) -> Optional[float]:
        return self._min_x

    @builtins.property
    def max_x(self) -> Optional[float]:
        return self._max_x

    @builtins.property
    def min_y(self) -> Optional[float]:
        return self._min_y

    @builtins.property
    def max_y(self) -> Optional[float]:
        return self._max_y


scout_compute_resolved_api_ScatterFitOptions.__name__ = "ScatterFitOptions"
scout_compute_resolved_api_ScatterFitOptions.__qualname__ = "ScatterFitOptions"
scout_compute_resolved_api_ScatterFitOptions.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ScatterNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x': ConjureFieldDefinition('x', scout_compute_resolved_api_NumericSeriesNode),
            'y': ConjureFieldDefinition('y', scout_compute_resolved_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_x', '_y']

    def __init__(self, x: "scout_compute_resolved_api_NumericSeriesNode", y: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._x = x
        self._y = y

    @builtins.property
    def x(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._x

    @builtins.property
    def y(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._y


scout_compute_resolved_api_ScatterNode.__name__ = "ScatterNode"
scout_compute_resolved_api_ScatterNode.__qualname__ = "ScatterNode"
scout_compute_resolved_api_ScatterNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_EnumArraySeriesNode),
            'index': ConjureFieldDefinition('index', int)
        }

    __slots__: List[str] = ['_input', '_index']

    def __init__(self, index: int, input: "scout_compute_resolved_api_EnumArraySeriesNode") -> None:
        self._input = input
        self._index = index

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_EnumArraySeriesNode":
        return self._input

    @builtins.property
    def index(self) -> int:
        return self._index


scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode.__name__ = "SelectIndexFromEnumArraySeriesNode"
scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode.__qualname__ = "SelectIndexFromEnumArraySeriesNode"
scout_compute_resolved_api_SelectIndexFromEnumArraySeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericArraySeriesNode),
            'index': ConjureFieldDefinition('index', int)
        }

    __slots__: List[str] = ['_input', '_index']

    def __init__(self, index: int, input: "scout_compute_resolved_api_NumericArraySeriesNode") -> None:
        self._input = input
        self._index = index

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericArraySeriesNode":
        return self._input

    @builtins.property
    def index(self) -> int:
        return self._index


scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode.__name__ = "SelectIndexFromNumericArraySeriesNode"
scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode.__qualname__ = "SelectIndexFromNumericArraySeriesNode"
scout_compute_resolved_api_SelectIndexFromNumericArraySeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectNewestPointsSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'num_points': ConjureFieldDefinition('numPoints', int)
        }

    __slots__: List[str] = ['_input', '_num_points']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", num_points: int) -> None:
        self._input = input
        self._num_points = num_points

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def num_points(self) -> int:
        return self._num_points


scout_compute_resolved_api_SelectNewestPointsSeriesNode.__name__ = "SelectNewestPointsSeriesNode"
scout_compute_resolved_api_SelectNewestPointsSeriesNode.__qualname__ = "SelectNewestPointsSeriesNode"
scout_compute_resolved_api_SelectNewestPointsSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectValueNode(ConjureUnionType):
    _first_point: Optional["scout_compute_resolved_api_SeriesNode"] = None
    _first_value_point: Optional["scout_compute_resolved_api_SeriesNode"] = None
    _first_range: Optional["scout_compute_resolved_api_RangesNode"] = None
    _last_point: Optional["scout_compute_resolved_api_SeriesNode"] = None
    _last_value_point: Optional["scout_compute_resolved_api_SeriesNode"] = None
    _last_range: Optional["scout_compute_resolved_api_RangesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'first_point': ConjureFieldDefinition('firstPoint', scout_compute_resolved_api_SeriesNode),
            'first_value_point': ConjureFieldDefinition('firstValuePoint', scout_compute_resolved_api_SeriesNode),
            'first_range': ConjureFieldDefinition('firstRange', scout_compute_resolved_api_RangesNode),
            'last_point': ConjureFieldDefinition('lastPoint', scout_compute_resolved_api_SeriesNode),
            'last_value_point': ConjureFieldDefinition('lastValuePoint', scout_compute_resolved_api_SeriesNode),
            'last_range': ConjureFieldDefinition('lastRange', scout_compute_resolved_api_RangesNode)
        }

    def __init__(
            self,
            first_point: Optional["scout_compute_resolved_api_SeriesNode"] = None,
            first_value_point: Optional["scout_compute_resolved_api_SeriesNode"] = None,
            first_range: Optional["scout_compute_resolved_api_RangesNode"] = None,
            last_point: Optional["scout_compute_resolved_api_SeriesNode"] = None,
            last_value_point: Optional["scout_compute_resolved_api_SeriesNode"] = None,
            last_range: Optional["scout_compute_resolved_api_RangesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (first_point is not None) + (first_value_point is not None) + (first_range is not None) + (last_point is not None) + (last_value_point is not None) + (last_range is not None) != 1:
                raise ValueError('a union must contain a single member')

            if first_point is not None:
                self._first_point = first_point
                self._type = 'firstPoint'
            if first_value_point is not None:
                self._first_value_point = first_value_point
                self._type = 'firstValuePoint'
            if first_range is not None:
                self._first_range = first_range
                self._type = 'firstRange'
            if last_point is not None:
                self._last_point = last_point
                self._type = 'lastPoint'
            if last_value_point is not None:
                self._last_value_point = last_value_point
                self._type = 'lastValuePoint'
            if last_range is not None:
                self._last_range = last_range
                self._type = 'lastRange'

        elif type_of_union == 'firstPoint':
            if first_point is None:
                raise ValueError('a union value must not be None')
            self._first_point = first_point
            self._type = 'firstPoint'
        elif type_of_union == 'firstValuePoint':
            if first_value_point is None:
                raise ValueError('a union value must not be None')
            self._first_value_point = first_value_point
            self._type = 'firstValuePoint'
        elif type_of_union == 'firstRange':
            if first_range is None:
                raise ValueError('a union value must not be None')
            self._first_range = first_range
            self._type = 'firstRange'
        elif type_of_union == 'lastPoint':
            if last_point is None:
                raise ValueError('a union value must not be None')
            self._last_point = last_point
            self._type = 'lastPoint'
        elif type_of_union == 'lastValuePoint':
            if last_value_point is None:
                raise ValueError('a union value must not be None')
            self._last_value_point = last_value_point
            self._type = 'lastValuePoint'
        elif type_of_union == 'lastRange':
            if last_range is None:
                raise ValueError('a union value must not be None')
            self._last_range = last_range
            self._type = 'lastRange'

    @builtins.property
    def first_point(self) -> Optional["scout_compute_resolved_api_SeriesNode"]:
        return self._first_point

    @builtins.property
    def first_value_point(self) -> Optional["scout_compute_resolved_api_SeriesNode"]:
        return self._first_value_point

    @builtins.property
    def first_range(self) -> Optional["scout_compute_resolved_api_RangesNode"]:
        return self._first_range

    @builtins.property
    def last_point(self) -> Optional["scout_compute_resolved_api_SeriesNode"]:
        return self._last_point

    @builtins.property
    def last_value_point(self) -> Optional["scout_compute_resolved_api_SeriesNode"]:
        return self._last_value_point

    @builtins.property
    def last_range(self) -> Optional["scout_compute_resolved_api_RangesNode"]:
        return self._last_range

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_SelectValueNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_SelectValueNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'firstPoint' and self.first_point is not None:
            return visitor._first_point(self.first_point)
        if self._type == 'firstValuePoint' and self.first_value_point is not None:
            return visitor._first_value_point(self.first_value_point)
        if self._type == 'firstRange' and self.first_range is not None:
            return visitor._first_range(self.first_range)
        if self._type == 'lastPoint' and self.last_point is not None:
            return visitor._last_point(self.last_point)
        if self._type == 'lastValuePoint' and self.last_value_point is not None:
            return visitor._last_value_point(self.last_value_point)
        if self._type == 'lastRange' and self.last_range is not None:
            return visitor._last_range(self.last_range)


scout_compute_resolved_api_SelectValueNode.__name__ = "SelectValueNode"
scout_compute_resolved_api_SelectValueNode.__qualname__ = "SelectValueNode"
scout_compute_resolved_api_SelectValueNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SelectValueNodeVisitor:

    @abstractmethod
    def _first_point(self, first_point: "scout_compute_resolved_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_value_point(self, first_value_point: "scout_compute_resolved_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _first_range(self, first_range: "scout_compute_resolved_api_RangesNode") -> Any:
        pass

    @abstractmethod
    def _last_point(self, last_point: "scout_compute_resolved_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _last_value_point(self, last_value_point: "scout_compute_resolved_api_SeriesNode") -> Any:
        pass

    @abstractmethod
    def _last_range(self, last_range: "scout_compute_resolved_api_RangesNode") -> Any:
        pass


scout_compute_resolved_api_SelectValueNodeVisitor.__name__ = "SelectValueNodeVisitor"
scout_compute_resolved_api_SelectValueNodeVisitor.__qualname__ = "SelectValueNodeVisitor"
scout_compute_resolved_api_SelectValueNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesCrossoverRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input_a': ConjureFieldDefinition('inputA', scout_compute_resolved_api_NumericSeriesNode),
            'input_b': ConjureFieldDefinition('inputB', scout_compute_resolved_api_NumericSeriesNode)
        }

    __slots__: List[str] = ['_input_a', '_input_b']

    def __init__(self, input_a: "scout_compute_resolved_api_NumericSeriesNode", input_b: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._input_a = input_a
        self._input_b = input_b

    @builtins.property
    def input_a(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input_a

    @builtins.property
    def input_b(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input_b


scout_compute_resolved_api_SeriesCrossoverRangesNode.__name__ = "SeriesCrossoverRangesNode"
scout_compute_resolved_api_SeriesCrossoverRangesNode.__qualname__ = "SeriesCrossoverRangesNode"
scout_compute_resolved_api_SeriesCrossoverRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_RawUntypedSeriesNode"] = None
    _enum: Optional["scout_compute_resolved_api_EnumSeriesNode"] = None
    _numeric: Optional["scout_compute_resolved_api_NumericSeriesNode"] = None
    _log: Optional["scout_compute_resolved_api_LogSeriesNode"] = None
    _array: Optional["scout_compute_resolved_api_ArraySeriesNode"] = None
    _struct: Optional["scout_compute_resolved_api_StructSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_RawUntypedSeriesNode),
            'enum': ConjureFieldDefinition('enum', scout_compute_resolved_api_EnumSeriesNode),
            'numeric': ConjureFieldDefinition('numeric', scout_compute_resolved_api_NumericSeriesNode),
            'log': ConjureFieldDefinition('log', scout_compute_resolved_api_LogSeriesNode),
            'array': ConjureFieldDefinition('array', scout_compute_resolved_api_ArraySeriesNode),
            'struct': ConjureFieldDefinition('struct', scout_compute_resolved_api_StructSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_RawUntypedSeriesNode"] = None,
            enum: Optional["scout_compute_resolved_api_EnumSeriesNode"] = None,
            numeric: Optional["scout_compute_resolved_api_NumericSeriesNode"] = None,
            log: Optional["scout_compute_resolved_api_LogSeriesNode"] = None,
            array: Optional["scout_compute_resolved_api_ArraySeriesNode"] = None,
            struct: Optional["scout_compute_resolved_api_StructSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (enum is not None) + (numeric is not None) + (log is not None) + (array is not None) + (struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if enum is not None:
                self._enum = enum
                self._type = 'enum'
            if numeric is not None:
                self._numeric = numeric
                self._type = 'numeric'
            if log is not None:
                self._log = log
                self._type = 'log'
            if array is not None:
                self._array = array
                self._type = 'array'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'enum':
            if enum is None:
                raise ValueError('a union value must not be None')
            self._enum = enum
            self._type = 'enum'
        elif type_of_union == 'numeric':
            if numeric is None:
                raise ValueError('a union value must not be None')
            self._numeric = numeric
            self._type = 'numeric'
        elif type_of_union == 'log':
            if log is None:
                raise ValueError('a union value must not be None')
            self._log = log
            self._type = 'log'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_RawUntypedSeriesNode"]:
        return self._raw

    @builtins.property
    def enum(self) -> Optional["scout_compute_resolved_api_EnumSeriesNode"]:
        return self._enum

    @builtins.property
    def numeric(self) -> Optional["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._numeric

    @builtins.property
    def log(self) -> Optional["scout_compute_resolved_api_LogSeriesNode"]:
        return self._log

    @builtins.property
    def array(self) -> Optional["scout_compute_resolved_api_ArraySeriesNode"]:
        return self._array

    @builtins.property
    def struct(self) -> Optional["scout_compute_resolved_api_StructSeriesNode"]:
        return self._struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_SeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_SeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'enum' and self.enum is not None:
            return visitor._enum(self.enum)
        if self._type == 'numeric' and self.numeric is not None:
            return visitor._numeric(self.numeric)
        if self._type == 'log' and self.log is not None:
            return visitor._log(self.log)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)


scout_compute_resolved_api_SeriesNode.__name__ = "SeriesNode"
scout_compute_resolved_api_SeriesNode.__qualname__ = "SeriesNode"
scout_compute_resolved_api_SeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_RawUntypedSeriesNode") -> Any:
        pass

    @abstractmethod
    def _enum(self, enum: "scout_compute_resolved_api_EnumSeriesNode") -> Any:
        pass

    @abstractmethod
    def _numeric(self, numeric: "scout_compute_resolved_api_NumericSeriesNode") -> Any:
        pass

    @abstractmethod
    def _log(self, log: "scout_compute_resolved_api_LogSeriesNode") -> Any:
        pass

    @abstractmethod
    def _array(self, array: "scout_compute_resolved_api_ArraySeriesNode") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: "scout_compute_resolved_api_StructSeriesNode") -> Any:
        pass


scout_compute_resolved_api_SeriesNodeVisitor.__name__ = "SeriesNodeVisitor"
scout_compute_resolved_api_SeriesNodeVisitor.__qualname__ = "SeriesNodeVisitor"
scout_compute_resolved_api_SeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SignalFilterConfiguration(ConjureUnionType):
    _low_pass: Optional["scout_compute_resolved_api_LowPassConfiguration"] = None
    _high_pass: Optional["scout_compute_resolved_api_HighPassConfiguration"] = None
    _band_pass: Optional["scout_compute_resolved_api_BandPassConfiguration"] = None
    _band_stop: Optional["scout_compute_resolved_api_BandStopConfiguration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'low_pass': ConjureFieldDefinition('lowPass', scout_compute_resolved_api_LowPassConfiguration),
            'high_pass': ConjureFieldDefinition('highPass', scout_compute_resolved_api_HighPassConfiguration),
            'band_pass': ConjureFieldDefinition('bandPass', scout_compute_resolved_api_BandPassConfiguration),
            'band_stop': ConjureFieldDefinition('bandStop', scout_compute_resolved_api_BandStopConfiguration)
        }

    def __init__(
            self,
            low_pass: Optional["scout_compute_resolved_api_LowPassConfiguration"] = None,
            high_pass: Optional["scout_compute_resolved_api_HighPassConfiguration"] = None,
            band_pass: Optional["scout_compute_resolved_api_BandPassConfiguration"] = None,
            band_stop: Optional["scout_compute_resolved_api_BandStopConfiguration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (low_pass is not None) + (high_pass is not None) + (band_pass is not None) + (band_stop is not None) != 1:
                raise ValueError('a union must contain a single member')

            if low_pass is not None:
                self._low_pass = low_pass
                self._type = 'lowPass'
            if high_pass is not None:
                self._high_pass = high_pass
                self._type = 'highPass'
            if band_pass is not None:
                self._band_pass = band_pass
                self._type = 'bandPass'
            if band_stop is not None:
                self._band_stop = band_stop
                self._type = 'bandStop'

        elif type_of_union == 'lowPass':
            if low_pass is None:
                raise ValueError('a union value must not be None')
            self._low_pass = low_pass
            self._type = 'lowPass'
        elif type_of_union == 'highPass':
            if high_pass is None:
                raise ValueError('a union value must not be None')
            self._high_pass = high_pass
            self._type = 'highPass'
        elif type_of_union == 'bandPass':
            if band_pass is None:
                raise ValueError('a union value must not be None')
            self._band_pass = band_pass
            self._type = 'bandPass'
        elif type_of_union == 'bandStop':
            if band_stop is None:
                raise ValueError('a union value must not be None')
            self._band_stop = band_stop
            self._type = 'bandStop'

    @builtins.property
    def low_pass(self) -> Optional["scout_compute_resolved_api_LowPassConfiguration"]:
        return self._low_pass

    @builtins.property
    def high_pass(self) -> Optional["scout_compute_resolved_api_HighPassConfiguration"]:
        return self._high_pass

    @builtins.property
    def band_pass(self) -> Optional["scout_compute_resolved_api_BandPassConfiguration"]:
        return self._band_pass

    @builtins.property
    def band_stop(self) -> Optional["scout_compute_resolved_api_BandStopConfiguration"]:
        return self._band_stop

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_SignalFilterConfigurationVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_SignalFilterConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'lowPass' and self.low_pass is not None:
            return visitor._low_pass(self.low_pass)
        if self._type == 'highPass' and self.high_pass is not None:
            return visitor._high_pass(self.high_pass)
        if self._type == 'bandPass' and self.band_pass is not None:
            return visitor._band_pass(self.band_pass)
        if self._type == 'bandStop' and self.band_stop is not None:
            return visitor._band_stop(self.band_stop)


scout_compute_resolved_api_SignalFilterConfiguration.__name__ = "SignalFilterConfiguration"
scout_compute_resolved_api_SignalFilterConfiguration.__qualname__ = "SignalFilterConfiguration"
scout_compute_resolved_api_SignalFilterConfiguration.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SignalFilterConfigurationVisitor:

    @abstractmethod
    def _low_pass(self, low_pass: "scout_compute_resolved_api_LowPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _high_pass(self, high_pass: "scout_compute_resolved_api_HighPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _band_pass(self, band_pass: "scout_compute_resolved_api_BandPassConfiguration") -> Any:
        pass

    @abstractmethod
    def _band_stop(self, band_stop: "scout_compute_resolved_api_BandStopConfiguration") -> Any:
        pass


scout_compute_resolved_api_SignalFilterConfigurationVisitor.__name__ = "SignalFilterConfigurationVisitor"
scout_compute_resolved_api_SignalFilterConfigurationVisitor.__qualname__ = "SignalFilterConfigurationVisitor"
scout_compute_resolved_api_SignalFilterConfigurationVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SignalFilterSeriesNode(ConjureBeanType):
    """Applies IIR-based signal filtering to input series. Includes low-pass, high-pass, band-pass, and band-stop
filters. Currently supports variable-order bidirectional Butterworth filters, with fixed-size padding based
on SciPy output.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'signal_filter_configuration': ConjureFieldDefinition('signalFilterConfiguration', scout_compute_resolved_api_SignalFilterConfiguration),
            'order': ConjureFieldDefinition('order', int),
            'sampling_frequency': ConjureFieldDefinition('samplingFrequency', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_input', '_signal_filter_configuration', '_order', '_sampling_frequency']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", order: int, signal_filter_configuration: "scout_compute_resolved_api_SignalFilterConfiguration", sampling_frequency: Optional[float] = None) -> None:
        self._input = input
        self._signal_filter_configuration = signal_filter_configuration
        self._order = order
        self._sampling_frequency = sampling_frequency

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def signal_filter_configuration(self) -> "scout_compute_resolved_api_SignalFilterConfiguration":
        """Configuration for the signal filter, including filter type, cutoff frequency, and order.
        """
        return self._signal_filter_configuration

    @builtins.property
    def order(self) -> int:
        """Order of filter. Must be a positive integer, and is effectively doubled for bidirectional filters.
        """
        return self._order

    @builtins.property
    def sampling_frequency(self) -> Optional[float]:
        """The sampling frequency of the input series. Used to calculate normalized frequency for cutoff frequencies.
Defaults to number of points divided by timespan of series.
        """
        return self._sampling_frequency


scout_compute_resolved_api_SignalFilterSeriesNode.__name__ = "SignalFilterSeriesNode"
scout_compute_resolved_api_SignalFilterSeriesNode.__qualname__ = "SignalFilterSeriesNode"
scout_compute_resolved_api_SignalFilterSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StabilityDetectionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_compute_resolved_api_Threshold),
            'window_configuration': ConjureFieldDefinition('windowConfiguration', scout_compute_resolved_api_PersistenceWindowConfiguration)
        }

    __slots__: List[str] = ['_input', '_threshold', '_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", threshold: "scout_compute_resolved_api_Threshold", window_configuration: "scout_compute_resolved_api_PersistenceWindowConfiguration") -> None:
        self._input = input
        self._threshold = threshold
        self._window_configuration = window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_compute_resolved_api_Threshold":
        return self._threshold

    @builtins.property
    def window_configuration(self) -> "scout_compute_resolved_api_PersistenceWindowConfiguration":
        return self._window_configuration


scout_compute_resolved_api_StabilityDetectionRangesNode.__name__ = "StabilityDetectionRangesNode"
scout_compute_resolved_api_StabilityDetectionRangesNode.__qualname__ = "StabilityDetectionRangesNode"
scout_compute_resolved_api_StabilityDetectionRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StaleRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'threshold': ConjureFieldDefinition('threshold', scout_run_api_Duration),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_input', '_threshold', '_start_timestamp']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", threshold: "scout_run_api_Duration", start_timestamp: Optional["api_Timestamp"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._start_timestamp = start_timestamp

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> "scout_run_api_Duration":
        return self._threshold

    @builtins.property
    def start_timestamp(self) -> Optional["api_Timestamp"]:
        return self._start_timestamp


scout_compute_resolved_api_StaleRangesNode.__name__ = "StaleRangesNode"
scout_compute_resolved_api_StaleRangesNode.__qualname__ = "StaleRangesNode"
scout_compute_resolved_api_StaleRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StorageLocator(ConjureUnionType):
    _nominal: Optional["scout_compute_resolved_api_NominalStorageLocator"] = None
    _external: Optional["timeseries_logicalseries_api_ExternalStorageLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nominal': ConjureFieldDefinition('nominal', scout_compute_resolved_api_NominalStorageLocator),
            'external': ConjureFieldDefinition('external', timeseries_logicalseries_api_ExternalStorageLocator)
        }

    def __init__(
            self,
            nominal: Optional["scout_compute_resolved_api_NominalStorageLocator"] = None,
            external: Optional["timeseries_logicalseries_api_ExternalStorageLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (nominal is not None) + (external is not None) != 1:
                raise ValueError('a union must contain a single member')

            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if external is not None:
                self._external = external
                self._type = 'external'

        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'external':
            if external is None:
                raise ValueError('a union value must not be None')
            self._external = external
            self._type = 'external'

    @builtins.property
    def nominal(self) -> Optional["scout_compute_resolved_api_NominalStorageLocator"]:
        return self._nominal

    @builtins.property
    def external(self) -> Optional["timeseries_logicalseries_api_ExternalStorageLocator"]:
        return self._external

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_StorageLocatorVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_StorageLocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'external' and self.external is not None:
            return visitor._external(self.external)


scout_compute_resolved_api_StorageLocator.__name__ = "StorageLocator"
scout_compute_resolved_api_StorageLocator.__qualname__ = "StorageLocator"
scout_compute_resolved_api_StorageLocator.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StorageLocatorVisitor:

    @abstractmethod
    def _nominal(self, nominal: "scout_compute_resolved_api_NominalStorageLocator") -> Any:
        pass

    @abstractmethod
    def _external(self, external: "timeseries_logicalseries_api_ExternalStorageLocator") -> Any:
        pass


scout_compute_resolved_api_StorageLocatorVisitor.__name__ = "StorageLocatorVisitor"
scout_compute_resolved_api_StorageLocatorVisitor.__qualname__ = "StorageLocatorVisitor"
scout_compute_resolved_api_StorageLocatorVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StructSeriesNode(ConjureUnionType):
    _raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None
    _extract_from_struct: Optional["scout_compute_resolved_api_ExtractStructFromStructSeriesNode"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'raw': ConjureFieldDefinition('raw', scout_compute_resolved_api_ResolvedSeries),
            'extract_from_struct': ConjureFieldDefinition('extractFromStruct', scout_compute_resolved_api_ExtractStructFromStructSeriesNode)
        }

    def __init__(
            self,
            raw: Optional["scout_compute_resolved_api_ResolvedSeries"] = None,
            extract_from_struct: Optional["scout_compute_resolved_api_ExtractStructFromStructSeriesNode"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (raw is not None) + (extract_from_struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if raw is not None:
                self._raw = raw
                self._type = 'raw'
            if extract_from_struct is not None:
                self._extract_from_struct = extract_from_struct
                self._type = 'extractFromStruct'

        elif type_of_union == 'raw':
            if raw is None:
                raise ValueError('a union value must not be None')
            self._raw = raw
            self._type = 'raw'
        elif type_of_union == 'extractFromStruct':
            if extract_from_struct is None:
                raise ValueError('a union value must not be None')
            self._extract_from_struct = extract_from_struct
            self._type = 'extractFromStruct'

    @builtins.property
    def raw(self) -> Optional["scout_compute_resolved_api_ResolvedSeries"]:
        return self._raw

    @builtins.property
    def extract_from_struct(self) -> Optional["scout_compute_resolved_api_ExtractStructFromStructSeriesNode"]:
        return self._extract_from_struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_StructSeriesNodeVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_StructSeriesNodeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'raw' and self.raw is not None:
            return visitor._raw(self.raw)
        if self._type == 'extractFromStruct' and self.extract_from_struct is not None:
            return visitor._extract_from_struct(self.extract_from_struct)


scout_compute_resolved_api_StructSeriesNode.__name__ = "StructSeriesNode"
scout_compute_resolved_api_StructSeriesNode.__qualname__ = "StructSeriesNode"
scout_compute_resolved_api_StructSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_StructSeriesNodeVisitor:

    @abstractmethod
    def _raw(self, raw: "scout_compute_resolved_api_ResolvedSeries") -> Any:
        pass

    @abstractmethod
    def _extract_from_struct(self, extract_from_struct: "scout_compute_resolved_api_ExtractStructFromStructSeriesNode") -> Any:
        pass


scout_compute_resolved_api_StructSeriesNodeVisitor.__name__ = "StructSeriesNodeVisitor"
scout_compute_resolved_api_StructSeriesNodeVisitor.__qualname__ = "StructSeriesNodeVisitor"
scout_compute_resolved_api_StructSeriesNodeVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SumSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_NumericSeriesNode]),
            'interpolation_configuration': ConjureFieldDefinition('interpolationConfiguration', scout_compute_resolved_api_InterpolationConfiguration)
        }

    __slots__: List[str] = ['_inputs', '_interpolation_configuration']

    def __init__(self, inputs: List["scout_compute_resolved_api_NumericSeriesNode"], interpolation_configuration: "scout_compute_resolved_api_InterpolationConfiguration") -> None:
        self._inputs = inputs
        self._interpolation_configuration = interpolation_configuration

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_NumericSeriesNode"]:
        return self._inputs

    @builtins.property
    def interpolation_configuration(self) -> "scout_compute_resolved_api_InterpolationConfiguration":
        return self._interpolation_configuration


scout_compute_resolved_api_SumSeriesNode.__name__ = "SumSeriesNode"
scout_compute_resolved_api_SumSeriesNode.__qualname__ = "SumSeriesNode"
scout_compute_resolved_api_SumSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeCartesian3dNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_Cartesian3dNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_resolved_api_Cartesian3dBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int]),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', scout_compute_api_ScatterSummarizationStrategy)
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points', '_summarization_strategy']

    def __init__(self, input: "scout_compute_resolved_api_Cartesian3dNode", summarization_strategy: "scout_compute_api_ScatterSummarizationStrategy", bounds: Optional["scout_compute_resolved_api_Cartesian3dBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points
        self._summarization_strategy = summarization_strategy

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_Cartesian3dNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_resolved_api_Cartesian3dBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        return self._max_points

    @builtins.property
    def summarization_strategy(self) -> "scout_compute_api_ScatterSummarizationStrategy":
        return self._summarization_strategy


scout_compute_resolved_api_SummarizeCartesian3dNode.__name__ = "SummarizeCartesian3dNode"
scout_compute_resolved_api_SummarizeCartesian3dNode.__qualname__ = "SummarizeCartesian3dNode"
scout_compute_resolved_api_SummarizeCartesian3dNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeCartesianNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_CartesianNode),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_compute_resolved_api_CartesianBounds]),
            'max_points': ConjureFieldDefinition('maxPoints', OptionalTypeWrapper[int]),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', scout_compute_api_ScatterSummarizationStrategy)
        }

    __slots__: List[str] = ['_input', '_bounds', '_max_points', '_summarization_strategy']

    def __init__(self, input: "scout_compute_resolved_api_CartesianNode", summarization_strategy: "scout_compute_api_ScatterSummarizationStrategy", bounds: Optional["scout_compute_resolved_api_CartesianBounds"] = None, max_points: Optional[int] = None) -> None:
        self._input = input
        self._bounds = bounds
        self._max_points = max_points
        self._summarization_strategy = summarization_strategy

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_CartesianNode":
        return self._input

    @builtins.property
    def bounds(self) -> Optional["scout_compute_resolved_api_CartesianBounds"]:
        return self._bounds

    @builtins.property
    def max_points(self) -> Optional[int]:
        return self._max_points

    @builtins.property
    def summarization_strategy(self) -> "scout_compute_api_ScatterSummarizationStrategy":
        return self._summarization_strategy


scout_compute_resolved_api_SummarizeCartesianNode.__name__ = "SummarizeCartesianNode"
scout_compute_resolved_api_SummarizeCartesianNode.__qualname__ = "SummarizeCartesianNode"
scout_compute_resolved_api_SummarizeCartesianNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_RangesNode),
            'max_ranges': ConjureFieldDefinition('maxRanges', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_input', '_max_ranges']

    def __init__(self, input: "scout_compute_resolved_api_RangesNode", max_ranges: Optional[int] = None) -> None:
        self._input = input
        self._max_ranges = max_ranges

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_RangesNode":
        return self._input

    @builtins.property
    def max_ranges(self) -> Optional[int]:
        return self._max_ranges


scout_compute_resolved_api_SummarizeRangesNode.__name__ = "SummarizeRangesNode"
scout_compute_resolved_api_SummarizeRangesNode.__qualname__ = "SummarizeRangesNode"
scout_compute_resolved_api_SummarizeRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_SummarizeSeriesNode(ConjureBeanType):
    """Summarizes the output of a series node. The output can be a numeric, enum, log, or cartesian series.
Summarization strategy should be specified.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'summarization_strategy': ConjureFieldDefinition('summarizationStrategy', scout_compute_api_SummarizationStrategy),
            'output_format': ConjureFieldDefinition('outputFormat', scout_compute_api_OutputFormat),
            'numeric_output_fields': ConjureFieldDefinition('numericOutputFields', OptionalTypeWrapper[List[scout_compute_api_NumericOutputField]])
        }

    __slots__: List[str] = ['_input', '_summarization_strategy', '_output_format', '_numeric_output_fields']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", output_format: "scout_compute_api_OutputFormat", summarization_strategy: "scout_compute_api_SummarizationStrategy", numeric_output_fields: Optional[List["scout_compute_api_NumericOutputField"]] = None) -> None:
        self._input = input
        self._summarization_strategy = summarization_strategy
        self._output_format = output_format
        self._numeric_output_fields = numeric_output_fields

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def summarization_strategy(self) -> "scout_compute_api_SummarizationStrategy":
        """The strategy to use when summarizing the series.
        """
        return self._summarization_strategy

    @builtins.property
    def output_format(self) -> "scout_compute_api_OutputFormat":
        return self._output_format

    @builtins.property
    def numeric_output_fields(self) -> Optional[List["scout_compute_api_NumericOutputField"]]:
        return self._numeric_output_fields


scout_compute_resolved_api_SummarizeSeriesNode.__name__ = "SummarizeSeriesNode"
scout_compute_resolved_api_SummarizeSeriesNode.__qualname__ = "SummarizeSeriesNode"
scout_compute_resolved_api_SummarizeSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TagFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'key': ConjureFieldDefinition('key', api_TagName),
            'values': ConjureFieldDefinition('values', List[api_TagValue]),
            'operator': ConjureFieldDefinition('operator', scout_compute_resolved_api_TagFilterOperator)
        }

    __slots__: List[str] = ['_key', '_values', '_operator']

    def __init__(self, key: str, operator: "scout_compute_resolved_api_TagFilterOperator", values: List[str]) -> None:
        self._key = key
        self._values = values
        self._operator = operator

    @builtins.property
    def key(self) -> str:
        return self._key

    @builtins.property
    def values(self) -> List[str]:
        return self._values

    @builtins.property
    def operator(self) -> "scout_compute_resolved_api_TagFilterOperator":
        return self._operator


scout_compute_resolved_api_TagFilter.__name__ = "TagFilter"
scout_compute_resolved_api_TagFilter.__qualname__ = "TagFilter"
scout_compute_resolved_api_TagFilter.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TagFilterOperator(ConjureEnumType):

    IN = 'IN'
    '''IN'''
    NOT_IN = 'NOT_IN'
    '''NOT_IN'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_compute_resolved_api_TagFilterOperator.__name__ = "TagFilterOperator"
scout_compute_resolved_api_TagFilterOperator.__qualname__ = "TagFilterOperator"
scout_compute_resolved_api_TagFilterOperator.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TagFilters(ConjureUnionType):
    _single: Optional["scout_compute_resolved_api_TagFilter"] = None
    _and_: Optional[List["scout_compute_resolved_api_TagFilters"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'single': ConjureFieldDefinition('single', scout_compute_resolved_api_TagFilter),
            'and_': ConjureFieldDefinition('and', List[scout_compute_resolved_api_TagFilters])
        }

    def __init__(
            self,
            single: Optional["scout_compute_resolved_api_TagFilter"] = None,
            and_: Optional[List["scout_compute_resolved_api_TagFilters"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (single is not None) + (and_ is not None) != 1:
                raise ValueError('a union must contain a single member')

            if single is not None:
                self._single = single
                self._type = 'single'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'

        elif type_of_union == 'single':
            if single is None:
                raise ValueError('a union value must not be None')
            self._single = single
            self._type = 'single'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'

    @builtins.property
    def single(self) -> Optional["scout_compute_resolved_api_TagFilter"]:
        return self._single

    @builtins.property
    def and_(self) -> Optional[List["scout_compute_resolved_api_TagFilters"]]:
        return self._and_

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_TagFiltersVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_TagFiltersVisitor'.format(visitor.__class__.__name__))
        if self._type == 'single' and self.single is not None:
            return visitor._single(self.single)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)


scout_compute_resolved_api_TagFilters.__name__ = "TagFilters"
scout_compute_resolved_api_TagFilters.__qualname__ = "TagFilters"
scout_compute_resolved_api_TagFilters.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TagFiltersVisitor:

    @abstractmethod
    def _single(self, single: "scout_compute_resolved_api_TagFilter") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_compute_resolved_api_TagFilters"]) -> Any:
        pass


scout_compute_resolved_api_TagFiltersVisitor.__name__ = "TagFiltersVisitor"
scout_compute_resolved_api_TagFiltersVisitor.__qualname__ = "TagFiltersVisitor"
scout_compute_resolved_api_TagFiltersVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Threshold(ConjureUnionType):
    _absolute: Optional["scout_compute_resolved_api_AbsoluteThreshold"] = None
    _percentage: Optional["scout_compute_resolved_api_PercentageThreshold"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'absolute': ConjureFieldDefinition('absolute', scout_compute_resolved_api_AbsoluteThreshold),
            'percentage': ConjureFieldDefinition('percentage', scout_compute_resolved_api_PercentageThreshold)
        }

    def __init__(
            self,
            absolute: Optional["scout_compute_resolved_api_AbsoluteThreshold"] = None,
            percentage: Optional["scout_compute_resolved_api_PercentageThreshold"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (absolute is not None) + (percentage is not None) != 1:
                raise ValueError('a union must contain a single member')

            if absolute is not None:
                self._absolute = absolute
                self._type = 'absolute'
            if percentage is not None:
                self._percentage = percentage
                self._type = 'percentage'

        elif type_of_union == 'absolute':
            if absolute is None:
                raise ValueError('a union value must not be None')
            self._absolute = absolute
            self._type = 'absolute'
        elif type_of_union == 'percentage':
            if percentage is None:
                raise ValueError('a union value must not be None')
            self._percentage = percentage
            self._type = 'percentage'

    @builtins.property
    def absolute(self) -> Optional["scout_compute_resolved_api_AbsoluteThreshold"]:
        return self._absolute

    @builtins.property
    def percentage(self) -> Optional["scout_compute_resolved_api_PercentageThreshold"]:
        return self._percentage

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_compute_resolved_api_ThresholdVisitor):
            raise ValueError('{} is not an instance of scout_compute_resolved_api_ThresholdVisitor'.format(visitor.__class__.__name__))
        if self._type == 'absolute' and self.absolute is not None:
            return visitor._absolute(self.absolute)
        if self._type == 'percentage' and self.percentage is not None:
            return visitor._percentage(self.percentage)


scout_compute_resolved_api_Threshold.__name__ = "Threshold"
scout_compute_resolved_api_Threshold.__qualname__ = "Threshold"
scout_compute_resolved_api_Threshold.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ThresholdVisitor:

    @abstractmethod
    def _absolute(self, absolute: "scout_compute_resolved_api_AbsoluteThreshold") -> Any:
        pass

    @abstractmethod
    def _percentage(self, percentage: "scout_compute_resolved_api_PercentageThreshold") -> Any:
        pass


scout_compute_resolved_api_ThresholdVisitor.__name__ = "ThresholdVisitor"
scout_compute_resolved_api_ThresholdVisitor.__qualname__ = "ThresholdVisitor"
scout_compute_resolved_api_ThresholdVisitor.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ThresholdingRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'threshold': ConjureFieldDefinition('threshold', float),
            'operator': ConjureFieldDefinition('operator', scout_compute_api_ThresholdOperator),
            'persistence_window_configuration': ConjureFieldDefinition('persistenceWindowConfiguration', OptionalTypeWrapper[scout_compute_resolved_api_PersistenceWindowConfiguration])
        }

    __slots__: List[str] = ['_input', '_threshold', '_operator', '_persistence_window_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operator: "scout_compute_api_ThresholdOperator", threshold: float, persistence_window_configuration: Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"] = None) -> None:
        self._input = input
        self._threshold = threshold
        self._operator = operator
        self._persistence_window_configuration = persistence_window_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def threshold(self) -> float:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_compute_api_ThresholdOperator":
        return self._operator

    @builtins.property
    def persistence_window_configuration(self) -> Optional["scout_compute_resolved_api_PersistenceWindowConfiguration"]:
        return self._persistence_window_configuration


scout_compute_resolved_api_ThresholdingRangesNode.__name__ = "ThresholdingRangesNode"
scout_compute_resolved_api_ThresholdingRangesNode.__qualname__ = "ThresholdingRangesNode"
scout_compute_resolved_api_ThresholdingRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TimeDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_SeriesNode),
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_input', '_time_unit']

    def __init__(self, input: "scout_compute_resolved_api_SeriesNode", time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._input = input
        self._time_unit = time_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_SeriesNode":
        return self._input

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit


scout_compute_resolved_api_TimeDifferenceSeriesNode.__name__ = "TimeDifferenceSeriesNode"
scout_compute_resolved_api_TimeDifferenceSeriesNode.__qualname__ = "TimeDifferenceSeriesNode"
scout_compute_resolved_api_TimeDifferenceSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TimeSeriesCurveFitNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', scout_compute_resolved_api_NumericSeriesNode),
            'options': ConjureFieldDefinition('options', scout_compute_resolved_api_TimeSeriesFitOptions)
        }

    __slots__: List[str] = ['_series', '_options']

    def __init__(self, options: "scout_compute_resolved_api_TimeSeriesFitOptions", series: "scout_compute_resolved_api_NumericSeriesNode") -> None:
        self._series = series
        self._options = options

    @builtins.property
    def series(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._series

    @builtins.property
    def options(self) -> "scout_compute_resolved_api_TimeSeriesFitOptions":
        return self._options


scout_compute_resolved_api_TimeSeriesCurveFitNode.__name__ = "TimeSeriesCurveFitNode"
scout_compute_resolved_api_TimeSeriesCurveFitNode.__qualname__ = "TimeSeriesCurveFitNode"
scout_compute_resolved_api_TimeSeriesCurveFitNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_TimeSeriesFitOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_unit': ConjureFieldDefinition('timeUnit', OptionalTypeWrapper[api_TimeUnit])
        }

    __slots__: List[str] = ['_time_unit']

    def __init__(self, time_unit: Optional["api_TimeUnit"] = None) -> None:
        self._time_unit = time_unit

    @builtins.property
    def time_unit(self) -> Optional["api_TimeUnit"]:
        return self._time_unit


scout_compute_resolved_api_TimeSeriesFitOptions.__name__ = "TimeSeriesFitOptions"
scout_compute_resolved_api_TimeSeriesFitOptions.__qualname__ = "TimeSeriesFitOptions"
scout_compute_resolved_api_TimeSeriesFitOptions.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnaryArithmeticSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'operation': ConjureFieldDefinition('operation', scout_compute_api_UnaryArithmeticOperation)
        }

    __slots__: List[str] = ['_input', '_operation']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", operation: "scout_compute_api_UnaryArithmeticOperation") -> None:
        self._input = input
        self._operation = operation

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def operation(self) -> "scout_compute_api_UnaryArithmeticOperation":
        return self._operation


scout_compute_resolved_api_UnaryArithmeticSeriesNode.__name__ = "UnaryArithmeticSeriesNode"
scout_compute_resolved_api_UnaryArithmeticSeriesNode.__qualname__ = "UnaryArithmeticSeriesNode"
scout_compute_resolved_api_UnaryArithmeticSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnionRangesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_compute_resolved_api_RangesNode])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_compute_resolved_api_RangesNode"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_compute_resolved_api_RangesNode"]:
        return self._inputs


scout_compute_resolved_api_UnionRangesNode.__name__ = "UnionRangesNode"
scout_compute_resolved_api_UnionRangesNode.__qualname__ = "UnionRangesNode"
scout_compute_resolved_api_UnionRangesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_UnitConversionSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'input_unit': ConjureFieldDefinition('inputUnit', scout_units_api_UnitSymbol),
            'output_unit': ConjureFieldDefinition('outputUnit', scout_units_api_UnitSymbol)
        }

    __slots__: List[str] = ['_input', '_input_unit', '_output_unit']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", input_unit: str, output_unit: str) -> None:
        self._input = input
        self._input_unit = input_unit
        self._output_unit = output_unit

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def input_unit(self) -> str:
        return self._input_unit

    @builtins.property
    def output_unit(self) -> str:
        return self._output_unit


scout_compute_resolved_api_UnitConversionSeriesNode.__name__ = "UnitConversionSeriesNode"
scout_compute_resolved_api_UnitConversionSeriesNode.__qualname__ = "UnitConversionSeriesNode"
scout_compute_resolved_api_UnitConversionSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ValueDifferenceSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'negative_values_configuration': ConjureFieldDefinition('negativeValuesConfiguration', OptionalTypeWrapper[scout_compute_api_NegativeValueConfiguration])
        }

    __slots__: List[str] = ['_input', '_negative_values_configuration']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", negative_values_configuration: Optional["scout_compute_api_NegativeValueConfiguration"] = None) -> None:
        self._input = input
        self._negative_values_configuration = negative_values_configuration

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def negative_values_configuration(self) -> Optional["scout_compute_api_NegativeValueConfiguration"]:
        return self._negative_values_configuration


scout_compute_resolved_api_ValueDifferenceSeriesNode.__name__ = "ValueDifferenceSeriesNode"
scout_compute_resolved_api_ValueDifferenceSeriesNode.__qualname__ = "ValueDifferenceSeriesNode"
scout_compute_resolved_api_ValueDifferenceSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_ValueMapSeriesNode(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'input': ConjureFieldDefinition('input', scout_compute_resolved_api_NumericSeriesNode),
            'mapping': ConjureFieldDefinition('mapping', List[scout_compute_resolved_api_RangeMap]),
            'default': ConjureFieldDefinition('default', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_input', '_mapping', '_default']

    def __init__(self, input: "scout_compute_resolved_api_NumericSeriesNode", mapping: List["scout_compute_resolved_api_RangeMap"], default: Optional[str] = None) -> None:
        self._input = input
        self._mapping = mapping
        self._default = default

    @builtins.property
    def input(self) -> "scout_compute_resolved_api_NumericSeriesNode":
        return self._input

    @builtins.property
    def mapping(self) -> List["scout_compute_resolved_api_RangeMap"]:
        return self._mapping

    @builtins.property
    def default(self) -> Optional[str]:
        return self._default


scout_compute_resolved_api_ValueMapSeriesNode.__name__ = "ValueMapSeriesNode"
scout_compute_resolved_api_ValueMapSeriesNode.__qualname__ = "ValueMapSeriesNode"
scout_compute_resolved_api_ValueMapSeriesNode.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_compute_resolved_api_Window(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_duration']

    def __init__(self, duration: "scout_run_api_Duration") -> None:
        self._duration = duration

    @builtins.property
    def duration(self) -> "scout_run_api_Duration":
        return self._duration


scout_compute_resolved_api_Window.__name__ = "Window"
scout_compute_resolved_api_Window.__qualname__ = "Window"
scout_compute_resolved_api_Window.__module__ = "nominal_api.scout_compute_resolved_api"


class scout_dataexport_api_AllTimestampsForwardFillStrategy(ConjureBeanType):
    """All timestamps will be kept.
The value of a channel at a timestamp will be its latest
value, within the provided look back period.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'look_back_period': ConjureFieldDefinition('lookBackPeriod', scout_run_api_Duration)
        }

    __slots__: List[str] = ['_look_back_period']

    def __init__(self, look_back_period: "scout_run_api_Duration") -> None:
        self._look_back_period = look_back_period

    @builtins.property
    def look_back_period(self) -> "scout_run_api_Duration":
        return self._look_back_period


scout_dataexport_api_AllTimestampsForwardFillStrategy.__name__ = "AllTimestampsForwardFillStrategy"
scout_dataexport_api_AllTimestampsForwardFillStrategy.__qualname__ = "AllTimestampsForwardFillStrategy"
scout_dataexport_api_AllTimestampsForwardFillStrategy.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_Arrow(ConjureBeanType):
    """Export settings for a stream of arrow-compatible data.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Arrow.__name__ = "Arrow"
scout_dataexport_api_Arrow.__qualname__ = "Arrow"
scout_dataexport_api_Arrow.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_CompressionFormat(ConjureEnumType):

    GZIP = 'GZIP'
    '''GZIP'''
    ZIP = 'ZIP'
    '''ZIP'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_dataexport_api_CompressionFormat.__name__ = "CompressionFormat"
scout_dataexport_api_CompressionFormat.__qualname__ = "CompressionFormat"
scout_dataexport_api_CompressionFormat.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_Csv(ConjureBeanType):
    """Export settings for a stream of `.csv` data.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Csv.__name__ = "Csv"
scout_dataexport_api_Csv.__qualname__ = "Csv"
scout_dataexport_api_Csv.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_DataExportService(Service):
    """Provides functionality for exporting data from Scout.
    """

    def export_channel_data(self, auth_header: str, request: "scout_dataexport_api_ExportDataRequest") -> Any:
        """Required permissions matches those required to compute the channels via the compute API.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/export/v1/export'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def generate_export_channel_data_presigned_link(self, auth_header: str, request: "scout_dataexport_api_ExportDataRequest") -> "scout_dataexport_api_GeneratePresignedLinkResponse":
        """Required permissions matches those required to compute the channels via the compute API.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/export/v1/generateExportPresignedLink'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_dataexport_api_GeneratePresignedLinkResponse, self._return_none_for_unknown_union_types)


scout_dataexport_api_DataExportService.__name__ = "DataExportService"
scout_dataexport_api_DataExportService.__qualname__ = "DataExportService"
scout_dataexport_api_DataExportService.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportChannels(ConjureUnionType):
    _time_domain: Optional["scout_dataexport_api_ExportTimeDomainChannels"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_domain': ConjureFieldDefinition('timeDomain', scout_dataexport_api_ExportTimeDomainChannels)
        }

    def __init__(
            self,
            time_domain: Optional["scout_dataexport_api_ExportTimeDomainChannels"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (time_domain is not None) != 1:
                raise ValueError('a union must contain a single member')

            if time_domain is not None:
                self._time_domain = time_domain
                self._type = 'timeDomain'

        elif type_of_union == 'timeDomain':
            if time_domain is None:
                raise ValueError('a union value must not be None')
            self._time_domain = time_domain
            self._type = 'timeDomain'

    @builtins.property
    def time_domain(self) -> Optional["scout_dataexport_api_ExportTimeDomainChannels"]:
        return self._time_domain

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ExportChannelsVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ExportChannelsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timeDomain' and self.time_domain is not None:
            return visitor._time_domain(self.time_domain)


scout_dataexport_api_ExportChannels.__name__ = "ExportChannels"
scout_dataexport_api_ExportChannels.__qualname__ = "ExportChannels"
scout_dataexport_api_ExportChannels.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportChannelsVisitor:

    @abstractmethod
    def _time_domain(self, time_domain: "scout_dataexport_api_ExportTimeDomainChannels") -> Any:
        pass


scout_dataexport_api_ExportChannelsVisitor.__name__ = "ExportChannelsVisitor"
scout_dataexport_api_ExportChannelsVisitor.__qualname__ = "ExportChannelsVisitor"
scout_dataexport_api_ExportChannelsVisitor.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportDataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'format': ConjureFieldDefinition('format', scout_dataexport_api_ExportFormat),
            'compression': ConjureFieldDefinition('compression', OptionalTypeWrapper[scout_dataexport_api_CompressionFormat]),
            'start_time': ConjureFieldDefinition('startTime', api_Timestamp),
            'end_time': ConjureFieldDefinition('endTime', api_Timestamp),
            'resolution': ConjureFieldDefinition('resolution', scout_dataexport_api_ResolutionOption),
            'channels': ConjureFieldDefinition('channels', scout_dataexport_api_ExportChannels),
            'context': ConjureFieldDefinition('context', scout_compute_api_Context)
        }

    __slots__: List[str] = ['_format', '_compression', '_start_time', '_end_time', '_resolution', '_channels', '_context']

    def __init__(self, channels: "scout_dataexport_api_ExportChannels", context: "scout_compute_api_Context", end_time: "api_Timestamp", format: "scout_dataexport_api_ExportFormat", resolution: "scout_dataexport_api_ResolutionOption", start_time: "api_Timestamp", compression: Optional["scout_dataexport_api_CompressionFormat"] = None) -> None:
        self._format = format
        self._compression = compression
        self._start_time = start_time
        self._end_time = end_time
        self._resolution = resolution
        self._channels = channels
        self._context = context

    @builtins.property
    def format(self) -> "scout_dataexport_api_ExportFormat":
        return self._format

    @builtins.property
    def compression(self) -> Optional["scout_dataexport_api_CompressionFormat"]:
        return self._compression

    @builtins.property
    def start_time(self) -> "api_Timestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> "api_Timestamp":
        return self._end_time

    @builtins.property
    def resolution(self) -> "scout_dataexport_api_ResolutionOption":
        return self._resolution

    @builtins.property
    def channels(self) -> "scout_dataexport_api_ExportChannels":
        return self._channels

    @builtins.property
    def context(self) -> "scout_compute_api_Context":
        return self._context


scout_dataexport_api_ExportDataRequest.__name__ = "ExportDataRequest"
scout_dataexport_api_ExportDataRequest.__qualname__ = "ExportDataRequest"
scout_dataexport_api_ExportDataRequest.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportFormat(ConjureUnionType):
    _arrow: Optional["scout_dataexport_api_Arrow"] = None
    _csv: Optional["scout_dataexport_api_Csv"] = None
    _matfile: Optional["scout_dataexport_api_Matfile"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'arrow': ConjureFieldDefinition('arrow', scout_dataexport_api_Arrow),
            'csv': ConjureFieldDefinition('csv', scout_dataexport_api_Csv),
            'matfile': ConjureFieldDefinition('matfile', scout_dataexport_api_Matfile)
        }

    def __init__(
            self,
            arrow: Optional["scout_dataexport_api_Arrow"] = None,
            csv: Optional["scout_dataexport_api_Csv"] = None,
            matfile: Optional["scout_dataexport_api_Matfile"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (arrow is not None) + (csv is not None) + (matfile is not None) != 1:
                raise ValueError('a union must contain a single member')

            if arrow is not None:
                self._arrow = arrow
                self._type = 'arrow'
            if csv is not None:
                self._csv = csv
                self._type = 'csv'
            if matfile is not None:
                self._matfile = matfile
                self._type = 'matfile'

        elif type_of_union == 'arrow':
            if arrow is None:
                raise ValueError('a union value must not be None')
            self._arrow = arrow
            self._type = 'arrow'
        elif type_of_union == 'csv':
            if csv is None:
                raise ValueError('a union value must not be None')
            self._csv = csv
            self._type = 'csv'
        elif type_of_union == 'matfile':
            if matfile is None:
                raise ValueError('a union value must not be None')
            self._matfile = matfile
            self._type = 'matfile'

    @builtins.property
    def arrow(self) -> Optional["scout_dataexport_api_Arrow"]:
        return self._arrow

    @builtins.property
    def csv(self) -> Optional["scout_dataexport_api_Csv"]:
        return self._csv

    @builtins.property
    def matfile(self) -> Optional["scout_dataexport_api_Matfile"]:
        return self._matfile

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ExportFormatVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ExportFormatVisitor'.format(visitor.__class__.__name__))
        if self._type == 'arrow' and self.arrow is not None:
            return visitor._arrow(self.arrow)
        if self._type == 'csv' and self.csv is not None:
            return visitor._csv(self.csv)
        if self._type == 'matfile' and self.matfile is not None:
            return visitor._matfile(self.matfile)


scout_dataexport_api_ExportFormat.__name__ = "ExportFormat"
scout_dataexport_api_ExportFormat.__qualname__ = "ExportFormat"
scout_dataexport_api_ExportFormat.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportFormatVisitor:

    @abstractmethod
    def _arrow(self, arrow: "scout_dataexport_api_Arrow") -> Any:
        pass

    @abstractmethod
    def _csv(self, csv: "scout_dataexport_api_Csv") -> Any:
        pass

    @abstractmethod
    def _matfile(self, matfile: "scout_dataexport_api_Matfile") -> Any:
        pass


scout_dataexport_api_ExportFormatVisitor.__name__ = "ExportFormatVisitor"
scout_dataexport_api_ExportFormatVisitor.__qualname__ = "ExportFormatVisitor"
scout_dataexport_api_ExportFormatVisitor.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ExportTimeDomainChannels(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'output_timestamp_format': ConjureFieldDefinition('outputTimestampFormat', scout_dataexport_api_TimestampFormat),
            'merge_timestamp_strategy': ConjureFieldDefinition('mergeTimestampStrategy', scout_dataexport_api_MergeTimestampStrategy),
            'channels': ConjureFieldDefinition('channels', List[scout_dataexport_api_TimeDomainChannel])
        }

    __slots__: List[str] = ['_output_timestamp_format', '_merge_timestamp_strategy', '_channels']

    def __init__(self, channels: List["scout_dataexport_api_TimeDomainChannel"], merge_timestamp_strategy: "scout_dataexport_api_MergeTimestampStrategy", output_timestamp_format: "scout_dataexport_api_TimestampFormat") -> None:
        self._output_timestamp_format = output_timestamp_format
        self._merge_timestamp_strategy = merge_timestamp_strategy
        self._channels = channels

    @builtins.property
    def output_timestamp_format(self) -> "scout_dataexport_api_TimestampFormat":
        return self._output_timestamp_format

    @builtins.property
    def merge_timestamp_strategy(self) -> "scout_dataexport_api_MergeTimestampStrategy":
        return self._merge_timestamp_strategy

    @builtins.property
    def channels(self) -> List["scout_dataexport_api_TimeDomainChannel"]:
        return self._channels


scout_dataexport_api_ExportTimeDomainChannels.__name__ = "ExportTimeDomainChannels"
scout_dataexport_api_ExportTimeDomainChannels.__qualname__ = "ExportTimeDomainChannels"
scout_dataexport_api_ExportTimeDomainChannels.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_GeneratePresignedLinkResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'presigned_url': ConjureFieldDefinition('presignedUrl', scout_dataexport_api_PresignedUrl)
        }

    __slots__: List[str] = ['_presigned_url']

    def __init__(self, presigned_url: "scout_dataexport_api_PresignedUrl") -> None:
        self._presigned_url = presigned_url

    @builtins.property
    def presigned_url(self) -> "scout_dataexport_api_PresignedUrl":
        return self._presigned_url


scout_dataexport_api_GeneratePresignedLinkResponse.__name__ = "GeneratePresignedLinkResponse"
scout_dataexport_api_GeneratePresignedLinkResponse.__qualname__ = "GeneratePresignedLinkResponse"
scout_dataexport_api_GeneratePresignedLinkResponse.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_Iso8601TimestampFormat(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Iso8601TimestampFormat.__name__ = "Iso8601TimestampFormat"
scout_dataexport_api_Iso8601TimestampFormat.__qualname__ = "Iso8601TimestampFormat"
scout_dataexport_api_Iso8601TimestampFormat.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_Matfile(ConjureBeanType):
    """Export settings for a `.mat` file compatible with matlab.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_Matfile.__name__ = "Matfile"
scout_dataexport_api_Matfile.__qualname__ = "Matfile"
scout_dataexport_api_Matfile.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_MergeTimestampStrategy(ConjureUnionType):
    """How to handle timestamps that are not aligned.
    """
    _none: Optional["scout_dataexport_api_NoneStrategy"] = None
    _all_timestamps_forward_fill: Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'none': ConjureFieldDefinition('none', scout_dataexport_api_NoneStrategy),
            'all_timestamps_forward_fill': ConjureFieldDefinition('allTimestampsForwardFill', scout_dataexport_api_AllTimestampsForwardFillStrategy)
        }

    def __init__(
            self,
            none: Optional["scout_dataexport_api_NoneStrategy"] = None,
            all_timestamps_forward_fill: Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (none is not None) + (all_timestamps_forward_fill is not None) != 1:
                raise ValueError('a union must contain a single member')

            if none is not None:
                self._none = none
                self._type = 'none'
            if all_timestamps_forward_fill is not None:
                self._all_timestamps_forward_fill = all_timestamps_forward_fill
                self._type = 'allTimestampsForwardFill'

        elif type_of_union == 'none':
            if none is None:
                raise ValueError('a union value must not be None')
            self._none = none
            self._type = 'none'
        elif type_of_union == 'allTimestampsForwardFill':
            if all_timestamps_forward_fill is None:
                raise ValueError('a union value must not be None')
            self._all_timestamps_forward_fill = all_timestamps_forward_fill
            self._type = 'allTimestampsForwardFill'

    @builtins.property
    def none(self) -> Optional["scout_dataexport_api_NoneStrategy"]:
        return self._none

    @builtins.property
    def all_timestamps_forward_fill(self) -> Optional["scout_dataexport_api_AllTimestampsForwardFillStrategy"]:
        return self._all_timestamps_forward_fill

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_MergeTimestampStrategyVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_MergeTimestampStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'none' and self.none is not None:
            return visitor._none(self.none)
        if self._type == 'allTimestampsForwardFill' and self.all_timestamps_forward_fill is not None:
            return visitor._all_timestamps_forward_fill(self.all_timestamps_forward_fill)


scout_dataexport_api_MergeTimestampStrategy.__name__ = "MergeTimestampStrategy"
scout_dataexport_api_MergeTimestampStrategy.__qualname__ = "MergeTimestampStrategy"
scout_dataexport_api_MergeTimestampStrategy.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_MergeTimestampStrategyVisitor:

    @abstractmethod
    def _none(self, none: "scout_dataexport_api_NoneStrategy") -> Any:
        pass

    @abstractmethod
    def _all_timestamps_forward_fill(self, all_timestamps_forward_fill: "scout_dataexport_api_AllTimestampsForwardFillStrategy") -> Any:
        pass


scout_dataexport_api_MergeTimestampStrategyVisitor.__name__ = "MergeTimestampStrategyVisitor"
scout_dataexport_api_MergeTimestampStrategyVisitor.__qualname__ = "MergeTimestampStrategyVisitor"
scout_dataexport_api_MergeTimestampStrategyVisitor.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_NoneStrategy(ConjureBeanType):
    """Do nothing. The value of a channel will be empty at
timestamps not present in its original time series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_NoneStrategy.__name__ = "NoneStrategy"
scout_dataexport_api_NoneStrategy.__qualname__ = "NoneStrategy"
scout_dataexport_api_NoneStrategy.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_PresignedUrl(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_url']

    def __init__(self, url: str) -> None:
        self._url = url

    @builtins.property
    def url(self) -> str:
        return self._url


scout_dataexport_api_PresignedUrl.__name__ = "PresignedUrl"
scout_dataexport_api_PresignedUrl.__qualname__ = "PresignedUrl"
scout_dataexport_api_PresignedUrl.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_RelativeTimestampFormat(ConjureBeanType):
    """Returns in relative time to the supplied timestamp.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'relative_to': ConjureFieldDefinition('relativeTo', api_Timestamp),
            'time_unit': ConjureFieldDefinition('timeUnit', api_TimeUnit)
        }

    __slots__: List[str] = ['_relative_to', '_time_unit']

    def __init__(self, relative_to: "api_Timestamp", time_unit: "api_TimeUnit") -> None:
        self._relative_to = relative_to
        self._time_unit = time_unit

    @builtins.property
    def relative_to(self) -> "api_Timestamp":
        return self._relative_to

    @builtins.property
    def time_unit(self) -> "api_TimeUnit":
        return self._time_unit


scout_dataexport_api_RelativeTimestampFormat.__name__ = "RelativeTimestampFormat"
scout_dataexport_api_RelativeTimestampFormat.__qualname__ = "RelativeTimestampFormat"
scout_dataexport_api_RelativeTimestampFormat.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ResolutionOption(ConjureUnionType):
    """The minimum desired step between adjacent timestamps. If multiple values are available for a timestamp,
the mean of the values will be used for numeric types and the mode of the values will be used for enum types.
    """
    _nanoseconds: Optional[int] = None
    _buckets: Optional[int] = None
    _undecimated: Optional["scout_dataexport_api_UndecimatedResolution"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nanoseconds': ConjureFieldDefinition('nanoseconds', int),
            'buckets': ConjureFieldDefinition('buckets', int),
            'undecimated': ConjureFieldDefinition('undecimated', scout_dataexport_api_UndecimatedResolution)
        }

    def __init__(
            self,
            nanoseconds: Optional[int] = None,
            buckets: Optional[int] = None,
            undecimated: Optional["scout_dataexport_api_UndecimatedResolution"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (nanoseconds is not None) + (buckets is not None) + (undecimated is not None) != 1:
                raise ValueError('a union must contain a single member')

            if nanoseconds is not None:
                self._nanoseconds = nanoseconds
                self._type = 'nanoseconds'
            if buckets is not None:
                self._buckets = buckets
                self._type = 'buckets'
            if undecimated is not None:
                self._undecimated = undecimated
                self._type = 'undecimated'

        elif type_of_union == 'nanoseconds':
            if nanoseconds is None:
                raise ValueError('a union value must not be None')
            self._nanoseconds = nanoseconds
            self._type = 'nanoseconds'
        elif type_of_union == 'buckets':
            if buckets is None:
                raise ValueError('a union value must not be None')
            self._buckets = buckets
            self._type = 'buckets'
        elif type_of_union == 'undecimated':
            if undecimated is None:
                raise ValueError('a union value must not be None')
            self._undecimated = undecimated
            self._type = 'undecimated'

    @builtins.property
    def nanoseconds(self) -> Optional[int]:
        return self._nanoseconds

    @builtins.property
    def buckets(self) -> Optional[int]:
        return self._buckets

    @builtins.property
    def undecimated(self) -> Optional["scout_dataexport_api_UndecimatedResolution"]:
        return self._undecimated

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_ResolutionOptionVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_ResolutionOptionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'nanoseconds' and self.nanoseconds is not None:
            return visitor._nanoseconds(self.nanoseconds)
        if self._type == 'buckets' and self.buckets is not None:
            return visitor._buckets(self.buckets)
        if self._type == 'undecimated' and self.undecimated is not None:
            return visitor._undecimated(self.undecimated)


scout_dataexport_api_ResolutionOption.__name__ = "ResolutionOption"
scout_dataexport_api_ResolutionOption.__qualname__ = "ResolutionOption"
scout_dataexport_api_ResolutionOption.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_ResolutionOptionVisitor:

    @abstractmethod
    def _nanoseconds(self, nanoseconds: int) -> Any:
        pass

    @abstractmethod
    def _buckets(self, buckets: int) -> Any:
        pass

    @abstractmethod
    def _undecimated(self, undecimated: "scout_dataexport_api_UndecimatedResolution") -> Any:
        pass


scout_dataexport_api_ResolutionOptionVisitor.__name__ = "ResolutionOptionVisitor"
scout_dataexport_api_ResolutionOptionVisitor.__qualname__ = "ResolutionOptionVisitor"
scout_dataexport_api_ResolutionOptionVisitor.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_TimeDomainChannel(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'column_name': ConjureFieldDefinition('columnName', str),
            'compute_node': ConjureFieldDefinition('computeNode', scout_compute_api_Series)
        }

    __slots__: List[str] = ['_column_name', '_compute_node']

    def __init__(self, column_name: str, compute_node: "scout_compute_api_Series") -> None:
        self._column_name = column_name
        self._compute_node = compute_node

    @builtins.property
    def column_name(self) -> str:
        return self._column_name

    @builtins.property
    def compute_node(self) -> "scout_compute_api_Series":
        return self._compute_node


scout_dataexport_api_TimeDomainChannel.__name__ = "TimeDomainChannel"
scout_dataexport_api_TimeDomainChannel.__qualname__ = "TimeDomainChannel"
scout_dataexport_api_TimeDomainChannel.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_TimestampFormat(ConjureUnionType):
    _iso8601: Optional["scout_dataexport_api_Iso8601TimestampFormat"] = None
    _relative: Optional["scout_dataexport_api_RelativeTimestampFormat"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'iso8601': ConjureFieldDefinition('iso8601', scout_dataexport_api_Iso8601TimestampFormat),
            'relative': ConjureFieldDefinition('relative', scout_dataexport_api_RelativeTimestampFormat)
        }

    def __init__(
            self,
            iso8601: Optional["scout_dataexport_api_Iso8601TimestampFormat"] = None,
            relative: Optional["scout_dataexport_api_RelativeTimestampFormat"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (iso8601 is not None) + (relative is not None) != 1:
                raise ValueError('a union must contain a single member')

            if iso8601 is not None:
                self._iso8601 = iso8601
                self._type = 'iso8601'
            if relative is not None:
                self._relative = relative
                self._type = 'relative'

        elif type_of_union == 'iso8601':
            if iso8601 is None:
                raise ValueError('a union value must not be None')
            self._iso8601 = iso8601
            self._type = 'iso8601'
        elif type_of_union == 'relative':
            if relative is None:
                raise ValueError('a union value must not be None')
            self._relative = relative
            self._type = 'relative'

    @builtins.property
    def iso8601(self) -> Optional["scout_dataexport_api_Iso8601TimestampFormat"]:
        return self._iso8601

    @builtins.property
    def relative(self) -> Optional["scout_dataexport_api_RelativeTimestampFormat"]:
        return self._relative

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_dataexport_api_TimestampFormatVisitor):
            raise ValueError('{} is not an instance of scout_dataexport_api_TimestampFormatVisitor'.format(visitor.__class__.__name__))
        if self._type == 'iso8601' and self.iso8601 is not None:
            return visitor._iso8601(self.iso8601)
        if self._type == 'relative' and self.relative is not None:
            return visitor._relative(self.relative)


scout_dataexport_api_TimestampFormat.__name__ = "TimestampFormat"
scout_dataexport_api_TimestampFormat.__qualname__ = "TimestampFormat"
scout_dataexport_api_TimestampFormat.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_TimestampFormatVisitor:

    @abstractmethod
    def _iso8601(self, iso8601: "scout_dataexport_api_Iso8601TimestampFormat") -> Any:
        pass

    @abstractmethod
    def _relative(self, relative: "scout_dataexport_api_RelativeTimestampFormat") -> Any:
        pass


scout_dataexport_api_TimestampFormatVisitor.__name__ = "TimestampFormatVisitor"
scout_dataexport_api_TimestampFormatVisitor.__qualname__ = "TimestampFormatVisitor"
scout_dataexport_api_TimestampFormatVisitor.__module__ = "nominal_api.scout_dataexport_api"


class scout_dataexport_api_UndecimatedResolution(ConjureBeanType):
    """Full resolution.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_dataexport_api_UndecimatedResolution.__name__ = "UndecimatedResolution"
scout_dataexport_api_UndecimatedResolution.__qualname__ = "UndecimatedResolution"
scout_dataexport_api_UndecimatedResolution.__module__ = "nominal_api.scout_dataexport_api"


class scout_datareview_api_ArchiveDataReview(ConjureBeanType):
    """Archive the data review which created this check alert. Only performable via the archive data review endpoint;
not supported by Perform Check Alert Action.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ArchiveDataReview.__name__ = "ArchiveDataReview"
scout_datareview_api_ArchiveDataReview.__qualname__ = "ArchiveDataReview"
scout_datareview_api_ArchiveDataReview.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_AutomaticCheckEvaluationRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'check_implementation_index': ConjureFieldDefinition('checkImplementationIndex', OptionalTypeWrapper[int]),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'state': ConjureFieldDefinition('state', scout_datareview_api_AutomaticCheckEvaluationState)
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_check_implementation_index', '_data_review_rid', '_state']

    def __init__(self, check_rid: str, data_review_rid: str, rid: str, state: "scout_datareview_api_AutomaticCheckEvaluationState", check_implementation_index: Optional[int] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._check_implementation_index = check_implementation_index
        self._data_review_rid = data_review_rid
        self._state = state

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def check_implementation_index(self) -> Optional[int]:
        """Checks can define a single range computation which can evaluate over multiple implementations of a context.
The check implementation index will correspond to the implementation index of the check condition.
        """
        return self._check_implementation_index

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def state(self) -> "scout_datareview_api_AutomaticCheckEvaluationState":
        return self._state


scout_datareview_api_AutomaticCheckEvaluation.__name__ = "AutomaticCheckEvaluation"
scout_datareview_api_AutomaticCheckEvaluation.__qualname__ = "AutomaticCheckEvaluation"
scout_datareview_api_AutomaticCheckEvaluation.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationAction(ConjureUnionType):
    _execution_finished: Optional["scout_datareview_api_AutomaticCheckExecutionFinished"] = None
    _execution_failed_to_run: Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"] = None
    _execution_retriggered: Optional["scout_datareview_api_ExecutionRetriggered"] = None
    _execution_started: Optional["scout_datareview_api_AutomaticCheckExecutionStarted"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'execution_finished': ConjureFieldDefinition('executionFinished', scout_datareview_api_AutomaticCheckExecutionFinished),
            'execution_failed_to_run': ConjureFieldDefinition('executionFailedToRun', scout_datareview_api_AutomaticCheckExecutionFailedToRun),
            'execution_retriggered': ConjureFieldDefinition('executionRetriggered', scout_datareview_api_ExecutionRetriggered),
            'execution_started': ConjureFieldDefinition('executionStarted', scout_datareview_api_AutomaticCheckExecutionStarted)
        }

    def __init__(
            self,
            execution_finished: Optional["scout_datareview_api_AutomaticCheckExecutionFinished"] = None,
            execution_failed_to_run: Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"] = None,
            execution_retriggered: Optional["scout_datareview_api_ExecutionRetriggered"] = None,
            execution_started: Optional["scout_datareview_api_AutomaticCheckExecutionStarted"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (execution_finished is not None) + (execution_failed_to_run is not None) + (execution_retriggered is not None) + (execution_started is not None) != 1:
                raise ValueError('a union must contain a single member')

            if execution_finished is not None:
                self._execution_finished = execution_finished
                self._type = 'executionFinished'
            if execution_failed_to_run is not None:
                self._execution_failed_to_run = execution_failed_to_run
                self._type = 'executionFailedToRun'
            if execution_retriggered is not None:
                self._execution_retriggered = execution_retriggered
                self._type = 'executionRetriggered'
            if execution_started is not None:
                self._execution_started = execution_started
                self._type = 'executionStarted'

        elif type_of_union == 'executionFinished':
            if execution_finished is None:
                raise ValueError('a union value must not be None')
            self._execution_finished = execution_finished
            self._type = 'executionFinished'
        elif type_of_union == 'executionFailedToRun':
            if execution_failed_to_run is None:
                raise ValueError('a union value must not be None')
            self._execution_failed_to_run = execution_failed_to_run
            self._type = 'executionFailedToRun'
        elif type_of_union == 'executionRetriggered':
            if execution_retriggered is None:
                raise ValueError('a union value must not be None')
            self._execution_retriggered = execution_retriggered
            self._type = 'executionRetriggered'
        elif type_of_union == 'executionStarted':
            if execution_started is None:
                raise ValueError('a union value must not be None')
            self._execution_started = execution_started
            self._type = 'executionStarted'

    @builtins.property
    def execution_finished(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionFinished"]:
        return self._execution_finished

    @builtins.property
    def execution_failed_to_run(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionFailedToRun"]:
        return self._execution_failed_to_run

    @builtins.property
    def execution_retriggered(self) -> Optional["scout_datareview_api_ExecutionRetriggered"]:
        return self._execution_retriggered

    @builtins.property
    def execution_started(self) -> Optional["scout_datareview_api_AutomaticCheckExecutionStarted"]:
        return self._execution_started

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'executionFinished' and self.execution_finished is not None:
            return visitor._execution_finished(self.execution_finished)
        if self._type == 'executionFailedToRun' and self.execution_failed_to_run is not None:
            return visitor._execution_failed_to_run(self.execution_failed_to_run)
        if self._type == 'executionRetriggered' and self.execution_retriggered is not None:
            return visitor._execution_retriggered(self.execution_retriggered)
        if self._type == 'executionStarted' and self.execution_started is not None:
            return visitor._execution_started(self.execution_started)


scout_datareview_api_AutomaticCheckEvaluationAction.__name__ = "AutomaticCheckEvaluationAction"
scout_datareview_api_AutomaticCheckEvaluationAction.__qualname__ = "AutomaticCheckEvaluationAction"
scout_datareview_api_AutomaticCheckEvaluationAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionVisitor:

    @abstractmethod
    def _execution_finished(self, execution_finished: "scout_datareview_api_AutomaticCheckExecutionFinished") -> Any:
        pass

    @abstractmethod
    def _execution_failed_to_run(self, execution_failed_to_run: "scout_datareview_api_AutomaticCheckExecutionFailedToRun") -> Any:
        pass

    @abstractmethod
    def _execution_retriggered(self, execution_retriggered: "scout_datareview_api_ExecutionRetriggered") -> Any:
        pass

    @abstractmethod
    def _execution_started(self, execution_started: "scout_datareview_api_AutomaticCheckExecutionStarted") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__name__ = "AutomaticCheckEvaluationActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__qualname__ = "AutomaticCheckEvaluationActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationActionVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_AutomaticCheckEvaluationActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_AutomaticCheckEvaluationActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_AutomaticCheckEvaluationActionLogEntry"]:
        return self._entries


scout_datareview_api_AutomaticCheckEvaluationActionLog.__name__ = "AutomaticCheckEvaluationActionLog"
scout_datareview_api_AutomaticCheckEvaluationActionLog.__qualname__ = "AutomaticCheckEvaluationActionLog"
scout_datareview_api_AutomaticCheckEvaluationActionLog.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'action': ConjureFieldDefinition('action', scout_datareview_api_AutomaticCheckEvaluationAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_AutomaticCheckEvaluationAction", timestamp: str) -> None:
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def action(self) -> "scout_datareview_api_AutomaticCheckEvaluationAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__name__ = "AutomaticCheckEvaluationActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__qualname__ = "AutomaticCheckEvaluationActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationActionLogEntry.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)


scout_datareview_api_AutomaticCheckEvaluationReviewAction.__name__ = "AutomaticCheckEvaluationReviewAction"
scout_datareview_api_AutomaticCheckEvaluationReviewAction.__qualname__ = "AutomaticCheckEvaluationReviewAction"
scout_datareview_api_AutomaticCheckEvaluationReviewAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__name__ = "AutomaticCheckEvaluationReviewActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__qualname__ = "AutomaticCheckEvaluationReviewActionVisitor"
scout_datareview_api_AutomaticCheckEvaluationReviewActionVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry"]:
        return self._entries


scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__name__ = "AutomaticCheckEvaluationReviewActionLog"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__qualname__ = "AutomaticCheckEvaluationReviewActionLog"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLog.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_AutomaticCheckEvaluationReviewAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_AutomaticCheckEvaluationReviewAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_AutomaticCheckEvaluationReviewAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__name__ = "AutomaticCheckEvaluationReviewActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__qualname__ = "AutomaticCheckEvaluationReviewActionLogEntry"
scout_datareview_api_AutomaticCheckEvaluationReviewActionLogEntry.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationState(ConjureUnionType):
    _pending_execution: Optional["scout_datareview_api_PendingExecutionState"] = None
    _failed_to_execute: Optional["scout_datareview_api_FailedToExecuteState"] = None
    _passing: Optional["scout_datareview_api_PassingExecutionState"] = None
    _generated_alerts: Optional["scout_datareview_api_GeneratedAlertsState"] = None
    _too_many_alerts: Optional["scout_datareview_api_TooManyAlertsState"] = None
    _executing: Optional["scout_datareview_api_ExecutingState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_execution': ConjureFieldDefinition('pendingExecution', scout_datareview_api_PendingExecutionState),
            'failed_to_execute': ConjureFieldDefinition('failedToExecute', scout_datareview_api_FailedToExecuteState),
            'passing': ConjureFieldDefinition('passing', scout_datareview_api_PassingExecutionState),
            'generated_alerts': ConjureFieldDefinition('generatedAlerts', scout_datareview_api_GeneratedAlertsState),
            'too_many_alerts': ConjureFieldDefinition('tooManyAlerts', scout_datareview_api_TooManyAlertsState),
            'executing': ConjureFieldDefinition('executing', scout_datareview_api_ExecutingState)
        }

    def __init__(
            self,
            pending_execution: Optional["scout_datareview_api_PendingExecutionState"] = None,
            failed_to_execute: Optional["scout_datareview_api_FailedToExecuteState"] = None,
            passing: Optional["scout_datareview_api_PassingExecutionState"] = None,
            generated_alerts: Optional["scout_datareview_api_GeneratedAlertsState"] = None,
            too_many_alerts: Optional["scout_datareview_api_TooManyAlertsState"] = None,
            executing: Optional["scout_datareview_api_ExecutingState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_execution is not None) + (failed_to_execute is not None) + (passing is not None) + (generated_alerts is not None) + (too_many_alerts is not None) + (executing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_execution is not None:
                self._pending_execution = pending_execution
                self._type = 'pendingExecution'
            if failed_to_execute is not None:
                self._failed_to_execute = failed_to_execute
                self._type = 'failedToExecute'
            if passing is not None:
                self._passing = passing
                self._type = 'passing'
            if generated_alerts is not None:
                self._generated_alerts = generated_alerts
                self._type = 'generatedAlerts'
            if too_many_alerts is not None:
                self._too_many_alerts = too_many_alerts
                self._type = 'tooManyAlerts'
            if executing is not None:
                self._executing = executing
                self._type = 'executing'

        elif type_of_union == 'pendingExecution':
            if pending_execution is None:
                raise ValueError('a union value must not be None')
            self._pending_execution = pending_execution
            self._type = 'pendingExecution'
        elif type_of_union == 'failedToExecute':
            if failed_to_execute is None:
                raise ValueError('a union value must not be None')
            self._failed_to_execute = failed_to_execute
            self._type = 'failedToExecute'
        elif type_of_union == 'passing':
            if passing is None:
                raise ValueError('a union value must not be None')
            self._passing = passing
            self._type = 'passing'
        elif type_of_union == 'generatedAlerts':
            if generated_alerts is None:
                raise ValueError('a union value must not be None')
            self._generated_alerts = generated_alerts
            self._type = 'generatedAlerts'
        elif type_of_union == 'tooManyAlerts':
            if too_many_alerts is None:
                raise ValueError('a union value must not be None')
            self._too_many_alerts = too_many_alerts
            self._type = 'tooManyAlerts'
        elif type_of_union == 'executing':
            if executing is None:
                raise ValueError('a union value must not be None')
            self._executing = executing
            self._type = 'executing'

    @builtins.property
    def pending_execution(self) -> Optional["scout_datareview_api_PendingExecutionState"]:
        return self._pending_execution

    @builtins.property
    def failed_to_execute(self) -> Optional["scout_datareview_api_FailedToExecuteState"]:
        return self._failed_to_execute

    @builtins.property
    def passing(self) -> Optional["scout_datareview_api_PassingExecutionState"]:
        return self._passing

    @builtins.property
    def generated_alerts(self) -> Optional["scout_datareview_api_GeneratedAlertsState"]:
        return self._generated_alerts

    @builtins.property
    def too_many_alerts(self) -> Optional["scout_datareview_api_TooManyAlertsState"]:
        return self._too_many_alerts

    @builtins.property
    def executing(self) -> Optional["scout_datareview_api_ExecutingState"]:
        return self._executing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_AutomaticCheckEvaluationStateVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_AutomaticCheckEvaluationStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingExecution' and self.pending_execution is not None:
            return visitor._pending_execution(self.pending_execution)
        if self._type == 'failedToExecute' and self.failed_to_execute is not None:
            return visitor._failed_to_execute(self.failed_to_execute)
        if self._type == 'passing' and self.passing is not None:
            return visitor._passing(self.passing)
        if self._type == 'generatedAlerts' and self.generated_alerts is not None:
            return visitor._generated_alerts(self.generated_alerts)
        if self._type == 'tooManyAlerts' and self.too_many_alerts is not None:
            return visitor._too_many_alerts(self.too_many_alerts)
        if self._type == 'executing' and self.executing is not None:
            return visitor._executing(self.executing)


scout_datareview_api_AutomaticCheckEvaluationState.__name__ = "AutomaticCheckEvaluationState"
scout_datareview_api_AutomaticCheckEvaluationState.__qualname__ = "AutomaticCheckEvaluationState"
scout_datareview_api_AutomaticCheckEvaluationState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckEvaluationStateVisitor:

    @abstractmethod
    def _pending_execution(self, pending_execution: "scout_datareview_api_PendingExecutionState") -> Any:
        pass

    @abstractmethod
    def _failed_to_execute(self, failed_to_execute: "scout_datareview_api_FailedToExecuteState") -> Any:
        pass

    @abstractmethod
    def _passing(self, passing: "scout_datareview_api_PassingExecutionState") -> Any:
        pass

    @abstractmethod
    def _generated_alerts(self, generated_alerts: "scout_datareview_api_GeneratedAlertsState") -> Any:
        pass

    @abstractmethod
    def _too_many_alerts(self, too_many_alerts: "scout_datareview_api_TooManyAlertsState") -> Any:
        pass

    @abstractmethod
    def _executing(self, executing: "scout_datareview_api_ExecutingState") -> Any:
        pass


scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__name__ = "AutomaticCheckEvaluationStateVisitor"
scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__qualname__ = "AutomaticCheckEvaluationStateVisitor"
scout_datareview_api_AutomaticCheckEvaluationStateVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionFailedToRun(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_AutomaticCheckExecutionFailedToRun.__name__ = "AutomaticCheckExecutionFailedToRun"
scout_datareview_api_AutomaticCheckExecutionFailedToRun.__qualname__ = "AutomaticCheckExecutionFailedToRun"
scout_datareview_api_AutomaticCheckExecutionFailedToRun.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionFinished(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'status': ConjureFieldDefinition('status', scout_datareview_api_Status)
        }

    __slots__: List[str] = ['_job_rid', '_status']

    def __init__(self, job_rid: str, status: "scout_datareview_api_Status") -> None:
        self._job_rid = job_rid
        self._status = status

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def status(self) -> "scout_datareview_api_Status":
        return self._status


scout_datareview_api_AutomaticCheckExecutionFinished.__name__ = "AutomaticCheckExecutionFinished"
scout_datareview_api_AutomaticCheckExecutionFinished.__qualname__ = "AutomaticCheckExecutionFinished"
scout_datareview_api_AutomaticCheckExecutionFinished.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_AutomaticCheckExecutionStarted(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_AutomaticCheckExecutionStarted.__name__ = "AutomaticCheckExecutionStarted"
scout_datareview_api_AutomaticCheckExecutionStarted.__qualname__ = "AutomaticCheckExecutionStarted"
scout_datareview_api_AutomaticCheckExecutionStarted.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_evaluation_action': ConjureFieldDefinition('checkEvaluationAction', scout_datareview_api_AutomaticCheckEvaluationReviewAction),
            'check_evaluation_rids': ConjureFieldDefinition('checkEvaluationRids', List[api_rids_AutomaticCheckEvaluationRid])
        }

    __slots__: List[str] = ['_check_evaluation_action', '_check_evaluation_rids']

    def __init__(self, check_evaluation_action: "scout_datareview_api_AutomaticCheckEvaluationReviewAction", check_evaluation_rids: List[str]) -> None:
        self._check_evaluation_action = check_evaluation_action
        self._check_evaluation_rids = check_evaluation_rids

    @builtins.property
    def check_evaluation_action(self) -> "scout_datareview_api_AutomaticCheckEvaluationReviewAction":
        return self._check_evaluation_action

    @builtins.property
    def check_evaluation_rids(self) -> List[str]:
        return self._check_evaluation_rids


scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__name__ = "BatchAutomaticCheckEvaluationActionRequest"
scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__qualname__ = "BatchAutomaticCheckEvaluationActionRequest"
scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_evaluations': ConjureFieldDefinition('checkEvaluations', List[scout_datareview_api_AutomaticCheckEvaluation])
        }

    __slots__: List[str] = ['_check_evaluations']

    def __init__(self, check_evaluations: List["scout_datareview_api_AutomaticCheckEvaluation"]) -> None:
        self._check_evaluations = check_evaluations

    @builtins.property
    def check_evaluations(self) -> List["scout_datareview_api_AutomaticCheckEvaluation"]:
        return self._check_evaluations


scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__name__ = "BatchAutomaticCheckEvaluationActionResponse"
scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__qualname__ = "BatchAutomaticCheckEvaluationActionResponse"
scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchCheckAlertActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_action': ConjureFieldDefinition('checkAlertAction', scout_datareview_api_CheckAlertAction),
            'check_alert_rids': ConjureFieldDefinition('checkAlertRids', List[scout_rids_api_CheckAlertRid])
        }

    __slots__: List[str] = ['_check_alert_action', '_check_alert_rids']

    def __init__(self, check_alert_action: "scout_datareview_api_CheckAlertAction", check_alert_rids: List[str]) -> None:
        self._check_alert_action = check_alert_action
        self._check_alert_rids = check_alert_rids

    @builtins.property
    def check_alert_action(self) -> "scout_datareview_api_CheckAlertAction":
        return self._check_alert_action

    @builtins.property
    def check_alert_rids(self) -> List[str]:
        return self._check_alert_rids


scout_datareview_api_BatchCheckAlertActionRequest.__name__ = "BatchCheckAlertActionRequest"
scout_datareview_api_BatchCheckAlertActionRequest.__qualname__ = "BatchCheckAlertActionRequest"
scout_datareview_api_BatchCheckAlertActionRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchCheckAlertActionResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alerts': ConjureFieldDefinition('checkAlerts', List[scout_datareview_api_CheckAlert])
        }

    __slots__: List[str] = ['_check_alerts']

    def __init__(self, check_alerts: List["scout_datareview_api_CheckAlert"]) -> None:
        self._check_alerts = check_alerts

    @builtins.property
    def check_alerts(self) -> List["scout_datareview_api_CheckAlert"]:
        return self._check_alerts


scout_datareview_api_BatchCheckAlertActionResponse.__name__ = "BatchCheckAlertActionResponse"
scout_datareview_api_BatchCheckAlertActionResponse.__qualname__ = "BatchCheckAlertActionResponse"
scout_datareview_api_BatchCheckAlertActionResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchInitiateDataReviewRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_datareview_api_CreateDataReviewRequest]),
            'notification_configurations': ConjureFieldDefinition('notificationConfigurations', List[scout_integrations_api_NotificationConfiguration])
        }

    __slots__: List[str] = ['_requests', '_notification_configurations']

    def __init__(self, notification_configurations: List["scout_integrations_api_NotificationConfiguration"], requests: List["scout_datareview_api_CreateDataReviewRequest"]) -> None:
        self._requests = requests
        self._notification_configurations = notification_configurations

    @builtins.property
    def requests(self) -> List["scout_datareview_api_CreateDataReviewRequest"]:
        return self._requests

    @builtins.property
    def notification_configurations(self) -> List["scout_integrations_api_NotificationConfiguration"]:
        """If provided, checklist violations will be sent to the specified integrations.
        """
        return self._notification_configurations


scout_datareview_api_BatchInitiateDataReviewRequest.__name__ = "BatchInitiateDataReviewRequest"
scout_datareview_api_BatchInitiateDataReviewRequest.__qualname__ = "BatchInitiateDataReviewRequest"
scout_datareview_api_BatchInitiateDataReviewRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchInitiateDataReviewResponse(ConjureBeanType):
    """Responses are returned in the same order as the requests.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_rids_api_DataReviewRid])
        }

    __slots__: List[str] = ['_rids']

    def __init__(self, rids: List[str]) -> None:
        self._rids = rids

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids


scout_datareview_api_BatchInitiateDataReviewResponse.__name__ = "BatchInitiateDataReviewResponse"
scout_datareview_api_BatchInitiateDataReviewResponse.__qualname__ = "BatchInitiateDataReviewResponse"
scout_datareview_api_BatchInitiateDataReviewResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_BatchManualCheckEvaluationActionRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_action': ConjureFieldDefinition('checkAlertAction', scout_datareview_api_ManualCheckAlertAction),
            'check_evaluation_rids': ConjureFieldDefinition('checkEvaluationRids', List[scout_datareview_api_ManualCheckEvaluationRid])
        }

    __slots__: List[str] = ['_check_alert_action', '_check_evaluation_rids']

    def __init__(self, check_alert_action: "scout_datareview_api_ManualCheckAlertAction", check_evaluation_rids: List[str]) -> None:
        self._check_alert_action = check_alert_action
        self._check_evaluation_rids = check_evaluation_rids

    @builtins.property
    def check_alert_action(self) -> "scout_datareview_api_ManualCheckAlertAction":
        return self._check_alert_action

    @builtins.property
    def check_evaluation_rids(self) -> List[str]:
        return self._check_evaluation_rids


scout_datareview_api_BatchManualCheckEvaluationActionRequest.__name__ = "BatchManualCheckEvaluationActionRequest"
scout_datareview_api_BatchManualCheckEvaluationActionRequest.__qualname__ = "BatchManualCheckEvaluationActionRequest"
scout_datareview_api_BatchManualCheckEvaluationActionRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlert(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_CheckAlertRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'implementation_index': ConjureFieldDefinition('implementationIndex', OptionalTypeWrapper[int]),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'check_evaluation_rid': ConjureFieldDefinition('checkEvaluationRid', api_rids_AutomaticCheckEvaluationRid),
            'name': ConjureFieldDefinition('name', str),
            'autogenerated_check_title': ConjureFieldDefinition('autogeneratedCheckTitle', OptionalTypeWrapper[str]),
            'autogenerated_check_description': ConjureFieldDefinition('autogeneratedCheckDescription', OptionalTypeWrapper[str]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid]),
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[api_Timestamp]),
            'state': ConjureFieldDefinition('state', scout_rids_api_CheckAlertState),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedVizId]),
            'notes': ConjureFieldDefinition('notes', OptionalTypeWrapper[str]),
            'notebook': ConjureFieldDefinition('notebook', OptionalTypeWrapper[scout_rids_api_NotebookRid])
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_implementation_index', '_data_review_rid', '_check_evaluation_rid', '_name', '_autogenerated_check_title', '_autogenerated_check_description', '_assignee_rids', '_start', '_end', '_state', '_priority', '_chart', '_notes', '_notebook']

    def __init__(self, assignee_rids: List[str], check_evaluation_rid: str, check_rid: str, data_review_rid: str, name: str, priority: "scout_api_Priority", rid: str, start: "api_Timestamp", state: "scout_rids_api_CheckAlertState", autogenerated_check_description: Optional[str] = None, autogenerated_check_title: Optional[str] = None, chart: Optional["scout_rids_api_VersionedVizId"] = None, end: Optional["api_Timestamp"] = None, implementation_index: Optional[int] = None, notebook: Optional[str] = None, notes: Optional[str] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._implementation_index = implementation_index
        self._data_review_rid = data_review_rid
        self._check_evaluation_rid = check_evaluation_rid
        self._name = name
        self._autogenerated_check_title = autogenerated_check_title
        self._autogenerated_check_description = autogenerated_check_description
        self._assignee_rids = assignee_rids
        self._start = start
        self._end = end
        self._state = state
        self._priority = priority
        self._chart = chart
        self._notes = notes
        self._notebook = notebook

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def implementation_index(self) -> Optional[int]:
        return self._implementation_index

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def check_evaluation_rid(self) -> str:
        return self._check_evaluation_rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def autogenerated_check_title(self) -> Optional[str]:
        return self._autogenerated_check_title

    @builtins.property
    def autogenerated_check_description(self) -> Optional[str]:
        return self._autogenerated_check_description

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> Optional["api_Timestamp"]:
        return self._end

    @builtins.property
    def state(self) -> "scout_rids_api_CheckAlertState":
        return self._state

    @builtins.property
    def priority(self) -> "scout_api_Priority":
        return self._priority

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedVizId"]:
        return self._chart

    @builtins.property
    def notes(self) -> Optional[str]:
        return self._notes

    @builtins.property
    def notebook(self) -> Optional[str]:
        return self._notebook


scout_datareview_api_CheckAlert.__name__ = "CheckAlert"
scout_datareview_api_CheckAlert.__qualname__ = "CheckAlert"
scout_datareview_api_CheckAlert.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None
    _link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None
    _unlink_notebook: Optional["scout_datareview_api_UnlinkNotebook"] = None
    _archive_data_review: Optional["scout_datareview_api_ArchiveDataReview"] = None
    _unarchive_data_review: Optional["scout_datareview_api_UnarchiveDataReview"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes),
            'link_notebook': ConjureFieldDefinition('linkNotebook', scout_datareview_api_LinkNotebook),
            'unlink_notebook': ConjureFieldDefinition('unlinkNotebook', scout_datareview_api_UnlinkNotebook),
            'archive_data_review': ConjureFieldDefinition('archiveDataReview', scout_datareview_api_ArchiveDataReview),
            'unarchive_data_review': ConjureFieldDefinition('unarchiveDataReview', scout_datareview_api_UnarchiveDataReview)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None,
            unlink_notebook: Optional["scout_datareview_api_UnlinkNotebook"] = None,
            archive_data_review: Optional["scout_datareview_api_ArchiveDataReview"] = None,
            unarchive_data_review: Optional["scout_datareview_api_UnarchiveDataReview"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) + (link_notebook is not None) + (unlink_notebook is not None) + (archive_data_review is not None) + (unarchive_data_review is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'
            if link_notebook is not None:
                self._link_notebook = link_notebook
                self._type = 'linkNotebook'
            if unlink_notebook is not None:
                self._unlink_notebook = unlink_notebook
                self._type = 'unlinkNotebook'
            if archive_data_review is not None:
                self._archive_data_review = archive_data_review
                self._type = 'archiveDataReview'
            if unarchive_data_review is not None:
                self._unarchive_data_review = unarchive_data_review
                self._type = 'unarchiveDataReview'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'
        elif type_of_union == 'linkNotebook':
            if link_notebook is None:
                raise ValueError('a union value must not be None')
            self._link_notebook = link_notebook
            self._type = 'linkNotebook'
        elif type_of_union == 'unlinkNotebook':
            if unlink_notebook is None:
                raise ValueError('a union value must not be None')
            self._unlink_notebook = unlink_notebook
            self._type = 'unlinkNotebook'
        elif type_of_union == 'archiveDataReview':
            if archive_data_review is None:
                raise ValueError('a union value must not be None')
            self._archive_data_review = archive_data_review
            self._type = 'archiveDataReview'
        elif type_of_union == 'unarchiveDataReview':
            if unarchive_data_review is None:
                raise ValueError('a union value must not be None')
            self._unarchive_data_review = unarchive_data_review
            self._type = 'unarchiveDataReview'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    @builtins.property
    def link_notebook(self) -> Optional["scout_datareview_api_LinkNotebook"]:
        return self._link_notebook

    @builtins.property
    def unlink_notebook(self) -> Optional["scout_datareview_api_UnlinkNotebook"]:
        return self._unlink_notebook

    @builtins.property
    def archive_data_review(self) -> Optional["scout_datareview_api_ArchiveDataReview"]:
        return self._archive_data_review

    @builtins.property
    def unarchive_data_review(self) -> Optional["scout_datareview_api_UnarchiveDataReview"]:
        return self._unarchive_data_review

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckAlertActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckAlertActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)
        if self._type == 'linkNotebook' and self.link_notebook is not None:
            return visitor._link_notebook(self.link_notebook)
        if self._type == 'unlinkNotebook' and self.unlink_notebook is not None:
            return visitor._unlink_notebook(self.unlink_notebook)
        if self._type == 'archiveDataReview' and self.archive_data_review is not None:
            return visitor._archive_data_review(self.archive_data_review)
        if self._type == 'unarchiveDataReview' and self.unarchive_data_review is not None:
            return visitor._unarchive_data_review(self.unarchive_data_review)


scout_datareview_api_CheckAlertAction.__name__ = "CheckAlertAction"
scout_datareview_api_CheckAlertAction.__qualname__ = "CheckAlertAction"
scout_datareview_api_CheckAlertAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass

    @abstractmethod
    def _link_notebook(self, link_notebook: "scout_datareview_api_LinkNotebook") -> Any:
        pass

    @abstractmethod
    def _unlink_notebook(self, unlink_notebook: "scout_datareview_api_UnlinkNotebook") -> Any:
        pass

    @abstractmethod
    def _archive_data_review(self, archive_data_review: "scout_datareview_api_ArchiveDataReview") -> Any:
        pass

    @abstractmethod
    def _unarchive_data_review(self, unarchive_data_review: "scout_datareview_api_UnarchiveDataReview") -> Any:
        pass


scout_datareview_api_CheckAlertActionVisitor.__name__ = "CheckAlertActionVisitor"
scout_datareview_api_CheckAlertActionVisitor.__qualname__ = "CheckAlertActionVisitor"
scout_datareview_api_CheckAlertActionVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_CheckAlertActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_CheckAlertActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_CheckAlertActionLogEntry"]:
        return self._entries


scout_datareview_api_CheckAlertActionLog.__name__ = "CheckAlertActionLog"
scout_datareview_api_CheckAlertActionLog.__qualname__ = "CheckAlertActionLog"
scout_datareview_api_CheckAlertActionLog.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_CheckAlertAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_CheckAlertAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_CheckAlertAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_CheckAlertActionLogEntry.__name__ = "CheckAlertActionLogEntry"
scout_datareview_api_CheckAlertActionLogEntry.__qualname__ = "CheckAlertActionLogEntry"
scout_datareview_api_CheckAlertActionLogEntry.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertStatus(ConjureEnumType):

    PENDING_REVIEW = 'PENDING_REVIEW'
    '''PENDING_REVIEW'''
    CLOSED_IGNORED = 'CLOSED_IGNORED'
    '''CLOSED_IGNORED'''
    CLOSED_REQUIRES_FURTHER_ACTION = 'CLOSED_REQUIRES_FURTHER_ACTION'
    '''CLOSED_REQUIRES_FURTHER_ACTION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_CheckAlertStatus.__name__ = "CheckAlertStatus"
scout_datareview_api_CheckAlertStatus.__qualname__ = "CheckAlertStatus"
scout_datareview_api_CheckAlertStatus.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramBuckets(ConjureUnionType):
    _unstacked: Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"] = None
    _priority: Optional["scout_datareview_api_CheckAlertsPriorityHistogram"] = None
    _status: Optional["scout_datareview_api_CheckAlertsStatusHistogram"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unstacked': ConjureFieldDefinition('unstacked', scout_datareview_api_CheckAlertsUnstackedHistogram),
            'priority': ConjureFieldDefinition('priority', scout_datareview_api_CheckAlertsPriorityHistogram),
            'status': ConjureFieldDefinition('status', scout_datareview_api_CheckAlertsStatusHistogram)
        }

    def __init__(
            self,
            unstacked: Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"] = None,
            priority: Optional["scout_datareview_api_CheckAlertsPriorityHistogram"] = None,
            status: Optional["scout_datareview_api_CheckAlertsStatusHistogram"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (unstacked is not None) + (priority is not None) + (status is not None) != 1:
                raise ValueError('a union must contain a single member')

            if unstacked is not None:
                self._unstacked = unstacked
                self._type = 'unstacked'
            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if status is not None:
                self._status = status
                self._type = 'status'

        elif type_of_union == 'unstacked':
            if unstacked is None:
                raise ValueError('a union value must not be None')
            self._unstacked = unstacked
            self._type = 'unstacked'
        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'status':
            if status is None:
                raise ValueError('a union value must not be None')
            self._status = status
            self._type = 'status'

    @builtins.property
    def unstacked(self) -> Optional["scout_datareview_api_CheckAlertsUnstackedHistogram"]:
        return self._unstacked

    @builtins.property
    def priority(self) -> Optional["scout_datareview_api_CheckAlertsPriorityHistogram"]:
        return self._priority

    @builtins.property
    def status(self) -> Optional["scout_datareview_api_CheckAlertsStatusHistogram"]:
        return self._status

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckAlertsHistogramBucketsVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckAlertsHistogramBucketsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'unstacked' and self.unstacked is not None:
            return visitor._unstacked(self.unstacked)
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'status' and self.status is not None:
            return visitor._status(self.status)


scout_datareview_api_CheckAlertsHistogramBuckets.__name__ = "CheckAlertsHistogramBuckets"
scout_datareview_api_CheckAlertsHistogramBuckets.__qualname__ = "CheckAlertsHistogramBuckets"
scout_datareview_api_CheckAlertsHistogramBuckets.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramBucketsVisitor:

    @abstractmethod
    def _unstacked(self, unstacked: "scout_datareview_api_CheckAlertsUnstackedHistogram") -> Any:
        pass

    @abstractmethod
    def _priority(self, priority: "scout_datareview_api_CheckAlertsPriorityHistogram") -> Any:
        pass

    @abstractmethod
    def _status(self, status: "scout_datareview_api_CheckAlertsStatusHistogram") -> Any:
        pass


scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__name__ = "CheckAlertsHistogramBucketsVisitor"
scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__qualname__ = "CheckAlertsHistogramBucketsVisitor"
scout_datareview_api_CheckAlertsHistogramBucketsVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_bins': ConjureFieldDefinition('numBins', OptionalTypeWrapper[int]),
            'search_text': ConjureFieldDefinition('searchText', OptionalTypeWrapper[str]),
            'distribution_variable': ConjureFieldDefinition('distributionVariable', scout_datareview_api_HistogramDistributionVariable),
            'sub_group_variable': ConjureFieldDefinition('subGroupVariable', OptionalTypeWrapper[scout_datareview_api_HistogramSubGroupVariable]),
            'start_time_after': ConjureFieldDefinition('startTimeAfter', api_Timestamp),
            'start_time_before': ConjureFieldDefinition('startTimeBefore', api_Timestamp),
            'status': ConjureFieldDefinition('status', OptionalTypeWrapper[List[scout_datareview_api_CheckAlertStatus]]),
            'check_rids': ConjureFieldDefinition('checkRids', OptionalTypeWrapper[List[scout_rids_api_CheckRid]]),
            'data_review_rids': ConjureFieldDefinition('dataReviewRids', OptionalTypeWrapper[List[scout_rids_api_DataReviewRid]]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', OptionalTypeWrapper[List[scout_rids_api_UserRid]]),
            'priorities': ConjureFieldDefinition('priorities', OptionalTypeWrapper[List[scout_api_Priority]]),
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid]),
            'pinned_checklist_refs': ConjureFieldDefinition('pinnedChecklistRefs', OptionalTypeWrapper[List[scout_checks_api_PinnedChecklistRef]]),
            'chart_rids': ConjureFieldDefinition('chartRids', OptionalTypeWrapper[List[scout_rids_api_VersionedVizId]]),
            'notebook_rids': ConjureFieldDefinition('notebookRids', OptionalTypeWrapper[List[scout_rids_api_NotebookRid]]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_num_bins', '_search_text', '_distribution_variable', '_sub_group_variable', '_start_time_after', '_start_time_before', '_status', '_check_rids', '_data_review_rids', '_assignee_rids', '_priorities', '_run_rids', '_asset_rids', '_pinned_checklist_refs', '_chart_rids', '_notebook_rids', '_show_archived', '_archived_statuses']

    def __init__(self, asset_rids: List[str], distribution_variable: "scout_datareview_api_HistogramDistributionVariable", run_rids: List[str], start_time_after: "api_Timestamp", start_time_before: "api_Timestamp", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, assignee_rids: Optional[List[str]] = None, chart_rids: Optional[List["scout_rids_api_VersionedVizId"]] = None, check_rids: Optional[List[str]] = None, data_review_rids: Optional[List[str]] = None, notebook_rids: Optional[List[str]] = None, num_bins: Optional[int] = None, pinned_checklist_refs: Optional[List["scout_checks_api_PinnedChecklistRef"]] = None, priorities: Optional[List["scout_api_Priority"]] = None, search_text: Optional[str] = None, show_archived: Optional[bool] = None, status: Optional[List["scout_datareview_api_CheckAlertStatus"]] = None, sub_group_variable: Optional["scout_datareview_api_HistogramSubGroupVariable"] = None) -> None:
        self._num_bins = num_bins
        self._search_text = search_text
        self._distribution_variable = distribution_variable
        self._sub_group_variable = sub_group_variable
        self._start_time_after = start_time_after
        self._start_time_before = start_time_before
        self._status = status
        self._check_rids = check_rids
        self._data_review_rids = data_review_rids
        self._assignee_rids = assignee_rids
        self._priorities = priorities
        self._run_rids = run_rids
        self._asset_rids = asset_rids
        self._pinned_checklist_refs = pinned_checklist_refs
        self._chart_rids = chart_rids
        self._notebook_rids = notebook_rids
        self._show_archived = show_archived
        self._archived_statuses = archived_statuses

    @builtins.property
    def num_bins(self) -> Optional[int]:
        """Defaults to 100. Throws if larger than 1_000.
        """
        return self._num_bins

    @builtins.property
    def search_text(self) -> Optional[str]:
        """Matches on check name
        """
        return self._search_text

    @builtins.property
    def distribution_variable(self) -> "scout_datareview_api_HistogramDistributionVariable":
        """Represents the data points on the x-axis of a histogram.
        """
        return self._distribution_variable

    @builtins.property
    def sub_group_variable(self) -> Optional["scout_datareview_api_HistogramSubGroupVariable"]:
        """The variable that divides the data into distinct groups for comparison within the histogram.
        """
        return self._sub_group_variable

    @builtins.property
    def start_time_after(self) -> "api_Timestamp":
        """Filters to start times after this time, inclusive.
        """
        return self._start_time_after

    @builtins.property
    def start_time_before(self) -> "api_Timestamp":
        """Filters to start times before this time, exclusive.
        """
        return self._start_time_before

    @builtins.property
    def status(self) -> Optional[List["scout_datareview_api_CheckAlertStatus"]]:
        return self._status

    @builtins.property
    def check_rids(self) -> Optional[List[str]]:
        return self._check_rids

    @builtins.property
    def data_review_rids(self) -> Optional[List[str]]:
        return self._data_review_rids

    @builtins.property
    def assignee_rids(self) -> Optional[List[str]]:
        return self._assignee_rids

    @builtins.property
    def priorities(self) -> Optional[List["scout_api_Priority"]]:
        return self._priorities

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def asset_rids(self) -> List[str]:
        return self._asset_rids

    @builtins.property
    def pinned_checklist_refs(self) -> Optional[List["scout_checks_api_PinnedChecklistRef"]]:
        return self._pinned_checklist_refs

    @builtins.property
    def chart_rids(self) -> Optional[List["scout_rids_api_VersionedVizId"]]:
        return self._chart_rids

    @builtins.property
    def notebook_rids(self) -> Optional[List[str]]:
        return self._notebook_rids

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """To be deprecated. Use archivedStatuses instead. If not present, will not show archived data reviews 
in search results.
        """
        return self._show_archived

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Filters search on check alerts based on the archived statuses provided. 
Default is NOT_ARCHIVED only if none are provided.
        """
        return self._archived_statuses


scout_datareview_api_CheckAlertsHistogramRequest.__name__ = "CheckAlertsHistogramRequest"
scout_datareview_api_CheckAlertsHistogramRequest.__qualname__ = "CheckAlertsHistogramRequest"
scout_datareview_api_CheckAlertsHistogramRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsHistogramResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', scout_datareview_api_CheckAlertsHistogramBuckets)
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: "scout_datareview_api_CheckAlertsHistogramBuckets") -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> "scout_datareview_api_CheckAlertsHistogramBuckets":
        return self._buckets


scout_datareview_api_CheckAlertsHistogramResponse.__name__ = "CheckAlertsHistogramResponse"
scout_datareview_api_CheckAlertsHistogramResponse.__qualname__ = "CheckAlertsHistogramResponse"
scout_datareview_api_CheckAlertsHistogramResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsPriorityHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramPriorityBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramPriorityBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramPriorityBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsPriorityHistogram.__name__ = "CheckAlertsPriorityHistogram"
scout_datareview_api_CheckAlertsPriorityHistogram.__qualname__ = "CheckAlertsPriorityHistogram"
scout_datareview_api_CheckAlertsPriorityHistogram.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsStatusHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramStatusBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramStatusBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramStatusBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsStatusHistogram.__name__ = "CheckAlertsStatusHistogram"
scout_datareview_api_CheckAlertsStatusHistogram.__qualname__ = "CheckAlertsStatusHistogram"
scout_datareview_api_CheckAlertsStatusHistogram.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckAlertsUnstackedHistogram(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'buckets': ConjureFieldDefinition('buckets', List[scout_datareview_api_HistogramBucket])
        }

    __slots__: List[str] = ['_buckets']

    def __init__(self, buckets: List["scout_datareview_api_HistogramBucket"]) -> None:
        self._buckets = buckets

    @builtins.property
    def buckets(self) -> List["scout_datareview_api_HistogramBucket"]:
        return self._buckets


scout_datareview_api_CheckAlertsUnstackedHistogram.__name__ = "CheckAlertsUnstackedHistogram"
scout_datareview_api_CheckAlertsUnstackedHistogram.__qualname__ = "CheckAlertsUnstackedHistogram"
scout_datareview_api_CheckAlertsUnstackedHistogram.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckEvaluation(ConjureUnionType):
    _automatic_check: Optional["scout_datareview_api_AutomaticCheckEvaluation"] = None
    _manual_check: Optional["scout_datareview_api_ManualCheckEvaluation"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'automatic_check': ConjureFieldDefinition('automaticCheck', scout_datareview_api_AutomaticCheckEvaluation),
            'manual_check': ConjureFieldDefinition('manualCheck', scout_datareview_api_ManualCheckEvaluation)
        }

    def __init__(
            self,
            automatic_check: Optional["scout_datareview_api_AutomaticCheckEvaluation"] = None,
            manual_check: Optional["scout_datareview_api_ManualCheckEvaluation"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (automatic_check is not None) + (manual_check is not None) != 1:
                raise ValueError('a union must contain a single member')

            if automatic_check is not None:
                self._automatic_check = automatic_check
                self._type = 'automaticCheck'
            if manual_check is not None:
                self._manual_check = manual_check
                self._type = 'manualCheck'

        elif type_of_union == 'automaticCheck':
            if automatic_check is None:
                raise ValueError('a union value must not be None')
            self._automatic_check = automatic_check
            self._type = 'automaticCheck'
        elif type_of_union == 'manualCheck':
            if manual_check is None:
                raise ValueError('a union value must not be None')
            self._manual_check = manual_check
            self._type = 'manualCheck'

    @builtins.property
    def automatic_check(self) -> Optional["scout_datareview_api_AutomaticCheckEvaluation"]:
        return self._automatic_check

    @builtins.property
    def manual_check(self) -> Optional["scout_datareview_api_ManualCheckEvaluation"]:
        return self._manual_check

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CheckEvaluationVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CheckEvaluationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'automaticCheck' and self.automatic_check is not None:
            return visitor._automatic_check(self.automatic_check)
        if self._type == 'manualCheck' and self.manual_check is not None:
            return visitor._manual_check(self.manual_check)


scout_datareview_api_CheckEvaluation.__name__ = "CheckEvaluation"
scout_datareview_api_CheckEvaluation.__qualname__ = "CheckEvaluation"
scout_datareview_api_CheckEvaluation.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CheckEvaluationVisitor:

    @abstractmethod
    def _automatic_check(self, automatic_check: "scout_datareview_api_AutomaticCheckEvaluation") -> Any:
        pass

    @abstractmethod
    def _manual_check(self, manual_check: "scout_datareview_api_ManualCheckEvaluation") -> Any:
        pass


scout_datareview_api_CheckEvaluationVisitor.__name__ = "CheckEvaluationVisitor"
scout_datareview_api_CheckEvaluationVisitor.__qualname__ = "CheckEvaluationVisitor"
scout_datareview_api_CheckEvaluationVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ChecklistEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist': ConjureFieldDefinition('checklist', scout_checks_api_PinnedChecklistRef),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'checks': ConjureFieldDefinition('checks', List[scout_datareview_api_CheckEvaluation])
        }

    __slots__: List[str] = ['_checklist', '_data_review_rid', '_checks']

    def __init__(self, checklist: "scout_checks_api_PinnedChecklistRef", checks: List["scout_datareview_api_CheckEvaluation"], data_review_rid: str) -> None:
        self._checklist = checklist
        self._data_review_rid = data_review_rid
        self._checks = checks

    @builtins.property
    def checklist(self) -> "scout_checks_api_PinnedChecklistRef":
        return self._checklist

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def checks(self) -> List["scout_datareview_api_CheckEvaluation"]:
        return self._checks


scout_datareview_api_ChecklistEvaluation.__name__ = "ChecklistEvaluation"
scout_datareview_api_ChecklistEvaluation.__qualname__ = "ChecklistEvaluation"
scout_datareview_api_ChecklistEvaluation.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseAction(ConjureUnionType):
    _close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_with_ignore': ConjureFieldDefinition('closeWithIgnore', scout_datareview_api_CloseWithIgnoreAlert),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction)
        }

    def __init__(
            self,
            close_with_ignore: Optional["scout_datareview_api_CloseWithIgnoreAlert"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_with_ignore is not None) + (close_with_further_action is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_with_ignore is not None:
                self._close_with_ignore = close_with_ignore
                self._type = 'closeWithIgnore'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'

        elif type_of_union == 'closeWithIgnore':
            if close_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._close_with_ignore = close_with_ignore
            self._type = 'closeWithIgnore'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'

    @builtins.property
    def close_with_ignore(self) -> Optional["scout_datareview_api_CloseWithIgnoreAlert"]:
        return self._close_with_ignore

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CloseActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CloseActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeWithIgnore' and self.close_with_ignore is not None:
            return visitor._close_with_ignore(self.close_with_ignore)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)


scout_datareview_api_CloseAction.__name__ = "CloseAction"
scout_datareview_api_CloseAction.__qualname__ = "CloseAction"
scout_datareview_api_CloseAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseActionVisitor:

    @abstractmethod
    def _close_with_ignore(self, close_with_ignore: "scout_datareview_api_CloseWithIgnoreAlert") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass


scout_datareview_api_CloseActionVisitor.__name__ = "CloseActionVisitor"
scout_datareview_api_CloseActionVisitor.__qualname__ = "CloseActionVisitor"
scout_datareview_api_CloseActionVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseAllLinkedAlerts(ConjureBeanType):
    """Close all alerts associated with the same notebook with the same comment.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAllLinkedAlerts.__name__ = "CloseAllLinkedAlerts"
scout_datareview_api_CloseAllLinkedAlerts.__qualname__ = "CloseAllLinkedAlerts"
scout_datareview_api_CloseAllLinkedAlerts.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseAndDetachFromNotebook(ConjureBeanType):
    """Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, those alerts will maintain the reference to the notebook and the notebook will remain unlocked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAndDetachFromNotebook.__name__ = "CloseAndDetachFromNotebook"
scout_datareview_api_CloseAndDetachFromNotebook.__qualname__ = "CloseAndDetachFromNotebook"
scout_datareview_api_CloseAndDetachFromNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook(ConjureBeanType):
    """Close the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be locked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__name__ = "CloseAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__qualname__ = "CloseAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseAndLinkToNotebook(ConjureBeanType):
    """Close the alert and link to notebook. Throws if the associated notebook has open alerts.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_action': ConjureFieldDefinition('closeAction', scout_datareview_api_CloseAction)
        }

    __slots__: List[str] = ['_close_action']

    def __init__(self, close_action: "scout_datareview_api_CloseAction") -> None:
        self._close_action = close_action

    @builtins.property
    def close_action(self) -> "scout_datareview_api_CloseAction":
        return self._close_action


scout_datareview_api_CloseAndLinkToNotebook.__name__ = "CloseAndLinkToNotebook"
scout_datareview_api_CloseAndLinkToNotebook.__qualname__ = "CloseAndLinkToNotebook"
scout_datareview_api_CloseAndLinkToNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseStrategy(ConjureUnionType):
    _close_all_linked_alerts: Optional["scout_datareview_api_CloseAllLinkedAlerts"] = None
    _close_and_detach_from_notebook: Optional["scout_datareview_api_CloseAndDetachFromNotebook"] = None
    _close_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'close_all_linked_alerts': ConjureFieldDefinition('closeAllLinkedAlerts', scout_datareview_api_CloseAllLinkedAlerts),
            'close_and_detach_from_notebook': ConjureFieldDefinition('closeAndDetachFromNotebook', scout_datareview_api_CloseAndDetachFromNotebook),
            'close_and_duplicate_previously_linked_notebook': ConjureFieldDefinition('closeAndDuplicatePreviouslyLinkedNotebook', scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook)
        }

    def __init__(
            self,
            close_all_linked_alerts: Optional["scout_datareview_api_CloseAllLinkedAlerts"] = None,
            close_and_detach_from_notebook: Optional["scout_datareview_api_CloseAndDetachFromNotebook"] = None,
            close_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (close_all_linked_alerts is not None) + (close_and_detach_from_notebook is not None) + (close_and_duplicate_previously_linked_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if close_all_linked_alerts is not None:
                self._close_all_linked_alerts = close_all_linked_alerts
                self._type = 'closeAllLinkedAlerts'
            if close_and_detach_from_notebook is not None:
                self._close_and_detach_from_notebook = close_and_detach_from_notebook
                self._type = 'closeAndDetachFromNotebook'
            if close_and_duplicate_previously_linked_notebook is not None:
                self._close_and_duplicate_previously_linked_notebook = close_and_duplicate_previously_linked_notebook
                self._type = 'closeAndDuplicatePreviouslyLinkedNotebook'

        elif type_of_union == 'closeAllLinkedAlerts':
            if close_all_linked_alerts is None:
                raise ValueError('a union value must not be None')
            self._close_all_linked_alerts = close_all_linked_alerts
            self._type = 'closeAllLinkedAlerts'
        elif type_of_union == 'closeAndDetachFromNotebook':
            if close_and_detach_from_notebook is None:
                raise ValueError('a union value must not be None')
            self._close_and_detach_from_notebook = close_and_detach_from_notebook
            self._type = 'closeAndDetachFromNotebook'
        elif type_of_union == 'closeAndDuplicatePreviouslyLinkedNotebook':
            if close_and_duplicate_previously_linked_notebook is None:
                raise ValueError('a union value must not be None')
            self._close_and_duplicate_previously_linked_notebook = close_and_duplicate_previously_linked_notebook
            self._type = 'closeAndDuplicatePreviouslyLinkedNotebook'

    @builtins.property
    def close_all_linked_alerts(self) -> Optional["scout_datareview_api_CloseAllLinkedAlerts"]:
        return self._close_all_linked_alerts

    @builtins.property
    def close_and_detach_from_notebook(self) -> Optional["scout_datareview_api_CloseAndDetachFromNotebook"]:
        return self._close_and_detach_from_notebook

    @builtins.property
    def close_and_duplicate_previously_linked_notebook(self) -> Optional["scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook"]:
        return self._close_and_duplicate_previously_linked_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_CloseStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_CloseStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'closeAllLinkedAlerts' and self.close_all_linked_alerts is not None:
            return visitor._close_all_linked_alerts(self.close_all_linked_alerts)
        if self._type == 'closeAndDetachFromNotebook' and self.close_and_detach_from_notebook is not None:
            return visitor._close_and_detach_from_notebook(self.close_and_detach_from_notebook)
        if self._type == 'closeAndDuplicatePreviouslyLinkedNotebook' and self.close_and_duplicate_previously_linked_notebook is not None:
            return visitor._close_and_duplicate_previously_linked_notebook(self.close_and_duplicate_previously_linked_notebook)


scout_datareview_api_CloseStrategy.__name__ = "CloseStrategy"
scout_datareview_api_CloseStrategy.__qualname__ = "CloseStrategy"
scout_datareview_api_CloseStrategy.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseStrategyVisitor:

    @abstractmethod
    def _close_all_linked_alerts(self, close_all_linked_alerts: "scout_datareview_api_CloseAllLinkedAlerts") -> Any:
        pass

    @abstractmethod
    def _close_and_detach_from_notebook(self, close_and_detach_from_notebook: "scout_datareview_api_CloseAndDetachFromNotebook") -> Any:
        pass

    @abstractmethod
    def _close_and_duplicate_previously_linked_notebook(self, close_and_duplicate_previously_linked_notebook: "scout_datareview_api_CloseAndDuplicatePreviouslyLinkedNotebook") -> Any:
        pass


scout_datareview_api_CloseStrategyVisitor.__name__ = "CloseStrategyVisitor"
scout_datareview_api_CloseStrategyVisitor.__qualname__ = "CloseStrategyVisitor"
scout_datareview_api_CloseStrategyVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseWithFurtherAction(ConjureBeanType):
    """Close the alert with further action. If the alert is linked to the same notebook as other alerts, the other 
alerts will also be closed with further action. This will also lock the associated notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_CloseStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_CloseStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_CloseStrategy"]:
        """Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not 
provided, the alert will be closed naively and throw if it leaves a linked notebook in an invalid state.
        """
        return self._strategy


scout_datareview_api_CloseWithFurtherAction.__name__ = "CloseWithFurtherAction"
scout_datareview_api_CloseWithFurtherAction.__qualname__ = "CloseWithFurtherAction"
scout_datareview_api_CloseWithFurtherAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CloseWithIgnoreAlert(ConjureBeanType):
    """Close the alert with ignore. If the alert is linked to the same notebook as other alerts, the other 
alerts will also be closed with ignore. This will also lock the associated notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_CloseStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_CloseStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_CloseStrategy"]:
        """Defines the strategy for closing the alert and any alerts linked via an associated notebook. If not 
provided, the default strategy is closeAllLinkedAlerts.
        """
        return self._strategy


scout_datareview_api_CloseWithIgnoreAlert.__name__ = "CloseWithIgnoreAlert"
scout_datareview_api_CloseWithIgnoreAlert.__qualname__ = "CloseWithIgnoreAlert"
scout_datareview_api_CloseWithIgnoreAlert.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ClosedWithFurtherActionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_ClosedWithFurtherActionState.__name__ = "ClosedWithFurtherActionState"
scout_datareview_api_ClosedWithFurtherActionState.__qualname__ = "ClosedWithFurtherActionState"
scout_datareview_api_ClosedWithFurtherActionState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_CreateDataReviewRequest(ConjureBeanType):
    """If commit not is provided, the latest commit on main will be used.
Asset RID is required only for multi-asset runs.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'asset_rid': ConjureFieldDefinition('assetRid', OptionalTypeWrapper[scout_rids_api_AssetRid]),
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'commit': ConjureFieldDefinition('commit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_run_rid', '_asset_rid', '_checklist_rid', '_commit']

    def __init__(self, checklist_rid: str, run_rid: str, asset_rid: Optional[str] = None, commit: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._asset_rid = asset_rid
        self._checklist_rid = checklist_rid
        self._commit = commit

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> Optional[str]:
        """Selects asset to execute data review on. Required for multi-asset runs.
        """
        return self._asset_rid

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def commit(self) -> Optional[str]:
        return self._commit


scout_datareview_api_CreateDataReviewRequest.__name__ = "CreateDataReviewRequest"
scout_datareview_api_CreateDataReviewRequest.__qualname__ = "CreateDataReviewRequest"
scout_datareview_api_CreateDataReviewRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DataReview(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_DataReviewRid),
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'checklist': ConjureFieldDefinition('checklist', OptionalTypeWrapper[scout_datareview_api_ChecklistEvaluation]),
            'checklist_ref': ConjureFieldDefinition('checklistRef', scout_checks_api_PinnedChecklistRef),
            'check_evaluations': ConjureFieldDefinition('checkEvaluations', List[scout_datareview_api_AutomaticCheckEvaluation]),
            'archived': ConjureFieldDefinition('archived', bool)
        }

    __slots__: List[str] = ['_rid', '_run_rid', '_asset_rid', '_created_at', '_created_by', '_checklist', '_checklist_ref', '_check_evaluations', '_archived']

    def __init__(self, archived: bool, asset_rid: str, check_evaluations: List["scout_datareview_api_AutomaticCheckEvaluation"], checklist_ref: "scout_checks_api_PinnedChecklistRef", created_at: str, created_by: str, rid: str, run_rid: str, checklist: Optional["scout_datareview_api_ChecklistEvaluation"] = None) -> None:
        self._rid = rid
        self._run_rid = run_rid
        self._asset_rid = asset_rid
        self._created_at = created_at
        self._created_by = created_by
        self._checklist = checklist
        self._checklist_ref = checklist_ref
        self._check_evaluations = check_evaluations
        self._archived = archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def run_rid(self) -> str:
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def checklist(self) -> Optional["scout_datareview_api_ChecklistEvaluation"]:
        return self._checklist

    @builtins.property
    def checklist_ref(self) -> "scout_checks_api_PinnedChecklistRef":
        return self._checklist_ref

    @builtins.property
    def check_evaluations(self) -> List["scout_datareview_api_AutomaticCheckEvaluation"]:
        return self._check_evaluations

    @builtins.property
    def archived(self) -> bool:
        return self._archived


scout_datareview_api_DataReview.__name__ = "DataReview"
scout_datareview_api_DataReview.__qualname__ = "DataReview"
scout_datareview_api_DataReview.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DataReviewCheckMetricsScope(ConjureUnionType):
    _run_rid: Optional[str] = None
    _asset_rid: Optional[str] = None
    _data_review_rid: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid)
        }

    def __init__(
            self,
            run_rid: Optional[str] = None,
            asset_rid: Optional[str] = None,
            data_review_rid: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (run_rid is not None) + (asset_rid is not None) + (data_review_rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if run_rid is not None:
                self._run_rid = run_rid
                self._type = 'runRid'
            if asset_rid is not None:
                self._asset_rid = asset_rid
                self._type = 'assetRid'
            if data_review_rid is not None:
                self._data_review_rid = data_review_rid
                self._type = 'dataReviewRid'

        elif type_of_union == 'runRid':
            if run_rid is None:
                raise ValueError('a union value must not be None')
            self._run_rid = run_rid
            self._type = 'runRid'
        elif type_of_union == 'assetRid':
            if asset_rid is None:
                raise ValueError('a union value must not be None')
            self._asset_rid = asset_rid
            self._type = 'assetRid'
        elif type_of_union == 'dataReviewRid':
            if data_review_rid is None:
                raise ValueError('a union value must not be None')
            self._data_review_rid = data_review_rid
            self._type = 'dataReviewRid'

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def asset_rid(self) -> Optional[str]:
        return self._asset_rid

    @builtins.property
    def data_review_rid(self) -> Optional[str]:
        return self._data_review_rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_DataReviewCheckMetricsScopeVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_DataReviewCheckMetricsScopeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'runRid' and self.run_rid is not None:
            return visitor._run_rid(self.run_rid)
        if self._type == 'assetRid' and self.asset_rid is not None:
            return visitor._asset_rid(self.asset_rid)
        if self._type == 'dataReviewRid' and self.data_review_rid is not None:
            return visitor._data_review_rid(self.data_review_rid)


scout_datareview_api_DataReviewCheckMetricsScope.__name__ = "DataReviewCheckMetricsScope"
scout_datareview_api_DataReviewCheckMetricsScope.__qualname__ = "DataReviewCheckMetricsScope"
scout_datareview_api_DataReviewCheckMetricsScope.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DataReviewCheckMetricsScopeVisitor:

    @abstractmethod
    def _run_rid(self, run_rid: str) -> Any:
        pass

    @abstractmethod
    def _asset_rid(self, asset_rid: str) -> Any:
        pass

    @abstractmethod
    def _data_review_rid(self, data_review_rid: str) -> Any:
        pass


scout_datareview_api_DataReviewCheckMetricsScopeVisitor.__name__ = "DataReviewCheckMetricsScopeVisitor"
scout_datareview_api_DataReviewCheckMetricsScopeVisitor.__qualname__ = "DataReviewCheckMetricsScopeVisitor"
scout_datareview_api_DataReviewCheckMetricsScopeVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DataReviewPage(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_reviews': ConjureFieldDefinition('dataReviews', List[scout_datareview_api_DataReview]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_data_reviews', '_next_page_token']

    def __init__(self, data_reviews: List["scout_datareview_api_DataReview"], next_page_token: Optional[str] = None) -> None:
        self._data_reviews = data_reviews
        self._next_page_token = next_page_token

    @builtins.property
    def data_reviews(self) -> List["scout_datareview_api_DataReview"]:
        return self._data_reviews

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_datareview_api_DataReviewPage.__name__ = "DataReviewPage"
scout_datareview_api_DataReviewPage.__qualname__ = "DataReviewPage"
scout_datareview_api_DataReviewPage.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DataReviewService(Service):
    """The data review service manages the evaluation, disposition, and historical record of checks alerts.
    """

    def batch_initiate(self, auth_header: str, request: "scout_datareview_api_BatchInitiateDataReviewRequest") -> "scout_datareview_api_BatchInitiateDataReviewResponse":
        """For each request, initiates data review for the requested run and checklist and executes 
the automatic checks against the run.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/batch-initiate'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchInitiateDataReviewResponse, self._return_none_for_unknown_union_types)

    def rerun_failed_automatic_checks(self, auth_header: str, request: "scout_datareview_api_RerunFailedAutomaticChecksRequest") -> None:
        """Re-executes the most recent failed automatic checks for the data review.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/rerun-failed-automatic-checks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def find_data_reviews(self, auth_header: str, request: "scout_datareview_api_FindDataReviewsRequest") -> "scout_datareview_api_DataReviewPage":
        """Returns the data reviews under the provided search parameters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_DataReviewPage, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, data_review_rid: str) -> "scout_datareview_api_DataReview":
        """Throws if not found.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataReviewRid': quote(str(_conjure_encoder.default(data_review_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_DataReview, self._return_none_for_unknown_union_types)

    def get_check_alert(self, auth_header: str, check_alert_rid: str) -> "scout_datareview_api_CheckAlert":
        """Throws if not found.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checkAlertRid': quote(str(_conjure_encoder.default(check_alert_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlert, self._return_none_for_unknown_union_types)

    def get_check_alerts_for_data_review(self, auth_header: str, data_review_rid: str) -> List["scout_datareview_api_CheckAlert"]:
        """Gets all check alerts from the provided data review.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataReviewRid': quote(str(_conjure_encoder.default(data_review_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}/check-alerts'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datareview_api_CheckAlert], self._return_none_for_unknown_union_types)

    def get_check_alerts_histogram(self, auth_header: str, request: "scout_datareview_api_CheckAlertsHistogramRequest") -> "scout_datareview_api_CheckAlertsHistogramResponse":
        """Returns a histogram of alerts that occur across the provided runs or assets. At least one run or asset must be specified.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/check-alerts/histogram'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlertsHistogramResponse, self._return_none_for_unknown_union_types)

    def search_check_alerts(self, auth_header: str, request: "scout_datareview_api_SearchCheckAlertsRequest") -> "scout_datareview_api_SearchCheckAlertsResponse":
        """Returns the check alerts under the provided search parameters. At least one run or asset must be specified.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/check-alerts'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_SearchCheckAlertsResponse, self._return_none_for_unknown_union_types)

    def get_check_alert_action_log(self, auth_header: str, check_alert_rid: str) -> "scout_datareview_api_CheckAlertActionLog":
        """Returns a record of the historical actions taken on the provided check alert.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checkAlertRid': quote(str(_conjure_encoder.default(check_alert_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlertActionLog, self._return_none_for_unknown_union_types)

    def get_check_alert_counts_for_notebooks(self, auth_header: str, rids: List[str] = None) -> Dict[str, int]:
        """Returns the number of alerts attached to each provided notebook.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v2/data-review/get-check-alert-counts-for-notebooks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_NotebookRid, int], self._return_none_for_unknown_union_types)

    def get_check_alert_status_for_notebooks(self, auth_header: str, rids: List[str] = None) -> Dict[str, Optional["scout_datareview_api_CheckAlertStatus"]]:
        """Returns the check alert status of any linked violations for the provided notebooks. If none exist, an empty
optional is returned.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v2/data-review/get-check-alert-status-for-notebooks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[scout_rids_api_NotebookRid, OptionalTypeWrapper[scout_datareview_api_CheckAlertStatus]], self._return_none_for_unknown_union_types)

    def perform_check_alert_action(self, auth_header: str, check_alert_rid: str, request: "scout_datareview_api_CheckAlertAction") -> "scout_datareview_api_CheckAlert":
        """Applies a check alert action to the specified check alert RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'checkAlertRid': quote(str(_conjure_encoder.default(check_alert_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/check-alerts/{checkAlertRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_CheckAlert, self._return_none_for_unknown_union_types)

    def batch_perform_check_alert_action(self, auth_header: str, request: "scout_datareview_api_BatchCheckAlertActionRequest") -> "scout_datareview_api_BatchCheckAlertActionResponse":
        """Applies a check alert action to the specified check alert RIDs. If any of the check actions fail,
then none of the check actions will be applied.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/check-alerts/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchCheckAlertActionResponse, self._return_none_for_unknown_union_types)

    def batch_perform_automatic_check_evaluation_review_action(self, auth_header: str, request: "scout_datareview_api_BatchAutomaticCheckEvaluationActionRequest") -> "scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse":
        """Applies an action to the specified check evaluation RIDs. If any of the check actions fail,
then none of the actions will be applied.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/automatic-check-evaluation/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_BatchAutomaticCheckEvaluationActionResponse, self._return_none_for_unknown_union_types)

    def get_automatic_check_evaluation_action_log(self, auth_header: str, rid: str) -> "scout_datareview_api_AutomaticCheckEvaluationActionLog":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/automatic-check-evaluation/{rid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_AutomaticCheckEvaluationActionLog, self._return_none_for_unknown_union_types)

    def batch_perform_manual_check_alert_action(self, auth_header: str, request: "scout_datareview_api_BatchManualCheckEvaluationActionRequest") -> None:
        """Applies an action to the specified check evaluation RIDs. If any of the check actions fail,
then none of the actions will be applied.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/manual-check-evaluation/batch-perform-action'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_manual_check_evaluation_action_log(self, auth_header: str, rid: str) -> "scout_datareview_api_ManualCheckEvaluationActionLog":
        """Returns a record of the historical manual actions taken on the provided check evaluation.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/manual-check-evaluation/{rid}/action-log'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_ManualCheckEvaluationActionLog, self._return_none_for_unknown_union_types)

    def archive_data_review(self, auth_header: str, data_review_rid: str) -> bool:
        """Archives the data review with the given rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataReviewRid': quote(str(_conjure_encoder.default(data_review_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/{dataReviewRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def batch_archive_data_review(self, auth_header: str, rids: List[str] = None) -> None:
        """Batch archives the data reviews with the given rids.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/scout/v2/data-review/batch-archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_data_review(self, auth_header: str, data_review_rid: str) -> None:
        """Unarchives the data review with the given rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataReviewRid': quote(str(_conjure_encoder.default(data_review_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/data-review/unarchive/{dataReviewRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_data_review_check_metrics(self, auth_header: str, request: "scout_datareview_api_GetDataReviewCheckMetricsRequest") -> "scout_datareview_api_GetDataReviewCheckMetricsResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/data-review/data-review-check-metrics'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datareview_api_GetDataReviewCheckMetricsResponse, self._return_none_for_unknown_union_types)


scout_datareview_api_DataReviewService.__name__ = "DataReviewService"
scout_datareview_api_DataReviewService.__qualname__ = "DataReviewService"
scout_datareview_api_DataReviewService.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_DuplicateAndLinkNotebook(ConjureBeanType):
    """Duplicate the notebook and link the alert to it.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_DuplicateAndLinkNotebook.__name__ = "DuplicateAndLinkNotebook"
scout_datareview_api_DuplicateAndLinkNotebook.__qualname__ = "DuplicateAndLinkNotebook"
scout_datareview_api_DuplicateAndLinkNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ExecutingState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_ExecutingState.__name__ = "ExecutingState"
scout_datareview_api_ExecutingState.__qualname__ = "ExecutingState"
scout_datareview_api_ExecutingState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ExecutionRetriggered(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_ExecutionRetriggered.__name__ = "ExecutionRetriggered"
scout_datareview_api_ExecutionRetriggered.__qualname__ = "ExecutionRetriggered"
scout_datareview_api_ExecutionRetriggered.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_FailedToExecuteState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid),
            'review_state': ConjureFieldDefinition('reviewState', OptionalTypeWrapper[scout_rids_api_CheckAlertState]),
            'review_notes': ConjureFieldDefinition('reviewNotes', OptionalTypeWrapper[str]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_job_rid', '_review_state', '_review_notes', '_assignee_rids']

    def __init__(self, assignee_rids: List[str], job_rid: str, review_notes: Optional[str] = None, review_state: Optional["scout_rids_api_CheckAlertState"] = None) -> None:
        self._job_rid = job_rid
        self._review_state = review_state
        self._review_notes = review_notes
        self._assignee_rids = assignee_rids

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid

    @builtins.property
    def review_state(self) -> Optional["scout_rids_api_CheckAlertState"]:
        return self._review_state

    @builtins.property
    def review_notes(self) -> Optional[str]:
        return self._review_notes

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids


scout_datareview_api_FailedToExecuteState.__name__ = "FailedToExecuteState"
scout_datareview_api_FailedToExecuteState.__qualname__ = "FailedToExecuteState"
scout_datareview_api_FailedToExecuteState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_FindDataReviewsRequest(ConjureBeanType):
    """If both sets are empty, an empty page is returned.
If one set is empty, that field is not considered for filtering (like a wildcard).
If commitId is omitted from a ChecklistRef, it will match all commits.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid]),
            'filter_by_both_runs_and_assets': ConjureFieldDefinition('filterByBothRunsAndAssets', OptionalTypeWrapper[bool]),
            'checklist_refs': ConjureFieldDefinition('checklistRefs', List[scout_checks_api_ChecklistRef]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_run_rids', '_asset_rids', '_filter_by_both_runs_and_assets', '_checklist_refs', '_next_page_token', '_page_size', '_show_archived', '_archived_statuses']

    def __init__(self, asset_rids: List[str], checklist_refs: List["scout_checks_api_ChecklistRef"], run_rids: List[str], archived_statuses: Optional[List["api_ArchivedStatus"]] = None, filter_by_both_runs_and_assets: Optional[bool] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None, show_archived: Optional[bool] = None) -> None:
        self._run_rids = run_rids
        self._asset_rids = asset_rids
        self._filter_by_both_runs_and_assets = filter_by_both_runs_and_assets
        self._checklist_refs = checklist_refs
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._show_archived = show_archived
        self._archived_statuses = archived_statuses

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def asset_rids(self) -> List[str]:
        return self._asset_rids

    @builtins.property
    def filter_by_both_runs_and_assets(self) -> Optional[bool]:
        """If true, results are filtered to data reviews w/ both run and asset in the requested runs/assets.
Defaults to false, where assets are converted to runs and all data reviews under the linked runs
(including data reviews on other assets sharing the parent run) will be returned.
It is recommended to set this to true and pass in asset RIDs for multi-asset runs.
Toggling this option has no effect if no asset RIDs are supplied.
        """
        return self._filter_by_both_runs_and_assets

    @builtins.property
    def checklist_refs(self) -> List["scout_checks_api_ChecklistRef"]:
        return self._checklist_refs

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 1000. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """To be deprecated. Use archivedStatuses instead. Allows for inclusion of archived data reviews 
in search results alongside non-archived ones. Defaults to false if not specified.
        """
        return self._show_archived

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Filters search on data reviews based on the archived statuses provided. 
Default is NOT_ARCHIVED only if none are provided.
        """
        return self._archived_statuses


scout_datareview_api_FindDataReviewsRequest.__name__ = "FindDataReviewsRequest"
scout_datareview_api_FindDataReviewsRequest.__qualname__ = "FindDataReviewsRequest"
scout_datareview_api_FindDataReviewsRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_GeneratedAlertsState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', OptionalTypeWrapper[List[scout_rids_api_CheckAlertRid]]),
            'event_rids': ConjureFieldDefinition('eventRids', List[api_rids_EventRid])
        }

    __slots__: List[str] = ['_rids', '_event_rids']

    def __init__(self, event_rids: List[str], rids: Optional[List[str]] = None) -> None:
        self._rids = rids
        self._event_rids = event_rids

    @builtins.property
    def rids(self) -> Optional[List[str]]:
        return self._rids

    @builtins.property
    def event_rids(self) -> List[str]:
        return self._event_rids


scout_datareview_api_GeneratedAlertsState.__name__ = "GeneratedAlertsState"
scout_datareview_api_GeneratedAlertsState.__qualname__ = "GeneratedAlertsState"
scout_datareview_api_GeneratedAlertsState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_GetDataReviewCheckMetricsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'scope': ConjureFieldDefinition('scope', scout_datareview_api_DataReviewCheckMetricsScope)
        }

    __slots__: List[str] = ['_scope']

    def __init__(self, scope: "scout_datareview_api_DataReviewCheckMetricsScope") -> None:
        self._scope = scope

    @builtins.property
    def scope(self) -> "scout_datareview_api_DataReviewCheckMetricsScope":
        return self._scope


scout_datareview_api_GetDataReviewCheckMetricsRequest.__name__ = "GetDataReviewCheckMetricsRequest"
scout_datareview_api_GetDataReviewCheckMetricsRequest.__qualname__ = "GetDataReviewCheckMetricsRequest"
scout_datareview_api_GetDataReviewCheckMetricsRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_GetDataReviewCheckMetricsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checks_pending_execution': ConjureFieldDefinition('checksPendingExecution', int),
            'checks_executing': ConjureFieldDefinition('checksExecuting', int),
            'checks_passed': ConjureFieldDefinition('checksPassed', int),
            'checks_with_events_pending_review': ConjureFieldDefinition('checksWithEventsPendingReview', int),
            'checks_with_events_closed_with_ignore': ConjureFieldDefinition('checksWithEventsClosedWithIgnore', int),
            'checks_with_events_closed_with_further_action': ConjureFieldDefinition('checksWithEventsClosedWithFurtherAction', int),
            'checks_with_events': ConjureFieldDefinition('checksWithEvents', int),
            'checks_with_too_many_events': ConjureFieldDefinition('checksWithTooManyEvents', int),
            'checks_failed_to_execute_pending_review': ConjureFieldDefinition('checksFailedToExecutePendingReview', int),
            'checks_failed_to_execute_closed_with_ignore': ConjureFieldDefinition('checksFailedToExecuteClosedWithIgnore', int),
            'checks_failed_to_execute_closed_with_further_action': ConjureFieldDefinition('checksFailedToExecuteClosedWithFurtherAction', int),
            'checks_failed_to_execute': ConjureFieldDefinition('checksFailedToExecute', int),
            'checks_executed': ConjureFieldDefinition('checksExecuted', int),
            'checks_total': ConjureFieldDefinition('checksTotal', int),
            'events_pending_review': ConjureFieldDefinition('eventsPendingReview', int),
            'events_closed_with_ignore': ConjureFieldDefinition('eventsClosedWithIgnore', int),
            'events_closed_with_further_action': ConjureFieldDefinition('eventsClosedWithFurtherAction', int),
            'events_total': ConjureFieldDefinition('eventsTotal', int)
        }

    __slots__: List[str] = ['_checks_pending_execution', '_checks_executing', '_checks_passed', '_checks_with_events_pending_review', '_checks_with_events_closed_with_ignore', '_checks_with_events_closed_with_further_action', '_checks_with_events', '_checks_with_too_many_events', '_checks_failed_to_execute_pending_review', '_checks_failed_to_execute_closed_with_ignore', '_checks_failed_to_execute_closed_with_further_action', '_checks_failed_to_execute', '_checks_executed', '_checks_total', '_events_pending_review', '_events_closed_with_ignore', '_events_closed_with_further_action', '_events_total']

    def __init__(self, checks_executed: int, checks_executing: int, checks_failed_to_execute: int, checks_failed_to_execute_closed_with_further_action: int, checks_failed_to_execute_closed_with_ignore: int, checks_failed_to_execute_pending_review: int, checks_passed: int, checks_pending_execution: int, checks_total: int, checks_with_events: int, checks_with_events_closed_with_further_action: int, checks_with_events_closed_with_ignore: int, checks_with_events_pending_review: int, checks_with_too_many_events: int, events_closed_with_further_action: int, events_closed_with_ignore: int, events_pending_review: int, events_total: int) -> None:
        self._checks_pending_execution = checks_pending_execution
        self._checks_executing = checks_executing
        self._checks_passed = checks_passed
        self._checks_with_events_pending_review = checks_with_events_pending_review
        self._checks_with_events_closed_with_ignore = checks_with_events_closed_with_ignore
        self._checks_with_events_closed_with_further_action = checks_with_events_closed_with_further_action
        self._checks_with_events = checks_with_events
        self._checks_with_too_many_events = checks_with_too_many_events
        self._checks_failed_to_execute_pending_review = checks_failed_to_execute_pending_review
        self._checks_failed_to_execute_closed_with_ignore = checks_failed_to_execute_closed_with_ignore
        self._checks_failed_to_execute_closed_with_further_action = checks_failed_to_execute_closed_with_further_action
        self._checks_failed_to_execute = checks_failed_to_execute
        self._checks_executed = checks_executed
        self._checks_total = checks_total
        self._events_pending_review = events_pending_review
        self._events_closed_with_ignore = events_closed_with_ignore
        self._events_closed_with_further_action = events_closed_with_further_action
        self._events_total = events_total

    @builtins.property
    def checks_pending_execution(self) -> int:
        return self._checks_pending_execution

    @builtins.property
    def checks_executing(self) -> int:
        return self._checks_executing

    @builtins.property
    def checks_passed(self) -> int:
        return self._checks_passed

    @builtins.property
    def checks_with_events_pending_review(self) -> int:
        return self._checks_with_events_pending_review

    @builtins.property
    def checks_with_events_closed_with_ignore(self) -> int:
        return self._checks_with_events_closed_with_ignore

    @builtins.property
    def checks_with_events_closed_with_further_action(self) -> int:
        return self._checks_with_events_closed_with_further_action

    @builtins.property
    def checks_with_events(self) -> int:
        return self._checks_with_events

    @builtins.property
    def checks_with_too_many_events(self) -> int:
        return self._checks_with_too_many_events

    @builtins.property
    def checks_failed_to_execute_pending_review(self) -> int:
        return self._checks_failed_to_execute_pending_review

    @builtins.property
    def checks_failed_to_execute_closed_with_ignore(self) -> int:
        return self._checks_failed_to_execute_closed_with_ignore

    @builtins.property
    def checks_failed_to_execute_closed_with_further_action(self) -> int:
        return self._checks_failed_to_execute_closed_with_further_action

    @builtins.property
    def checks_failed_to_execute(self) -> int:
        return self._checks_failed_to_execute

    @builtins.property
    def checks_executed(self) -> int:
        return self._checks_executed

    @builtins.property
    def checks_total(self) -> int:
        return self._checks_total

    @builtins.property
    def events_pending_review(self) -> int:
        return self._events_pending_review

    @builtins.property
    def events_closed_with_ignore(self) -> int:
        return self._events_closed_with_ignore

    @builtins.property
    def events_closed_with_further_action(self) -> int:
        return self._events_closed_with_further_action

    @builtins.property
    def events_total(self) -> int:
        return self._events_total


scout_datareview_api_GetDataReviewCheckMetricsResponse.__name__ = "GetDataReviewCheckMetricsResponse"
scout_datareview_api_GetDataReviewCheckMetricsResponse.__qualname__ = "GetDataReviewCheckMetricsResponse"
scout_datareview_api_GetDataReviewCheckMetricsResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_count']

    def __init__(self, count: int, end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._count = count

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def count(self) -> int:
        return self._count


scout_datareview_api_HistogramBucket.__name__ = "HistogramBucket"
scout_datareview_api_HistogramBucket.__qualname__ = "HistogramBucket"
scout_datareview_api_HistogramBucket.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramDistributionVariable(ConjureUnionType):
    _start_time: Optional["scout_datareview_api_HistogramStartTimeVariable"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', scout_datareview_api_HistogramStartTimeVariable)
        }

    def __init__(
            self,
            start_time: Optional["scout_datareview_api_HistogramStartTimeVariable"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (start_time is not None) != 1:
                raise ValueError('a union must contain a single member')

            if start_time is not None:
                self._start_time = start_time
                self._type = 'startTime'

        elif type_of_union == 'startTime':
            if start_time is None:
                raise ValueError('a union value must not be None')
            self._start_time = start_time
            self._type = 'startTime'

    @builtins.property
    def start_time(self) -> Optional["scout_datareview_api_HistogramStartTimeVariable"]:
        return self._start_time

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_HistogramDistributionVariableVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_HistogramDistributionVariableVisitor'.format(visitor.__class__.__name__))
        if self._type == 'startTime' and self.start_time is not None:
            return visitor._start_time(self.start_time)


scout_datareview_api_HistogramDistributionVariable.__name__ = "HistogramDistributionVariable"
scout_datareview_api_HistogramDistributionVariable.__qualname__ = "HistogramDistributionVariable"
scout_datareview_api_HistogramDistributionVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramDistributionVariableVisitor:

    @abstractmethod
    def _start_time(self, start_time: "scout_datareview_api_HistogramStartTimeVariable") -> Any:
        pass


scout_datareview_api_HistogramDistributionVariableVisitor.__name__ = "HistogramDistributionVariableVisitor"
scout_datareview_api_HistogramDistributionVariableVisitor.__qualname__ = "HistogramDistributionVariableVisitor"
scout_datareview_api_HistogramDistributionVariableVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramEndTimeVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramEndTimeVariable.__name__ = "HistogramEndTimeVariable"
scout_datareview_api_HistogramEndTimeVariable.__qualname__ = "HistogramEndTimeVariable"
scout_datareview_api_HistogramEndTimeVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramPriorityBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'counts': ConjureFieldDefinition('counts', Dict[scout_api_Priority, int])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_counts']

    def __init__(self, counts: Dict["scout_api_Priority", int], end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._counts = counts

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def counts(self) -> Dict["scout_api_Priority", int]:
        return self._counts


scout_datareview_api_HistogramPriorityBucket.__name__ = "HistogramPriorityBucket"
scout_datareview_api_HistogramPriorityBucket.__qualname__ = "HistogramPriorityBucket"
scout_datareview_api_HistogramPriorityBucket.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramPriorityVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramPriorityVariable.__name__ = "HistogramPriorityVariable"
scout_datareview_api_HistogramPriorityVariable.__qualname__ = "HistogramPriorityVariable"
scout_datareview_api_HistogramPriorityVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramStartTimeVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramStartTimeVariable.__name__ = "HistogramStartTimeVariable"
scout_datareview_api_HistogramStartTimeVariable.__qualname__ = "HistogramStartTimeVariable"
scout_datareview_api_HistogramStartTimeVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramStatusBucket(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_inclusive': ConjureFieldDefinition('startInclusive', api_Timestamp),
            'end_exclusive': ConjureFieldDefinition('endExclusive', api_Timestamp),
            'counts': ConjureFieldDefinition('counts', Dict[scout_datareview_api_CheckAlertStatus, int])
        }

    __slots__: List[str] = ['_start_inclusive', '_end_exclusive', '_counts']

    def __init__(self, counts: Dict["scout_datareview_api_CheckAlertStatus", int], end_exclusive: "api_Timestamp", start_inclusive: "api_Timestamp") -> None:
        self._start_inclusive = start_inclusive
        self._end_exclusive = end_exclusive
        self._counts = counts

    @builtins.property
    def start_inclusive(self) -> "api_Timestamp":
        return self._start_inclusive

    @builtins.property
    def end_exclusive(self) -> "api_Timestamp":
        return self._end_exclusive

    @builtins.property
    def counts(self) -> Dict["scout_datareview_api_CheckAlertStatus", int]:
        return self._counts


scout_datareview_api_HistogramStatusBucket.__name__ = "HistogramStatusBucket"
scout_datareview_api_HistogramStatusBucket.__qualname__ = "HistogramStatusBucket"
scout_datareview_api_HistogramStatusBucket.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramStatusVariable(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_HistogramStatusVariable.__name__ = "HistogramStatusVariable"
scout_datareview_api_HistogramStatusVariable.__qualname__ = "HistogramStatusVariable"
scout_datareview_api_HistogramStatusVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramSubGroupVariable(ConjureUnionType):
    _priority: Optional["scout_datareview_api_HistogramPriorityVariable"] = None
    _status: Optional["scout_datareview_api_HistogramStatusVariable"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'priority': ConjureFieldDefinition('priority', scout_datareview_api_HistogramPriorityVariable),
            'status': ConjureFieldDefinition('status', scout_datareview_api_HistogramStatusVariable)
        }

    def __init__(
            self,
            priority: Optional["scout_datareview_api_HistogramPriorityVariable"] = None,
            status: Optional["scout_datareview_api_HistogramStatusVariable"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (priority is not None) + (status is not None) != 1:
                raise ValueError('a union must contain a single member')

            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if status is not None:
                self._status = status
                self._type = 'status'

        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'status':
            if status is None:
                raise ValueError('a union value must not be None')
            self._status = status
            self._type = 'status'

    @builtins.property
    def priority(self) -> Optional["scout_datareview_api_HistogramPriorityVariable"]:
        return self._priority

    @builtins.property
    def status(self) -> Optional["scout_datareview_api_HistogramStatusVariable"]:
        return self._status

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_HistogramSubGroupVariableVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_HistogramSubGroupVariableVisitor'.format(visitor.__class__.__name__))
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'status' and self.status is not None:
            return visitor._status(self.status)


scout_datareview_api_HistogramSubGroupVariable.__name__ = "HistogramSubGroupVariable"
scout_datareview_api_HistogramSubGroupVariable.__qualname__ = "HistogramSubGroupVariable"
scout_datareview_api_HistogramSubGroupVariable.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_HistogramSubGroupVariableVisitor:

    @abstractmethod
    def _priority(self, priority: "scout_datareview_api_HistogramPriorityVariable") -> Any:
        pass

    @abstractmethod
    def _status(self, status: "scout_datareview_api_HistogramStatusVariable") -> Any:
        pass


scout_datareview_api_HistogramSubGroupVariableVisitor.__name__ = "HistogramSubGroupVariableVisitor"
scout_datareview_api_HistogramSubGroupVariableVisitor.__qualname__ = "HistogramSubGroupVariableVisitor"
scout_datareview_api_HistogramSubGroupVariableVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_LinkNotebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_LinkNotebookStrategy])
        }

    __slots__: List[str] = ['_rid', '_strategy']

    def __init__(self, rid: str, strategy: Optional["scout_datareview_api_LinkNotebookStrategy"] = None) -> None:
        self._rid = rid
        self._strategy = strategy

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_LinkNotebookStrategy"]:
        """Defines the strategy for reconciling the alert with any linked alerts via the associated notebook. If not
provided, the alert will be linked naively and throw if it leaves a linked notebook in an invalid state.
        """
        return self._strategy


scout_datareview_api_LinkNotebook.__name__ = "LinkNotebook"
scout_datareview_api_LinkNotebook.__qualname__ = "LinkNotebook"
scout_datareview_api_LinkNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_LinkNotebookStrategy(ConjureUnionType):
    _duplicate_and_link_to_new_notebook: Optional["scout_datareview_api_DuplicateAndLinkNotebook"] = None
    _close_and_link: Optional["scout_datareview_api_CloseAndLinkToNotebook"] = None
    _reopen_and_link: Optional["scout_datareview_api_ReopenAndLinkToNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duplicate_and_link_to_new_notebook': ConjureFieldDefinition('duplicateAndLinkToNewNotebook', scout_datareview_api_DuplicateAndLinkNotebook),
            'close_and_link': ConjureFieldDefinition('closeAndLink', scout_datareview_api_CloseAndLinkToNotebook),
            'reopen_and_link': ConjureFieldDefinition('reopenAndLink', scout_datareview_api_ReopenAndLinkToNotebook)
        }

    def __init__(
            self,
            duplicate_and_link_to_new_notebook: Optional["scout_datareview_api_DuplicateAndLinkNotebook"] = None,
            close_and_link: Optional["scout_datareview_api_CloseAndLinkToNotebook"] = None,
            reopen_and_link: Optional["scout_datareview_api_ReopenAndLinkToNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (duplicate_and_link_to_new_notebook is not None) + (close_and_link is not None) + (reopen_and_link is not None) != 1:
                raise ValueError('a union must contain a single member')

            if duplicate_and_link_to_new_notebook is not None:
                self._duplicate_and_link_to_new_notebook = duplicate_and_link_to_new_notebook
                self._type = 'duplicateAndLinkToNewNotebook'
            if close_and_link is not None:
                self._close_and_link = close_and_link
                self._type = 'closeAndLink'
            if reopen_and_link is not None:
                self._reopen_and_link = reopen_and_link
                self._type = 'reopenAndLink'

        elif type_of_union == 'duplicateAndLinkToNewNotebook':
            if duplicate_and_link_to_new_notebook is None:
                raise ValueError('a union value must not be None')
            self._duplicate_and_link_to_new_notebook = duplicate_and_link_to_new_notebook
            self._type = 'duplicateAndLinkToNewNotebook'
        elif type_of_union == 'closeAndLink':
            if close_and_link is None:
                raise ValueError('a union value must not be None')
            self._close_and_link = close_and_link
            self._type = 'closeAndLink'
        elif type_of_union == 'reopenAndLink':
            if reopen_and_link is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_link = reopen_and_link
            self._type = 'reopenAndLink'

    @builtins.property
    def duplicate_and_link_to_new_notebook(self) -> Optional["scout_datareview_api_DuplicateAndLinkNotebook"]:
        return self._duplicate_and_link_to_new_notebook

    @builtins.property
    def close_and_link(self) -> Optional["scout_datareview_api_CloseAndLinkToNotebook"]:
        return self._close_and_link

    @builtins.property
    def reopen_and_link(self) -> Optional["scout_datareview_api_ReopenAndLinkToNotebook"]:
        return self._reopen_and_link

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_LinkNotebookStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_LinkNotebookStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'duplicateAndLinkToNewNotebook' and self.duplicate_and_link_to_new_notebook is not None:
            return visitor._duplicate_and_link_to_new_notebook(self.duplicate_and_link_to_new_notebook)
        if self._type == 'closeAndLink' and self.close_and_link is not None:
            return visitor._close_and_link(self.close_and_link)
        if self._type == 'reopenAndLink' and self.reopen_and_link is not None:
            return visitor._reopen_and_link(self.reopen_and_link)


scout_datareview_api_LinkNotebookStrategy.__name__ = "LinkNotebookStrategy"
scout_datareview_api_LinkNotebookStrategy.__qualname__ = "LinkNotebookStrategy"
scout_datareview_api_LinkNotebookStrategy.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_LinkNotebookStrategyVisitor:

    @abstractmethod
    def _duplicate_and_link_to_new_notebook(self, duplicate_and_link_to_new_notebook: "scout_datareview_api_DuplicateAndLinkNotebook") -> Any:
        pass

    @abstractmethod
    def _close_and_link(self, close_and_link: "scout_datareview_api_CloseAndLinkToNotebook") -> Any:
        pass

    @abstractmethod
    def _reopen_and_link(self, reopen_and_link: "scout_datareview_api_ReopenAndLinkToNotebook") -> Any:
        pass


scout_datareview_api_LinkNotebookStrategyVisitor.__name__ = "LinkNotebookStrategyVisitor"
scout_datareview_api_LinkNotebookStrategyVisitor.__qualname__ = "LinkNotebookStrategyVisitor"
scout_datareview_api_LinkNotebookStrategyVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckAlertAction(ConjureUnionType):
    _pass_: Optional["scout_datareview_api_Pass"] = None
    _close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None
    _reopen: Optional["scout_datareview_api_Reopen"] = None
    _reassign: Optional["scout_datareview_api_Reassign"] = None
    _update_notes: Optional["scout_datareview_api_UpdateNotes"] = None
    _link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pass_': ConjureFieldDefinition('pass', scout_datareview_api_Pass),
            'close_with_further_action': ConjureFieldDefinition('closeWithFurtherAction', scout_datareview_api_CloseWithFurtherAction),
            'reopen': ConjureFieldDefinition('reopen', scout_datareview_api_Reopen),
            'reassign': ConjureFieldDefinition('reassign', scout_datareview_api_Reassign),
            'update_notes': ConjureFieldDefinition('updateNotes', scout_datareview_api_UpdateNotes),
            'link_notebook': ConjureFieldDefinition('linkNotebook', scout_datareview_api_LinkNotebook)
        }

    def __init__(
            self,
            pass_: Optional["scout_datareview_api_Pass"] = None,
            close_with_further_action: Optional["scout_datareview_api_CloseWithFurtherAction"] = None,
            reopen: Optional["scout_datareview_api_Reopen"] = None,
            reassign: Optional["scout_datareview_api_Reassign"] = None,
            update_notes: Optional["scout_datareview_api_UpdateNotes"] = None,
            link_notebook: Optional["scout_datareview_api_LinkNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pass_ is not None) + (close_with_further_action is not None) + (reopen is not None) + (reassign is not None) + (update_notes is not None) + (link_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pass_ is not None:
                self._pass_ = pass_
                self._type = 'pass'
            if close_with_further_action is not None:
                self._close_with_further_action = close_with_further_action
                self._type = 'closeWithFurtherAction'
            if reopen is not None:
                self._reopen = reopen
                self._type = 'reopen'
            if reassign is not None:
                self._reassign = reassign
                self._type = 'reassign'
            if update_notes is not None:
                self._update_notes = update_notes
                self._type = 'updateNotes'
            if link_notebook is not None:
                self._link_notebook = link_notebook
                self._type = 'linkNotebook'

        elif type_of_union == 'pass':
            if pass_ is None:
                raise ValueError('a union value must not be None')
            self._pass_ = pass_
            self._type = 'pass'
        elif type_of_union == 'closeWithFurtherAction':
            if close_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._close_with_further_action = close_with_further_action
            self._type = 'closeWithFurtherAction'
        elif type_of_union == 'reopen':
            if reopen is None:
                raise ValueError('a union value must not be None')
            self._reopen = reopen
            self._type = 'reopen'
        elif type_of_union == 'reassign':
            if reassign is None:
                raise ValueError('a union value must not be None')
            self._reassign = reassign
            self._type = 'reassign'
        elif type_of_union == 'updateNotes':
            if update_notes is None:
                raise ValueError('a union value must not be None')
            self._update_notes = update_notes
            self._type = 'updateNotes'
        elif type_of_union == 'linkNotebook':
            if link_notebook is None:
                raise ValueError('a union value must not be None')
            self._link_notebook = link_notebook
            self._type = 'linkNotebook'

    @builtins.property
    def pass_(self) -> Optional["scout_datareview_api_Pass"]:
        return self._pass_

    @builtins.property
    def close_with_further_action(self) -> Optional["scout_datareview_api_CloseWithFurtherAction"]:
        return self._close_with_further_action

    @builtins.property
    def reopen(self) -> Optional["scout_datareview_api_Reopen"]:
        return self._reopen

    @builtins.property
    def reassign(self) -> Optional["scout_datareview_api_Reassign"]:
        return self._reassign

    @builtins.property
    def update_notes(self) -> Optional["scout_datareview_api_UpdateNotes"]:
        return self._update_notes

    @builtins.property
    def link_notebook(self) -> Optional["scout_datareview_api_LinkNotebook"]:
        return self._link_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ManualCheckAlertActionVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ManualCheckAlertActionVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pass' and self.pass_ is not None:
            return visitor._pass(self.pass_)
        if self._type == 'closeWithFurtherAction' and self.close_with_further_action is not None:
            return visitor._close_with_further_action(self.close_with_further_action)
        if self._type == 'reopen' and self.reopen is not None:
            return visitor._reopen(self.reopen)
        if self._type == 'reassign' and self.reassign is not None:
            return visitor._reassign(self.reassign)
        if self._type == 'updateNotes' and self.update_notes is not None:
            return visitor._update_notes(self.update_notes)
        if self._type == 'linkNotebook' and self.link_notebook is not None:
            return visitor._link_notebook(self.link_notebook)


scout_datareview_api_ManualCheckAlertAction.__name__ = "ManualCheckAlertAction"
scout_datareview_api_ManualCheckAlertAction.__qualname__ = "ManualCheckAlertAction"
scout_datareview_api_ManualCheckAlertAction.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckAlertActionVisitor:

    @abstractmethod
    def _pass(self, pass_: "scout_datareview_api_Pass") -> Any:
        pass

    @abstractmethod
    def _close_with_further_action(self, close_with_further_action: "scout_datareview_api_CloseWithFurtherAction") -> Any:
        pass

    @abstractmethod
    def _reopen(self, reopen: "scout_datareview_api_Reopen") -> Any:
        pass

    @abstractmethod
    def _reassign(self, reassign: "scout_datareview_api_Reassign") -> Any:
        pass

    @abstractmethod
    def _update_notes(self, update_notes: "scout_datareview_api_UpdateNotes") -> Any:
        pass

    @abstractmethod
    def _link_notebook(self, link_notebook: "scout_datareview_api_LinkNotebook") -> Any:
        pass


scout_datareview_api_ManualCheckAlertActionVisitor.__name__ = "ManualCheckAlertActionVisitor"
scout_datareview_api_ManualCheckAlertActionVisitor.__qualname__ = "ManualCheckAlertActionVisitor"
scout_datareview_api_ManualCheckAlertActionVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluation(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datareview_api_ManualCheckEvaluationRid),
            'check_rid': ConjureFieldDefinition('checkRid', scout_rids_api_CheckRid),
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid),
            'state': ConjureFieldDefinition('state', scout_datareview_api_ManualCheckEvaluationState),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid]),
            'chart': ConjureFieldDefinition('chart', OptionalTypeWrapper[scout_rids_api_VersionedVizId]),
            'notes': ConjureFieldDefinition('notes', OptionalTypeWrapper[str]),
            'notebook': ConjureFieldDefinition('notebook', OptionalTypeWrapper[scout_rids_api_NotebookRid])
        }

    __slots__: List[str] = ['_rid', '_check_rid', '_data_review_rid', '_state', '_assignee_rids', '_chart', '_notes', '_notebook']

    def __init__(self, assignee_rids: List[str], check_rid: str, data_review_rid: str, rid: str, state: "scout_datareview_api_ManualCheckEvaluationState", chart: Optional["scout_rids_api_VersionedVizId"] = None, notebook: Optional[str] = None, notes: Optional[str] = None) -> None:
        self._rid = rid
        self._check_rid = check_rid
        self._data_review_rid = data_review_rid
        self._state = state
        self._assignee_rids = assignee_rids
        self._chart = chart
        self._notes = notes
        self._notebook = notebook

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def check_rid(self) -> str:
        return self._check_rid

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid

    @builtins.property
    def state(self) -> "scout_datareview_api_ManualCheckEvaluationState":
        return self._state

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids

    @builtins.property
    def chart(self) -> Optional["scout_rids_api_VersionedVizId"]:
        return self._chart

    @builtins.property
    def notes(self) -> Optional[str]:
        return self._notes

    @builtins.property
    def notebook(self) -> Optional[str]:
        return self._notebook


scout_datareview_api_ManualCheckEvaluation.__name__ = "ManualCheckEvaluation"
scout_datareview_api_ManualCheckEvaluation.__qualname__ = "ManualCheckEvaluation"
scout_datareview_api_ManualCheckEvaluation.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationActionLog(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'entries': ConjureFieldDefinition('entries', List[scout_datareview_api_ManualCheckEvaluationActionLogEntry])
        }

    __slots__: List[str] = ['_entries']

    def __init__(self, entries: List["scout_datareview_api_ManualCheckEvaluationActionLogEntry"]) -> None:
        self._entries = entries

    @builtins.property
    def entries(self) -> List["scout_datareview_api_ManualCheckEvaluationActionLogEntry"]:
        return self._entries


scout_datareview_api_ManualCheckEvaluationActionLog.__name__ = "ManualCheckEvaluationActionLog"
scout_datareview_api_ManualCheckEvaluationActionLog.__qualname__ = "ManualCheckEvaluationActionLog"
scout_datareview_api_ManualCheckEvaluationActionLog.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationActionLogEntry(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'performed_by': ConjureFieldDefinition('performedBy', scout_rids_api_UserRid),
            'action': ConjureFieldDefinition('action', scout_datareview_api_ManualCheckAlertAction),
            'timestamp': ConjureFieldDefinition('timestamp', str)
        }

    __slots__: List[str] = ['_performed_by', '_action', '_timestamp']

    def __init__(self, action: "scout_datareview_api_ManualCheckAlertAction", performed_by: str, timestamp: str) -> None:
        self._performed_by = performed_by
        self._action = action
        self._timestamp = timestamp

    @builtins.property
    def performed_by(self) -> str:
        return self._performed_by

    @builtins.property
    def action(self) -> "scout_datareview_api_ManualCheckAlertAction":
        return self._action

    @builtins.property
    def timestamp(self) -> str:
        return self._timestamp


scout_datareview_api_ManualCheckEvaluationActionLogEntry.__name__ = "ManualCheckEvaluationActionLogEntry"
scout_datareview_api_ManualCheckEvaluationActionLogEntry.__qualname__ = "ManualCheckEvaluationActionLogEntry"
scout_datareview_api_ManualCheckEvaluationActionLogEntry.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationState(ConjureUnionType):
    _pending_review: Optional["scout_datareview_api_PendingReviewState"] = None
    _closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionState"] = None
    _passing: Optional["scout_datareview_api_PassState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', scout_datareview_api_PendingReviewState),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', scout_datareview_api_ClosedWithFurtherActionState),
            'passing': ConjureFieldDefinition('passing', scout_datareview_api_PassState)
        }

    def __init__(
            self,
            pending_review: Optional["scout_datareview_api_PendingReviewState"] = None,
            closed_with_further_action: Optional["scout_datareview_api_ClosedWithFurtherActionState"] = None,
            passing: Optional["scout_datareview_api_PassState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_review is not None) + (closed_with_further_action is not None) + (passing is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_review is not None:
                self._pending_review = pending_review
                self._type = 'pendingReview'
            if closed_with_further_action is not None:
                self._closed_with_further_action = closed_with_further_action
                self._type = 'closedWithFurtherAction'
            if passing is not None:
                self._passing = passing
                self._type = 'passing'

        elif type_of_union == 'pendingReview':
            if pending_review is None:
                raise ValueError('a union value must not be None')
            self._pending_review = pending_review
            self._type = 'pendingReview'
        elif type_of_union == 'closedWithFurtherAction':
            if closed_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._closed_with_further_action = closed_with_further_action
            self._type = 'closedWithFurtherAction'
        elif type_of_union == 'passing':
            if passing is None:
                raise ValueError('a union value must not be None')
            self._passing = passing
            self._type = 'passing'

    @builtins.property
    def pending_review(self) -> Optional["scout_datareview_api_PendingReviewState"]:
        return self._pending_review

    @builtins.property
    def closed_with_further_action(self) -> Optional["scout_datareview_api_ClosedWithFurtherActionState"]:
        return self._closed_with_further_action

    @builtins.property
    def passing(self) -> Optional["scout_datareview_api_PassState"]:
        return self._passing

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ManualCheckEvaluationStateVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ManualCheckEvaluationStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingReview' and self.pending_review is not None:
            return visitor._pending_review(self.pending_review)
        if self._type == 'closedWithFurtherAction' and self.closed_with_further_action is not None:
            return visitor._closed_with_further_action(self.closed_with_further_action)
        if self._type == 'passing' and self.passing is not None:
            return visitor._passing(self.passing)


scout_datareview_api_ManualCheckEvaluationState.__name__ = "ManualCheckEvaluationState"
scout_datareview_api_ManualCheckEvaluationState.__qualname__ = "ManualCheckEvaluationState"
scout_datareview_api_ManualCheckEvaluationState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ManualCheckEvaluationStateVisitor:

    @abstractmethod
    def _pending_review(self, pending_review: "scout_datareview_api_PendingReviewState") -> Any:
        pass

    @abstractmethod
    def _closed_with_further_action(self, closed_with_further_action: "scout_datareview_api_ClosedWithFurtherActionState") -> Any:
        pass

    @abstractmethod
    def _passing(self, passing: "scout_datareview_api_PassState") -> Any:
        pass


scout_datareview_api_ManualCheckEvaluationStateVisitor.__name__ = "ManualCheckEvaluationStateVisitor"
scout_datareview_api_ManualCheckEvaluationStateVisitor.__qualname__ = "ManualCheckEvaluationStateVisitor"
scout_datareview_api_ManualCheckEvaluationStateVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_Pass(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str)
        }

    __slots__: List[str] = ['_comment']

    def __init__(self, comment: str) -> None:
        self._comment = comment

    @builtins.property
    def comment(self) -> str:
        return self._comment


scout_datareview_api_Pass.__name__ = "Pass"
scout_datareview_api_Pass.__qualname__ = "Pass"
scout_datareview_api_Pass.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_PassState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_datareview_api_PassState.__name__ = "PassState"
scout_datareview_api_PassState.__qualname__ = "PassState"
scout_datareview_api_PassState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_PassingExecutionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_PassingExecutionState.__name__ = "PassingExecutionState"
scout_datareview_api_PassingExecutionState.__qualname__ = "PassingExecutionState"
scout_datareview_api_PassingExecutionState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_PendingExecutionState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'job_rid': ConjureFieldDefinition('jobRid', scout_checks_api_JobRid)
        }

    __slots__: List[str] = ['_job_rid']

    def __init__(self, job_rid: str) -> None:
        self._job_rid = job_rid

    @builtins.property
    def job_rid(self) -> str:
        return self._job_rid


scout_datareview_api_PendingExecutionState.__name__ = "PendingExecutionState"
scout_datareview_api_PendingExecutionState.__qualname__ = "PendingExecutionState"
scout_datareview_api_PendingExecutionState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_PendingReviewState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_PendingReviewState.__name__ = "PendingReviewState"
scout_datareview_api_PendingReviewState.__qualname__ = "PendingReviewState"
scout_datareview_api_PendingReviewState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_Reassign(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'assignee_rids': ConjureFieldDefinition('assigneeRids', List[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_assignee_rids']

    def __init__(self, assignee_rids: List[str]) -> None:
        self._assignee_rids = assignee_rids

    @builtins.property
    def assignee_rids(self) -> List[str]:
        return self._assignee_rids


scout_datareview_api_Reassign.__name__ = "Reassign"
scout_datareview_api_Reassign.__qualname__ = "Reassign"
scout_datareview_api_Reassign.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_Reopen(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'strategy': ConjureFieldDefinition('strategy', OptionalTypeWrapper[scout_datareview_api_ReopenStrategy])
        }

    __slots__: List[str] = ['_comment', '_strategy']

    def __init__(self, comment: str, strategy: Optional["scout_datareview_api_ReopenStrategy"] = None) -> None:
        self._comment = comment
        self._strategy = strategy

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def strategy(self) -> Optional["scout_datareview_api_ReopenStrategy"]:
        """Defines the strategy for reopening the alert and any alerts linked via an associated notebook. If not 
provided, the default strategy is reopenAllLinkedAlerts.
        """
        return self._strategy


scout_datareview_api_Reopen.__name__ = "Reopen"
scout_datareview_api_Reopen.__qualname__ = "Reopen"
scout_datareview_api_Reopen.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenAllLinkedAlerts(ConjureBeanType):
    """Reopen all alerts associated with the same notebook and unlock the notebook.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAllLinkedAlerts.__name__ = "ReopenAllLinkedAlerts"
scout_datareview_api_ReopenAllLinkedAlerts.__qualname__ = "ReopenAllLinkedAlerts"
scout_datareview_api_ReopenAllLinkedAlerts.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenAndDetachFromNotebook(ConjureBeanType):
    """Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, those alerts will maintain the reference to the notebook and the notebook will remain locked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAndDetachFromNotebook.__name__ = "ReopenAndDetachFromNotebook"
scout_datareview_api_ReopenAndDetachFromNotebook.__qualname__ = "ReopenAndDetachFromNotebook"
scout_datareview_api_ReopenAndDetachFromNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook(ConjureBeanType):
    """Reopen the alert and detach it from the notebook. If the alert is linked to the same notebook as other 
alerts, the notebook will be duplicated and the alert will be linked to the new notebook. The new notebook
will be unlocked.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__name__ = "ReopenAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__qualname__ = "ReopenAndDuplicatePreviouslyLinkedNotebook"
scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenAndLinkToNotebook(ConjureBeanType):
    """Reopen the alert and link to notebook. Throws if the associated notebook has closed alerts.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str)
        }

    __slots__: List[str] = ['_comment']

    def __init__(self, comment: str) -> None:
        self._comment = comment

    @builtins.property
    def comment(self) -> str:
        return self._comment


scout_datareview_api_ReopenAndLinkToNotebook.__name__ = "ReopenAndLinkToNotebook"
scout_datareview_api_ReopenAndLinkToNotebook.__qualname__ = "ReopenAndLinkToNotebook"
scout_datareview_api_ReopenAndLinkToNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenStrategy(ConjureUnionType):
    _reopen_all_linked_alerts: Optional["scout_datareview_api_ReopenAllLinkedAlerts"] = None
    _reopen_and_detach_from_notebook: Optional["scout_datareview_api_ReopenAndDetachFromNotebook"] = None
    _reopen_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'reopen_all_linked_alerts': ConjureFieldDefinition('reopenAllLinkedAlerts', scout_datareview_api_ReopenAllLinkedAlerts),
            'reopen_and_detach_from_notebook': ConjureFieldDefinition('reopenAndDetachFromNotebook', scout_datareview_api_ReopenAndDetachFromNotebook),
            'reopen_and_duplicate_previously_linked_notebook': ConjureFieldDefinition('reopenAndDuplicatePreviouslyLinkedNotebook', scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook)
        }

    def __init__(
            self,
            reopen_all_linked_alerts: Optional["scout_datareview_api_ReopenAllLinkedAlerts"] = None,
            reopen_and_detach_from_notebook: Optional["scout_datareview_api_ReopenAndDetachFromNotebook"] = None,
            reopen_and_duplicate_previously_linked_notebook: Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (reopen_all_linked_alerts is not None) + (reopen_and_detach_from_notebook is not None) + (reopen_and_duplicate_previously_linked_notebook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if reopen_all_linked_alerts is not None:
                self._reopen_all_linked_alerts = reopen_all_linked_alerts
                self._type = 'reopenAllLinkedAlerts'
            if reopen_and_detach_from_notebook is not None:
                self._reopen_and_detach_from_notebook = reopen_and_detach_from_notebook
                self._type = 'reopenAndDetachFromNotebook'
            if reopen_and_duplicate_previously_linked_notebook is not None:
                self._reopen_and_duplicate_previously_linked_notebook = reopen_and_duplicate_previously_linked_notebook
                self._type = 'reopenAndDuplicatePreviouslyLinkedNotebook'

        elif type_of_union == 'reopenAllLinkedAlerts':
            if reopen_all_linked_alerts is None:
                raise ValueError('a union value must not be None')
            self._reopen_all_linked_alerts = reopen_all_linked_alerts
            self._type = 'reopenAllLinkedAlerts'
        elif type_of_union == 'reopenAndDetachFromNotebook':
            if reopen_and_detach_from_notebook is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_detach_from_notebook = reopen_and_detach_from_notebook
            self._type = 'reopenAndDetachFromNotebook'
        elif type_of_union == 'reopenAndDuplicatePreviouslyLinkedNotebook':
            if reopen_and_duplicate_previously_linked_notebook is None:
                raise ValueError('a union value must not be None')
            self._reopen_and_duplicate_previously_linked_notebook = reopen_and_duplicate_previously_linked_notebook
            self._type = 'reopenAndDuplicatePreviouslyLinkedNotebook'

    @builtins.property
    def reopen_all_linked_alerts(self) -> Optional["scout_datareview_api_ReopenAllLinkedAlerts"]:
        return self._reopen_all_linked_alerts

    @builtins.property
    def reopen_and_detach_from_notebook(self) -> Optional["scout_datareview_api_ReopenAndDetachFromNotebook"]:
        return self._reopen_and_detach_from_notebook

    @builtins.property
    def reopen_and_duplicate_previously_linked_notebook(self) -> Optional["scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook"]:
        return self._reopen_and_duplicate_previously_linked_notebook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datareview_api_ReopenStrategyVisitor):
            raise ValueError('{} is not an instance of scout_datareview_api_ReopenStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'reopenAllLinkedAlerts' and self.reopen_all_linked_alerts is not None:
            return visitor._reopen_all_linked_alerts(self.reopen_all_linked_alerts)
        if self._type == 'reopenAndDetachFromNotebook' and self.reopen_and_detach_from_notebook is not None:
            return visitor._reopen_and_detach_from_notebook(self.reopen_and_detach_from_notebook)
        if self._type == 'reopenAndDuplicatePreviouslyLinkedNotebook' and self.reopen_and_duplicate_previously_linked_notebook is not None:
            return visitor._reopen_and_duplicate_previously_linked_notebook(self.reopen_and_duplicate_previously_linked_notebook)


scout_datareview_api_ReopenStrategy.__name__ = "ReopenStrategy"
scout_datareview_api_ReopenStrategy.__qualname__ = "ReopenStrategy"
scout_datareview_api_ReopenStrategy.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_ReopenStrategyVisitor:

    @abstractmethod
    def _reopen_all_linked_alerts(self, reopen_all_linked_alerts: "scout_datareview_api_ReopenAllLinkedAlerts") -> Any:
        pass

    @abstractmethod
    def _reopen_and_detach_from_notebook(self, reopen_and_detach_from_notebook: "scout_datareview_api_ReopenAndDetachFromNotebook") -> Any:
        pass

    @abstractmethod
    def _reopen_and_duplicate_previously_linked_notebook(self, reopen_and_duplicate_previously_linked_notebook: "scout_datareview_api_ReopenAndDuplicatePreviouslyLinkedNotebook") -> Any:
        pass


scout_datareview_api_ReopenStrategyVisitor.__name__ = "ReopenStrategyVisitor"
scout_datareview_api_ReopenStrategyVisitor.__qualname__ = "ReopenStrategyVisitor"
scout_datareview_api_ReopenStrategyVisitor.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_RerunFailedAutomaticChecksRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_review_rid': ConjureFieldDefinition('dataReviewRid', scout_rids_api_DataReviewRid)
        }

    __slots__: List[str] = ['_data_review_rid']

    def __init__(self, data_review_rid: str) -> None:
        self._data_review_rid = data_review_rid

    @builtins.property
    def data_review_rid(self) -> str:
        return self._data_review_rid


scout_datareview_api_RerunFailedAutomaticChecksRequest.__name__ = "RerunFailedAutomaticChecksRequest"
scout_datareview_api_RerunFailedAutomaticChecksRequest.__qualname__ = "RerunFailedAutomaticChecksRequest"
scout_datareview_api_RerunFailedAutomaticChecksRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_datareview_api_SearchCheckAlertsSortOptions]),
            'search_text': ConjureFieldDefinition('searchText', OptionalTypeWrapper[str]),
            'after': ConjureFieldDefinition('after', OptionalTypeWrapper[api_Timestamp]),
            'before': ConjureFieldDefinition('before', OptionalTypeWrapper[api_Timestamp]),
            'status': ConjureFieldDefinition('status', OptionalTypeWrapper[List[scout_datareview_api_CheckAlertStatus]]),
            'check_rids': ConjureFieldDefinition('checkRids', OptionalTypeWrapper[List[scout_rids_api_CheckRid]]),
            'data_review_rids': ConjureFieldDefinition('dataReviewRids', OptionalTypeWrapper[List[scout_rids_api_DataReviewRid]]),
            'assignee_rids': ConjureFieldDefinition('assigneeRids', OptionalTypeWrapper[List[scout_rids_api_UserRid]]),
            'priorities': ConjureFieldDefinition('priorities', OptionalTypeWrapper[List[scout_api_Priority]]),
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid]),
            'pinned_checklist_refs': ConjureFieldDefinition('pinnedChecklistRefs', OptionalTypeWrapper[List[scout_checks_api_PinnedChecklistRef]]),
            'chart_rids': ConjureFieldDefinition('chartRids', OptionalTypeWrapper[List[scout_rids_api_VersionedVizId]]),
            'notebook_rids': ConjureFieldDefinition('notebookRids', OptionalTypeWrapper[List[scout_rids_api_NotebookRid]]),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_next_page_token', '_page_size', '_sort_by', '_search_text', '_after', '_before', '_status', '_check_rids', '_data_review_rids', '_assignee_rids', '_priorities', '_run_rids', '_asset_rids', '_pinned_checklist_refs', '_chart_rids', '_notebook_rids', '_show_archived', '_archived_statuses']

    def __init__(self, asset_rids: List[str], run_rids: List[str], after: Optional["api_Timestamp"] = None, archived_statuses: Optional[List["api_ArchivedStatus"]] = None, assignee_rids: Optional[List[str]] = None, before: Optional["api_Timestamp"] = None, chart_rids: Optional[List["scout_rids_api_VersionedVizId"]] = None, check_rids: Optional[List[str]] = None, data_review_rids: Optional[List[str]] = None, next_page_token: Optional[str] = None, notebook_rids: Optional[List[str]] = None, page_size: Optional[int] = None, pinned_checklist_refs: Optional[List["scout_checks_api_PinnedChecklistRef"]] = None, priorities: Optional[List["scout_api_Priority"]] = None, search_text: Optional[str] = None, show_archived: Optional[bool] = None, sort_by: Optional["scout_datareview_api_SearchCheckAlertsSortOptions"] = None, status: Optional[List["scout_datareview_api_CheckAlertStatus"]] = None) -> None:
        self._next_page_token = next_page_token
        self._page_size = page_size
        self._sort_by = sort_by
        self._search_text = search_text
        self._after = after
        self._before = before
        self._status = status
        self._check_rids = check_rids
        self._data_review_rids = data_review_rids
        self._assignee_rids = assignee_rids
        self._priorities = priorities
        self._run_rids = run_rids
        self._asset_rids = asset_rids
        self._pinned_checklist_refs = pinned_checklist_refs
        self._chart_rids = chart_rids
        self._notebook_rids = notebook_rids
        self._show_archived = show_archived
        self._archived_statuses = archived_statuses

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def sort_by(self) -> Optional["scout_datareview_api_SearchCheckAlertsSortOptions"]:
        """If not present, will sort by start time in descending order.
        """
        return self._sort_by

    @builtins.property
    def search_text(self) -> Optional[str]:
        """Matches on check name
        """
        return self._search_text

    @builtins.property
    def after(self) -> Optional["api_Timestamp"]:
        """Filters to start times after this time, inclusive.
        """
        return self._after

    @builtins.property
    def before(self) -> Optional["api_Timestamp"]:
        """Filters to start times before this time, exclusive.
        """
        return self._before

    @builtins.property
    def status(self) -> Optional[List["scout_datareview_api_CheckAlertStatus"]]:
        return self._status

    @builtins.property
    def check_rids(self) -> Optional[List[str]]:
        return self._check_rids

    @builtins.property
    def data_review_rids(self) -> Optional[List[str]]:
        return self._data_review_rids

    @builtins.property
    def assignee_rids(self) -> Optional[List[str]]:
        return self._assignee_rids

    @builtins.property
    def priorities(self) -> Optional[List["scout_api_Priority"]]:
        return self._priorities

    @builtins.property
    def run_rids(self) -> List[str]:
        return self._run_rids

    @builtins.property
    def asset_rids(self) -> List[str]:
        return self._asset_rids

    @builtins.property
    def pinned_checklist_refs(self) -> Optional[List["scout_checks_api_PinnedChecklistRef"]]:
        return self._pinned_checklist_refs

    @builtins.property
    def chart_rids(self) -> Optional[List["scout_rids_api_VersionedVizId"]]:
        return self._chart_rids

    @builtins.property
    def notebook_rids(self) -> Optional[List[str]]:
        return self._notebook_rids

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """To be deprecated. Use archivedStatuses instead. If true, includes archived check alerts in the search 
results. If not present or false, will not show archived data reviews in search results
        """
        return self._show_archived

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Filters search on check alerts based on the archived statuses provided.
Default is NOT_ARCHIVED only if none are provided.
        """
        return self._archived_statuses


scout_datareview_api_SearchCheckAlertsRequest.__name__ = "SearchCheckAlertsRequest"
scout_datareview_api_SearchCheckAlertsRequest.__qualname__ = "SearchCheckAlertsRequest"
scout_datareview_api_SearchCheckAlertsRequest.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'check_alerts': ConjureFieldDefinition('checkAlerts', List[scout_datareview_api_CheckAlert])
        }

    __slots__: List[str] = ['_next_page_token', '_check_alerts']

    def __init__(self, check_alerts: List["scout_datareview_api_CheckAlert"], next_page_token: Optional[str] = None) -> None:
        self._next_page_token = next_page_token
        self._check_alerts = check_alerts

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def check_alerts(self) -> List["scout_datareview_api_CheckAlert"]:
        return self._check_alerts


scout_datareview_api_SearchCheckAlertsResponse.__name__ = "SearchCheckAlertsResponse"
scout_datareview_api_SearchCheckAlertsResponse.__qualname__ = "SearchCheckAlertsResponse"
scout_datareview_api_SearchCheckAlertsResponse.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsSortField(ConjureEnumType):

    CHECK_NAME = 'CHECK_NAME'
    '''CHECK_NAME'''
    START = 'START'
    '''START'''
    END = 'END'
    '''END'''
    STATUS = 'STATUS'
    '''STATUS'''
    PRIORITY = 'PRIORITY'
    '''PRIORITY'''
    DURATION = 'DURATION'
    '''DURATION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_SearchCheckAlertsSortField.__name__ = "SearchCheckAlertsSortField"
scout_datareview_api_SearchCheckAlertsSortField.__qualname__ = "SearchCheckAlertsSortField"
scout_datareview_api_SearchCheckAlertsSortField.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_SearchCheckAlertsSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_datareview_api_SearchCheckAlertsSortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_datareview_api_SearchCheckAlertsSortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_datareview_api_SearchCheckAlertsSortField":
        return self._field


scout_datareview_api_SearchCheckAlertsSortOptions.__name__ = "SearchCheckAlertsSortOptions"
scout_datareview_api_SearchCheckAlertsSortOptions.__qualname__ = "SearchCheckAlertsSortOptions"
scout_datareview_api_SearchCheckAlertsSortOptions.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_Status(ConjureEnumType):

    PASS = 'PASS'
    '''PASS'''
    FAIL = 'FAIL'
    '''FAIL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datareview_api_Status.__name__ = "Status"
scout_datareview_api_Status.__qualname__ = "Status"
scout_datareview_api_Status.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_TooManyAlertsState(ConjureBeanType):
    """The number of generated alerts is greater than the maximum. The check is likely misconfigured.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_TooManyAlertsState.__name__ = "TooManyAlertsState"
scout_datareview_api_TooManyAlertsState.__qualname__ = "TooManyAlertsState"
scout_datareview_api_TooManyAlertsState.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_UnarchiveDataReview(ConjureBeanType):
    """Unarchive the data review which created this check alert. Only performable via the unarchive data review 
endpoint; not supported by Perform Check Alert Action.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_UnarchiveDataReview.__name__ = "UnarchiveDataReview"
scout_datareview_api_UnarchiveDataReview.__qualname__ = "UnarchiveDataReview"
scout_datareview_api_UnarchiveDataReview.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_UnlinkNotebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datareview_api_UnlinkNotebook.__name__ = "UnlinkNotebook"
scout_datareview_api_UnlinkNotebook.__qualname__ = "UnlinkNotebook"
scout_datareview_api_UnlinkNotebook.__module__ = "nominal_api.scout_datareview_api"


class scout_datareview_api_UpdateNotes(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'notes': ConjureFieldDefinition('notes', str)
        }

    __slots__: List[str] = ['_notes']

    def __init__(self, notes: str) -> None:
        self._notes = notes

    @builtins.property
    def notes(self) -> str:
        return self._notes


scout_datareview_api_UpdateNotes.__name__ = "UpdateNotes"
scout_datareview_api_UpdateNotes.__qualname__ = "UpdateNotes"
scout_datareview_api_UpdateNotes.__module__ = "nominal_api.scout_datareview_api"


class scout_datasource_DataSourceService(Service):
    """Data sources are data input to runs, including databases, CSV, video, and streaming data. They contain channels that represent the series data.
The DataSource Service is responsible for indexing and searching channels across data sources.
    """

    def search_channels(self, auth_header: str, query: "datasource_api_SearchChannelsRequest") -> "datasource_api_SearchChannelsResponse":
        """Returns channels that match the search criteria. Results are sorted by similarity score.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(query)

        _path = '/data-source/v1/data-sources/search-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchChannelsResponse, self._return_none_for_unknown_union_types)

    def search_filtered_channels(self, auth_header: str, query: "datasource_api_SearchFilteredChannelsRequest") -> "datasource_api_SearchFilteredChannelsResponse":
        """Returns channels that match the search criteria. Results are sorted by similarity score.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(query)

        _path = '/data-source/v1/data-sources/search-filtered-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchFilteredChannelsResponse, self._return_none_for_unknown_union_types)

    def search_hierarchical_channels(self, auth_header: str, query: "datasource_api_SearchHierarchicalChannelsRequest") -> "datasource_api_SearchHierarchicalChannelsResponse":
        """Returns only channels that are direct children of the parent. Returns results sorted alphabetically.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(query)

        _path = '/data-source/v1/data-sources/search-hierarchical-channels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_SearchHierarchicalChannelsResponse, self._return_none_for_unknown_union_types)

    def index_channel_prefix_tree(self, auth_header: str, request: "datasource_api_IndexChannelPrefixTreeRequest") -> "datasource_api_ChannelPrefixTree":
        """Indexes the channel prefix tree for a specified data source. This operation constructs a prefix tree from the 
channels available in the data source.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/index-channel-prefix-tree'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_ChannelPrefixTree, self._return_none_for_unknown_union_types)

    def batch_get_channel_prefix_trees(self, auth_header: str, request: "datasource_api_BatchGetChannelPrefixTreeRequest") -> "datasource_api_BatchGetChannelPrefixTreeResponse":
        """Returns the channel prefix tree for each of the specified data sources. If the tree for a data source has not
been indexed, it will be omitted from the map.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/batch-get-channel-prefix-tree'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_BatchGetChannelPrefixTreeResponse, self._return_none_for_unknown_union_types)

    def get_available_tags_for_channel(self, auth_header: str, request: "datasource_api_GetAvailableTagsForChannelRequest") -> "datasource_api_GetAvailableTagsForChannelResponse":
        """Returns the the set of all tag keys and their values that are available for the specified channel given an
initial set of filters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/get-available-tags'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_GetAvailableTagsForChannelResponse, self._return_none_for_unknown_union_types)

    def get_data_scope_bounds(self, auth_header: str, request: "datasource_api_BatchGetDataScopeBoundsRequest") -> "datasource_api_BatchGetDataScopeBoundsResponse":
        """Returns the maximum data timestamps for the specified data scopes. Responses are returned
in the same order as requests.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/get-data-scope-bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_BatchGetDataScopeBoundsResponse, self._return_none_for_unknown_union_types)

    def get_tag_values_for_data_source(self, auth_header: str, data_source_rid: str, request: "datasource_api_GetTagValuesForDataSourceRequest") -> Dict[str, List[str]]:
        """Returns available tag values for a given data source for a set of tag keys. For Nominal data sources, a time 
range can be provided to filter tag values to those present within the months spanned by the range. If no
time range is provided, this defaults to the last month. For external data sources, the range must not be 
specified, as all tag values are returned.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/{dataSourceRid}/get-tags'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[api_TagName, List[api_TagValue]], self._return_none_for_unknown_union_types)

    def get_available_tag_keys(self, auth_header: str, data_source_rid: str, request: "datasource_api_GetAvailableTagKeysRequest") -> "datasource_api_GetAvailableTagKeysResponse":
        """Paged endpoint returning the set of all tag keys that are available for the specified channel given an
initial set of filters.
If any tag filters are supplied, their tag keys are omitted from the result.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/{dataSourceRid}/get-tag-keys'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_GetAvailableTagKeysResponse, self._return_none_for_unknown_union_types)

    def get_available_tag_values(self, auth_header: str, data_source_rid: str, request: "datasource_api_GetAvailableTagValuesRequest") -> "datasource_api_GetAvailableTagValuesResponse":
        """Paged endpoint returning the set of all tag values that are available for the specified tag and datasource
given an initial set of filters.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/v1/data-sources/{dataSourceRid}/get-tag-values'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), datasource_api_GetAvailableTagValuesResponse, self._return_none_for_unknown_union_types)


scout_datasource_DataSourceService.__name__ = "DataSourceService"
scout_datasource_DataSourceService.__qualname__ = "DataSourceService"
scout_datasource_DataSourceService.__module__ = "nominal_api.scout_datasource"


class scout_datasource_connection_ConnectionBootstrapperService(Service):
    """Nominal periodically scrapes connected databases (Connections) in order to maintain a database of all
series that can be read from that database. This service is responsible for executing the scrape, and can
be used manually to trigger a rescrape for any reason (for example, when updating a schema).
    """

    def populate_series(self, auth_header: str, request: "scout_datasource_connection_api_PopulateSeriesRequest", rid: str) -> None:
        """Populates the connection with series, by querying within the requested time range. If start or end are both omitted,
will query the last 7 days by default. If one of start or end is omitted, will query a 7 day range from the provided
start or end. Will throw if the requested range is larger than 30 days.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/connection/v1/{rid}/populateSeries'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_datasource_connection_ConnectionBootstrapperService.__name__ = "ConnectionBootstrapperService"
scout_datasource_connection_ConnectionBootstrapperService.__qualname__ = "ConnectionBootstrapperService"
scout_datasource_connection_ConnectionBootstrapperService.__module__ = "nominal_api.scout_datasource_connection"


class scout_datasource_connection_ConnectionService(Service):
    """A Connection contains the relevant metadata and information to be used as a data source for runs.
The Connection Service is responsible for creating, updating, and retrieving database connections.
    """

    def create_connection(self, auth_header: str, create_connection: "scout_datasource_connection_api_CreateConnection") -> "scout_datasource_connection_api_Connection":
        """Creates a new connection.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(create_connection)

        _path = '/data-source/connection/v1/connections'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def update_connection(self, auth_header: str, request: "scout_datasource_connection_api_UpdateConnectionRequest", rid: str) -> "scout_datasource_connection_api_Connection":
        """Updates an existing connection.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/connection/v1/connection/{rid}/details'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def update_connection_status(self, auth_header: str, request: "scout_datasource_connection_api_ConnectionStatus", rid: str) -> None:
        """Updates an existing connection status.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/data-source/connection/v1/connection/{rid}/status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def add_available_tags(self, auth_header: str, rid: str, tags: Dict[str, List[str]]) -> "scout_datasource_connection_api_Connection":
        """Adds available tag key/value pairs to the connection. If a tag name already exists, the values will be merged.
This is primarily an internal endpoint to update tags for external connections as they are periodically 
scraped. This endpoint should only be called by clients for Visual crossing connections. Throws if called for
Nominal connections which have their tags automatically indexed in the underlying Database.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(tags)

        _path = '/data-source/connection/v1/connection/{rid}/available-tags'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def get_connection(self, auth_header: str, rid: str) -> "scout_datasource_connection_api_Connection":
        """Gets a connection by its RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connection/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_Connection, self._return_none_for_unknown_union_types)

    def get_connections(self, auth_header: str, rids: List[str] = None) -> List["scout_datasource_connection_api_Connection"]:
        """Gets a set of connections by their RIDs.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/data-source/connection/v1/connection/multiple'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datasource_connection_api_Connection], self._return_none_for_unknown_union_types)

    def list_connections(self, auth_header: str, workspaces: List[str] = None, include_archived: Optional[bool] = None) -> List["scout_datasource_connection_api_Connection"]:
        """Lists all connections.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeArchived': _conjure_encoder.default(include_archived),
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_datasource_connection_api_Connection], self._return_none_for_unknown_union_types)

    def list_connections_v2(self, auth_header: str, workspaces: List[str] = None, include_archived: Optional[bool] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> "scout_datasource_connection_api_ListConnectionsResponse":
        """Lists connections with pagination. Returns connections ordered by creation time descending.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'includeArchived': _conjure_encoder.default(include_archived),
            'workspaces': _conjure_encoder.default(workspaces),
            'pageSize': _conjure_encoder.default(page_size),
            'nextPageToken': _conjure_encoder.default(next_page_token),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/data-source/connection/v2/connections'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_datasource_connection_api_ListConnectionsResponse, self._return_none_for_unknown_union_types)

    def archive_connection(self, auth_header: str, rid: str) -> None:
        """Archives a connection, which simply tags the connection for a client to filter.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_connection(self, auth_header: str, rid: str) -> None:
        """Undoes the archiving of a connection.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/data-source/connection/v1/connections/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_datasource_connection_ConnectionService.__name__ = "ConnectionService"
scout_datasource_connection_ConnectionService.__qualname__ = "ConnectionService"
scout_datasource_connection_ConnectionService.__module__ = "nominal_api.scout_datasource_connection"


class scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig.__name__ = "AllChannelsConnectionsScrapingConfig"
scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig.__qualname__ = "AllChannelsConnectionsScrapingConfig"
scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ApiConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_uri': ConjureFieldDefinition('apiUri', str),
            'token_secret_rid': ConjureFieldDefinition('tokenSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_api_uri', '_token_secret_rid']

    def __init__(self, api_uri: str, token_secret_rid: str) -> None:
        self._api_uri = api_uri
        self._token_secret_rid = token_secret_rid

    @builtins.property
    def api_uri(self) -> str:
        """The URI to connect to hit the endpoints specified in the spec.
        """
        return self._api_uri

    @builtins.property
    def token_secret_rid(self) -> str:
        """Secret Rid of token secret stored in Secrets Service.
        """
        return self._token_secret_rid


scout_datasource_connection_api_ApiConnectionDetails.__name__ = "ApiConnectionDetails"
scout_datasource_connection_api_ApiConnectionDetails.__qualname__ = "ApiConnectionDetails"
scout_datasource_connection_api_ApiConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ApiScrapingConfig(ConjureUnionType):
    """This config is used to scrape data from an external connections service.
    """
    _all_channels: Optional["scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig"] = None
    _channel_allow_list: Optional["scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig"] = None
    _channel_block_list: Optional["scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'all_channels': ConjureFieldDefinition('allChannels', scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig),
            'channel_allow_list': ConjureFieldDefinition('channelAllowList', scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig),
            'channel_block_list': ConjureFieldDefinition('channelBlockList', scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig)
        }

    def __init__(
            self,
            all_channels: Optional["scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig"] = None,
            channel_allow_list: Optional["scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig"] = None,
            channel_block_list: Optional["scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (all_channels is not None) + (channel_allow_list is not None) + (channel_block_list is not None) != 1:
                raise ValueError('a union must contain a single member')

            if all_channels is not None:
                self._all_channels = all_channels
                self._type = 'allChannels'
            if channel_allow_list is not None:
                self._channel_allow_list = channel_allow_list
                self._type = 'channelAllowList'
            if channel_block_list is not None:
                self._channel_block_list = channel_block_list
                self._type = 'channelBlockList'

        elif type_of_union == 'allChannels':
            if all_channels is None:
                raise ValueError('a union value must not be None')
            self._all_channels = all_channels
            self._type = 'allChannels'
        elif type_of_union == 'channelAllowList':
            if channel_allow_list is None:
                raise ValueError('a union value must not be None')
            self._channel_allow_list = channel_allow_list
            self._type = 'channelAllowList'
        elif type_of_union == 'channelBlockList':
            if channel_block_list is None:
                raise ValueError('a union value must not be None')
            self._channel_block_list = channel_block_list
            self._type = 'channelBlockList'

    @builtins.property
    def all_channels(self) -> Optional["scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig"]:
        return self._all_channels

    @builtins.property
    def channel_allow_list(self) -> Optional["scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig"]:
        return self._channel_allow_list

    @builtins.property
    def channel_block_list(self) -> Optional["scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig"]:
        return self._channel_block_list

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_ApiScrapingConfigVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_ApiScrapingConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'allChannels' and self.all_channels is not None:
            return visitor._all_channels(self.all_channels)
        if self._type == 'channelAllowList' and self.channel_allow_list is not None:
            return visitor._channel_allow_list(self.channel_allow_list)
        if self._type == 'channelBlockList' and self.channel_block_list is not None:
            return visitor._channel_block_list(self.channel_block_list)


scout_datasource_connection_api_ApiScrapingConfig.__name__ = "ApiScrapingConfig"
scout_datasource_connection_api_ApiScrapingConfig.__qualname__ = "ApiScrapingConfig"
scout_datasource_connection_api_ApiScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ApiScrapingConfigVisitor:

    @abstractmethod
    def _all_channels(self, all_channels: "scout_datasource_connection_api_AllChannelsConnectionsScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _channel_allow_list(self, channel_allow_list: "scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _channel_block_list(self, channel_block_list: "scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig") -> Any:
        pass


scout_datasource_connection_api_ApiScrapingConfigVisitor.__name__ = "ApiScrapingConfigVisitor"
scout_datasource_connection_api_ApiScrapingConfigVisitor.__qualname__ = "ApiScrapingConfigVisitor"
scout_datasource_connection_api_ApiScrapingConfigVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_BigQueryChannelNameComponent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'include_project': ConjureFieldDefinition('includeProject', bool),
            'include_dataset': ConjureFieldDefinition('includeDataset', bool),
            'include_table': ConjureFieldDefinition('includeTable', bool)
        }

    __slots__: List[str] = ['_include_project', '_include_dataset', '_include_table']

    def __init__(self, include_dataset: bool, include_project: bool, include_table: bool) -> None:
        self._include_project = include_project
        self._include_dataset = include_dataset
        self._include_table = include_table

    @builtins.property
    def include_project(self) -> bool:
        """Whether to include the project name in the channel name.
        """
        return self._include_project

    @builtins.property
    def include_dataset(self) -> bool:
        """Whether to include the dataset name in the channel name.
        """
        return self._include_dataset

    @builtins.property
    def include_table(self) -> bool:
        """Whether to include the table name in the channel name.
        """
        return self._include_table


scout_datasource_connection_api_BigQueryChannelNameComponent.__name__ = "BigQueryChannelNameComponent"
scout_datasource_connection_api_BigQueryChannelNameComponent.__qualname__ = "BigQueryChannelNameComponent"
scout_datasource_connection_api_BigQueryChannelNameComponent.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_BigQueryConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'region': ConjureFieldDefinition('region', scout_datasource_connection_api_LocationName),
            'project': ConjureFieldDefinition('project', scout_datasource_connection_api_ProjectName),
            'dataset': ConjureFieldDefinition('dataset', scout_datasource_connection_api_DatasetName),
            'table': ConjureFieldDefinition('table', scout_datasource_connection_api_TableName),
            'service_account_key_secret_rid': ConjureFieldDefinition('serviceAccountKeySecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_region', '_project', '_dataset', '_table', '_service_account_key_secret_rid']

    def __init__(self, dataset: str, project: str, region: str, service_account_key_secret_rid: str, table: str) -> None:
        self._region = region
        self._project = project
        self._dataset = dataset
        self._table = table
        self._service_account_key_secret_rid = service_account_key_secret_rid

    @builtins.property
    def region(self) -> str:
        """The region of the BigQuery Project (e.g. "us-east1")
        """
        return self._region

    @builtins.property
    def project(self) -> str:
        """The name of the BigQuery Project
        """
        return self._project

    @builtins.property
    def dataset(self) -> str:
        """The name of the dataset within the project
        """
        return self._dataset

    @builtins.property
    def table(self) -> str:
        """The name of the table within the dataset
        """
        return self._table

    @builtins.property
    def service_account_key_secret_rid(self) -> str:
        """Secret Rid of service account key stored in Secrets Service.
        """
        return self._service_account_key_secret_rid


scout_datasource_connection_api_BigQueryConnectionDetails.__name__ = "BigQueryConnectionDetails"
scout_datasource_connection_api_BigQueryConnectionDetails.__qualname__ = "BigQueryConnectionDetails"
scout_datasource_connection_api_BigQueryConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_BigQueryScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_column': ConjureFieldDefinition('timeColumn', scout_datasource_connection_api_ColumnName),
            'tag_columns': ConjureFieldDefinition('tagColumns', List[scout_datasource_connection_api_ColumnName]),
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', OptionalTypeWrapper[scout_datasource_connection_api_BigQueryChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_time_column', '_tag_columns', '_channel_name_components', '_separator']

    def __init__(self, tag_columns: List[str], time_column: str, channel_name_components: Optional["scout_datasource_connection_api_BigQueryChannelNameComponent"] = None, separator: Optional[str] = None) -> None:
        self._time_column = time_column
        self._tag_columns = tag_columns
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def time_column(self) -> str:
        """The name of the column that holds the timestamp.
        """
        return self._time_column

    @builtins.property
    def tag_columns(self) -> List[str]:
        """The name of the columns that should be interpreted as tag columns
        """
        return self._tag_columns

    @builtins.property
    def channel_name_components(self) -> Optional["scout_datasource_connection_api_BigQueryChannelNameComponent"]:
        """channelNameComponents will be combined, together with separator, to form
a fully qualified channel name. By default, we don't add anything
to the column name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> Optional[str]:
        """The separator that delimits the parts of the channel name. If
ommitted, the default is a ".".
        """
        return self._separator


scout_datasource_connection_api_BigQueryScrapingConfig.__name__ = "BigQueryScrapingConfig"
scout_datasource_connection_api_BigQueryScrapingConfig.__qualname__ = "BigQueryScrapingConfig"
scout_datasource_connection_api_BigQueryScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_allow_list': ConjureFieldDefinition('channelAllowList', List[api_Channel])
        }

    __slots__: List[str] = ['_channel_allow_list']

    def __init__(self, channel_allow_list: List[str]) -> None:
        self._channel_allow_list = channel_allow_list

    @builtins.property
    def channel_allow_list(self) -> List[str]:
        """Only channels in this set will be scraped. Must not be empty.
        """
        return self._channel_allow_list


scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig.__name__ = "ChannelAllowListConnectionsScrapingConfig"
scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig.__qualname__ = "ChannelAllowListConnectionsScrapingConfig"
scout_datasource_connection_api_ChannelAllowListConnectionsScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_block_list': ConjureFieldDefinition('channelBlockList', List[api_Channel])
        }

    __slots__: List[str] = ['_channel_block_list']

    def __init__(self, channel_block_list: List[str]) -> None:
        self._channel_block_list = channel_block_list

    @builtins.property
    def channel_block_list(self) -> List[str]:
        """Only channels not in this set will be scraped. Must not be empty.
        """
        return self._channel_block_list


scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig.__name__ = "ChannelBlockListConnectionsScrapingConfig"
scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig.__qualname__ = "ChannelBlockListConnectionsScrapingConfig"
scout_datasource_connection_api_ChannelBlockListConnectionsScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Connection(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_datasource_connection_api_ConnectionRid),
            'display_name': ConjureFieldDefinition('displayName', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'connection_details': ConjureFieldDefinition('connectionDetails', scout_datasource_connection_api_ConnectionDetails),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', List[api_TagName]),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', bool),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig]),
            'connection_status': ConjureFieldDefinition('connectionStatus', scout_datasource_connection_api_ConnectionStatus),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_display_name', '_description', '_connection_details', '_required_tag_names', '_metadata', '_scraping', '_should_scrape', '_limits', '_connection_status', '_is_archived']

    def __init__(self, connection_details: "scout_datasource_connection_api_ConnectionDetails", connection_status: "scout_datasource_connection_api_ConnectionStatus", display_name: str, is_archived: bool, metadata: Dict[str, str], required_tag_names: List[str], rid: str, should_scrape: bool, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None) -> None:
        self._rid = rid
        self._display_name = display_name
        self._description = description
        self._connection_details = connection_details
        self._required_tag_names = required_tag_names
        self._metadata = metadata
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits
        self._connection_status = connection_status
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def display_name(self) -> str:
        """The display name of the connection. For example: "Nominal production TimescaleDB"
        """
        return self._display_name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def connection_details(self) -> "scout_datasource_connection_api_ConnectionDetails":
        return self._connection_details

    @builtins.property
    def required_tag_names(self) -> List[str]:
        """Additional tag names that should be supplied to construct a fully qualified series. These are suggested,
rather than strictly required.
        """
        return self._required_tag_names

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        return self._metadata

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        """
        """
        return self._scraping

    @builtins.property
    def should_scrape(self) -> bool:
        """The connection will be scraped iff this flag is set and scrapingConfig is present.
        """
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits

    @builtins.property
    def connection_status(self) -> "scout_datasource_connection_api_ConnectionStatus":
        return self._connection_status

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_datasource_connection_api_Connection.__name__ = "Connection"
scout_datasource_connection_api_Connection.__qualname__ = "Connection"
scout_datasource_connection_api_Connection.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionDetails(ConjureUnionType):
    _timescale: Optional["scout_datasource_connection_api_TimescaleConnectionDetails"] = None
    _influx: Optional["scout_datasource_connection_api_Influx2ConnectionDetails"] = None
    _influx1: Optional["scout_datasource_connection_api_Influx1ConnectionDetails"] = None
    _nominal: Optional["scout_datasource_connection_api_NominalConnectionDetails"] = None
    _timestream: Optional["scout_datasource_connection_api_TimestreamConnectionDetails"] = None
    _visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"] = None
    _big_query: Optional["scout_datasource_connection_api_BigQueryConnectionDetails"] = None
    _api: Optional["scout_datasource_connection_api_ApiConnectionDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timescale': ConjureFieldDefinition('timescale', scout_datasource_connection_api_TimescaleConnectionDetails),
            'influx': ConjureFieldDefinition('influx', scout_datasource_connection_api_Influx2ConnectionDetails),
            'influx1': ConjureFieldDefinition('influx1', scout_datasource_connection_api_Influx1ConnectionDetails),
            'nominal': ConjureFieldDefinition('nominal', scout_datasource_connection_api_NominalConnectionDetails),
            'timestream': ConjureFieldDefinition('timestream', scout_datasource_connection_api_TimestreamConnectionDetails),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', scout_datasource_connection_api_VisualCrossingConnectionDetails),
            'big_query': ConjureFieldDefinition('bigQuery', scout_datasource_connection_api_BigQueryConnectionDetails),
            'api': ConjureFieldDefinition('api', scout_datasource_connection_api_ApiConnectionDetails)
        }

    def __init__(
            self,
            timescale: Optional["scout_datasource_connection_api_TimescaleConnectionDetails"] = None,
            influx: Optional["scout_datasource_connection_api_Influx2ConnectionDetails"] = None,
            influx1: Optional["scout_datasource_connection_api_Influx1ConnectionDetails"] = None,
            nominal: Optional["scout_datasource_connection_api_NominalConnectionDetails"] = None,
            timestream: Optional["scout_datasource_connection_api_TimestreamConnectionDetails"] = None,
            visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"] = None,
            big_query: Optional["scout_datasource_connection_api_BigQueryConnectionDetails"] = None,
            api: Optional["scout_datasource_connection_api_ApiConnectionDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timescale is not None) + (influx is not None) + (influx1 is not None) + (nominal is not None) + (timestream is not None) + (visual_crossing is not None) + (big_query is not None) + (api is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timescale is not None:
                self._timescale = timescale
                self._type = 'timescale'
            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if influx1 is not None:
                self._influx1 = influx1
                self._type = 'influx1'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'
            if big_query is not None:
                self._big_query = big_query
                self._type = 'bigQuery'
            if api is not None:
                self._api = api
                self._type = 'api'

        elif type_of_union == 'timescale':
            if timescale is None:
                raise ValueError('a union value must not be None')
            self._timescale = timescale
            self._type = 'timescale'
        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'influx1':
            if influx1 is None:
                raise ValueError('a union value must not be None')
            self._influx1 = influx1
            self._type = 'influx1'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'
        elif type_of_union == 'bigQuery':
            if big_query is None:
                raise ValueError('a union value must not be None')
            self._big_query = big_query
            self._type = 'bigQuery'
        elif type_of_union == 'api':
            if api is None:
                raise ValueError('a union value must not be None')
            self._api = api
            self._type = 'api'

    @builtins.property
    def timescale(self) -> Optional["scout_datasource_connection_api_TimescaleConnectionDetails"]:
        return self._timescale

    @builtins.property
    def influx(self) -> Optional["scout_datasource_connection_api_Influx2ConnectionDetails"]:
        return self._influx

    @builtins.property
    def influx1(self) -> Optional["scout_datasource_connection_api_Influx1ConnectionDetails"]:
        return self._influx1

    @builtins.property
    def nominal(self) -> Optional["scout_datasource_connection_api_NominalConnectionDetails"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["scout_datasource_connection_api_TimestreamConnectionDetails"]:
        return self._timestream

    @builtins.property
    def visual_crossing(self) -> Optional["scout_datasource_connection_api_VisualCrossingConnectionDetails"]:
        return self._visual_crossing

    @builtins.property
    def big_query(self) -> Optional["scout_datasource_connection_api_BigQueryConnectionDetails"]:
        return self._big_query

    @builtins.property
    def api(self) -> Optional["scout_datasource_connection_api_ApiConnectionDetails"]:
        return self._api

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_ConnectionDetailsVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_ConnectionDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timescale' and self.timescale is not None:
            return visitor._timescale(self.timescale)
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'influx1' and self.influx1 is not None:
            return visitor._influx1(self.influx1)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)
        if self._type == 'bigQuery' and self.big_query is not None:
            return visitor._big_query(self.big_query)
        if self._type == 'api' and self.api is not None:
            return visitor._api(self.api)


scout_datasource_connection_api_ConnectionDetails.__name__ = "ConnectionDetails"
scout_datasource_connection_api_ConnectionDetails.__qualname__ = "ConnectionDetails"
scout_datasource_connection_api_ConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionDetailsVisitor:

    @abstractmethod
    def _timescale(self, timescale: "scout_datasource_connection_api_TimescaleConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _influx(self, influx: "scout_datasource_connection_api_Influx2ConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _influx1(self, influx1: "scout_datasource_connection_api_Influx1ConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "scout_datasource_connection_api_NominalConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "scout_datasource_connection_api_TimestreamConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "scout_datasource_connection_api_VisualCrossingConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _big_query(self, big_query: "scout_datasource_connection_api_BigQueryConnectionDetails") -> Any:
        pass

    @abstractmethod
    def _api(self, api: "scout_datasource_connection_api_ApiConnectionDetails") -> Any:
        pass


scout_datasource_connection_api_ConnectionDetailsVisitor.__name__ = "ConnectionDetailsVisitor"
scout_datasource_connection_api_ConnectionDetailsVisitor.__qualname__ = "ConnectionDetailsVisitor"
scout_datasource_connection_api_ConnectionDetailsVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionPlottingConfiguration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max_undecimated_points_per_page': ConjureFieldDefinition('maxUndecimatedPointsPerPage', OptionalTypeWrapper[int]),
            'max_unbounded_range': ConjureFieldDefinition('maxUnboundedRange', OptionalTypeWrapper[int]),
            'max_undecimated_page_reads_per_second': ConjureFieldDefinition('maxUndecimatedPageReadsPerSecond', OptionalTypeWrapper[float]),
            'max_permits_per_second': ConjureFieldDefinition('maxPermitsPerSecond', OptionalTypeWrapper[float]),
            'max_connections': ConjureFieldDefinition('maxConnections', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_max_undecimated_points_per_page', '_max_unbounded_range', '_max_undecimated_page_reads_per_second', '_max_permits_per_second', '_max_connections']

    def __init__(self, max_connections: Optional[int] = None, max_permits_per_second: Optional[float] = None, max_unbounded_range: Optional[int] = None, max_undecimated_page_reads_per_second: Optional[float] = None, max_undecimated_points_per_page: Optional[int] = None) -> None:
        self._max_undecimated_points_per_page = max_undecimated_points_per_page
        self._max_unbounded_range = max_unbounded_range
        self._max_undecimated_page_reads_per_second = max_undecimated_page_reads_per_second
        self._max_permits_per_second = max_permits_per_second
        self._max_connections = max_connections

    @builtins.property
    def max_undecimated_points_per_page(self) -> Optional[int]:
        """The maximum number of points to return per page for undecimated queries
        """
        return self._max_undecimated_points_per_page

    @builtins.property
    def max_unbounded_range(self) -> Optional[int]:
        """The maximum range (in nanoseconds) for unbounded queries
        """
        return self._max_unbounded_range

    @builtins.property
    def max_undecimated_page_reads_per_second(self) -> Optional[float]:
        """The maximum number of page reads per second for undecimated queries
        """
        return self._max_undecimated_page_reads_per_second

    @builtins.property
    def max_permits_per_second(self) -> Optional[float]:
        """The maximum number of permits per second for queries
        """
        return self._max_permits_per_second

    @builtins.property
    def max_connections(self) -> Optional[int]:
        """The maximum number of connections to the database
        """
        return self._max_connections


scout_datasource_connection_api_ConnectionPlottingConfiguration.__name__ = "ConnectionPlottingConfiguration"
scout_datasource_connection_api_ConnectionPlottingConfiguration.__qualname__ = "ConnectionPlottingConfiguration"
scout_datasource_connection_api_ConnectionPlottingConfiguration.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ConnectionStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_connected': ConjureFieldDefinition('isConnected', bool)
        }

    __slots__: List[str] = ['_is_connected']

    def __init__(self, is_connected: bool) -> None:
        self._is_connected = is_connected

    @builtins.property
    def is_connected(self) -> bool:
        return self._is_connected


scout_datasource_connection_api_ConnectionStatus.__name__ = "ConnectionStatus"
scout_datasource_connection_api_ConnectionStatus.__qualname__ = "ConnectionStatus"
scout_datasource_connection_api_ConnectionStatus.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_CreateConnection(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'connection_details': ConjureFieldDefinition('connectionDetails', scout_datasource_connection_api_ConnectionDetails),
            'metadata': ConjureFieldDefinition('metadata', Dict[str, str]),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', List[api_TagName]),
            'available_tag_values': ConjureFieldDefinition('availableTagValues', OptionalTypeWrapper[Dict[api_TagName, List[api_TagValue]]]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', bool),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'marking_rids': ConjureFieldDefinition('markingRids', List[scout_rids_api_MarkingRid])
        }

    __slots__: List[str] = ['_name', '_description', '_connection_details', '_metadata', '_required_tag_names', '_available_tag_values', '_scraping', '_should_scrape', '_limits', '_workspace', '_marking_rids']

    def __init__(self, connection_details: "scout_datasource_connection_api_ConnectionDetails", marking_rids: List[str], metadata: Dict[str, str], name: str, required_tag_names: List[str], should_scrape: bool, available_tag_values: Optional[Dict[str, List[str]]] = None, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None, workspace: Optional[str] = None) -> None:
        self._name = name
        self._description = description
        self._connection_details = connection_details
        self._metadata = metadata
        self._required_tag_names = required_tag_names
        self._available_tag_values = available_tag_values
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits
        self._workspace = workspace
        self._marking_rids = marking_rids

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def connection_details(self) -> "scout_datasource_connection_api_ConnectionDetails":
        return self._connection_details

    @builtins.property
    def metadata(self) -> Dict[str, str]:
        """Metadata information about the connection which is not relevant to the DB connection itself.
        """
        return self._metadata

    @builtins.property
    def required_tag_names(self) -> List[str]:
        """Additional tag name that are required to construct a fully qualified series.
        """
        return self._required_tag_names

    @builtins.property
    def available_tag_values(self) -> Optional[Dict[str, List[str]]]:
        """In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which 
have their tags automatically indexed in the underlying database. Tags for external connections are 
periodically scraped. Tags should only be updated  manually for Visual crossing connections.
        """
        return self._available_tag_values

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        return self._scraping

    @builtins.property
    def should_scrape(self) -> bool:
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the connection. If not provided, the connection will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace

    @builtins.property
    def marking_rids(self) -> List[str]:
        """The markings to apply to the created connection.
If not provided, the connection will be visible to all users in the same workspace.
        """
        return self._marking_rids


scout_datasource_connection_api_CreateConnection.__name__ = "CreateConnection"
scout_datasource_connection_api_CreateConnection.__qualname__ = "CreateConnection"
scout_datasource_connection_api_CreateConnection.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Duration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', scout_datasource_connection_api_TemporalUnit),
            'count': ConjureFieldDefinition('count', int)
        }

    __slots__: List[str] = ['_unit', '_count']

    def __init__(self, count: int, unit: "scout_datasource_connection_api_TemporalUnit") -> None:
        self._unit = unit
        self._count = count

    @builtins.property
    def unit(self) -> "scout_datasource_connection_api_TemporalUnit":
        return self._unit

    @builtins.property
    def count(self) -> int:
        return self._count


scout_datasource_connection_api_Duration.__name__ = "Duration"
scout_datasource_connection_api_Duration.__qualname__ = "Duration"
scout_datasource_connection_api_Duration.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_HeaderValue(ConjureUnionType):
    _plain: Optional[str] = None
    _secret_rid: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'plain': ConjureFieldDefinition('plain', str),
            'secret_rid': ConjureFieldDefinition('secretRid', scout_datasource_connection_api_SecretRid)
        }

    def __init__(
            self,
            plain: Optional[str] = None,
            secret_rid: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (plain is not None) + (secret_rid is not None) != 1:
                raise ValueError('a union must contain a single member')

            if plain is not None:
                self._plain = plain
                self._type = 'plain'
            if secret_rid is not None:
                self._secret_rid = secret_rid
                self._type = 'secretRid'

        elif type_of_union == 'plain':
            if plain is None:
                raise ValueError('a union value must not be None')
            self._plain = plain
            self._type = 'plain'
        elif type_of_union == 'secretRid':
            if secret_rid is None:
                raise ValueError('a union value must not be None')
            self._secret_rid = secret_rid
            self._type = 'secretRid'

    @builtins.property
    def plain(self) -> Optional[str]:
        return self._plain

    @builtins.property
    def secret_rid(self) -> Optional[str]:
        return self._secret_rid

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_HeaderValueVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_HeaderValueVisitor'.format(visitor.__class__.__name__))
        if self._type == 'plain' and self.plain is not None:
            return visitor._plain(self.plain)
        if self._type == 'secretRid' and self.secret_rid is not None:
            return visitor._secret_rid(self.secret_rid)


scout_datasource_connection_api_HeaderValue.__name__ = "HeaderValue"
scout_datasource_connection_api_HeaderValue.__qualname__ = "HeaderValue"
scout_datasource_connection_api_HeaderValue.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_HeaderValueVisitor:

    @abstractmethod
    def _plain(self, plain: str) -> Any:
        pass

    @abstractmethod
    def _secret_rid(self, secret_rid: str) -> Any:
        pass


scout_datasource_connection_api_HeaderValueVisitor.__name__ = "HeaderValueVisitor"
scout_datasource_connection_api_HeaderValueVisitor.__qualname__ = "HeaderValueVisitor"
scout_datasource_connection_api_HeaderValueVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Influx1ConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'headers': ConjureFieldDefinition('headers', Dict[str, scout_datasource_connection_api_HeaderValue]),
            'credentials': ConjureFieldDefinition('credentials', OptionalTypeWrapper[scout_datasource_connection_api_PasswordCredentials])
        }

    __slots__: List[str] = ['_host', '_port', '_headers', '_credentials']

    def __init__(self, headers: Dict[str, "scout_datasource_connection_api_HeaderValue"], host: str, port: int, credentials: Optional["scout_datasource_connection_api_PasswordCredentials"] = None) -> None:
        self._host = host
        self._port = port
        self._headers = headers
        self._credentials = credentials

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def headers(self) -> Dict[str, "scout_datasource_connection_api_HeaderValue"]:
        """A map of header name to value
        """
        return self._headers

    @builtins.property
    def credentials(self) -> Optional["scout_datasource_connection_api_PasswordCredentials"]:
        return self._credentials


scout_datasource_connection_api_Influx1ConnectionDetails.__name__ = "Influx1ConnectionDetails"
scout_datasource_connection_api_Influx1ConnectionDetails.__qualname__ = "Influx1ConnectionDetails"
scout_datasource_connection_api_Influx1ConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_Influx2ConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'headers': ConjureFieldDefinition('headers', Dict[str, scout_datasource_connection_api_HeaderValue]),
            'org': ConjureFieldDefinition('org', scout_datasource_connection_api_influx_OrgId),
            'token_secret_rid': ConjureFieldDefinition('tokenSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_host', '_port', '_headers', '_org', '_token_secret_rid']

    def __init__(self, headers: Dict[str, "scout_datasource_connection_api_HeaderValue"], host: str, org: str, port: int, token_secret_rid: str) -> None:
        self._host = host
        self._port = port
        self._headers = headers
        self._org = org
        self._token_secret_rid = token_secret_rid

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def headers(self) -> Dict[str, "scout_datasource_connection_api_HeaderValue"]:
        """A map of header name to value
        """
        return self._headers

    @builtins.property
    def org(self) -> str:
        return self._org

    @builtins.property
    def token_secret_rid(self) -> str:
        """Secret Rid of token secret stored in Secrets Service.
        """
        return self._token_secret_rid


scout_datasource_connection_api_Influx2ConnectionDetails.__name__ = "Influx2ConnectionDetails"
scout_datasource_connection_api_Influx2ConnectionDetails.__qualname__ = "Influx2ConnectionDetails"
scout_datasource_connection_api_Influx2ConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxChannelNameComponent(ConjureUnionType):
    _bucket: Optional["api_Empty"] = None
    _measurement: Optional["api_Empty"] = None
    _field: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', api_Empty),
            'measurement': ConjureFieldDefinition('measurement', api_Empty),
            'field': ConjureFieldDefinition('field', api_Empty)
        }

    def __init__(
            self,
            bucket: Optional["api_Empty"] = None,
            measurement: Optional["api_Empty"] = None,
            field: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (bucket is not None) + (measurement is not None) + (field is not None) != 1:
                raise ValueError('a union must contain a single member')

            if bucket is not None:
                self._bucket = bucket
                self._type = 'bucket'
            if measurement is not None:
                self._measurement = measurement
                self._type = 'measurement'
            if field is not None:
                self._field = field
                self._type = 'field'

        elif type_of_union == 'bucket':
            if bucket is None:
                raise ValueError('a union value must not be None')
            self._bucket = bucket
            self._type = 'bucket'
        elif type_of_union == 'measurement':
            if measurement is None:
                raise ValueError('a union value must not be None')
            self._measurement = measurement
            self._type = 'measurement'
        elif type_of_union == 'field':
            if field is None:
                raise ValueError('a union value must not be None')
            self._field = field
            self._type = 'field'

    @builtins.property
    def bucket(self) -> Optional["api_Empty"]:
        return self._bucket

    @builtins.property
    def measurement(self) -> Optional["api_Empty"]:
        return self._measurement

    @builtins.property
    def field(self) -> Optional["api_Empty"]:
        return self._field

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_InfluxChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_InfluxChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'bucket' and self.bucket is not None:
            return visitor._bucket(self.bucket)
        if self._type == 'measurement' and self.measurement is not None:
            return visitor._measurement(self.measurement)
        if self._type == 'field' and self.field is not None:
            return visitor._field(self.field)


scout_datasource_connection_api_InfluxChannelNameComponent.__name__ = "InfluxChannelNameComponent"
scout_datasource_connection_api_InfluxChannelNameComponent.__qualname__ = "InfluxChannelNameComponent"
scout_datasource_connection_api_InfluxChannelNameComponent.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxChannelNameComponentVisitor:

    @abstractmethod
    def _bucket(self, bucket: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _measurement(self, measurement: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _field(self, field: "api_Empty") -> Any:
        pass


scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__name__ = "InfluxChannelNameComponentVisitor"
scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__qualname__ = "InfluxChannelNameComponentVisitor"
scout_datasource_connection_api_InfluxChannelNameComponentVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_InfluxScrapingFilter]),
            'series_archetype_construction': ConjureFieldDefinition('seriesArchetypeConstruction', scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig)
        }

    __slots__: List[str] = ['_filter', '_series_archetype_construction']

    def __init__(self, filter: List["scout_datasource_connection_api_InfluxScrapingFilter"], series_archetype_construction: "scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig") -> None:
        self._filter = filter
        self._series_archetype_construction = series_archetype_construction

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_InfluxScrapingFilter"]:
        """Filters are ANDed together
        """
        return self._filter

    @builtins.property
    def series_archetype_construction(self) -> "scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig":
        return self._series_archetype_construction


scout_datasource_connection_api_InfluxScrapingConfig.__name__ = "InfluxScrapingConfig"
scout_datasource_connection_api_InfluxScrapingConfig.__qualname__ = "InfluxScrapingConfig"
scout_datasource_connection_api_InfluxScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingFilter(ConjureUnionType):
    _not_: Optional["scout_datasource_connection_api_InfluxScrapingFilter"] = None
    _match_bucket: Optional[List[str]] = None
    _match_measurement: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_': ConjureFieldDefinition('not', scout_datasource_connection_api_InfluxScrapingFilter),
            'match_bucket': ConjureFieldDefinition('matchBucket', List[scout_datasource_connection_api_BucketName]),
            'match_measurement': ConjureFieldDefinition('matchMeasurement', List[scout_datasource_connection_api_MeasurementName])
        }

    def __init__(
            self,
            not_: Optional["scout_datasource_connection_api_InfluxScrapingFilter"] = None,
            match_bucket: Optional[List[str]] = None,
            match_measurement: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_ is not None) + (match_bucket is not None) + (match_measurement is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if match_bucket is not None:
                self._match_bucket = match_bucket
                self._type = 'matchBucket'
            if match_measurement is not None:
                self._match_measurement = match_measurement
                self._type = 'matchMeasurement'

        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'matchBucket':
            if match_bucket is None:
                raise ValueError('a union value must not be None')
            self._match_bucket = match_bucket
            self._type = 'matchBucket'
        elif type_of_union == 'matchMeasurement':
            if match_measurement is None:
                raise ValueError('a union value must not be None')
            self._match_measurement = match_measurement
            self._type = 'matchMeasurement'

    @builtins.property
    def not_(self) -> Optional["scout_datasource_connection_api_InfluxScrapingFilter"]:
        return self._not_

    @builtins.property
    def match_bucket(self) -> Optional[List[str]]:
        """Match any of the specified buckets
        """
        return self._match_bucket

    @builtins.property
    def match_measurement(self) -> Optional[List[str]]:
        """Match any of the specified measurements
        """
        return self._match_measurement

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_InfluxScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_InfluxScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'matchBucket' and self.match_bucket is not None:
            return visitor._match_bucket(self.match_bucket)
        if self._type == 'matchMeasurement' and self.match_measurement is not None:
            return visitor._match_measurement(self.match_measurement)


scout_datasource_connection_api_InfluxScrapingFilter.__name__ = "InfluxScrapingFilter"
scout_datasource_connection_api_InfluxScrapingFilter.__qualname__ = "InfluxScrapingFilter"
scout_datasource_connection_api_InfluxScrapingFilter.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxScrapingFilterVisitor:

    @abstractmethod
    def _not(self, not_: "scout_datasource_connection_api_InfluxScrapingFilter") -> Any:
        pass

    @abstractmethod
    def _match_bucket(self, match_bucket: List[str]) -> Any:
        pass

    @abstractmethod
    def _match_measurement(self, match_measurement: List[str]) -> Any:
        pass


scout_datasource_connection_api_InfluxScrapingFilterVisitor.__name__ = "InfluxScrapingFilterVisitor"
scout_datasource_connection_api_InfluxScrapingFilterVisitor.__qualname__ = "InfluxScrapingFilterVisitor"
scout_datasource_connection_api_InfluxScrapingFilterVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig(ConjureBeanType):
    """For example, for config of the form {components: [measurement, field, tag: vehicle], separator: "."} will construct a
channel that looks like vehicle_a.measurement.field. Tags will automatically be specified inside of the archetype.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_InfluxChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_InfluxChannelNameComponent"], separator: str) -> None:
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_InfluxChannelNameComponent"]:
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__name__ = "InfluxSeriesArchetypeConstructionConfig"
scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__qualname__ = "InfluxSeriesArchetypeConstructionConfig"
scout_datasource_connection_api_InfluxSeriesArchetypeConstructionConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_LimitsConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'max_query_range': ConjureFieldDefinition('maxQueryRange', OptionalTypeWrapper[scout_datasource_connection_api_Duration])
        }

    __slots__: List[str] = ['_max_query_range']

    def __init__(self, max_query_range: Optional["scout_datasource_connection_api_Duration"] = None) -> None:
        self._max_query_range = max_query_range

    @builtins.property
    def max_query_range(self) -> Optional["scout_datasource_connection_api_Duration"]:
        return self._max_query_range


scout_datasource_connection_api_LimitsConfig.__name__ = "LimitsConfig"
scout_datasource_connection_api_LimitsConfig.__qualname__ = "LimitsConfig"
scout_datasource_connection_api_LimitsConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ListConnectionsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'connections': ConjureFieldDefinition('connections', List[scout_datasource_connection_api_Connection]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_connections', '_next_page_token']

    def __init__(self, connections: List["scout_datasource_connection_api_Connection"], next_page_token: Optional[str] = None) -> None:
        self._connections = connections
        self._next_page_token = next_page_token

    @builtins.property
    def connections(self) -> List["scout_datasource_connection_api_Connection"]:
        return self._connections

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_datasource_connection_api_ListConnectionsResponse.__name__ = "ListConnectionsResponse"
scout_datasource_connection_api_ListConnectionsResponse.__qualname__ = "ListConnectionsResponse"
scout_datasource_connection_api_ListConnectionsResponse.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalChannelNameComponent(ConjureUnionType):
    _channel: Optional["api_Empty"] = None
    _value_of_tag_with_name: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Empty),
            'value_of_tag_with_name': ConjureFieldDefinition('valueOfTagWithName', api_TagName)
        }

    def __init__(
            self,
            channel: Optional["api_Empty"] = None,
            value_of_tag_with_name: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (channel is not None) + (value_of_tag_with_name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if channel is not None:
                self._channel = channel
                self._type = 'channel'
            if value_of_tag_with_name is not None:
                self._value_of_tag_with_name = value_of_tag_with_name
                self._type = 'valueOfTagWithName'

        elif type_of_union == 'channel':
            if channel is None:
                raise ValueError('a union value must not be None')
            self._channel = channel
            self._type = 'channel'
        elif type_of_union == 'valueOfTagWithName':
            if value_of_tag_with_name is None:
                raise ValueError('a union value must not be None')
            self._value_of_tag_with_name = value_of_tag_with_name
            self._type = 'valueOfTagWithName'

    @builtins.property
    def channel(self) -> Optional["api_Empty"]:
        return self._channel

    @builtins.property
    def value_of_tag_with_name(self) -> Optional[str]:
        """The value of the specified TagName will be used. If the tag is not present, it will be omitted.
        """
        return self._value_of_tag_with_name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_NominalChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_NominalChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'channel' and self.channel is not None:
            return visitor._channel(self.channel)
        if self._type == 'valueOfTagWithName' and self.value_of_tag_with_name is not None:
            return visitor._value_of_tag_with_name(self.value_of_tag_with_name)


scout_datasource_connection_api_NominalChannelNameComponent.__name__ = "NominalChannelNameComponent"
scout_datasource_connection_api_NominalChannelNameComponent.__qualname__ = "NominalChannelNameComponent"
scout_datasource_connection_api_NominalChannelNameComponent.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalChannelNameComponentVisitor:

    @abstractmethod
    def _channel(self, channel: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _value_of_tag_with_name(self, value_of_tag_with_name: str) -> Any:
        pass


scout_datasource_connection_api_NominalChannelNameComponentVisitor.__name__ = "NominalChannelNameComponentVisitor"
scout_datasource_connection_api_NominalChannelNameComponentVisitor.__qualname__ = "NominalChannelNameComponentVisitor"
scout_datasource_connection_api_NominalChannelNameComponentVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nominal_data_source_rid': ConjureFieldDefinition('nominalDataSourceRid', api_rids_NominalDataSourceRid)
        }

    __slots__: List[str] = ['_nominal_data_source_rid']

    def __init__(self, nominal_data_source_rid: str) -> None:
        self._nominal_data_source_rid = nominal_data_source_rid

    @builtins.property
    def nominal_data_source_rid(self) -> str:
        return self._nominal_data_source_rid


scout_datasource_connection_api_NominalConnectionDetails.__name__ = "NominalConnectionDetails"
scout_datasource_connection_api_NominalConnectionDetails.__qualname__ = "NominalConnectionDetails"
scout_datasource_connection_api_NominalConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_NominalScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_NominalChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_NominalChannelNameComponent"], separator: str) -> None:
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_NominalChannelNameComponent"]:
        """channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_NominalScrapingConfig.__name__ = "NominalScrapingConfig"
scout_datasource_connection_api_NominalScrapingConfig.__qualname__ = "NominalScrapingConfig"
scout_datasource_connection_api_NominalScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PasswordCredentials(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'username': ConjureFieldDefinition('username', str),
            'password_secret_rid': ConjureFieldDefinition('passwordSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_username', '_password_secret_rid']

    def __init__(self, password_secret_rid: str, username: str) -> None:
        self._username = username
        self._password_secret_rid = password_secret_rid

    @builtins.property
    def username(self) -> str:
        return self._username

    @builtins.property
    def password_secret_rid(self) -> str:
        """Secret Rid of password secret stored in Secrets Service.
        """
        return self._password_secret_rid


scout_datasource_connection_api_PasswordCredentials.__name__ = "PasswordCredentials"
scout_datasource_connection_api_PasswordCredentials.__qualname__ = "PasswordCredentials"
scout_datasource_connection_api_PasswordCredentials.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleChannelNameComponent(ConjureUnionType):
    _table: Optional["api_Empty"] = None
    _name: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', api_Empty),
            'name': ConjureFieldDefinition('name', api_Empty)
        }

    def __init__(
            self,
            table: Optional["api_Empty"] = None,
            name: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) + (name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'
            if name is not None:
                self._name = name
                self._type = 'name'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'
        elif type_of_union == 'name':
            if name is None:
                raise ValueError('a union value must not be None')
            self._name = name
            self._type = 'name'

    @builtins.property
    def table(self) -> Optional["api_Empty"]:
        return self._table

    @builtins.property
    def name(self) -> Optional["api_Empty"]:
        """The value of the name column.
        """
        return self._name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)
        if self._type == 'name' and self.name is not None:
            return visitor._name(self.name)


scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__name__ = "PivotedTimescaleChannelNameComponent"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__qualname__ = "PivotedTimescaleChannelNameComponent"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponent.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor:

    @abstractmethod
    def _table(self, table: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _name(self, name: "api_Empty") -> Any:
        pass


scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__name__ = "PivotedTimescaleChannelNameComponentVisitor"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__qualname__ = "PivotedTimescaleChannelNameComponentVisitor"
scout_datasource_connection_api_PivotedTimescaleChannelNameComponentVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PivotedTimescaleScrapingConfig(ConjureBeanType):
    """This config is used to scrape data from a Timescale database that has a pivoted schema.
time | name           | value | device
 1   | temperature    | 1     | a
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_TimescaleScrapingFilter]),
            'time_column': ConjureFieldDefinition('timeColumn', scout_datasource_connection_api_ColumnName),
            'name_column': ConjureFieldDefinition('nameColumn', scout_datasource_connection_api_ColumnName),
            'value_column': ConjureFieldDefinition('valueColumn', scout_datasource_connection_api_ColumnName),
            'dimension_columns': ConjureFieldDefinition('dimensionColumns', List[scout_datasource_connection_api_ColumnName]),
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_PivotedTimescaleChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str)
        }

    __slots__: List[str] = ['_filter', '_time_column', '_name_column', '_value_column', '_dimension_columns', '_channel_name_components', '_separator']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_PivotedTimescaleChannelNameComponent"], dimension_columns: List[str], filter: List["scout_datasource_connection_api_TimescaleScrapingFilter"], name_column: str, separator: str, time_column: str, value_column: str) -> None:
        self._filter = filter
        self._time_column = time_column
        self._name_column = name_column
        self._value_column = value_column
        self._dimension_columns = dimension_columns
        self._channel_name_components = channel_name_components
        self._separator = separator

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_TimescaleScrapingFilter"]:
        """In order for data to be picked up by the scraper, it must match all
filters in this list. To exclude chunks of data, it's possible to use 
a not filter.
        """
        return self._filter

    @builtins.property
    def time_column(self) -> str:
        """The name of the column that holds the timestamp.
        """
        return self._time_column

    @builtins.property
    def name_column(self) -> str:
        """The name of the column that holds the series name.
        """
        return self._name_column

    @builtins.property
    def value_column(self) -> str:
        """The name of the column that holds the series values.
        """
        return self._value_column

    @builtins.property
    def dimension_columns(self) -> List[str]:
        """The names of the columns that comprise a dimension. They should have a database index for efficient filtering. We do not discover
dimensions based on hypertable schema because they are not necessarily configured properly.
        """
        return self._dimension_columns

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_PivotedTimescaleChannelNameComponent"]:
        """channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator


scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__name__ = "PivotedTimescaleScrapingConfig"
scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__qualname__ = "PivotedTimescaleScrapingConfig"
scout_datasource_connection_api_PivotedTimescaleScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_PopulateSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[str]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_start_time', '_end_time']

    def __init__(self, end_time: Optional[str] = None, start_time: Optional[str] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def start_time(self) -> Optional[str]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional[str]:
        return self._end_time


scout_datasource_connection_api_PopulateSeriesRequest.__name__ = "PopulateSeriesRequest"
scout_datasource_connection_api_PopulateSeriesRequest.__qualname__ = "PopulateSeriesRequest"
scout_datasource_connection_api_PopulateSeriesRequest.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ScrapingConfig(ConjureUnionType):
    _influx: Optional["scout_datasource_connection_api_InfluxScrapingConfig"] = None
    _nominal: Optional["scout_datasource_connection_api_NominalScrapingConfig"] = None
    _timestream: Optional["scout_datasource_connection_api_TimestreamScrapingConfig"] = None
    _timescale: Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"] = None
    _visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"] = None
    _big_query: Optional["scout_datasource_connection_api_BigQueryScrapingConfig"] = None
    _api: Optional["scout_datasource_connection_api_ApiScrapingConfig"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'influx': ConjureFieldDefinition('influx', scout_datasource_connection_api_InfluxScrapingConfig),
            'nominal': ConjureFieldDefinition('nominal', scout_datasource_connection_api_NominalScrapingConfig),
            'timestream': ConjureFieldDefinition('timestream', scout_datasource_connection_api_TimestreamScrapingConfig),
            'timescale': ConjureFieldDefinition('timescale', scout_datasource_connection_api_PivotedTimescaleScrapingConfig),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', scout_datasource_connection_api_VisualCrossingScrapingConfig),
            'big_query': ConjureFieldDefinition('bigQuery', scout_datasource_connection_api_BigQueryScrapingConfig),
            'api': ConjureFieldDefinition('api', scout_datasource_connection_api_ApiScrapingConfig)
        }

    def __init__(
            self,
            influx: Optional["scout_datasource_connection_api_InfluxScrapingConfig"] = None,
            nominal: Optional["scout_datasource_connection_api_NominalScrapingConfig"] = None,
            timestream: Optional["scout_datasource_connection_api_TimestreamScrapingConfig"] = None,
            timescale: Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"] = None,
            visual_crossing: Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"] = None,
            big_query: Optional["scout_datasource_connection_api_BigQueryScrapingConfig"] = None,
            api: Optional["scout_datasource_connection_api_ApiScrapingConfig"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (influx is not None) + (nominal is not None) + (timestream is not None) + (timescale is not None) + (visual_crossing is not None) + (big_query is not None) + (api is not None) != 1:
                raise ValueError('a union must contain a single member')

            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if timescale is not None:
                self._timescale = timescale
                self._type = 'timescale'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'
            if big_query is not None:
                self._big_query = big_query
                self._type = 'bigQuery'
            if api is not None:
                self._api = api
                self._type = 'api'

        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'timescale':
            if timescale is None:
                raise ValueError('a union value must not be None')
            self._timescale = timescale
            self._type = 'timescale'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'
        elif type_of_union == 'bigQuery':
            if big_query is None:
                raise ValueError('a union value must not be None')
            self._big_query = big_query
            self._type = 'bigQuery'
        elif type_of_union == 'api':
            if api is None:
                raise ValueError('a union value must not be None')
            self._api = api
            self._type = 'api'

    @builtins.property
    def influx(self) -> Optional["scout_datasource_connection_api_InfluxScrapingConfig"]:
        return self._influx

    @builtins.property
    def nominal(self) -> Optional["scout_datasource_connection_api_NominalScrapingConfig"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["scout_datasource_connection_api_TimestreamScrapingConfig"]:
        return self._timestream

    @builtins.property
    def timescale(self) -> Optional["scout_datasource_connection_api_PivotedTimescaleScrapingConfig"]:
        return self._timescale

    @builtins.property
    def visual_crossing(self) -> Optional["scout_datasource_connection_api_VisualCrossingScrapingConfig"]:
        return self._visual_crossing

    @builtins.property
    def big_query(self) -> Optional["scout_datasource_connection_api_BigQueryScrapingConfig"]:
        return self._big_query

    @builtins.property
    def api(self) -> Optional["scout_datasource_connection_api_ApiScrapingConfig"]:
        return self._api

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_ScrapingConfigVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_ScrapingConfigVisitor'.format(visitor.__class__.__name__))
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'timescale' and self.timescale is not None:
            return visitor._timescale(self.timescale)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)
        if self._type == 'bigQuery' and self.big_query is not None:
            return visitor._big_query(self.big_query)
        if self._type == 'api' and self.api is not None:
            return visitor._api(self.api)


scout_datasource_connection_api_ScrapingConfig.__name__ = "ScrapingConfig"
scout_datasource_connection_api_ScrapingConfig.__qualname__ = "ScrapingConfig"
scout_datasource_connection_api_ScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_ScrapingConfigVisitor:

    @abstractmethod
    def _influx(self, influx: "scout_datasource_connection_api_InfluxScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "scout_datasource_connection_api_NominalScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "scout_datasource_connection_api_TimestreamScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _timescale(self, timescale: "scout_datasource_connection_api_PivotedTimescaleScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "scout_datasource_connection_api_VisualCrossingScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _big_query(self, big_query: "scout_datasource_connection_api_BigQueryScrapingConfig") -> Any:
        pass

    @abstractmethod
    def _api(self, api: "scout_datasource_connection_api_ApiScrapingConfig") -> Any:
        pass


scout_datasource_connection_api_ScrapingConfigVisitor.__name__ = "ScrapingConfigVisitor"
scout_datasource_connection_api_ScrapingConfigVisitor.__qualname__ = "ScrapingConfigVisitor"
scout_datasource_connection_api_ScrapingConfigVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TemporalUnit(ConjureEnumType):

    HOURS = 'HOURS'
    '''HOURS'''
    DAYS = 'DAYS'
    '''DAYS'''
    WEEKS = 'WEEKS'
    '''WEEKS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datasource_connection_api_TemporalUnit.__name__ = "TemporalUnit"
scout_datasource_connection_api_TemporalUnit.__qualname__ = "TemporalUnit"
scout_datasource_connection_api_TemporalUnit.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', str),
            'host': ConjureFieldDefinition('host', str),
            'port': ConjureFieldDefinition('port', int),
            'username': ConjureFieldDefinition('username', str),
            'password_secret_rid': ConjureFieldDefinition('passwordSecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_database', '_host', '_port', '_username', '_password_secret_rid']

    def __init__(self, database: str, host: str, password_secret_rid: str, port: int, username: str) -> None:
        self._database = database
        self._host = host
        self._port = port
        self._username = username
        self._password_secret_rid = password_secret_rid

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def host(self) -> str:
        return self._host

    @builtins.property
    def port(self) -> int:
        return self._port

    @builtins.property
    def username(self) -> str:
        """This is also the reference to the secret containing the password
        """
        return self._username

    @builtins.property
    def password_secret_rid(self) -> str:
        """Secret Rid of password secret stored in Secrets Service.
        """
        return self._password_secret_rid


scout_datasource_connection_api_TimescaleConnectionDetails.__name__ = "TimescaleConnectionDetails"
scout_datasource_connection_api_TimescaleConnectionDetails.__qualname__ = "TimescaleConnectionDetails"
scout_datasource_connection_api_TimescaleConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleScrapingFilter(ConjureUnionType):
    _not_: Optional["scout_datasource_connection_api_TimescaleScrapingFilter"] = None
    _match_table: Optional[List[str]] = None
    _match_schema: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'not_': ConjureFieldDefinition('not', scout_datasource_connection_api_TimescaleScrapingFilter),
            'match_table': ConjureFieldDefinition('matchTable', List[scout_datasource_connection_api_TableName]),
            'match_schema': ConjureFieldDefinition('matchSchema', List[scout_datasource_connection_api_SchemaName])
        }

    def __init__(
            self,
            not_: Optional["scout_datasource_connection_api_TimescaleScrapingFilter"] = None,
            match_table: Optional[List[str]] = None,
            match_schema: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (not_ is not None) + (match_table is not None) + (match_schema is not None) != 1:
                raise ValueError('a union must contain a single member')

            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if match_table is not None:
                self._match_table = match_table
                self._type = 'matchTable'
            if match_schema is not None:
                self._match_schema = match_schema
                self._type = 'matchSchema'

        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'matchTable':
            if match_table is None:
                raise ValueError('a union value must not be None')
            self._match_table = match_table
            self._type = 'matchTable'
        elif type_of_union == 'matchSchema':
            if match_schema is None:
                raise ValueError('a union value must not be None')
            self._match_schema = match_schema
            self._type = 'matchSchema'

    @builtins.property
    def not_(self) -> Optional["scout_datasource_connection_api_TimescaleScrapingFilter"]:
        return self._not_

    @builtins.property
    def match_table(self) -> Optional[List[str]]:
        """Match any of the specified tables in the database.
        """
        return self._match_table

    @builtins.property
    def match_schema(self) -> Optional[List[str]]:
        """Match any of the specified schemas in the database.
        """
        return self._match_schema

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimescaleScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimescaleScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'matchTable' and self.match_table is not None:
            return visitor._match_table(self.match_table)
        if self._type == 'matchSchema' and self.match_schema is not None:
            return visitor._match_schema(self.match_schema)


scout_datasource_connection_api_TimescaleScrapingFilter.__name__ = "TimescaleScrapingFilter"
scout_datasource_connection_api_TimescaleScrapingFilter.__qualname__ = "TimescaleScrapingFilter"
scout_datasource_connection_api_TimescaleScrapingFilter.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimescaleScrapingFilterVisitor:

    @abstractmethod
    def _not(self, not_: "scout_datasource_connection_api_TimescaleScrapingFilter") -> Any:
        pass

    @abstractmethod
    def _match_table(self, match_table: List[str]) -> Any:
        pass

    @abstractmethod
    def _match_schema(self, match_schema: List[str]) -> Any:
        pass


scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__name__ = "TimescaleScrapingFilterVisitor"
scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__qualname__ = "TimescaleScrapingFilterVisitor"
scout_datasource_connection_api_TimescaleScrapingFilterVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamChannelNameComponent(ConjureUnionType):
    _table: Optional["api_Empty"] = None
    _measure: Optional["api_Empty"] = None
    _attribute: Optional["api_Empty"] = None
    _value_of_tag_with_name: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', api_Empty),
            'measure': ConjureFieldDefinition('measure', api_Empty),
            'attribute': ConjureFieldDefinition('attribute', api_Empty),
            'value_of_tag_with_name': ConjureFieldDefinition('valueOfTagWithName', api_TagName)
        }

    def __init__(
            self,
            table: Optional["api_Empty"] = None,
            measure: Optional["api_Empty"] = None,
            attribute: Optional["api_Empty"] = None,
            value_of_tag_with_name: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (table is not None) + (measure is not None) + (attribute is not None) + (value_of_tag_with_name is not None) != 1:
                raise ValueError('a union must contain a single member')

            if table is not None:
                self._table = table
                self._type = 'table'
            if measure is not None:
                self._measure = measure
                self._type = 'measure'
            if attribute is not None:
                self._attribute = attribute
                self._type = 'attribute'
            if value_of_tag_with_name is not None:
                self._value_of_tag_with_name = value_of_tag_with_name
                self._type = 'valueOfTagWithName'

        elif type_of_union == 'table':
            if table is None:
                raise ValueError('a union value must not be None')
            self._table = table
            self._type = 'table'
        elif type_of_union == 'measure':
            if measure is None:
                raise ValueError('a union value must not be None')
            self._measure = measure
            self._type = 'measure'
        elif type_of_union == 'attribute':
            if attribute is None:
                raise ValueError('a union value must not be None')
            self._attribute = attribute
            self._type = 'attribute'
        elif type_of_union == 'valueOfTagWithName':
            if value_of_tag_with_name is None:
                raise ValueError('a union value must not be None')
            self._value_of_tag_with_name = value_of_tag_with_name
            self._type = 'valueOfTagWithName'

    @builtins.property
    def table(self) -> Optional["api_Empty"]:
        return self._table

    @builtins.property
    def measure(self) -> Optional["api_Empty"]:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional["api_Empty"]:
        return self._attribute

    @builtins.property
    def value_of_tag_with_name(self) -> Optional[str]:
        """The value of the specified TagName will be used. If the tag is not present, it will be omitted.
        """
        return self._value_of_tag_with_name

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimestreamChannelNameComponentVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimestreamChannelNameComponentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'table' and self.table is not None:
            return visitor._table(self.table)
        if self._type == 'measure' and self.measure is not None:
            return visitor._measure(self.measure)
        if self._type == 'attribute' and self.attribute is not None:
            return visitor._attribute(self.attribute)
        if self._type == 'valueOfTagWithName' and self.value_of_tag_with_name is not None:
            return visitor._value_of_tag_with_name(self.value_of_tag_with_name)


scout_datasource_connection_api_TimestreamChannelNameComponent.__name__ = "TimestreamChannelNameComponent"
scout_datasource_connection_api_TimestreamChannelNameComponent.__qualname__ = "TimestreamChannelNameComponent"
scout_datasource_connection_api_TimestreamChannelNameComponent.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamChannelNameComponentVisitor:

    @abstractmethod
    def _table(self, table: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _measure(self, measure: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _attribute(self, attribute: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _value_of_tag_with_name(self, value_of_tag_with_name: str) -> Any:
        pass


scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__name__ = "TimestreamChannelNameComponentVisitor"
scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__qualname__ = "TimestreamChannelNameComponentVisitor"
scout_datasource_connection_api_TimestreamChannelNameComponentVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'nominal_role_arn': ConjureFieldDefinition('nominalRoleArn', str),
            'nominal_role_region': ConjureFieldDefinition('nominalRoleRegion', str),
            'external_region': ConjureFieldDefinition('externalRegion', str),
            'external_role_arn': ConjureFieldDefinition('externalRoleArn', str),
            'database': ConjureFieldDefinition('database', str)
        }

    __slots__: List[str] = ['_nominal_role_arn', '_nominal_role_region', '_external_region', '_external_role_arn', '_database']

    def __init__(self, database: str, external_region: str, external_role_arn: str, nominal_role_arn: str, nominal_role_region: str) -> None:
        self._nominal_role_arn = nominal_role_arn
        self._nominal_role_region = nominal_role_region
        self._external_region = external_region
        self._external_role_arn = external_role_arn
        self._database = database

    @builtins.property
    def nominal_role_arn(self) -> str:
        """The role ARN owned by Nominal that has permission to assume the externalRoleArn.
        """
        return self._nominal_role_arn

    @builtins.property
    def nominal_role_region(self) -> str:
        """AWS region that contains the Nominal role.
        """
        return self._nominal_role_region

    @builtins.property
    def external_region(self) -> str:
        """AWS region that contains the Timestream instance.
        """
        return self._external_region

    @builtins.property
    def external_role_arn(self) -> str:
        """The role ARN used to make queries to Timestream. This role is owned by the AWS account that owns the Timestream instance.
        """
        return self._external_role_arn

    @builtins.property
    def database(self) -> str:
        """Database inside of the Timestream instance to connect to.
        """
        return self._database


scout_datasource_connection_api_TimestreamConnectionDetails.__name__ = "TimestreamConnectionDetails"
scout_datasource_connection_api_TimestreamConnectionDetails.__qualname__ = "TimestreamConnectionDetails"
scout_datasource_connection_api_TimestreamConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'filter': ConjureFieldDefinition('filter', List[scout_datasource_connection_api_TimestreamScrapingFilter]),
            'channel_name_components': ConjureFieldDefinition('channelNameComponents', List[scout_datasource_connection_api_TimestreamChannelNameComponent]),
            'separator': ConjureFieldDefinition('separator', str),
            'max_look_back_period_hours': ConjureFieldDefinition('maxLookBackPeriodHours', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_filter', '_channel_name_components', '_separator', '_max_look_back_period_hours']

    def __init__(self, channel_name_components: List["scout_datasource_connection_api_TimestreamChannelNameComponent"], filter: List["scout_datasource_connection_api_TimestreamScrapingFilter"], separator: str, max_look_back_period_hours: Optional[int] = None) -> None:
        self._filter = filter
        self._channel_name_components = channel_name_components
        self._separator = separator
        self._max_look_back_period_hours = max_look_back_period_hours

    @builtins.property
    def filter(self) -> List["scout_datasource_connection_api_TimestreamScrapingFilter"]:
        """In order for data to be picked up by the scraper, it must match all
filters in this list.
        """
        return self._filter

    @builtins.property
    def channel_name_components(self) -> List["scout_datasource_connection_api_TimestreamChannelNameComponent"]:
        """channelNameComponents will be combined, together with separator, to form
a fully qualified channel name.
        """
        return self._channel_name_components

    @builtins.property
    def separator(self) -> str:
        return self._separator

    @builtins.property
    def max_look_back_period_hours(self) -> Optional[int]:
        """The maximum time in hours to look back over series data to find unique measure and tag combinations.
If not specified, the default look back period will be used.
        """
        return self._max_look_back_period_hours


scout_datasource_connection_api_TimestreamScrapingConfig.__name__ = "TimestreamScrapingConfig"
scout_datasource_connection_api_TimestreamScrapingConfig.__qualname__ = "TimestreamScrapingConfig"
scout_datasource_connection_api_TimestreamScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingFilter(ConjureUnionType):
    _match_table: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'match_table': ConjureFieldDefinition('matchTable', List[scout_datasource_connection_api_TableName])
        }

    def __init__(
            self,
            match_table: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (match_table is not None) != 1:
                raise ValueError('a union must contain a single member')

            if match_table is not None:
                self._match_table = match_table
                self._type = 'matchTable'

        elif type_of_union == 'matchTable':
            if match_table is None:
                raise ValueError('a union value must not be None')
            self._match_table = match_table
            self._type = 'matchTable'

    @builtins.property
    def match_table(self) -> Optional[List[str]]:
        """Match any of the specified tables in the database.
        """
        return self._match_table

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_datasource_connection_api_TimestreamScrapingFilterVisitor):
            raise ValueError('{} is not an instance of scout_datasource_connection_api_TimestreamScrapingFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'matchTable' and self.match_table is not None:
            return visitor._match_table(self.match_table)


scout_datasource_connection_api_TimestreamScrapingFilter.__name__ = "TimestreamScrapingFilter"
scout_datasource_connection_api_TimestreamScrapingFilter.__qualname__ = "TimestreamScrapingFilter"
scout_datasource_connection_api_TimestreamScrapingFilter.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_TimestreamScrapingFilterVisitor:

    @abstractmethod
    def _match_table(self, match_table: List[str]) -> Any:
        pass


scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__name__ = "TimestreamScrapingFilterVisitor"
scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__qualname__ = "TimestreamScrapingFilterVisitor"
scout_datasource_connection_api_TimestreamScrapingFilterVisitor.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_UpdateConnectionRequest(ConjureBeanType):
    """Fields that are empty will be treated as a no-op update.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'metadata': ConjureFieldDefinition('metadata', OptionalTypeWrapper[Dict[str, str]]),
            'connection_details': ConjureFieldDefinition('connectionDetails', OptionalTypeWrapper[scout_datasource_connection_api_ConnectionDetails]),
            'required_tag_names': ConjureFieldDefinition('requiredTagNames', OptionalTypeWrapper[List[api_TagName]]),
            'available_tag_values': ConjureFieldDefinition('availableTagValues', OptionalTypeWrapper[Dict[api_TagName, List[api_TagValue]]]),
            'scraping': ConjureFieldDefinition('scraping', OptionalTypeWrapper[scout_datasource_connection_api_ScrapingConfig]),
            'should_scrape': ConjureFieldDefinition('shouldScrape', OptionalTypeWrapper[bool]),
            'limits': ConjureFieldDefinition('limits', OptionalTypeWrapper[scout_datasource_connection_api_LimitsConfig])
        }

    __slots__: List[str] = ['_name', '_description', '_metadata', '_connection_details', '_required_tag_names', '_available_tag_values', '_scraping', '_should_scrape', '_limits']

    def __init__(self, available_tag_values: Optional[Dict[str, List[str]]] = None, connection_details: Optional["scout_datasource_connection_api_ConnectionDetails"] = None, description: Optional[str] = None, limits: Optional["scout_datasource_connection_api_LimitsConfig"] = None, metadata: Optional[Dict[str, str]] = None, name: Optional[str] = None, required_tag_names: Optional[List[str]] = None, scraping: Optional["scout_datasource_connection_api_ScrapingConfig"] = None, should_scrape: Optional[bool] = None) -> None:
        self._name = name
        self._description = description
        self._metadata = metadata
        self._connection_details = connection_details
        self._required_tag_names = required_tag_names
        self._available_tag_values = available_tag_values
        self._scraping = scraping
        self._should_scrape = should_scrape
        self._limits = limits

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def metadata(self) -> Optional[Dict[str, str]]:
        return self._metadata

    @builtins.property
    def connection_details(self) -> Optional["scout_datasource_connection_api_ConnectionDetails"]:
        return self._connection_details

    @builtins.property
    def required_tag_names(self) -> Optional[List[str]]:
        return self._required_tag_names

    @builtins.property
    def available_tag_values(self) -> Optional[Dict[str, List[str]]]:
        """In most cases, this does not to be set by the user. Throws if populated for Nominal connections, which 
have their tags automatically indexed in the underlying database. Tags for external connections are 
periodically scraped. Tags should only be updated manually for Visual crossing connections.
        """
        return self._available_tag_values

    @builtins.property
    def scraping(self) -> Optional["scout_datasource_connection_api_ScrapingConfig"]:
        return self._scraping

    @builtins.property
    def should_scrape(self) -> Optional[bool]:
        return self._should_scrape

    @builtins.property
    def limits(self) -> Optional["scout_datasource_connection_api_LimitsConfig"]:
        return self._limits


scout_datasource_connection_api_UpdateConnectionRequest.__name__ = "UpdateConnectionRequest"
scout_datasource_connection_api_UpdateConnectionRequest.__qualname__ = "UpdateConnectionRequest"
scout_datasource_connection_api_UpdateConnectionRequest.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingAvailableSeries(ConjureBeanType):
    """Deprecated and not used for anything anymore, see record VisualCrossingAvailableSeries instead.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'type': ConjureFieldDefinition('type', scout_datasource_connection_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_channel', '_unit', '_description', '_type']

    def __init__(self, channel: str, type: "scout_datasource_connection_api_VisualCrossingType", description: Optional[str] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._unit = unit
        self._description = description
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def type(self) -> "scout_datasource_connection_api_VisualCrossingType":
        return self._type


scout_datasource_connection_api_VisualCrossingAvailableSeries.__name__ = "VisualCrossingAvailableSeries"
scout_datasource_connection_api_VisualCrossingAvailableSeries.__qualname__ = "VisualCrossingAvailableSeries"
scout_datasource_connection_api_VisualCrossingAvailableSeries.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingConnectionDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key_secret_rid': ConjureFieldDefinition('apiKeySecretRid', scout_datasource_connection_api_SecretRid)
        }

    __slots__: List[str] = ['_api_key_secret_rid']

    def __init__(self, api_key_secret_rid: str) -> None:
        self._api_key_secret_rid = api_key_secret_rid

    @builtins.property
    def api_key_secret_rid(self) -> str:
        """Secret Rid of API key stored in Secrets Service.
        """
        return self._api_key_secret_rid


scout_datasource_connection_api_VisualCrossingConnectionDetails.__name__ = "VisualCrossingConnectionDetails"
scout_datasource_connection_api_VisualCrossingConnectionDetails.__qualname__ = "VisualCrossingConnectionDetails"
scout_datasource_connection_api_VisualCrossingConnectionDetails.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingScrapingConfig(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'available_series': ConjureFieldDefinition('availableSeries', List[scout_datasource_connection_api_VisualCrossingAvailableSeries])
        }

    __slots__: List[str] = ['_available_series']

    def __init__(self, available_series: List["scout_datasource_connection_api_VisualCrossingAvailableSeries"]) -> None:
        self._available_series = available_series

    @builtins.property
    def available_series(self) -> List["scout_datasource_connection_api_VisualCrossingAvailableSeries"]:
        """list of available channels
        """
        return self._available_series


scout_datasource_connection_api_VisualCrossingScrapingConfig.__name__ = "VisualCrossingScrapingConfig"
scout_datasource_connection_api_VisualCrossingScrapingConfig.__qualname__ = "VisualCrossingScrapingConfig"
scout_datasource_connection_api_VisualCrossingScrapingConfig.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_datasource_connection_api_VisualCrossingType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_datasource_connection_api_VisualCrossingType.__name__ = "VisualCrossingType"
scout_datasource_connection_api_VisualCrossingType.__qualname__ = "VisualCrossingType"
scout_datasource_connection_api_VisualCrossingType.__module__ = "nominal_api.scout_datasource_connection_api"


class scout_favorites_FavoritesService(Service):
    """Creating favorites allows users to pin specific resources (i.e. assets, workbooks, etc.) as favorites for 
quick access within search pages throughout the application for themselves.
    """

    def get_favorites_list(self, auth_header: str, workspace_rid: str, resource_types: List["scout_favorites_api_ResourceType"] = None) -> "scout_favorites_api_FavoritesListResponse":
        """Retrieves the favorites list for the current user in the specified workspace.
        """
        resource_types = resource_types if resource_types is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'resourceTypes': _conjure_encoder.default(resource_types),
        }

        _path_params: Dict[str, str] = {
            'workspaceRid': quote(str(_conjure_encoder.default(workspace_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/favorites/workspace/{workspaceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_favorites_api_FavoritesListResponse, self._return_none_for_unknown_union_types)

    def set_favorites_list(self, auth_header: str, request: "scout_favorites_api_SetFavoritesListRequest", workspace_rid: str) -> "scout_favorites_api_FavoritesListResponse":
        """Overwrites the favorites list for the current user in the specified workspace.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'workspaceRid': quote(str(_conjure_encoder.default(workspace_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/favorites/workspace/{workspaceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_favorites_api_FavoritesListResponse, self._return_none_for_unknown_union_types)


scout_favorites_FavoritesService.__name__ = "FavoritesService"
scout_favorites_FavoritesService.__qualname__ = "FavoritesService"
scout_favorites_FavoritesService.__module__ = "nominal_api.scout_favorites"


class scout_favorites_api_FavoriteResource(ConjureUnionType):
    _asset: Optional[str] = None
    _run: Optional[str] = None
    _notebook: Optional[str] = None
    _notebook_template: Optional[str] = None
    _checklist: Optional[str] = None
    _saved_view: Optional[str] = None
    _procedure: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'run': ConjureFieldDefinition('run', scout_run_api_RunRid),
            'notebook': ConjureFieldDefinition('notebook', scout_rids_api_NotebookRid),
            'notebook_template': ConjureFieldDefinition('notebookTemplate', scout_rids_api_TemplateRid),
            'checklist': ConjureFieldDefinition('checklist', scout_rids_api_ChecklistRid),
            'saved_view': ConjureFieldDefinition('savedView', scout_rids_api_SavedViewRid),
            'procedure': ConjureFieldDefinition('procedure', api_rids_ProcedureRid)
        }

    def __init__(
            self,
            asset: Optional[str] = None,
            run: Optional[str] = None,
            notebook: Optional[str] = None,
            notebook_template: Optional[str] = None,
            checklist: Optional[str] = None,
            saved_view: Optional[str] = None,
            procedure: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (asset is not None) + (run is not None) + (notebook is not None) + (notebook_template is not None) + (checklist is not None) + (saved_view is not None) + (procedure is not None) != 1:
                raise ValueError('a union must contain a single member')

            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if run is not None:
                self._run = run
                self._type = 'run'
            if notebook is not None:
                self._notebook = notebook
                self._type = 'notebook'
            if notebook_template is not None:
                self._notebook_template = notebook_template
                self._type = 'notebookTemplate'
            if checklist is not None:
                self._checklist = checklist
                self._type = 'checklist'
            if saved_view is not None:
                self._saved_view = saved_view
                self._type = 'savedView'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'

        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'run':
            if run is None:
                raise ValueError('a union value must not be None')
            self._run = run
            self._type = 'run'
        elif type_of_union == 'notebook':
            if notebook is None:
                raise ValueError('a union value must not be None')
            self._notebook = notebook
            self._type = 'notebook'
        elif type_of_union == 'notebookTemplate':
            if notebook_template is None:
                raise ValueError('a union value must not be None')
            self._notebook_template = notebook_template
            self._type = 'notebookTemplate'
        elif type_of_union == 'checklist':
            if checklist is None:
                raise ValueError('a union value must not be None')
            self._checklist = checklist
            self._type = 'checklist'
        elif type_of_union == 'savedView':
            if saved_view is None:
                raise ValueError('a union value must not be None')
            self._saved_view = saved_view
            self._type = 'savedView'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def run(self) -> Optional[str]:
        return self._run

    @builtins.property
    def notebook(self) -> Optional[str]:
        return self._notebook

    @builtins.property
    def notebook_template(self) -> Optional[str]:
        return self._notebook_template

    @builtins.property
    def checklist(self) -> Optional[str]:
        return self._checklist

    @builtins.property
    def saved_view(self) -> Optional[str]:
        return self._saved_view

    @builtins.property
    def procedure(self) -> Optional[str]:
        return self._procedure

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_favorites_api_FavoriteResourceVisitor):
            raise ValueError('{} is not an instance of scout_favorites_api_FavoriteResourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'run' and self.run is not None:
            return visitor._run(self.run)
        if self._type == 'notebook' and self.notebook is not None:
            return visitor._notebook(self.notebook)
        if self._type == 'notebookTemplate' and self.notebook_template is not None:
            return visitor._notebook_template(self.notebook_template)
        if self._type == 'checklist' and self.checklist is not None:
            return visitor._checklist(self.checklist)
        if self._type == 'savedView' and self.saved_view is not None:
            return visitor._saved_view(self.saved_view)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)


scout_favorites_api_FavoriteResource.__name__ = "FavoriteResource"
scout_favorites_api_FavoriteResource.__qualname__ = "FavoriteResource"
scout_favorites_api_FavoriteResource.__module__ = "nominal_api.scout_favorites_api"


class scout_favorites_api_FavoriteResourceVisitor:

    @abstractmethod
    def _asset(self, asset: str) -> Any:
        pass

    @abstractmethod
    def _run(self, run: str) -> Any:
        pass

    @abstractmethod
    def _notebook(self, notebook: str) -> Any:
        pass

    @abstractmethod
    def _notebook_template(self, notebook_template: str) -> Any:
        pass

    @abstractmethod
    def _checklist(self, checklist: str) -> Any:
        pass

    @abstractmethod
    def _saved_view(self, saved_view: str) -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: str) -> Any:
        pass


scout_favorites_api_FavoriteResourceVisitor.__name__ = "FavoriteResourceVisitor"
scout_favorites_api_FavoriteResourceVisitor.__qualname__ = "FavoriteResourceVisitor"
scout_favorites_api_FavoriteResourceVisitor.__module__ = "nominal_api.scout_favorites_api"


class scout_favorites_api_FavoritesListResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'favorites': ConjureFieldDefinition('favorites', List[scout_favorites_api_FavoriteResource])
        }

    __slots__: List[str] = ['_favorites']

    def __init__(self, favorites: List["scout_favorites_api_FavoriteResource"]) -> None:
        self._favorites = favorites

    @builtins.property
    def favorites(self) -> List["scout_favorites_api_FavoriteResource"]:
        return self._favorites


scout_favorites_api_FavoritesListResponse.__name__ = "FavoritesListResponse"
scout_favorites_api_FavoritesListResponse.__qualname__ = "FavoritesListResponse"
scout_favorites_api_FavoritesListResponse.__module__ = "nominal_api.scout_favorites_api"


class scout_favorites_api_ResourceType(ConjureEnumType):

    ASSET = 'ASSET'
    '''ASSET'''
    RUN = 'RUN'
    '''RUN'''
    NOTEBOOK = 'NOTEBOOK'
    '''NOTEBOOK'''
    NOTEBOOK_TEMPLATE = 'NOTEBOOK_TEMPLATE'
    '''NOTEBOOK_TEMPLATE'''
    CHECKLIST = 'CHECKLIST'
    '''CHECKLIST'''
    SAVED_VIEW = 'SAVED_VIEW'
    '''SAVED_VIEW'''
    PROCEDURE = 'PROCEDURE'
    '''PROCEDURE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_favorites_api_ResourceType.__name__ = "ResourceType"
scout_favorites_api_ResourceType.__qualname__ = "ResourceType"
scout_favorites_api_ResourceType.__module__ = "nominal_api.scout_favorites_api"


class scout_favorites_api_SetFavoritesListRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resources': ConjureFieldDefinition('resources', List[scout_favorites_api_FavoriteResource])
        }

    __slots__: List[str] = ['_resources']

    def __init__(self, resources: List["scout_favorites_api_FavoriteResource"]) -> None:
        self._resources = resources

    @builtins.property
    def resources(self) -> List["scout_favorites_api_FavoriteResource"]:
        """The resources to set as the user's favorites. Note that the provided list will overwrite 
all the user's previous favorites.
        """
        return self._resources


scout_favorites_api_SetFavoritesListRequest.__name__ = "SetFavoritesListRequest"
scout_favorites_api_SetFavoritesListRequest.__qualname__ = "SetFavoritesListRequest"
scout_favorites_api_SetFavoritesListRequest.__module__ = "nominal_api.scout_favorites_api"


class scout_integrations_api_AlertMessageFields(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_title': ConjureFieldDefinition('assetTitle', str),
            'check_title': ConjureFieldDefinition('checkTitle', str),
            'check_description': ConjureFieldDefinition('checkDescription', str),
            'checklist_title': ConjureFieldDefinition('checklistTitle', str),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'check_lineage_rid': ConjureFieldDefinition('checkLineageRid', scout_rids_api_CheckLineageRid),
            'workbook_url': ConjureFieldDefinition('workbookUrl', OptionalTypeWrapper[str]),
            'alert_url': ConjureFieldDefinition('alertUrl', OptionalTypeWrapper[str]),
            'event_type': ConjureFieldDefinition('eventType', event_EventType),
            'priority': ConjureFieldDefinition('priority', scout_api_Priority),
            'labels': ConjureFieldDefinition('labels', List[str]),
            'alert_type': ConjureFieldDefinition('alertType', scout_integrations_api_AlertType)
        }

    __slots__: List[str] = ['_asset_title', '_check_title', '_check_description', '_checklist_title', '_asset_rid', '_check_lineage_rid', '_workbook_url', '_alert_url', '_event_type', '_priority', '_labels', '_alert_type']

    def __init__(self, alert_type: "scout_integrations_api_AlertType", asset_rid: str, asset_title: str, check_description: str, check_lineage_rid: str, check_title: str, checklist_title: str, event_type: "event_EventType", labels: List[str], priority: "scout_api_Priority", alert_url: Optional[str] = None, workbook_url: Optional[str] = None) -> None:
        self._asset_title = asset_title
        self._check_title = check_title
        self._check_description = check_description
        self._checklist_title = checklist_title
        self._asset_rid = asset_rid
        self._check_lineage_rid = check_lineage_rid
        self._workbook_url = workbook_url
        self._alert_url = alert_url
        self._event_type = event_type
        self._priority = priority
        self._labels = labels
        self._alert_type = alert_type

    @builtins.property
    def asset_title(self) -> str:
        return self._asset_title

    @builtins.property
    def check_title(self) -> str:
        return self._check_title

    @builtins.property
    def check_description(self) -> str:
        return self._check_description

    @builtins.property
    def checklist_title(self) -> str:
        return self._checklist_title

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def check_lineage_rid(self) -> str:
        return self._check_lineage_rid

    @builtins.property
    def workbook_url(self) -> Optional[str]:
        """Appended to the end of the message as a button (if supported) or as a text hyperlink.
        """
        return self._workbook_url

    @builtins.property
    def alert_url(self) -> Optional[str]:
        """Appended to the end of the message as a button (if supported) or as a text hyperlink.
        """
        return self._alert_url

    @builtins.property
    def event_type(self) -> "event_EventType":
        """Will be prefixed in title and indicated by an icon.
        """
        return self._event_type

    @builtins.property
    def priority(self) -> "scout_api_Priority":
        return self._priority

    @builtins.property
    def labels(self) -> List[str]:
        """Currently exposed as 'tags' on the frontend to match Opsgenie naming. Used by some integrations to filter/route messages.
        """
        return self._labels

    @builtins.property
    def alert_type(self) -> "scout_integrations_api_AlertType":
        """Determines execution status of the alert, between success, failure, and execution error.
        """
        return self._alert_type


scout_integrations_api_AlertMessageFields.__name__ = "AlertMessageFields"
scout_integrations_api_AlertMessageFields.__qualname__ = "AlertMessageFields"
scout_integrations_api_AlertMessageFields.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_AlertType(ConjureEnumType):

    INVALID = 'INVALID'
    '''INVALID'''
    FAILURE = 'FAILURE'
    '''FAILURE'''
    RECOVERY = 'RECOVERY'
    '''RECOVERY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_integrations_api_AlertType.__name__ = "AlertType"
scout_integrations_api_AlertType.__qualname__ = "AlertType"
scout_integrations_api_AlertType.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateIntegrationDetails(ConjureUnionType):
    _create_simple_webhook_details: Optional["scout_integrations_api_CreateSimpleWebhookDetails"] = None
    _create_opsgenie_integration_details: Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"] = None
    _create_teams_webhook_integration_details: Optional["scout_integrations_api_CreateTeamsWebhookIntegrationDetails"] = None
    _create_pager_duty_integration_details: Optional["scout_integrations_api_CreatePagerDutyIntegrationDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_simple_webhook_details': ConjureFieldDefinition('createSimpleWebhookDetails', scout_integrations_api_CreateSimpleWebhookDetails),
            'create_opsgenie_integration_details': ConjureFieldDefinition('createOpsgenieIntegrationDetails', scout_integrations_api_CreateOpsgenieIntegrationDetails),
            'create_teams_webhook_integration_details': ConjureFieldDefinition('createTeamsWebhookIntegrationDetails', scout_integrations_api_CreateTeamsWebhookIntegrationDetails),
            'create_pager_duty_integration_details': ConjureFieldDefinition('createPagerDutyIntegrationDetails', scout_integrations_api_CreatePagerDutyIntegrationDetails)
        }

    def __init__(
            self,
            create_simple_webhook_details: Optional["scout_integrations_api_CreateSimpleWebhookDetails"] = None,
            create_opsgenie_integration_details: Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"] = None,
            create_teams_webhook_integration_details: Optional["scout_integrations_api_CreateTeamsWebhookIntegrationDetails"] = None,
            create_pager_duty_integration_details: Optional["scout_integrations_api_CreatePagerDutyIntegrationDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (create_simple_webhook_details is not None) + (create_opsgenie_integration_details is not None) + (create_teams_webhook_integration_details is not None) + (create_pager_duty_integration_details is not None) != 1:
                raise ValueError('a union must contain a single member')

            if create_simple_webhook_details is not None:
                self._create_simple_webhook_details = create_simple_webhook_details
                self._type = 'createSimpleWebhookDetails'
            if create_opsgenie_integration_details is not None:
                self._create_opsgenie_integration_details = create_opsgenie_integration_details
                self._type = 'createOpsgenieIntegrationDetails'
            if create_teams_webhook_integration_details is not None:
                self._create_teams_webhook_integration_details = create_teams_webhook_integration_details
                self._type = 'createTeamsWebhookIntegrationDetails'
            if create_pager_duty_integration_details is not None:
                self._create_pager_duty_integration_details = create_pager_duty_integration_details
                self._type = 'createPagerDutyIntegrationDetails'

        elif type_of_union == 'createSimpleWebhookDetails':
            if create_simple_webhook_details is None:
                raise ValueError('a union value must not be None')
            self._create_simple_webhook_details = create_simple_webhook_details
            self._type = 'createSimpleWebhookDetails'
        elif type_of_union == 'createOpsgenieIntegrationDetails':
            if create_opsgenie_integration_details is None:
                raise ValueError('a union value must not be None')
            self._create_opsgenie_integration_details = create_opsgenie_integration_details
            self._type = 'createOpsgenieIntegrationDetails'
        elif type_of_union == 'createTeamsWebhookIntegrationDetails':
            if create_teams_webhook_integration_details is None:
                raise ValueError('a union value must not be None')
            self._create_teams_webhook_integration_details = create_teams_webhook_integration_details
            self._type = 'createTeamsWebhookIntegrationDetails'
        elif type_of_union == 'createPagerDutyIntegrationDetails':
            if create_pager_duty_integration_details is None:
                raise ValueError('a union value must not be None')
            self._create_pager_duty_integration_details = create_pager_duty_integration_details
            self._type = 'createPagerDutyIntegrationDetails'

    @builtins.property
    def create_simple_webhook_details(self) -> Optional["scout_integrations_api_CreateSimpleWebhookDetails"]:
        return self._create_simple_webhook_details

    @builtins.property
    def create_opsgenie_integration_details(self) -> Optional["scout_integrations_api_CreateOpsgenieIntegrationDetails"]:
        return self._create_opsgenie_integration_details

    @builtins.property
    def create_teams_webhook_integration_details(self) -> Optional["scout_integrations_api_CreateTeamsWebhookIntegrationDetails"]:
        return self._create_teams_webhook_integration_details

    @builtins.property
    def create_pager_duty_integration_details(self) -> Optional["scout_integrations_api_CreatePagerDutyIntegrationDetails"]:
        return self._create_pager_duty_integration_details

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_CreateIntegrationDetailsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_CreateIntegrationDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'createSimpleWebhookDetails' and self.create_simple_webhook_details is not None:
            return visitor._create_simple_webhook_details(self.create_simple_webhook_details)
        if self._type == 'createOpsgenieIntegrationDetails' and self.create_opsgenie_integration_details is not None:
            return visitor._create_opsgenie_integration_details(self.create_opsgenie_integration_details)
        if self._type == 'createTeamsWebhookIntegrationDetails' and self.create_teams_webhook_integration_details is not None:
            return visitor._create_teams_webhook_integration_details(self.create_teams_webhook_integration_details)
        if self._type == 'createPagerDutyIntegrationDetails' and self.create_pager_duty_integration_details is not None:
            return visitor._create_pager_duty_integration_details(self.create_pager_duty_integration_details)


scout_integrations_api_CreateIntegrationDetails.__name__ = "CreateIntegrationDetails"
scout_integrations_api_CreateIntegrationDetails.__qualname__ = "CreateIntegrationDetails"
scout_integrations_api_CreateIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateIntegrationDetailsVisitor:

    @abstractmethod
    def _create_simple_webhook_details(self, create_simple_webhook_details: "scout_integrations_api_CreateSimpleWebhookDetails") -> Any:
        pass

    @abstractmethod
    def _create_opsgenie_integration_details(self, create_opsgenie_integration_details: "scout_integrations_api_CreateOpsgenieIntegrationDetails") -> Any:
        pass

    @abstractmethod
    def _create_teams_webhook_integration_details(self, create_teams_webhook_integration_details: "scout_integrations_api_CreateTeamsWebhookIntegrationDetails") -> Any:
        pass

    @abstractmethod
    def _create_pager_duty_integration_details(self, create_pager_duty_integration_details: "scout_integrations_api_CreatePagerDutyIntegrationDetails") -> Any:
        pass


scout_integrations_api_CreateIntegrationDetailsVisitor.__name__ = "CreateIntegrationDetailsVisitor"
scout_integrations_api_CreateIntegrationDetailsVisitor.__qualname__ = "CreateIntegrationDetailsVisitor"
scout_integrations_api_CreateIntegrationDetailsVisitor.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateIntegrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'create_integration_details': ConjureFieldDefinition('createIntegrationDetails', scout_integrations_api_CreateIntegrationDetails),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_name', '_description', '_create_integration_details', '_workspace']

    def __init__(self, create_integration_details: "scout_integrations_api_CreateIntegrationDetails", name: str, description: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._name = name
        self._description = description
        self._create_integration_details = create_integration_details
        self._workspace = workspace

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def create_integration_details(self) -> "scout_integrations_api_CreateIntegrationDetails":
        return self._create_integration_details

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the integration. If not provided, the integration will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


scout_integrations_api_CreateIntegrationRequest.__name__ = "CreateIntegrationRequest"
scout_integrations_api_CreateIntegrationRequest.__qualname__ = "CreateIntegrationRequest"
scout_integrations_api_CreateIntegrationRequest.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateOpsgenieIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key': ConjureFieldDefinition('apiKey', str),
            'region': ConjureFieldDefinition('region', scout_integrations_api_OpsgenieRegion)
        }

    __slots__: List[str] = ['_api_key', '_region']

    def __init__(self, api_key: str, region: "scout_integrations_api_OpsgenieRegion") -> None:
        self._api_key = api_key
        self._region = region

    @builtins.property
    def api_key(self) -> str:
        return self._api_key

    @builtins.property
    def region(self) -> "scout_integrations_api_OpsgenieRegion":
        return self._region


scout_integrations_api_CreateOpsgenieIntegrationDetails.__name__ = "CreateOpsgenieIntegrationDetails"
scout_integrations_api_CreateOpsgenieIntegrationDetails.__qualname__ = "CreateOpsgenieIntegrationDetails"
scout_integrations_api_CreateOpsgenieIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreatePagerDutyIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'routing_key': ConjureFieldDefinition('routingKey', str)
        }

    __slots__: List[str] = ['_routing_key']

    def __init__(self, routing_key: str) -> None:
        self._routing_key = routing_key

    @builtins.property
    def routing_key(self) -> str:
        return self._routing_key


scout_integrations_api_CreatePagerDutyIntegrationDetails.__name__ = "CreatePagerDutyIntegrationDetails"
scout_integrations_api_CreatePagerDutyIntegrationDetails.__qualname__ = "CreatePagerDutyIntegrationDetails"
scout_integrations_api_CreatePagerDutyIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateSimpleWebhookDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'webhook': ConjureFieldDefinition('webhook', str)
        }

    __slots__: List[str] = ['_webhook']

    def __init__(self, webhook: str) -> None:
        self._webhook = webhook

    @builtins.property
    def webhook(self) -> str:
        return self._webhook


scout_integrations_api_CreateSimpleWebhookDetails.__name__ = "CreateSimpleWebhookDetails"
scout_integrations_api_CreateSimpleWebhookDetails.__qualname__ = "CreateSimpleWebhookDetails"
scout_integrations_api_CreateSimpleWebhookDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_CreateTeamsWebhookIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'webhook': ConjureFieldDefinition('webhook', str)
        }

    __slots__: List[str] = ['_webhook']

    def __init__(self, webhook: str) -> None:
        self._webhook = webhook

    @builtins.property
    def webhook(self) -> str:
        return self._webhook


scout_integrations_api_CreateTeamsWebhookIntegrationDetails.__name__ = "CreateTeamsWebhookIntegrationDetails"
scout_integrations_api_CreateTeamsWebhookIntegrationDetails.__qualname__ = "CreateTeamsWebhookIntegrationDetails"
scout_integrations_api_CreateTeamsWebhookIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_GenerateSlackWebhookResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_url']

    def __init__(self, url: str) -> None:
        self._url = url

    @builtins.property
    def url(self) -> str:
        return self._url


scout_integrations_api_GenerateSlackWebhookResponse.__name__ = "GenerateSlackWebhookResponse"
scout_integrations_api_GenerateSlackWebhookResponse.__qualname__ = "GenerateSlackWebhookResponse"
scout_integrations_api_GenerateSlackWebhookResponse.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_Integration(ConjureBeanType):
    """Configuration details used to connect to an external service.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_integrations_api_IntegrationRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'integration_details': ConjureFieldDefinition('integrationDetails', scout_integrations_api_IntegrationDetails),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_integration_details', '_created_at', '_created_by', '_is_archived']

    def __init__(self, created_at: str, created_by: str, integration_details: "scout_integrations_api_IntegrationDetails", is_archived: bool, name: str, rid: str, description: Optional[str] = None) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._integration_details = integration_details
        self._created_at = created_at
        self._created_by = created_by
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def integration_details(self) -> "scout_integrations_api_IntegrationDetails":
        return self._integration_details

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_integrations_api_Integration.__name__ = "Integration"
scout_integrations_api_Integration.__qualname__ = "Integration"
scout_integrations_api_Integration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_IntegrationDetails(ConjureUnionType):
    _slack_webhook_integration: Optional["scout_integrations_api_SlackWebhookIntegration"] = None
    _opsgenie_integration: Optional["scout_integrations_api_OpsgenieIntegration"] = None
    _simple_webhook_integration: Optional["scout_integrations_api_SimpleWebhookIntegration"] = None
    _teams_webhook_integration: Optional["scout_integrations_api_TeamsWebhookIntegration"] = None
    _pager_duty_integration: Optional["scout_integrations_api_PagerDutyIntegration"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'slack_webhook_integration': ConjureFieldDefinition('slackWebhookIntegration', scout_integrations_api_SlackWebhookIntegration),
            'opsgenie_integration': ConjureFieldDefinition('opsgenieIntegration', scout_integrations_api_OpsgenieIntegration),
            'simple_webhook_integration': ConjureFieldDefinition('simpleWebhookIntegration', scout_integrations_api_SimpleWebhookIntegration),
            'teams_webhook_integration': ConjureFieldDefinition('teamsWebhookIntegration', scout_integrations_api_TeamsWebhookIntegration),
            'pager_duty_integration': ConjureFieldDefinition('pagerDutyIntegration', scout_integrations_api_PagerDutyIntegration)
        }

    def __init__(
            self,
            slack_webhook_integration: Optional["scout_integrations_api_SlackWebhookIntegration"] = None,
            opsgenie_integration: Optional["scout_integrations_api_OpsgenieIntegration"] = None,
            simple_webhook_integration: Optional["scout_integrations_api_SimpleWebhookIntegration"] = None,
            teams_webhook_integration: Optional["scout_integrations_api_TeamsWebhookIntegration"] = None,
            pager_duty_integration: Optional["scout_integrations_api_PagerDutyIntegration"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (slack_webhook_integration is not None) + (opsgenie_integration is not None) + (simple_webhook_integration is not None) + (teams_webhook_integration is not None) + (pager_duty_integration is not None) != 1:
                raise ValueError('a union must contain a single member')

            if slack_webhook_integration is not None:
                self._slack_webhook_integration = slack_webhook_integration
                self._type = 'slackWebhookIntegration'
            if opsgenie_integration is not None:
                self._opsgenie_integration = opsgenie_integration
                self._type = 'opsgenieIntegration'
            if simple_webhook_integration is not None:
                self._simple_webhook_integration = simple_webhook_integration
                self._type = 'simpleWebhookIntegration'
            if teams_webhook_integration is not None:
                self._teams_webhook_integration = teams_webhook_integration
                self._type = 'teamsWebhookIntegration'
            if pager_duty_integration is not None:
                self._pager_duty_integration = pager_duty_integration
                self._type = 'pagerDutyIntegration'

        elif type_of_union == 'slackWebhookIntegration':
            if slack_webhook_integration is None:
                raise ValueError('a union value must not be None')
            self._slack_webhook_integration = slack_webhook_integration
            self._type = 'slackWebhookIntegration'
        elif type_of_union == 'opsgenieIntegration':
            if opsgenie_integration is None:
                raise ValueError('a union value must not be None')
            self._opsgenie_integration = opsgenie_integration
            self._type = 'opsgenieIntegration'
        elif type_of_union == 'simpleWebhookIntegration':
            if simple_webhook_integration is None:
                raise ValueError('a union value must not be None')
            self._simple_webhook_integration = simple_webhook_integration
            self._type = 'simpleWebhookIntegration'
        elif type_of_union == 'teamsWebhookIntegration':
            if teams_webhook_integration is None:
                raise ValueError('a union value must not be None')
            self._teams_webhook_integration = teams_webhook_integration
            self._type = 'teamsWebhookIntegration'
        elif type_of_union == 'pagerDutyIntegration':
            if pager_duty_integration is None:
                raise ValueError('a union value must not be None')
            self._pager_duty_integration = pager_duty_integration
            self._type = 'pagerDutyIntegration'

    @builtins.property
    def slack_webhook_integration(self) -> Optional["scout_integrations_api_SlackWebhookIntegration"]:
        return self._slack_webhook_integration

    @builtins.property
    def opsgenie_integration(self) -> Optional["scout_integrations_api_OpsgenieIntegration"]:
        return self._opsgenie_integration

    @builtins.property
    def simple_webhook_integration(self) -> Optional["scout_integrations_api_SimpleWebhookIntegration"]:
        return self._simple_webhook_integration

    @builtins.property
    def teams_webhook_integration(self) -> Optional["scout_integrations_api_TeamsWebhookIntegration"]:
        return self._teams_webhook_integration

    @builtins.property
    def pager_duty_integration(self) -> Optional["scout_integrations_api_PagerDutyIntegration"]:
        return self._pager_duty_integration

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_IntegrationDetailsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_IntegrationDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'slackWebhookIntegration' and self.slack_webhook_integration is not None:
            return visitor._slack_webhook_integration(self.slack_webhook_integration)
        if self._type == 'opsgenieIntegration' and self.opsgenie_integration is not None:
            return visitor._opsgenie_integration(self.opsgenie_integration)
        if self._type == 'simpleWebhookIntegration' and self.simple_webhook_integration is not None:
            return visitor._simple_webhook_integration(self.simple_webhook_integration)
        if self._type == 'teamsWebhookIntegration' and self.teams_webhook_integration is not None:
            return visitor._teams_webhook_integration(self.teams_webhook_integration)
        if self._type == 'pagerDutyIntegration' and self.pager_duty_integration is not None:
            return visitor._pager_duty_integration(self.pager_duty_integration)


scout_integrations_api_IntegrationDetails.__name__ = "IntegrationDetails"
scout_integrations_api_IntegrationDetails.__qualname__ = "IntegrationDetails"
scout_integrations_api_IntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_IntegrationDetailsVisitor:

    @abstractmethod
    def _slack_webhook_integration(self, slack_webhook_integration: "scout_integrations_api_SlackWebhookIntegration") -> Any:
        pass

    @abstractmethod
    def _opsgenie_integration(self, opsgenie_integration: "scout_integrations_api_OpsgenieIntegration") -> Any:
        pass

    @abstractmethod
    def _simple_webhook_integration(self, simple_webhook_integration: "scout_integrations_api_SimpleWebhookIntegration") -> Any:
        pass

    @abstractmethod
    def _teams_webhook_integration(self, teams_webhook_integration: "scout_integrations_api_TeamsWebhookIntegration") -> Any:
        pass

    @abstractmethod
    def _pager_duty_integration(self, pager_duty_integration: "scout_integrations_api_PagerDutyIntegration") -> Any:
        pass


scout_integrations_api_IntegrationDetailsVisitor.__name__ = "IntegrationDetailsVisitor"
scout_integrations_api_IntegrationDetailsVisitor.__qualname__ = "IntegrationDetailsVisitor"
scout_integrations_api_IntegrationDetailsVisitor.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_IntegrationsService(Service):
    """Service for managing integrations with external services.
    """

    def generate_slack_webhook_link(self, auth_header: str, is_gov_slack: Optional[bool] = None, workspace: Optional[str] = None) -> "scout_integrations_api_GenerateSlackWebhookResponse":
        """Generates link to request permissions for Slack bot to join workspaces and use a webhook.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspace': _conjure_encoder.default(workspace),
            'isGovSlack': _conjure_encoder.default(is_gov_slack),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/slack-oauth/init-webhook'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_GenerateSlackWebhookResponse, self._return_none_for_unknown_union_types)

    def create_slack_webhook(self, auth_header: str, code: str, state: str) -> None:
        """Creates a new Slack integration. Called internally after Slack authorization.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'code': _conjure_encoder.default(code),
            'state': _conjure_encoder.default(state),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/slack-oauth/redirect'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def create_integration(self, auth_header: str, create_integration_request: "scout_integrations_api_CreateIntegrationRequest") -> "scout_integrations_api_Integration":
        """Creates a new integration.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(create_integration_request)

        _path = '/scout/v2/integrations'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def delete_integration(self, auth_header: str, integration_rid: str) -> None:
        """Deletes an integration by archiving.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'integrationRid': quote(str(_conjure_encoder.default(integration_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def update_integration_metadata(self, auth_header: str, integration_rid: str, request: "scout_integrations_api_UpdateIntegrationRequest") -> "scout_integrations_api_Integration":
        """Updates the metadata of an integration.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'integrationRid': quote(str(_conjure_encoder.default(integration_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def update_integration_details(self, auth_header: str, integration_rid: str, request: "scout_integrations_api_UpdateIntegrationDetailsRequest") -> "scout_integrations_api_Integration":
        """Updates the integration details for an integration.
Intended to allow changing webhooks or rotating API keys.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'integrationRid': quote(str(_conjure_encoder.default(integration_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/integrations/{integrationRid}/details'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def get_integration(self, auth_header: str, integration_rid: str) -> "scout_integrations_api_Integration":
        """Retrieves an integration with the specified integration RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'integrationRid': quote(str(_conjure_encoder.default(integration_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/v2/integrations/{integrationRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_integrations_api_Integration, self._return_none_for_unknown_union_types)

    def list_integrations(self, auth_header: str, workspaces: List[str] = None) -> List["scout_integrations_api_Integration"]:
        """Lists all integrations. Archived integrations are not included.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/scout/v2/integrations/list'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_integrations_api_Integration], self._return_none_for_unknown_union_types)

    def send_message(self, auth_header: str, request: "scout_integrations_api_SendMessageRequest") -> None:
        """Sends a string message to the specified integration from a checklist execution.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v2/integrations/send-message'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_integrations_api_IntegrationsService.__name__ = "IntegrationsService"
scout_integrations_api_IntegrationsService.__qualname__ = "IntegrationsService"
scout_integrations_api_IntegrationsService.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_InternalSendMessageRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'integration_rid': ConjureFieldDefinition('integrationRid', scout_integrations_api_IntegrationRid),
            'message': ConjureFieldDefinition('message', scout_integrations_api_MessageFields)
        }

    __slots__: List[str] = ['_integration_rid', '_message']

    def __init__(self, integration_rid: str, message: "scout_integrations_api_MessageFields") -> None:
        self._integration_rid = integration_rid
        self._message = message

    @builtins.property
    def integration_rid(self) -> str:
        return self._integration_rid

    @builtins.property
    def message(self) -> "scout_integrations_api_MessageFields":
        return self._message


scout_integrations_api_InternalSendMessageRequest.__name__ = "InternalSendMessageRequest"
scout_integrations_api_InternalSendMessageRequest.__qualname__ = "InternalSendMessageRequest"
scout_integrations_api_InternalSendMessageRequest.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_MessageFields(ConjureUnionType):
    _alert: Optional["scout_integrations_api_AlertMessageFields"] = None
    _resolution_error: Optional["scout_integrations_api_ResolutionFailureMessageFields"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'alert': ConjureFieldDefinition('alert', scout_integrations_api_AlertMessageFields),
            'resolution_error': ConjureFieldDefinition('resolutionError', scout_integrations_api_ResolutionFailureMessageFields)
        }

    def __init__(
            self,
            alert: Optional["scout_integrations_api_AlertMessageFields"] = None,
            resolution_error: Optional["scout_integrations_api_ResolutionFailureMessageFields"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (alert is not None) + (resolution_error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if alert is not None:
                self._alert = alert
                self._type = 'alert'
            if resolution_error is not None:
                self._resolution_error = resolution_error
                self._type = 'resolutionError'

        elif type_of_union == 'alert':
            if alert is None:
                raise ValueError('a union value must not be None')
            self._alert = alert
            self._type = 'alert'
        elif type_of_union == 'resolutionError':
            if resolution_error is None:
                raise ValueError('a union value must not be None')
            self._resolution_error = resolution_error
            self._type = 'resolutionError'

    @builtins.property
    def alert(self) -> Optional["scout_integrations_api_AlertMessageFields"]:
        return self._alert

    @builtins.property
    def resolution_error(self) -> Optional["scout_integrations_api_ResolutionFailureMessageFields"]:
        return self._resolution_error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_MessageFieldsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_MessageFieldsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'alert' and self.alert is not None:
            return visitor._alert(self.alert)
        if self._type == 'resolutionError' and self.resolution_error is not None:
            return visitor._resolution_error(self.resolution_error)


scout_integrations_api_MessageFields.__name__ = "MessageFields"
scout_integrations_api_MessageFields.__qualname__ = "MessageFields"
scout_integrations_api_MessageFields.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_MessageFieldsVisitor:

    @abstractmethod
    def _alert(self, alert: "scout_integrations_api_AlertMessageFields") -> Any:
        pass

    @abstractmethod
    def _resolution_error(self, resolution_error: "scout_integrations_api_ResolutionFailureMessageFields") -> Any:
        pass


scout_integrations_api_MessageFieldsVisitor.__name__ = "MessageFieldsVisitor"
scout_integrations_api_MessageFieldsVisitor.__qualname__ = "MessageFieldsVisitor"
scout_integrations_api_MessageFieldsVisitor.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_NotificationConfiguration(ConjureBeanType):
    """Configuration details to send notifications to a linked integration.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'integration_rid': ConjureFieldDefinition('integrationRid', scout_integrations_api_IntegrationRid),
            'notification_filters': ConjureFieldDefinition('notificationFilters', OptionalTypeWrapper[List[scout_integrations_api_NotificationFilter]]),
            'appended_workbook_rid': ConjureFieldDefinition('appendedWorkbookRid', OptionalTypeWrapper[scout_rids_api_NotebookRid]),
            'tags': ConjureFieldDefinition('tags', List[str])
        }

    __slots__: List[str] = ['_integration_rid', '_notification_filters', '_appended_workbook_rid', '_tags']

    def __init__(self, integration_rid: str, tags: List[str], appended_workbook_rid: Optional[str] = None, notification_filters: Optional[List["scout_integrations_api_NotificationFilter"]] = None) -> None:
        self._integration_rid = integration_rid
        self._notification_filters = notification_filters
        self._appended_workbook_rid = appended_workbook_rid
        self._tags = tags

    @builtins.property
    def integration_rid(self) -> str:
        return self._integration_rid

    @builtins.property
    def notification_filters(self) -> Optional[List["scout_integrations_api_NotificationFilter"]]:
        """Specifies the type of notifications to filter. If not provided, all notifications are sent.
        """
        return self._notification_filters

    @builtins.property
    def appended_workbook_rid(self) -> Optional[str]:
        """If provided, appends a link to the workbook specified by the RID to the notification.
        """
        return self._appended_workbook_rid

    @builtins.property
    def tags(self) -> List[str]:
        """20 tags max, 50 characters max each. Tags are used to filter messages in Opsgenie. For other integrations, tags are ignored.
        """
        return self._tags


scout_integrations_api_NotificationConfiguration.__name__ = "NotificationConfiguration"
scout_integrations_api_NotificationConfiguration.__qualname__ = "NotificationConfiguration"
scout_integrations_api_NotificationConfiguration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_NotificationFilter(ConjureEnumType):
    """Specifies a type of notification to filter.
    """

    EXECUTION_ERROR = 'EXECUTION_ERROR'
    '''EXECUTION_ERROR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_integrations_api_NotificationFilter.__name__ = "NotificationFilter"
scout_integrations_api_NotificationFilter.__qualname__ = "NotificationFilter"
scout_integrations_api_NotificationFilter.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_OpsgenieIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'region': ConjureFieldDefinition('region', scout_integrations_api_OpsgenieRegion)
        }

    __slots__: List[str] = ['_region']

    def __init__(self, region: "scout_integrations_api_OpsgenieRegion") -> None:
        self._region = region

    @builtins.property
    def region(self) -> "scout_integrations_api_OpsgenieRegion":
        return self._region


scout_integrations_api_OpsgenieIntegration.__name__ = "OpsgenieIntegration"
scout_integrations_api_OpsgenieIntegration.__qualname__ = "OpsgenieIntegration"
scout_integrations_api_OpsgenieIntegration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_OpsgenieRegion(ConjureEnumType):
    """Opsgenie region for the account linked to the provided API key.
    """

    US = 'US'
    '''US'''
    EU = 'EU'
    '''EU'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_integrations_api_OpsgenieRegion.__name__ = "OpsgenieRegion"
scout_integrations_api_OpsgenieRegion.__qualname__ = "OpsgenieRegion"
scout_integrations_api_OpsgenieRegion.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_PagerDutyIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_integrations_api_PagerDutyIntegration.__name__ = "PagerDutyIntegration"
scout_integrations_api_PagerDutyIntegration.__qualname__ = "PagerDutyIntegration"
scout_integrations_api_PagerDutyIntegration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_ResolutionFailureMessageFields(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checklist_title': ConjureFieldDefinition('checklistTitle', str),
            'asset_title': ConjureFieldDefinition('assetTitle', str),
            'checklist_rid': ConjureFieldDefinition('checklistRid', scout_rids_api_ChecklistRid),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'unresolved_checks': ConjureFieldDefinition('unresolvedChecks', int),
            'total_checks': ConjureFieldDefinition('totalChecks', int),
            'labels': ConjureFieldDefinition('labels', List[str])
        }

    __slots__: List[str] = ['_checklist_title', '_asset_title', '_checklist_rid', '_asset_rid', '_unresolved_checks', '_total_checks', '_labels']

    def __init__(self, asset_rid: str, asset_title: str, checklist_rid: str, checklist_title: str, labels: List[str], total_checks: int, unresolved_checks: int) -> None:
        self._checklist_title = checklist_title
        self._asset_title = asset_title
        self._checklist_rid = checklist_rid
        self._asset_rid = asset_rid
        self._unresolved_checks = unresolved_checks
        self._total_checks = total_checks
        self._labels = labels

    @builtins.property
    def checklist_title(self) -> str:
        return self._checklist_title

    @builtins.property
    def asset_title(self) -> str:
        return self._asset_title

    @builtins.property
    def checklist_rid(self) -> str:
        return self._checklist_rid

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def unresolved_checks(self) -> int:
        return self._unresolved_checks

    @builtins.property
    def total_checks(self) -> int:
        return self._total_checks

    @builtins.property
    def labels(self) -> List[str]:
        """Currently exposed as 'tags' on the frontend to match Opsgenie naming. Used by some integrations to filter/route messages.
        """
        return self._labels


scout_integrations_api_ResolutionFailureMessageFields.__name__ = "ResolutionFailureMessageFields"
scout_integrations_api_ResolutionFailureMessageFields.__qualname__ = "ResolutionFailureMessageFields"
scout_integrations_api_ResolutionFailureMessageFields.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_SendMessageRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'message': ConjureFieldDefinition('message', str),
            'tags': ConjureFieldDefinition('tags', List[str]),
            'ops_genie_alias': ConjureFieldDefinition('opsGenieAlias', OptionalTypeWrapper[str]),
            'integration_rid': ConjureFieldDefinition('integrationRid', scout_integrations_api_IntegrationRid),
            'priority': ConjureFieldDefinition('priority', OptionalTypeWrapper[scout_api_Priority])
        }

    __slots__: List[str] = ['_title', '_message', '_tags', '_ops_genie_alias', '_integration_rid', '_priority']

    def __init__(self, integration_rid: str, message: str, tags: List[str], ops_genie_alias: Optional[str] = None, priority: Optional["scout_api_Priority"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._message = message
        self._tags = tags
        self._ops_genie_alias = ops_genie_alias
        self._integration_rid = integration_rid
        self._priority = priority

    @builtins.property
    def title(self) -> Optional[str]:
        """Optional title for the message. 130 characters max.
        """
        return self._title

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def tags(self) -> List[str]:
        """20 tags max, 50 characters max each. Tags are used to filter messages in Opsgenie. For other integrations, tags are ignored.
        """
        return self._tags

    @builtins.property
    def ops_genie_alias(self) -> Optional[str]:
        """Alias to use for the Opsgenie alert deduplication. 512 characters max.
        """
        return self._ops_genie_alias

    @builtins.property
    def integration_rid(self) -> str:
        return self._integration_rid

    @builtins.property
    def priority(self) -> Optional["scout_api_Priority"]:
        return self._priority


scout_integrations_api_SendMessageRequest.__name__ = "SendMessageRequest"
scout_integrations_api_SendMessageRequest.__qualname__ = "SendMessageRequest"
scout_integrations_api_SendMessageRequest.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_SimpleWebhookIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_integrations_api_SimpleWebhookIntegration.__name__ = "SimpleWebhookIntegration"
scout_integrations_api_SimpleWebhookIntegration.__qualname__ = "SimpleWebhookIntegration"
scout_integrations_api_SimpleWebhookIntegration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_SlackInstanceType(ConjureEnumType):

    COMMERCIAL = 'COMMERCIAL'
    '''COMMERCIAL'''
    GOV = 'GOV'
    '''GOV'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_integrations_api_SlackInstanceType.__name__ = "SlackInstanceType"
scout_integrations_api_SlackInstanceType.__qualname__ = "SlackInstanceType"
scout_integrations_api_SlackInstanceType.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_SlackWebhookIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'team_name': ConjureFieldDefinition('teamName', str),
            'channel': ConjureFieldDefinition('channel', str),
            'channel_id': ConjureFieldDefinition('channelId', str),
            'slack_instance': ConjureFieldDefinition('slackInstance', OptionalTypeWrapper[scout_integrations_api_SlackInstanceType])
        }

    __slots__: List[str] = ['_team_name', '_channel', '_channel_id', '_slack_instance']

    def __init__(self, channel: str, channel_id: str, team_name: str, slack_instance: Optional["scout_integrations_api_SlackInstanceType"] = None) -> None:
        self._team_name = team_name
        self._channel = channel
        self._channel_id = channel_id
        self._slack_instance = slack_instance

    @builtins.property
    def team_name(self) -> str:
        return self._team_name

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def channel_id(self) -> str:
        return self._channel_id

    @builtins.property
    def slack_instance(self) -> Optional["scout_integrations_api_SlackInstanceType"]:
        return self._slack_instance


scout_integrations_api_SlackWebhookIntegration.__name__ = "SlackWebhookIntegration"
scout_integrations_api_SlackWebhookIntegration.__qualname__ = "SlackWebhookIntegration"
scout_integrations_api_SlackWebhookIntegration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_TeamsWebhookIntegration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_integrations_api_TeamsWebhookIntegration.__name__ = "TeamsWebhookIntegration"
scout_integrations_api_TeamsWebhookIntegration.__qualname__ = "TeamsWebhookIntegration"
scout_integrations_api_TeamsWebhookIntegration.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateIntegrationDetails(ConjureUnionType):
    _simple_webhook: Optional["scout_integrations_api_UpdateSimpleWebhookDetails"] = None
    _opsgenie_integration: Optional["scout_integrations_api_UpdateOpsgenieIntegrationDetails"] = None
    _teams_webhook: Optional["scout_integrations_api_UpdateTeamsWebhookIntegrationDetails"] = None
    _pager_duty: Optional["scout_integrations_api_UpdatePagerDutyIntegrationDetails"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'simple_webhook': ConjureFieldDefinition('simpleWebhook', scout_integrations_api_UpdateSimpleWebhookDetails),
            'opsgenie_integration': ConjureFieldDefinition('opsgenieIntegration', scout_integrations_api_UpdateOpsgenieIntegrationDetails),
            'teams_webhook': ConjureFieldDefinition('teamsWebhook', scout_integrations_api_UpdateTeamsWebhookIntegrationDetails),
            'pager_duty': ConjureFieldDefinition('pagerDuty', scout_integrations_api_UpdatePagerDutyIntegrationDetails)
        }

    def __init__(
            self,
            simple_webhook: Optional["scout_integrations_api_UpdateSimpleWebhookDetails"] = None,
            opsgenie_integration: Optional["scout_integrations_api_UpdateOpsgenieIntegrationDetails"] = None,
            teams_webhook: Optional["scout_integrations_api_UpdateTeamsWebhookIntegrationDetails"] = None,
            pager_duty: Optional["scout_integrations_api_UpdatePagerDutyIntegrationDetails"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (simple_webhook is not None) + (opsgenie_integration is not None) + (teams_webhook is not None) + (pager_duty is not None) != 1:
                raise ValueError('a union must contain a single member')

            if simple_webhook is not None:
                self._simple_webhook = simple_webhook
                self._type = 'simpleWebhook'
            if opsgenie_integration is not None:
                self._opsgenie_integration = opsgenie_integration
                self._type = 'opsgenieIntegration'
            if teams_webhook is not None:
                self._teams_webhook = teams_webhook
                self._type = 'teamsWebhook'
            if pager_duty is not None:
                self._pager_duty = pager_duty
                self._type = 'pagerDuty'

        elif type_of_union == 'simpleWebhook':
            if simple_webhook is None:
                raise ValueError('a union value must not be None')
            self._simple_webhook = simple_webhook
            self._type = 'simpleWebhook'
        elif type_of_union == 'opsgenieIntegration':
            if opsgenie_integration is None:
                raise ValueError('a union value must not be None')
            self._opsgenie_integration = opsgenie_integration
            self._type = 'opsgenieIntegration'
        elif type_of_union == 'teamsWebhook':
            if teams_webhook is None:
                raise ValueError('a union value must not be None')
            self._teams_webhook = teams_webhook
            self._type = 'teamsWebhook'
        elif type_of_union == 'pagerDuty':
            if pager_duty is None:
                raise ValueError('a union value must not be None')
            self._pager_duty = pager_duty
            self._type = 'pagerDuty'

    @builtins.property
    def simple_webhook(self) -> Optional["scout_integrations_api_UpdateSimpleWebhookDetails"]:
        return self._simple_webhook

    @builtins.property
    def opsgenie_integration(self) -> Optional["scout_integrations_api_UpdateOpsgenieIntegrationDetails"]:
        return self._opsgenie_integration

    @builtins.property
    def teams_webhook(self) -> Optional["scout_integrations_api_UpdateTeamsWebhookIntegrationDetails"]:
        return self._teams_webhook

    @builtins.property
    def pager_duty(self) -> Optional["scout_integrations_api_UpdatePagerDutyIntegrationDetails"]:
        return self._pager_duty

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_integrations_api_UpdateIntegrationDetailsVisitor):
            raise ValueError('{} is not an instance of scout_integrations_api_UpdateIntegrationDetailsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'simpleWebhook' and self.simple_webhook is not None:
            return visitor._simple_webhook(self.simple_webhook)
        if self._type == 'opsgenieIntegration' and self.opsgenie_integration is not None:
            return visitor._opsgenie_integration(self.opsgenie_integration)
        if self._type == 'teamsWebhook' and self.teams_webhook is not None:
            return visitor._teams_webhook(self.teams_webhook)
        if self._type == 'pagerDuty' and self.pager_duty is not None:
            return visitor._pager_duty(self.pager_duty)


scout_integrations_api_UpdateIntegrationDetails.__name__ = "UpdateIntegrationDetails"
scout_integrations_api_UpdateIntegrationDetails.__qualname__ = "UpdateIntegrationDetails"
scout_integrations_api_UpdateIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateIntegrationDetailsVisitor:

    @abstractmethod
    def _simple_webhook(self, simple_webhook: "scout_integrations_api_UpdateSimpleWebhookDetails") -> Any:
        pass

    @abstractmethod
    def _opsgenie_integration(self, opsgenie_integration: "scout_integrations_api_UpdateOpsgenieIntegrationDetails") -> Any:
        pass

    @abstractmethod
    def _teams_webhook(self, teams_webhook: "scout_integrations_api_UpdateTeamsWebhookIntegrationDetails") -> Any:
        pass

    @abstractmethod
    def _pager_duty(self, pager_duty: "scout_integrations_api_UpdatePagerDutyIntegrationDetails") -> Any:
        pass


scout_integrations_api_UpdateIntegrationDetailsVisitor.__name__ = "UpdateIntegrationDetailsVisitor"
scout_integrations_api_UpdateIntegrationDetailsVisitor.__qualname__ = "UpdateIntegrationDetailsVisitor"
scout_integrations_api_UpdateIntegrationDetailsVisitor.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateIntegrationDetailsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'update_integration_details': ConjureFieldDefinition('updateIntegrationDetails', scout_integrations_api_UpdateIntegrationDetails)
        }

    __slots__: List[str] = ['_update_integration_details']

    def __init__(self, update_integration_details: "scout_integrations_api_UpdateIntegrationDetails") -> None:
        self._update_integration_details = update_integration_details

    @builtins.property
    def update_integration_details(self) -> "scout_integrations_api_UpdateIntegrationDetails":
        """Includes the information needed to rotate the integration-specific secrets.
Examples include unsecured webhook URL or API keys.
        """
        return self._update_integration_details


scout_integrations_api_UpdateIntegrationDetailsRequest.__name__ = "UpdateIntegrationDetailsRequest"
scout_integrations_api_UpdateIntegrationDetailsRequest.__qualname__ = "UpdateIntegrationDetailsRequest"
scout_integrations_api_UpdateIntegrationDetailsRequest.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateIntegrationRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name', '_description']

    def __init__(self, description: Optional[str] = None, name: Optional[str] = None) -> None:
        self._name = name
        self._description = description

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


scout_integrations_api_UpdateIntegrationRequest.__name__ = "UpdateIntegrationRequest"
scout_integrations_api_UpdateIntegrationRequest.__qualname__ = "UpdateIntegrationRequest"
scout_integrations_api_UpdateIntegrationRequest.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateOpsgenieIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'api_key': ConjureFieldDefinition('apiKey', str),
            'region': ConjureFieldDefinition('region', scout_integrations_api_OpsgenieRegion)
        }

    __slots__: List[str] = ['_api_key', '_region']

    def __init__(self, api_key: str, region: "scout_integrations_api_OpsgenieRegion") -> None:
        self._api_key = api_key
        self._region = region

    @builtins.property
    def api_key(self) -> str:
        return self._api_key

    @builtins.property
    def region(self) -> "scout_integrations_api_OpsgenieRegion":
        return self._region


scout_integrations_api_UpdateOpsgenieIntegrationDetails.__name__ = "UpdateOpsgenieIntegrationDetails"
scout_integrations_api_UpdateOpsgenieIntegrationDetails.__qualname__ = "UpdateOpsgenieIntegrationDetails"
scout_integrations_api_UpdateOpsgenieIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdatePagerDutyIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'routing_key': ConjureFieldDefinition('routingKey', str)
        }

    __slots__: List[str] = ['_routing_key']

    def __init__(self, routing_key: str) -> None:
        self._routing_key = routing_key

    @builtins.property
    def routing_key(self) -> str:
        return self._routing_key


scout_integrations_api_UpdatePagerDutyIntegrationDetails.__name__ = "UpdatePagerDutyIntegrationDetails"
scout_integrations_api_UpdatePagerDutyIntegrationDetails.__qualname__ = "UpdatePagerDutyIntegrationDetails"
scout_integrations_api_UpdatePagerDutyIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateSimpleWebhookDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'webhook': ConjureFieldDefinition('webhook', str)
        }

    __slots__: List[str] = ['_webhook']

    def __init__(self, webhook: str) -> None:
        self._webhook = webhook

    @builtins.property
    def webhook(self) -> str:
        return self._webhook


scout_integrations_api_UpdateSimpleWebhookDetails.__name__ = "UpdateSimpleWebhookDetails"
scout_integrations_api_UpdateSimpleWebhookDetails.__qualname__ = "UpdateSimpleWebhookDetails"
scout_integrations_api_UpdateSimpleWebhookDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_integrations_api_UpdateTeamsWebhookIntegrationDetails(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'webhook': ConjureFieldDefinition('webhook', str)
        }

    __slots__: List[str] = ['_webhook']

    def __init__(self, webhook: str) -> None:
        self._webhook = webhook

    @builtins.property
    def webhook(self) -> str:
        return self._webhook


scout_integrations_api_UpdateTeamsWebhookIntegrationDetails.__name__ = "UpdateTeamsWebhookIntegrationDetails"
scout_integrations_api_UpdateTeamsWebhookIntegrationDetails.__qualname__ = "UpdateTeamsWebhookIntegrationDetails"
scout_integrations_api_UpdateTeamsWebhookIntegrationDetails.__module__ = "nominal_api.scout_integrations_api"


class scout_internal_search_api_BooleanField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', bool)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: bool) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> bool:
        return self._value


scout_internal_search_api_BooleanField.__name__ = "BooleanField"
scout_internal_search_api_BooleanField.__qualname__ = "BooleanField"
scout_internal_search_api_BooleanField.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_DateTimeField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', str),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator)
        }

    __slots__: List[str] = ['_name', '_value', '_operator']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", value: str) -> None:
        self._name = name
        self._value = value
        self._operator = operator

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator


scout_internal_search_api_DateTimeField.__name__ = "DateTimeField"
scout_internal_search_api_DateTimeField.__qualname__ = "DateTimeField"
scout_internal_search_api_DateTimeField.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_LongField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'threshold': ConjureFieldDefinition('threshold', int),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator)
        }

    __slots__: List[str] = ['_name', '_threshold', '_operator']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", threshold: int) -> None:
        self._name = name
        self._threshold = threshold
        self._operator = operator

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def threshold(self) -> int:
        return self._threshold

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator


scout_internal_search_api_LongField.__name__ = "LongField"
scout_internal_search_api_LongField.__qualname__ = "LongField"
scout_internal_search_api_LongField.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_Operator(ConjureEnumType):

    LEQ = 'LEQ'
    '''LEQ'''
    LT = 'LT'
    '''LT'''
    GEQ = 'GEQ'
    '''GEQ'''
    GT = 'GT'
    '''GT'''
    EQ = 'EQ'
    '''EQ'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_internal_search_api_Operator.__name__ = "Operator"
scout_internal_search_api_Operator.__qualname__ = "Operator"
scout_internal_search_api_Operator.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_SearchQuery(ConjureUnionType):
    _date_time_field: Optional["scout_internal_search_api_DateTimeField"] = None
    _string_field: Optional["scout_internal_search_api_StringField"] = None
    _timestamp_field: Optional["scout_internal_search_api_TimestampField"] = None
    _long_field: Optional["scout_internal_search_api_LongField"] = None
    _boolean_field: Optional["scout_internal_search_api_BooleanField"] = None
    _exact_match: Optional[str] = None
    _string_array_exact_match: Optional["scout_internal_search_api_StringArrayField"] = None
    _string_array_length: Optional["scout_metadata_StringArrayLengthQuery"] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["scout_internal_search_api_SearchQuery"]] = None
    _or_: Optional[List["scout_internal_search_api_SearchQuery"]] = None
    _not_: Optional["scout_internal_search_api_SearchQuery"] = None
    _workspace: Optional[str] = None
    _created_at: Optional["scout_metadata_CreatedAtQuery"] = None
    _archived_status: Optional["api_ArchivedStatus"] = None
    _is_published: Optional[bool] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'date_time_field': ConjureFieldDefinition('dateTimeField', scout_internal_search_api_DateTimeField),
            'string_field': ConjureFieldDefinition('stringField', scout_internal_search_api_StringField),
            'timestamp_field': ConjureFieldDefinition('timestampField', scout_internal_search_api_TimestampField),
            'long_field': ConjureFieldDefinition('longField', scout_internal_search_api_LongField),
            'boolean_field': ConjureFieldDefinition('booleanField', scout_internal_search_api_BooleanField),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'string_array_exact_match': ConjureFieldDefinition('stringArrayExactMatch', scout_internal_search_api_StringArrayField),
            'string_array_length': ConjureFieldDefinition('stringArrayLength', scout_metadata_StringArrayLengthQuery),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_internal_search_api_SearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_internal_search_api_SearchQuery]),
            'not_': ConjureFieldDefinition('not', scout_internal_search_api_SearchQuery),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'created_at': ConjureFieldDefinition('createdAt', scout_metadata_CreatedAtQuery),
            'archived_status': ConjureFieldDefinition('archivedStatus', api_ArchivedStatus),
            'is_published': ConjureFieldDefinition('isPublished', bool)
        }

    def __init__(
            self,
            date_time_field: Optional["scout_internal_search_api_DateTimeField"] = None,
            string_field: Optional["scout_internal_search_api_StringField"] = None,
            timestamp_field: Optional["scout_internal_search_api_TimestampField"] = None,
            long_field: Optional["scout_internal_search_api_LongField"] = None,
            boolean_field: Optional["scout_internal_search_api_BooleanField"] = None,
            exact_match: Optional[str] = None,
            string_array_exact_match: Optional["scout_internal_search_api_StringArrayField"] = None,
            string_array_length: Optional["scout_metadata_StringArrayLengthQuery"] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["scout_internal_search_api_SearchQuery"]] = None,
            or_: Optional[List["scout_internal_search_api_SearchQuery"]] = None,
            not_: Optional["scout_internal_search_api_SearchQuery"] = None,
            workspace: Optional[str] = None,
            created_at: Optional["scout_metadata_CreatedAtQuery"] = None,
            archived_status: Optional["api_ArchivedStatus"] = None,
            is_published: Optional[bool] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (date_time_field is not None) + (string_field is not None) + (timestamp_field is not None) + (long_field is not None) + (boolean_field is not None) + (exact_match is not None) + (string_array_exact_match is not None) + (string_array_length is not None) + (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) + (workspace is not None) + (created_at is not None) + (archived_status is not None) + (is_published is not None) != 1:
                raise ValueError('a union must contain a single member')

            if date_time_field is not None:
                self._date_time_field = date_time_field
                self._type = 'dateTimeField'
            if string_field is not None:
                self._string_field = string_field
                self._type = 'stringField'
            if timestamp_field is not None:
                self._timestamp_field = timestamp_field
                self._type = 'timestampField'
            if long_field is not None:
                self._long_field = long_field
                self._type = 'longField'
            if boolean_field is not None:
                self._boolean_field = boolean_field
                self._type = 'booleanField'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if string_array_exact_match is not None:
                self._string_array_exact_match = string_array_exact_match
                self._type = 'stringArrayExactMatch'
            if string_array_length is not None:
                self._string_array_length = string_array_length
                self._type = 'stringArrayLength'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if created_at is not None:
                self._created_at = created_at
                self._type = 'createdAt'
            if archived_status is not None:
                self._archived_status = archived_status
                self._type = 'archivedStatus'
            if is_published is not None:
                self._is_published = is_published
                self._type = 'isPublished'

        elif type_of_union == 'dateTimeField':
            if date_time_field is None:
                raise ValueError('a union value must not be None')
            self._date_time_field = date_time_field
            self._type = 'dateTimeField'
        elif type_of_union == 'stringField':
            if string_field is None:
                raise ValueError('a union value must not be None')
            self._string_field = string_field
            self._type = 'stringField'
        elif type_of_union == 'timestampField':
            if timestamp_field is None:
                raise ValueError('a union value must not be None')
            self._timestamp_field = timestamp_field
            self._type = 'timestampField'
        elif type_of_union == 'longField':
            if long_field is None:
                raise ValueError('a union value must not be None')
            self._long_field = long_field
            self._type = 'longField'
        elif type_of_union == 'booleanField':
            if boolean_field is None:
                raise ValueError('a union value must not be None')
            self._boolean_field = boolean_field
            self._type = 'booleanField'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'stringArrayExactMatch':
            if string_array_exact_match is None:
                raise ValueError('a union value must not be None')
            self._string_array_exact_match = string_array_exact_match
            self._type = 'stringArrayExactMatch'
        elif type_of_union == 'stringArrayLength':
            if string_array_length is None:
                raise ValueError('a union value must not be None')
            self._string_array_length = string_array_length
            self._type = 'stringArrayLength'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'createdAt':
            if created_at is None:
                raise ValueError('a union value must not be None')
            self._created_at = created_at
            self._type = 'createdAt'
        elif type_of_union == 'archivedStatus':
            if archived_status is None:
                raise ValueError('a union value must not be None')
            self._archived_status = archived_status
            self._type = 'archivedStatus'
        elif type_of_union == 'isPublished':
            if is_published is None:
                raise ValueError('a union value must not be None')
            self._is_published = is_published
            self._type = 'isPublished'

    @builtins.property
    def date_time_field(self) -> Optional["scout_internal_search_api_DateTimeField"]:
        return self._date_time_field

    @builtins.property
    def string_field(self) -> Optional["scout_internal_search_api_StringField"]:
        return self._string_field

    @builtins.property
    def timestamp_field(self) -> Optional["scout_internal_search_api_TimestampField"]:
        return self._timestamp_field

    @builtins.property
    def long_field(self) -> Optional["scout_internal_search_api_LongField"]:
        return self._long_field

    @builtins.property
    def boolean_field(self) -> Optional["scout_internal_search_api_BooleanField"]:
        return self._boolean_field

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def string_array_exact_match(self) -> Optional["scout_internal_search_api_StringArrayField"]:
        """Requires the string values in the query to exactly match the set of string values in the resource.
To do a partial match, use an "and" on StringField queries.
        """
        return self._string_array_exact_match

    @builtins.property
    def string_array_length(self) -> Optional["scout_metadata_StringArrayLengthQuery"]:
        return self._string_array_length

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_internal_search_api_SearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_internal_search_api_SearchQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_internal_search_api_SearchQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def created_at(self) -> Optional["scout_metadata_CreatedAtQuery"]:
        return self._created_at

    @builtins.property
    def archived_status(self) -> Optional["api_ArchivedStatus"]:
        """Prefer to use archivedStatus field in IndexableDb#search
        """
        return self._archived_status

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_internal_search_api_SearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_internal_search_api_SearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dateTimeField' and self.date_time_field is not None:
            return visitor._date_time_field(self.date_time_field)
        if self._type == 'stringField' and self.string_field is not None:
            return visitor._string_field(self.string_field)
        if self._type == 'timestampField' and self.timestamp_field is not None:
            return visitor._timestamp_field(self.timestamp_field)
        if self._type == 'longField' and self.long_field is not None:
            return visitor._long_field(self.long_field)
        if self._type == 'booleanField' and self.boolean_field is not None:
            return visitor._boolean_field(self.boolean_field)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'stringArrayExactMatch' and self.string_array_exact_match is not None:
            return visitor._string_array_exact_match(self.string_array_exact_match)
        if self._type == 'stringArrayLength' and self.string_array_length is not None:
            return visitor._string_array_length(self.string_array_length)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'createdAt' and self.created_at is not None:
            return visitor._created_at(self.created_at)
        if self._type == 'archivedStatus' and self.archived_status is not None:
            return visitor._archived_status(self.archived_status)
        if self._type == 'isPublished' and self.is_published is not None:
            return visitor._is_published(self.is_published)


scout_internal_search_api_SearchQuery.__name__ = "SearchQuery"
scout_internal_search_api_SearchQuery.__qualname__ = "SearchQuery"
scout_internal_search_api_SearchQuery.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_SearchQueryVisitor:

    @abstractmethod
    def _date_time_field(self, date_time_field: "scout_internal_search_api_DateTimeField") -> Any:
        pass

    @abstractmethod
    def _string_field(self, string_field: "scout_internal_search_api_StringField") -> Any:
        pass

    @abstractmethod
    def _timestamp_field(self, timestamp_field: "scout_internal_search_api_TimestampField") -> Any:
        pass

    @abstractmethod
    def _long_field(self, long_field: "scout_internal_search_api_LongField") -> Any:
        pass

    @abstractmethod
    def _boolean_field(self, boolean_field: "scout_internal_search_api_BooleanField") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _string_array_exact_match(self, string_array_exact_match: "scout_internal_search_api_StringArrayField") -> Any:
        pass

    @abstractmethod
    def _string_array_length(self, string_array_length: "scout_metadata_StringArrayLengthQuery") -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_internal_search_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_internal_search_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_internal_search_api_SearchQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _created_at(self, created_at: "scout_metadata_CreatedAtQuery") -> Any:
        pass

    @abstractmethod
    def _archived_status(self, archived_status: "api_ArchivedStatus") -> Any:
        pass

    @abstractmethod
    def _is_published(self, is_published: bool) -> Any:
        pass


scout_internal_search_api_SearchQueryVisitor.__name__ = "SearchQueryVisitor"
scout_internal_search_api_SearchQueryVisitor.__qualname__ = "SearchQueryVisitor"
scout_internal_search_api_SearchQueryVisitor.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_StringArrayField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', List[str])
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: List[str]) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> List[str]:
        return self._value


scout_internal_search_api_StringArrayField.__name__ = "StringArrayField"
scout_internal_search_api_StringArrayField.__qualname__ = "StringArrayField"
scout_internal_search_api_StringArrayField.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_StringField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_internal_search_api_StringField.__name__ = "StringField"
scout_internal_search_api_StringField.__qualname__ = "StringField"
scout_internal_search_api_StringField.__module__ = "nominal_api.scout_internal_search_api"


class scout_internal_search_api_TimestampField(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator)
        }

    __slots__: List[str] = ['_name', '_timestamp', '_operator']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", timestamp: "api_Timestamp") -> None:
        self._name = name
        self._timestamp = timestamp
        self._operator = operator

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator


scout_internal_search_api_TimestampField.__name__ = "TimestampField"
scout_internal_search_api_TimestampField.__qualname__ = "TimestampField"
scout_internal_search_api_TimestampField.__module__ = "nominal_api.scout_internal_search_api"


class scout_jobs_api_InternalJobService(Service):
    """The Internal Job Service is responsible for running jobs for checklist executions.
    """

    def submit_jobs(self, auth_header: str, request: "scout_checks_api_SubmitJobsRequest") -> "scout_checks_api_SubmitJobsResponse":
        """Runs the requested job specs.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/internal/jobs/v1/submitJobs'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_SubmitJobsResponse, self._return_none_for_unknown_union_types)


scout_jobs_api_InternalJobService.__name__ = "InternalJobService"
scout_jobs_api_InternalJobService.__qualname__ = "InternalJobService"
scout_jobs_api_InternalJobService.__module__ = "nominal_api.scout_jobs_api"


class scout_jobs_api_JobService(Service):
    """The Job Service is responsible for returning information about jobs for checklist executions.
    """

    def get_job_report(self, auth_header: str, job_rid: str) -> "scout_checks_api_JobReport":
        """Fetches the job report for a job RID. Throws ResourcesNotFound if no job exists with this job RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'jobRid': quote(str(_conjure_encoder.default(job_rid)), safe=''),
        }

        _json: Any = None

        _path = '/jobs/v1/{jobRid}/job-report'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_JobReport, self._return_none_for_unknown_union_types)

    def batch_get_job_reports(self, auth_header: str, request: "scout_checks_api_BatchGetJobReportsRequest") -> "scout_checks_api_BatchGetJobReportsResponse":
        """Fetches the job reports for a set of job RIDs. Omits any job reports the user is not permitted to see from
the response.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/jobs/v1/batch-get-job-reports'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_checks_api_BatchGetJobReportsResponse, self._return_none_for_unknown_union_types)


scout_jobs_api_JobService.__name__ = "JobService"
scout_jobs_api_JobService.__qualname__ = "JobService"
scout_jobs_api_JobService.__module__ = "nominal_api.scout_jobs_api"


class scout_layout_api_ChartPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_ChartPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_ChartPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_ChartPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_ChartPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_ChartPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_ChartPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_ChartPanel.__name__ = "ChartPanel"
scout_layout_api_ChartPanel.__qualname__ = "ChartPanel"
scout_layout_api_ChartPanel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_ChartPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_ChartPanelV1") -> Any:
        pass


scout_layout_api_ChartPanelVisitor.__name__ = "ChartPanelVisitor"
scout_layout_api_ChartPanelVisitor.__qualname__ = "ChartPanelVisitor"
scout_layout_api_ChartPanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_ChartPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'chart_rid': ConjureFieldDefinition('chartRid', scout_rids_api_VersionedVizId),
            'hide_legend': ConjureFieldDefinition('hideLegend', bool)
        }

    __slots__: List[str] = ['_id', '_chart_rid', '_hide_legend']

    def __init__(self, chart_rid: "scout_rids_api_VersionedVizId", hide_legend: bool, id: str) -> None:
        self._id = id
        self._chart_rid = chart_rid
        self._hide_legend = hide_legend

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def chart_rid(self) -> "scout_rids_api_VersionedVizId":
        return self._chart_rid

    @builtins.property
    def hide_legend(self) -> bool:
        return self._hide_legend


scout_layout_api_ChartPanelV1.__name__ = "ChartPanelV1"
scout_layout_api_ChartPanelV1.__qualname__ = "ChartPanelV1"
scout_layout_api_ChartPanelV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_EmptyPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_EmptyPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_EmptyPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_EmptyPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_EmptyPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_EmptyPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_EmptyPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_EmptyPanel.__name__ = "EmptyPanel"
scout_layout_api_EmptyPanel.__qualname__ = "EmptyPanel"
scout_layout_api_EmptyPanel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_EmptyPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_EmptyPanelV1") -> Any:
        pass


scout_layout_api_EmptyPanelVisitor.__name__ = "EmptyPanelVisitor"
scout_layout_api_EmptyPanelVisitor.__qualname__ = "EmptyPanelVisitor"
scout_layout_api_EmptyPanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_EmptyPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId)
        }

    __slots__: List[str] = ['_id']

    def __init__(self, id: str) -> None:
        self._id = id

    @builtins.property
    def id(self) -> str:
        return self._id


scout_layout_api_EmptyPanelV1.__name__ = "EmptyPanelV1"
scout_layout_api_EmptyPanelV1.__qualname__ = "EmptyPanelV1"
scout_layout_api_EmptyPanelV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_Panel(ConjureUnionType):
    _viz: Optional["scout_layout_api_VizPanel"] = None
    _chart: Optional["scout_layout_api_ChartPanel"] = None
    _empty: Optional["scout_layout_api_EmptyPanel"] = None
    _split: Optional["scout_layout_api_SplitPanel"] = None
    _tabbed: Optional["scout_layout_api_TabbedPanel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'viz': ConjureFieldDefinition('viz', scout_layout_api_VizPanel),
            'chart': ConjureFieldDefinition('chart', scout_layout_api_ChartPanel),
            'empty': ConjureFieldDefinition('empty', scout_layout_api_EmptyPanel),
            'split': ConjureFieldDefinition('split', scout_layout_api_SplitPanel),
            'tabbed': ConjureFieldDefinition('tabbed', scout_layout_api_TabbedPanel)
        }

    def __init__(
            self,
            viz: Optional["scout_layout_api_VizPanel"] = None,
            chart: Optional["scout_layout_api_ChartPanel"] = None,
            empty: Optional["scout_layout_api_EmptyPanel"] = None,
            split: Optional["scout_layout_api_SplitPanel"] = None,
            tabbed: Optional["scout_layout_api_TabbedPanel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (viz is not None) + (chart is not None) + (empty is not None) + (split is not None) + (tabbed is not None) != 1:
                raise ValueError('a union must contain a single member')

            if viz is not None:
                self._viz = viz
                self._type = 'viz'
            if chart is not None:
                self._chart = chart
                self._type = 'chart'
            if empty is not None:
                self._empty = empty
                self._type = 'empty'
            if split is not None:
                self._split = split
                self._type = 'split'
            if tabbed is not None:
                self._tabbed = tabbed
                self._type = 'tabbed'

        elif type_of_union == 'viz':
            if viz is None:
                raise ValueError('a union value must not be None')
            self._viz = viz
            self._type = 'viz'
        elif type_of_union == 'chart':
            if chart is None:
                raise ValueError('a union value must not be None')
            self._chart = chart
            self._type = 'chart'
        elif type_of_union == 'empty':
            if empty is None:
                raise ValueError('a union value must not be None')
            self._empty = empty
            self._type = 'empty'
        elif type_of_union == 'split':
            if split is None:
                raise ValueError('a union value must not be None')
            self._split = split
            self._type = 'split'
        elif type_of_union == 'tabbed':
            if tabbed is None:
                raise ValueError('a union value must not be None')
            self._tabbed = tabbed
            self._type = 'tabbed'

    @builtins.property
    def viz(self) -> Optional["scout_layout_api_VizPanel"]:
        return self._viz

    @builtins.property
    def chart(self) -> Optional["scout_layout_api_ChartPanel"]:
        return self._chart

    @builtins.property
    def empty(self) -> Optional["scout_layout_api_EmptyPanel"]:
        return self._empty

    @builtins.property
    def split(self) -> Optional["scout_layout_api_SplitPanel"]:
        return self._split

    @builtins.property
    def tabbed(self) -> Optional["scout_layout_api_TabbedPanel"]:
        return self._tabbed

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_PanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_PanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'viz' and self.viz is not None:
            return visitor._viz(self.viz)
        if self._type == 'chart' and self.chart is not None:
            return visitor._chart(self.chart)
        if self._type == 'empty' and self.empty is not None:
            return visitor._empty(self.empty)
        if self._type == 'split' and self.split is not None:
            return visitor._split(self.split)
        if self._type == 'tabbed' and self.tabbed is not None:
            return visitor._tabbed(self.tabbed)


scout_layout_api_Panel.__name__ = "Panel"
scout_layout_api_Panel.__qualname__ = "Panel"
scout_layout_api_Panel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_PanelVisitor:

    @abstractmethod
    def _viz(self, viz: "scout_layout_api_VizPanel") -> Any:
        pass

    @abstractmethod
    def _chart(self, chart: "scout_layout_api_ChartPanel") -> Any:
        pass

    @abstractmethod
    def _empty(self, empty: "scout_layout_api_EmptyPanel") -> Any:
        pass

    @abstractmethod
    def _split(self, split: "scout_layout_api_SplitPanel") -> Any:
        pass

    @abstractmethod
    def _tabbed(self, tabbed: "scout_layout_api_TabbedPanel") -> Any:
        pass


scout_layout_api_PanelVisitor.__name__ = "PanelVisitor"
scout_layout_api_PanelVisitor.__qualname__ = "PanelVisitor"
scout_layout_api_PanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SingleTab(ConjureUnionType):
    _v1: Optional["scout_layout_api_SingleTabV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_SingleTabV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_SingleTabV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_SingleTabV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_SingleTabVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_SingleTabVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_SingleTab.__name__ = "SingleTab"
scout_layout_api_SingleTab.__qualname__ = "SingleTab"
scout_layout_api_SingleTab.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SingleTabVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_SingleTabV1") -> Any:
        pass


scout_layout_api_SingleTabVisitor.__name__ = "SingleTabVisitor"
scout_layout_api_SingleTabVisitor.__qualname__ = "SingleTabVisitor"
scout_layout_api_SingleTabVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SingleTabV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'panel': ConjureFieldDefinition('panel', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_title', '_panel']

    def __init__(self, panel: "scout_layout_api_Panel", title: str) -> None:
        self._title = title
        self._panel = panel

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def panel(self) -> "scout_layout_api_Panel":
        return self._panel


scout_layout_api_SingleTabV1.__name__ = "SingleTabV1"
scout_layout_api_SingleTabV1.__qualname__ = "SingleTabV1"
scout_layout_api_SingleTabV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SplitPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_SplitPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_SplitPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_SplitPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_SplitPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_SplitPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_SplitPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_SplitPanel.__name__ = "SplitPanel"
scout_layout_api_SplitPanel.__qualname__ = "SplitPanel"
scout_layout_api_SplitPanel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SplitPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_SplitPanelV1") -> Any:
        pass


scout_layout_api_SplitPanelVisitor.__name__ = "SplitPanelVisitor"
scout_layout_api_SplitPanelVisitor.__qualname__ = "SplitPanelVisitor"
scout_layout_api_SplitPanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SplitPanelOrientation(ConjureEnumType):

    HORIZONTAL = 'HORIZONTAL'
    '''HORIZONTAL'''
    VERTICAL = 'VERTICAL'
    '''VERTICAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_layout_api_SplitPanelOrientation.__name__ = "SplitPanelOrientation"
scout_layout_api_SplitPanelOrientation.__qualname__ = "SplitPanelOrientation"
scout_layout_api_SplitPanelOrientation.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_SplitPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'orientation': ConjureFieldDefinition('orientation', scout_layout_api_SplitPanelOrientation),
            'side_one': ConjureFieldDefinition('sideOne', scout_layout_api_Panel),
            'side_two': ConjureFieldDefinition('sideTwo', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_id', '_orientation', '_side_one', '_side_two']

    def __init__(self, id: str, orientation: "scout_layout_api_SplitPanelOrientation", side_one: "scout_layout_api_Panel", side_two: "scout_layout_api_Panel") -> None:
        self._id = id
        self._orientation = orientation
        self._side_one = side_one
        self._side_two = side_two

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def orientation(self) -> "scout_layout_api_SplitPanelOrientation":
        return self._orientation

    @builtins.property
    def side_one(self) -> "scout_layout_api_Panel":
        return self._side_one

    @builtins.property
    def side_two(self) -> "scout_layout_api_Panel":
        return self._side_two


scout_layout_api_SplitPanelV1.__name__ = "SplitPanelV1"
scout_layout_api_SplitPanelV1.__qualname__ = "SplitPanelV1"
scout_layout_api_SplitPanelV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_TabbedPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_TabbedPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_TabbedPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_TabbedPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_TabbedPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_TabbedPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_TabbedPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_TabbedPanel.__name__ = "TabbedPanel"
scout_layout_api_TabbedPanel.__qualname__ = "TabbedPanel"
scout_layout_api_TabbedPanel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_TabbedPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_TabbedPanelV1") -> Any:
        pass


scout_layout_api_TabbedPanelVisitor.__name__ = "TabbedPanelVisitor"
scout_layout_api_TabbedPanelVisitor.__qualname__ = "TabbedPanelVisitor"
scout_layout_api_TabbedPanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_TabbedPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'tabs': ConjureFieldDefinition('tabs', List[scout_layout_api_SingleTab])
        }

    __slots__: List[str] = ['_id', '_tabs']

    def __init__(self, id: str, tabs: List["scout_layout_api_SingleTab"]) -> None:
        self._id = id
        self._tabs = tabs

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def tabs(self) -> List["scout_layout_api_SingleTab"]:
        return self._tabs


scout_layout_api_TabbedPanelV1.__name__ = "TabbedPanelV1"
scout_layout_api_TabbedPanelV1.__qualname__ = "TabbedPanelV1"
scout_layout_api_TabbedPanelV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_VizPanel(ConjureUnionType):
    _v1: Optional["scout_layout_api_VizPanelV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_VizPanelV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_VizPanelV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_VizPanelV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_VizPanelVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_VizPanelVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_VizPanel.__name__ = "VizPanel"
scout_layout_api_VizPanel.__qualname__ = "VizPanel"
scout_layout_api_VizPanel.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_VizPanelVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_VizPanelV1") -> Any:
        pass


scout_layout_api_VizPanelVisitor.__name__ = "VizPanelVisitor"
scout_layout_api_VizPanelVisitor.__qualname__ = "VizPanelVisitor"
scout_layout_api_VizPanelVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_VizPanelV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_layout_api_PanelId),
            'viz_id': ConjureFieldDefinition('vizId', scout_rids_api_VizId),
            'hide_legend': ConjureFieldDefinition('hideLegend', bool)
        }

    __slots__: List[str] = ['_id', '_viz_id', '_hide_legend']

    def __init__(self, hide_legend: bool, id: str, viz_id: str) -> None:
        self._id = id
        self._viz_id = viz_id
        self._hide_legend = hide_legend

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def viz_id(self) -> str:
        return self._viz_id

    @builtins.property
    def hide_legend(self) -> bool:
        return self._hide_legend


scout_layout_api_VizPanelV1.__name__ = "VizPanelV1"
scout_layout_api_VizPanelV1.__qualname__ = "VizPanelV1"
scout_layout_api_VizPanelV1.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_WorkbookLayout(ConjureUnionType):
    _v1: Optional["scout_layout_api_WorkbookLayoutV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_layout_api_WorkbookLayoutV1)
        }

    def __init__(
            self,
            v1: Optional["scout_layout_api_WorkbookLayoutV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_layout_api_WorkbookLayoutV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_layout_api_WorkbookLayoutVisitor):
            raise ValueError('{} is not an instance of scout_layout_api_WorkbookLayoutVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_layout_api_WorkbookLayout.__name__ = "WorkbookLayout"
scout_layout_api_WorkbookLayout.__qualname__ = "WorkbookLayout"
scout_layout_api_WorkbookLayout.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_WorkbookLayoutVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_layout_api_WorkbookLayoutV1") -> Any:
        pass


scout_layout_api_WorkbookLayoutVisitor.__name__ = "WorkbookLayoutVisitor"
scout_layout_api_WorkbookLayoutVisitor.__qualname__ = "WorkbookLayoutVisitor"
scout_layout_api_WorkbookLayoutVisitor.__module__ = "nominal_api.scout_layout_api"


class scout_layout_api_WorkbookLayoutV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'root_panel': ConjureFieldDefinition('rootPanel', scout_layout_api_Panel)
        }

    __slots__: List[str] = ['_root_panel']

    def __init__(self, root_panel: "scout_layout_api_Panel") -> None:
        self._root_panel = root_panel

    @builtins.property
    def root_panel(self) -> "scout_layout_api_Panel":
        return self._root_panel


scout_layout_api_WorkbookLayoutV1.__name__ = "WorkbookLayoutV1"
scout_layout_api_WorkbookLayoutV1.__qualname__ = "WorkbookLayoutV1"
scout_layout_api_WorkbookLayoutV1.__module__ = "nominal_api.scout_layout_api"


class scout_metadata_CreatedAtQuery(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_operator', '_value']

    def __init__(self, operator: "scout_internal_search_api_Operator", value: str) -> None:
        self._operator = operator
        self._value = value

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator

    @builtins.property
    def value(self) -> str:
        return self._value


scout_metadata_CreatedAtQuery.__name__ = "CreatedAtQuery"
scout_metadata_CreatedAtQuery.__qualname__ = "CreatedAtQuery"
scout_metadata_CreatedAtQuery.__module__ = "nominal_api.scout_metadata"


class scout_metadata_ListPropertiesAndLabelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_types': ConjureFieldDefinition('resourceTypes', OptionalTypeWrapper[List[scout_metadata_ResourceType]]),
            'workspaces': ConjureFieldDefinition('workspaces', OptionalTypeWrapper[List[api_rids_WorkspaceRid]])
        }

    __slots__: List[str] = ['_resource_types', '_workspaces']

    def __init__(self, resource_types: Optional[List["scout_metadata_ResourceType"]] = None, workspaces: Optional[List[str]] = None) -> None:
        self._resource_types = resource_types
        self._workspaces = workspaces

    @builtins.property
    def resource_types(self) -> Optional[List["scout_metadata_ResourceType"]]:
        """If omitted, all resource types are included.
        """
        return self._resource_types

    @builtins.property
    def workspaces(self) -> Optional[List[str]]:
        """If omitted, results will come from all workspaces the user belongs to.
        """
        return self._workspaces


scout_metadata_ListPropertiesAndLabelsRequest.__name__ = "ListPropertiesAndLabelsRequest"
scout_metadata_ListPropertiesAndLabelsRequest.__qualname__ = "ListPropertiesAndLabelsRequest"
scout_metadata_ListPropertiesAndLabelsRequest.__module__ = "nominal_api.scout_metadata"


class scout_metadata_ListPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_metadata_ListPropertiesAndLabelsResponse.__name__ = "ListPropertiesAndLabelsResponse"
scout_metadata_ListPropertiesAndLabelsResponse.__qualname__ = "ListPropertiesAndLabelsResponse"
scout_metadata_ListPropertiesAndLabelsResponse.__module__ = "nominal_api.scout_metadata"


class scout_metadata_ResourceMetadataService(Service):
    """The Resource Metadata Service provides common metadata about resources.
    """

    def list_properties_and_labels(self, auth_header: str, request: "scout_metadata_ListPropertiesAndLabelsRequest") -> "scout_metadata_ListPropertiesAndLabelsResponse":
        """Returns all existing properties (key value pairs) and labels, which can be used to organize resources
such as runs and videos.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/v1/metadata/list-properties-labels'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_metadata_ListPropertiesAndLabelsResponse, self._return_none_for_unknown_union_types)


scout_metadata_ResourceMetadataService.__name__ = "ResourceMetadataService"
scout_metadata_ResourceMetadataService.__qualname__ = "ResourceMetadataService"
scout_metadata_ResourceMetadataService.__module__ = "nominal_api.scout_metadata"


class scout_metadata_ResourceType(ConjureEnumType):

    RUN = 'RUN'
    '''RUN'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    ASSET = 'ASSET'
    '''ASSET'''
    EVENT = 'EVENT'
    '''EVENT'''
    DATASET = 'DATASET'
    '''DATASET'''
    MODULE = 'MODULE'
    '''MODULE'''
    PROCEDURE_EXECUTION = 'PROCEDURE_EXECUTION'
    '''PROCEDURE_EXECUTION'''
    PROCEDURE = 'PROCEDURE'
    '''PROCEDURE'''
    SAVED_VIEW = 'SAVED_VIEW'
    '''SAVED_VIEW'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_metadata_ResourceType.__name__ = "ResourceType"
scout_metadata_ResourceType.__qualname__ = "ResourceType"
scout_metadata_ResourceType.__module__ = "nominal_api.scout_metadata"


class scout_metadata_StringArrayLengthQuery(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator),
            'value': ConjureFieldDefinition('value', int)
        }

    __slots__: List[str] = ['_name', '_operator', '_value']

    def __init__(self, name: str, operator: "scout_internal_search_api_Operator", value: int) -> None:
        self._name = name
        self._operator = operator
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator

    @builtins.property
    def value(self) -> int:
        return self._value


scout_metadata_StringArrayLengthQuery.__name__ = "StringArrayLengthQuery"
scout_metadata_StringArrayLengthQuery.__qualname__ = "StringArrayLengthQuery"
scout_metadata_StringArrayLengthQuery.__module__ = "nominal_api.scout_metadata"


class scout_notebook_api_AssetsFilter(ConjureBeanType):
    """for an exact match, use the exactAssetRids filter
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_operator', '_assets']

    def __init__(self, assets: List[str], operator: "api_SetOperator") -> None:
        self._operator = operator
        self._assets = assets

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets


scout_notebook_api_AssetsFilter.__name__ = "AssetsFilter"
scout_notebook_api_AssetsFilter.__qualname__ = "AssetsFilter"
scout_notebook_api_AssetsFilter.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_ChartWithOverlays(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_VizId),
            'version': ConjureFieldDefinition('version', scout_rids_api_Version),
            'overlays': ConjureFieldDefinition('overlays', object)
        }

    __slots__: List[str] = ['_rid', '_version', '_overlays']

    def __init__(self, overlays: Any, rid: str, version: int) -> None:
        self._rid = rid
        self._version = version
        self._overlays = overlays

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def version(self) -> int:
        return self._version

    @builtins.property
    def overlays(self) -> Any:
        return self._overlays


scout_notebook_api_ChartWithOverlays.__name__ = "ChartWithOverlays"
scout_notebook_api_ChartWithOverlays.__qualname__ = "ChartWithOverlays"
scout_notebook_api_ChartWithOverlays.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_CreateNotebookRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'notebook_type': ConjureFieldDefinition('notebookType', OptionalTypeWrapper[scout_notebook_api_NotebookType]),
            'is_draft': ConjureFieldDefinition('isDraft', bool),
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'data_scope': ConjureFieldDefinition('dataScope', OptionalTypeWrapper[scout_notebook_api_NotebookDataScope]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', OptionalTypeWrapper[scout_workbookcommon_api_UnifiedWorkbookContent]),
            'event_refs': ConjureFieldDefinition('eventRefs', List[scout_workbookcommon_api_EventReference]),
            'check_alert_refs': ConjureFieldDefinition('checkAlertRefs', OptionalTypeWrapper[List[scout_workbookcommon_api_CheckAlertReference]]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_title', '_description', '_notebook_type', '_is_draft', '_state_as_json', '_charts', '_run_rid', '_data_scope', '_layout', '_content', '_content_v2', '_event_refs', '_check_alert_refs', '_workspace']

    def __init__(self, description: str, event_refs: List["scout_workbookcommon_api_EventReference"], is_draft: bool, layout: "scout_layout_api_WorkbookLayout", state_as_json: str, title: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, check_alert_refs: Optional[List["scout_workbookcommon_api_CheckAlertReference"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None, content_v2: Optional["scout_workbookcommon_api_UnifiedWorkbookContent"] = None, data_scope: Optional["scout_notebook_api_NotebookDataScope"] = None, notebook_type: Optional["scout_notebook_api_NotebookType"] = None, run_rid: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._notebook_type = notebook_type
        self._is_draft = is_draft
        self._state_as_json = state_as_json
        self._charts = charts
        self._run_rid = run_rid
        self._data_scope = data_scope
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2
        self._event_refs = event_refs
        self._check_alert_refs = check_alert_refs
        self._workspace = workspace

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def notebook_type(self) -> Optional["scout_notebook_api_NotebookType"]:
        """Optional for backcompatibility. Default is a normal workbook.
        """
        return self._notebook_type

    @builtins.property
    def is_draft(self) -> bool:
        return self._is_draft

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """deprecated. Use dataScope instead
        """
        return self._run_rid

    @builtins.property
    def data_scope(self) -> Optional["scout_notebook_api_NotebookDataScope"]:
        """Optional for back-compatibility.
        """
        return self._data_scope

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> Optional["scout_workbookcommon_api_UnifiedWorkbookContent"]:
        """Optional for backcompatibility
        """
        return self._content_v2

    @builtins.property
    def event_refs(self) -> List["scout_workbookcommon_api_EventReference"]:
        """Field to pin events to a workbook on creation.
        """
        return self._event_refs

    @builtins.property
    def check_alert_refs(self) -> Optional[List["scout_workbookcommon_api_CheckAlertReference"]]:
        """Field to pin check alerts to a workbook on creation.
Any specified CheckAlertReference will be added to the workbook along with it's corresponding EventReference.
        """
        return self._check_alert_refs

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the workbook. If not provided, the workbook will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


scout_notebook_api_CreateNotebookRequest.__name__ = "CreateNotebookRequest"
scout_notebook_api_CreateNotebookRequest.__qualname__ = "CreateNotebookRequest"
scout_notebook_api_CreateNotebookRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_notebook_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_notebook_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_notebook_api_GetAllLabelsAndPropertiesResponse.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_GetSnapshotHistoryRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_rid', '_page_size', '_next_page_token']

    def __init__(self, rid: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._rid = rid
        self._page_size = page_size
        self._next_page_token = next_page_token

    @builtins.property
    def rid(self) -> str:
        """The RID of the workbook to get snapshots for.
        """
        return self._rid

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_notebook_api_GetSnapshotHistoryRequest.__name__ = "GetSnapshotHistoryRequest"
scout_notebook_api_GetSnapshotHistoryRequest.__qualname__ = "GetSnapshotHistoryRequest"
scout_notebook_api_GetSnapshotHistoryRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_GetSnapshotHistoryResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'snapshots': ConjureFieldDefinition('snapshots', List[scout_notebook_api_SnapshotSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_snapshots', '_next_page_token']

    def __init__(self, snapshots: List["scout_notebook_api_SnapshotSummary"], next_page_token: Optional[str] = None) -> None:
        self._snapshots = snapshots
        self._next_page_token = next_page_token

    @builtins.property
    def snapshots(self) -> List["scout_notebook_api_SnapshotSummary"]:
        return self._snapshots

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_notebook_api_GetSnapshotHistoryResponse.__name__ = "GetSnapshotHistoryResponse"
scout_notebook_api_GetSnapshotHistoryResponse.__qualname__ = "GetSnapshotHistoryResponse"
scout_notebook_api_GetSnapshotHistoryResponse.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_Lock(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_locked': ConjureFieldDefinition('isLocked', bool),
            'updated_at': ConjureFieldDefinition('updatedAt', OptionalTypeWrapper[str]),
            'updated_by_rid': ConjureFieldDefinition('updatedByRid', OptionalTypeWrapper[scout_rids_api_UserRid])
        }

    __slots__: List[str] = ['_is_locked', '_updated_at', '_updated_by_rid']

    def __init__(self, is_locked: bool, updated_at: Optional[str] = None, updated_by_rid: Optional[str] = None) -> None:
        self._is_locked = is_locked
        self._updated_at = updated_at
        self._updated_by_rid = updated_by_rid

    @builtins.property
    def is_locked(self) -> bool:
        return self._is_locked

    @builtins.property
    def updated_at(self) -> Optional[str]:
        return self._updated_at

    @builtins.property
    def updated_by_rid(self) -> Optional[str]:
        return self._updated_by_rid


scout_notebook_api_Lock.__name__ = "Lock"
scout_notebook_api_Lock.__qualname__ = "Lock"
scout_notebook_api_Lock.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_Notebook(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'snapshot_rid': ConjureFieldDefinition('snapshotRid', scout_rids_api_SnapshotRid),
            'snapshot_author_rid': ConjureFieldDefinition('snapshotAuthorRid', scout_rids_api_UserRid),
            'snapshot_created_at': ConjureFieldDefinition('snapshotCreatedAt', str),
            'metadata': ConjureFieldDefinition('metadata', scout_notebook_api_NotebookMetadata),
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', scout_workbookcommon_api_UnifiedWorkbookContent),
            'event_refs': ConjureFieldDefinition('eventRefs', List[scout_workbookcommon_api_EventReference]),
            'check_alert_refs': ConjureFieldDefinition('checkAlertRefs', OptionalTypeWrapper[List[scout_workbookcommon_api_CheckAlertReference]])
        }

    __slots__: List[str] = ['_rid', '_snapshot_rid', '_snapshot_author_rid', '_snapshot_created_at', '_metadata', '_state_as_json', '_charts', '_layout', '_content', '_content_v2', '_event_refs', '_check_alert_refs']

    def __init__(self, content_v2: "scout_workbookcommon_api_UnifiedWorkbookContent", event_refs: List["scout_workbookcommon_api_EventReference"], layout: "scout_layout_api_WorkbookLayout", metadata: "scout_notebook_api_NotebookMetadata", rid: str, snapshot_author_rid: str, snapshot_created_at: str, snapshot_rid: str, state_as_json: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, check_alert_refs: Optional[List["scout_workbookcommon_api_CheckAlertReference"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None) -> None:
        self._rid = rid
        self._snapshot_rid = snapshot_rid
        self._snapshot_author_rid = snapshot_author_rid
        self._snapshot_created_at = snapshot_created_at
        self._metadata = metadata
        self._state_as_json = state_as_json
        self._charts = charts
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2
        self._event_refs = event_refs
        self._check_alert_refs = check_alert_refs

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def snapshot_rid(self) -> str:
        return self._snapshot_rid

    @builtins.property
    def snapshot_author_rid(self) -> str:
        return self._snapshot_author_rid

    @builtins.property
    def snapshot_created_at(self) -> str:
        return self._snapshot_created_at

    @builtins.property
    def metadata(self) -> "scout_notebook_api_NotebookMetadata":
        return self._metadata

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> "scout_workbookcommon_api_UnifiedWorkbookContent":
        return self._content_v2

    @builtins.property
    def event_refs(self) -> List["scout_workbookcommon_api_EventReference"]:
        return self._event_refs

    @builtins.property
    def check_alert_refs(self) -> Optional[List["scout_workbookcommon_api_CheckAlertReference"]]:
        return self._check_alert_refs


scout_notebook_api_Notebook.__name__ = "Notebook"
scout_notebook_api_Notebook.__qualname__ = "Notebook"
scout_notebook_api_Notebook.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookDataScope(ConjureUnionType):
    _run_rids: Optional[List[str]] = None
    _asset_rids: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rids': ConjureFieldDefinition('runRids', List[scout_run_api_RunRid]),
            'asset_rids': ConjureFieldDefinition('assetRids', List[scout_rids_api_AssetRid])
        }

    def __init__(
            self,
            run_rids: Optional[List[str]] = None,
            asset_rids: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (run_rids is not None) + (asset_rids is not None) != 1:
                raise ValueError('a union must contain a single member')

            if run_rids is not None:
                self._run_rids = run_rids
                self._type = 'runRids'
            if asset_rids is not None:
                self._asset_rids = asset_rids
                self._type = 'assetRids'

        elif type_of_union == 'runRids':
            if run_rids is None:
                raise ValueError('a union value must not be None')
            self._run_rids = run_rids
            self._type = 'runRids'
        elif type_of_union == 'assetRids':
            if asset_rids is None:
                raise ValueError('a union value must not be None')
            self._asset_rids = asset_rids
            self._type = 'assetRids'

    @builtins.property
    def run_rids(self) -> Optional[List[str]]:
        return self._run_rids

    @builtins.property
    def asset_rids(self) -> Optional[List[str]]:
        return self._asset_rids

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_notebook_api_NotebookDataScopeVisitor):
            raise ValueError('{} is not an instance of scout_notebook_api_NotebookDataScopeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'runRids' and self.run_rids is not None:
            return visitor._run_rids(self.run_rids)
        if self._type == 'assetRids' and self.asset_rids is not None:
            return visitor._asset_rids(self.asset_rids)


scout_notebook_api_NotebookDataScope.__name__ = "NotebookDataScope"
scout_notebook_api_NotebookDataScope.__qualname__ = "NotebookDataScope"
scout_notebook_api_NotebookDataScope.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookDataScopeVisitor:

    @abstractmethod
    def _run_rids(self, run_rids: List[str]) -> Any:
        pass

    @abstractmethod
    def _asset_rids(self, asset_rids: List[str]) -> Any:
        pass


scout_notebook_api_NotebookDataScopeVisitor.__name__ = "NotebookDataScopeVisitor"
scout_notebook_api_NotebookDataScopeVisitor.__qualname__ = "NotebookDataScopeVisitor"
scout_notebook_api_NotebookDataScopeVisitor.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'data_scope': ConjureFieldDefinition('dataScope', scout_notebook_api_NotebookDataScope),
            'notebook_type': ConjureFieldDefinition('notebookType', scout_notebook_api_NotebookType),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'is_draft': ConjureFieldDefinition('isDraft', bool),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'lock': ConjureFieldDefinition('lock', scout_notebook_api_Lock),
            'created_by_rid': ConjureFieldDefinition('createdByRid', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_run_rid', '_data_scope', '_notebook_type', '_title', '_description', '_is_draft', '_is_archived', '_lock', '_created_by_rid', '_created_at', '_updated_at', '_properties', '_labels']

    def __init__(self, created_at: str, created_by_rid: str, data_scope: "scout_notebook_api_NotebookDataScope", description: str, is_archived: bool, is_draft: bool, labels: List[str], lock: "scout_notebook_api_Lock", notebook_type: "scout_notebook_api_NotebookType", properties: Dict[str, str], title: str, run_rid: Optional[str] = None, updated_at: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._data_scope = data_scope
        self._notebook_type = notebook_type
        self._title = title
        self._description = description
        self._is_draft = is_draft
        self._is_archived = is_archived
        self._lock = lock
        self._created_by_rid = created_by_rid
        self._created_at = created_at
        self._updated_at = updated_at
        self._properties = properties
        self._labels = labels

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """deprecated. Use dataScope instead
        """
        return self._run_rid

    @builtins.property
    def data_scope(self) -> "scout_notebook_api_NotebookDataScope":
        return self._data_scope

    @builtins.property
    def notebook_type(self) -> "scout_notebook_api_NotebookType":
        return self._notebook_type

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def is_draft(self) -> bool:
        return self._is_draft

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def lock(self) -> "scout_notebook_api_Lock":
        return self._lock

    @builtins.property
    def created_by_rid(self) -> str:
        return self._created_by_rid

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> Optional[str]:
        """The timestamp when the workbook was last updated
        """
        return self._updated_at

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_notebook_api_NotebookMetadata.__name__ = "NotebookMetadata"
scout_notebook_api_NotebookMetadata.__qualname__ = "NotebookMetadata"
scout_notebook_api_NotebookMetadata.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookMetadataWithRid(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_NotebookRid),
            'metadata': ConjureFieldDefinition('metadata', scout_notebook_api_NotebookMetadata)
        }

    __slots__: List[str] = ['_rid', '_metadata']

    def __init__(self, metadata: "scout_notebook_api_NotebookMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_notebook_api_NotebookMetadata":
        return self._metadata


scout_notebook_api_NotebookMetadataWithRid.__name__ = "NotebookMetadataWithRid"
scout_notebook_api_NotebookMetadataWithRid.__qualname__ = "NotebookMetadataWithRid"
scout_notebook_api_NotebookMetadataWithRid.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookType(ConjureEnumType):

    WORKBOOK = 'WORKBOOK'
    '''WORKBOOK'''
    COMPARISON_WORKBOOK = 'COMPARISON_WORKBOOK'
    '''COMPARISON_WORKBOOK'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_notebook_api_NotebookType.__name__ = "NotebookType"
scout_notebook_api_NotebookType.__qualname__ = "NotebookType"
scout_notebook_api_NotebookType.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_NotebookTypesFilter(ConjureBeanType):
    """returns notebooks that match any of the provided notebook types
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'types': ConjureFieldDefinition('types', List[scout_notebook_api_NotebookType])
        }

    __slots__: List[str] = ['_types']

    def __init__(self, types: List["scout_notebook_api_NotebookType"]) -> None:
        self._types = types

    @builtins.property
    def types(self) -> List["scout_notebook_api_NotebookType"]:
        return self._types


scout_notebook_api_NotebookTypesFilter.__name__ = "NotebookTypesFilter"
scout_notebook_api_NotebookTypesFilter.__qualname__ = "NotebookTypesFilter"
scout_notebook_api_NotebookTypesFilter.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_RunsFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'runs': ConjureFieldDefinition('runs', List[scout_run_api_RunRid])
        }

    __slots__: List[str] = ['_operator', '_runs']

    def __init__(self, operator: "api_SetOperator", runs: List[str]) -> None:
        self._operator = operator
        self._runs = runs

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def runs(self) -> List[str]:
        return self._runs


scout_notebook_api_RunsFilter.__name__ = "RunsFilter"
scout_notebook_api_RunsFilter.__qualname__ = "RunsFilter"
scout_notebook_api_RunsFilter.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksQuery(ConjureUnionType):
    _and_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None
    _or_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None
    _not_: Optional["scout_notebook_api_SearchNotebooksQuery"] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _asset_rid: Optional[str] = None
    _asset_rids: Optional["scout_notebook_api_AssetsFilter"] = None
    _exact_asset_rids: Optional[List[str]] = None
    _author_rid: Optional[str] = None
    _run_rid: Optional[str] = None
    _run_rids: Optional["scout_notebook_api_RunsFilter"] = None
    _notebook_type: Optional["scout_notebook_api_NotebookType"] = None
    _notebook_types: Optional["scout_notebook_api_NotebookTypesFilter"] = None
    _draft_state: Optional[bool] = None
    _archived: Optional[bool] = None
    _workspace: Optional[str] = None
    _author_is_current_user: Optional[bool] = None
    _author_rids: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_notebook_api_SearchNotebooksQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_notebook_api_SearchNotebooksQuery]),
            'not_': ConjureFieldDefinition('not', scout_notebook_api_SearchNotebooksQuery),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'asset_rid': ConjureFieldDefinition('assetRid', scout_rids_api_AssetRid),
            'asset_rids': ConjureFieldDefinition('assetRids', scout_notebook_api_AssetsFilter),
            'exact_asset_rids': ConjureFieldDefinition('exactAssetRids', List[scout_rids_api_AssetRid]),
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'run_rid': ConjureFieldDefinition('runRid', scout_run_api_RunRid),
            'run_rids': ConjureFieldDefinition('runRids', scout_notebook_api_RunsFilter),
            'notebook_type': ConjureFieldDefinition('notebookType', scout_notebook_api_NotebookType),
            'notebook_types': ConjureFieldDefinition('notebookTypes', scout_notebook_api_NotebookTypesFilter),
            'draft_state': ConjureFieldDefinition('draftState', bool),
            'archived': ConjureFieldDefinition('archived', bool),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'author_is_current_user': ConjureFieldDefinition('authorIsCurrentUser', bool),
            'author_rids': ConjureFieldDefinition('authorRids', List[scout_rids_api_UserRid])
        }

    def __init__(
            self,
            and_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None,
            or_: Optional[List["scout_notebook_api_SearchNotebooksQuery"]] = None,
            not_: Optional["scout_notebook_api_SearchNotebooksQuery"] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            asset_rid: Optional[str] = None,
            asset_rids: Optional["scout_notebook_api_AssetsFilter"] = None,
            exact_asset_rids: Optional[List[str]] = None,
            author_rid: Optional[str] = None,
            run_rid: Optional[str] = None,
            run_rids: Optional["scout_notebook_api_RunsFilter"] = None,
            notebook_type: Optional["scout_notebook_api_NotebookType"] = None,
            notebook_types: Optional["scout_notebook_api_NotebookTypesFilter"] = None,
            draft_state: Optional[bool] = None,
            archived: Optional[bool] = None,
            workspace: Optional[str] = None,
            author_is_current_user: Optional[bool] = None,
            author_rids: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (not_ is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (asset_rid is not None) + (asset_rids is not None) + (exact_asset_rids is not None) + (author_rid is not None) + (run_rid is not None) + (run_rids is not None) + (notebook_type is not None) + (notebook_types is not None) + (draft_state is not None) + (archived is not None) + (workspace is not None) + (author_is_current_user is not None) + (author_rids is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if asset_rid is not None:
                self._asset_rid = asset_rid
                self._type = 'assetRid'
            if asset_rids is not None:
                self._asset_rids = asset_rids
                self._type = 'assetRids'
            if exact_asset_rids is not None:
                self._exact_asset_rids = exact_asset_rids
                self._type = 'exactAssetRids'
            if author_rid is not None:
                self._author_rid = author_rid
                self._type = 'authorRid'
            if run_rid is not None:
                self._run_rid = run_rid
                self._type = 'runRid'
            if run_rids is not None:
                self._run_rids = run_rids
                self._type = 'runRids'
            if notebook_type is not None:
                self._notebook_type = notebook_type
                self._type = 'notebookType'
            if notebook_types is not None:
                self._notebook_types = notebook_types
                self._type = 'notebookTypes'
            if draft_state is not None:
                self._draft_state = draft_state
                self._type = 'draftState'
            if archived is not None:
                self._archived = archived
                self._type = 'archived'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if author_is_current_user is not None:
                self._author_is_current_user = author_is_current_user
                self._type = 'authorIsCurrentUser'
            if author_rids is not None:
                self._author_rids = author_rids
                self._type = 'authorRids'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'assetRid':
            if asset_rid is None:
                raise ValueError('a union value must not be None')
            self._asset_rid = asset_rid
            self._type = 'assetRid'
        elif type_of_union == 'assetRids':
            if asset_rids is None:
                raise ValueError('a union value must not be None')
            self._asset_rids = asset_rids
            self._type = 'assetRids'
        elif type_of_union == 'exactAssetRids':
            if exact_asset_rids is None:
                raise ValueError('a union value must not be None')
            self._exact_asset_rids = exact_asset_rids
            self._type = 'exactAssetRids'
        elif type_of_union == 'authorRid':
            if author_rid is None:
                raise ValueError('a union value must not be None')
            self._author_rid = author_rid
            self._type = 'authorRid'
        elif type_of_union == 'runRid':
            if run_rid is None:
                raise ValueError('a union value must not be None')
            self._run_rid = run_rid
            self._type = 'runRid'
        elif type_of_union == 'runRids':
            if run_rids is None:
                raise ValueError('a union value must not be None')
            self._run_rids = run_rids
            self._type = 'runRids'
        elif type_of_union == 'notebookType':
            if notebook_type is None:
                raise ValueError('a union value must not be None')
            self._notebook_type = notebook_type
            self._type = 'notebookType'
        elif type_of_union == 'notebookTypes':
            if notebook_types is None:
                raise ValueError('a union value must not be None')
            self._notebook_types = notebook_types
            self._type = 'notebookTypes'
        elif type_of_union == 'draftState':
            if draft_state is None:
                raise ValueError('a union value must not be None')
            self._draft_state = draft_state
            self._type = 'draftState'
        elif type_of_union == 'archived':
            if archived is None:
                raise ValueError('a union value must not be None')
            self._archived = archived
            self._type = 'archived'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'authorIsCurrentUser':
            if author_is_current_user is None:
                raise ValueError('a union value must not be None')
            self._author_is_current_user = author_is_current_user
            self._type = 'authorIsCurrentUser'
        elif type_of_union == 'authorRids':
            if author_rids is None:
                raise ValueError('a union value must not be None')
            self._author_rids = author_rids
            self._type = 'authorRids'

    @builtins.property
    def and_(self) -> Optional[List["scout_notebook_api_SearchNotebooksQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_notebook_api_SearchNotebooksQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_notebook_api_SearchNotebooksQuery"]:
        return self._not_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def asset_rid(self) -> Optional[str]:
        return self._asset_rid

    @builtins.property
    def asset_rids(self) -> Optional["scout_notebook_api_AssetsFilter"]:
        return self._asset_rids

    @builtins.property
    def exact_asset_rids(self) -> Optional[List[str]]:
        """Requires the set of assets in the query to exactly match the set of assets in the notebook.
To do a partial match, use an assetRids query.
        """
        return self._exact_asset_rids

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def run_rid(self) -> Optional[str]:
        return self._run_rid

    @builtins.property
    def run_rids(self) -> Optional["scout_notebook_api_RunsFilter"]:
        return self._run_rids

    @builtins.property
    def notebook_type(self) -> Optional["scout_notebook_api_NotebookType"]:
        return self._notebook_type

    @builtins.property
    def notebook_types(self) -> Optional["scout_notebook_api_NotebookTypesFilter"]:
        return self._notebook_types

    @builtins.property
    def draft_state(self) -> Optional[bool]:
        return self._draft_state

    @builtins.property
    def archived(self) -> Optional[bool]:
        return self._archived

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def author_is_current_user(self) -> Optional[bool]:
        return self._author_is_current_user

    @builtins.property
    def author_rids(self) -> Optional[List[str]]:
        return self._author_rids

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_notebook_api_SearchNotebooksQueryVisitor):
            raise ValueError('{} is not an instance of scout_notebook_api_SearchNotebooksQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'assetRid' and self.asset_rid is not None:
            return visitor._asset_rid(self.asset_rid)
        if self._type == 'assetRids' and self.asset_rids is not None:
            return visitor._asset_rids(self.asset_rids)
        if self._type == 'exactAssetRids' and self.exact_asset_rids is not None:
            return visitor._exact_asset_rids(self.exact_asset_rids)
        if self._type == 'authorRid' and self.author_rid is not None:
            return visitor._author_rid(self.author_rid)
        if self._type == 'runRid' and self.run_rid is not None:
            return visitor._run_rid(self.run_rid)
        if self._type == 'runRids' and self.run_rids is not None:
            return visitor._run_rids(self.run_rids)
        if self._type == 'notebookType' and self.notebook_type is not None:
            return visitor._notebook_type(self.notebook_type)
        if self._type == 'notebookTypes' and self.notebook_types is not None:
            return visitor._notebook_types(self.notebook_types)
        if self._type == 'draftState' and self.draft_state is not None:
            return visitor._draft_state(self.draft_state)
        if self._type == 'archived' and self.archived is not None:
            return visitor._archived(self.archived)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'authorIsCurrentUser' and self.author_is_current_user is not None:
            return visitor._author_is_current_user(self.author_is_current_user)
        if self._type == 'authorRids' and self.author_rids is not None:
            return visitor._author_rids(self.author_rids)


scout_notebook_api_SearchNotebooksQuery.__name__ = "SearchNotebooksQuery"
scout_notebook_api_SearchNotebooksQuery.__qualname__ = "SearchNotebooksQuery"
scout_notebook_api_SearchNotebooksQuery.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_notebook_api_SearchNotebooksQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_notebook_api_SearchNotebooksQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_notebook_api_SearchNotebooksQuery") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _asset_rid(self, asset_rid: str) -> Any:
        pass

    @abstractmethod
    def _asset_rids(self, asset_rids: "scout_notebook_api_AssetsFilter") -> Any:
        pass

    @abstractmethod
    def _exact_asset_rids(self, exact_asset_rids: List[str]) -> Any:
        pass

    @abstractmethod
    def _author_rid(self, author_rid: str) -> Any:
        pass

    @abstractmethod
    def _run_rid(self, run_rid: str) -> Any:
        pass

    @abstractmethod
    def _run_rids(self, run_rids: "scout_notebook_api_RunsFilter") -> Any:
        pass

    @abstractmethod
    def _notebook_type(self, notebook_type: "scout_notebook_api_NotebookType") -> Any:
        pass

    @abstractmethod
    def _notebook_types(self, notebook_types: "scout_notebook_api_NotebookTypesFilter") -> Any:
        pass

    @abstractmethod
    def _draft_state(self, draft_state: bool) -> Any:
        pass

    @abstractmethod
    def _archived(self, archived: bool) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _author_is_current_user(self, author_is_current_user: bool) -> Any:
        pass

    @abstractmethod
    def _author_rids(self, author_rids: List[str]) -> Any:
        pass


scout_notebook_api_SearchNotebooksQueryVisitor.__name__ = "SearchNotebooksQueryVisitor"
scout_notebook_api_SearchNotebooksQueryVisitor.__qualname__ = "SearchNotebooksQueryVisitor"
scout_notebook_api_SearchNotebooksQueryVisitor.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_notebook_api_SearchNotebooksQuery),
            'show_drafts': ConjureFieldDefinition('showDrafts', bool),
            'show_archived': ConjureFieldDefinition('showArchived', OptionalTypeWrapper[bool]),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_notebook_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_show_drafts', '_show_archived', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "scout_notebook_api_SearchNotebooksQuery", show_drafts: bool, next_page_token: Optional[str] = None, page_size: Optional[int] = None, show_archived: Optional[bool] = None, sort_by: Optional["scout_notebook_api_SortBy"] = None) -> None:
        self._query = query
        self._show_drafts = show_drafts
        self._show_archived = show_archived
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "scout_notebook_api_SearchNotebooksQuery":
        return self._query

    @builtins.property
    def show_drafts(self) -> bool:
        """Soon to be deprecated. Compose a draftState filter within SearchNotebooksQuery instead
        """
        return self._show_drafts

    @builtins.property
    def show_archived(self) -> Optional[bool]:
        """Soon to be deprecated. Compose an archived filter within SearchNotebooksQuery instead
        """
        return self._show_archived

    @builtins.property
    def sort_by(self) -> Optional["scout_notebook_api_SortBy"]:
        """UPDATED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size


scout_notebook_api_SearchNotebooksRequest.__name__ = "SearchNotebooksRequest"
scout_notebook_api_SearchNotebooksRequest.__qualname__ = "SearchNotebooksRequest"
scout_notebook_api_SearchNotebooksRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SearchNotebooksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_notebook_api_NotebookMetadataWithRid]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_notebook_api_NotebookMetadataWithRid"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_notebook_api_NotebookMetadataWithRid"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_notebook_api_SearchNotebooksResponse.__name__ = "SearchNotebooksResponse"
scout_notebook_api_SearchNotebooksResponse.__qualname__ = "SearchNotebooksResponse"
scout_notebook_api_SearchNotebooksResponse.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SnapshotSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_SnapshotRid),
            'notebook_rid': ConjureFieldDefinition('notebookRid', scout_rids_api_NotebookRid),
            'author_rid': ConjureFieldDefinition('authorRid', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str)
        }

    __slots__: List[str] = ['_rid', '_notebook_rid', '_author_rid', '_created_at']

    def __init__(self, author_rid: str, created_at: str, notebook_rid: str, rid: str) -> None:
        self._rid = rid
        self._notebook_rid = notebook_rid
        self._author_rid = author_rid
        self._created_at = created_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def notebook_rid(self) -> str:
        return self._notebook_rid

    @builtins.property
    def author_rid(self) -> str:
        return self._author_rid

    @builtins.property
    def created_at(self) -> str:
        return self._created_at


scout_notebook_api_SnapshotSummary.__name__ = "SnapshotSummary"
scout_notebook_api_SnapshotSummary.__qualname__ = "SnapshotSummary"
scout_notebook_api_SnapshotSummary.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_notebook_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_notebook_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_notebook_api_SortByField":
        return self._field


scout_notebook_api_SortBy.__name__ = "SortBy"
scout_notebook_api_SortBy.__qualname__ = "SortBy"
scout_notebook_api_SortBy.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_SortByField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_notebook_api_SortByField.__name__ = "SortByField"
scout_notebook_api_SortByField.__qualname__ = "SortByField"
scout_notebook_api_SortByField.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_UpdateNotebookMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'data_scope': ConjureFieldDefinition('dataScope', OptionalTypeWrapper[scout_notebook_api_NotebookDataScope]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'is_draft': ConjureFieldDefinition('isDraft', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_data_scope', '_description', '_properties', '_labels', '_is_draft']

    def __init__(self, data_scope: Optional["scout_notebook_api_NotebookDataScope"] = None, description: Optional[str] = None, is_draft: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._data_scope = data_scope
        self._description = description
        self._properties = properties
        self._labels = labels
        self._is_draft = is_draft

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def data_scope(self) -> Optional["scout_notebook_api_NotebookDataScope"]:
        """Optional for backcompatibility.
        """
        return self._data_scope

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def is_draft(self) -> Optional[bool]:
        return self._is_draft


scout_notebook_api_UpdateNotebookMetadataRequest.__name__ = "UpdateNotebookMetadataRequest"
scout_notebook_api_UpdateNotebookMetadataRequest.__qualname__ = "UpdateNotebookMetadataRequest"
scout_notebook_api_UpdateNotebookMetadataRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_UpdateNotebookRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'state_as_json': ConjureFieldDefinition('stateAsJson', str),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_notebook_api_ChartWithOverlays]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookContent]),
            'content_v2': ConjureFieldDefinition('contentV2', OptionalTypeWrapper[scout_workbookcommon_api_UnifiedWorkbookContent]),
            'latest_snapshot_rid': ConjureFieldDefinition('latestSnapshotRid', OptionalTypeWrapper[scout_rids_api_SnapshotRid]),
            'event_refs': ConjureFieldDefinition('eventRefs', List[scout_workbookcommon_api_EventReference]),
            'check_alert_refs': ConjureFieldDefinition('checkAlertRefs', OptionalTypeWrapper[List[scout_workbookcommon_api_CheckAlertReference]])
        }

    __slots__: List[str] = ['_state_as_json', '_charts', '_layout', '_content', '_content_v2', '_latest_snapshot_rid', '_event_refs', '_check_alert_refs']

    def __init__(self, event_refs: List["scout_workbookcommon_api_EventReference"], layout: "scout_layout_api_WorkbookLayout", state_as_json: str, charts: Optional[List["scout_notebook_api_ChartWithOverlays"]] = None, check_alert_refs: Optional[List["scout_workbookcommon_api_CheckAlertReference"]] = None, content: Optional["scout_workbookcommon_api_WorkbookContent"] = None, content_v2: Optional["scout_workbookcommon_api_UnifiedWorkbookContent"] = None, latest_snapshot_rid: Optional[str] = None) -> None:
        self._state_as_json = state_as_json
        self._charts = charts
        self._layout = layout
        self._content = content
        self._content_v2 = content_v2
        self._latest_snapshot_rid = latest_snapshot_rid
        self._event_refs = event_refs
        self._check_alert_refs = check_alert_refs

    @builtins.property
    def state_as_json(self) -> str:
        return self._state_as_json

    @builtins.property
    def charts(self) -> Optional[List["scout_notebook_api_ChartWithOverlays"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._content

    @builtins.property
    def content_v2(self) -> Optional["scout_workbookcommon_api_UnifiedWorkbookContent"]:
        """Optional for backcompatibility
        """
        return self._content_v2

    @builtins.property
    def latest_snapshot_rid(self) -> Optional[str]:
        """If provided, will only update the notebook if the latest snapshot matches the provided snapshot rid,
and throws SaveNotebookConflict otherwise.
        """
        return self._latest_snapshot_rid

    @builtins.property
    def event_refs(self) -> List["scout_workbookcommon_api_EventReference"]:
        """Replace existing pinned events on the workbook.
        """
        return self._event_refs

    @builtins.property
    def check_alert_refs(self) -> Optional[List["scout_workbookcommon_api_CheckAlertReference"]]:
        """Field to pin check alerts to a workbook on creation.
If not provided, will keep the set of check alerts on the workbook unchanged.
Providing an empty set will remove all check alerts from the workbook.
Any specified CheckAlertReference will be added to the workbook along with it's corresponding EventReference.
        """
        return self._check_alert_refs


scout_notebook_api_UpdateNotebookRequest.__name__ = "UpdateNotebookRequest"
scout_notebook_api_UpdateNotebookRequest.__qualname__ = "UpdateNotebookRequest"
scout_notebook_api_UpdateNotebookRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_notebook_api_UpdateRefNameRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ref_name_updates': ConjureFieldDefinition('refNameUpdates', Dict[scout_api_DataSourceRefName, scout_api_DataSourceRefName])
        }

    __slots__: List[str] = ['_ref_name_updates']

    def __init__(self, ref_name_updates: Dict[str, str]) -> None:
        self._ref_name_updates = ref_name_updates

    @builtins.property
    def ref_name_updates(self) -> Dict[str, str]:
        return self._ref_name_updates


scout_notebook_api_UpdateRefNameRequest.__name__ = "UpdateRefNameRequest"
scout_notebook_api_UpdateRefNameRequest.__qualname__ = "UpdateRefNameRequest"
scout_notebook_api_UpdateRefNameRequest.__module__ = "nominal_api.scout_notebook_api"


class scout_plotting_TimestampType(ConjureEnumType):

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_plotting_TimestampType.__name__ = "TimestampType"
scout_plotting_TimestampType.__qualname__ = "TimestampType"
scout_plotting_TimestampType.__module__ = "nominal_api.scout_plotting"


class scout_rids_api_CheckAlertState(ConjureUnionType):
    _pending_review: Optional["scout_rids_api_PendingReviewAlertState"] = None
    _closed_with_further_action: Optional["scout_rids_api_ClosedWithFurtherActionAlertState"] = None
    _closed_with_ignore: Optional["scout_rids_api_ClosedWithIgnoreAlertState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', scout_rids_api_PendingReviewAlertState),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', scout_rids_api_ClosedWithFurtherActionAlertState),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', scout_rids_api_ClosedWithIgnoreAlertState)
        }

    def __init__(
            self,
            pending_review: Optional["scout_rids_api_PendingReviewAlertState"] = None,
            closed_with_further_action: Optional["scout_rids_api_ClosedWithFurtherActionAlertState"] = None,
            closed_with_ignore: Optional["scout_rids_api_ClosedWithIgnoreAlertState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (pending_review is not None) + (closed_with_further_action is not None) + (closed_with_ignore is not None) != 1:
                raise ValueError('a union must contain a single member')

            if pending_review is not None:
                self._pending_review = pending_review
                self._type = 'pendingReview'
            if closed_with_further_action is not None:
                self._closed_with_further_action = closed_with_further_action
                self._type = 'closedWithFurtherAction'
            if closed_with_ignore is not None:
                self._closed_with_ignore = closed_with_ignore
                self._type = 'closedWithIgnore'

        elif type_of_union == 'pendingReview':
            if pending_review is None:
                raise ValueError('a union value must not be None')
            self._pending_review = pending_review
            self._type = 'pendingReview'
        elif type_of_union == 'closedWithFurtherAction':
            if closed_with_further_action is None:
                raise ValueError('a union value must not be None')
            self._closed_with_further_action = closed_with_further_action
            self._type = 'closedWithFurtherAction'
        elif type_of_union == 'closedWithIgnore':
            if closed_with_ignore is None:
                raise ValueError('a union value must not be None')
            self._closed_with_ignore = closed_with_ignore
            self._type = 'closedWithIgnore'

    @builtins.property
    def pending_review(self) -> Optional["scout_rids_api_PendingReviewAlertState"]:
        return self._pending_review

    @builtins.property
    def closed_with_further_action(self) -> Optional["scout_rids_api_ClosedWithFurtherActionAlertState"]:
        return self._closed_with_further_action

    @builtins.property
    def closed_with_ignore(self) -> Optional["scout_rids_api_ClosedWithIgnoreAlertState"]:
        return self._closed_with_ignore

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_rids_api_CheckAlertStateVisitor):
            raise ValueError('{} is not an instance of scout_rids_api_CheckAlertStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'pendingReview' and self.pending_review is not None:
            return visitor._pending_review(self.pending_review)
        if self._type == 'closedWithFurtherAction' and self.closed_with_further_action is not None:
            return visitor._closed_with_further_action(self.closed_with_further_action)
        if self._type == 'closedWithIgnore' and self.closed_with_ignore is not None:
            return visitor._closed_with_ignore(self.closed_with_ignore)


scout_rids_api_CheckAlertState.__name__ = "CheckAlertState"
scout_rids_api_CheckAlertState.__qualname__ = "CheckAlertState"
scout_rids_api_CheckAlertState.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_CheckAlertStateVisitor:

    @abstractmethod
    def _pending_review(self, pending_review: "scout_rids_api_PendingReviewAlertState") -> Any:
        pass

    @abstractmethod
    def _closed_with_further_action(self, closed_with_further_action: "scout_rids_api_ClosedWithFurtherActionAlertState") -> Any:
        pass

    @abstractmethod
    def _closed_with_ignore(self, closed_with_ignore: "scout_rids_api_ClosedWithIgnoreAlertState") -> Any:
        pass


scout_rids_api_CheckAlertStateVisitor.__name__ = "CheckAlertStateVisitor"
scout_rids_api_CheckAlertStateVisitor.__qualname__ = "CheckAlertStateVisitor"
scout_rids_api_CheckAlertStateVisitor.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_ClosedWithFurtherActionAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_rids_api_ClosedWithFurtherActionAlertState.__name__ = "ClosedWithFurtherActionAlertState"
scout_rids_api_ClosedWithFurtherActionAlertState.__qualname__ = "ClosedWithFurtherActionAlertState"
scout_rids_api_ClosedWithFurtherActionAlertState.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_ClosedWithIgnoreAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'comment': ConjureFieldDefinition('comment', str),
            'closed_by': ConjureFieldDefinition('closedBy', scout_rids_api_UserRid)
        }

    __slots__: List[str] = ['_comment', '_closed_by']

    def __init__(self, closed_by: str, comment: str) -> None:
        self._comment = comment
        self._closed_by = closed_by

    @builtins.property
    def comment(self) -> str:
        return self._comment

    @builtins.property
    def closed_by(self) -> str:
        return self._closed_by


scout_rids_api_ClosedWithIgnoreAlertState.__name__ = "ClosedWithIgnoreAlertState"
scout_rids_api_ClosedWithIgnoreAlertState.__qualname__ = "ClosedWithIgnoreAlertState"
scout_rids_api_ClosedWithIgnoreAlertState.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_ComputeEventQuery(ConjureUnionType):
    _search_text: Optional["scout_compute_api_StringConstant"] = None
    _after: Optional["scout_compute_api_TimestampConstant"] = None
    _before: Optional["scout_compute_api_TimestampConstant"] = None
    _advanced_time_filter: Optional["scout_rids_api_EventTimeFilter"] = None
    _asset: Optional["scout_compute_api_StringConstant"] = None
    _template: Optional["scout_compute_api_StringConstant"] = None
    _workbook: Optional["scout_compute_api_StringConstant"] = None
    _data_review: Optional["scout_compute_api_StringConstant"] = None
    _origin_type: Optional["scout_rids_api_SearchEventOriginType"] = None
    _data_review_check: Optional["scout_compute_api_StringConstant"] = None
    _disposition_status: Optional["scout_rids_api_EventDispositionStatus"] = None
    _priority: Optional["scout_compute_api_StringConstant"] = None
    _assignee: Optional["scout_compute_api_StringConstant"] = None
    _event_type: Optional["scout_rids_api_EventType"] = None
    _created_by: Optional["scout_compute_api_StringConstant"] = None
    _label: Optional["scout_compute_api_StringConstant"] = None
    _property: Optional["scout_rids_api_Property"] = None
    _and_: Optional[List["scout_rids_api_ComputeEventQuery"]] = None
    _or_: Optional[List["scout_rids_api_ComputeEventQuery"]] = None
    _not_: Optional["scout_rids_api_ComputeEventQuery"] = None
    _workspace: Optional["scout_compute_api_StringConstant"] = None
    _procedure: Optional["scout_compute_api_StringConstant"] = None
    _procedure_execution: Optional["scout_compute_api_StringConstant"] = None
    _step_id: Optional["scout_compute_api_StringConstant"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', scout_compute_api_StringConstant),
            'after': ConjureFieldDefinition('after', scout_compute_api_TimestampConstant),
            'before': ConjureFieldDefinition('before', scout_compute_api_TimestampConstant),
            'advanced_time_filter': ConjureFieldDefinition('advancedTimeFilter', scout_rids_api_EventTimeFilter),
            'asset': ConjureFieldDefinition('asset', scout_compute_api_StringConstant),
            'template': ConjureFieldDefinition('template', scout_compute_api_StringConstant),
            'workbook': ConjureFieldDefinition('workbook', scout_compute_api_StringConstant),
            'data_review': ConjureFieldDefinition('dataReview', scout_compute_api_StringConstant),
            'origin_type': ConjureFieldDefinition('originType', scout_rids_api_SearchEventOriginType),
            'data_review_check': ConjureFieldDefinition('dataReviewCheck', scout_compute_api_StringConstant),
            'disposition_status': ConjureFieldDefinition('dispositionStatus', scout_rids_api_EventDispositionStatus),
            'priority': ConjureFieldDefinition('priority', scout_compute_api_StringConstant),
            'assignee': ConjureFieldDefinition('assignee', scout_compute_api_StringConstant),
            'event_type': ConjureFieldDefinition('eventType', scout_rids_api_EventType),
            'created_by': ConjureFieldDefinition('createdBy', scout_compute_api_StringConstant),
            'label': ConjureFieldDefinition('label', scout_compute_api_StringConstant),
            'property': ConjureFieldDefinition('property', scout_rids_api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_rids_api_ComputeEventQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_rids_api_ComputeEventQuery]),
            'not_': ConjureFieldDefinition('not', scout_rids_api_ComputeEventQuery),
            'workspace': ConjureFieldDefinition('workspace', scout_compute_api_StringConstant),
            'procedure': ConjureFieldDefinition('procedure', scout_compute_api_StringConstant),
            'procedure_execution': ConjureFieldDefinition('procedureExecution', scout_compute_api_StringConstant),
            'step_id': ConjureFieldDefinition('stepId', scout_compute_api_StringConstant)
        }

    def __init__(
            self,
            search_text: Optional["scout_compute_api_StringConstant"] = None,
            after: Optional["scout_compute_api_TimestampConstant"] = None,
            before: Optional["scout_compute_api_TimestampConstant"] = None,
            advanced_time_filter: Optional["scout_rids_api_EventTimeFilter"] = None,
            asset: Optional["scout_compute_api_StringConstant"] = None,
            template: Optional["scout_compute_api_StringConstant"] = None,
            workbook: Optional["scout_compute_api_StringConstant"] = None,
            data_review: Optional["scout_compute_api_StringConstant"] = None,
            origin_type: Optional["scout_rids_api_SearchEventOriginType"] = None,
            data_review_check: Optional["scout_compute_api_StringConstant"] = None,
            disposition_status: Optional["scout_rids_api_EventDispositionStatus"] = None,
            priority: Optional["scout_compute_api_StringConstant"] = None,
            assignee: Optional["scout_compute_api_StringConstant"] = None,
            event_type: Optional["scout_rids_api_EventType"] = None,
            created_by: Optional["scout_compute_api_StringConstant"] = None,
            label: Optional["scout_compute_api_StringConstant"] = None,
            property: Optional["scout_rids_api_Property"] = None,
            and_: Optional[List["scout_rids_api_ComputeEventQuery"]] = None,
            or_: Optional[List["scout_rids_api_ComputeEventQuery"]] = None,
            not_: Optional["scout_rids_api_ComputeEventQuery"] = None,
            workspace: Optional["scout_compute_api_StringConstant"] = None,
            procedure: Optional["scout_compute_api_StringConstant"] = None,
            procedure_execution: Optional["scout_compute_api_StringConstant"] = None,
            step_id: Optional["scout_compute_api_StringConstant"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (after is not None) + (before is not None) + (advanced_time_filter is not None) + (asset is not None) + (template is not None) + (workbook is not None) + (data_review is not None) + (origin_type is not None) + (data_review_check is not None) + (disposition_status is not None) + (priority is not None) + (assignee is not None) + (event_type is not None) + (created_by is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) + (workspace is not None) + (procedure is not None) + (procedure_execution is not None) + (step_id is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if after is not None:
                self._after = after
                self._type = 'after'
            if before is not None:
                self._before = before
                self._type = 'before'
            if advanced_time_filter is not None:
                self._advanced_time_filter = advanced_time_filter
                self._type = 'advancedTimeFilter'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if template is not None:
                self._template = template
                self._type = 'template'
            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if data_review is not None:
                self._data_review = data_review
                self._type = 'dataReview'
            if origin_type is not None:
                self._origin_type = origin_type
                self._type = 'originType'
            if data_review_check is not None:
                self._data_review_check = data_review_check
                self._type = 'dataReviewCheck'
            if disposition_status is not None:
                self._disposition_status = disposition_status
                self._type = 'dispositionStatus'
            if priority is not None:
                self._priority = priority
                self._type = 'priority'
            if assignee is not None:
                self._assignee = assignee
                self._type = 'assignee'
            if event_type is not None:
                self._event_type = event_type
                self._type = 'eventType'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if procedure is not None:
                self._procedure = procedure
                self._type = 'procedure'
            if procedure_execution is not None:
                self._procedure_execution = procedure_execution
                self._type = 'procedureExecution'
            if step_id is not None:
                self._step_id = step_id
                self._type = 'stepId'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'after':
            if after is None:
                raise ValueError('a union value must not be None')
            self._after = after
            self._type = 'after'
        elif type_of_union == 'before':
            if before is None:
                raise ValueError('a union value must not be None')
            self._before = before
            self._type = 'before'
        elif type_of_union == 'advancedTimeFilter':
            if advanced_time_filter is None:
                raise ValueError('a union value must not be None')
            self._advanced_time_filter = advanced_time_filter
            self._type = 'advancedTimeFilter'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'template':
            if template is None:
                raise ValueError('a union value must not be None')
            self._template = template
            self._type = 'template'
        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'dataReview':
            if data_review is None:
                raise ValueError('a union value must not be None')
            self._data_review = data_review
            self._type = 'dataReview'
        elif type_of_union == 'originType':
            if origin_type is None:
                raise ValueError('a union value must not be None')
            self._origin_type = origin_type
            self._type = 'originType'
        elif type_of_union == 'dataReviewCheck':
            if data_review_check is None:
                raise ValueError('a union value must not be None')
            self._data_review_check = data_review_check
            self._type = 'dataReviewCheck'
        elif type_of_union == 'dispositionStatus':
            if disposition_status is None:
                raise ValueError('a union value must not be None')
            self._disposition_status = disposition_status
            self._type = 'dispositionStatus'
        elif type_of_union == 'priority':
            if priority is None:
                raise ValueError('a union value must not be None')
            self._priority = priority
            self._type = 'priority'
        elif type_of_union == 'assignee':
            if assignee is None:
                raise ValueError('a union value must not be None')
            self._assignee = assignee
            self._type = 'assignee'
        elif type_of_union == 'eventType':
            if event_type is None:
                raise ValueError('a union value must not be None')
            self._event_type = event_type
            self._type = 'eventType'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'procedure':
            if procedure is None:
                raise ValueError('a union value must not be None')
            self._procedure = procedure
            self._type = 'procedure'
        elif type_of_union == 'procedureExecution':
            if procedure_execution is None:
                raise ValueError('a union value must not be None')
            self._procedure_execution = procedure_execution
            self._type = 'procedureExecution'
        elif type_of_union == 'stepId':
            if step_id is None:
                raise ValueError('a union value must not be None')
            self._step_id = step_id
            self._type = 'stepId'

    @builtins.property
    def search_text(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._search_text

    @builtins.property
    def after(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Filters to events after this timestamp, exclusive.
This includes events that start before, but end after this time.
        """
        return self._after

    @builtins.property
    def before(self) -> Optional["scout_compute_api_TimestampConstant"]:
        """Filters to events before this timestamp, exclusive.
This includes events that start before, but end after this time.
        """
        return self._before

    @builtins.property
    def advanced_time_filter(self) -> Optional["scout_rids_api_EventTimeFilter"]:
        return self._advanced_time_filter

    @builtins.property
    def asset(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._asset

    @builtins.property
    def template(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._template

    @builtins.property
    def workbook(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._workbook

    @builtins.property
    def data_review(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._data_review

    @builtins.property
    def origin_type(self) -> Optional["scout_rids_api_SearchEventOriginType"]:
        return self._origin_type

    @builtins.property
    def data_review_check(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._data_review_check

    @builtins.property
    def disposition_status(self) -> Optional["scout_rids_api_EventDispositionStatus"]:
        return self._disposition_status

    @builtins.property
    def priority(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._priority

    @builtins.property
    def assignee(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._assignee

    @builtins.property
    def event_type(self) -> Optional["scout_rids_api_EventType"]:
        return self._event_type

    @builtins.property
    def created_by(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._created_by

    @builtins.property
    def label(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._label

    @builtins.property
    def property(self) -> Optional["scout_rids_api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_rids_api_ComputeEventQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_rids_api_ComputeEventQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_rids_api_ComputeEventQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._workspace

    @builtins.property
    def procedure(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._procedure

    @builtins.property
    def procedure_execution(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._procedure_execution

    @builtins.property
    def step_id(self) -> Optional["scout_compute_api_StringConstant"]:
        return self._step_id

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_rids_api_ComputeEventQueryVisitor):
            raise ValueError('{} is not an instance of scout_rids_api_ComputeEventQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'after' and self.after is not None:
            return visitor._after(self.after)
        if self._type == 'before' and self.before is not None:
            return visitor._before(self.before)
        if self._type == 'advancedTimeFilter' and self.advanced_time_filter is not None:
            return visitor._advanced_time_filter(self.advanced_time_filter)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'template' and self.template is not None:
            return visitor._template(self.template)
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'dataReview' and self.data_review is not None:
            return visitor._data_review(self.data_review)
        if self._type == 'originType' and self.origin_type is not None:
            return visitor._origin_type(self.origin_type)
        if self._type == 'dataReviewCheck' and self.data_review_check is not None:
            return visitor._data_review_check(self.data_review_check)
        if self._type == 'dispositionStatus' and self.disposition_status is not None:
            return visitor._disposition_status(self.disposition_status)
        if self._type == 'priority' and self.priority is not None:
            return visitor._priority(self.priority)
        if self._type == 'assignee' and self.assignee is not None:
            return visitor._assignee(self.assignee)
        if self._type == 'eventType' and self.event_type is not None:
            return visitor._event_type(self.event_type)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'procedure' and self.procedure is not None:
            return visitor._procedure(self.procedure)
        if self._type == 'procedureExecution' and self.procedure_execution is not None:
            return visitor._procedure_execution(self.procedure_execution)
        if self._type == 'stepId' and self.step_id is not None:
            return visitor._step_id(self.step_id)


scout_rids_api_ComputeEventQuery.__name__ = "ComputeEventQuery"
scout_rids_api_ComputeEventQuery.__qualname__ = "ComputeEventQuery"
scout_rids_api_ComputeEventQuery.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_ComputeEventQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _after(self, after: "scout_compute_api_TimestampConstant") -> Any:
        pass

    @abstractmethod
    def _before(self, before: "scout_compute_api_TimestampConstant") -> Any:
        pass

    @abstractmethod
    def _advanced_time_filter(self, advanced_time_filter: "scout_rids_api_EventTimeFilter") -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _template(self, template: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _workbook(self, workbook: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _data_review(self, data_review: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _origin_type(self, origin_type: "scout_rids_api_SearchEventOriginType") -> Any:
        pass

    @abstractmethod
    def _data_review_check(self, data_review_check: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _disposition_status(self, disposition_status: "scout_rids_api_EventDispositionStatus") -> Any:
        pass

    @abstractmethod
    def _priority(self, priority: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _assignee(self, assignee: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _event_type(self, event_type: "scout_rids_api_EventType") -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _label(self, label: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_rids_api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_rids_api_ComputeEventQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_rids_api_ComputeEventQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_rids_api_ComputeEventQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _procedure(self, procedure: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _procedure_execution(self, procedure_execution: "scout_compute_api_StringConstant") -> Any:
        pass

    @abstractmethod
    def _step_id(self, step_id: "scout_compute_api_StringConstant") -> Any:
        pass


scout_rids_api_ComputeEventQueryVisitor.__name__ = "ComputeEventQueryVisitor"
scout_rids_api_ComputeEventQueryVisitor.__qualname__ = "ComputeEventQueryVisitor"
scout_rids_api_ComputeEventQueryVisitor.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_EventDispositionStatus(ConjureEnumType):

    PENDING_REVIEW = 'PENDING_REVIEW'
    '''PENDING_REVIEW'''
    CLOSED_IGNORED = 'CLOSED_IGNORED'
    '''CLOSED_IGNORED'''
    CLOSED_REQUIRES_FURTHER_ACTION = 'CLOSED_REQUIRES_FURTHER_ACTION'
    '''CLOSED_REQUIRES_FURTHER_ACTION'''
    NO_DISPOSITION = 'NO_DISPOSITION'
    '''NO_DISPOSITION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_rids_api_EventDispositionStatus.__name__ = "EventDispositionStatus"
scout_rids_api_EventDispositionStatus.__qualname__ = "EventDispositionStatus"
scout_rids_api_EventDispositionStatus.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_EventTimeFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', scout_compute_api_TimestampConstant),
            'timestamp_condition': ConjureFieldDefinition('timestampCondition', scout_rids_api_EventTimeFilterCondition)
        }

    __slots__: List[str] = ['_timestamp', '_timestamp_condition']

    def __init__(self, timestamp: "scout_compute_api_TimestampConstant", timestamp_condition: "scout_rids_api_EventTimeFilterCondition") -> None:
        self._timestamp = timestamp
        self._timestamp_condition = timestamp_condition

    @builtins.property
    def timestamp(self) -> "scout_compute_api_TimestampConstant":
        return self._timestamp

    @builtins.property
    def timestamp_condition(self) -> "scout_rids_api_EventTimeFilterCondition":
        return self._timestamp_condition


scout_rids_api_EventTimeFilter.__name__ = "EventTimeFilter"
scout_rids_api_EventTimeFilter.__qualname__ = "EventTimeFilter"
scout_rids_api_EventTimeFilter.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_EventTimeFilterCondition(ConjureEnumType):

    START_TIME_BEFORE_INCLUSIVE = 'START_TIME_BEFORE_INCLUSIVE'
    '''START_TIME_BEFORE_INCLUSIVE'''
    START_TIME_BEFORE_EXCLUSIVE = 'START_TIME_BEFORE_EXCLUSIVE'
    '''START_TIME_BEFORE_EXCLUSIVE'''
    START_TIME_AFTER_INCLUSIVE = 'START_TIME_AFTER_INCLUSIVE'
    '''START_TIME_AFTER_INCLUSIVE'''
    START_TIME_AFTER_EXCLUSIVE = 'START_TIME_AFTER_EXCLUSIVE'
    '''START_TIME_AFTER_EXCLUSIVE'''
    END_TIME_BEFORE_INCLUSIVE = 'END_TIME_BEFORE_INCLUSIVE'
    '''END_TIME_BEFORE_INCLUSIVE'''
    END_TIME_BEFORE_EXCLUSIVE = 'END_TIME_BEFORE_EXCLUSIVE'
    '''END_TIME_BEFORE_EXCLUSIVE'''
    END_TIME_AFTER_INCLUSIVE = 'END_TIME_AFTER_INCLUSIVE'
    '''END_TIME_AFTER_INCLUSIVE'''
    END_TIME_AFTER_EXCLUSIVE = 'END_TIME_AFTER_EXCLUSIVE'
    '''END_TIME_AFTER_EXCLUSIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_rids_api_EventTimeFilterCondition.__name__ = "EventTimeFilterCondition"
scout_rids_api_EventTimeFilterCondition.__qualname__ = "EventTimeFilterCondition"
scout_rids_api_EventTimeFilterCondition.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_EventType(ConjureEnumType):

    INFO = 'INFO'
    '''INFO'''
    FLAG = 'FLAG'
    '''FLAG'''
    ERROR = 'ERROR'
    '''ERROR'''
    SUCCESS = 'SUCCESS'
    '''SUCCESS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_rids_api_EventType.__name__ = "EventType"
scout_rids_api_EventType.__qualname__ = "EventType"
scout_rids_api_EventType.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_LabelsFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'operator': ConjureFieldDefinition('operator', api_SetOperator),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_operator', '_labels']

    def __init__(self, labels: List[str], operator: "api_SetOperator") -> None:
        self._operator = operator
        self._labels = labels

    @builtins.property
    def operator(self) -> "api_SetOperator":
        return self._operator

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_rids_api_LabelsFilter.__name__ = "LabelsFilter"
scout_rids_api_LabelsFilter.__qualname__ = "LabelsFilter"
scout_rids_api_LabelsFilter.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_PendingReviewAlertState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_rids_api_PendingReviewAlertState.__name__ = "PendingReviewAlertState"
scout_rids_api_PendingReviewAlertState.__qualname__ = "PendingReviewAlertState"
scout_rids_api_PendingReviewAlertState.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_PropertiesFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_PropertyName),
            'values': ConjureFieldDefinition('values', List[api_PropertyValue])
        }

    __slots__: List[str] = ['_name', '_values']

    def __init__(self, name: str, values: List[str]) -> None:
        self._name = name
        self._values = values

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def values(self) -> List[str]:
        return self._values


scout_rids_api_PropertiesFilter.__name__ = "PropertiesFilter"
scout_rids_api_PropertiesFilter.__qualname__ = "PropertiesFilter"
scout_rids_api_PropertiesFilter.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_Property(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_compute_api_StringConstant),
            'value': ConjureFieldDefinition('value', scout_compute_api_StringConstant)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: "scout_compute_api_StringConstant", value: "scout_compute_api_StringConstant") -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> "scout_compute_api_StringConstant":
        return self._name

    @builtins.property
    def value(self) -> "scout_compute_api_StringConstant":
        return self._value


scout_rids_api_Property.__name__ = "Property"
scout_rids_api_Property.__qualname__ = "Property"
scout_rids_api_Property.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_SearchEventOriginType(ConjureEnumType):

    WORKBOOK = 'WORKBOOK'
    '''WORKBOOK'''
    TEMPLATE = 'TEMPLATE'
    '''TEMPLATE'''
    API = 'API'
    '''API'''
    DATA_REVIEW = 'DATA_REVIEW'
    '''DATA_REVIEW'''
    PROCEDURE = 'PROCEDURE'
    '''PROCEDURE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_rids_api_SearchEventOriginType.__name__ = "SearchEventOriginType"
scout_rids_api_SearchEventOriginType.__qualname__ = "SearchEventOriginType"
scout_rids_api_SearchEventOriginType.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_UserDuration(ConjureBeanType):
    """Represents a time duration with a unit for user-facing display
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', float),
            'unit': ConjureFieldDefinition('unit', api_TimeUnit)
        }

    __slots__: List[str] = ['_duration', '_unit']

    def __init__(self, duration: float, unit: "api_TimeUnit") -> None:
        self._duration = duration
        self._unit = unit

    @builtins.property
    def duration(self) -> float:
        return self._duration

    @builtins.property
    def unit(self) -> "api_TimeUnit":
        return self._unit


scout_rids_api_UserDuration.__name__ = "UserDuration"
scout_rids_api_UserDuration.__qualname__ = "UserDuration"
scout_rids_api_UserDuration.__module__ = "nominal_api.scout_rids_api"


class scout_rids_api_VersionedVizId(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_VizId),
            'version': ConjureFieldDefinition('version', scout_rids_api_Version)
        }

    __slots__: List[str] = ['_rid', '_version']

    def __init__(self, rid: str, version: int) -> None:
        self._rid = rid
        self._version = version

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def version(self) -> int:
        return self._version


scout_rids_api_VersionedVizId.__name__ = "VersionedVizId"
scout_rids_api_VersionedVizId.__qualname__ = "VersionedVizId"
scout_rids_api_VersionedVizId.__module__ = "nominal_api.scout_rids_api"


class scout_run_api_AllRunsPropertiesAndLabelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_run_api_AllRunsPropertiesAndLabelsResponse.__name__ = "AllRunsPropertiesAndLabelsResponse"
scout_run_api_AllRunsPropertiesAndLabelsResponse.__qualname__ = "AllRunsPropertiesAndLabelsResponse"
scout_run_api_AllRunsPropertiesAndLabelsResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_ArchiveRunsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_run_api_RunRid]),
            'include_linked_workbooks': ConjureFieldDefinition('includeLinkedWorkbooks', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_rids', '_include_linked_workbooks']

    def __init__(self, rids: List[str], include_linked_workbooks: Optional[bool] = None) -> None:
        self._rids = rids
        self._include_linked_workbooks = include_linked_workbooks

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids

    @builtins.property
    def include_linked_workbooks(self) -> Optional[bool]:
        """If true, all auto-archived workbooks that are linked to run will be unarchived as well.
Defaults to false.
        """
        return self._include_linked_workbooks


scout_run_api_ArchiveRunsRequest.__name__ = "ArchiveRunsRequest"
scout_run_api_ArchiveRunsRequest.__qualname__ = "ArchiveRunsRequest"
scout_run_api_ArchiveRunsRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_AssetsFilter(ConjureBeanType):
    """returns runs that match any of the provided assets.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid])
        }

    __slots__: List[str] = ['_assets']

    def __init__(self, assets: List[str]) -> None:
        self._assets = assets

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets


scout_run_api_AssetsFilter.__name__ = "AssetsFilter"
scout_run_api_AssetsFilter.__qualname__ = "AssetsFilter"
scout_run_api_AssetsFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_Channel),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[scout_run_api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[api_SeriesDataType])
        }

    __slots__: List[str] = ['_name', '_data_source', '_unit', '_description', '_data_type']

    def __init__(self, data_source: "scout_run_api_DataSource", name: str, data_type: Optional["api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional["scout_run_api_Unit"] = None) -> None:
        self._name = name
        self._data_source = data_source
        self._unit = unit
        self._description = description
        self._data_type = data_type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def unit(self) -> Optional["scout_run_api_Unit"]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_type(self) -> Optional["api_SeriesDataType"]:
        return self._data_type


scout_run_api_ChannelMetadata.__name__ = "ChannelMetadata"
scout_run_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
scout_run_api_ChannelMetadata.__module__ = "nominal_api.scout_run_api"


class scout_run_api_CheckAlertStatesFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_state': ConjureFieldDefinition('checkAlertState', scout_rids_api_CheckAlertState),
            'operator': ConjureFieldDefinition('operator', scout_internal_search_api_Operator),
            'threshold': ConjureFieldDefinition('threshold', int)
        }

    __slots__: List[str] = ['_check_alert_state', '_operator', '_threshold']

    def __init__(self, check_alert_state: "scout_rids_api_CheckAlertState", operator: "scout_internal_search_api_Operator", threshold: int) -> None:
        self._check_alert_state = check_alert_state
        self._operator = operator
        self._threshold = threshold

    @builtins.property
    def check_alert_state(self) -> "scout_rids_api_CheckAlertState":
        return self._check_alert_state

    @builtins.property
    def operator(self) -> "scout_internal_search_api_Operator":
        return self._operator

    @builtins.property
    def threshold(self) -> int:
        return self._threshold


scout_run_api_CheckAlertStatesFilter.__name__ = "CheckAlertStatesFilter"
scout_run_api_CheckAlertStatesFilter.__qualname__ = "CheckAlertStatesFilter"
scout_run_api_CheckAlertStatesFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_CreateOrUpdateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_rid': ConjureFieldDefinition('runRid', OptionalTypeWrapper[scout_run_api_RunRid]),
            'create_run_request': ConjureFieldDefinition('createRunRequest', scout_run_api_CreateRunRequest)
        }

    __slots__: List[str] = ['_run_rid', '_create_run_request']

    def __init__(self, create_run_request: "scout_run_api_CreateRunRequest", run_rid: Optional[str] = None) -> None:
        self._run_rid = run_rid
        self._create_run_request = create_run_request

    @builtins.property
    def run_rid(self) -> Optional[str]:
        """If a run with the same rid already exists, it will be updated.
Otherwise, a new run will be created.
        """
        return self._run_rid

    @builtins.property
    def create_run_request(self) -> "scout_run_api_CreateRunRequest":
        return self._create_run_request


scout_run_api_CreateOrUpdateRunRequest.__name__ = "CreateOrUpdateRunRequest"
scout_run_api_CreateOrUpdateRunRequest.__qualname__ = "CreateOrUpdateRunRequest"
scout_run_api_CreateOrUpdateRunRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_CreateRunDataSource(ConjureBeanType):
    """For write requests, we want to allow for optional fields
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', OptionalTypeWrapper[scout_run_api_DataSource]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', OptionalTypeWrapper[api_rids_DataSourceRid]),
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_run_api_Duration]),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source', '_data_source_rid', '_offset', '_series_tags']

    def __init__(self, series_tags: Dict[str, str], data_source: Optional["scout_run_api_DataSource"] = None, data_source_rid: Optional[str] = None, offset: Optional["scout_run_api_Duration"] = None) -> None:
        self._data_source = data_source
        self._data_source_rid = data_source_rid
        self._offset = offset
        self._series_tags = series_tags

    @builtins.property
    def data_source(self) -> Optional["scout_run_api_DataSource"]:
        """One of dataSource and dataSourceRid must be present.
dataSourceRid takes precedence.
        """
        return self._data_source

    @builtins.property
    def data_source_rid(self) -> Optional[str]:
        """One of dataSource and dataSourceRid must be present.
dataSourceRid takes precedence.
        """
        return self._data_source_rid

    @builtins.property
    def offset(self) -> Optional["scout_run_api_Duration"]:
        return self._offset

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """Used to resolve logical series for this data source.
        """
        return self._series_tags


scout_run_api_CreateRunDataSource.__name__ = "CreateRunDataSource"
scout_run_api_CreateRunDataSource.__qualname__ = "CreateRunDataSource"
scout_run_api_CreateRunDataSource.__module__ = "nominal_api.scout_run_api"


class scout_run_api_CreateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[scout_api_DataSourceRefName, scout_run_api_CreateRunDataSource]),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid]),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_links', '_run_prefix', '_data_sources', '_attachments', '_asset', '_assets', '_workspace']

    def __init__(self, assets: List[str], attachments: List[str], data_sources: Dict[str, "scout_run_api_CreateRunDataSource"], description: str, labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], start_time: "scout_run_api_UtcTimestamp", title: str, asset: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, run_prefix: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._run_prefix = run_prefix
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset
        self._assets = assets
        self._workspace = workspace

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def start_time(self) -> "scout_run_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Dict[str, "scout_run_api_CreateRunDataSource"]:
        return self._data_sources

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the run. If not provided, the run will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
All data sources, attachments, and assets must be in the same workspace.
        """
        return self._workspace


scout_run_api_CreateRunRequest.__name__ = "CreateRunRequest"
scout_run_api_CreateRunRequest.__qualname__ = "CreateRunRequest"
scout_run_api_CreateRunRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_CustomTimeframeFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp])
        }

    __slots__: List[str] = ['_start_time', '_end_time']

    def __init__(self, end_time: Optional["scout_run_api_UtcTimestamp"] = None, start_time: Optional["scout_run_api_UtcTimestamp"] = None) -> None:
        self._start_time = start_time
        self._end_time = end_time

    @builtins.property
    def start_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time


scout_run_api_CustomTimeframeFilter.__name__ = "CustomTimeframeFilter"
scout_run_api_CustomTimeframeFilter.__qualname__ = "CustomTimeframeFilter"
scout_run_api_CustomTimeframeFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataReviewAlertMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_review': ConjureFieldDefinition('pendingReview', int),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', int),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', int)
        }

    __slots__: List[str] = ['_pending_review', '_closed_with_ignore', '_closed_with_further_action']

    def __init__(self, closed_with_further_action: int, closed_with_ignore: int, pending_review: int) -> None:
        self._pending_review = pending_review
        self._closed_with_ignore = closed_with_ignore
        self._closed_with_further_action = closed_with_further_action

    @builtins.property
    def pending_review(self) -> int:
        return self._pending_review

    @builtins.property
    def closed_with_ignore(self) -> int:
        return self._closed_with_ignore

    @builtins.property
    def closed_with_further_action(self) -> int:
        return self._closed_with_further_action


scout_run_api_DataReviewAlertMetrics.__name__ = "DataReviewAlertMetrics"
scout_run_api_DataReviewAlertMetrics.__qualname__ = "DataReviewAlertMetrics"
scout_run_api_DataReviewAlertMetrics.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataReviewCheckMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'pending_execution': ConjureFieldDefinition('pendingExecution', int),
            'executing': ConjureFieldDefinition('executing', int),
            'passing_automatic': ConjureFieldDefinition('passingAutomatic', int),
            'pending_review': ConjureFieldDefinition('pendingReview', int),
            'closed_with_ignore': ConjureFieldDefinition('closedWithIgnore', int),
            'closed_with_further_action': ConjureFieldDefinition('closedWithFurtherAction', int),
            'failed_to_execute_pending_review': ConjureFieldDefinition('failedToExecutePendingReview', int),
            'failed_to_execute_closed_with_ignore': ConjureFieldDefinition('failedToExecuteClosedWithIgnore', int),
            'failed_to_execute_closed_with_further_action': ConjureFieldDefinition('failedToExecuteClosedWithFurtherAction', int)
        }

    __slots__: List[str] = ['_pending_execution', '_executing', '_passing_automatic', '_pending_review', '_closed_with_ignore', '_closed_with_further_action', '_failed_to_execute_pending_review', '_failed_to_execute_closed_with_ignore', '_failed_to_execute_closed_with_further_action']

    def __init__(self, closed_with_further_action: int, closed_with_ignore: int, executing: int, failed_to_execute_closed_with_further_action: int, failed_to_execute_closed_with_ignore: int, failed_to_execute_pending_review: int, passing_automatic: int, pending_execution: int, pending_review: int) -> None:
        self._pending_execution = pending_execution
        self._executing = executing
        self._passing_automatic = passing_automatic
        self._pending_review = pending_review
        self._closed_with_ignore = closed_with_ignore
        self._closed_with_further_action = closed_with_further_action
        self._failed_to_execute_pending_review = failed_to_execute_pending_review
        self._failed_to_execute_closed_with_ignore = failed_to_execute_closed_with_ignore
        self._failed_to_execute_closed_with_further_action = failed_to_execute_closed_with_further_action

    @builtins.property
    def pending_execution(self) -> int:
        return self._pending_execution

    @builtins.property
    def executing(self) -> int:
        return self._executing

    @builtins.property
    def passing_automatic(self) -> int:
        return self._passing_automatic

    @builtins.property
    def pending_review(self) -> int:
        return self._pending_review

    @builtins.property
    def closed_with_ignore(self) -> int:
        return self._closed_with_ignore

    @builtins.property
    def closed_with_further_action(self) -> int:
        return self._closed_with_further_action

    @builtins.property
    def failed_to_execute_pending_review(self) -> int:
        return self._failed_to_execute_pending_review

    @builtins.property
    def failed_to_execute_closed_with_ignore(self) -> int:
        return self._failed_to_execute_closed_with_ignore

    @builtins.property
    def failed_to_execute_closed_with_further_action(self) -> int:
        return self._failed_to_execute_closed_with_further_action


scout_run_api_DataReviewCheckMetrics.__name__ = "DataReviewCheckMetrics"
scout_run_api_DataReviewCheckMetrics.__qualname__ = "DataReviewCheckMetrics"
scout_run_api_DataReviewCheckMetrics.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataReviewMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'checks': ConjureFieldDefinition('checks', scout_run_api_DataReviewCheckMetrics),
            'alerts': ConjureFieldDefinition('alerts', scout_run_api_DataReviewAlertMetrics)
        }

    __slots__: List[str] = ['_checks', '_alerts']

    def __init__(self, alerts: "scout_run_api_DataReviewAlertMetrics", checks: "scout_run_api_DataReviewCheckMetrics") -> None:
        self._checks = checks
        self._alerts = alerts

    @builtins.property
    def checks(self) -> "scout_run_api_DataReviewCheckMetrics":
        return self._checks

    @builtins.property
    def alerts(self) -> "scout_run_api_DataReviewAlertMetrics":
        return self._alerts


scout_run_api_DataReviewMetrics.__name__ = "DataReviewMetrics"
scout_run_api_DataReviewMetrics.__qualname__ = "DataReviewMetrics"
scout_run_api_DataReviewMetrics.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataScopes(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_scopes': ConjureFieldDefinition('dataScopes', Dict[scout_api_DataSourceRefName, scout_asset_api_DataScope])
        }

    __slots__: List[str] = ['_data_scopes']

    def __init__(self, data_scopes: Dict[str, "scout_asset_api_DataScope"]) -> None:
        self._data_scopes = data_scopes

    @builtins.property
    def data_scopes(self) -> Dict[str, "scout_asset_api_DataScope"]:
        return self._data_scopes


scout_run_api_DataScopes.__name__ = "DataScopes"
scout_run_api_DataScopes.__qualname__ = "DataScopes"
scout_run_api_DataScopes.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataSource(ConjureUnionType):
    _dataset: Optional[str] = None
    _connection: Optional[str] = None
    _log_set: Optional[str] = None
    _video: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset': ConjureFieldDefinition('dataset', api_rids_DatasetRid),
            'connection': ConjureFieldDefinition('connection', scout_run_api_ConnectionRid),
            'log_set': ConjureFieldDefinition('logSet', scout_run_api_LogSetRid),
            'video': ConjureFieldDefinition('video', api_rids_VideoRid)
        }

    def __init__(
            self,
            dataset: Optional[str] = None,
            connection: Optional[str] = None,
            log_set: Optional[str] = None,
            video: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (dataset is not None) + (connection is not None) + (log_set is not None) + (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if dataset is not None:
                self._dataset = dataset
                self._type = 'dataset'
            if connection is not None:
                self._connection = connection
                self._type = 'connection'
            if log_set is not None:
                self._log_set = log_set
                self._type = 'logSet'
            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'dataset':
            if dataset is None:
                raise ValueError('a union value must not be None')
            self._dataset = dataset
            self._type = 'dataset'
        elif type_of_union == 'connection':
            if connection is None:
                raise ValueError('a union value must not be None')
            self._connection = connection
            self._type = 'connection'
        elif type_of_union == 'logSet':
            if log_set is None:
                raise ValueError('a union value must not be None')
            self._log_set = log_set
            self._type = 'logSet'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def dataset(self) -> Optional[str]:
        return self._dataset

    @builtins.property
    def connection(self) -> Optional[str]:
        return self._connection

    @builtins.property
    def log_set(self) -> Optional[str]:
        return self._log_set

    @builtins.property
    def video(self) -> Optional[str]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_DataSourceVisitor):
            raise ValueError('{} is not an instance of scout_run_api_DataSourceVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataset' and self.dataset is not None:
            return visitor._dataset(self.dataset)
        if self._type == 'connection' and self.connection is not None:
            return visitor._connection(self.connection)
        if self._type == 'logSet' and self.log_set is not None:
            return visitor._log_set(self.log_set)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


scout_run_api_DataSource.__name__ = "DataSource"
scout_run_api_DataSource.__qualname__ = "DataSource"
scout_run_api_DataSource.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataSourceVisitor:

    @abstractmethod
    def _dataset(self, dataset: str) -> Any:
        pass

    @abstractmethod
    def _connection(self, connection: str) -> Any:
        pass

    @abstractmethod
    def _log_set(self, log_set: str) -> Any:
        pass

    @abstractmethod
    def _video(self, video: str) -> Any:
        pass


scout_run_api_DataSourceVisitor.__name__ = "DataSourceVisitor"
scout_run_api_DataSourceVisitor.__qualname__ = "DataSourceVisitor"
scout_run_api_DataSourceVisitor.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataSourceSeriesTag(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_TagName),
            'value': ConjureFieldDefinition('value', api_TagValue)
        }

    __slots__: List[str] = ['_name', '_value']

    def __init__(self, name: str, value: str) -> None:
        self._name = name
        self._value = value

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def value(self) -> str:
        return self._value


scout_run_api_DataSourceSeriesTag.__name__ = "DataSourceSeriesTag"
scout_run_api_DataSourceSeriesTag.__qualname__ = "DataSourceSeriesTag"
scout_run_api_DataSourceSeriesTag.__module__ = "nominal_api.scout_run_api"


class scout_run_api_DataSourceType(ConjureEnumType):

    DATASET = 'DATASET'
    '''DATASET'''
    CONNECTION = 'CONNECTION'
    '''CONNECTION'''
    LOGSET = 'LOGSET'
    '''LOGSET'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_DataSourceType.__name__ = "DataSourceType"
scout_run_api_DataSourceType.__qualname__ = "DataSourceType"
scout_run_api_DataSourceType.__module__ = "nominal_api.scout_run_api"


class scout_run_api_Duration(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds': ConjureFieldDefinition('seconds', int),
            'nanos': ConjureFieldDefinition('nanos', int),
            'picos': ConjureFieldDefinition('picos', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds', '_nanos', '_picos']

    def __init__(self, nanos: int, seconds: int, picos: Optional[int] = None) -> None:
        self._seconds = seconds
        self._nanos = nanos
        self._picos = picos

    @builtins.property
    def seconds(self) -> int:
        return self._seconds

    @builtins.property
    def nanos(self) -> int:
        return self._nanos

    @builtins.property
    def picos(self) -> Optional[int]:
        return self._picos


scout_run_api_Duration.__name__ = "Duration"
scout_run_api_Duration.__qualname__ = "Duration"
scout_run_api_Duration.__module__ = "nominal_api.scout_run_api"


class scout_run_api_GetRunByIdRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run_number': ConjureFieldDefinition('runNumber', int),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_run_number', '_run_prefix', '_workspace']

    def __init__(self, run_number: int, run_prefix: Optional[str] = None, workspace: Optional[str] = None) -> None:
        self._run_number = run_number
        self._run_prefix = run_prefix
        self._workspace = workspace

    @builtins.property
    def run_number(self) -> int:
        return self._run_number

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to query for the run. If not provided, the run
will be queried in the default workspace for the user's organization,
if the default workspace for the organization is configured and the user
has access to it.
        """
        return self._workspace


scout_run_api_GetRunByIdRequest.__name__ = "GetRunByIdRequest"
scout_run_api_GetRunByIdRequest.__qualname__ = "GetRunByIdRequest"
scout_run_api_GetRunByIdRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_GetRunsByAssetRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_asset', '_next_page_token']

    def __init__(self, asset: str, next_page_token: Optional[str] = None) -> None:
        self._asset = asset
        self._next_page_token = next_page_token

    @builtins.property
    def asset(self) -> str:
        return self._asset

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_GetRunsByAssetRequest.__name__ = "GetRunsByAssetRequest"
scout_run_api_GetRunsByAssetRequest.__qualname__ = "GetRunsByAssetRequest"
scout_run_api_GetRunsByAssetRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_GetRunsByAssetResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_Run]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_Run"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_Run"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_GetRunsByAssetResponse.__name__ = "GetRunsByAssetResponse"
scout_run_api_GetRunsByAssetResponse.__qualname__ = "GetRunsByAssetResponse"
scout_run_api_GetRunsByAssetResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_Link(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'url': ConjureFieldDefinition('url', str)
        }

    __slots__: List[str] = ['_title', '_url']

    def __init__(self, url: str, title: Optional[str] = None) -> None:
        self._title = title
        self._url = url

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def url(self) -> str:
        return self._url


scout_run_api_Link.__name__ = "Link"
scout_run_api_Link.__qualname__ = "Link"
scout_run_api_Link.__module__ = "nominal_api.scout_run_api"


class scout_run_api_PresetTimeframeDuration(ConjureEnumType):

    ALL_TIME = 'ALL_TIME'
    '''ALL_TIME'''
    LAST_DAY = 'LAST_DAY'
    '''LAST_DAY'''
    LAST_WEEK = 'LAST_WEEK'
    '''LAST_WEEK'''
    LAST_MONTH = 'LAST_MONTH'
    '''LAST_MONTH'''
    LAST_YEAR = 'LAST_YEAR'
    '''LAST_YEAR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_PresetTimeframeDuration.__name__ = "PresetTimeframeDuration"
scout_run_api_PresetTimeframeDuration.__qualname__ = "PresetTimeframeDuration"
scout_run_api_PresetTimeframeDuration.__module__ = "nominal_api.scout_run_api"


class scout_run_api_PresetTimeframeFilter(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'duration': ConjureFieldDefinition('duration', scout_run_api_PresetTimeframeDuration)
        }

    __slots__: List[str] = ['_duration']

    def __init__(self, duration: "scout_run_api_PresetTimeframeDuration") -> None:
        self._duration = duration

    @builtins.property
    def duration(self) -> "scout_run_api_PresetTimeframeDuration":
        return self._duration


scout_run_api_PresetTimeframeFilter.__name__ = "PresetTimeframeFilter"
scout_run_api_PresetTimeframeFilter.__qualname__ = "PresetTimeframeFilter"
scout_run_api_PresetTimeframeFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RefNameAndType(ConjureBeanType):
    """Scoped to the org-level, intended to help the frontend
prevent users from submitting invalid ref names, ex.
using a `dataset` ref name for a `connection` data source
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', scout_api_DataSourceRefName),
            'type': ConjureFieldDefinition('type', scout_run_api_DataSourceType)
        }

    __slots__: List[str] = ['_name', '_type']

    def __init__(self, name: str, type: "scout_run_api_DataSourceType") -> None:
        self._name = name
        self._type = type

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def type(self) -> "scout_run_api_DataSourceType":
        return self._type


scout_run_api_RefNameAndType.__name__ = "RefNameAndType"
scout_run_api_RefNameAndType.__qualname__ = "RefNameAndType"
scout_run_api_RefNameAndType.__module__ = "nominal_api.scout_run_api"


class scout_run_api_Run(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_run_api_RunRid),
            'run_number': ConjureFieldDefinition('runNumber', int),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'author_rid': ConjureFieldDefinition('authorRid', OptionalTypeWrapper[scout_rids_api_UserRid]),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'links': ConjureFieldDefinition('links', List[scout_run_api_Link]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'asset_data_scopes_map': ConjureFieldDefinition('assetDataScopesMap', Dict[scout_rids_api_AssetRid, scout_run_api_DataScopes]),
            'asset_data_scopes': ConjureFieldDefinition('assetDataScopes', List[scout_asset_api_DataScope]),
            'data_sources': ConjureFieldDefinition('dataSources', Dict[scout_api_DataSourceRefName, scout_run_api_RunDataSource]),
            'attachments': ConjureFieldDefinition('attachments', List[api_rids_AttachmentRid]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid]),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid]),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_run_number', '_run_prefix', '_title', '_description', '_author_rid', '_start_time', '_end_time', '_properties', '_labels', '_links', '_created_at', '_updated_at', '_asset_data_scopes_map', '_asset_data_scopes', '_data_sources', '_attachments', '_asset', '_assets', '_is_archived']

    def __init__(self, asset_data_scopes: List["scout_asset_api_DataScope"], asset_data_scopes_map: Dict[str, "scout_run_api_DataScopes"], assets: List[str], attachments: List[str], created_at: str, data_sources: Dict[str, "scout_run_api_RunDataSource"], description: str, is_archived: bool, labels: List[str], links: List["scout_run_api_Link"], properties: Dict[str, str], rid: str, run_number: int, start_time: "scout_run_api_UtcTimestamp", title: str, updated_at: str, asset: Optional[str] = None, author_rid: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, run_prefix: Optional[str] = None) -> None:
        self._rid = rid
        self._run_number = run_number
        self._run_prefix = run_prefix
        self._title = title
        self._description = description
        self._author_rid = author_rid
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._created_at = created_at
        self._updated_at = updated_at
        self._asset_data_scopes_map = asset_data_scopes_map
        self._asset_data_scopes = asset_data_scopes
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset
        self._assets = assets
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def run_number(self) -> int:
        return self._run_number

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def author_rid(self) -> Optional[str]:
        return self._author_rid

    @builtins.property
    def start_time(self) -> "scout_run_api_UtcTimestamp":
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def links(self) -> List["scout_run_api_Link"]:
        return self._links

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def asset_data_scopes_map(self) -> Dict[str, "scout_run_api_DataScopes"]:
        """Map from asset RIDs to their data scopes
        """
        return self._asset_data_scopes_map

    @builtins.property
    def asset_data_scopes(self) -> List["scout_asset_api_DataScope"]:
        return self._asset_data_scopes

    @builtins.property
    def data_sources(self) -> Dict[str, "scout_run_api_RunDataSource"]:
        """Map from refnames to run data sources. Will be empty for multi-asset runs.
        """
        return self._data_sources

    @builtins.property
    def attachments(self) -> List[str]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


scout_run_api_Run.__name__ = "Run"
scout_run_api_Run.__qualname__ = "Run"
scout_run_api_Run.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RunDataReviewEvaluationStatus(ConjureEnumType):

    NO_CHECKS_APPLIED = 'NO_CHECKS_APPLIED'
    '''NO_CHECKS_APPLIED'''
    FAILED_TO_EXECUTE = 'FAILED_TO_EXECUTE'
    '''FAILED_TO_EXECUTE'''
    EXECUTING = 'EXECUTING'
    '''EXECUTING'''
    PENDING_EXECUTION = 'PENDING_EXECUTION'
    '''PENDING_EXECUTION'''
    CLOSED_WITH_FURTHER_ACTION = 'CLOSED_WITH_FURTHER_ACTION'
    '''CLOSED_WITH_FURTHER_ACTION'''
    GENERATED_ALERTS = 'GENERATED_ALERTS'
    '''GENERATED_ALERTS'''
    CLOSED_WITH_IGNORE = 'CLOSED_WITH_IGNORE'
    '''CLOSED_WITH_IGNORE'''
    PASSING = 'PASSING'
    '''PASSING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_RunDataReviewEvaluationStatus.__name__ = "RunDataReviewEvaluationStatus"
scout_run_api_RunDataReviewEvaluationStatus.__qualname__ = "RunDataReviewEvaluationStatus"
scout_run_api_RunDataReviewEvaluationStatus.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RunDataReviewSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'evaluation_status': ConjureFieldDefinition('evaluationStatus', scout_run_api_RunDataReviewEvaluationStatus),
            'total_issue_count': ConjureFieldDefinition('totalIssueCount', int),
            'reviewed_issue_count': ConjureFieldDefinition('reviewedIssueCount', int),
            'issues_with_further_action_count': ConjureFieldDefinition('issuesWithFurtherActionCount', int),
            'execution_error_count': ConjureFieldDefinition('executionErrorCount', int)
        }

    __slots__: List[str] = ['_evaluation_status', '_total_issue_count', '_reviewed_issue_count', '_issues_with_further_action_count', '_execution_error_count']

    def __init__(self, evaluation_status: "scout_run_api_RunDataReviewEvaluationStatus", execution_error_count: int, issues_with_further_action_count: int, reviewed_issue_count: int, total_issue_count: int) -> None:
        self._evaluation_status = evaluation_status
        self._total_issue_count = total_issue_count
        self._reviewed_issue_count = reviewed_issue_count
        self._issues_with_further_action_count = issues_with_further_action_count
        self._execution_error_count = execution_error_count

    @builtins.property
    def evaluation_status(self) -> "scout_run_api_RunDataReviewEvaluationStatus":
        return self._evaluation_status

    @builtins.property
    def total_issue_count(self) -> int:
        return self._total_issue_count

    @builtins.property
    def reviewed_issue_count(self) -> int:
        return self._reviewed_issue_count

    @builtins.property
    def issues_with_further_action_count(self) -> int:
        return self._issues_with_further_action_count

    @builtins.property
    def execution_error_count(self) -> int:
        return self._execution_error_count


scout_run_api_RunDataReviewSummary.__name__ = "RunDataReviewSummary"
scout_run_api_RunDataReviewSummary.__qualname__ = "RunDataReviewSummary"
scout_run_api_RunDataReviewSummary.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RunDataSource(ConjureBeanType):
    """For read requests, we want to require all fields
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'offset': ConjureFieldDefinition('offset', scout_run_api_Duration),
            'ref_name': ConjureFieldDefinition('refName', scout_api_DataSourceRefName),
            'timestamp_type': ConjureFieldDefinition('timestampType', scout_run_api_WeakTimestampType),
            'series_tags': ConjureFieldDefinition('seriesTags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source', '_offset', '_ref_name', '_timestamp_type', '_series_tags']

    def __init__(self, data_source: "scout_run_api_DataSource", offset: "scout_run_api_Duration", ref_name: str, series_tags: Dict[str, str], timestamp_type: "scout_run_api_WeakTimestampType") -> None:
        self._data_source = data_source
        self._offset = offset
        self._ref_name = ref_name
        self._timestamp_type = timestamp_type
        self._series_tags = series_tags

    @builtins.property
    def data_source(self) -> "scout_run_api_DataSource":
        return self._data_source

    @builtins.property
    def offset(self) -> "scout_run_api_Duration":
        """This offset is used for small time-sync corrections. Notably, it is
not the offset to move a relative data source to the start of the run.
        """
        return self._offset

    @builtins.property
    def ref_name(self) -> str:
        """Included for convenience, duplicated from the key of the map
        """
        return self._ref_name

    @builtins.property
    def timestamp_type(self) -> "scout_run_api_WeakTimestampType":
        return self._timestamp_type

    @builtins.property
    def series_tags(self) -> Dict[str, str]:
        """Used to resolve logical series for this data source.
        """
        return self._series_tags


scout_run_api_RunDataSource.__name__ = "RunDataSource"
scout_run_api_RunDataSource.__qualname__ = "RunDataSource"
scout_run_api_RunDataSource.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RunWithDataReviewMetrics(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_run_api_Run),
            'data_review_metrics': ConjureFieldDefinition('dataReviewMetrics', scout_run_api_DataReviewMetrics)
        }

    __slots__: List[str] = ['_run', '_data_review_metrics']

    def __init__(self, data_review_metrics: "scout_run_api_DataReviewMetrics", run: "scout_run_api_Run") -> None:
        self._run = run
        self._data_review_metrics = data_review_metrics

    @builtins.property
    def run(self) -> "scout_run_api_Run":
        return self._run

    @builtins.property
    def data_review_metrics(self) -> "scout_run_api_DataReviewMetrics":
        return self._data_review_metrics


scout_run_api_RunWithDataReviewMetrics.__name__ = "RunWithDataReviewMetrics"
scout_run_api_RunWithDataReviewMetrics.__qualname__ = "RunWithDataReviewMetrics"
scout_run_api_RunWithDataReviewMetrics.__module__ = "nominal_api.scout_run_api"


class scout_run_api_RunWithDataReviewSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'run': ConjureFieldDefinition('run', scout_run_api_Run),
            'data_review_summary': ConjureFieldDefinition('dataReviewSummary', scout_run_api_RunDataReviewSummary)
        }

    __slots__: List[str] = ['_run', '_data_review_summary']

    def __init__(self, data_review_summary: "scout_run_api_RunDataReviewSummary", run: "scout_run_api_Run") -> None:
        self._run = run
        self._data_review_summary = data_review_summary

    @builtins.property
    def run(self) -> "scout_run_api_Run":
        return self._run

    @builtins.property
    def data_review_summary(self) -> "scout_run_api_RunDataReviewSummary":
        return self._data_review_summary


scout_run_api_RunWithDataReviewSummary.__name__ = "RunWithDataReviewSummary"
scout_run_api_RunWithDataReviewSummary.__qualname__ = "RunWithDataReviewSummary"
scout_run_api_RunWithDataReviewSummary.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchQuery(ConjureUnionType):
    _start_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None
    _start_time: Optional["scout_run_api_TimeframeFilter"] = None
    _end_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None
    _end_time: Optional["scout_run_api_TimeframeFilter"] = None
    _time_range: Optional["scout_run_api_TimeRangeFilter"] = None
    _created_at: Optional["scout_run_api_TimeframeFilter"] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _asset: Optional[str] = None
    _assets: Optional["scout_run_api_AssetsFilter"] = None
    _is_single_asset: Optional[bool] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _data_source_series_tag: Optional["scout_run_api_DataSourceSeriesTag"] = None
    _data_source_ref_name: Optional[str] = None
    _data_source: Optional["scout_run_api_DataSource"] = None
    _run_number: Optional[int] = None
    _run_prefix: Optional[str] = None
    _check_alert_states_filter: Optional["scout_run_api_CheckAlertStatesFilter"] = None
    _archived: Optional[bool] = None
    _and_: Optional[List["scout_run_api_SearchQuery"]] = None
    _or_: Optional[List["scout_run_api_SearchQuery"]] = None
    _not_: Optional["scout_run_api_SearchQuery"] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_time_inclusive': ConjureFieldDefinition('startTimeInclusive', scout_run_api_UtcTimestamp),
            'start_time': ConjureFieldDefinition('startTime', scout_run_api_TimeframeFilter),
            'end_time_inclusive': ConjureFieldDefinition('endTimeInclusive', scout_run_api_UtcTimestamp),
            'end_time': ConjureFieldDefinition('endTime', scout_run_api_TimeframeFilter),
            'time_range': ConjureFieldDefinition('timeRange', scout_run_api_TimeRangeFilter),
            'created_at': ConjureFieldDefinition('createdAt', scout_run_api_TimeframeFilter),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'asset': ConjureFieldDefinition('asset', scout_rids_api_AssetRid),
            'assets': ConjureFieldDefinition('assets', scout_run_api_AssetsFilter),
            'is_single_asset': ConjureFieldDefinition('isSingleAsset', bool),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'data_source_series_tag': ConjureFieldDefinition('dataSourceSeriesTag', scout_run_api_DataSourceSeriesTag),
            'data_source_ref_name': ConjureFieldDefinition('dataSourceRefName', scout_api_DataSourceRefName),
            'data_source': ConjureFieldDefinition('dataSource', scout_run_api_DataSource),
            'run_number': ConjureFieldDefinition('runNumber', int),
            'run_prefix': ConjureFieldDefinition('runPrefix', str),
            'check_alert_states_filter': ConjureFieldDefinition('checkAlertStatesFilter', scout_run_api_CheckAlertStatesFilter),
            'archived': ConjureFieldDefinition('archived', bool),
            'and_': ConjureFieldDefinition('and', List[scout_run_api_SearchQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_run_api_SearchQuery]),
            'not_': ConjureFieldDefinition('not', scout_run_api_SearchQuery),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            start_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None,
            start_time: Optional["scout_run_api_TimeframeFilter"] = None,
            end_time_inclusive: Optional["scout_run_api_UtcTimestamp"] = None,
            end_time: Optional["scout_run_api_TimeframeFilter"] = None,
            time_range: Optional["scout_run_api_TimeRangeFilter"] = None,
            created_at: Optional["scout_run_api_TimeframeFilter"] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            asset: Optional[str] = None,
            assets: Optional["scout_run_api_AssetsFilter"] = None,
            is_single_asset: Optional[bool] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            data_source_series_tag: Optional["scout_run_api_DataSourceSeriesTag"] = None,
            data_source_ref_name: Optional[str] = None,
            data_source: Optional["scout_run_api_DataSource"] = None,
            run_number: Optional[int] = None,
            run_prefix: Optional[str] = None,
            check_alert_states_filter: Optional["scout_run_api_CheckAlertStatesFilter"] = None,
            archived: Optional[bool] = None,
            and_: Optional[List["scout_run_api_SearchQuery"]] = None,
            or_: Optional[List["scout_run_api_SearchQuery"]] = None,
            not_: Optional["scout_run_api_SearchQuery"] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (start_time_inclusive is not None) + (start_time is not None) + (end_time_inclusive is not None) + (end_time is not None) + (time_range is not None) + (created_at is not None) + (exact_match is not None) + (search_text is not None) + (asset is not None) + (assets is not None) + (is_single_asset is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (data_source_series_tag is not None) + (data_source_ref_name is not None) + (data_source is not None) + (run_number is not None) + (run_prefix is not None) + (check_alert_states_filter is not None) + (archived is not None) + (and_ is not None) + (or_ is not None) + (not_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if start_time_inclusive is not None:
                self._start_time_inclusive = start_time_inclusive
                self._type = 'startTimeInclusive'
            if start_time is not None:
                self._start_time = start_time
                self._type = 'startTime'
            if end_time_inclusive is not None:
                self._end_time_inclusive = end_time_inclusive
                self._type = 'endTimeInclusive'
            if end_time is not None:
                self._end_time = end_time
                self._type = 'endTime'
            if time_range is not None:
                self._time_range = time_range
                self._type = 'timeRange'
            if created_at is not None:
                self._created_at = created_at
                self._type = 'createdAt'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if assets is not None:
                self._assets = assets
                self._type = 'assets'
            if is_single_asset is not None:
                self._is_single_asset = is_single_asset
                self._type = 'isSingleAsset'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if data_source_series_tag is not None:
                self._data_source_series_tag = data_source_series_tag
                self._type = 'dataSourceSeriesTag'
            if data_source_ref_name is not None:
                self._data_source_ref_name = data_source_ref_name
                self._type = 'dataSourceRefName'
            if data_source is not None:
                self._data_source = data_source
                self._type = 'dataSource'
            if run_number is not None:
                self._run_number = run_number
                self._type = 'runNumber'
            if run_prefix is not None:
                self._run_prefix = run_prefix
                self._type = 'runPrefix'
            if check_alert_states_filter is not None:
                self._check_alert_states_filter = check_alert_states_filter
                self._type = 'checkAlertStatesFilter'
            if archived is not None:
                self._archived = archived
                self._type = 'archived'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'startTimeInclusive':
            if start_time_inclusive is None:
                raise ValueError('a union value must not be None')
            self._start_time_inclusive = start_time_inclusive
            self._type = 'startTimeInclusive'
        elif type_of_union == 'startTime':
            if start_time is None:
                raise ValueError('a union value must not be None')
            self._start_time = start_time
            self._type = 'startTime'
        elif type_of_union == 'endTimeInclusive':
            if end_time_inclusive is None:
                raise ValueError('a union value must not be None')
            self._end_time_inclusive = end_time_inclusive
            self._type = 'endTimeInclusive'
        elif type_of_union == 'endTime':
            if end_time is None:
                raise ValueError('a union value must not be None')
            self._end_time = end_time
            self._type = 'endTime'
        elif type_of_union == 'timeRange':
            if time_range is None:
                raise ValueError('a union value must not be None')
            self._time_range = time_range
            self._type = 'timeRange'
        elif type_of_union == 'createdAt':
            if created_at is None:
                raise ValueError('a union value must not be None')
            self._created_at = created_at
            self._type = 'createdAt'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'assets':
            if assets is None:
                raise ValueError('a union value must not be None')
            self._assets = assets
            self._type = 'assets'
        elif type_of_union == 'isSingleAsset':
            if is_single_asset is None:
                raise ValueError('a union value must not be None')
            self._is_single_asset = is_single_asset
            self._type = 'isSingleAsset'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'dataSourceSeriesTag':
            if data_source_series_tag is None:
                raise ValueError('a union value must not be None')
            self._data_source_series_tag = data_source_series_tag
            self._type = 'dataSourceSeriesTag'
        elif type_of_union == 'dataSourceRefName':
            if data_source_ref_name is None:
                raise ValueError('a union value must not be None')
            self._data_source_ref_name = data_source_ref_name
            self._type = 'dataSourceRefName'
        elif type_of_union == 'dataSource':
            if data_source is None:
                raise ValueError('a union value must not be None')
            self._data_source = data_source
            self._type = 'dataSource'
        elif type_of_union == 'runNumber':
            if run_number is None:
                raise ValueError('a union value must not be None')
            self._run_number = run_number
            self._type = 'runNumber'
        elif type_of_union == 'runPrefix':
            if run_prefix is None:
                raise ValueError('a union value must not be None')
            self._run_prefix = run_prefix
            self._type = 'runPrefix'
        elif type_of_union == 'checkAlertStatesFilter':
            if check_alert_states_filter is None:
                raise ValueError('a union value must not be None')
            self._check_alert_states_filter = check_alert_states_filter
            self._type = 'checkAlertStatesFilter'
        elif type_of_union == 'archived':
            if archived is None:
                raise ValueError('a union value must not be None')
            self._archived = archived
            self._type = 'archived'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def start_time_inclusive(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._start_time_inclusive

    @builtins.property
    def start_time(self) -> Optional["scout_run_api_TimeframeFilter"]:
        return self._start_time

    @builtins.property
    def end_time_inclusive(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end_time_inclusive

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_TimeframeFilter"]:
        return self._end_time

    @builtins.property
    def time_range(self) -> Optional["scout_run_api_TimeRangeFilter"]:
        return self._time_range

    @builtins.property
    def created_at(self) -> Optional["scout_run_api_TimeframeFilter"]:
        return self._created_at

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact substring match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def assets(self) -> Optional["scout_run_api_AssetsFilter"]:
        return self._assets

    @builtins.property
    def is_single_asset(self) -> Optional[bool]:
        """Search for either only single-asset runs (true), or only multi-asset runs (false).
        """
        return self._is_single_asset

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def data_source_series_tag(self) -> Optional["scout_run_api_DataSourceSeriesTag"]:
        return self._data_source_series_tag

    @builtins.property
    def data_source_ref_name(self) -> Optional[str]:
        return self._data_source_ref_name

    @builtins.property
    def data_source(self) -> Optional["scout_run_api_DataSource"]:
        return self._data_source

    @builtins.property
    def run_number(self) -> Optional[int]:
        return self._run_number

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        return self._run_prefix

    @builtins.property
    def check_alert_states_filter(self) -> Optional["scout_run_api_CheckAlertStatesFilter"]:
        """Search for runs where its aggregated check alert satisfy a given operator and threshold.
        """
        return self._check_alert_states_filter

    @builtins.property
    def archived(self) -> Optional[bool]:
        return self._archived

    @builtins.property
    def and_(self) -> Optional[List["scout_run_api_SearchQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_run_api_SearchQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_run_api_SearchQuery"]:
        return self._not_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_SearchQueryVisitor):
            raise ValueError('{} is not an instance of scout_run_api_SearchQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'startTimeInclusive' and self.start_time_inclusive is not None:
            return visitor._start_time_inclusive(self.start_time_inclusive)
        if self._type == 'startTime' and self.start_time is not None:
            return visitor._start_time(self.start_time)
        if self._type == 'endTimeInclusive' and self.end_time_inclusive is not None:
            return visitor._end_time_inclusive(self.end_time_inclusive)
        if self._type == 'endTime' and self.end_time is not None:
            return visitor._end_time(self.end_time)
        if self._type == 'timeRange' and self.time_range is not None:
            return visitor._time_range(self.time_range)
        if self._type == 'createdAt' and self.created_at is not None:
            return visitor._created_at(self.created_at)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'assets' and self.assets is not None:
            return visitor._assets(self.assets)
        if self._type == 'isSingleAsset' and self.is_single_asset is not None:
            return visitor._is_single_asset(self.is_single_asset)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'dataSourceSeriesTag' and self.data_source_series_tag is not None:
            return visitor._data_source_series_tag(self.data_source_series_tag)
        if self._type == 'dataSourceRefName' and self.data_source_ref_name is not None:
            return visitor._data_source_ref_name(self.data_source_ref_name)
        if self._type == 'dataSource' and self.data_source is not None:
            return visitor._data_source(self.data_source)
        if self._type == 'runNumber' and self.run_number is not None:
            return visitor._run_number(self.run_number)
        if self._type == 'runPrefix' and self.run_prefix is not None:
            return visitor._run_prefix(self.run_prefix)
        if self._type == 'checkAlertStatesFilter' and self.check_alert_states_filter is not None:
            return visitor._check_alert_states_filter(self.check_alert_states_filter)
        if self._type == 'archived' and self.archived is not None:
            return visitor._archived(self.archived)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


scout_run_api_SearchQuery.__name__ = "SearchQuery"
scout_run_api_SearchQuery.__qualname__ = "SearchQuery"
scout_run_api_SearchQuery.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchQueryVisitor:

    @abstractmethod
    def _start_time_inclusive(self, start_time_inclusive: "scout_run_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _start_time(self, start_time: "scout_run_api_TimeframeFilter") -> Any:
        pass

    @abstractmethod
    def _end_time_inclusive(self, end_time_inclusive: "scout_run_api_UtcTimestamp") -> Any:
        pass

    @abstractmethod
    def _end_time(self, end_time: "scout_run_api_TimeframeFilter") -> Any:
        pass

    @abstractmethod
    def _time_range(self, time_range: "scout_run_api_TimeRangeFilter") -> Any:
        pass

    @abstractmethod
    def _created_at(self, created_at: "scout_run_api_TimeframeFilter") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: str) -> Any:
        pass

    @abstractmethod
    def _assets(self, assets: "scout_run_api_AssetsFilter") -> Any:
        pass

    @abstractmethod
    def _is_single_asset(self, is_single_asset: bool) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _data_source_series_tag(self, data_source_series_tag: "scout_run_api_DataSourceSeriesTag") -> Any:
        pass

    @abstractmethod
    def _data_source_ref_name(self, data_source_ref_name: str) -> Any:
        pass

    @abstractmethod
    def _data_source(self, data_source: "scout_run_api_DataSource") -> Any:
        pass

    @abstractmethod
    def _run_number(self, run_number: int) -> Any:
        pass

    @abstractmethod
    def _run_prefix(self, run_prefix: str) -> Any:
        pass

    @abstractmethod
    def _check_alert_states_filter(self, check_alert_states_filter: "scout_run_api_CheckAlertStatesFilter") -> Any:
        pass

    @abstractmethod
    def _archived(self, archived: bool) -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_run_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_run_api_SearchQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_run_api_SearchQuery") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


scout_run_api_SearchQueryVisitor.__name__ = "SearchQueryVisitor"
scout_run_api_SearchQueryVisitor.__qualname__ = "SearchQueryVisitor"
scout_run_api_SearchQueryVisitor.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunChannelsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'ref_name_filter': ConjureFieldDefinition('refNameFilter', OptionalTypeWrapper[List[scout_api_DataSourceRefName]]),
            'previously_selected_channels': ConjureFieldDefinition('previouslySelectedChannels', Dict[scout_api_DataSourceRefName, List[api_Channel]]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_search_text', '_ref_name_filter', '_previously_selected_channels', '_next_page_token', '_page_size']

    def __init__(self, previously_selected_channels: Dict[str, List[str]], search_text: str, next_page_token: Optional[str] = None, page_size: Optional[int] = None, ref_name_filter: Optional[List[str]] = None) -> None:
        self._search_text = search_text
        self._ref_name_filter = ref_name_filter
        self._previously_selected_channels = previously_selected_channels
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def search_text(self) -> str:
        return self._search_text

    @builtins.property
    def ref_name_filter(self) -> Optional[List[str]]:
        """If not empty, will filter to channels from the selected DataSourceRefNames.
        """
        return self._ref_name_filter

    @builtins.property
    def previously_selected_channels(self) -> Dict[str, List[str]]:
        return self._previously_selected_channels

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 1000. Will throw if larger than 1000.
        """
        return self._page_size


scout_run_api_SearchRunChannelsRequest.__name__ = "SearchRunChannelsRequest"
scout_run_api_SearchRunChannelsRequest.__qualname__ = "SearchRunChannelsRequest"
scout_run_api_SearchRunChannelsRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunChannelsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_ChannelMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_ChannelMetadata"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_ChannelMetadata"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunChannelsResponse.__name__ = "SearchRunChannelsResponse"
scout_run_api_SearchRunChannelsResponse.__qualname__ = "SearchRunChannelsResponse"
scout_run_api_SearchRunChannelsResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_run_api_SortOptions),
            'page_size': ConjureFieldDefinition('pageSize', int),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'query': ConjureFieldDefinition('query', scout_run_api_SearchQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, page_size: int, query: "scout_run_api_SearchQuery", sort: "scout_run_api_SortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "scout_run_api_SortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> int:
        """Will reject page sizes greater than 1000.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_run_api_SearchQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived runs in search.
        """
        return self._archived_statuses


scout_run_api_SearchRunsRequest.__name__ = "SearchRunsRequest"
scout_run_api_SearchRunsRequest.__qualname__ = "SearchRunsRequest"
scout_run_api_SearchRunsRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_Run]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_Run"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_Run"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsResponse.__name__ = "SearchRunsResponse"
scout_run_api_SearchRunsResponse.__qualname__ = "SearchRunsResponse"
scout_run_api_SearchRunsResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunsWithDataReviewMetricsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_RunWithDataReviewMetrics]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_RunWithDataReviewMetrics"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_RunWithDataReviewMetrics"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsWithDataReviewMetricsResponse.__name__ = "SearchRunsWithDataReviewMetricsResponse"
scout_run_api_SearchRunsWithDataReviewMetricsResponse.__qualname__ = "SearchRunsWithDataReviewMetricsResponse"
scout_run_api_SearchRunsWithDataReviewMetricsResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SearchRunsWithDataReviewSummaryResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_run_api_RunWithDataReviewSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_run_api_RunWithDataReviewSummary"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_run_api_RunWithDataReviewSummary"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_run_api_SearchRunsWithDataReviewSummaryResponse.__name__ = "SearchRunsWithDataReviewSummaryResponse"
scout_run_api_SearchRunsWithDataReviewSummaryResponse.__qualname__ = "SearchRunsWithDataReviewSummaryResponse"
scout_run_api_SearchRunsWithDataReviewSummaryResponse.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SortField(ConjureEnumType):

    NAME = 'NAME'
    '''NAME'''
    ID = 'ID'
    '''ID'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    START_TIME = 'START_TIME'
    '''START_TIME'''
    END_TIME = 'END_TIME'
    '''END_TIME'''
    PENDING_CHECK_ALERTS = 'PENDING_CHECK_ALERTS'
    '''PENDING_CHECK_ALERTS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_SortField.__name__ = "SortField"
scout_run_api_SortField.__qualname__ = "SortField"
scout_run_api_SortField.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SortKey(ConjureUnionType):
    _field: Optional["scout_run_api_SortField"] = None
    _property: Optional["scout_run_api_SortProperty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field': ConjureFieldDefinition('field', scout_run_api_SortField),
            'property': ConjureFieldDefinition('property', scout_run_api_SortProperty)
        }

    def __init__(
            self,
            field: Optional["scout_run_api_SortField"] = None,
            property: Optional["scout_run_api_SortProperty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (field is not None) + (property is not None) != 1:
                raise ValueError('a union must contain a single member')

            if field is not None:
                self._field = field
                self._type = 'field'
            if property is not None:
                self._property = property
                self._type = 'property'

        elif type_of_union == 'field':
            if field is None:
                raise ValueError('a union value must not be None')
            self._field = field
            self._type = 'field'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'

    @builtins.property
    def field(self) -> Optional["scout_run_api_SortField"]:
        return self._field

    @builtins.property
    def property(self) -> Optional["scout_run_api_SortProperty"]:
        """Sort by a property value. Requires a property name, and will always sort null values last.
        """
        return self._property

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_SortKeyVisitor):
            raise ValueError('{} is not an instance of scout_run_api_SortKeyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'field' and self.field is not None:
            return visitor._field(self.field)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)


scout_run_api_SortKey.__name__ = "SortKey"
scout_run_api_SortKey.__qualname__ = "SortKey"
scout_run_api_SortKey.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SortKeyVisitor:

    @abstractmethod
    def _field(self, field: "scout_run_api_SortField") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "scout_run_api_SortProperty") -> Any:
        pass


scout_run_api_SortKeyVisitor.__name__ = "SortKeyVisitor"
scout_run_api_SortKeyVisitor.__qualname__ = "SortKeyVisitor"
scout_run_api_SortKeyVisitor.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', OptionalTypeWrapper[scout_run_api_SortField]),
            'sort_key': ConjureFieldDefinition('sortKey', OptionalTypeWrapper[scout_run_api_SortKey])
        }

    __slots__: List[str] = ['_is_descending', '_field', '_sort_key']

    def __init__(self, is_descending: bool, field: Optional["scout_run_api_SortField"] = None, sort_key: Optional["scout_run_api_SortKey"] = None) -> None:
        self._is_descending = is_descending
        self._field = field
        self._sort_key = sort_key

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> Optional["scout_run_api_SortField"]:
        return self._field

    @builtins.property
    def sort_key(self) -> Optional["scout_run_api_SortKey"]:
        """Field to sort by. Includes both field and property-based sorting.
        """
        return self._sort_key


scout_run_api_SortOptions.__name__ = "SortOptions"
scout_run_api_SortOptions.__qualname__ = "SortOptions"
scout_run_api_SortOptions.__module__ = "nominal_api.scout_run_api"


class scout_run_api_SortProperty(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_PropertyName)
        }

    __slots__: List[str] = ['_name']

    def __init__(self, name: str) -> None:
        self._name = name

    @builtins.property
    def name(self) -> str:
        return self._name


scout_run_api_SortProperty.__name__ = "SortProperty"
scout_run_api_SortProperty.__qualname__ = "SortProperty"
scout_run_api_SortProperty.__module__ = "nominal_api.scout_run_api"


class scout_run_api_TimeRangeFilter(ConjureBeanType):
    """searches for runs that have at least some intersection with the specified range.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'end': ConjureFieldDefinition('end', OptionalTypeWrapper[scout_run_api_UtcTimestamp])
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: Optional["scout_run_api_UtcTimestamp"] = None, start: Optional["scout_run_api_UtcTimestamp"] = None) -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._start

    @builtins.property
    def end(self) -> Optional["scout_run_api_UtcTimestamp"]:
        return self._end


scout_run_api_TimeRangeFilter.__name__ = "TimeRangeFilter"
scout_run_api_TimeRangeFilter.__qualname__ = "TimeRangeFilter"
scout_run_api_TimeRangeFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_TimeframeFilter(ConjureUnionType):
    _custom: Optional["scout_run_api_CustomTimeframeFilter"] = None
    _preset: Optional["scout_run_api_PresetTimeframeFilter"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'custom': ConjureFieldDefinition('custom', scout_run_api_CustomTimeframeFilter),
            'preset': ConjureFieldDefinition('preset', scout_run_api_PresetTimeframeFilter)
        }

    def __init__(
            self,
            custom: Optional["scout_run_api_CustomTimeframeFilter"] = None,
            preset: Optional["scout_run_api_PresetTimeframeFilter"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (custom is not None) + (preset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if custom is not None:
                self._custom = custom
                self._type = 'custom'
            if preset is not None:
                self._preset = preset
                self._type = 'preset'

        elif type_of_union == 'custom':
            if custom is None:
                raise ValueError('a union value must not be None')
            self._custom = custom
            self._type = 'custom'
        elif type_of_union == 'preset':
            if preset is None:
                raise ValueError('a union value must not be None')
            self._preset = preset
            self._type = 'preset'

    @builtins.property
    def custom(self) -> Optional["scout_run_api_CustomTimeframeFilter"]:
        return self._custom

    @builtins.property
    def preset(self) -> Optional["scout_run_api_PresetTimeframeFilter"]:
        return self._preset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_run_api_TimeframeFilterVisitor):
            raise ValueError('{} is not an instance of scout_run_api_TimeframeFilterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'custom' and self.custom is not None:
            return visitor._custom(self.custom)
        if self._type == 'preset' and self.preset is not None:
            return visitor._preset(self.preset)


scout_run_api_TimeframeFilter.__name__ = "TimeframeFilter"
scout_run_api_TimeframeFilter.__qualname__ = "TimeframeFilter"
scout_run_api_TimeframeFilter.__module__ = "nominal_api.scout_run_api"


class scout_run_api_TimeframeFilterVisitor:

    @abstractmethod
    def _custom(self, custom: "scout_run_api_CustomTimeframeFilter") -> Any:
        pass

    @abstractmethod
    def _preset(self, preset: "scout_run_api_PresetTimeframeFilter") -> Any:
        pass


scout_run_api_TimeframeFilterVisitor.__name__ = "TimeframeFilterVisitor"
scout_run_api_TimeframeFilterVisitor.__qualname__ = "TimeframeFilterVisitor"
scout_run_api_TimeframeFilterVisitor.__module__ = "nominal_api.scout_run_api"


class scout_run_api_UnarchiveRunsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rids': ConjureFieldDefinition('rids', List[scout_run_api_RunRid]),
            'include_linked_workbooks': ConjureFieldDefinition('includeLinkedWorkbooks', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_rids', '_include_linked_workbooks']

    def __init__(self, rids: List[str], include_linked_workbooks: Optional[bool] = None) -> None:
        self._rids = rids
        self._include_linked_workbooks = include_linked_workbooks

    @builtins.property
    def rids(self) -> List[str]:
        return self._rids

    @builtins.property
    def include_linked_workbooks(self) -> Optional[bool]:
        """If true, all auto-archived workbooks that are linked to run will be unarchived as well.
Defaults to false.
        """
        return self._include_linked_workbooks


scout_run_api_UnarchiveRunsRequest.__name__ = "UnarchiveRunsRequest"
scout_run_api_UnarchiveRunsRequest.__qualname__ = "UnarchiveRunsRequest"
scout_run_api_UnarchiveRunsRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'symbol': ConjureFieldDefinition('symbol', str)
        }

    __slots__: List[str] = ['_name', '_symbol']

    def __init__(self, symbol: str, name: Optional[str] = None) -> None:
        self._name = name
        self._symbol = symbol

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol


scout_run_api_Unit.__name__ = "Unit"
scout_run_api_Unit.__qualname__ = "Unit"
scout_run_api_Unit.__module__ = "nominal_api.scout_run_api"


class scout_run_api_UpdateAttachmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'attachments_to_add': ConjureFieldDefinition('attachmentsToAdd', List[api_rids_AttachmentRid]),
            'attachments_to_remove': ConjureFieldDefinition('attachmentsToRemove', List[api_rids_AttachmentRid])
        }

    __slots__: List[str] = ['_attachments_to_add', '_attachments_to_remove']

    def __init__(self, attachments_to_add: List[str], attachments_to_remove: List[str]) -> None:
        self._attachments_to_add = attachments_to_add
        self._attachments_to_remove = attachments_to_remove

    @builtins.property
    def attachments_to_add(self) -> List[str]:
        return self._attachments_to_add

    @builtins.property
    def attachments_to_remove(self) -> List[str]:
        return self._attachments_to_remove


scout_run_api_UpdateAttachmentsRequest.__name__ = "UpdateAttachmentsRequest"
scout_run_api_UpdateAttachmentsRequest.__qualname__ = "UpdateAttachmentsRequest"
scout_run_api_UpdateAttachmentsRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_UpdateRunRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'start_time': ConjureFieldDefinition('startTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'end_time': ConjureFieldDefinition('endTime', OptionalTypeWrapper[scout_run_api_UtcTimestamp]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'links': ConjureFieldDefinition('links', OptionalTypeWrapper[List[scout_run_api_Link]]),
            'run_prefix': ConjureFieldDefinition('runPrefix', OptionalTypeWrapper[str]),
            'data_sources': ConjureFieldDefinition('dataSources', OptionalTypeWrapper[Dict[scout_api_DataSourceRefName, scout_run_api_CreateRunDataSource]]),
            'attachments': ConjureFieldDefinition('attachments', OptionalTypeWrapper[List[api_rids_AttachmentRid]]),
            'asset': ConjureFieldDefinition('asset', OptionalTypeWrapper[scout_rids_api_AssetRid]),
            'assets': ConjureFieldDefinition('assets', List[scout_rids_api_AssetRid]),
            'strict_overwrite': ConjureFieldDefinition('strictOverwrite', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_description', '_start_time', '_end_time', '_properties', '_labels', '_links', '_run_prefix', '_data_sources', '_attachments', '_asset', '_assets', '_strict_overwrite']

    def __init__(self, assets: List[str], asset: Optional[str] = None, attachments: Optional[List[str]] = None, data_sources: Optional[Dict[str, "scout_run_api_CreateRunDataSource"]] = None, description: Optional[str] = None, end_time: Optional["scout_run_api_UtcTimestamp"] = None, labels: Optional[List[str]] = None, links: Optional[List["scout_run_api_Link"]] = None, properties: Optional[Dict[str, str]] = None, run_prefix: Optional[str] = None, start_time: Optional["scout_run_api_UtcTimestamp"] = None, strict_overwrite: Optional[bool] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._start_time = start_time
        self._end_time = end_time
        self._properties = properties
        self._labels = labels
        self._links = links
        self._run_prefix = run_prefix
        self._data_sources = data_sources
        self._attachments = attachments
        self._asset = asset
        self._assets = assets
        self._strict_overwrite = strict_overwrite

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def start_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        """If strictOverwrite is false, will only update the startTime if it is before the existing startTime.
        """
        return self._start_time

    @builtins.property
    def end_time(self) -> Optional["scout_run_api_UtcTimestamp"]:
        """If strictOverwrite is false, will only update the endTime if it is after the existing endTime.
        """
        return self._end_time

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def links(self) -> Optional[List["scout_run_api_Link"]]:
        return self._links

    @builtins.property
    def run_prefix(self) -> Optional[str]:
        """Pass in an empty string to remove the run prefix.
        """
        return self._run_prefix

    @builtins.property
    def data_sources(self) -> Optional[Dict[str, "scout_run_api_CreateRunDataSource"]]:
        return self._data_sources

    @builtins.property
    def attachments(self) -> Optional[List[str]]:
        return self._attachments

    @builtins.property
    def asset(self) -> Optional[str]:
        return self._asset

    @builtins.property
    def assets(self) -> List[str]:
        return self._assets

    @builtins.property
    def strict_overwrite(self) -> Optional[bool]:
        """If true, will blindly overwrite the existing fields with the new values in the request.
If false, will only update the fields if application constraints are maintained.
See individual field docs for more details.
Defaults to true for backwards compatibility.
        """
        return self._strict_overwrite


scout_run_api_UpdateRunRequest.__name__ = "UpdateRunRequest"
scout_run_api_UpdateRunRequest.__qualname__ = "UpdateRunRequest"
scout_run_api_UpdateRunRequest.__module__ = "nominal_api.scout_run_api"


class scout_run_api_UtcTimestamp(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'seconds_since_epoch': ConjureFieldDefinition('secondsSinceEpoch', int),
            'offset_nanoseconds': ConjureFieldDefinition('offsetNanoseconds', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_seconds_since_epoch', '_offset_nanoseconds']

    def __init__(self, seconds_since_epoch: int, offset_nanoseconds: Optional[int] = None) -> None:
        self._seconds_since_epoch = seconds_since_epoch
        self._offset_nanoseconds = offset_nanoseconds

    @builtins.property
    def seconds_since_epoch(self) -> int:
        return self._seconds_since_epoch

    @builtins.property
    def offset_nanoseconds(self) -> Optional[int]:
        return self._offset_nanoseconds


scout_run_api_UtcTimestamp.__name__ = "UtcTimestamp"
scout_run_api_UtcTimestamp.__qualname__ = "UtcTimestamp"
scout_run_api_UtcTimestamp.__module__ = "nominal_api.scout_run_api"


class scout_run_api_WeakTimestampType(ConjureEnumType):
    """If a CSV data source is still being split, the timestamp type is not known.
    """

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    PENDING = 'PENDING'
    '''PENDING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_run_api_WeakTimestampType.__name__ = "WeakTimestampType"
scout_run_api_WeakTimestampType.__qualname__ = "WeakTimestampType"
scout_run_api_WeakTimestampType.__module__ = "nominal_api.scout_run_api"


class scout_savedviews_SavedViewService(Service):
    """Saved Views allow users to store and reuse filter and table display configurations across 
assets, runs, checklists, and more. They can be favorited, archived, and shared across a workspace.
    """

    def create_saved_view(self, auth_header: str, request: "scout_savedviews_api_CreateSavedViewRequest") -> "scout_savedviews_api_CreateSavedViewResponse":
        """Creates a new saved view in the given workspace. If no workspace is specified,
it is created in the user's default workspace.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/saved-views/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_savedviews_api_CreateSavedViewResponse, self._return_none_for_unknown_union_types)

    def get_saved_view(self, auth_header: str, saved_view_rid: str) -> "scout_savedviews_api_GetSavedViewResponse":
        """Fetches a saved view by RID. Throws NOT_FOUND if it does not exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'savedViewRid': quote(str(_conjure_encoder.default(saved_view_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/saved-views/v1/{savedViewRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_savedviews_api_GetSavedViewResponse, self._return_none_for_unknown_union_types)

    def batch_get_saved_views(self, auth_header: str, saved_view_rids: List[str] = None) -> "scout_savedviews_api_BatchGetSavedViewsResponse":
        """Retrieves multiple saved views. Any invalid or unknown RIDs are omitted from the response.
        """
        saved_view_rids = saved_view_rids if saved_view_rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(saved_view_rids)

        _path = '/scout/saved-views/v1/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_savedviews_api_BatchGetSavedViewsResponse, self._return_none_for_unknown_union_types)

    def search_saved_views(self, auth_header: str, request: "scout_savedviews_api_SearchSavedViewsRequest") -> "scout_savedviews_api_SearchSavedViewsResponse":
        """Searches for saved views using a nested query expression. Supports pagination.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/saved-views/v1/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_savedviews_api_SearchSavedViewsResponse, self._return_none_for_unknown_union_types)

    def update_saved_view(self, auth_header: str, request: "scout_savedviews_api_UpdateSavedViewRequest", saved_view_rid: str) -> "scout_savedviews_api_UpdateSavedViewResponse":
        """Updates metadata, search filters, or display settings for an existing saved view.
Throws NOT_FOUND if the view doesn't exist and INVALID_ARGUMENT if it is archived.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'savedViewRid': quote(str(_conjure_encoder.default(saved_view_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/scout/saved-views/v1/{savedViewRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_savedviews_api_UpdateSavedViewResponse, self._return_none_for_unknown_union_types)

    def archive_saved_view(self, auth_header: str, saved_view_rid: str) -> None:
        """Archives the specified saved view. Archived views are hidden from search.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'savedViewRid': quote(str(_conjure_encoder.default(saved_view_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/saved-views/v1/{savedViewRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive_saved_view(self, auth_header: str, saved_view_rid: str) -> None:
        """Restores archived saved view, making them discoverable in search again.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'savedViewRid': quote(str(_conjure_encoder.default(saved_view_rid)), safe=''),
        }

        _json: Any = None

        _path = '/scout/saved-views/v1/{savedViewRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


scout_savedviews_SavedViewService.__name__ = "SavedViewService"
scout_savedviews_SavedViewService.__qualname__ = "SavedViewService"
scout_savedviews_SavedViewService.__module__ = "nominal_api.scout_savedviews"


class scout_savedviews_api_AssetMetricColumn(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', scout_savedviews_api_MetricColumnMetadata),
            'time_range': ConjureFieldDefinition('timeRange', scout_savedviews_api_AssetMetricColumnTimeRange),
            'aggregation': ConjureFieldDefinition('aggregation', scout_savedviews_api_MetricColumnAggregation),
            'data': ConjureFieldDefinition('data', scout_savedviews_api_MetricColumnData),
            'style': ConjureFieldDefinition('style', OptionalTypeWrapper[scout_savedviews_api_MetricColumnStyle])
        }

    __slots__: List[str] = ['_metadata', '_time_range', '_aggregation', '_data', '_style']

    def __init__(self, aggregation: "scout_savedviews_api_MetricColumnAggregation", data: "scout_savedviews_api_MetricColumnData", metadata: "scout_savedviews_api_MetricColumnMetadata", time_range: "scout_savedviews_api_AssetMetricColumnTimeRange", style: Optional["scout_savedviews_api_MetricColumnStyle"] = None) -> None:
        self._metadata = metadata
        self._time_range = time_range
        self._aggregation = aggregation
        self._data = data
        self._style = style

    @builtins.property
    def metadata(self) -> "scout_savedviews_api_MetricColumnMetadata":
        return self._metadata

    @builtins.property
    def time_range(self) -> "scout_savedviews_api_AssetMetricColumnTimeRange":
        return self._time_range

    @builtins.property
    def aggregation(self) -> "scout_savedviews_api_MetricColumnAggregation":
        return self._aggregation

    @builtins.property
    def data(self) -> "scout_savedviews_api_MetricColumnData":
        return self._data

    @builtins.property
    def style(self) -> Optional["scout_savedviews_api_MetricColumnStyle"]:
        return self._style


scout_savedviews_api_AssetMetricColumn.__name__ = "AssetMetricColumn"
scout_savedviews_api_AssetMetricColumn.__qualname__ = "AssetMetricColumn"
scout_savedviews_api_AssetMetricColumn.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_AssetMetricColumnTimeRange(ConjureUnionType):
    _most_recent_run: Optional["scout_savedviews_api_MostRecentRun"] = None
    _custom: Optional["scout_run_api_CustomTimeframeFilter"] = None
    _preset: Optional["scout_run_api_PresetTimeframeFilter"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'most_recent_run': ConjureFieldDefinition('mostRecentRun', scout_savedviews_api_MostRecentRun),
            'custom': ConjureFieldDefinition('custom', scout_run_api_CustomTimeframeFilter),
            'preset': ConjureFieldDefinition('preset', scout_run_api_PresetTimeframeFilter)
        }

    def __init__(
            self,
            most_recent_run: Optional["scout_savedviews_api_MostRecentRun"] = None,
            custom: Optional["scout_run_api_CustomTimeframeFilter"] = None,
            preset: Optional["scout_run_api_PresetTimeframeFilter"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (most_recent_run is not None) + (custom is not None) + (preset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if most_recent_run is not None:
                self._most_recent_run = most_recent_run
                self._type = 'mostRecentRun'
            if custom is not None:
                self._custom = custom
                self._type = 'custom'
            if preset is not None:
                self._preset = preset
                self._type = 'preset'

        elif type_of_union == 'mostRecentRun':
            if most_recent_run is None:
                raise ValueError('a union value must not be None')
            self._most_recent_run = most_recent_run
            self._type = 'mostRecentRun'
        elif type_of_union == 'custom':
            if custom is None:
                raise ValueError('a union value must not be None')
            self._custom = custom
            self._type = 'custom'
        elif type_of_union == 'preset':
            if preset is None:
                raise ValueError('a union value must not be None')
            self._preset = preset
            self._type = 'preset'

    @builtins.property
    def most_recent_run(self) -> Optional["scout_savedviews_api_MostRecentRun"]:
        return self._most_recent_run

    @builtins.property
    def custom(self) -> Optional["scout_run_api_CustomTimeframeFilter"]:
        return self._custom

    @builtins.property
    def preset(self) -> Optional["scout_run_api_PresetTimeframeFilter"]:
        return self._preset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_AssetMetricColumnTimeRangeVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_AssetMetricColumnTimeRangeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'mostRecentRun' and self.most_recent_run is not None:
            return visitor._most_recent_run(self.most_recent_run)
        if self._type == 'custom' and self.custom is not None:
            return visitor._custom(self.custom)
        if self._type == 'preset' and self.preset is not None:
            return visitor._preset(self.preset)


scout_savedviews_api_AssetMetricColumnTimeRange.__name__ = "AssetMetricColumnTimeRange"
scout_savedviews_api_AssetMetricColumnTimeRange.__qualname__ = "AssetMetricColumnTimeRange"
scout_savedviews_api_AssetMetricColumnTimeRange.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_AssetMetricColumnTimeRangeVisitor:

    @abstractmethod
    def _most_recent_run(self, most_recent_run: "scout_savedviews_api_MostRecentRun") -> Any:
        pass

    @abstractmethod
    def _custom(self, custom: "scout_run_api_CustomTimeframeFilter") -> Any:
        pass

    @abstractmethod
    def _preset(self, preset: "scout_run_api_PresetTimeframeFilter") -> Any:
        pass


scout_savedviews_api_AssetMetricColumnTimeRangeVisitor.__name__ = "AssetMetricColumnTimeRangeVisitor"
scout_savedviews_api_AssetMetricColumnTimeRangeVisitor.__qualname__ = "AssetMetricColumnTimeRangeVisitor"
scout_savedviews_api_AssetMetricColumnTimeRangeVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_AssetMetricColumns(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metric_columns': ConjureFieldDefinition('metricColumns', Dict[scout_savedviews_api_ColumnId, scout_savedviews_api_AssetMetricColumn])
        }

    __slots__: List[str] = ['_metric_columns']

    def __init__(self, metric_columns: Dict[str, "scout_savedviews_api_AssetMetricColumn"]) -> None:
        self._metric_columns = metric_columns

    @builtins.property
    def metric_columns(self) -> Dict[str, "scout_savedviews_api_AssetMetricColumn"]:
        return self._metric_columns


scout_savedviews_api_AssetMetricColumns.__name__ = "AssetMetricColumns"
scout_savedviews_api_AssetMetricColumns.__qualname__ = "AssetMetricColumns"
scout_savedviews_api_AssetMetricColumns.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_AssetSearchState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[scout_asset_api_AssetSortOptions]),
            'group_by': ConjureFieldDefinition('groupBy', OptionalTypeWrapper[List[scout_savedviews_api_ColumnId]]),
            'query': ConjureFieldDefinition('query', scout_asset_api_SearchAssetsQuery)
        }

    __slots__: List[str] = ['_sort', '_group_by', '_query']

    def __init__(self, query: "scout_asset_api_SearchAssetsQuery", group_by: Optional[List[str]] = None, sort: Optional["scout_asset_api_AssetSortOptions"] = None) -> None:
        self._sort = sort
        self._group_by = group_by
        self._query = query

    @builtins.property
    def sort(self) -> Optional["scout_asset_api_AssetSortOptions"]:
        return self._sort

    @builtins.property
    def group_by(self) -> Optional[List[str]]:
        return self._group_by

    @builtins.property
    def query(self) -> "scout_asset_api_SearchAssetsQuery":
        return self._query


scout_savedviews_api_AssetSearchState.__name__ = "AssetSearchState"
scout_savedviews_api_AssetSearchState.__qualname__ = "AssetSearchState"
scout_savedviews_api_AssetSearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_BatchGetSavedViewsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'saved_views': ConjureFieldDefinition('savedViews', List[scout_savedviews_api_SavedView])
        }

    __slots__: List[str] = ['_saved_views']

    def __init__(self, saved_views: List["scout_savedviews_api_SavedView"]) -> None:
        self._saved_views = saved_views

    @builtins.property
    def saved_views(self) -> List["scout_savedviews_api_SavedView"]:
        return self._saved_views


scout_savedviews_api_BatchGetSavedViewsResponse.__name__ = "BatchGetSavedViewsResponse"
scout_savedviews_api_BatchGetSavedViewsResponse.__qualname__ = "BatchGetSavedViewsResponse"
scout_savedviews_api_BatchGetSavedViewsResponse.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_ChecklistSearchState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[scout_checks_api_SortOptions]),
            'query': ConjureFieldDefinition('query', scout_checks_api_ChecklistSearchQuery)
        }

    __slots__: List[str] = ['_sort', '_query']

    def __init__(self, query: "scout_checks_api_ChecklistSearchQuery", sort: Optional["scout_checks_api_SortOptions"] = None) -> None:
        self._sort = sort
        self._query = query

    @builtins.property
    def sort(self) -> Optional["scout_checks_api_SortOptions"]:
        return self._sort

    @builtins.property
    def query(self) -> "scout_checks_api_ChecklistSearchQuery":
        return self._query


scout_savedviews_api_ChecklistSearchState.__name__ = "ChecklistSearchState"
scout_savedviews_api_ChecklistSearchState.__qualname__ = "ChecklistSearchState"
scout_savedviews_api_ChecklistSearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_ColumnPinningState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'left': ConjureFieldDefinition('left', List[scout_savedviews_api_ColumnId]),
            'right': ConjureFieldDefinition('right', List[scout_savedviews_api_ColumnId])
        }

    __slots__: List[str] = ['_left', '_right']

    def __init__(self, left: List[str], right: List[str]) -> None:
        self._left = left
        self._right = right

    @builtins.property
    def left(self) -> List[str]:
        return self._left

    @builtins.property
    def right(self) -> List[str]:
        return self._right


scout_savedviews_api_ColumnPinningState.__name__ = "ColumnPinningState"
scout_savedviews_api_ColumnPinningState.__qualname__ = "ColumnPinningState"
scout_savedviews_api_ColumnPinningState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_CreateSavedViewRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[scout_api_Symbol]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_api_Color]),
            'search_state': ConjureFieldDefinition('searchState', scout_savedviews_api_SearchState),
            'display_state': ConjureFieldDefinition('displayState', scout_savedviews_api_DisplayState),
            'workspace_rid': ConjureFieldDefinition('workspaceRid', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_title', '_symbol', '_color', '_search_state', '_display_state', '_workspace_rid']

    def __init__(self, display_state: "scout_savedviews_api_DisplayState", search_state: "scout_savedviews_api_SearchState", title: str, color: Optional["scout_api_Color"] = None, symbol: Optional["scout_api_Symbol"] = None, workspace_rid: Optional[str] = None) -> None:
        self._title = title
        self._symbol = symbol
        self._color = color
        self._search_state = search_state
        self._display_state = display_state
        self._workspace_rid = workspace_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def symbol(self) -> Optional["scout_api_Symbol"]:
        return self._symbol

    @builtins.property
    def color(self) -> Optional["scout_api_Color"]:
        return self._color

    @builtins.property
    def search_state(self) -> "scout_savedviews_api_SearchState":
        return self._search_state

    @builtins.property
    def display_state(self) -> "scout_savedviews_api_DisplayState":
        return self._display_state

    @builtins.property
    def workspace_rid(self) -> Optional[str]:
        return self._workspace_rid


scout_savedviews_api_CreateSavedViewRequest.__name__ = "CreateSavedViewRequest"
scout_savedviews_api_CreateSavedViewRequest.__qualname__ = "CreateSavedViewRequest"
scout_savedviews_api_CreateSavedViewRequest.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_CreateSavedViewResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'saved_view': ConjureFieldDefinition('savedView', scout_savedviews_api_SavedView)
        }

    __slots__: List[str] = ['_saved_view']

    def __init__(self, saved_view: "scout_savedviews_api_SavedView") -> None:
        self._saved_view = saved_view

    @builtins.property
    def saved_view(self) -> "scout_savedviews_api_SavedView":
        return self._saved_view


scout_savedviews_api_CreateSavedViewResponse.__name__ = "CreateSavedViewResponse"
scout_savedviews_api_CreateSavedViewResponse.__qualname__ = "CreateSavedViewResponse"
scout_savedviews_api_CreateSavedViewResponse.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_DisplayState(ConjureUnionType):
    _display_state_v1: Optional["scout_savedviews_api_TableState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_state_v1': ConjureFieldDefinition('displayStateV1', scout_savedviews_api_TableState)
        }

    def __init__(
            self,
            display_state_v1: Optional["scout_savedviews_api_TableState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (display_state_v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if display_state_v1 is not None:
                self._display_state_v1 = display_state_v1
                self._type = 'displayStateV1'

        elif type_of_union == 'displayStateV1':
            if display_state_v1 is None:
                raise ValueError('a union value must not be None')
            self._display_state_v1 = display_state_v1
            self._type = 'displayStateV1'

    @builtins.property
    def display_state_v1(self) -> Optional["scout_savedviews_api_TableState"]:
        return self._display_state_v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_DisplayStateVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_DisplayStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'displayStateV1' and self.display_state_v1 is not None:
            return visitor._display_state_v1(self.display_state_v1)


scout_savedviews_api_DisplayState.__name__ = "DisplayState"
scout_savedviews_api_DisplayState.__qualname__ = "DisplayState"
scout_savedviews_api_DisplayState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_DisplayStateVisitor:

    @abstractmethod
    def _display_state_v1(self, display_state_v1: "scout_savedviews_api_TableState") -> Any:
        pass


scout_savedviews_api_DisplayStateVisitor.__name__ = "DisplayStateVisitor"
scout_savedviews_api_DisplayStateVisitor.__qualname__ = "DisplayStateVisitor"
scout_savedviews_api_DisplayStateVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_GetSavedViewResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'saved_view': ConjureFieldDefinition('savedView', scout_savedviews_api_SavedView)
        }

    __slots__: List[str] = ['_saved_view']

    def __init__(self, saved_view: "scout_savedviews_api_SavedView") -> None:
        self._saved_view = saved_view

    @builtins.property
    def saved_view(self) -> "scout_savedviews_api_SavedView":
        return self._saved_view


scout_savedviews_api_GetSavedViewResponse.__name__ = "GetSavedViewResponse"
scout_savedviews_api_GetSavedViewResponse.__qualname__ = "GetSavedViewResponse"
scout_savedviews_api_GetSavedViewResponse.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnAggregation(ConjureEnumType):

    TOTAL_COUNT = 'TOTAL_COUNT'
    '''TOTAL_COUNT'''
    TOTAL_DURATION = 'TOTAL_DURATION'
    '''TOTAL_DURATION'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_savedviews_api_MetricColumnAggregation.__name__ = "MetricColumnAggregation"
scout_savedviews_api_MetricColumnAggregation.__qualname__ = "MetricColumnAggregation"
scout_savedviews_api_MetricColumnAggregation.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnData(ConjureUnionType):
    _event: Optional["event_SearchQuery"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'event': ConjureFieldDefinition('event', event_SearchQuery)
        }

    def __init__(
            self,
            event: Optional["event_SearchQuery"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (event is not None) != 1:
                raise ValueError('a union must contain a single member')

            if event is not None:
                self._event = event
                self._type = 'event'

        elif type_of_union == 'event':
            if event is None:
                raise ValueError('a union value must not be None')
            self._event = event
            self._type = 'event'

    @builtins.property
    def event(self) -> Optional["event_SearchQuery"]:
        return self._event

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_MetricColumnDataVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_MetricColumnDataVisitor'.format(visitor.__class__.__name__))
        if self._type == 'event' and self.event is not None:
            return visitor._event(self.event)


scout_savedviews_api_MetricColumnData.__name__ = "MetricColumnData"
scout_savedviews_api_MetricColumnData.__qualname__ = "MetricColumnData"
scout_savedviews_api_MetricColumnData.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnDataVisitor:

    @abstractmethod
    def _event(self, event: "event_SearchQuery") -> Any:
        pass


scout_savedviews_api_MetricColumnDataVisitor.__name__ = "MetricColumnDataVisitor"
scout_savedviews_api_MetricColumnDataVisitor.__qualname__ = "MetricColumnDataVisitor"
scout_savedviews_api_MetricColumnDataVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[scout_api_Symbol])
        }

    __slots__: List[str] = ['_title', '_description', '_symbol']

    def __init__(self, title: str, description: Optional[str] = None, symbol: Optional["scout_api_Symbol"] = None) -> None:
        self._title = title
        self._description = description
        self._symbol = symbol

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def symbol(self) -> Optional["scout_api_Symbol"]:
        return self._symbol


scout_savedviews_api_MetricColumnMetadata.__name__ = "MetricColumnMetadata"
scout_savedviews_api_MetricColumnMetadata.__qualname__ = "MetricColumnMetadata"
scout_savedviews_api_MetricColumnMetadata.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnStyle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', scout_savedviews_api_MetricColumnThresholdType),
            'value': ConjureFieldDefinition('value', OptionalTypeWrapper[List[scout_savedviews_api_MetricColumnThreshold]])
        }

    __slots__: List[str] = ['_type', '_value']

    def __init__(self, type: "scout_savedviews_api_MetricColumnThresholdType", value: Optional[List["scout_savedviews_api_MetricColumnThreshold"]] = None) -> None:
        self._type = type
        self._value = value

    @builtins.property
    def type(self) -> "scout_savedviews_api_MetricColumnThresholdType":
        return self._type

    @builtins.property
    def value(self) -> Optional[List["scout_savedviews_api_MetricColumnThreshold"]]:
        return self._value


scout_savedviews_api_MetricColumnStyle.__name__ = "MetricColumnStyle"
scout_savedviews_api_MetricColumnStyle.__qualname__ = "MetricColumnStyle"
scout_savedviews_api_MetricColumnStyle.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnThreshold(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', float),
            'color': ConjureFieldDefinition('color', str),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_value', '_color', '_label']

    def __init__(self, color: str, value: float, label: Optional[str] = None) -> None:
        self._value = value
        self._color = color
        self._label = label

    @builtins.property
    def value(self) -> float:
        return self._value

    @builtins.property
    def color(self) -> str:
        return self._color

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label


scout_savedviews_api_MetricColumnThreshold.__name__ = "MetricColumnThreshold"
scout_savedviews_api_MetricColumnThreshold.__qualname__ = "MetricColumnThreshold"
scout_savedviews_api_MetricColumnThreshold.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnThresholdType(ConjureEnumType):

    RAW = 'RAW'
    '''RAW'''
    BAR = 'BAR'
    '''BAR'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_savedviews_api_MetricColumnThresholdType.__name__ = "MetricColumnThresholdType"
scout_savedviews_api_MetricColumnThresholdType.__qualname__ = "MetricColumnThresholdType"
scout_savedviews_api_MetricColumnThresholdType.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumns(ConjureUnionType):
    _asset: Optional["scout_savedviews_api_AssetMetricColumns"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset': ConjureFieldDefinition('asset', scout_savedviews_api_AssetMetricColumns)
        }

    def __init__(
            self,
            asset: Optional["scout_savedviews_api_AssetMetricColumns"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (asset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if asset is not None:
                self._asset = asset
                self._type = 'asset'

        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'

    @builtins.property
    def asset(self) -> Optional["scout_savedviews_api_AssetMetricColumns"]:
        return self._asset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_MetricColumnsVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_MetricColumnsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)


scout_savedviews_api_MetricColumns.__name__ = "MetricColumns"
scout_savedviews_api_MetricColumns.__qualname__ = "MetricColumns"
scout_savedviews_api_MetricColumns.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MetricColumnsVisitor:

    @abstractmethod
    def _asset(self, asset: "scout_savedviews_api_AssetMetricColumns") -> Any:
        pass


scout_savedviews_api_MetricColumnsVisitor.__name__ = "MetricColumnsVisitor"
scout_savedviews_api_MetricColumnsVisitor.__qualname__ = "MetricColumnsVisitor"
scout_savedviews_api_MetricColumnsVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_MostRecentRun(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_savedviews_api_MostRecentRun.__name__ = "MostRecentRun"
scout_savedviews_api_MostRecentRun.__qualname__ = "MostRecentRun"
scout_savedviews_api_MostRecentRun.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_ResourceType(ConjureEnumType):

    ASSET = 'ASSET'
    '''ASSET'''
    RUN = 'RUN'
    '''RUN'''
    WORKBOOK = 'WORKBOOK'
    '''WORKBOOK'''
    CHECKLIST = 'CHECKLIST'
    '''CHECKLIST'''
    TEMPLATE = 'TEMPLATE'
    '''TEMPLATE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_savedviews_api_ResourceType.__name__ = "ResourceType"
scout_savedviews_api_ResourceType.__qualname__ = "ResourceType"
scout_savedviews_api_ResourceType.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_RunSearchState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[scout_run_api_SortOptions]),
            'group_by': ConjureFieldDefinition('groupBy', OptionalTypeWrapper[List[scout_savedviews_api_ColumnId]]),
            'query': ConjureFieldDefinition('query', scout_run_api_SearchQuery)
        }

    __slots__: List[str] = ['_sort', '_group_by', '_query']

    def __init__(self, query: "scout_run_api_SearchQuery", group_by: Optional[List[str]] = None, sort: Optional["scout_run_api_SortOptions"] = None) -> None:
        self._sort = sort
        self._group_by = group_by
        self._query = query

    @builtins.property
    def sort(self) -> Optional["scout_run_api_SortOptions"]:
        return self._sort

    @builtins.property
    def group_by(self) -> Optional[List[str]]:
        return self._group_by

    @builtins.property
    def query(self) -> "scout_run_api_SearchQuery":
        return self._query


scout_savedviews_api_RunSearchState.__name__ = "RunSearchState"
scout_savedviews_api_RunSearchState.__qualname__ = "RunSearchState"
scout_savedviews_api_RunSearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SavedView(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metadata': ConjureFieldDefinition('metadata', scout_savedviews_api_SavedViewMetadata),
            'search_state': ConjureFieldDefinition('searchState', scout_savedviews_api_SearchState),
            'display_state': ConjureFieldDefinition('displayState', scout_savedviews_api_DisplayState)
        }

    __slots__: List[str] = ['_metadata', '_search_state', '_display_state']

    def __init__(self, display_state: "scout_savedviews_api_DisplayState", metadata: "scout_savedviews_api_SavedViewMetadata", search_state: "scout_savedviews_api_SearchState") -> None:
        self._metadata = metadata
        self._search_state = search_state
        self._display_state = display_state

    @builtins.property
    def metadata(self) -> "scout_savedviews_api_SavedViewMetadata":
        return self._metadata

    @builtins.property
    def search_state(self) -> "scout_savedviews_api_SearchState":
        return self._search_state

    @builtins.property
    def display_state(self) -> "scout_savedviews_api_DisplayState":
        return self._display_state


scout_savedviews_api_SavedView.__name__ = "SavedView"
scout_savedviews_api_SavedView.__qualname__ = "SavedView"
scout_savedviews_api_SavedView.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SavedViewMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_SavedViewRid),
            'resource_type': ConjureFieldDefinition('resourceType', scout_savedviews_api_ResourceType),
            'title': ConjureFieldDefinition('title', str),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[scout_api_Symbol]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_api_Color]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'updated_at': ConjureFieldDefinition('updatedAt', str)
        }

    __slots__: List[str] = ['_rid', '_resource_type', '_title', '_symbol', '_color', '_is_archived', '_created_at', '_created_by', '_updated_at']

    def __init__(self, created_at: str, created_by: str, is_archived: bool, resource_type: "scout_savedviews_api_ResourceType", rid: str, title: str, updated_at: str, color: Optional["scout_api_Color"] = None, symbol: Optional["scout_api_Symbol"] = None) -> None:
        self._rid = rid
        self._resource_type = resource_type
        self._title = title
        self._symbol = symbol
        self._color = color
        self._is_archived = is_archived
        self._created_at = created_at
        self._created_by = created_by
        self._updated_at = updated_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def resource_type(self) -> "scout_savedviews_api_ResourceType":
        return self._resource_type

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def symbol(self) -> Optional["scout_api_Symbol"]:
        return self._symbol

    @builtins.property
    def color(self) -> Optional["scout_api_Color"]:
        return self._color

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at


scout_savedviews_api_SavedViewMetadata.__name__ = "SavedViewMetadata"
scout_savedviews_api_SavedViewMetadata.__qualname__ = "SavedViewMetadata"
scout_savedviews_api_SavedViewMetadata.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SavedViewSortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'sort_key': ConjureFieldDefinition('sortKey', scout_savedviews_api_SortKey)
        }

    __slots__: List[str] = ['_is_descending', '_sort_key']

    def __init__(self, is_descending: bool, sort_key: "scout_savedviews_api_SortKey") -> None:
        self._is_descending = is_descending
        self._sort_key = sort_key

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def sort_key(self) -> "scout_savedviews_api_SortKey":
        """Field to sort by.
        """
        return self._sort_key


scout_savedviews_api_SavedViewSortOptions.__name__ = "SavedViewSortOptions"
scout_savedviews_api_SavedViewSortOptions.__qualname__ = "SavedViewSortOptions"
scout_savedviews_api_SavedViewSortOptions.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchSavedViewsQuery(ConjureUnionType):
    _and_: Optional["scout_savedviews_api_SearchSavedViewsQueryList"] = None
    _or_: Optional["scout_savedviews_api_SearchSavedViewsQueryList"] = None
    _not_: Optional["scout_savedviews_api_SearchSavedViewsQuery"] = None
    _title_exact_substring_search: Optional[str] = None
    _resource_type: Optional["scout_savedviews_api_ResourceType"] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', scout_savedviews_api_SearchSavedViewsQueryList),
            'or_': ConjureFieldDefinition('or', scout_savedviews_api_SearchSavedViewsQueryList),
            'not_': ConjureFieldDefinition('not', scout_savedviews_api_SearchSavedViewsQuery),
            'title_exact_substring_search': ConjureFieldDefinition('titleExactSubstringSearch', str),
            'resource_type': ConjureFieldDefinition('resourceType', scout_savedviews_api_ResourceType),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            and_: Optional["scout_savedviews_api_SearchSavedViewsQueryList"] = None,
            or_: Optional["scout_savedviews_api_SearchSavedViewsQueryList"] = None,
            not_: Optional["scout_savedviews_api_SearchSavedViewsQuery"] = None,
            title_exact_substring_search: Optional[str] = None,
            resource_type: Optional["scout_savedviews_api_ResourceType"] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (not_ is not None) + (title_exact_substring_search is not None) + (resource_type is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if title_exact_substring_search is not None:
                self._title_exact_substring_search = title_exact_substring_search
                self._type = 'titleExactSubstringSearch'
            if resource_type is not None:
                self._resource_type = resource_type
                self._type = 'resourceType'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'titleExactSubstringSearch':
            if title_exact_substring_search is None:
                raise ValueError('a union value must not be None')
            self._title_exact_substring_search = title_exact_substring_search
            self._type = 'titleExactSubstringSearch'
        elif type_of_union == 'resourceType':
            if resource_type is None:
                raise ValueError('a union value must not be None')
            self._resource_type = resource_type
            self._type = 'resourceType'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def and_(self) -> Optional["scout_savedviews_api_SearchSavedViewsQueryList"]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional["scout_savedviews_api_SearchSavedViewsQueryList"]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_savedviews_api_SearchSavedViewsQuery"]:
        return self._not_

    @builtins.property
    def title_exact_substring_search(self) -> Optional[str]:
        return self._title_exact_substring_search

    @builtins.property
    def resource_type(self) -> Optional["scout_savedviews_api_ResourceType"]:
        return self._resource_type

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_SearchSavedViewsQueryVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_SearchSavedViewsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'titleExactSubstringSearch' and self.title_exact_substring_search is not None:
            return visitor._title_exact_substring_search(self.title_exact_substring_search)
        if self._type == 'resourceType' and self.resource_type is not None:
            return visitor._resource_type(self.resource_type)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


scout_savedviews_api_SearchSavedViewsQuery.__name__ = "SearchSavedViewsQuery"
scout_savedviews_api_SearchSavedViewsQuery.__qualname__ = "SearchSavedViewsQuery"
scout_savedviews_api_SearchSavedViewsQuery.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchSavedViewsQueryVisitor:

    @abstractmethod
    def _and(self, and_: "scout_savedviews_api_SearchSavedViewsQueryList") -> Any:
        pass

    @abstractmethod
    def _or(self, or_: "scout_savedviews_api_SearchSavedViewsQueryList") -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_savedviews_api_SearchSavedViewsQuery") -> Any:
        pass

    @abstractmethod
    def _title_exact_substring_search(self, title_exact_substring_search: str) -> Any:
        pass

    @abstractmethod
    def _resource_type(self, resource_type: "scout_savedviews_api_ResourceType") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


scout_savedviews_api_SearchSavedViewsQueryVisitor.__name__ = "SearchSavedViewsQueryVisitor"
scout_savedviews_api_SearchSavedViewsQueryVisitor.__qualname__ = "SearchSavedViewsQueryVisitor"
scout_savedviews_api_SearchSavedViewsQueryVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchSavedViewsQueryList(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'queries': ConjureFieldDefinition('queries', List[scout_savedviews_api_SearchSavedViewsQuery])
        }

    __slots__: List[str] = ['_queries']

    def __init__(self, queries: List["scout_savedviews_api_SearchSavedViewsQuery"]) -> None:
        self._queries = queries

    @builtins.property
    def queries(self) -> List["scout_savedviews_api_SearchSavedViewsQuery"]:
        return self._queries


scout_savedviews_api_SearchSavedViewsQueryList.__name__ = "SearchSavedViewsQueryList"
scout_savedviews_api_SearchSavedViewsQueryList.__qualname__ = "SearchSavedViewsQueryList"
scout_savedviews_api_SearchSavedViewsQueryList.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchSavedViewsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', scout_savedviews_api_SavedViewSortOptions),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'query': ConjureFieldDefinition('query', scout_savedviews_api_SearchSavedViewsQuery),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_sort', '_page_size', '_next_page_token', '_query', '_archived_statuses']

    def __init__(self, query: "scout_savedviews_api_SearchSavedViewsQuery", sort: "scout_savedviews_api_SavedViewSortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, next_page_token: Optional[str] = None, page_size: Optional[int] = None) -> None:
        self._sort = sort
        self._page_size = page_size
        self._next_page_token = next_page_token
        self._query = query
        self._archived_statuses = archived_statuses

    @builtins.property
    def sort(self) -> "scout_savedviews_api_SavedViewSortOptions":
        return self._sort

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def query(self) -> "scout_savedviews_api_SearchSavedViewsQuery":
        return self._query

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived assets in search.
        """
        return self._archived_statuses


scout_savedviews_api_SearchSavedViewsRequest.__name__ = "SearchSavedViewsRequest"
scout_savedviews_api_SearchSavedViewsRequest.__qualname__ = "SearchSavedViewsRequest"
scout_savedviews_api_SearchSavedViewsRequest.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchSavedViewsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'saved_views': ConjureFieldDefinition('savedViews', List[scout_savedviews_api_SavedViewMetadata]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_saved_views', '_next_page_token']

    def __init__(self, saved_views: List["scout_savedviews_api_SavedViewMetadata"], next_page_token: Optional[str] = None) -> None:
        self._saved_views = saved_views
        self._next_page_token = next_page_token

    @builtins.property
    def saved_views(self) -> List["scout_savedviews_api_SavedViewMetadata"]:
        return self._saved_views

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_savedviews_api_SearchSavedViewsResponse.__name__ = "SearchSavedViewsResponse"
scout_savedviews_api_SearchSavedViewsResponse.__qualname__ = "SearchSavedViewsResponse"
scout_savedviews_api_SearchSavedViewsResponse.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchState(ConjureUnionType):
    _asset: Optional["scout_savedviews_api_AssetSearchState"] = None
    _run: Optional["scout_savedviews_api_RunSearchState"] = None
    _checklist: Optional["scout_savedviews_api_ChecklistSearchState"] = None
    _workbook: Optional["scout_savedviews_api_WorkbookSearchState"] = None
    _template: Optional["scout_savedviews_api_TemplateSearchState"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset': ConjureFieldDefinition('asset', scout_savedviews_api_AssetSearchState),
            'run': ConjureFieldDefinition('run', scout_savedviews_api_RunSearchState),
            'checklist': ConjureFieldDefinition('checklist', scout_savedviews_api_ChecklistSearchState),
            'workbook': ConjureFieldDefinition('workbook', scout_savedviews_api_WorkbookSearchState),
            'template': ConjureFieldDefinition('template', scout_savedviews_api_TemplateSearchState)
        }

    def __init__(
            self,
            asset: Optional["scout_savedviews_api_AssetSearchState"] = None,
            run: Optional["scout_savedviews_api_RunSearchState"] = None,
            checklist: Optional["scout_savedviews_api_ChecklistSearchState"] = None,
            workbook: Optional["scout_savedviews_api_WorkbookSearchState"] = None,
            template: Optional["scout_savedviews_api_TemplateSearchState"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (asset is not None) + (run is not None) + (checklist is not None) + (workbook is not None) + (template is not None) != 1:
                raise ValueError('a union must contain a single member')

            if asset is not None:
                self._asset = asset
                self._type = 'asset'
            if run is not None:
                self._run = run
                self._type = 'run'
            if checklist is not None:
                self._checklist = checklist
                self._type = 'checklist'
            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if template is not None:
                self._template = template
                self._type = 'template'

        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'
        elif type_of_union == 'run':
            if run is None:
                raise ValueError('a union value must not be None')
            self._run = run
            self._type = 'run'
        elif type_of_union == 'checklist':
            if checklist is None:
                raise ValueError('a union value must not be None')
            self._checklist = checklist
            self._type = 'checklist'
        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'template':
            if template is None:
                raise ValueError('a union value must not be None')
            self._template = template
            self._type = 'template'

    @builtins.property
    def asset(self) -> Optional["scout_savedviews_api_AssetSearchState"]:
        return self._asset

    @builtins.property
    def run(self) -> Optional["scout_savedviews_api_RunSearchState"]:
        return self._run

    @builtins.property
    def checklist(self) -> Optional["scout_savedviews_api_ChecklistSearchState"]:
        return self._checklist

    @builtins.property
    def workbook(self) -> Optional["scout_savedviews_api_WorkbookSearchState"]:
        return self._workbook

    @builtins.property
    def template(self) -> Optional["scout_savedviews_api_TemplateSearchState"]:
        return self._template

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_SearchStateVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_SearchStateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)
        if self._type == 'run' and self.run is not None:
            return visitor._run(self.run)
        if self._type == 'checklist' and self.checklist is not None:
            return visitor._checklist(self.checklist)
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'template' and self.template is not None:
            return visitor._template(self.template)


scout_savedviews_api_SearchState.__name__ = "SearchState"
scout_savedviews_api_SearchState.__qualname__ = "SearchState"
scout_savedviews_api_SearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SearchStateVisitor:

    @abstractmethod
    def _asset(self, asset: "scout_savedviews_api_AssetSearchState") -> Any:
        pass

    @abstractmethod
    def _run(self, run: "scout_savedviews_api_RunSearchState") -> Any:
        pass

    @abstractmethod
    def _checklist(self, checklist: "scout_savedviews_api_ChecklistSearchState") -> Any:
        pass

    @abstractmethod
    def _workbook(self, workbook: "scout_savedviews_api_WorkbookSearchState") -> Any:
        pass

    @abstractmethod
    def _template(self, template: "scout_savedviews_api_TemplateSearchState") -> Any:
        pass


scout_savedviews_api_SearchStateVisitor.__name__ = "SearchStateVisitor"
scout_savedviews_api_SearchStateVisitor.__qualname__ = "SearchStateVisitor"
scout_savedviews_api_SearchStateVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SortField(ConjureEnumType):

    TITLE = 'TITLE'
    '''TITLE'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    USER_DEFINED = 'USER_DEFINED'
    '''USER_DEFINED'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_savedviews_api_SortField.__name__ = "SortField"
scout_savedviews_api_SortField.__qualname__ = "SortField"
scout_savedviews_api_SortField.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SortKey(ConjureUnionType):
    _field: Optional["scout_savedviews_api_SortField"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field': ConjureFieldDefinition('field', scout_savedviews_api_SortField)
        }

    def __init__(
            self,
            field: Optional["scout_savedviews_api_SortField"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (field is not None) != 1:
                raise ValueError('a union must contain a single member')

            if field is not None:
                self._field = field
                self._type = 'field'

        elif type_of_union == 'field':
            if field is None:
                raise ValueError('a union value must not be None')
            self._field = field
            self._type = 'field'

    @builtins.property
    def field(self) -> Optional["scout_savedviews_api_SortField"]:
        return self._field

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_SortKeyVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_SortKeyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'field' and self.field is not None:
            return visitor._field(self.field)


scout_savedviews_api_SortKey.__name__ = "SortKey"
scout_savedviews_api_SortKey.__qualname__ = "SortKey"
scout_savedviews_api_SortKey.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_SortKeyVisitor:

    @abstractmethod
    def _field(self, field: "scout_savedviews_api_SortField") -> Any:
        pass


scout_savedviews_api_SortKeyVisitor.__name__ = "SortKeyVisitor"
scout_savedviews_api_SortKeyVisitor.__qualname__ = "SortKeyVisitor"
scout_savedviews_api_SortKeyVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_TableState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'column_visibility': ConjureFieldDefinition('columnVisibility', OptionalTypeWrapper[Dict[scout_savedviews_api_ColumnId, bool]]),
            'column_sizing': ConjureFieldDefinition('columnSizing', OptionalTypeWrapper[Dict[scout_savedviews_api_ColumnId, int]]),
            'column_order': ConjureFieldDefinition('columnOrder', OptionalTypeWrapper[List[scout_savedviews_api_ColumnId]]),
            'column_pinning': ConjureFieldDefinition('columnPinning', OptionalTypeWrapper[scout_savedviews_api_ColumnPinningState]),
            'metric_columns': ConjureFieldDefinition('metricColumns', OptionalTypeWrapper[scout_savedviews_api_MetricColumns])
        }

    __slots__: List[str] = ['_column_visibility', '_column_sizing', '_column_order', '_column_pinning', '_metric_columns']

    def __init__(self, column_order: Optional[List[str]] = None, column_pinning: Optional["scout_savedviews_api_ColumnPinningState"] = None, column_sizing: Optional[Dict[str, int]] = None, column_visibility: Optional[Dict[str, bool]] = None, metric_columns: Optional["scout_savedviews_api_MetricColumns"] = None) -> None:
        self._column_visibility = column_visibility
        self._column_sizing = column_sizing
        self._column_order = column_order
        self._column_pinning = column_pinning
        self._metric_columns = metric_columns

    @builtins.property
    def column_visibility(self) -> Optional[Dict[str, bool]]:
        return self._column_visibility

    @builtins.property
    def column_sizing(self) -> Optional[Dict[str, int]]:
        return self._column_sizing

    @builtins.property
    def column_order(self) -> Optional[List[str]]:
        return self._column_order

    @builtins.property
    def column_pinning(self) -> Optional["scout_savedviews_api_ColumnPinningState"]:
        return self._column_pinning

    @builtins.property
    def metric_columns(self) -> Optional["scout_savedviews_api_MetricColumns"]:
        return self._metric_columns


scout_savedviews_api_TableState.__name__ = "TableState"
scout_savedviews_api_TableState.__qualname__ = "TableState"
scout_savedviews_api_TableState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_TemplateSearchState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[scout_template_api_SortBy]),
            'query': ConjureFieldDefinition('query', scout_template_api_SearchTemplatesQuery)
        }

    __slots__: List[str] = ['_sort', '_query']

    def __init__(self, query: "scout_template_api_SearchTemplatesQuery", sort: Optional["scout_template_api_SortBy"] = None) -> None:
        self._sort = sort
        self._query = query

    @builtins.property
    def sort(self) -> Optional["scout_template_api_SortBy"]:
        """Sort for templates view. Uses BE-supplied default if empty.
        """
        return self._sort

    @builtins.property
    def query(self) -> "scout_template_api_SearchTemplatesQuery":
        return self._query


scout_savedviews_api_TemplateSearchState.__name__ = "TemplateSearchState"
scout_savedviews_api_TemplateSearchState.__qualname__ = "TemplateSearchState"
scout_savedviews_api_TemplateSearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateColor(ConjureUnionType):
    _color: Optional["scout_api_Color"] = None
    _clear_color: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'color': ConjureFieldDefinition('color', scout_api_Color),
            'clear_color': ConjureFieldDefinition('clearColor', api_Empty)
        }

    def __init__(
            self,
            color: Optional["scout_api_Color"] = None,
            clear_color: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (color is not None) + (clear_color is not None) != 1:
                raise ValueError('a union must contain a single member')

            if color is not None:
                self._color = color
                self._type = 'color'
            if clear_color is not None:
                self._clear_color = clear_color
                self._type = 'clearColor'

        elif type_of_union == 'color':
            if color is None:
                raise ValueError('a union value must not be None')
            self._color = color
            self._type = 'color'
        elif type_of_union == 'clearColor':
            if clear_color is None:
                raise ValueError('a union value must not be None')
            self._clear_color = clear_color
            self._type = 'clearColor'

    @builtins.property
    def color(self) -> Optional["scout_api_Color"]:
        return self._color

    @builtins.property
    def clear_color(self) -> Optional["api_Empty"]:
        return self._clear_color

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_UpdateColorVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_UpdateColorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'color' and self.color is not None:
            return visitor._color(self.color)
        if self._type == 'clearColor' and self.clear_color is not None:
            return visitor._clear_color(self.clear_color)


scout_savedviews_api_UpdateColor.__name__ = "UpdateColor"
scout_savedviews_api_UpdateColor.__qualname__ = "UpdateColor"
scout_savedviews_api_UpdateColor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateColorVisitor:

    @abstractmethod
    def _color(self, color: "scout_api_Color") -> Any:
        pass

    @abstractmethod
    def _clear_color(self, clear_color: "api_Empty") -> Any:
        pass


scout_savedviews_api_UpdateColorVisitor.__name__ = "UpdateColorVisitor"
scout_savedviews_api_UpdateColorVisitor.__qualname__ = "UpdateColorVisitor"
scout_savedviews_api_UpdateColorVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateSavedViewRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[scout_savedviews_api_UpdateSymbol]),
            'color': ConjureFieldDefinition('color', OptionalTypeWrapper[scout_savedviews_api_UpdateColor]),
            'search_state': ConjureFieldDefinition('searchState', OptionalTypeWrapper[scout_savedviews_api_SearchState]),
            'display_state': ConjureFieldDefinition('displayState', OptionalTypeWrapper[scout_savedviews_api_DisplayState]),
            'index': ConjureFieldDefinition('index', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_title', '_symbol', '_color', '_search_state', '_display_state', '_index']

    def __init__(self, color: Optional["scout_savedviews_api_UpdateColor"] = None, display_state: Optional["scout_savedviews_api_DisplayState"] = None, index: Optional[int] = None, search_state: Optional["scout_savedviews_api_SearchState"] = None, symbol: Optional["scout_savedviews_api_UpdateSymbol"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._symbol = symbol
        self._color = color
        self._search_state = search_state
        self._display_state = display_state
        self._index = index

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def symbol(self) -> Optional["scout_savedviews_api_UpdateSymbol"]:
        return self._symbol

    @builtins.property
    def color(self) -> Optional["scout_savedviews_api_UpdateColor"]:
        return self._color

    @builtins.property
    def search_state(self) -> Optional["scout_savedviews_api_SearchState"]:
        return self._search_state

    @builtins.property
    def display_state(self) -> Optional["scout_savedviews_api_DisplayState"]:
        return self._display_state

    @builtins.property
    def index(self) -> Optional[int]:
        return self._index


scout_savedviews_api_UpdateSavedViewRequest.__name__ = "UpdateSavedViewRequest"
scout_savedviews_api_UpdateSavedViewRequest.__qualname__ = "UpdateSavedViewRequest"
scout_savedviews_api_UpdateSavedViewRequest.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateSavedViewResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'saved_view': ConjureFieldDefinition('savedView', scout_savedviews_api_SavedView)
        }

    __slots__: List[str] = ['_saved_view']

    def __init__(self, saved_view: "scout_savedviews_api_SavedView") -> None:
        self._saved_view = saved_view

    @builtins.property
    def saved_view(self) -> "scout_savedviews_api_SavedView":
        return self._saved_view


scout_savedviews_api_UpdateSavedViewResponse.__name__ = "UpdateSavedViewResponse"
scout_savedviews_api_UpdateSavedViewResponse.__qualname__ = "UpdateSavedViewResponse"
scout_savedviews_api_UpdateSavedViewResponse.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateSymbol(ConjureUnionType):
    _symbol: Optional["scout_api_Symbol"] = None
    _clear_symbol: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'symbol': ConjureFieldDefinition('symbol', scout_api_Symbol),
            'clear_symbol': ConjureFieldDefinition('clearSymbol', api_Empty)
        }

    def __init__(
            self,
            symbol: Optional["scout_api_Symbol"] = None,
            clear_symbol: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (symbol is not None) + (clear_symbol is not None) != 1:
                raise ValueError('a union must contain a single member')

            if symbol is not None:
                self._symbol = symbol
                self._type = 'symbol'
            if clear_symbol is not None:
                self._clear_symbol = clear_symbol
                self._type = 'clearSymbol'

        elif type_of_union == 'symbol':
            if symbol is None:
                raise ValueError('a union value must not be None')
            self._symbol = symbol
            self._type = 'symbol'
        elif type_of_union == 'clearSymbol':
            if clear_symbol is None:
                raise ValueError('a union value must not be None')
            self._clear_symbol = clear_symbol
            self._type = 'clearSymbol'

    @builtins.property
    def symbol(self) -> Optional["scout_api_Symbol"]:
        return self._symbol

    @builtins.property
    def clear_symbol(self) -> Optional["api_Empty"]:
        return self._clear_symbol

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_savedviews_api_UpdateSymbolVisitor):
            raise ValueError('{} is not an instance of scout_savedviews_api_UpdateSymbolVisitor'.format(visitor.__class__.__name__))
        if self._type == 'symbol' and self.symbol is not None:
            return visitor._symbol(self.symbol)
        if self._type == 'clearSymbol' and self.clear_symbol is not None:
            return visitor._clear_symbol(self.clear_symbol)


scout_savedviews_api_UpdateSymbol.__name__ = "UpdateSymbol"
scout_savedviews_api_UpdateSymbol.__qualname__ = "UpdateSymbol"
scout_savedviews_api_UpdateSymbol.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_UpdateSymbolVisitor:

    @abstractmethod
    def _symbol(self, symbol: "scout_api_Symbol") -> Any:
        pass

    @abstractmethod
    def _clear_symbol(self, clear_symbol: "api_Empty") -> Any:
        pass


scout_savedviews_api_UpdateSymbolVisitor.__name__ = "UpdateSymbolVisitor"
scout_savedviews_api_UpdateSymbolVisitor.__qualname__ = "UpdateSymbolVisitor"
scout_savedviews_api_UpdateSymbolVisitor.__module__ = "nominal_api.scout_savedviews_api"


class scout_savedviews_api_WorkbookSearchState(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'sort': ConjureFieldDefinition('sort', OptionalTypeWrapper[scout_notebook_api_SortBy]),
            'query': ConjureFieldDefinition('query', scout_notebook_api_SearchNotebooksQuery)
        }

    __slots__: List[str] = ['_sort', '_query']

    def __init__(self, query: "scout_notebook_api_SearchNotebooksQuery", sort: Optional["scout_notebook_api_SortBy"] = None) -> None:
        self._sort = sort
        self._query = query

    @builtins.property
    def sort(self) -> Optional["scout_notebook_api_SortBy"]:
        return self._sort

    @builtins.property
    def query(self) -> "scout_notebook_api_SearchNotebooksQuery":
        return self._query


scout_savedviews_api_WorkbookSearchState.__name__ = "WorkbookSearchState"
scout_savedviews_api_WorkbookSearchState.__qualname__ = "WorkbookSearchState"
scout_savedviews_api_WorkbookSearchState.__module__ = "nominal_api.scout_savedviews_api"


class scout_template_api_CommitTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_rids_api_VersionedVizId]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_charts', '_layout', '_content', '_message', '_latest_commit']

    def __init__(self, content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", message: str, charts: Optional[List["scout_rids_api_VersionedVizId"]] = None, latest_commit: Optional[str] = None) -> None:
        self._charts = charts
        self._layout = layout
        self._content = content
        self._message = message
        self._latest_commit = latest_commit

    @builtins.property
    def charts(self) -> Optional[List["scout_rids_api_VersionedVizId"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_template_api_CommitTemplateRequest.__name__ = "CommitTemplateRequest"
scout_template_api_CommitTemplateRequest.__qualname__ = "CommitTemplateRequest"
scout_template_api_CommitTemplateRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_CreateTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool]),
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_rids_api_VersionedVizId]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'message': ConjureFieldDefinition('message', str),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_published', '_charts', '_layout', '_content', '_message', '_workspace']

    def __init__(self, content: "scout_workbookcommon_api_WorkbookContent", description: str, labels: List[str], layout: "scout_layout_api_WorkbookLayout", message: str, properties: Dict[str, str], title: str, charts: Optional[List["scout_rids_api_VersionedVizId"]] = None, is_published: Optional[bool] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_published = is_published
        self._charts = charts
        self._layout = layout
        self._content = content
        self._message = message
        self._workspace = workspace

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def is_published(self) -> Optional[bool]:
        """Default is true
        """
        return self._is_published

    @builtins.property
    def charts(self) -> Optional[List["scout_rids_api_VersionedVizId"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the template. If not provided, the template will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


scout_template_api_CreateTemplateRequest.__name__ = "CreateTemplateRequest"
scout_template_api_CreateTemplateRequest.__qualname__ = "CreateTemplateRequest"
scout_template_api_CreateTemplateRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_GetAllLabelsAndPropertiesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, List[api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', List[api_Label])
        }

    __slots__: List[str] = ['_properties', '_labels']

    def __init__(self, labels: List[str], properties: Dict[str, List[str]]) -> None:
        self._properties = properties
        self._labels = labels

    @builtins.property
    def properties(self) -> Dict[str, List[str]]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels


scout_template_api_GetAllLabelsAndPropertiesResponse.__name__ = "GetAllLabelsAndPropertiesResponse"
scout_template_api_GetAllLabelsAndPropertiesResponse.__qualname__ = "GetAllLabelsAndPropertiesResponse"
scout_template_api_GetAllLabelsAndPropertiesResponse.__module__ = "nominal_api.scout_template_api"


class scout_template_api_MergeToMainRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit_on_main': ConjureFieldDefinition('latestCommitOnMain', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_branch_name', '_message', '_latest_commit_on_main']

    def __init__(self, branch_name: str, message: str, latest_commit_on_main: Optional[str] = None) -> None:
        self._branch_name = branch_name
        self._message = message
        self._latest_commit_on_main = latest_commit_on_main

    @builtins.property
    def branch_name(self) -> str:
        """If "main", the request will throw.
        """
        return self._branch_name

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit_on_main(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit_on_main


scout_template_api_MergeToMainRequest.__name__ = "MergeToMainRequest"
scout_template_api_MergeToMainRequest.__qualname__ = "MergeToMainRequest"
scout_template_api_MergeToMainRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SaveTemplateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'charts': ConjureFieldDefinition('charts', OptionalTypeWrapper[List[scout_rids_api_VersionedVizId]]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_charts', '_layout', '_content', '_latest_commit']

    def __init__(self, content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", charts: Optional[List["scout_rids_api_VersionedVizId"]] = None, latest_commit: Optional[str] = None) -> None:
        self._charts = charts
        self._layout = layout
        self._content = content
        self._latest_commit = latest_commit

    @builtins.property
    def charts(self) -> Optional[List["scout_rids_api_VersionedVizId"]]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_template_api_SaveTemplateRequest.__name__ = "SaveTemplateRequest"
scout_template_api_SaveTemplateRequest.__qualname__ = "SaveTemplateRequest"
scout_template_api_SaveTemplateRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SearchTemplatesQuery(ConjureUnionType):
    _and_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None
    _or_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None
    _not_: Optional["scout_template_api_SearchTemplatesQuery"] = None
    _exact_match: Optional[str] = None
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _labels: Optional["scout_rids_api_LabelsFilter"] = None
    _property: Optional["api_Property"] = None
    _properties: Optional["scout_rids_api_PropertiesFilter"] = None
    _created_by: Optional[str] = None
    _is_archived: Optional[bool] = None
    _is_published: Optional[bool] = None
    _workspace: Optional[str] = None
    _author_is_current_user: Optional[bool] = None
    _author_rids: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'and_': ConjureFieldDefinition('and', List[scout_template_api_SearchTemplatesQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_template_api_SearchTemplatesQuery]),
            'not_': ConjureFieldDefinition('not', scout_template_api_SearchTemplatesQuery),
            'exact_match': ConjureFieldDefinition('exactMatch', str),
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'labels': ConjureFieldDefinition('labels', scout_rids_api_LabelsFilter),
            'property': ConjureFieldDefinition('property', api_Property),
            'properties': ConjureFieldDefinition('properties', scout_rids_api_PropertiesFilter),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid),
            'author_is_current_user': ConjureFieldDefinition('authorIsCurrentUser', bool),
            'author_rids': ConjureFieldDefinition('authorRids', List[scout_rids_api_UserRid])
        }

    def __init__(
            self,
            and_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None,
            or_: Optional[List["scout_template_api_SearchTemplatesQuery"]] = None,
            not_: Optional["scout_template_api_SearchTemplatesQuery"] = None,
            exact_match: Optional[str] = None,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            labels: Optional["scout_rids_api_LabelsFilter"] = None,
            property: Optional["api_Property"] = None,
            properties: Optional["scout_rids_api_PropertiesFilter"] = None,
            created_by: Optional[str] = None,
            is_archived: Optional[bool] = None,
            is_published: Optional[bool] = None,
            workspace: Optional[str] = None,
            author_is_current_user: Optional[bool] = None,
            author_rids: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (and_ is not None) + (or_ is not None) + (not_ is not None) + (exact_match is not None) + (search_text is not None) + (label is not None) + (labels is not None) + (property is not None) + (properties is not None) + (created_by is not None) + (is_archived is not None) + (is_published is not None) + (workspace is not None) + (author_is_current_user is not None) + (author_rids is not None) != 1:
                raise ValueError('a union must contain a single member')

            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if not_ is not None:
                self._not_ = not_
                self._type = 'not'
            if exact_match is not None:
                self._exact_match = exact_match
                self._type = 'exactMatch'
            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if labels is not None:
                self._labels = labels
                self._type = 'labels'
            if property is not None:
                self._property = property
                self._type = 'property'
            if properties is not None:
                self._properties = properties
                self._type = 'properties'
            if created_by is not None:
                self._created_by = created_by
                self._type = 'createdBy'
            if is_archived is not None:
                self._is_archived = is_archived
                self._type = 'isArchived'
            if is_published is not None:
                self._is_published = is_published
                self._type = 'isPublished'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'
            if author_is_current_user is not None:
                self._author_is_current_user = author_is_current_user
                self._type = 'authorIsCurrentUser'
            if author_rids is not None:
                self._author_rids = author_rids
                self._type = 'authorRids'

        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'not':
            if not_ is None:
                raise ValueError('a union value must not be None')
            self._not_ = not_
            self._type = 'not'
        elif type_of_union == 'exactMatch':
            if exact_match is None:
                raise ValueError('a union value must not be None')
            self._exact_match = exact_match
            self._type = 'exactMatch'
        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'labels':
            if labels is None:
                raise ValueError('a union value must not be None')
            self._labels = labels
            self._type = 'labels'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'properties':
            if properties is None:
                raise ValueError('a union value must not be None')
            self._properties = properties
            self._type = 'properties'
        elif type_of_union == 'createdBy':
            if created_by is None:
                raise ValueError('a union value must not be None')
            self._created_by = created_by
            self._type = 'createdBy'
        elif type_of_union == 'isArchived':
            if is_archived is None:
                raise ValueError('a union value must not be None')
            self._is_archived = is_archived
            self._type = 'isArchived'
        elif type_of_union == 'isPublished':
            if is_published is None:
                raise ValueError('a union value must not be None')
            self._is_published = is_published
            self._type = 'isPublished'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'
        elif type_of_union == 'authorIsCurrentUser':
            if author_is_current_user is None:
                raise ValueError('a union value must not be None')
            self._author_is_current_user = author_is_current_user
            self._type = 'authorIsCurrentUser'
        elif type_of_union == 'authorRids':
            if author_rids is None:
                raise ValueError('a union value must not be None')
            self._author_rids = author_rids
            self._type = 'authorRids'

    @builtins.property
    def and_(self) -> Optional[List["scout_template_api_SearchTemplatesQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_template_api_SearchTemplatesQuery"]]:
        return self._or_

    @builtins.property
    def not_(self) -> Optional["scout_template_api_SearchTemplatesQuery"]:
        return self._not_

    @builtins.property
    def exact_match(self) -> Optional[str]:
        """Performs case insensitive exact match search on the title.
        """
        return self._exact_match

    @builtins.property
    def search_text(self) -> Optional[str]:
        """Searches title and description only
        """
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def labels(self) -> Optional["scout_rids_api_LabelsFilter"]:
        return self._labels

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def properties(self) -> Optional["scout_rids_api_PropertiesFilter"]:
        return self._properties

    @builtins.property
    def created_by(self) -> Optional[str]:
        return self._created_by

    @builtins.property
    def is_archived(self) -> Optional[bool]:
        return self._is_archived

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    @builtins.property
    def author_is_current_user(self) -> Optional[bool]:
        return self._author_is_current_user

    @builtins.property
    def author_rids(self) -> Optional[List[str]]:
        return self._author_rids

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_template_api_SearchTemplatesQueryVisitor):
            raise ValueError('{} is not an instance of scout_template_api_SearchTemplatesQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'not' and self.not_ is not None:
            return visitor._not(self.not_)
        if self._type == 'exactMatch' and self.exact_match is not None:
            return visitor._exact_match(self.exact_match)
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'labels' and self.labels is not None:
            return visitor._labels(self.labels)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'properties' and self.properties is not None:
            return visitor._properties(self.properties)
        if self._type == 'createdBy' and self.created_by is not None:
            return visitor._created_by(self.created_by)
        if self._type == 'isArchived' and self.is_archived is not None:
            return visitor._is_archived(self.is_archived)
        if self._type == 'isPublished' and self.is_published is not None:
            return visitor._is_published(self.is_published)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)
        if self._type == 'authorIsCurrentUser' and self.author_is_current_user is not None:
            return visitor._author_is_current_user(self.author_is_current_user)
        if self._type == 'authorRids' and self.author_rids is not None:
            return visitor._author_rids(self.author_rids)


scout_template_api_SearchTemplatesQuery.__name__ = "SearchTemplatesQuery"
scout_template_api_SearchTemplatesQuery.__qualname__ = "SearchTemplatesQuery"
scout_template_api_SearchTemplatesQuery.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SearchTemplatesQueryVisitor:

    @abstractmethod
    def _and(self, and_: List["scout_template_api_SearchTemplatesQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_template_api_SearchTemplatesQuery"]) -> Any:
        pass

    @abstractmethod
    def _not(self, not_: "scout_template_api_SearchTemplatesQuery") -> Any:
        pass

    @abstractmethod
    def _exact_match(self, exact_match: str) -> Any:
        pass

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _labels(self, labels: "scout_rids_api_LabelsFilter") -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _properties(self, properties: "scout_rids_api_PropertiesFilter") -> Any:
        pass

    @abstractmethod
    def _created_by(self, created_by: str) -> Any:
        pass

    @abstractmethod
    def _is_archived(self, is_archived: bool) -> Any:
        pass

    @abstractmethod
    def _is_published(self, is_published: bool) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass

    @abstractmethod
    def _author_is_current_user(self, author_is_current_user: bool) -> Any:
        pass

    @abstractmethod
    def _author_rids(self, author_rids: List[str]) -> Any:
        pass


scout_template_api_SearchTemplatesQueryVisitor.__name__ = "SearchTemplatesQueryVisitor"
scout_template_api_SearchTemplatesQueryVisitor.__qualname__ = "SearchTemplatesQueryVisitor"
scout_template_api_SearchTemplatesQueryVisitor.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SearchTemplatesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_template_api_SearchTemplatesQuery),
            'sort_by': ConjureFieldDefinition('sortBy', OptionalTypeWrapper[scout_template_api_SortBy]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token]),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_query', '_sort_by', '_next_page_token', '_page_size']

    def __init__(self, query: "scout_template_api_SearchTemplatesQuery", next_page_token: Optional[str] = None, page_size: Optional[int] = None, sort_by: Optional["scout_template_api_SortBy"] = None) -> None:
        self._query = query
        self._sort_by = sort_by
        self._next_page_token = next_page_token
        self._page_size = page_size

    @builtins.property
    def query(self) -> "scout_template_api_SearchTemplatesQuery":
        return self._query

    @builtins.property
    def sort_by(self) -> Optional["scout_template_api_SortBy"]:
        """EDITED_AT descending by default
        """
        return self._sort_by

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size


scout_template_api_SearchTemplatesRequest.__name__ = "SearchTemplatesRequest"
scout_template_api_SearchTemplatesRequest.__qualname__ = "SearchTemplatesRequest"
scout_template_api_SearchTemplatesRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SearchTemplatesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_template_api_TemplateSummary]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_template_api_TemplateSummary"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_template_api_TemplateSummary"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_template_api_SearchTemplatesResponse.__name__ = "SearchTemplatesResponse"
scout_template_api_SearchTemplatesResponse.__qualname__ = "SearchTemplatesResponse"
scout_template_api_SearchTemplatesResponse.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SortBy(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_template_api_SortByField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_template_api_SortByField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_template_api_SortByField":
        return self._field


scout_template_api_SortBy.__name__ = "SortBy"
scout_template_api_SortBy.__qualname__ = "SortBy"
scout_template_api_SortBy.__module__ = "nominal_api.scout_template_api"


class scout_template_api_SortByField(ConjureEnumType):
    """UPDATED_AT is an alias for EDITED_AT.
    """

    NAME = 'NAME'
    '''NAME'''
    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UPDATED_AT = 'UPDATED_AT'
    '''UPDATED_AT'''
    EDITED_AT = 'EDITED_AT'
    '''EDITED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_template_api_SortByField.__name__ = "SortByField"
scout_template_api_SortByField.__qualname__ = "SortByField"
scout_template_api_SortByField.__module__ = "nominal_api.scout_template_api"


class scout_template_api_Template(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TemplateRid),
            'metadata': ConjureFieldDefinition('metadata', scout_template_api_TemplateMetadata),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit),
            'charts': ConjureFieldDefinition('charts', List[scout_rids_api_VersionedVizId]),
            'layout': ConjureFieldDefinition('layout', scout_layout_api_WorkbookLayout),
            'content': ConjureFieldDefinition('content', scout_workbookcommon_api_WorkbookContent)
        }

    __slots__: List[str] = ['_rid', '_metadata', '_commit', '_charts', '_layout', '_content']

    def __init__(self, charts: List["scout_rids_api_VersionedVizId"], commit: "scout_versioning_api_Commit", content: "scout_workbookcommon_api_WorkbookContent", layout: "scout_layout_api_WorkbookLayout", metadata: "scout_template_api_TemplateMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata
        self._commit = commit
        self._charts = charts
        self._layout = layout
        self._content = content

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_template_api_TemplateMetadata":
        return self._metadata

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit

    @builtins.property
    def charts(self) -> List["scout_rids_api_VersionedVizId"]:
        return self._charts

    @builtins.property
    def layout(self) -> "scout_layout_api_WorkbookLayout":
        return self._layout

    @builtins.property
    def content(self) -> "scout_workbookcommon_api_WorkbookContent":
        return self._content


scout_template_api_Template.__name__ = "Template"
scout_template_api_Template.__qualname__ = "Template"
scout_template_api_Template.__module__ = "nominal_api.scout_template_api"


class scout_template_api_TemplateMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', str),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'is_published': ConjureFieldDefinition('isPublished', bool),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str),
            'edited_at': ConjureFieldDefinition('editedAt', str)
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_archived', '_is_published', '_created_by', '_created_at', '_updated_at', '_edited_at']

    def __init__(self, created_at: str, created_by: str, description: str, edited_at: str, is_archived: bool, is_published: bool, labels: List[str], properties: Dict[str, str], title: str, updated_at: str) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_archived = is_archived
        self._is_published = is_published
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at
        self._edited_at = edited_at

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def is_published(self) -> bool:
        return self._is_published

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at

    @builtins.property
    def edited_at(self) -> str:
        """The time of the last permanent commit to the main branch.
        """
        return self._edited_at


scout_template_api_TemplateMetadata.__name__ = "TemplateMetadata"
scout_template_api_TemplateMetadata.__qualname__ = "TemplateMetadata"
scout_template_api_TemplateMetadata.__module__ = "nominal_api.scout_template_api"


class scout_template_api_TemplateSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_rids_api_TemplateRid),
            'metadata': ConjureFieldDefinition('metadata', scout_template_api_TemplateMetadata)
        }

    __slots__: List[str] = ['_rid', '_metadata']

    def __init__(self, metadata: "scout_template_api_TemplateMetadata", rid: str) -> None:
        self._rid = rid
        self._metadata = metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def metadata(self) -> "scout_template_api_TemplateMetadata":
        return self._metadata


scout_template_api_TemplateSummary.__name__ = "TemplateSummary"
scout_template_api_TemplateSummary.__qualname__ = "TemplateSummary"
scout_template_api_TemplateSummary.__module__ = "nominal_api.scout_template_api"


class scout_template_api_UpdateMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'is_archived': ConjureFieldDefinition('isArchived', OptionalTypeWrapper[bool]),
            'is_published': ConjureFieldDefinition('isPublished', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_is_archived', '_is_published']

    def __init__(self, description: Optional[str] = None, is_archived: Optional[bool] = None, is_published: Optional[bool] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._is_archived = is_archived
        self._is_published = is_published

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def is_archived(self) -> Optional[bool]:
        return self._is_archived

    @builtins.property
    def is_published(self) -> Optional[bool]:
        return self._is_published


scout_template_api_UpdateMetadataRequest.__name__ = "UpdateMetadataRequest"
scout_template_api_UpdateMetadataRequest.__qualname__ = "UpdateMetadataRequest"
scout_template_api_UpdateMetadataRequest.__module__ = "nominal_api.scout_template_api"


class scout_template_api_UpdateRefNameRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ref_name_updates': ConjureFieldDefinition('refNameUpdates', Dict[scout_api_DataSourceRefName, scout_api_DataSourceRefName]),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_ref_name_updates', '_latest_commit']

    def __init__(self, ref_name_updates: Dict[str, str], latest_commit: Optional[str] = None) -> None:
        self._ref_name_updates = ref_name_updates
        self._latest_commit = latest_commit

    @builtins.property
    def ref_name_updates(self) -> Dict[str, str]:
        return self._ref_name_updates

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        """If present, will validate that the latest commit matches this id,
and otherwise throw CommitConflict.
        """
        return self._latest_commit


scout_template_api_UpdateRefNameRequest.__name__ = "UpdateRefNameRequest"
scout_template_api_UpdateRefNameRequest.__qualname__ = "UpdateRefNameRequest"
scout_template_api_UpdateRefNameRequest.__module__ = "nominal_api.scout_template_api"


class scout_units_api_GetUnitsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'units_by_property': ConjureFieldDefinition('unitsByProperty', Dict[scout_units_api_UnitProperty, List[scout_units_api_Unit]])
        }

    __slots__: List[str] = ['_units_by_property']

    def __init__(self, units_by_property: Dict[str, List["scout_units_api_Unit"]]) -> None:
        self._units_by_property = units_by_property

    @builtins.property
    def units_by_property(self) -> Dict[str, List["scout_units_api_Unit"]]:
        return self._units_by_property


scout_units_api_GetUnitsResponse.__name__ = "GetUnitsResponse"
scout_units_api_GetUnitsResponse.__qualname__ = "GetUnitsResponse"
scout_units_api_GetUnitsResponse.__module__ = "nominal_api.scout_units_api"


class scout_units_api_Unit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[scout_units_api_UnitName]),
            'symbol': ConjureFieldDefinition('symbol', scout_units_api_UnitSymbol),
            'property': ConjureFieldDefinition('property', OptionalTypeWrapper[scout_units_api_UnitProperty]),
            'dimension': ConjureFieldDefinition('dimension', OptionalTypeWrapper[scout_units_api_UnitDimension]),
            'system': ConjureFieldDefinition('system', scout_units_api_UnitSystem)
        }

    __slots__: List[str] = ['_name', '_symbol', '_property', '_dimension', '_system']

    def __init__(self, symbol: str, system: str, dimension: Optional["scout_units_api_UnitDimension"] = None, name: Optional[str] = None, property: Optional[str] = None) -> None:
        self._name = name
        self._symbol = symbol
        self._property = property
        self._dimension = dimension
        self._system = system

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def symbol(self) -> str:
        return self._symbol

    @builtins.property
    def property(self) -> Optional[str]:
        """Empty if no property is available. If two units measure different properties, it is not possible to 
convert between them.
        """
        return self._property

    @builtins.property
    def dimension(self) -> Optional["scout_units_api_UnitDimension"]:
        """The physical dimensions in terms of the base units of the system. It is only possible to convert units if 
they have the same dimension. Empty if the unit is a base unit.
        """
        return self._dimension

    @builtins.property
    def system(self) -> str:
        return self._system


scout_units_api_Unit.__name__ = "Unit"
scout_units_api_Unit.__qualname__ = "Unit"
scout_units_api_Unit.__module__ = "nominal_api.scout_units_api"


class scout_units_api_UnitDimension(ConjureBeanType):
    """The fundamental base dimensions and their exponents, whose product compose a unit.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'base_dimensions': ConjureFieldDefinition('baseDimensions', Dict[str, int])
        }

    __slots__: List[str] = ['_base_dimensions']

    def __init__(self, base_dimensions: Dict[str, int]) -> None:
        self._base_dimensions = base_dimensions

    @builtins.property
    def base_dimensions(self) -> Dict[str, int]:
        return self._base_dimensions


scout_units_api_UnitDimension.__name__ = "UnitDimension"
scout_units_api_UnitDimension.__qualname__ = "UnitDimension"
scout_units_api_UnitDimension.__module__ = "nominal_api.scout_units_api"


class scout_versioning_api_Branch(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_versioning_api_BranchRid),
            'name': ConjureFieldDefinition('name', scout_versioning_api_BranchName),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_at': ConjureFieldDefinition('updatedAt', str)
        }

    __slots__: List[str] = ['_rid', '_name', '_resource_rid', '_commit', '_created_by', '_created_at', '_updated_at']

    def __init__(self, commit: str, created_at: str, created_by: str, name: str, resource_rid: str, rid: str, updated_at: str) -> None:
        self._rid = rid
        self._name = name
        self._resource_rid = resource_rid
        self._commit = commit
        self._created_by = created_by
        self._created_at = created_at
        self._updated_at = updated_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit(self) -> str:
        return self._commit

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def updated_at(self) -> str:
        return self._updated_at


scout_versioning_api_Branch.__name__ = "Branch"
scout_versioning_api_Branch.__qualname__ = "Branch"
scout_versioning_api_Branch.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_BranchAndCommit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'branch': ConjureFieldDefinition('branch', scout_versioning_api_Branch),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_Commit)
        }

    __slots__: List[str] = ['_branch', '_commit']

    def __init__(self, branch: "scout_versioning_api_Branch", commit: "scout_versioning_api_Commit") -> None:
        self._branch = branch
        self._commit = commit

    @builtins.property
    def branch(self) -> "scout_versioning_api_Branch":
        return self._branch

    @builtins.property
    def commit(self) -> "scout_versioning_api_Commit":
        return self._commit


scout_versioning_api_BranchAndCommit.__name__ = "BranchAndCommit"
scout_versioning_api_BranchAndCommit.__qualname__ = "BranchAndCommit"
scout_versioning_api_BranchAndCommit.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_Commit(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', scout_versioning_api_CommitId),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'parent_commit': ConjureFieldDefinition('parentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'merge_parent_commit': ConjureFieldDefinition('mergeParentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'message': ConjureFieldDefinition('message', str),
            'is_working_state': ConjureFieldDefinition('isWorkingState', bool),
            'committed_by': ConjureFieldDefinition('committedBy', scout_rids_api_UserRid),
            'committed_at': ConjureFieldDefinition('committedAt', str)
        }

    __slots__: List[str] = ['_id', '_resource_rid', '_parent_commit', '_merge_parent_commit', '_message', '_is_working_state', '_committed_by', '_committed_at']

    def __init__(self, committed_at: str, committed_by: str, id: str, is_working_state: bool, message: str, resource_rid: str, merge_parent_commit: Optional[str] = None, parent_commit: Optional[str] = None) -> None:
        self._id = id
        self._resource_rid = resource_rid
        self._parent_commit = parent_commit
        self._merge_parent_commit = merge_parent_commit
        self._message = message
        self._is_working_state = is_working_state
        self._committed_by = committed_by
        self._committed_at = committed_at

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def parent_commit(self) -> Optional[str]:
        return self._parent_commit

    @builtins.property
    def merge_parent_commit(self) -> Optional[str]:
        return self._merge_parent_commit

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def is_working_state(self) -> bool:
        """A working state commit is created via the `saveWorkingState` endpoint
and is non-permanent. In the future, it may be compacted and not exist.
        """
        return self._is_working_state

    @builtins.property
    def committed_by(self) -> str:
        return self._committed_by

    @builtins.property
    def committed_at(self) -> str:
        return self._committed_at


scout_versioning_api_Commit.__name__ = "Commit"
scout_versioning_api_Commit.__qualname__ = "Commit"
scout_versioning_api_Commit.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CommitHistory(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'history': ConjureFieldDefinition('history', List[scout_versioning_api_Commit]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_history', '_next_page_token']

    def __init__(self, history: List["scout_versioning_api_Commit"], next_page_token: Optional[str] = None) -> None:
        self._history = history
        self._next_page_token = next_page_token

    @builtins.property
    def history(self) -> List["scout_versioning_api_Commit"]:
        return self._history

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_versioning_api_CommitHistory.__name__ = "CommitHistory"
scout_versioning_api_CommitHistory.__qualname__ = "CommitHistory"
scout_versioning_api_CommitHistory.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CommitRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'merge_parent_commit': ConjureFieldDefinition('mergeParentCommit', OptionalTypeWrapper[scout_versioning_api_CommitId]),
            'message': ConjureFieldDefinition('message', str),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_new_commit', '_merge_parent_commit', '_message', '_latest_commit']

    def __init__(self, message: str, new_commit: str, latest_commit: Optional[str] = None, merge_parent_commit: Optional[str] = None) -> None:
        self._new_commit = new_commit
        self._merge_parent_commit = merge_parent_commit
        self._message = message
        self._latest_commit = latest_commit

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def merge_parent_commit(self) -> Optional[str]:
        """If present, this existing commit will be the merge parent
of the new commit. It will be made permanent if not already,
to prevent the merge parent from being compacted.
        """
        return self._merge_parent_commit

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        return self._latest_commit


scout_versioning_api_CommitRequest.__name__ = "CommitRequest"
scout_versioning_api_CommitRequest.__qualname__ = "CommitRequest"
scout_versioning_api_CommitRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CompactCommitsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'strategy': ConjureFieldDefinition('strategy', scout_versioning_api_CompactionStrategy)
        }

    __slots__: List[str] = ['_strategy']

    def __init__(self, strategy: "scout_versioning_api_CompactionStrategy") -> None:
        self._strategy = strategy

    @builtins.property
    def strategy(self) -> "scout_versioning_api_CompactionStrategy":
        return self._strategy


scout_versioning_api_CompactCommitsRequest.__name__ = "CompactCommitsRequest"
scout_versioning_api_CompactCommitsRequest.__qualname__ = "CompactCommitsRequest"
scout_versioning_api_CompactCommitsRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CompactionStrategy(ConjureUnionType):
    """Needs to be expressible as a database query
    """
    _older_than_days: Optional[int] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'older_than_days': ConjureFieldDefinition('olderThanDays', int)
        }

    def __init__(
            self,
            older_than_days: Optional[int] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (older_than_days is not None) != 1:
                raise ValueError('a union must contain a single member')

            if older_than_days is not None:
                self._older_than_days = older_than_days
                self._type = 'olderThanDays'

        elif type_of_union == 'olderThanDays':
            if older_than_days is None:
                raise ValueError('a union value must not be None')
            self._older_than_days = older_than_days
            self._type = 'olderThanDays'

    @builtins.property
    def older_than_days(self) -> Optional[int]:
        return self._older_than_days

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_versioning_api_CompactionStrategyVisitor):
            raise ValueError('{} is not an instance of scout_versioning_api_CompactionStrategyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'olderThanDays' and self.older_than_days is not None:
            return visitor._older_than_days(self.older_than_days)


scout_versioning_api_CompactionStrategy.__name__ = "CompactionStrategy"
scout_versioning_api_CompactionStrategy.__qualname__ = "CompactionStrategy"
scout_versioning_api_CompactionStrategy.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CompactionStrategyVisitor:

    @abstractmethod
    def _older_than_days(self, older_than_days: int) -> Any:
        pass


scout_versioning_api_CompactionStrategyVisitor.__name__ = "CompactionStrategyVisitor"
scout_versioning_api_CompactionStrategyVisitor.__qualname__ = "CompactionStrategyVisitor"
scout_versioning_api_CompactionStrategyVisitor.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CreateBranchRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_commit': ConjureFieldDefinition('existingCommit', scout_versioning_api_CommitId),
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName)
        }

    __slots__: List[str] = ['_existing_commit', '_branch_name']

    def __init__(self, branch_name: str, existing_commit: str) -> None:
        self._existing_commit = existing_commit
        self._branch_name = branch_name

    @builtins.property
    def existing_commit(self) -> str:
        return self._existing_commit

    @builtins.property
    def branch_name(self) -> str:
        return self._branch_name


scout_versioning_api_CreateBranchRequest.__name__ = "CreateBranchRequest"
scout_versioning_api_CreateBranchRequest.__qualname__ = "CreateBranchRequest"
scout_versioning_api_CreateBranchRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_CreateTagRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'existing_commit': ConjureFieldDefinition('existingCommit', scout_versioning_api_CommitId),
            'tag_name': ConjureFieldDefinition('tagName', scout_versioning_api_TagName)
        }

    __slots__: List[str] = ['_existing_commit', '_tag_name']

    def __init__(self, existing_commit: str, tag_name: str) -> None:
        self._existing_commit = existing_commit
        self._tag_name = tag_name

    @builtins.property
    def existing_commit(self) -> str:
        return self._existing_commit

    @builtins.property
    def tag_name(self) -> str:
        return self._tag_name


scout_versioning_api_CreateTagRequest.__name__ = "CreateTagRequest"
scout_versioning_api_CreateTagRequest.__qualname__ = "CreateTagRequest"
scout_versioning_api_CreateTagRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_GetLeastCommonAncestorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'commit1': ConjureFieldDefinition('commit1', scout_versioning_api_CommitId),
            'commit2': ConjureFieldDefinition('commit2', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_commit1', '_commit2']

    def __init__(self, commit1: str, commit2: str) -> None:
        self._commit1 = commit1
        self._commit2 = commit2

    @builtins.property
    def commit1(self) -> str:
        return self._commit1

    @builtins.property
    def commit2(self) -> str:
        return self._commit2


scout_versioning_api_GetLeastCommonAncestorRequest.__name__ = "GetLeastCommonAncestorRequest"
scout_versioning_api_GetLeastCommonAncestorRequest.__qualname__ = "GetLeastCommonAncestorRequest"
scout_versioning_api_GetLeastCommonAncestorRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_InitResourceVersioningRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_new_commit', '_message']

    def __init__(self, message: str, new_commit: str) -> None:
        self._new_commit = new_commit
        self._message = message

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def message(self) -> str:
        return self._message


scout_versioning_api_InitResourceVersioningRequest.__name__ = "InitResourceVersioningRequest"
scout_versioning_api_InitResourceVersioningRequest.__qualname__ = "InitResourceVersioningRequest"
scout_versioning_api_InitResourceVersioningRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_ResourceAndBranchName(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'branch_name': ConjureFieldDefinition('branchName', scout_versioning_api_BranchName)
        }

    __slots__: List[str] = ['_resource_rid', '_branch_name']

    def __init__(self, branch_name: str, resource_rid: str) -> None:
        self._resource_rid = resource_rid
        self._branch_name = branch_name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def branch_name(self) -> str:
        return self._branch_name


scout_versioning_api_ResourceAndBranchName.__name__ = "ResourceAndBranchName"
scout_versioning_api_ResourceAndBranchName.__qualname__ = "ResourceAndBranchName"
scout_versioning_api_ResourceAndBranchName.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_ResourceAndCommitId(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit_id': ConjureFieldDefinition('commitId', scout_versioning_api_CommitId)
        }

    __slots__: List[str] = ['_resource_rid', '_commit_id']

    def __init__(self, commit_id: str, resource_rid: str) -> None:
        self._resource_rid = resource_rid
        self._commit_id = commit_id

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit_id(self) -> str:
        return self._commit_id


scout_versioning_api_ResourceAndCommitId.__name__ = "ResourceAndCommitId"
scout_versioning_api_ResourceAndCommitId.__qualname__ = "ResourceAndCommitId"
scout_versioning_api_ResourceAndCommitId.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_SaveWorkingStateRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'new_commit': ConjureFieldDefinition('newCommit', scout_versioning_api_CommitId),
            'latest_commit': ConjureFieldDefinition('latestCommit', OptionalTypeWrapper[scout_versioning_api_CommitId])
        }

    __slots__: List[str] = ['_new_commit', '_latest_commit']

    def __init__(self, new_commit: str, latest_commit: Optional[str] = None) -> None:
        self._new_commit = new_commit
        self._latest_commit = latest_commit

    @builtins.property
    def new_commit(self) -> str:
        return self._new_commit

    @builtins.property
    def latest_commit(self) -> Optional[str]:
        return self._latest_commit


scout_versioning_api_SaveWorkingStateRequest.__name__ = "SaveWorkingStateRequest"
scout_versioning_api_SaveWorkingStateRequest.__qualname__ = "SaveWorkingStateRequest"
scout_versioning_api_SaveWorkingStateRequest.__module__ = "nominal_api.scout_versioning_api"


class scout_versioning_api_Tag(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', scout_versioning_api_TagRid),
            'name': ConjureFieldDefinition('name', scout_versioning_api_TagName),
            'resource_rid': ConjureFieldDefinition('resourceRid', str),
            'commit': ConjureFieldDefinition('commit', scout_versioning_api_CommitId),
            'created_by': ConjureFieldDefinition('createdBy', scout_rids_api_UserRid),
            'created_at': ConjureFieldDefinition('createdAt', str)
        }

    __slots__: List[str] = ['_rid', '_name', '_resource_rid', '_commit', '_created_by', '_created_at']

    def __init__(self, commit: str, created_at: str, created_by: str, name: str, resource_rid: str, rid: str) -> None:
        self._rid = rid
        self._name = name
        self._resource_rid = resource_rid
        self._commit = commit
        self._created_by = created_by
        self._created_at = created_at

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def resource_rid(self) -> str:
        return self._resource_rid

    @builtins.property
    def commit(self) -> str:
        return self._commit

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at


scout_versioning_api_Tag.__name__ = "Tag"
scout_versioning_api_Tag.__qualname__ = "Tag"
scout_versioning_api_Tag.__module__ = "nominal_api.scout_versioning_api"


class scout_video_VideoFileService(Service):
    """The video service manages individual video files and their metadata.
    """

    def create(self, auth_header: str, request: "scout_video_api_CreateVideoFileRequest") -> "scout_video_api_VideoFile":
        """Create and persist a video file entity with the given metadata
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video-files/v1/video-files'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_VideoFile, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, video_file_rid: str) -> "scout_video_api_VideoFile":
        """Returns video file metadata associated with a video file RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_VideoFile, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, video_file_rids: List[str] = None) -> List["scout_video_api_VideoFile"]:
        """Returns all video files and their metadata associated with the given RIDs
        """
        video_file_rids = video_file_rids if video_file_rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(video_file_rids)

        _path = '/video-files/v1/video-files/batchGet'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_VideoFile], self._return_none_for_unknown_union_types)

    def list_files_in_video(self, auth_header: str, video_rid: str) -> List["scout_video_api_VideoFile"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(video_rid)

        _path = '/video-files/v1/video-files/list-files-in-video'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_VideoFile], self._return_none_for_unknown_union_types)

    def list_files_in_video_paginated(self, auth_header: str, video_rid: "scout_video_api_ListFilesInVideoRequest") -> "scout_video_api_ListFilesInVideoResponse":
        """Returns a paginated list of all video files and their metadata associated with the given video RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(video_rid)

        _path = '/video-files/v1/video-files/list-files-in-video-paginated'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_ListFilesInVideoResponse, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "scout_video_api_UpdateVideoFileRequest", video_file_rid: str) -> "scout_video_api_VideoFile":
        """Updates the metadata for a video file associated with the given RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video-files/v1/video-files/{videoFileRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_VideoFile, self._return_none_for_unknown_union_types)

    def delete(self, auth_header: str, video_file_rid: str) -> None:
        """Permanently deletes a video file and all associated segments from the database.
This operation cannot be undone.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive(self, auth_header: str, video_file_rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, video_file_rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_ingest_status(self, auth_header: str, video_file_rid: str) -> "scout_video_api_GetIngestStatusResponse":
        """Get the latest ingest status for a given video file by RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_GetIngestStatusResponse, self._return_none_for_unknown_union_types)

    def batch_get_ingest_status(self, auth_header: str, video_file_rids: List[str] = None) -> Dict[str, "scout_video_api_VideoFileIngestStatus"]:
        """Get the latest ingest status for a set of given video files by RID.
        """
        video_file_rids = video_file_rids if video_file_rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(video_file_rids)

        _path = '/video-files/v1/videos/batch-get-ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[api_rids_VideoFileRid, scout_video_api_VideoFileIngestStatus], self._return_none_for_unknown_union_types)

    def update_ingest_status(self, auth_header: str, request: "scout_video_api_UpdateIngestStatusRequest", video_file_rid: str) -> None:
        """Update the latest ingest status for a given video file by RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video-files/v1/videos/{videoFileRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_segment_summaries(self, auth_header: str, video_file_rid: str) -> List["scout_video_api_SegmentSummary"]:
        """Returns the min and max absolute and media timestamps for each segment in a video file. 
To be used during frame-timestamp mapping when playing back videos.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}/segment-summaries'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_SegmentSummary], self._return_none_for_unknown_union_types)

    def get_playlist(self, auth_header: str, video_file_rid: str) -> Any:
        """Generate an HLS playlist for a video file with the given RID to enable playback.
The HLS playlist will contain links to all of the video segments in the video in sequential order.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video-files/v1/video-files/{videoFileRid}/playlist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw


scout_video_VideoFileService.__name__ = "VideoFileService"
scout_video_VideoFileService.__qualname__ = "VideoFileService"
scout_video_VideoFileService.__module__ = "nominal_api.scout_video"


class scout_video_VideoSegmentService(Service):
    """Upon ingestion, every video is split into smaller segments. The Video Segment Service manages operations on videos
at the segment-level.
    """

    def create_segments(self, auth_header: str, request: "scout_video_api_CreateSegmentsRequest", video_rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/create-segments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def create_video_file_segments(self, auth_header: str, request: "scout_video_api_CreateSegmentsRequest", video_file_rid: str, video_rid: str) -> "scout_video_api_CreateSegmentsResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
            'videoFileRid': quote(str(_conjure_encoder.default(video_file_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/{videoFileRid}/create-segments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_CreateSegmentsResponse, self._return_none_for_unknown_union_types)

    def create_video_stream_segments(self, auth_header: str, request: "scout_video_api_CreateSegmentsRequest", stream_uuid: str, video_rid: str) -> "scout_video_api_CreateSegmentsResponse":
        """Creates segments for a video stream. Similar to createVideoFileSegments but for streaming video.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
            'streamUuid': quote(str(_conjure_encoder.default(stream_uuid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/streams/{streamUuid}/create-segments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_CreateSegmentsResponse, self._return_none_for_unknown_union_types)

    def create_segments_v2(self, auth_header: str, request: "scout_video_api_CreateSegmentsV2Request") -> "scout_video_api_CreateSegmentsV2Response":
        """Creates segments for a dataset file video. Used for channel-based video ingestion.
Internal use only.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v2/videos/create-segments'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_CreateSegmentsV2Response, self._return_none_for_unknown_union_types)

    def get_segment_by_timestamp(self, auth_header: str, request: "scout_video_api_GetSegmentByTimestampRequest", video_rid: str) -> Optional["scout_video_api_Segment"]:
        """Returns metadata for the segment within a video containing the requested absolute timestamp.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/get-segment-by-timestamp'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_Segment], self._return_none_for_unknown_union_types)


scout_video_VideoSegmentService.__name__ = "VideoSegmentService"
scout_video_VideoSegmentService.__qualname__ = "VideoSegmentService"
scout_video_VideoSegmentService.__module__ = "nominal_api.scout_video"


class scout_video_VideoService(Service):
    """The video service manages videos and video metadata.
    """

    def get(self, auth_header: str, video_rid: str) -> "scout_video_api_Video":
        """Returns video metadata associated with a video rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, request: "scout_video_api_GetVideosRequest") -> "scout_video_api_GetVideosResponse":
        """Returns video metadata about each video given a set of video rids.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/batchGet'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_GetVideosResponse, self._return_none_for_unknown_union_types)

    def search(self, auth_header: str, request: "scout_video_api_SearchVideosRequest") -> "scout_video_api_SearchVideosResponse":
        """Returns metadata about videos that match a given query.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_SearchVideosResponse, self._return_none_for_unknown_union_types)

    def create(self, auth_header: str, request: "scout_video_api_CreateVideoRequest") -> "scout_video_api_Video":
        """Creates and persists a video entity with the given metadata.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "scout_video_api_UpdateVideoMetadataRequest", video_rid: str) -> "scout_video_api_Video":
        """Updates the metadata for a video associated with the given video rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_Video, self._return_none_for_unknown_union_types)

    def update_ingest_status(self, auth_header: str, request: "scout_video_api_UpdateIngestStatus", video_rid: str) -> None:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_ingest_status(self, auth_header: str, video_rid: str) -> "scout_video_api_DetailedIngestStatus":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_DetailedIngestStatus, self._return_none_for_unknown_union_types)

    def batch_get_ingest_status(self, auth_header: str, video_rids: List[str] = None) -> Dict[str, "scout_video_api_DetailedIngestStatus"]:
        video_rids = video_rids if video_rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(video_rids)

        _path = '/video/v1/videos/batch-get-ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), Dict[api_rids_VideoRid, scout_video_api_DetailedIngestStatus], self._return_none_for_unknown_union_types)

    def get_enriched_ingest_status(self, auth_header: str, request: "scout_video_api_GetEnrichedVideoIngestStatusRequest") -> Optional["scout_video_api_EnrichedVideoIngestStatus"]:
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/enriched-ingest-status'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_EnrichedVideoIngestStatus], self._return_none_for_unknown_union_types)

    def archive(self, auth_header: str, video_rid: str) -> None:
        """Archives a video, which excludes it from search and hides it from being publicly visible, but does not
permanently delete it. Archived videos can be unarchived.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, video_rid: str) -> None:
        """Unarchives a previously archived video.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get_playlist(self, auth_header: str, video_rid: str, end: Optional[str] = None, start: Optional[str] = None) -> Any:
        """Generates an HLS playlist for a video within optional time bounds.
Uses GET with query parameters for HLS.js compatibility.
The HLS playlist will contain links to all of the segments in the video that overlap with the given bounds,
or all segments if no bounds are provided.

Note: The start and end parameters must either both be provided or both be omitted.
Providing only one will result in a MissingTimestampBoundPair error.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'start': _conjure_encoder.default(start),
            'end': _conjure_encoder.default(end),
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/playlist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def get_segment_summaries(self, auth_header: str, video_rid: str) -> List["scout_video_api_SegmentSummary"]:
        """Returns the min and max absolute and media timestamps for each segment in a video. To be used during 
frame-timestamp mapping.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/segment-summaries'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_SegmentSummary], self._return_none_for_unknown_union_types)

    def get_playlist_in_bounds(self, auth_header: str, request: "scout_video_api_GetPlaylistInBoundsRequest", video_rid: str) -> Any:
        """Generates an HLS playlist for a video with the given video rid to enable playback within an optional set of
bounds. The HLS playlist will contain links to all of the segments in the video that overlap with the given 
bounds.
playlist will be limited to the given bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/playlist-in-bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def get_playlist_in_bounds_v2(self, auth_header: str, request: "scout_video_api_GetPlaylistInBoundsForChannelRequest") -> Any:
        """Generates an HLS playlist for a video series (identified by channel + tags) within bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v2/videos/playlist-in-bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def get_playlist_v2(self, auth_header: str, channel: str, end: str, start: str, asset_rid: Optional[str] = None, data_scope_name: Optional[str] = None, data_source_rid: Optional[str] = None, tags: Optional[str] = None) -> Any:
        """Generates an HLS playlist for a video series within time bounds.
Specify either dataSourceRid OR (assetRid + dataScopeName) to identify the series source.

Note: Both start and end parameters are required and must be provided together.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'dataSourceRid': _conjure_encoder.default(data_source_rid),
            'assetRid': _conjure_encoder.default(asset_rid),
            'dataScopeName': _conjure_encoder.default(data_scope_name),
            'channel': _conjure_encoder.default(channel),
            'tags': _conjure_encoder.default(tags),
            'start': _conjure_encoder.default(start),
            'end': _conjure_encoder.default(end),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/video/v2/videos/playlist'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            stream=True,
            json=_json)

        _raw = _response.raw
        _raw.decode_content = True
        return _raw

    def get_segment_summaries_in_bounds(self, auth_header: str, request: "scout_video_api_GetSegmentSummariesInBoundsRequest", video_rid: str) -> List["scout_video_api_SegmentSummary"]:
        """Returns the min and max absolute and media timestamps for each segment in a video that overlap with an 
optional set of bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/segment-summaries-in-bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_SegmentSummary], self._return_none_for_unknown_union_types)

    def get_segment_summaries_in_bounds_v2(self, auth_header: str, request: "scout_video_api_GetSegmentSummariesInBoundsForChannelRequest") -> List["scout_video_api_SegmentSummaryV2"]:
        """Returns the min and max absolute and media timestamps for each segment matching a video series 
(identified by channel + tags) within the specified bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v2/videos/segment-summaries-in-bounds'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[scout_video_api_SegmentSummaryV2], self._return_none_for_unknown_union_types)

    def get_segment_metadata_v2(self, auth_header: str, request: "scout_video_api_GetSegmentMetadataForChannelRequest") -> Optional["scout_video_api_VideoChannelSegmentsMetadata"]:
        """Returns aggregated segment metadata for a video channel series, including total frames,
segment count, min/max timestamps, and average frame rate. Optionally filter by time bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v2/videos/segment-metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_VideoChannelSegmentsMetadata], self._return_none_for_unknown_union_types)

    def get_segment_by_timestamp_v2(self, auth_header: str, request: "scout_video_api_GetSegmentByTimestampV2Request") -> Optional["scout_video_api_SegmentV2"]:
        """Returns metadata for the segment within a video series containing the requested absolute timestamp.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v2/videos/get-segment-by-timestamp'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_SegmentV2], self._return_none_for_unknown_union_types)

    def get_file_summaries(self, auth_header: str, request: "scout_video_api_GetFileSummariesRequest", video_rid: str) -> "scout_video_api_GetFileSummariesResponse":
        """Returns the min and max absolute timestamps from non-archived video files associated with a given video that
overlap with an optional set of bounds. The files on the edges of the bounds will be truncated to segments
that are inside or overlap with the bounds.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/video/v1/videos/{videoRid}/get-ranges-with-existing-segment-data'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_GetFileSummariesResponse, self._return_none_for_unknown_union_types)

    def generate_whip_stream(self, auth_header: str, video_rid: str) -> "scout_video_api_GenerateWhipStreamResponse":
        """Generates a stream ID scoped to a video and returns a WHIP URL with a MediaMTX JWT and ICE servers.
Enforces write permission on the video.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/streaming/whip'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), scout_video_api_GenerateWhipStreamResponse, self._return_none_for_unknown_union_types)

    def generate_whep_stream(self, auth_header: str, video_rid: str) -> Optional["scout_video_api_GenerateWhepStreamResponse"]:
        """Returns WHEP URL, ICE servers, and token for playing back the active stream.
Returns empty if there is no active stream.
Enforces read permission on the video.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'videoRid': quote(str(_conjure_encoder.default(video_rid)), safe=''),
        }

        _json: Any = None

        _path = '/video/v1/videos/{videoRid}/streaming/whep'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[scout_video_api_GenerateWhepStreamResponse], self._return_none_for_unknown_union_types)

    def upload_segment_from_media_mtx(self, auth_header: str, body: Any, content_length: int, duration: str, file_path: str, stream_path: str) -> None:
        """MediaMTX segment upload endpoint. Receives video segments from MediaMTX hooks.
Validates JWT and logs session. Future: create video segments from uploaded files.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/octet-stream',
            'Authorization': auth_header,
            'Content-Length': _conjure_encoder.default(content_length),
        }

        _params: Dict[str, Any] = {
            'streamPath': _conjure_encoder.default(stream_path),
            'filePath': _conjure_encoder.default(file_path),
            'duration': _conjure_encoder.default(duration),
        }

        _path_params: Dict[str, str] = {
        }

        _data: Any = body

        _path = '/video/v1/segment/upload'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            data=_data)

        return


scout_video_VideoService.__name__ = "VideoService"
scout_video_VideoService.__qualname__ = "VideoService"
scout_video_VideoService.__module__ = "nominal_api.scout_video"


class scout_video_api_Bounds(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp)
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp") -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end


scout_video_api_Bounds.__name__ = "Bounds"
scout_video_api_Bounds.__qualname__ = "Bounds"
scout_video_api_Bounds.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateSegment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_handle': ConjureFieldDefinition('dataHandle', api_Handle),
            'frame_rate': ConjureFieldDefinition('frameRate', float),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', float),
            'timestamps': ConjureFieldDefinition('timestamps', scout_video_api_SegmentTimestamps),
            'segment_end_timestamp': ConjureFieldDefinition('segmentEndTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_data_handle', '_frame_rate', '_duration_seconds', '_timestamps', '_segment_end_timestamp']

    def __init__(self, data_handle: "api_Handle", duration_seconds: float, frame_rate: float, segment_end_timestamp: "api_Timestamp", timestamps: "scout_video_api_SegmentTimestamps") -> None:
        self._data_handle = data_handle
        self._frame_rate = frame_rate
        self._duration_seconds = duration_seconds
        self._timestamps = timestamps
        self._segment_end_timestamp = segment_end_timestamp

    @builtins.property
    def data_handle(self) -> "api_Handle":
        return self._data_handle

    @builtins.property
    def frame_rate(self) -> float:
        """The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
        """
        return self._frame_rate

    @builtins.property
    def duration_seconds(self) -> float:
        return self._duration_seconds

    @builtins.property
    def timestamps(self) -> "scout_video_api_SegmentTimestamps":
        return self._timestamps

    @builtins.property
    def segment_end_timestamp(self) -> "api_Timestamp":
        return self._segment_end_timestamp


scout_video_api_CreateSegment.__name__ = "CreateSegment"
scout_video_api_CreateSegment.__qualname__ = "CreateSegment"
scout_video_api_CreateSegment.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateSegmentsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[scout_video_api_CreateSegment]),
            'series_uuid': ConjureFieldDefinition('seriesUuid', OptionalTypeWrapper[str]),
            'over_write_segments': ConjureFieldDefinition('overWriteSegments', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_requests', '_series_uuid', '_over_write_segments']

    def __init__(self, requests: List["scout_video_api_CreateSegment"], over_write_segments: Optional[bool] = None, series_uuid: Optional[str] = None) -> None:
        self._requests = requests
        self._series_uuid = series_uuid
        self._over_write_segments = over_write_segments

    @builtins.property
    def requests(self) -> List["scout_video_api_CreateSegment"]:
        return self._requests

    @builtins.property
    def series_uuid(self) -> Optional[str]:
        return self._series_uuid

    @builtins.property
    def over_write_segments(self) -> Optional[bool]:
        """If true, overlapping segments from other video files within the same video will be deleted
before inserting new segments. The cached segment metadata for affected files will be recomputed.
        """
        return self._over_write_segments


scout_video_api_CreateSegmentsRequest.__name__ = "CreateSegmentsRequest"
scout_video_api_CreateSegmentsRequest.__qualname__ = "CreateSegmentsRequest"
scout_video_api_CreateSegmentsRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateSegmentsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'segments': ConjureFieldDefinition('segments', List[scout_video_api_Segment])
        }

    __slots__: List[str] = ['_segments']

    def __init__(self, segments: List["scout_video_api_Segment"]) -> None:
        self._segments = segments

    @builtins.property
    def segments(self) -> List["scout_video_api_Segment"]:
        return self._segments


scout_video_api_CreateSegmentsResponse.__name__ = "CreateSegmentsResponse"
scout_video_api_CreateSegmentsResponse.__qualname__ = "CreateSegmentsResponse"
scout_video_api_CreateSegmentsResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateSegmentsV2Request(ConjureBeanType):
    """Request to create video segments for channel-based ingestion. Internal use only.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', api_rids_DatasetRid),
            'dataset_file_id': ConjureFieldDefinition('datasetFileId', str),
            'requests': ConjureFieldDefinition('requests', List[scout_video_api_CreateSegment]),
            'series_uuid': ConjureFieldDefinition('seriesUuid', str),
            'over_write_segments': ConjureFieldDefinition('overWriteSegments', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_dataset_rid', '_dataset_file_id', '_requests', '_series_uuid', '_over_write_segments']

    def __init__(self, dataset_file_id: str, dataset_rid: str, requests: List["scout_video_api_CreateSegment"], series_uuid: str, over_write_segments: Optional[bool] = None) -> None:
        self._dataset_rid = dataset_rid
        self._dataset_file_id = dataset_file_id
        self._requests = requests
        self._series_uuid = series_uuid
        self._over_write_segments = over_write_segments

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def dataset_file_id(self) -> str:
        return self._dataset_file_id

    @builtins.property
    def requests(self) -> List["scout_video_api_CreateSegment"]:
        return self._requests

    @builtins.property
    def series_uuid(self) -> str:
        return self._series_uuid

    @builtins.property
    def over_write_segments(self) -> Optional[bool]:
        """If true, overlapping segments from other dataset files within the same series will be deleted
before inserting new segments. The cached segment metadata for affected files will be recomputed.
        """
        return self._over_write_segments


scout_video_api_CreateSegmentsV2Request.__name__ = "CreateSegmentsV2Request"
scout_video_api_CreateSegmentsV2Request.__qualname__ = "CreateSegmentsV2Request"
scout_video_api_CreateSegmentsV2Request.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateSegmentsV2Response(ConjureBeanType):
    """Response for creating V2 segments. Internal use only.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'segments': ConjureFieldDefinition('segments', List[scout_video_api_SegmentV2])
        }

    __slots__: List[str] = ['_segments']

    def __init__(self, segments: List["scout_video_api_SegmentV2"]) -> None:
        self._segments = segments

    @builtins.property
    def segments(self) -> List["scout_video_api_SegmentV2"]:
        return self._segments


scout_video_api_CreateSegmentsV2Response.__name__ = "CreateSegmentsV2Response"
scout_video_api_CreateSegmentsV2Response.__qualname__ = "CreateSegmentsV2Response"
scout_video_api_CreateSegmentsV2Response.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateVideoFileRequest(ConjureBeanType):
    """Request to create and persist a video file
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_video_api_VideoFileOriginMetadata),
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'raw_file_size': ConjureFieldDefinition('rawFileSize', int)
        }

    __slots__: List[str] = ['_title', '_description', '_origin_metadata', '_video_rid', '_raw_file_size']

    def __init__(self, origin_metadata: "scout_video_api_VideoFileOriginMetadata", raw_file_size: int, title: str, video_rid: str, description: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._origin_metadata = origin_metadata
        self._video_rid = video_rid
        self._raw_file_size = raw_file_size

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def origin_metadata(self) -> "scout_video_api_VideoFileOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def raw_file_size(self) -> int:
        """The size of the pre-processed raw video file in bytes.
        """
        return self._raw_file_size


scout_video_api_CreateVideoFileRequest.__name__ = "CreateVideoFileRequest"
scout_video_api_CreateVideoFileRequest.__qualname__ = "CreateVideoFileRequest"
scout_video_api_CreateVideoFileRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_CreateVideoRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'origin_metadata': ConjureFieldDefinition('originMetadata', OptionalTypeWrapper[scout_video_api_VideoOriginMetadata]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid]),
            'marking_rids': ConjureFieldDefinition('markingRids', List[scout_rids_api_MarkingRid])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_origin_metadata', '_workspace', '_marking_rids']

    def __init__(self, labels: List[str], marking_rids: List[str], properties: Dict[str, str], title: str, description: Optional[str] = None, origin_metadata: Optional["scout_video_api_VideoOriginMetadata"] = None, workspace: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._origin_metadata = origin_metadata
        self._workspace = workspace
        self._marking_rids = marking_rids

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def origin_metadata(self) -> Optional["scout_video_api_VideoOriginMetadata"]:
        return self._origin_metadata

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the video. If not provided, the video will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
        """
        return self._workspace

    @builtins.property
    def marking_rids(self) -> List[str]:
        """The markings to apply to the created video.
If not provided, the video will be visible to all users in the same workspace.
        """
        return self._marking_rids


scout_video_api_CreateVideoRequest.__name__ = "CreateVideoRequest"
scout_video_api_CreateVideoRequest.__qualname__ = "CreateVideoRequest"
scout_video_api_CreateVideoRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_DetailedIngestStatus(ConjureUnionType):
    _success: Optional["scout_video_api_SuccessIngestStatus"] = None
    _error: Optional["scout_video_api_ErrorIngestStatus"] = None
    _in_progress: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_video_api_SuccessIngestStatus),
            'error': ConjureFieldDefinition('error', scout_video_api_ErrorIngestStatus),
            'in_progress': ConjureFieldDefinition('inProgress', float)
        }

    def __init__(
            self,
            success: Optional["scout_video_api_SuccessIngestStatus"] = None,
            error: Optional["scout_video_api_ErrorIngestStatus"] = None,
            in_progress: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_video_api_SuccessIngestStatus"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_video_api_ErrorIngestStatus"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional[float]:
        """A number between 0 and 1 representing percentage progress.
        """
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_DetailedIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_DetailedIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_video_api_DetailedIngestStatus.__name__ = "DetailedIngestStatus"
scout_video_api_DetailedIngestStatus.__qualname__ = "DetailedIngestStatus"
scout_video_api_DetailedIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_DetailedIngestStatusVisitor:

    @abstractmethod
    def _success(self, success: "scout_video_api_SuccessIngestStatus") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_video_api_ErrorIngestStatus") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: float) -> Any:
        pass


scout_video_api_DetailedIngestStatusVisitor.__name__ = "DetailedIngestStatusVisitor"
scout_video_api_DetailedIngestStatusVisitor.__qualname__ = "DetailedIngestStatusVisitor"
scout_video_api_DetailedIngestStatusVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_EnrichedVideoIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'status': ConjureFieldDefinition('status', scout_video_api_VideoIngestStatus),
            'file_ingest_status': ConjureFieldDefinition('fileIngestStatus', Dict[api_rids_VideoFileRid, scout_video_api_VideoFileIngestStatus]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_status', '_file_ingest_status', '_next_page_token']

    def __init__(self, file_ingest_status: Dict[str, "scout_video_api_VideoFileIngestStatus"], status: "scout_video_api_VideoIngestStatus", next_page_token: Optional[str] = None) -> None:
        self._status = status
        self._file_ingest_status = file_ingest_status
        self._next_page_token = next_page_token

    @builtins.property
    def status(self) -> "scout_video_api_VideoIngestStatus":
        return self._status

    @builtins.property
    def file_ingest_status(self) -> Dict[str, "scout_video_api_VideoFileIngestStatus"]:
        return self._file_ingest_status

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_video_api_EnrichedVideoIngestStatus.__name__ = "EnrichedVideoIngestStatus"
scout_video_api_EnrichedVideoIngestStatus.__qualname__ = "EnrichedVideoIngestStatus"
scout_video_api_EnrichedVideoIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_ErrorIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'errors': ConjureFieldDefinition('errors', List[scout_video_api_IngestError])
        }

    __slots__: List[str] = ['_errors']

    def __init__(self, errors: List["scout_video_api_IngestError"]) -> None:
        self._errors = errors

    @builtins.property
    def errors(self) -> List["scout_video_api_IngestError"]:
        return self._errors


scout_video_api_ErrorIngestStatus.__name__ = "ErrorIngestStatus"
scout_video_api_ErrorIngestStatus.__qualname__ = "ErrorIngestStatus"
scout_video_api_ErrorIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_FileSummary(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'file_rid': ConjureFieldDefinition('fileRid', api_rids_VideoFileRid),
            'bounds': ConjureFieldDefinition('bounds', scout_video_api_Bounds)
        }

    __slots__: List[str] = ['_file_rid', '_bounds']

    def __init__(self, bounds: "scout_video_api_Bounds", file_rid: str) -> None:
        self._file_rid = file_rid
        self._bounds = bounds

    @builtins.property
    def file_rid(self) -> str:
        return self._file_rid

    @builtins.property
    def bounds(self) -> "scout_video_api_Bounds":
        return self._bounds


scout_video_api_FileSummary.__name__ = "FileSummary"
scout_video_api_FileSummary.__qualname__ = "FileSummary"
scout_video_api_FileSummary.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GenerateWhepStreamResponse(ConjureBeanType):
    """Response with WHEP URL, ICE servers, and token for playback
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'whep_url': ConjureFieldDefinition('whepUrl', str),
            'ice_servers': ConjureFieldDefinition('iceServers', List[scout_video_api_IceServer]),
            'token': ConjureFieldDefinition('token', str)
        }

    __slots__: List[str] = ['_whep_url', '_ice_servers', '_token']

    def __init__(self, ice_servers: List["scout_video_api_IceServer"], token: str, whep_url: str) -> None:
        self._whep_url = whep_url
        self._ice_servers = ice_servers
        self._token = token

    @builtins.property
    def whep_url(self) -> str:
        return self._whep_url

    @builtins.property
    def ice_servers(self) -> List["scout_video_api_IceServer"]:
        return self._ice_servers

    @builtins.property
    def token(self) -> str:
        return self._token


scout_video_api_GenerateWhepStreamResponse.__name__ = "GenerateWhepStreamResponse"
scout_video_api_GenerateWhepStreamResponse.__qualname__ = "GenerateWhepStreamResponse"
scout_video_api_GenerateWhepStreamResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GenerateWhipStreamResponse(ConjureBeanType):
    """Response with WHIP URL and ICE servers for publishing
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'stream_id': ConjureFieldDefinition('streamId', str),
            'whip_url': ConjureFieldDefinition('whipUrl', str),
            'ice_servers': ConjureFieldDefinition('iceServers', List[scout_video_api_IceServer])
        }

    __slots__: List[str] = ['_stream_id', '_whip_url', '_ice_servers']

    def __init__(self, ice_servers: List["scout_video_api_IceServer"], stream_id: str, whip_url: str) -> None:
        self._stream_id = stream_id
        self._whip_url = whip_url
        self._ice_servers = ice_servers

    @builtins.property
    def stream_id(self) -> str:
        return self._stream_id

    @builtins.property
    def whip_url(self) -> str:
        return self._whip_url

    @builtins.property
    def ice_servers(self) -> List["scout_video_api_IceServer"]:
        return self._ice_servers


scout_video_api_GenerateWhipStreamResponse.__name__ = "GenerateWhipStreamResponse"
scout_video_api_GenerateWhipStreamResponse.__qualname__ = "GenerateWhipStreamResponse"
scout_video_api_GenerateWhipStreamResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetEnrichedVideoIngestStatusRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_video_rid', '_token']

    def __init__(self, video_rid: str, token: Optional[str] = None) -> None:
        self._video_rid = video_rid
        self._token = token

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token


scout_video_api_GetEnrichedVideoIngestStatusRequest.__name__ = "GetEnrichedVideoIngestStatusRequest"
scout_video_api_GetEnrichedVideoIngestStatusRequest.__qualname__ = "GetEnrichedVideoIngestStatusRequest"
scout_video_api_GetEnrichedVideoIngestStatusRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetFileSummariesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_video_api_Bounds])
        }

    __slots__: List[str] = ['_bounds']

    def __init__(self, bounds: Optional["scout_video_api_Bounds"] = None) -> None:
        self._bounds = bounds

    @builtins.property
    def bounds(self) -> Optional["scout_video_api_Bounds"]:
        return self._bounds


scout_video_api_GetFileSummariesRequest.__name__ = "GetFileSummariesRequest"
scout_video_api_GetFileSummariesRequest.__qualname__ = "GetFileSummariesRequest"
scout_video_api_GetFileSummariesRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetFileSummariesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'file_summaries': ConjureFieldDefinition('fileSummaries', List[scout_video_api_FileSummary])
        }

    __slots__: List[str] = ['_file_summaries']

    def __init__(self, file_summaries: List["scout_video_api_FileSummary"]) -> None:
        self._file_summaries = file_summaries

    @builtins.property
    def file_summaries(self) -> List["scout_video_api_FileSummary"]:
        return self._file_summaries


scout_video_api_GetFileSummariesResponse.__name__ = "GetFileSummariesResponse"
scout_video_api_GetFileSummariesResponse.__qualname__ = "GetFileSummariesResponse"
scout_video_api_GetFileSummariesResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetIngestStatusResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_video_api_VideoFileIngestStatus)
        }

    __slots__: List[str] = ['_ingest_status']

    def __init__(self, ingest_status: "scout_video_api_VideoFileIngestStatus") -> None:
        self._ingest_status = ingest_status

    @builtins.property
    def ingest_status(self) -> "scout_video_api_VideoFileIngestStatus":
        return self._ingest_status


scout_video_api_GetIngestStatusResponse.__name__ = "GetIngestStatusResponse"
scout_video_api_GetIngestStatusResponse.__qualname__ = "GetIngestStatusResponse"
scout_video_api_GetIngestStatusResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetPlaylistInBoundsForChannelRequest(ConjureBeanType):
    """Request to get playlist for a video channel series.
Uses channel + tags to resolve to video series metadata within the specified video.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_series': ConjureFieldDefinition('channelSeries', scout_video_api_VideoChannelSeries),
            'bounds': ConjureFieldDefinition('bounds', scout_video_api_Bounds)
        }

    __slots__: List[str] = ['_channel_series', '_bounds']

    def __init__(self, bounds: "scout_video_api_Bounds", channel_series: "scout_video_api_VideoChannelSeries") -> None:
        self._channel_series = channel_series
        self._bounds = bounds

    @builtins.property
    def channel_series(self) -> "scout_video_api_VideoChannelSeries":
        return self._channel_series

    @builtins.property
    def bounds(self) -> "scout_video_api_Bounds":
        return self._bounds


scout_video_api_GetPlaylistInBoundsForChannelRequest.__name__ = "GetPlaylistInBoundsForChannelRequest"
scout_video_api_GetPlaylistInBoundsForChannelRequest.__qualname__ = "GetPlaylistInBoundsForChannelRequest"
scout_video_api_GetPlaylistInBoundsForChannelRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetPlaylistInBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_video_api_Bounds])
        }

    __slots__: List[str] = ['_bounds']

    def __init__(self, bounds: Optional["scout_video_api_Bounds"] = None) -> None:
        self._bounds = bounds

    @builtins.property
    def bounds(self) -> Optional["scout_video_api_Bounds"]:
        return self._bounds


scout_video_api_GetPlaylistInBoundsRequest.__name__ = "GetPlaylistInBoundsRequest"
scout_video_api_GetPlaylistInBoundsRequest.__qualname__ = "GetPlaylistInBoundsRequest"
scout_video_api_GetPlaylistInBoundsRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetSegmentByTimestampRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'view_range_start': ConjureFieldDefinition('viewRangeStart', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_timestamp', '_view_range_start']

    def __init__(self, timestamp: "api_Timestamp", view_range_start: Optional["api_Timestamp"] = None) -> None:
        self._timestamp = timestamp
        self._view_range_start = view_range_start

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def view_range_start(self) -> Optional["api_Timestamp"]:
        """The start of the view range used to dynamically calculate media timestamps. The first segment with an 
overlap with the time bounds will have its minimum media timestamp set to 0, with every subsequent
segment building media time cumulatively from that offset. This will determine the starting media
timestamp of the returned segment. The view range should be the same as the one requested to get the
playlist and segment summaries.
        """
        return self._view_range_start


scout_video_api_GetSegmentByTimestampRequest.__name__ = "GetSegmentByTimestampRequest"
scout_video_api_GetSegmentByTimestampRequest.__qualname__ = "GetSegmentByTimestampRequest"
scout_video_api_GetSegmentByTimestampRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetSegmentByTimestampV2Request(ConjureBeanType):
    """Request to get a segment by timestamp for a video series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_series': ConjureFieldDefinition('channelSeries', scout_video_api_VideoChannelSeries),
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'view_range_start': ConjureFieldDefinition('viewRangeStart', OptionalTypeWrapper[api_Timestamp])
        }

    __slots__: List[str] = ['_channel_series', '_timestamp', '_view_range_start']

    def __init__(self, channel_series: "scout_video_api_VideoChannelSeries", timestamp: "api_Timestamp", view_range_start: Optional["api_Timestamp"] = None) -> None:
        self._channel_series = channel_series
        self._timestamp = timestamp
        self._view_range_start = view_range_start

    @builtins.property
    def channel_series(self) -> "scout_video_api_VideoChannelSeries":
        return self._channel_series

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def view_range_start(self) -> Optional["api_Timestamp"]:
        """The start of the view range used to dynamically calculate media timestamps. The first segment with an 
overlap with the time bounds will have its minimum media timestamp set to 0, with every subsequent
segment building media time cumulatively from that offset.
        """
        return self._view_range_start


scout_video_api_GetSegmentByTimestampV2Request.__name__ = "GetSegmentByTimestampV2Request"
scout_video_api_GetSegmentByTimestampV2Request.__qualname__ = "GetSegmentByTimestampV2Request"
scout_video_api_GetSegmentByTimestampV2Request.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetSegmentMetadataForChannelRequest(ConjureBeanType):
    """Request to get aggregated segment metadata for a video channel series.
Uses channel + tags to resolve to video series metadata.
Optionally filter by time bounds.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_series': ConjureFieldDefinition('channelSeries', scout_video_api_VideoChannelSeries),
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_video_api_Bounds])
        }

    __slots__: List[str] = ['_channel_series', '_bounds']

    def __init__(self, channel_series: "scout_video_api_VideoChannelSeries", bounds: Optional["scout_video_api_Bounds"] = None) -> None:
        self._channel_series = channel_series
        self._bounds = bounds

    @builtins.property
    def channel_series(self) -> "scout_video_api_VideoChannelSeries":
        return self._channel_series

    @builtins.property
    def bounds(self) -> Optional["scout_video_api_Bounds"]:
        return self._bounds


scout_video_api_GetSegmentMetadataForChannelRequest.__name__ = "GetSegmentMetadataForChannelRequest"
scout_video_api_GetSegmentMetadataForChannelRequest.__qualname__ = "GetSegmentMetadataForChannelRequest"
scout_video_api_GetSegmentMetadataForChannelRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetSegmentSummariesInBoundsForChannelRequest(ConjureBeanType):
    """Request to get segment summaries for a video channel series.
Uses channel + tags to resolve to video series metadata within the specified bounds.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_series': ConjureFieldDefinition('channelSeries', scout_video_api_VideoChannelSeries),
            'bounds': ConjureFieldDefinition('bounds', scout_video_api_Bounds)
        }

    __slots__: List[str] = ['_channel_series', '_bounds']

    def __init__(self, bounds: "scout_video_api_Bounds", channel_series: "scout_video_api_VideoChannelSeries") -> None:
        self._channel_series = channel_series
        self._bounds = bounds

    @builtins.property
    def channel_series(self) -> "scout_video_api_VideoChannelSeries":
        return self._channel_series

    @builtins.property
    def bounds(self) -> "scout_video_api_Bounds":
        return self._bounds


scout_video_api_GetSegmentSummariesInBoundsForChannelRequest.__name__ = "GetSegmentSummariesInBoundsForChannelRequest"
scout_video_api_GetSegmentSummariesInBoundsForChannelRequest.__qualname__ = "GetSegmentSummariesInBoundsForChannelRequest"
scout_video_api_GetSegmentSummariesInBoundsForChannelRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetSegmentSummariesInBoundsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bounds': ConjureFieldDefinition('bounds', OptionalTypeWrapper[scout_video_api_Bounds])
        }

    __slots__: List[str] = ['_bounds']

    def __init__(self, bounds: Optional["scout_video_api_Bounds"] = None) -> None:
        self._bounds = bounds

    @builtins.property
    def bounds(self) -> Optional["scout_video_api_Bounds"]:
        return self._bounds


scout_video_api_GetSegmentSummariesInBoundsRequest.__name__ = "GetSegmentSummariesInBoundsRequest"
scout_video_api_GetSegmentSummariesInBoundsRequest.__qualname__ = "GetSegmentSummariesInBoundsRequest"
scout_video_api_GetSegmentSummariesInBoundsRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetVideosRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rids': ConjureFieldDefinition('videoRids', List[api_rids_VideoRid])
        }

    __slots__: List[str] = ['_video_rids']

    def __init__(self, video_rids: List[str]) -> None:
        self._video_rids = video_rids

    @builtins.property
    def video_rids(self) -> List[str]:
        return self._video_rids


scout_video_api_GetVideosRequest.__name__ = "GetVideosRequest"
scout_video_api_GetVideosRequest.__qualname__ = "GetVideosRequest"
scout_video_api_GetVideosRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_GetVideosResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[scout_video_api_Video])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["scout_video_api_Video"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["scout_video_api_Video"]:
        return self._responses


scout_video_api_GetVideosResponse.__name__ = "GetVideosResponse"
scout_video_api_GetVideosResponse.__qualname__ = "GetVideosResponse"
scout_video_api_GetVideosResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_IceServer(ConjureBeanType):
    """WebRTC ICE server configuration
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'urls': ConjureFieldDefinition('urls', List[str]),
            'username': ConjureFieldDefinition('username', OptionalTypeWrapper[str]),
            'credential': ConjureFieldDefinition('credential', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_urls', '_username', '_credential']

    def __init__(self, urls: List[str], credential: Optional[str] = None, username: Optional[str] = None) -> None:
        self._urls = urls
        self._username = username
        self._credential = credential

    @builtins.property
    def urls(self) -> List[str]:
        return self._urls

    @builtins.property
    def username(self) -> Optional[str]:
        return self._username

    @builtins.property
    def credential(self) -> Optional[str]:
        return self._credential


scout_video_api_IceServer.__name__ = "IceServer"
scout_video_api_IceServer.__qualname__ = "IceServer"
scout_video_api_IceServer.__module__ = "nominal_api.scout_video_api"


class scout_video_api_IngestError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'error_type': ConjureFieldDefinition('errorType', scout_video_api_ErrorType),
            'message': ConjureFieldDefinition('message', str)
        }

    __slots__: List[str] = ['_error_type', '_message']

    def __init__(self, error_type: str, message: str) -> None:
        self._error_type = error_type
        self._message = message

    @builtins.property
    def error_type(self) -> str:
        return self._error_type

    @builtins.property
    def message(self) -> str:
        return self._message


scout_video_api_IngestError.__name__ = "IngestError"
scout_video_api_IngestError.__qualname__ = "IngestError"
scout_video_api_IngestError.__module__ = "nominal_api.scout_video_api"


class scout_video_api_ListFilesInVideoRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_video_rid', '_token']

    def __init__(self, video_rid: str, token: Optional[str] = None) -> None:
        self._video_rid = video_rid
        self._token = token

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token


scout_video_api_ListFilesInVideoRequest.__name__ = "ListFilesInVideoRequest"
scout_video_api_ListFilesInVideoRequest.__qualname__ = "ListFilesInVideoRequest"
scout_video_api_ListFilesInVideoRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_ListFilesInVideoResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'files': ConjureFieldDefinition('files', List[scout_video_api_VideoFile]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_files', '_next_page_token']

    def __init__(self, files: List["scout_video_api_VideoFile"], next_page_token: Optional[str] = None) -> None:
        self._files = files
        self._next_page_token = next_page_token

    @builtins.property
    def files(self) -> List["scout_video_api_VideoFile"]:
        return self._files

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_video_api_ListFilesInVideoResponse.__name__ = "ListFilesInVideoResponse"
scout_video_api_ListFilesInVideoResponse.__qualname__ = "ListFilesInVideoResponse"
scout_video_api_ListFilesInVideoResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_McapTimestampManifest(ConjureBeanType):
    """Timestamps are derived from the mcap file containing the video frames.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'mcap_channel_locator': ConjureFieldDefinition('mcapChannelLocator', api_McapChannelLocator)
        }

    __slots__: List[str] = ['_mcap_channel_locator']

    def __init__(self, mcap_channel_locator: "api_McapChannelLocator") -> None:
        self._mcap_channel_locator = mcap_channel_locator

    @builtins.property
    def mcap_channel_locator(self) -> "api_McapChannelLocator":
        return self._mcap_channel_locator


scout_video_api_McapTimestampManifest.__name__ = "McapTimestampManifest"
scout_video_api_McapTimestampManifest.__qualname__ = "McapTimestampManifest"
scout_video_api_McapTimestampManifest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_NoTimestampManifest(ConjureBeanType):
    """these values will not be updated after ingest time, to allow for resetting. The updated values are stored
implicitly through the segment timestamps.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', api_Timestamp),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[scout_video_api_ScaleParameter])
        }

    __slots__: List[str] = ['_starting_timestamp', '_scale_parameter']

    def __init__(self, starting_timestamp: "api_Timestamp", scale_parameter: Optional["scout_video_api_ScaleParameter"] = None) -> None:
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def starting_timestamp(self) -> "api_Timestamp":
        """Specifies the original starting timestamp of the video.
        """
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["scout_video_api_ScaleParameter"]:
        """A field that specifies that the frame rate of the video does not match the frame rate of the camera | i.e. a slowed down or sped up video. Can specify either the camera frame rate or the absolute end time.
        """
        return self._scale_parameter


scout_video_api_NoTimestampManifest.__name__ = "NoTimestampManifest"
scout_video_api_NoTimestampManifest.__qualname__ = "NoTimestampManifest"
scout_video_api_NoTimestampManifest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_ScaleParameter(ConjureUnionType):
    _true_frame_rate: Optional[float] = None
    _ending_timestamp: Optional["api_Timestamp"] = None
    _scale_factor: Optional[float] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'true_frame_rate': ConjureFieldDefinition('trueFrameRate', float),
            'ending_timestamp': ConjureFieldDefinition('endingTimestamp', api_Timestamp),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float)
        }

    def __init__(
            self,
            true_frame_rate: Optional[float] = None,
            ending_timestamp: Optional["api_Timestamp"] = None,
            scale_factor: Optional[float] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (true_frame_rate is not None) + (ending_timestamp is not None) + (scale_factor is not None) != 1:
                raise ValueError('a union must contain a single member')

            if true_frame_rate is not None:
                self._true_frame_rate = true_frame_rate
                self._type = 'trueFrameRate'
            if ending_timestamp is not None:
                self._ending_timestamp = ending_timestamp
                self._type = 'endingTimestamp'
            if scale_factor is not None:
                self._scale_factor = scale_factor
                self._type = 'scaleFactor'

        elif type_of_union == 'trueFrameRate':
            if true_frame_rate is None:
                raise ValueError('a union value must not be None')
            self._true_frame_rate = true_frame_rate
            self._type = 'trueFrameRate'
        elif type_of_union == 'endingTimestamp':
            if ending_timestamp is None:
                raise ValueError('a union value must not be None')
            self._ending_timestamp = ending_timestamp
            self._type = 'endingTimestamp'
        elif type_of_union == 'scaleFactor':
            if scale_factor is None:
                raise ValueError('a union value must not be None')
            self._scale_factor = scale_factor
            self._type = 'scaleFactor'

    @builtins.property
    def true_frame_rate(self) -> Optional[float]:
        return self._true_frame_rate

    @builtins.property
    def ending_timestamp(self) -> Optional["api_Timestamp"]:
        return self._ending_timestamp

    @builtins.property
    def scale_factor(self) -> Optional[float]:
        """the scale factor can be used to calculate whether media duration differs from a video's | real duration, and if so, the true frame rate of the camera. The video time will thus be scaled | by the ratio of the real duration to media duration, or media frame rate to true frame rate.
        """
        return self._scale_factor

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_ScaleParameterVisitor):
            raise ValueError('{} is not an instance of scout_video_api_ScaleParameterVisitor'.format(visitor.__class__.__name__))
        if self._type == 'trueFrameRate' and self.true_frame_rate is not None:
            return visitor._true_frame_rate(self.true_frame_rate)
        if self._type == 'endingTimestamp' and self.ending_timestamp is not None:
            return visitor._ending_timestamp(self.ending_timestamp)
        if self._type == 'scaleFactor' and self.scale_factor is not None:
            return visitor._scale_factor(self.scale_factor)


scout_video_api_ScaleParameter.__name__ = "ScaleParameter"
scout_video_api_ScaleParameter.__qualname__ = "ScaleParameter"
scout_video_api_ScaleParameter.__module__ = "nominal_api.scout_video_api"


class scout_video_api_ScaleParameterVisitor:

    @abstractmethod
    def _true_frame_rate(self, true_frame_rate: float) -> Any:
        pass

    @abstractmethod
    def _ending_timestamp(self, ending_timestamp: "api_Timestamp") -> Any:
        pass

    @abstractmethod
    def _scale_factor(self, scale_factor: float) -> Any:
        pass


scout_video_api_ScaleParameterVisitor.__name__ = "ScaleParameterVisitor"
scout_video_api_ScaleParameterVisitor.__qualname__ = "ScaleParameterVisitor"
scout_video_api_ScaleParameterVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SearchVideosQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["scout_video_api_SearchVideosQuery"]] = None
    _or_: Optional[List["scout_video_api_SearchVideosQuery"]] = None
    _ingest_status: Optional["api_IngestStatus"] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[scout_video_api_SearchVideosQuery]),
            'or_': ConjureFieldDefinition('or', List[scout_video_api_SearchVideosQuery]),
            'ingest_status': ConjureFieldDefinition('ingestStatus', api_IngestStatus),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["scout_video_api_SearchVideosQuery"]] = None,
            or_: Optional[List["scout_video_api_SearchVideosQuery"]] = None,
            ingest_status: Optional["api_IngestStatus"] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (ingest_status is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if ingest_status is not None:
                self._ingest_status = ingest_status
                self._type = 'ingestStatus'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'ingestStatus':
            if ingest_status is None:
                raise ValueError('a union value must not be None')
            self._ingest_status = ingest_status
            self._type = 'ingestStatus'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["scout_video_api_SearchVideosQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["scout_video_api_SearchVideosQuery"]]:
        return self._or_

    @builtins.property
    def ingest_status(self) -> Optional["api_IngestStatus"]:
        return self._ingest_status

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_SearchVideosQueryVisitor):
            raise ValueError('{} is not an instance of scout_video_api_SearchVideosQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'ingestStatus' and self.ingest_status is not None:
            return visitor._ingest_status(self.ingest_status)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


scout_video_api_SearchVideosQuery.__name__ = "SearchVideosQuery"
scout_video_api_SearchVideosQuery.__qualname__ = "SearchVideosQuery"
scout_video_api_SearchVideosQuery.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SearchVideosQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["scout_video_api_SearchVideosQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["scout_video_api_SearchVideosQuery"]) -> Any:
        pass

    @abstractmethod
    def _ingest_status(self, ingest_status: "api_IngestStatus") -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


scout_video_api_SearchVideosQueryVisitor.__name__ = "SearchVideosQueryVisitor"
scout_video_api_SearchVideosQueryVisitor.__qualname__ = "SearchVideosQueryVisitor"
scout_video_api_SearchVideosQueryVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SearchVideosRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', scout_video_api_SearchVideosQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token]),
            'sort_options': ConjureFieldDefinition('sortOptions', scout_video_api_SortOptions),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_page_size', '_token', '_sort_options', '_archived_statuses']

    def __init__(self, query: "scout_video_api_SearchVideosQuery", sort_options: "scout_video_api_SortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._token = token
        self._sort_options = sort_options
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "scout_video_api_SearchVideosQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1_000.
        """
        return self._page_size

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def sort_options(self) -> "scout_video_api_SortOptions":
        return self._sort_options

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived videos in search.
        """
        return self._archived_statuses


scout_video_api_SearchVideosRequest.__name__ = "SearchVideosRequest"
scout_video_api_SearchVideosRequest.__qualname__ = "SearchVideosRequest"
scout_video_api_SearchVideosRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SearchVideosResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[scout_video_api_Video]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["scout_video_api_Video"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["scout_video_api_Video"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


scout_video_api_SearchVideosResponse.__name__ = "SearchVideosResponse"
scout_video_api_SearchVideosResponse.__qualname__ = "SearchVideosResponse"
scout_video_api_SearchVideosResponse.__module__ = "nominal_api.scout_video_api"


class scout_video_api_Segment(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_SegmentRid),
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'data_handle': ConjureFieldDefinition('dataHandle', api_Handle),
            'frame_rate': ConjureFieldDefinition('frameRate', float),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', float),
            'timestamps': ConjureFieldDefinition('timestamps', scout_video_api_SegmentTimestamps)
        }

    __slots__: List[str] = ['_rid', '_video_rid', '_data_handle', '_frame_rate', '_duration_seconds', '_timestamps']

    def __init__(self, data_handle: "api_Handle", duration_seconds: float, frame_rate: float, rid: str, timestamps: "scout_video_api_SegmentTimestamps", video_rid: str) -> None:
        self._rid = rid
        self._video_rid = video_rid
        self._data_handle = data_handle
        self._frame_rate = frame_rate
        self._duration_seconds = duration_seconds
        self._timestamps = timestamps

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def data_handle(self) -> "api_Handle":
        return self._data_handle

    @builtins.property
    def frame_rate(self) -> float:
        """The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
        """
        return self._frame_rate

    @builtins.property
    def duration_seconds(self) -> float:
        """The duration of a segment in media time.
        """
        return self._duration_seconds

    @builtins.property
    def timestamps(self) -> "scout_video_api_SegmentTimestamps":
        """for videos with frame-level timestamps, we provide mappings, otherwise we just include a single list
of timestamps.
        """
        return self._timestamps


scout_video_api_Segment.__name__ = "Segment"
scout_video_api_Segment.__qualname__ = "Segment"
scout_video_api_Segment.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SegmentSummary(ConjureBeanType):
    """Bounding timestamps for the frames within a segment. For non-frame-mapped videos, the min and max media
timestamps will be empty.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'min_media_timestamp': ConjureFieldDefinition('minMediaTimestamp', float),
            'max_media_timestamp': ConjureFieldDefinition('maxMediaTimestamp', float)
        }

    __slots__: List[str] = ['_min_absolute_timestamp', '_max_absolute_timestamp', '_min_media_timestamp', '_max_media_timestamp']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", max_media_timestamp: float, min_absolute_timestamp: "api_Timestamp", min_media_timestamp: float) -> None:
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._min_media_timestamp = min_media_timestamp
        self._max_media_timestamp = max_media_timestamp

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        return self._max_absolute_timestamp

    @builtins.property
    def min_media_timestamp(self) -> float:
        return self._min_media_timestamp

    @builtins.property
    def max_media_timestamp(self) -> float:
        return self._max_media_timestamp


scout_video_api_SegmentSummary.__name__ = "SegmentSummary"
scout_video_api_SegmentSummary.__qualname__ = "SegmentSummary"
scout_video_api_SegmentSummary.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SegmentSummaryV2(ConjureBeanType):
    """Bounding timestamps for the frames within a segment. Includes datasetFileId for V2 channel-based API.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_file_id': ConjureFieldDefinition('datasetFileId', OptionalTypeWrapper[str]),
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'min_media_timestamp': ConjureFieldDefinition('minMediaTimestamp', float),
            'max_media_timestamp': ConjureFieldDefinition('maxMediaTimestamp', float)
        }

    __slots__: List[str] = ['_dataset_file_id', '_min_absolute_timestamp', '_max_absolute_timestamp', '_min_media_timestamp', '_max_media_timestamp']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", max_media_timestamp: float, min_absolute_timestamp: "api_Timestamp", min_media_timestamp: float, dataset_file_id: Optional[str] = None) -> None:
        self._dataset_file_id = dataset_file_id
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._min_media_timestamp = min_media_timestamp
        self._max_media_timestamp = max_media_timestamp

    @builtins.property
    def dataset_file_id(self) -> Optional[str]:
        """The dataset file ID that this segment belongs to.
        """
        return self._dataset_file_id

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        return self._max_absolute_timestamp

    @builtins.property
    def min_media_timestamp(self) -> float:
        return self._min_media_timestamp

    @builtins.property
    def max_media_timestamp(self) -> float:
        return self._max_media_timestamp


scout_video_api_SegmentSummaryV2.__name__ = "SegmentSummaryV2"
scout_video_api_SegmentSummaryV2.__qualname__ = "SegmentSummaryV2"
scout_video_api_SegmentSummaryV2.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SegmentTimestamps(ConjureUnionType):
    """A video segment will either contain timestamps or timestamp mappings depending on whether it is intended to
be frame-mapped. Without a frame-timestamp mapping manifest file, a list of absolute timestamps will be
automatically assigned to each segment based on media timestamps.. Otherwise, media timestamps will be
extracted and mapped to those in the provided manifest.
    """
    _timestamp_mappings: Optional["scout_video_api_TimestampMappings"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp_mappings': ConjureFieldDefinition('timestampMappings', scout_video_api_TimestampMappings)
        }

    def __init__(
            self,
            timestamp_mappings: Optional["scout_video_api_TimestampMappings"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timestamp_mappings is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timestamp_mappings is not None:
                self._timestamp_mappings = timestamp_mappings
                self._type = 'timestampMappings'

        elif type_of_union == 'timestampMappings':
            if timestamp_mappings is None:
                raise ValueError('a union value must not be None')
            self._timestamp_mappings = timestamp_mappings
            self._type = 'timestampMappings'

    @builtins.property
    def timestamp_mappings(self) -> Optional["scout_video_api_TimestampMappings"]:
        return self._timestamp_mappings

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_SegmentTimestampsVisitor):
            raise ValueError('{} is not an instance of scout_video_api_SegmentTimestampsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timestampMappings' and self.timestamp_mappings is not None:
            return visitor._timestamp_mappings(self.timestamp_mappings)


scout_video_api_SegmentTimestamps.__name__ = "SegmentTimestamps"
scout_video_api_SegmentTimestamps.__qualname__ = "SegmentTimestamps"
scout_video_api_SegmentTimestamps.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SegmentTimestampsVisitor:

    @abstractmethod
    def _timestamp_mappings(self, timestamp_mappings: "scout_video_api_TimestampMappings") -> Any:
        pass


scout_video_api_SegmentTimestampsVisitor.__name__ = "SegmentTimestampsVisitor"
scout_video_api_SegmentTimestampsVisitor.__qualname__ = "SegmentTimestampsVisitor"
scout_video_api_SegmentTimestampsVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SegmentV2(ConjureBeanType):
    """Segment for V2 channel-based video API (without videoRid).
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_SegmentRid),
            'dataset_file_id': ConjureFieldDefinition('datasetFileId', OptionalTypeWrapper[str]),
            'data_handle': ConjureFieldDefinition('dataHandle', api_Handle),
            'frame_rate': ConjureFieldDefinition('frameRate', float),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', float),
            'timestamps': ConjureFieldDefinition('timestamps', scout_video_api_SegmentTimestamps)
        }

    __slots__: List[str] = ['_rid', '_dataset_file_id', '_data_handle', '_frame_rate', '_duration_seconds', '_timestamps']

    def __init__(self, data_handle: "api_Handle", duration_seconds: float, frame_rate: float, rid: str, timestamps: "scout_video_api_SegmentTimestamps", dataset_file_id: Optional[str] = None) -> None:
        self._rid = rid
        self._dataset_file_id = dataset_file_id
        self._data_handle = data_handle
        self._frame_rate = frame_rate
        self._duration_seconds = duration_seconds
        self._timestamps = timestamps

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def dataset_file_id(self) -> Optional[str]:
        """The dataset file ID that this segment belongs to.
        """
        return self._dataset_file_id

    @builtins.property
    def data_handle(self) -> "api_Handle":
        return self._data_handle

    @builtins.property
    def frame_rate(self) -> float:
        """The average frame rate (FPS) of the segment calculated as total frames / duration in seconds.
        """
        return self._frame_rate

    @builtins.property
    def duration_seconds(self) -> float:
        """The duration of a segment in media time.
        """
        return self._duration_seconds

    @builtins.property
    def timestamps(self) -> "scout_video_api_SegmentTimestamps":
        """for videos with frame-level timestamps, we provide mappings, otherwise we just include a single list
of timestamps.
        """
        return self._timestamps


scout_video_api_SegmentV2.__name__ = "SegmentV2"
scout_video_api_SegmentV2.__qualname__ = "SegmentV2"
scout_video_api_SegmentV2.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_video_api_SortField.__name__ = "SortField"
scout_video_api_SortField.__qualname__ = "SortField"
scout_video_api_SortField.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', scout_video_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "scout_video_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "scout_video_api_SortField":
        return self._field


scout_video_api_SortOptions.__name__ = "SortOptions"
scout_video_api_SortOptions.__qualname__ = "SortOptions"
scout_video_api_SortOptions.__module__ = "nominal_api.scout_video_api"


class scout_video_api_SuccessIngestStatus(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



scout_video_api_SuccessIngestStatus.__name__ = "SuccessIngestStatus"
scout_video_api_SuccessIngestStatus.__qualname__ = "SuccessIngestStatus"
scout_video_api_SuccessIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_TimestampMappings(ConjureBeanType):
    """contains 2 equal-length lists, which contain the video media time and user-provided absolute time
for the frame at each index. Enables frame-mapping on the front-end.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'media_timestamps': ConjureFieldDefinition('mediaTimestamps', List[float]),
            'absolute_timestamps': ConjureFieldDefinition('absoluteTimestamps', List[api_Timestamp])
        }

    __slots__: List[str] = ['_media_timestamps', '_absolute_timestamps']

    def __init__(self, absolute_timestamps: List["api_Timestamp"], media_timestamps: List[float]) -> None:
        self._media_timestamps = media_timestamps
        self._absolute_timestamps = absolute_timestamps

    @builtins.property
    def media_timestamps(self) -> List[float]:
        return self._media_timestamps

    @builtins.property
    def absolute_timestamps(self) -> List["api_Timestamp"]:
        return self._absolute_timestamps


scout_video_api_TimestampMappings.__name__ = "TimestampMappings"
scout_video_api_TimestampMappings.__qualname__ = "TimestampMappings"
scout_video_api_TimestampMappings.__module__ = "nominal_api.scout_video_api"


class scout_video_api_UpdateIngestStatus(ConjureUnionType):
    _success: Optional["scout_video_api_SuccessIngestStatus"] = None
    _error: Optional["scout_video_api_ErrorIngestStatus"] = None
    _in_progress: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_video_api_SuccessIngestStatus),
            'error': ConjureFieldDefinition('error', scout_video_api_ErrorIngestStatus),
            'in_progress': ConjureFieldDefinition('inProgress', api_Empty)
        }

    def __init__(
            self,
            success: Optional["scout_video_api_SuccessIngestStatus"] = None,
            error: Optional["scout_video_api_ErrorIngestStatus"] = None,
            in_progress: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_video_api_SuccessIngestStatus"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_video_api_ErrorIngestStatus"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["api_Empty"]:
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_UpdateIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_UpdateIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_video_api_UpdateIngestStatus.__name__ = "UpdateIngestStatus"
scout_video_api_UpdateIngestStatus.__qualname__ = "UpdateIngestStatus"
scout_video_api_UpdateIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_UpdateIngestStatusVisitor:

    @abstractmethod
    def _success(self, success: "scout_video_api_SuccessIngestStatus") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_video_api_ErrorIngestStatus") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "api_Empty") -> Any:
        pass


scout_video_api_UpdateIngestStatusVisitor.__name__ = "UpdateIngestStatusVisitor"
scout_video_api_UpdateIngestStatusVisitor.__qualname__ = "UpdateIngestStatusVisitor"
scout_video_api_UpdateIngestStatusVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_UpdateIngestStatusRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video': ConjureFieldDefinition('video', api_rids_VideoRid),
            'ingest_status': ConjureFieldDefinition('ingestStatus', scout_video_api_VideoFileIngestStatus)
        }

    __slots__: List[str] = ['_video', '_ingest_status']

    def __init__(self, ingest_status: "scout_video_api_VideoFileIngestStatus", video: str) -> None:
        self._video = video
        self._ingest_status = ingest_status

    @builtins.property
    def video(self) -> str:
        return self._video

    @builtins.property
    def ingest_status(self) -> "scout_video_api_VideoFileIngestStatus":
        return self._ingest_status


scout_video_api_UpdateIngestStatusRequest.__name__ = "UpdateIngestStatusRequest"
scout_video_api_UpdateIngestStatusRequest.__qualname__ = "UpdateIngestStatusRequest"
scout_video_api_UpdateIngestStatusRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_UpdateVideoFileRequest(ConjureBeanType):
    """Request to update metadata for a given video file.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[scout_video_api_ScaleParameter]),
            'segmented_files_size': ConjureFieldDefinition('segmentedFilesSize', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_title', '_description', '_starting_timestamp', '_scale_parameter', '_segmented_files_size']

    def __init__(self, description: Optional[str] = None, scale_parameter: Optional["scout_video_api_ScaleParameter"] = None, segmented_files_size: Optional[int] = None, starting_timestamp: Optional["api_Timestamp"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter
        self._segmented_files_size = segmented_files_size

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def starting_timestamp(self) -> Optional["api_Timestamp"]:
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["scout_video_api_ScaleParameter"]:
        return self._scale_parameter

    @builtins.property
    def segmented_files_size(self) -> Optional[int]:
        """The total size of all the post-processed segments corresponding to this video file in bytes.
        """
        return self._segmented_files_size


scout_video_api_UpdateVideoFileRequest.__name__ = "UpdateVideoFileRequest"
scout_video_api_UpdateVideoFileRequest.__qualname__ = "UpdateVideoFileRequest"
scout_video_api_UpdateVideoFileRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_UpdateVideoMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title': ConjureFieldDefinition('title', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'starting_timestamp': ConjureFieldDefinition('startingTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'scale_parameter': ConjureFieldDefinition('scaleParameter', OptionalTypeWrapper[scout_video_api_ScaleParameter])
        }

    __slots__: List[str] = ['_title', '_description', '_labels', '_properties', '_starting_timestamp', '_scale_parameter']

    def __init__(self, description: Optional[str] = None, labels: Optional[List[str]] = None, properties: Optional[Dict[str, str]] = None, scale_parameter: Optional["scout_video_api_ScaleParameter"] = None, starting_timestamp: Optional["api_Timestamp"] = None, title: Optional[str] = None) -> None:
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._starting_timestamp = starting_timestamp
        self._scale_parameter = scale_parameter

    @builtins.property
    def title(self) -> Optional[str]:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def starting_timestamp(self) -> Optional["api_Timestamp"]:
        return self._starting_timestamp

    @builtins.property
    def scale_parameter(self) -> Optional["scout_video_api_ScaleParameter"]:
        return self._scale_parameter


scout_video_api_UpdateVideoMetadataRequest.__name__ = "UpdateVideoMetadataRequest"
scout_video_api_UpdateVideoMetadataRequest.__qualname__ = "UpdateVideoMetadataRequest"
scout_video_api_UpdateVideoMetadataRequest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_Video(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_VideoRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool),
            'origin_metadata': ConjureFieldDefinition('originMetadata', OptionalTypeWrapper[scout_video_api_VideoOriginMetadata]),
            'all_segments_metadata': ConjureFieldDefinition('allSegmentsMetadata', OptionalTypeWrapper[scout_video_api_VideoAllSegmentsMetadata])
        }

    __slots__: List[str] = ['_rid', '_title', '_description', '_labels', '_properties', '_created_by', '_created_at', '_is_archived', '_origin_metadata', '_all_segments_metadata']

    def __init__(self, created_at: str, created_by: str, is_archived: bool, labels: List[str], properties: Dict[str, str], rid: str, title: str, all_segments_metadata: Optional["scout_video_api_VideoAllSegmentsMetadata"] = None, description: Optional[str] = None, origin_metadata: Optional["scout_video_api_VideoOriginMetadata"] = None) -> None:
        self._rid = rid
        self._title = title
        self._description = description
        self._labels = labels
        self._properties = properties
        self._created_by = created_by
        self._created_at = created_at
        self._is_archived = is_archived
        self._origin_metadata = origin_metadata
        self._all_segments_metadata = all_segments_metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived

    @builtins.property
    def origin_metadata(self) -> Optional["scout_video_api_VideoOriginMetadata"]:
        return self._origin_metadata

    @builtins.property
    def all_segments_metadata(self) -> Optional["scout_video_api_VideoAllSegmentsMetadata"]:
        return self._all_segments_metadata


scout_video_api_Video.__name__ = "Video"
scout_video_api_Video.__qualname__ = "Video"
scout_video_api_Video.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoAllSegmentsMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_VideoRid),
            'num_frames': ConjureFieldDefinition('numFrames', int),
            'num_segments': ConjureFieldDefinition('numSegments', int),
            'scale_factor': ConjureFieldDefinition('scaleFactor', OptionalTypeWrapper[float]),
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'media_duration_seconds': ConjureFieldDefinition('mediaDurationSeconds', float),
            'media_frame_rate': ConjureFieldDefinition('mediaFrameRate', float),
            'min_timestamp': ConjureFieldDefinition('minTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'max_timestamp': ConjureFieldDefinition('maxTimestamp', OptionalTypeWrapper[api_Timestamp]),
            'duration_seconds': ConjureFieldDefinition('durationSeconds', OptionalTypeWrapper[float]),
            'frame_rate': ConjureFieldDefinition('frameRate', OptionalTypeWrapper[float])
        }

    __slots__: List[str] = ['_rid', '_num_frames', '_num_segments', '_scale_factor', '_min_absolute_timestamp', '_max_absolute_timestamp', '_media_duration_seconds', '_media_frame_rate', '_min_timestamp', '_max_timestamp', '_duration_seconds', '_frame_rate']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", media_duration_seconds: float, media_frame_rate: float, min_absolute_timestamp: "api_Timestamp", num_frames: int, num_segments: int, rid: str, duration_seconds: Optional[float] = None, frame_rate: Optional[float] = None, max_timestamp: Optional["api_Timestamp"] = None, min_timestamp: Optional["api_Timestamp"] = None, scale_factor: Optional[float] = None) -> None:
        self._rid = rid
        self._num_frames = num_frames
        self._num_segments = num_segments
        self._scale_factor = scale_factor
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._media_duration_seconds = media_duration_seconds
        self._media_frame_rate = media_frame_rate
        self._min_timestamp = min_timestamp
        self._max_timestamp = max_timestamp
        self._duration_seconds = duration_seconds
        self._frame_rate = frame_rate

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def num_frames(self) -> int:
        return self._num_frames

    @builtins.property
    def num_segments(self) -> int:
        return self._num_segments

    @builtins.property
    def scale_factor(self) -> Optional[float]:
        """deprecated, in favor of per-file VideoFileSegmentsMetadata scaleFactor. Will be removed after April 15th.
        """
        return self._scale_factor

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        """the timestamp corresponding to absolute starting timestamp plus absolute duration of the video.
        """
        return self._max_absolute_timestamp

    @builtins.property
    def media_duration_seconds(self) -> float:
        return self._media_duration_seconds

    @builtins.property
    def media_frame_rate(self) -> float:
        """The average media frame rate (FPS) of the video calculated as total frames / duration in seconds.
        """
        return self._media_frame_rate

    @builtins.property
    def min_timestamp(self) -> Optional["api_Timestamp"]:
        """deprecated. Will be removed after April 15th.
        """
        return self._min_timestamp

    @builtins.property
    def max_timestamp(self) -> Optional["api_Timestamp"]:
        """deprecated. Will be removed after April 15th.
        """
        return self._max_timestamp

    @builtins.property
    def duration_seconds(self) -> Optional[float]:
        """deprecated. Will be removed after April 15th.
        """
        return self._duration_seconds

    @builtins.property
    def frame_rate(self) -> Optional[float]:
        """deprecated. Will be removed after April 15th.
        """
        return self._frame_rate


scout_video_api_VideoAllSegmentsMetadata.__name__ = "VideoAllSegmentsMetadata"
scout_video_api_VideoAllSegmentsMetadata.__qualname__ = "VideoAllSegmentsMetadata"
scout_video_api_VideoAllSegmentsMetadata.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoAssetChannel(ConjureBeanType):
    """Reference a video channel via an Asset's data scope
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_rid': ConjureFieldDefinition('assetRid', str),
            'data_scope_name': ConjureFieldDefinition('dataScopeName', str),
            'channel': ConjureFieldDefinition('channel', str),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_asset_rid', '_data_scope_name', '_channel', '_tags']

    def __init__(self, asset_rid: str, channel: str, data_scope_name: str, tags: Dict[str, str]) -> None:
        self._asset_rid = asset_rid
        self._data_scope_name = data_scope_name
        self._channel = channel
        self._tags = tags

    @builtins.property
    def asset_rid(self) -> str:
        return self._asset_rid

    @builtins.property
    def data_scope_name(self) -> str:
        return self._data_scope_name

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


scout_video_api_VideoAssetChannel.__name__ = "VideoAssetChannel"
scout_video_api_VideoAssetChannel.__qualname__ = "VideoAssetChannel"
scout_video_api_VideoAssetChannel.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoChannelSegmentsMetadata(ConjureBeanType):
    """Aggregated segment metadata for a video channel series
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'num_frames': ConjureFieldDefinition('numFrames', int),
            'num_segments': ConjureFieldDefinition('numSegments', int),
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'media_duration_seconds': ConjureFieldDefinition('mediaDurationSeconds', float),
            'media_frame_rate': ConjureFieldDefinition('mediaFrameRate', float)
        }

    __slots__: List[str] = ['_num_frames', '_num_segments', '_min_absolute_timestamp', '_max_absolute_timestamp', '_media_duration_seconds', '_media_frame_rate']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", media_duration_seconds: float, media_frame_rate: float, min_absolute_timestamp: "api_Timestamp", num_frames: int, num_segments: int) -> None:
        self._num_frames = num_frames
        self._num_segments = num_segments
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._media_duration_seconds = media_duration_seconds
        self._media_frame_rate = media_frame_rate

    @builtins.property
    def num_frames(self) -> int:
        return self._num_frames

    @builtins.property
    def num_segments(self) -> int:
        return self._num_segments

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        return self._max_absolute_timestamp

    @builtins.property
    def media_duration_seconds(self) -> float:
        return self._media_duration_seconds

    @builtins.property
    def media_frame_rate(self) -> float:
        """The average media frame rate (FPS) calculated as total frames / duration in seconds.
        """
        return self._media_frame_rate


scout_video_api_VideoChannelSegmentsMetadata.__name__ = "VideoChannelSegmentsMetadata"
scout_video_api_VideoChannelSegmentsMetadata.__qualname__ = "VideoChannelSegmentsMetadata"
scout_video_api_VideoChannelSegmentsMetadata.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoChannelSeries(ConjureUnionType):
    """Union type for referencing a video channel. Allows querying video data via 
datasource/channel, asset data scopes, or run data scopes.
    """
    _data_source: Optional["scout_video_api_VideoDataSourceChannel"] = None
    _asset: Optional["scout_video_api_VideoAssetChannel"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source': ConjureFieldDefinition('dataSource', scout_video_api_VideoDataSourceChannel),
            'asset': ConjureFieldDefinition('asset', scout_video_api_VideoAssetChannel)
        }

    def __init__(
            self,
            data_source: Optional["scout_video_api_VideoDataSourceChannel"] = None,
            asset: Optional["scout_video_api_VideoAssetChannel"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (data_source is not None) + (asset is not None) != 1:
                raise ValueError('a union must contain a single member')

            if data_source is not None:
                self._data_source = data_source
                self._type = 'dataSource'
            if asset is not None:
                self._asset = asset
                self._type = 'asset'

        elif type_of_union == 'dataSource':
            if data_source is None:
                raise ValueError('a union value must not be None')
            self._data_source = data_source
            self._type = 'dataSource'
        elif type_of_union == 'asset':
            if asset is None:
                raise ValueError('a union value must not be None')
            self._asset = asset
            self._type = 'asset'

    @builtins.property
    def data_source(self) -> Optional["scout_video_api_VideoDataSourceChannel"]:
        return self._data_source

    @builtins.property
    def asset(self) -> Optional["scout_video_api_VideoAssetChannel"]:
        return self._asset

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoChannelSeriesVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoChannelSeriesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'dataSource' and self.data_source is not None:
            return visitor._data_source(self.data_source)
        if self._type == 'asset' and self.asset is not None:
            return visitor._asset(self.asset)


scout_video_api_VideoChannelSeries.__name__ = "VideoChannelSeries"
scout_video_api_VideoChannelSeries.__qualname__ = "VideoChannelSeries"
scout_video_api_VideoChannelSeries.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoChannelSeriesVisitor:

    @abstractmethod
    def _data_source(self, data_source: "scout_video_api_VideoDataSourceChannel") -> Any:
        pass

    @abstractmethod
    def _asset(self, asset: "scout_video_api_VideoAssetChannel") -> Any:
        pass


scout_video_api_VideoChannelSeriesVisitor.__name__ = "VideoChannelSeriesVisitor"
scout_video_api_VideoChannelSeriesVisitor.__qualname__ = "VideoChannelSeriesVisitor"
scout_video_api_VideoChannelSeriesVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoDataSourceChannel(ConjureBeanType):
    """Reference a video channel directly from a datasource/dataset
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', str),
            'channel': ConjureFieldDefinition('channel', str),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_data_source_rid', '_channel', '_tags']

    def __init__(self, channel: str, data_source_rid: str, tags: Dict[str, str]) -> None:
        self._data_source_rid = data_source_rid
        self._channel = channel
        self._tags = tags

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


scout_video_api_VideoDataSourceChannel.__name__ = "VideoDataSourceChannel"
scout_video_api_VideoDataSourceChannel.__qualname__ = "VideoDataSourceChannel"
scout_video_api_VideoDataSourceChannel.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFile(ConjureBeanType):
    """Representation of a single user-provided video file.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_VideoFileRid),
            'video_rid': ConjureFieldDefinition('videoRid', api_rids_VideoRid),
            'title': ConjureFieldDefinition('title', str),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'origin_metadata': ConjureFieldDefinition('originMetadata', scout_video_api_VideoFileOriginMetadata),
            'segment_metadata': ConjureFieldDefinition('segmentMetadata', OptionalTypeWrapper[scout_video_api_VideoFileSegmentsMetadata])
        }

    __slots__: List[str] = ['_rid', '_video_rid', '_title', '_description', '_created_by', '_created_at', '_origin_metadata', '_segment_metadata']

    def __init__(self, created_at: str, created_by: str, origin_metadata: "scout_video_api_VideoFileOriginMetadata", rid: str, title: str, video_rid: str, description: Optional[str] = None, segment_metadata: Optional["scout_video_api_VideoFileSegmentsMetadata"] = None) -> None:
        self._rid = rid
        self._video_rid = video_rid
        self._title = title
        self._description = description
        self._created_by = created_by
        self._created_at = created_at
        self._origin_metadata = origin_metadata
        self._segment_metadata = segment_metadata

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def video_rid(self) -> str:
        return self._video_rid

    @builtins.property
    def title(self) -> str:
        return self._title

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def origin_metadata(self) -> "scout_video_api_VideoFileOriginMetadata":
        return self._origin_metadata

    @builtins.property
    def segment_metadata(self) -> Optional["scout_video_api_VideoFileSegmentsMetadata"]:
        return self._segment_metadata


scout_video_api_VideoFile.__name__ = "VideoFile"
scout_video_api_VideoFile.__qualname__ = "VideoFile"
scout_video_api_VideoFile.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileIngestStatus(ConjureUnionType):
    _success: Optional["scout_video_api_SuccessIngestStatus"] = None
    _error: Optional["scout_video_api_IngestError"] = None
    _in_progress: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'success': ConjureFieldDefinition('success', scout_video_api_SuccessIngestStatus),
            'error': ConjureFieldDefinition('error', scout_video_api_IngestError),
            'in_progress': ConjureFieldDefinition('inProgress', api_Empty)
        }

    def __init__(
            self,
            success: Optional["scout_video_api_SuccessIngestStatus"] = None,
            error: Optional["scout_video_api_IngestError"] = None,
            in_progress: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (success is not None) + (error is not None) + (in_progress is not None) != 1:
                raise ValueError('a union must contain a single member')

            if success is not None:
                self._success = success
                self._type = 'success'
            if error is not None:
                self._error = error
                self._type = 'error'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'

        elif type_of_union == 'success':
            if success is None:
                raise ValueError('a union value must not be None')
            self._success = success
            self._type = 'success'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'

    @builtins.property
    def success(self) -> Optional["scout_video_api_SuccessIngestStatus"]:
        return self._success

    @builtins.property
    def error(self) -> Optional["scout_video_api_IngestError"]:
        return self._error

    @builtins.property
    def in_progress(self) -> Optional["api_Empty"]:
        return self._in_progress

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoFileIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoFileIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'success' and self.success is not None:
            return visitor._success(self.success)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)


scout_video_api_VideoFileIngestStatus.__name__ = "VideoFileIngestStatus"
scout_video_api_VideoFileIngestStatus.__qualname__ = "VideoFileIngestStatus"
scout_video_api_VideoFileIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileIngestStatusVisitor:

    @abstractmethod
    def _success(self, success: "scout_video_api_SuccessIngestStatus") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "scout_video_api_IngestError") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "api_Empty") -> Any:
        pass


scout_video_api_VideoFileIngestStatusVisitor.__name__ = "VideoFileIngestStatusVisitor"
scout_video_api_VideoFileIngestStatusVisitor.__qualname__ = "VideoFileIngestStatusVisitor"
scout_video_api_VideoFileIngestStatusVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileOriginMetadata(ConjureBeanType):
    """Metadata about the origin of the video file. This includes the original source of the video file and 
additional timestamp metadata used to time-sync the video file.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'source': ConjureFieldDefinition('source', api_Handle),
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoFileTimestampManifest)
        }

    __slots__: List[str] = ['_source', '_timestamp_manifest']

    def __init__(self, source: "api_Handle", timestamp_manifest: "scout_video_api_VideoFileTimestampManifest") -> None:
        self._source = source
        self._timestamp_manifest = timestamp_manifest

    @builtins.property
    def source(self) -> "api_Handle":
        return self._source

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoFileTimestampManifest":
        return self._timestamp_manifest


scout_video_api_VideoFileOriginMetadata.__name__ = "VideoFileOriginMetadata"
scout_video_api_VideoFileOriginMetadata.__qualname__ = "VideoFileOriginMetadata"
scout_video_api_VideoFileOriginMetadata.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileSegmentsMetadata(ConjureBeanType):
    """High-level metadata about the segments comprising a video file post-segmentation.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_VideoFileRid),
            'num_frames': ConjureFieldDefinition('numFrames', int),
            'num_segments': ConjureFieldDefinition('numSegments', int),
            'scale_factor': ConjureFieldDefinition('scaleFactor', float),
            'min_absolute_timestamp': ConjureFieldDefinition('minAbsoluteTimestamp', api_Timestamp),
            'max_absolute_timestamp': ConjureFieldDefinition('maxAbsoluteTimestamp', api_Timestamp),
            'media_duration_seconds': ConjureFieldDefinition('mediaDurationSeconds', float),
            'media_frame_rate': ConjureFieldDefinition('mediaFrameRate', float)
        }

    __slots__: List[str] = ['_rid', '_num_frames', '_num_segments', '_scale_factor', '_min_absolute_timestamp', '_max_absolute_timestamp', '_media_duration_seconds', '_media_frame_rate']

    def __init__(self, max_absolute_timestamp: "api_Timestamp", media_duration_seconds: float, media_frame_rate: float, min_absolute_timestamp: "api_Timestamp", num_frames: int, num_segments: int, rid: str, scale_factor: float) -> None:
        self._rid = rid
        self._num_frames = num_frames
        self._num_segments = num_segments
        self._scale_factor = scale_factor
        self._min_absolute_timestamp = min_absolute_timestamp
        self._max_absolute_timestamp = max_absolute_timestamp
        self._media_duration_seconds = media_duration_seconds
        self._media_frame_rate = media_frame_rate

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def num_frames(self) -> int:
        return self._num_frames

    @builtins.property
    def num_segments(self) -> int:
        return self._num_segments

    @builtins.property
    def scale_factor(self) -> float:
        return self._scale_factor

    @builtins.property
    def min_absolute_timestamp(self) -> "api_Timestamp":
        return self._min_absolute_timestamp

    @builtins.property
    def max_absolute_timestamp(self) -> "api_Timestamp":
        return self._max_absolute_timestamp

    @builtins.property
    def media_duration_seconds(self) -> float:
        return self._media_duration_seconds

    @builtins.property
    def media_frame_rate(self) -> float:
        return self._media_frame_rate


scout_video_api_VideoFileSegmentsMetadata.__name__ = "VideoFileSegmentsMetadata"
scout_video_api_VideoFileSegmentsMetadata.__qualname__ = "VideoFileSegmentsMetadata"
scout_video_api_VideoFileSegmentsMetadata.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileTimestampManifest(ConjureUnionType):
    """A video files timestamp manifest specifies how to determine absolute timestamps for each frame. In an MCAP 
file, this data is embedded within the source file. Alternatively, the manifest may be provided as an external 
sidecar file. If no manifest is available, the timestamps are calculated by applying a starting offset to the 
presentation timestamp of each frame.
    """
    _mcap: Optional["scout_video_api_McapTimestampManifest"] = None
    _s3path: Optional[str] = None
    _no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'mcap': ConjureFieldDefinition('mcap', scout_video_api_McapTimestampManifest),
            's3path': ConjureFieldDefinition('s3path', api_S3Path),
            'no_manifest': ConjureFieldDefinition('noManifest', scout_video_api_NoTimestampManifest)
        }

    def __init__(
            self,
            mcap: Optional["scout_video_api_McapTimestampManifest"] = None,
            s3path: Optional[str] = None,
            no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (mcap is not None) + (s3path is not None) + (no_manifest is not None) != 1:
                raise ValueError('a union must contain a single member')

            if mcap is not None:
                self._mcap = mcap
                self._type = 'mcap'
            if s3path is not None:
                self._s3path = s3path
                self._type = 's3path'
            if no_manifest is not None:
                self._no_manifest = no_manifest
                self._type = 'noManifest'

        elif type_of_union == 'mcap':
            if mcap is None:
                raise ValueError('a union value must not be None')
            self._mcap = mcap
            self._type = 'mcap'
        elif type_of_union == 's3path':
            if s3path is None:
                raise ValueError('a union value must not be None')
            self._s3path = s3path
            self._type = 's3path'
        elif type_of_union == 'noManifest':
            if no_manifest is None:
                raise ValueError('a union value must not be None')
            self._no_manifest = no_manifest
            self._type = 'noManifest'

    @builtins.property
    def mcap(self) -> Optional["scout_video_api_McapTimestampManifest"]:
        return self._mcap

    @builtins.property
    def s3path(self) -> Optional[str]:
        return self._s3path

    @builtins.property
    def no_manifest(self) -> Optional["scout_video_api_NoTimestampManifest"]:
        return self._no_manifest

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoFileTimestampManifestVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoFileTimestampManifestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'mcap' and self.mcap is not None:
            return visitor._mcap(self.mcap)
        if self._type == 's3path' and self.s3path is not None:
            return visitor._s3path(self.s3path)
        if self._type == 'noManifest' and self.no_manifest is not None:
            return visitor._no_manifest(self.no_manifest)


scout_video_api_VideoFileTimestampManifest.__name__ = "VideoFileTimestampManifest"
scout_video_api_VideoFileTimestampManifest.__qualname__ = "VideoFileTimestampManifest"
scout_video_api_VideoFileTimestampManifest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoFileTimestampManifestVisitor:

    @abstractmethod
    def _mcap(self, mcap: "scout_video_api_McapTimestampManifest") -> Any:
        pass

    @abstractmethod
    def _s3path(self, s3path: str) -> Any:
        pass

    @abstractmethod
    def _no_manifest(self, no_manifest: "scout_video_api_NoTimestampManifest") -> Any:
        pass


scout_video_api_VideoFileTimestampManifestVisitor.__name__ = "VideoFileTimestampManifestVisitor"
scout_video_api_VideoFileTimestampManifestVisitor.__qualname__ = "VideoFileTimestampManifestVisitor"
scout_video_api_VideoFileTimestampManifestVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoIngestStatus(ConjureUnionType):
    _ready: Optional["api_Empty"] = None
    _in_progress: Optional["api_Empty"] = None
    _error: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ready': ConjureFieldDefinition('ready', api_Empty),
            'in_progress': ConjureFieldDefinition('inProgress', api_Empty),
            'error': ConjureFieldDefinition('error', api_Empty)
        }

    def __init__(
            self,
            ready: Optional["api_Empty"] = None,
            in_progress: Optional["api_Empty"] = None,
            error: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (ready is not None) + (in_progress is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if ready is not None:
                self._ready = ready
                self._type = 'ready'
            if in_progress is not None:
                self._in_progress = in_progress
                self._type = 'inProgress'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'ready':
            if ready is None:
                raise ValueError('a union value must not be None')
            self._ready = ready
            self._type = 'ready'
        elif type_of_union == 'inProgress':
            if in_progress is None:
                raise ValueError('a union value must not be None')
            self._in_progress = in_progress
            self._type = 'inProgress'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def ready(self) -> Optional["api_Empty"]:
        return self._ready

    @builtins.property
    def in_progress(self) -> Optional["api_Empty"]:
        return self._in_progress

    @builtins.property
    def error(self) -> Optional["api_Empty"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoIngestStatusVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoIngestStatusVisitor'.format(visitor.__class__.__name__))
        if self._type == 'ready' and self.ready is not None:
            return visitor._ready(self.ready)
        if self._type == 'inProgress' and self.in_progress is not None:
            return visitor._in_progress(self.in_progress)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


scout_video_api_VideoIngestStatus.__name__ = "VideoIngestStatus"
scout_video_api_VideoIngestStatus.__qualname__ = "VideoIngestStatus"
scout_video_api_VideoIngestStatus.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoIngestStatusVisitor:

    @abstractmethod
    def _ready(self, ready: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _in_progress(self, in_progress: "api_Empty") -> Any:
        pass

    @abstractmethod
    def _error(self, error: "api_Empty") -> Any:
        pass


scout_video_api_VideoIngestStatusVisitor.__name__ = "VideoIngestStatusVisitor"
scout_video_api_VideoIngestStatusVisitor.__qualname__ = "VideoIngestStatusVisitor"
scout_video_api_VideoIngestStatusVisitor.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoOriginMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'video_sources': ConjureFieldDefinition('videoSources', List[api_Handle]),
            'timestamp_manifest': ConjureFieldDefinition('timestampManifest', scout_video_api_VideoTimestampManifest)
        }

    __slots__: List[str] = ['_video_sources', '_timestamp_manifest']

    def __init__(self, timestamp_manifest: "scout_video_api_VideoTimestampManifest", video_sources: List["api_Handle"]) -> None:
        self._video_sources = video_sources
        self._timestamp_manifest = timestamp_manifest

    @builtins.property
    def video_sources(self) -> List["api_Handle"]:
        return self._video_sources

    @builtins.property
    def timestamp_manifest(self) -> "scout_video_api_VideoTimestampManifest":
        return self._timestamp_manifest


scout_video_api_VideoOriginMetadata.__name__ = "VideoOriginMetadata"
scout_video_api_VideoOriginMetadata.__qualname__ = "VideoOriginMetadata"
scout_video_api_VideoOriginMetadata.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoTimestampManifest(ConjureUnionType):
    _mcap: Optional["scout_video_api_McapTimestampManifest"] = None
    _s3paths: Optional[List[str]] = None
    _no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'mcap': ConjureFieldDefinition('mcap', scout_video_api_McapTimestampManifest),
            's3paths': ConjureFieldDefinition('s3paths', List[api_S3Path]),
            'no_manifest': ConjureFieldDefinition('noManifest', scout_video_api_NoTimestampManifest)
        }

    def __init__(
            self,
            mcap: Optional["scout_video_api_McapTimestampManifest"] = None,
            s3paths: Optional[List[str]] = None,
            no_manifest: Optional["scout_video_api_NoTimestampManifest"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (mcap is not None) + (s3paths is not None) + (no_manifest is not None) != 1:
                raise ValueError('a union must contain a single member')

            if mcap is not None:
                self._mcap = mcap
                self._type = 'mcap'
            if s3paths is not None:
                self._s3paths = s3paths
                self._type = 's3paths'
            if no_manifest is not None:
                self._no_manifest = no_manifest
                self._type = 'noManifest'

        elif type_of_union == 'mcap':
            if mcap is None:
                raise ValueError('a union value must not be None')
            self._mcap = mcap
            self._type = 'mcap'
        elif type_of_union == 's3paths':
            if s3paths is None:
                raise ValueError('a union value must not be None')
            self._s3paths = s3paths
            self._type = 's3paths'
        elif type_of_union == 'noManifest':
            if no_manifest is None:
                raise ValueError('a union value must not be None')
            self._no_manifest = no_manifest
            self._type = 'noManifest'

    @builtins.property
    def mcap(self) -> Optional["scout_video_api_McapTimestampManifest"]:
        return self._mcap

    @builtins.property
    def s3paths(self) -> Optional[List[str]]:
        return self._s3paths

    @builtins.property
    def no_manifest(self) -> Optional["scout_video_api_NoTimestampManifest"]:
        return self._no_manifest

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_video_api_VideoTimestampManifestVisitor):
            raise ValueError('{} is not an instance of scout_video_api_VideoTimestampManifestVisitor'.format(visitor.__class__.__name__))
        if self._type == 'mcap' and self.mcap is not None:
            return visitor._mcap(self.mcap)
        if self._type == 's3paths' and self.s3paths is not None:
            return visitor._s3paths(self.s3paths)
        if self._type == 'noManifest' and self.no_manifest is not None:
            return visitor._no_manifest(self.no_manifest)


scout_video_api_VideoTimestampManifest.__name__ = "VideoTimestampManifest"
scout_video_api_VideoTimestampManifest.__qualname__ = "VideoTimestampManifest"
scout_video_api_VideoTimestampManifest.__module__ = "nominal_api.scout_video_api"


class scout_video_api_VideoTimestampManifestVisitor:

    @abstractmethod
    def _mcap(self, mcap: "scout_video_api_McapTimestampManifest") -> Any:
        pass

    @abstractmethod
    def _s3paths(self, s3paths: List[str]) -> Any:
        pass

    @abstractmethod
    def _no_manifest(self, no_manifest: "scout_video_api_NoTimestampManifest") -> Any:
        pass


scout_video_api_VideoTimestampManifestVisitor.__name__ = "VideoTimestampManifestVisitor"
scout_video_api_VideoTimestampManifestVisitor.__qualname__ = "VideoTimestampManifestVisitor"
scout_video_api_VideoTimestampManifestVisitor.__module__ = "nominal_api.scout_video_api"


class scout_workbookcommon_api_AssetOffset(ConjureBeanType):
    """An offset that can be applied to an asset.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_workbookcommon_api_Offset]),
            'data_sources': ConjureFieldDefinition('dataSources', OptionalTypeWrapper[Dict[scout_api_DataSourceRefName, scout_workbookcommon_api_Offset]])
        }

    __slots__: List[str] = ['_offset', '_data_sources']

    def __init__(self, data_sources: Optional[Dict[str, "scout_workbookcommon_api_Offset"]] = None, offset: Optional["scout_workbookcommon_api_Offset"] = None) -> None:
        self._offset = offset
        self._data_sources = data_sources

    @builtins.property
    def offset(self) -> Optional["scout_workbookcommon_api_Offset"]:
        return self._offset

    @builtins.property
    def data_sources(self) -> Optional[Dict[str, "scout_workbookcommon_api_Offset"]]:
        return self._data_sources


scout_workbookcommon_api_AssetOffset.__name__ = "AssetOffset"
scout_workbookcommon_api_AssetOffset.__qualname__ = "AssetOffset"
scout_workbookcommon_api_AssetOffset.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_AssetSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_rids_api_UserDuration]),
            'data_scope_offsets': ConjureFieldDefinition('dataScopeOffsets', OptionalTypeWrapper[Dict[scout_api_DataSourceRefName, scout_rids_api_UserDuration]])
        }

    __slots__: List[str] = ['_offset', '_data_scope_offsets']

    def __init__(self, data_scope_offsets: Optional[Dict[str, "scout_rids_api_UserDuration"]] = None, offset: Optional["scout_rids_api_UserDuration"] = None) -> None:
        self._offset = offset
        self._data_scope_offsets = data_scope_offsets

    @builtins.property
    def offset(self) -> Optional["scout_rids_api_UserDuration"]:
        return self._offset

    @builtins.property
    def data_scope_offsets(self) -> Optional[Dict[str, "scout_rids_api_UserDuration"]]:
        return self._data_scope_offsets


scout_workbookcommon_api_AssetSettings.__name__ = "AssetSettings"
scout_workbookcommon_api_AssetSettings.__qualname__ = "AssetSettings"
scout_workbookcommon_api_AssetSettings.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_CheckAlertReference(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'check_alert_rid': ConjureFieldDefinition('checkAlertRid', scout_rids_api_CheckAlertRid)
        }

    __slots__: List[str] = ['_check_alert_rid']

    def __init__(self, check_alert_rid: str) -> None:
        self._check_alert_rid = check_alert_rid

    @builtins.property
    def check_alert_rid(self) -> str:
        return self._check_alert_rid


scout_workbookcommon_api_CheckAlertReference.__name__ = "CheckAlertReference"
scout_workbookcommon_api_CheckAlertReference.__qualname__ = "CheckAlertReference"
scout_workbookcommon_api_CheckAlertReference.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_EventAlignTo(ConjureEnumType):
    """The align to value for an event offset. If the queried event is a moment, the offset will be the moment timestamp regardless of the align to value.
    """

    START = 'START'
    '''START'''
    END = 'END'
    '''END'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_workbookcommon_api_EventAlignTo.__name__ = "EventAlignTo"
scout_workbookcommon_api_EventAlignTo.__qualname__ = "EventAlignTo"
scout_workbookcommon_api_EventAlignTo.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_EventAlignment(ConjureBeanType):
    """An offset that is defined relative to the first target event found by query.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'target_run_rid': ConjureFieldDefinition('targetRunRid', scout_run_api_RunRid),
            'align_to': ConjureFieldDefinition('alignTo', scout_workbookcommon_api_EventAlignTo),
            'event_query': ConjureFieldDefinition('eventQuery', event_SearchQuery)
        }

    __slots__: List[str] = ['_target_run_rid', '_align_to', '_event_query']

    def __init__(self, align_to: "scout_workbookcommon_api_EventAlignTo", event_query: "event_SearchQuery", target_run_rid: str) -> None:
        self._target_run_rid = target_run_rid
        self._align_to = align_to
        self._event_query = event_query

    @builtins.property
    def target_run_rid(self) -> str:
        return self._target_run_rid

    @builtins.property
    def align_to(self) -> "scout_workbookcommon_api_EventAlignTo":
        return self._align_to

    @builtins.property
    def event_query(self) -> "event_SearchQuery":
        return self._event_query


scout_workbookcommon_api_EventAlignment.__name__ = "EventAlignment"
scout_workbookcommon_api_EventAlignment.__qualname__ = "EventAlignment"
scout_workbookcommon_api_EventAlignment.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_EventReference(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'event_uuid': ConjureFieldDefinition('eventUuid', OptionalTypeWrapper[str]),
            'rid': ConjureFieldDefinition('rid', api_rids_EventRid)
        }

    __slots__: List[str] = ['_event_uuid', '_rid']

    def __init__(self, rid: str, event_uuid: Optional[str] = None) -> None:
        self._event_uuid = event_uuid
        self._rid = rid

    @builtins.property
    def event_uuid(self) -> Optional[str]:
        return self._event_uuid

    @builtins.property
    def rid(self) -> str:
        """The event's unique identifier.
        """
        return self._rid


scout_workbookcommon_api_EventReference.__name__ = "EventReference"
scout_workbookcommon_api_EventReference.__qualname__ = "EventReference"
scout_workbookcommon_api_EventReference.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_InputType(ConjureUnionType):
    _tag: Optional["scout_workbookcommon_api_Tag"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'tag': ConjureFieldDefinition('tag', scout_workbookcommon_api_Tag)
        }

    def __init__(
            self,
            tag: Optional["scout_workbookcommon_api_Tag"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (tag is not None) != 1:
                raise ValueError('a union must contain a single member')

            if tag is not None:
                self._tag = tag
                self._type = 'tag'

        elif type_of_union == 'tag':
            if tag is None:
                raise ValueError('a union value must not be None')
            self._tag = tag
            self._type = 'tag'

    @builtins.property
    def tag(self) -> Optional["scout_workbookcommon_api_Tag"]:
        return self._tag

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_InputTypeVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_InputTypeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'tag' and self.tag is not None:
            return visitor._tag(self.tag)


scout_workbookcommon_api_InputType.__name__ = "InputType"
scout_workbookcommon_api_InputType.__qualname__ = "InputType"
scout_workbookcommon_api_InputType.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_InputTypeVisitor:

    @abstractmethod
    def _tag(self, tag: "scout_workbookcommon_api_Tag") -> Any:
        pass


scout_workbookcommon_api_InputTypeVisitor.__name__ = "InputTypeVisitor"
scout_workbookcommon_api_InputTypeVisitor.__qualname__ = "InputTypeVisitor"
scout_workbookcommon_api_InputTypeVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_Offset(ConjureUnionType):
    _custom: Optional["scout_rids_api_UserDuration"] = None
    _run_align: Optional["scout_workbookcommon_api_RunAlignment"] = None
    _event_align: Optional["scout_workbookcommon_api_EventAlignment"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'custom': ConjureFieldDefinition('custom', scout_rids_api_UserDuration),
            'run_align': ConjureFieldDefinition('runAlign', scout_workbookcommon_api_RunAlignment),
            'event_align': ConjureFieldDefinition('eventAlign', scout_workbookcommon_api_EventAlignment)
        }

    def __init__(
            self,
            custom: Optional["scout_rids_api_UserDuration"] = None,
            run_align: Optional["scout_workbookcommon_api_RunAlignment"] = None,
            event_align: Optional["scout_workbookcommon_api_EventAlignment"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (custom is not None) + (run_align is not None) + (event_align is not None) != 1:
                raise ValueError('a union must contain a single member')

            if custom is not None:
                self._custom = custom
                self._type = 'custom'
            if run_align is not None:
                self._run_align = run_align
                self._type = 'runAlign'
            if event_align is not None:
                self._event_align = event_align
                self._type = 'eventAlign'

        elif type_of_union == 'custom':
            if custom is None:
                raise ValueError('a union value must not be None')
            self._custom = custom
            self._type = 'custom'
        elif type_of_union == 'runAlign':
            if run_align is None:
                raise ValueError('a union value must not be None')
            self._run_align = run_align
            self._type = 'runAlign'
        elif type_of_union == 'eventAlign':
            if event_align is None:
                raise ValueError('a union value must not be None')
            self._event_align = event_align
            self._type = 'eventAlign'

    @builtins.property
    def custom(self) -> Optional["scout_rids_api_UserDuration"]:
        return self._custom

    @builtins.property
    def run_align(self) -> Optional["scout_workbookcommon_api_RunAlignment"]:
        return self._run_align

    @builtins.property
    def event_align(self) -> Optional["scout_workbookcommon_api_EventAlignment"]:
        return self._event_align

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_OffsetVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_OffsetVisitor'.format(visitor.__class__.__name__))
        if self._type == 'custom' and self.custom is not None:
            return visitor._custom(self.custom)
        if self._type == 'runAlign' and self.run_align is not None:
            return visitor._run_align(self.run_align)
        if self._type == 'eventAlign' and self.event_align is not None:
            return visitor._event_align(self.event_align)


scout_workbookcommon_api_Offset.__name__ = "Offset"
scout_workbookcommon_api_Offset.__qualname__ = "Offset"
scout_workbookcommon_api_Offset.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_OffsetVisitor:

    @abstractmethod
    def _custom(self, custom: "scout_rids_api_UserDuration") -> Any:
        pass

    @abstractmethod
    def _run_align(self, run_align: "scout_workbookcommon_api_RunAlignment") -> Any:
        pass

    @abstractmethod
    def _event_align(self, event_align: "scout_workbookcommon_api_EventAlignment") -> Any:
        pass


scout_workbookcommon_api_OffsetVisitor.__name__ = "OffsetVisitor"
scout_workbookcommon_api_OffsetVisitor.__qualname__ = "OffsetVisitor"
scout_workbookcommon_api_OffsetVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_RunAlignTo(ConjureEnumType):
    """The align to value for a run offset.
    """

    START = 'START'
    '''START'''
    END = 'END'
    '''END'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_workbookcommon_api_RunAlignTo.__name__ = "RunAlignTo"
scout_workbookcommon_api_RunAlignTo.__qualname__ = "RunAlignTo"
scout_workbookcommon_api_RunAlignTo.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_RunAlignment(ConjureBeanType):
    """An offset that is defined relative to a target run.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'align_to': ConjureFieldDefinition('alignTo', scout_workbookcommon_api_RunAlignTo),
            'target_run_rid': ConjureFieldDefinition('targetRunRid', scout_run_api_RunRid)
        }

    __slots__: List[str] = ['_align_to', '_target_run_rid']

    def __init__(self, align_to: "scout_workbookcommon_api_RunAlignTo", target_run_rid: str) -> None:
        self._align_to = align_to
        self._target_run_rid = target_run_rid

    @builtins.property
    def align_to(self) -> "scout_workbookcommon_api_RunAlignTo":
        return self._align_to

    @builtins.property
    def target_run_rid(self) -> str:
        return self._target_run_rid


scout_workbookcommon_api_RunAlignment.__name__ = "RunAlignment"
scout_workbookcommon_api_RunAlignment.__qualname__ = "RunAlignment"
scout_workbookcommon_api_RunAlignment.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_RunOffset(ConjureBeanType):
    """An offset that can be applied to a run.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_workbookcommon_api_Offset]),
            'assets': ConjureFieldDefinition('assets', OptionalTypeWrapper[Dict[scout_rids_api_AssetRid, scout_workbookcommon_api_AssetOffset]])
        }

    __slots__: List[str] = ['_offset', '_assets']

    def __init__(self, assets: Optional[Dict[str, "scout_workbookcommon_api_AssetOffset"]] = None, offset: Optional["scout_workbookcommon_api_Offset"] = None) -> None:
        self._offset = offset
        self._assets = assets

    @builtins.property
    def offset(self) -> Optional["scout_workbookcommon_api_Offset"]:
        return self._offset

    @builtins.property
    def assets(self) -> Optional[Dict[str, "scout_workbookcommon_api_AssetOffset"]]:
        return self._assets


scout_workbookcommon_api_RunOffset.__name__ = "RunOffset"
scout_workbookcommon_api_RunOffset.__qualname__ = "RunOffset"
scout_workbookcommon_api_RunOffset.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_RunSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'offset': ConjureFieldDefinition('offset', OptionalTypeWrapper[scout_rids_api_UserDuration]),
            'asset_settings': ConjureFieldDefinition('assetSettings', OptionalTypeWrapper[Dict[scout_rids_api_AssetRid, scout_workbookcommon_api_AssetSettings]])
        }

    __slots__: List[str] = ['_offset', '_asset_settings']

    def __init__(self, asset_settings: Optional[Dict[str, "scout_workbookcommon_api_AssetSettings"]] = None, offset: Optional["scout_rids_api_UserDuration"] = None) -> None:
        self._offset = offset
        self._asset_settings = asset_settings

    @builtins.property
    def offset(self) -> Optional["scout_rids_api_UserDuration"]:
        return self._offset

    @builtins.property
    def asset_settings(self) -> Optional[Dict[str, "scout_workbookcommon_api_AssetSettings"]]:
        return self._asset_settings


scout_workbookcommon_api_RunSettings.__name__ = "RunSettings"
scout_workbookcommon_api_RunSettings.__qualname__ = "RunSettings"
scout_workbookcommon_api_RunSettings.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_Tag(ConjureBeanType):
    """A tag input contains tag key and tag value information that can apply
to a channel's compute tree. Applies the tag to both the tag filter
and tag group by fields of the series node in the compute tree.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'key': ConjureFieldDefinition('key', scout_workbookcommon_api_TagString),
            'values': ConjureFieldDefinition('values', List[scout_workbookcommon_api_TagString])
        }

    __slots__: List[str] = ['_key', '_values']

    def __init__(self, key: "scout_workbookcommon_api_TagString", values: List["scout_workbookcommon_api_TagString"]) -> None:
        self._key = key
        self._values = values

    @builtins.property
    def key(self) -> "scout_workbookcommon_api_TagString":
        """The key of the tag for the filter and group by compute arguments.
        """
        return self._key

    @builtins.property
    def values(self) -> List["scout_workbookcommon_api_TagString"]:
        """The values of the tag to filter against. 
An empty list will treat the tag as a wildcard, including all values in the compute
        """
        return self._values


scout_workbookcommon_api_Tag.__name__ = "Tag"
scout_workbookcommon_api_Tag.__qualname__ = "Tag"
scout_workbookcommon_api_Tag.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_TagString(ConjureUnionType):
    _literal: Optional["scout_workbookcommon_api_TagStringLiteral"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'literal': ConjureFieldDefinition('literal', scout_workbookcommon_api_TagStringLiteral)
        }

    def __init__(
            self,
            literal: Optional["scout_workbookcommon_api_TagStringLiteral"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (literal is not None) != 1:
                raise ValueError('a union must contain a single member')

            if literal is not None:
                self._literal = literal
                self._type = 'literal'

        elif type_of_union == 'literal':
            if literal is None:
                raise ValueError('a union value must not be None')
            self._literal = literal
            self._type = 'literal'

    @builtins.property
    def literal(self) -> Optional["scout_workbookcommon_api_TagStringLiteral"]:
        return self._literal

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_TagStringVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_TagStringVisitor'.format(visitor.__class__.__name__))
        if self._type == 'literal' and self.literal is not None:
            return visitor._literal(self.literal)


scout_workbookcommon_api_TagString.__name__ = "TagString"
scout_workbookcommon_api_TagString.__qualname__ = "TagString"
scout_workbookcommon_api_TagString.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_TagStringVisitor:

    @abstractmethod
    def _literal(self, literal: "scout_workbookcommon_api_TagStringLiteral") -> Any:
        pass


scout_workbookcommon_api_TagStringVisitor.__name__ = "TagStringVisitor"
scout_workbookcommon_api_TagStringVisitor.__qualname__ = "TagStringVisitor"
scout_workbookcommon_api_TagStringVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_TagStringLiteral(ConjureBeanType):
    """A literal string value
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', str),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_id', '_value']

    def __init__(self, id: str, value: str) -> None:
        self._id = id
        self._value = value

    @builtins.property
    def id(self) -> str:
        """A unique identifier for this string. Cannot be shared across different Tag inputs.
Used as the variable id for the StringConstant applied to the tag fields 
of the channel compute node.
        """
        return self._id

    @builtins.property
    def value(self) -> str:
        """The string value.
        """
        return self._value


scout_workbookcommon_api_TagStringLiteral.__name__ = "TagStringLiteral"
scout_workbookcommon_api_TagStringLiteral.__qualname__ = "TagStringLiteral"
scout_workbookcommon_api_TagStringLiteral.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_UnifiedWorkbookContent(ConjureUnionType):
    _workbook: Optional["scout_workbookcommon_api_WorkbookContent"] = None
    _comparison_workbook: Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workbook': ConjureFieldDefinition('workbook', scout_workbookcommon_api_WorkbookContent),
            'comparison_workbook': ConjureFieldDefinition('comparisonWorkbook', scout_comparisonnotebook_api_ComparisonWorkbookContent)
        }

    def __init__(
            self,
            workbook: Optional["scout_workbookcommon_api_WorkbookContent"] = None,
            comparison_workbook: Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (workbook is not None) + (comparison_workbook is not None) != 1:
                raise ValueError('a union must contain a single member')

            if workbook is not None:
                self._workbook = workbook
                self._type = 'workbook'
            if comparison_workbook is not None:
                self._comparison_workbook = comparison_workbook
                self._type = 'comparisonWorkbook'

        elif type_of_union == 'workbook':
            if workbook is None:
                raise ValueError('a union value must not be None')
            self._workbook = workbook
            self._type = 'workbook'
        elif type_of_union == 'comparisonWorkbook':
            if comparison_workbook is None:
                raise ValueError('a union value must not be None')
            self._comparison_workbook = comparison_workbook
            self._type = 'comparisonWorkbook'

    @builtins.property
    def workbook(self) -> Optional["scout_workbookcommon_api_WorkbookContent"]:
        return self._workbook

    @builtins.property
    def comparison_workbook(self) -> Optional["scout_comparisonnotebook_api_ComparisonWorkbookContent"]:
        return self._comparison_workbook

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_UnifiedWorkbookContentVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_UnifiedWorkbookContentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'workbook' and self.workbook is not None:
            return visitor._workbook(self.workbook)
        if self._type == 'comparisonWorkbook' and self.comparison_workbook is not None:
            return visitor._comparison_workbook(self.comparison_workbook)


scout_workbookcommon_api_UnifiedWorkbookContent.__name__ = "UnifiedWorkbookContent"
scout_workbookcommon_api_UnifiedWorkbookContent.__qualname__ = "UnifiedWorkbookContent"
scout_workbookcommon_api_UnifiedWorkbookContent.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_UnifiedWorkbookContentVisitor:

    @abstractmethod
    def _workbook(self, workbook: "scout_workbookcommon_api_WorkbookContent") -> Any:
        pass

    @abstractmethod
    def _comparison_workbook(self, comparison_workbook: "scout_comparisonnotebook_api_ComparisonWorkbookContent") -> Any:
        pass


scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__name__ = "UnifiedWorkbookContentVisitor"
scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__qualname__ = "UnifiedWorkbookContentVisitor"
scout_workbookcommon_api_UnifiedWorkbookContentVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookContent(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_variables': ConjureFieldDefinition('channelVariables', scout_channelvariables_api_WorkbookChannelVariableMap),
            'inputs': ConjureFieldDefinition('inputs', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookInputs]),
            'charts': ConjureFieldDefinition('charts', scout_chartdefinition_api_WorkbookVizDefinitionMap),
            'settings': ConjureFieldDefinition('settings', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookSettings])
        }

    __slots__: List[str] = ['_channel_variables', '_inputs', '_charts', '_settings']

    def __init__(self, channel_variables: Dict[str, "scout_channelvariables_api_ChannelVariable"], charts: Dict[str, "scout_chartdefinition_api_VizDefinition"], inputs: Optional["scout_workbookcommon_api_WorkbookInputs"] = None, settings: Optional["scout_workbookcommon_api_WorkbookSettings"] = None) -> None:
        self._channel_variables = channel_variables
        self._inputs = inputs
        self._charts = charts
        self._settings = settings

    @builtins.property
    def channel_variables(self) -> Dict[str, "scout_channelvariables_api_ChannelVariable"]:
        return self._channel_variables

    @builtins.property
    def inputs(self) -> Optional["scout_workbookcommon_api_WorkbookInputs"]:
        return self._inputs

    @builtins.property
    def charts(self) -> Dict[str, "scout_chartdefinition_api_VizDefinition"]:
        """map of visualizations. Previously termed "charts"
        """
        return self._charts

    @builtins.property
    def settings(self) -> Optional["scout_workbookcommon_api_WorkbookSettings"]:
        return self._settings


scout_workbookcommon_api_WorkbookContent.__name__ = "WorkbookContent"
scout_workbookcommon_api_WorkbookContent.__qualname__ = "WorkbookContent"
scout_workbookcommon_api_WorkbookContent.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookInput(ConjureBeanType):
    """A workbook input is a value managed at the workbook level
that can be applied to multiple elements.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', str),
            'label': ConjureFieldDefinition('label', OptionalTypeWrapper[str]),
            'value': ConjureFieldDefinition('value', scout_workbookcommon_api_InputType)
        }

    __slots__: List[str] = ['_id', '_label', '_value']

    def __init__(self, id: str, value: "scout_workbookcommon_api_InputType", label: Optional[str] = None) -> None:
        self._id = id
        self._label = label
        self._value = value

    @builtins.property
    def id(self) -> str:
        """The unique identifier of the input.
        """
        return self._id

    @builtins.property
    def label(self) -> Optional[str]:
        """The label of the input for display purposes.
        """
        return self._label

    @builtins.property
    def value(self) -> "scout_workbookcommon_api_InputType":
        return self._value


scout_workbookcommon_api_WorkbookInput.__name__ = "WorkbookInput"
scout_workbookcommon_api_WorkbookInput.__qualname__ = "WorkbookInput"
scout_workbookcommon_api_WorkbookInput.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookInputs(ConjureUnionType):
    _v1: Optional["scout_workbookcommon_api_WorkbookInputsV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_workbookcommon_api_WorkbookInputsV1)
        }

    def __init__(
            self,
            v1: Optional["scout_workbookcommon_api_WorkbookInputsV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_workbookcommon_api_WorkbookInputsV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_WorkbookInputsVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_WorkbookInputsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_workbookcommon_api_WorkbookInputs.__name__ = "WorkbookInputs"
scout_workbookcommon_api_WorkbookInputs.__qualname__ = "WorkbookInputs"
scout_workbookcommon_api_WorkbookInputs.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookInputsVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_workbookcommon_api_WorkbookInputsV1") -> Any:
        pass


scout_workbookcommon_api_WorkbookInputsVisitor.__name__ = "WorkbookInputsVisitor"
scout_workbookcommon_api_WorkbookInputsVisitor.__qualname__ = "WorkbookInputsVisitor"
scout_workbookcommon_api_WorkbookInputsVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookInputsV1(ConjureBeanType):
    """A list of workbook inputs.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'inputs': ConjureFieldDefinition('inputs', List[scout_workbookcommon_api_WorkbookInput])
        }

    __slots__: List[str] = ['_inputs']

    def __init__(self, inputs: List["scout_workbookcommon_api_WorkbookInput"]) -> None:
        self._inputs = inputs

    @builtins.property
    def inputs(self) -> List["scout_workbookcommon_api_WorkbookInput"]:
        return self._inputs


scout_workbookcommon_api_WorkbookInputsV1.__name__ = "WorkbookInputsV1"
scout_workbookcommon_api_WorkbookInputsV1.__qualname__ = "WorkbookInputsV1"
scout_workbookcommon_api_WorkbookInputsV1.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookOffsets(ConjureUnionType):
    _v1: Optional["scout_workbookcommon_api_WorkbookOffsetsV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_workbookcommon_api_WorkbookOffsetsV1)
        }

    def __init__(
            self,
            v1: Optional["scout_workbookcommon_api_WorkbookOffsetsV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_workbookcommon_api_WorkbookOffsetsV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_WorkbookOffsetsVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_WorkbookOffsetsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_workbookcommon_api_WorkbookOffsets.__name__ = "WorkbookOffsets"
scout_workbookcommon_api_WorkbookOffsets.__qualname__ = "WorkbookOffsets"
scout_workbookcommon_api_WorkbookOffsets.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookOffsetsVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_workbookcommon_api_WorkbookOffsetsV1") -> Any:
        pass


scout_workbookcommon_api_WorkbookOffsetsVisitor.__name__ = "WorkbookOffsetsVisitor"
scout_workbookcommon_api_WorkbookOffsetsVisitor.__qualname__ = "WorkbookOffsetsVisitor"
scout_workbookcommon_api_WorkbookOffsetsVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookOffsetsV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'runs': ConjureFieldDefinition('runs', Dict[scout_run_api_RunRid, scout_workbookcommon_api_RunOffset]),
            'assets': ConjureFieldDefinition('assets', Dict[scout_rids_api_AssetRid, scout_workbookcommon_api_AssetOffset])
        }

    __slots__: List[str] = ['_runs', '_assets']

    def __init__(self, assets: Dict[str, "scout_workbookcommon_api_AssetOffset"], runs: Dict[str, "scout_workbookcommon_api_RunOffset"]) -> None:
        self._runs = runs
        self._assets = assets

    @builtins.property
    def runs(self) -> Dict[str, "scout_workbookcommon_api_RunOffset"]:
        return self._runs

    @builtins.property
    def assets(self) -> Dict[str, "scout_workbookcommon_api_AssetOffset"]:
        return self._assets


scout_workbookcommon_api_WorkbookOffsetsV1.__name__ = "WorkbookOffsetsV1"
scout_workbookcommon_api_WorkbookOffsetsV1.__qualname__ = "WorkbookOffsetsV1"
scout_workbookcommon_api_WorkbookOffsetsV1.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'asset_settings': ConjureFieldDefinition('assetSettings', OptionalTypeWrapper[Dict[scout_rids_api_AssetRid, scout_workbookcommon_api_AssetSettings]]),
            'run_settings': ConjureFieldDefinition('runSettings', OptionalTypeWrapper[Dict[scout_run_api_RunRid, scout_workbookcommon_api_RunSettings]]),
            'time_settings': ConjureFieldDefinition('timeSettings', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookTimeSettings]),
            'offsets': ConjureFieldDefinition('offsets', OptionalTypeWrapper[scout_workbookcommon_api_WorkbookOffsets])
        }

    __slots__: List[str] = ['_asset_settings', '_run_settings', '_time_settings', '_offsets']

    def __init__(self, asset_settings: Optional[Dict[str, "scout_workbookcommon_api_AssetSettings"]] = None, offsets: Optional["scout_workbookcommon_api_WorkbookOffsets"] = None, run_settings: Optional[Dict[str, "scout_workbookcommon_api_RunSettings"]] = None, time_settings: Optional["scout_workbookcommon_api_WorkbookTimeSettings"] = None) -> None:
        self._asset_settings = asset_settings
        self._run_settings = run_settings
        self._time_settings = time_settings
        self._offsets = offsets

    @builtins.property
    def asset_settings(self) -> Optional[Dict[str, "scout_workbookcommon_api_AssetSettings"]]:
        """Settings for assets to be used in the workbook. This should be present for asset workbooks.
        """
        return self._asset_settings

    @builtins.property
    def run_settings(self) -> Optional[Dict[str, "scout_workbookcommon_api_RunSettings"]]:
        """Settings for runs to be used in the workbook. This should be present for run workbooks.
        """
        return self._run_settings

    @builtins.property
    def time_settings(self) -> Optional["scout_workbookcommon_api_WorkbookTimeSettings"]:
        """Time range settings when users access a workbook. Time range URL query params will take precedence
over persisted the global time range.
        """
        return self._time_settings

    @builtins.property
    def offsets(self) -> Optional["scout_workbookcommon_api_WorkbookOffsets"]:
        """Time offsets that can be applied to the workbook.
        """
        return self._offsets


scout_workbookcommon_api_WorkbookSettings.__name__ = "WorkbookSettings"
scout_workbookcommon_api_WorkbookSettings.__qualname__ = "WorkbookSettings"
scout_workbookcommon_api_WorkbookSettings.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookTimeRangeType(ConjureEnumType):

    ABSOLUTE = 'ABSOLUTE'
    '''ABSOLUTE'''
    RELATIVE = 'RELATIVE'
    '''RELATIVE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


scout_workbookcommon_api_WorkbookTimeRangeType.__name__ = "WorkbookTimeRangeType"
scout_workbookcommon_api_WorkbookTimeRangeType.__qualname__ = "WorkbookTimeRangeType"
scout_workbookcommon_api_WorkbookTimeRangeType.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookTimeSettings(ConjureUnionType):
    _v1: Optional["scout_workbookcommon_api_WorkbookTimeSettingsV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', scout_workbookcommon_api_WorkbookTimeSettingsV1)
        }

    def __init__(
            self,
            v1: Optional["scout_workbookcommon_api_WorkbookTimeSettingsV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["scout_workbookcommon_api_WorkbookTimeSettingsV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, scout_workbookcommon_api_WorkbookTimeSettingsVisitor):
            raise ValueError('{} is not an instance of scout_workbookcommon_api_WorkbookTimeSettingsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


scout_workbookcommon_api_WorkbookTimeSettings.__name__ = "WorkbookTimeSettings"
scout_workbookcommon_api_WorkbookTimeSettings.__qualname__ = "WorkbookTimeSettings"
scout_workbookcommon_api_WorkbookTimeSettings.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookTimeSettingsVisitor:

    @abstractmethod
    def _v1(self, v1: "scout_workbookcommon_api_WorkbookTimeSettingsV1") -> Any:
        pass


scout_workbookcommon_api_WorkbookTimeSettingsVisitor.__name__ = "WorkbookTimeSettingsVisitor"
scout_workbookcommon_api_WorkbookTimeSettingsVisitor.__qualname__ = "WorkbookTimeSettingsVisitor"
scout_workbookcommon_api_WorkbookTimeSettingsVisitor.__module__ = "nominal_api.scout_workbookcommon_api"


class scout_workbookcommon_api_WorkbookTimeSettingsV1(ConjureBeanType):
    """Time range configuration for workbooks
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_range_type': ConjureFieldDefinition('timeRangeType', scout_workbookcommon_api_WorkbookTimeRangeType),
            'global_time_range': ConjureFieldDefinition('globalTimeRange', OptionalTypeWrapper[scout_workbookcommon_api_TimeRange]),
            'is_global_time': ConjureFieldDefinition('isGlobalTime', bool),
            'tab_time_ranges': ConjureFieldDefinition('tabTimeRanges', Dict[str, scout_workbookcommon_api_TimeRange])
        }

    __slots__: List[str] = ['_time_range_type', '_global_time_range', '_is_global_time', '_tab_time_ranges']

    def __init__(self, is_global_time: bool, tab_time_ranges: Dict[str, "api_Range"], time_range_type: "scout_workbookcommon_api_WorkbookTimeRangeType", global_time_range: Optional["api_Range"] = None) -> None:
        self._time_range_type = time_range_type
        self._global_time_range = global_time_range
        self._is_global_time = is_global_time
        self._tab_time_ranges = tab_time_ranges

    @builtins.property
    def time_range_type(self) -> "scout_workbookcommon_api_WorkbookTimeRangeType":
        """The time range type of the workbook
        """
        return self._time_range_type

    @builtins.property
    def global_time_range(self) -> Optional["api_Range"]:
        """The global time range a workbook falls back to.
        """
        return self._global_time_range

    @builtins.property
    def is_global_time(self) -> bool:
        """If true, workbook will default to globalTimeRange for all tabs.
If false, will attempt to use tabTime to populate the workbook time range.
        """
        return self._is_global_time

    @builtins.property
    def tab_time_ranges(self) -> Dict[str, "api_Range"]:
        return self._tab_time_ranges


scout_workbookcommon_api_WorkbookTimeSettingsV1.__name__ = "WorkbookTimeSettingsV1"
scout_workbookcommon_api_WorkbookTimeSettingsV1.__qualname__ = "WorkbookTimeSettingsV1"
scout_workbookcommon_api_WorkbookTimeSettingsV1.__module__ = "nominal_api.scout_workbookcommon_api"


class secrets_api_CreateSecretRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'decrypted_value': ConjureFieldDefinition('decryptedValue', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_name', '_description', '_decrypted_value', '_properties', '_labels', '_workspace']

    def __init__(self, decrypted_value: str, description: str, labels: List[str], name: str, properties: Dict[str, str], workspace: Optional[str] = None) -> None:
        self._name = name
        self._description = description
        self._decrypted_value = decrypted_value
        self._properties = properties
        self._labels = labels
        self._workspace = workspace

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def decrypted_value(self) -> str:
        return self._decrypted_value

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the secret. If not provided, the secret will be created in
the default workspace for the user's organization, if the default workspace for the
organization is configured.
        """
        return self._workspace


secrets_api_CreateSecretRequest.__name__ = "CreateSecretRequest"
secrets_api_CreateSecretRequest.__qualname__ = "CreateSecretRequest"
secrets_api_CreateSecretRequest.__module__ = "nominal_api.secrets_api"


class secrets_api_DecryptedSecret(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', secrets_api_SecretRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'decrypted_value': ConjureFieldDefinition('decryptedValue', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_decrypted_value', '_created_by', '_properties', '_labels', '_created_at', '_is_archived']

    def __init__(self, created_at: str, created_by: str, decrypted_value: str, description: str, is_archived: bool, labels: List[str], name: str, properties: Dict[str, str], rid: str) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._decrypted_value = decrypted_value
        self._created_by = created_by
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def decrypted_value(self) -> str:
        return self._decrypted_value

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


secrets_api_DecryptedSecret.__name__ = "DecryptedSecret"
secrets_api_DecryptedSecret.__qualname__ = "DecryptedSecret"
secrets_api_DecryptedSecret.__module__ = "nominal_api.secrets_api"


class secrets_api_GetSecretsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'secret_rids': ConjureFieldDefinition('secretRids', List[secrets_api_SecretRid])
        }

    __slots__: List[str] = ['_secret_rids']

    def __init__(self, secret_rids: List[str]) -> None:
        self._secret_rids = secret_rids

    @builtins.property
    def secret_rids(self) -> List[str]:
        return self._secret_rids


secrets_api_GetSecretsRequest.__name__ = "GetSecretsRequest"
secrets_api_GetSecretsRequest.__qualname__ = "GetSecretsRequest"
secrets_api_GetSecretsRequest.__module__ = "nominal_api.secrets_api"


class secrets_api_GetSecretsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'response': ConjureFieldDefinition('response', List[secrets_api_Secret])
        }

    __slots__: List[str] = ['_response']

    def __init__(self, response: List["secrets_api_Secret"]) -> None:
        self._response = response

    @builtins.property
    def response(self) -> List["secrets_api_Secret"]:
        return self._response


secrets_api_GetSecretsResponse.__name__ = "GetSecretsResponse"
secrets_api_GetSecretsResponse.__qualname__ = "GetSecretsResponse"
secrets_api_GetSecretsResponse.__module__ = "nominal_api.secrets_api"


class secrets_api_InternalSecretService(Service):
    """The internal secrets service provides functionality for retrieving customer secrets where the "user" is a service.
    """

    def get_decrypted(self, auth_header: str, rid: str) -> "secrets_api_DecryptedSecret":
        """Get decrypted secret by rid. This is a privileged operation that is restricted to services only.
This endpoint must be a conjure endpoint in order to support TLS.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/secrets/internal/v1/secrets/{rid}/decrypted'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_DecryptedSecret, self._return_none_for_unknown_union_types)


secrets_api_InternalSecretService.__name__ = "InternalSecretService"
secrets_api_InternalSecretService.__qualname__ = "InternalSecretService"
secrets_api_InternalSecretService.__module__ = "nominal_api.secrets_api"


class secrets_api_SearchSecretsQuery(ConjureUnionType):
    _search_text: Optional[str] = None
    _label: Optional[str] = None
    _property: Optional["api_Property"] = None
    _and_: Optional[List["secrets_api_SearchSecretsQuery"]] = None
    _or_: Optional[List["secrets_api_SearchSecretsQuery"]] = None
    _workspace: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'search_text': ConjureFieldDefinition('searchText', str),
            'label': ConjureFieldDefinition('label', api_Label),
            'property': ConjureFieldDefinition('property', api_Property),
            'and_': ConjureFieldDefinition('and', List[secrets_api_SearchSecretsQuery]),
            'or_': ConjureFieldDefinition('or', List[secrets_api_SearchSecretsQuery]),
            'workspace': ConjureFieldDefinition('workspace', api_rids_WorkspaceRid)
        }

    def __init__(
            self,
            search_text: Optional[str] = None,
            label: Optional[str] = None,
            property: Optional["api_Property"] = None,
            and_: Optional[List["secrets_api_SearchSecretsQuery"]] = None,
            or_: Optional[List["secrets_api_SearchSecretsQuery"]] = None,
            workspace: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (search_text is not None) + (label is not None) + (property is not None) + (and_ is not None) + (or_ is not None) + (workspace is not None) != 1:
                raise ValueError('a union must contain a single member')

            if search_text is not None:
                self._search_text = search_text
                self._type = 'searchText'
            if label is not None:
                self._label = label
                self._type = 'label'
            if property is not None:
                self._property = property
                self._type = 'property'
            if and_ is not None:
                self._and_ = and_
                self._type = 'and'
            if or_ is not None:
                self._or_ = or_
                self._type = 'or'
            if workspace is not None:
                self._workspace = workspace
                self._type = 'workspace'

        elif type_of_union == 'searchText':
            if search_text is None:
                raise ValueError('a union value must not be None')
            self._search_text = search_text
            self._type = 'searchText'
        elif type_of_union == 'label':
            if label is None:
                raise ValueError('a union value must not be None')
            self._label = label
            self._type = 'label'
        elif type_of_union == 'property':
            if property is None:
                raise ValueError('a union value must not be None')
            self._property = property
            self._type = 'property'
        elif type_of_union == 'and':
            if and_ is None:
                raise ValueError('a union value must not be None')
            self._and_ = and_
            self._type = 'and'
        elif type_of_union == 'or':
            if or_ is None:
                raise ValueError('a union value must not be None')
            self._or_ = or_
            self._type = 'or'
        elif type_of_union == 'workspace':
            if workspace is None:
                raise ValueError('a union value must not be None')
            self._workspace = workspace
            self._type = 'workspace'

    @builtins.property
    def search_text(self) -> Optional[str]:
        return self._search_text

    @builtins.property
    def label(self) -> Optional[str]:
        return self._label

    @builtins.property
    def property(self) -> Optional["api_Property"]:
        return self._property

    @builtins.property
    def and_(self) -> Optional[List["secrets_api_SearchSecretsQuery"]]:
        return self._and_

    @builtins.property
    def or_(self) -> Optional[List["secrets_api_SearchSecretsQuery"]]:
        return self._or_

    @builtins.property
    def workspace(self) -> Optional[str]:
        return self._workspace

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, secrets_api_SearchSecretsQueryVisitor):
            raise ValueError('{} is not an instance of secrets_api_SearchSecretsQueryVisitor'.format(visitor.__class__.__name__))
        if self._type == 'searchText' and self.search_text is not None:
            return visitor._search_text(self.search_text)
        if self._type == 'label' and self.label is not None:
            return visitor._label(self.label)
        if self._type == 'property' and self.property is not None:
            return visitor._property(self.property)
        if self._type == 'and' and self.and_ is not None:
            return visitor._and(self.and_)
        if self._type == 'or' and self.or_ is not None:
            return visitor._or(self.or_)
        if self._type == 'workspace' and self.workspace is not None:
            return visitor._workspace(self.workspace)


secrets_api_SearchSecretsQuery.__name__ = "SearchSecretsQuery"
secrets_api_SearchSecretsQuery.__qualname__ = "SearchSecretsQuery"
secrets_api_SearchSecretsQuery.__module__ = "nominal_api.secrets_api"


class secrets_api_SearchSecretsQueryVisitor:

    @abstractmethod
    def _search_text(self, search_text: str) -> Any:
        pass

    @abstractmethod
    def _label(self, label: str) -> Any:
        pass

    @abstractmethod
    def _property(self, property: "api_Property") -> Any:
        pass

    @abstractmethod
    def _and(self, and_: List["secrets_api_SearchSecretsQuery"]) -> Any:
        pass

    @abstractmethod
    def _or(self, or_: List["secrets_api_SearchSecretsQuery"]) -> Any:
        pass

    @abstractmethod
    def _workspace(self, workspace: str) -> Any:
        pass


secrets_api_SearchSecretsQueryVisitor.__name__ = "SearchSecretsQueryVisitor"
secrets_api_SearchSecretsQueryVisitor.__qualname__ = "SearchSecretsQueryVisitor"
secrets_api_SearchSecretsQueryVisitor.__module__ = "nominal_api.secrets_api"


class secrets_api_SearchSecretsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'query': ConjureFieldDefinition('query', secrets_api_SearchSecretsQuery),
            'page_size': ConjureFieldDefinition('pageSize', OptionalTypeWrapper[int]),
            'sort': ConjureFieldDefinition('sort', secrets_api_SortOptions),
            'token': ConjureFieldDefinition('token', OptionalTypeWrapper[api_Token]),
            'archived_statuses': ConjureFieldDefinition('archivedStatuses', OptionalTypeWrapper[List[api_ArchivedStatus]])
        }

    __slots__: List[str] = ['_query', '_page_size', '_sort', '_token', '_archived_statuses']

    def __init__(self, query: "secrets_api_SearchSecretsQuery", sort: "secrets_api_SortOptions", archived_statuses: Optional[List["api_ArchivedStatus"]] = None, page_size: Optional[int] = None, token: Optional[str] = None) -> None:
        self._query = query
        self._page_size = page_size
        self._sort = sort
        self._token = token
        self._archived_statuses = archived_statuses

    @builtins.property
    def query(self) -> "secrets_api_SearchSecretsQuery":
        return self._query

    @builtins.property
    def page_size(self) -> Optional[int]:
        """Defaults to 100. Will throw if larger than 1000.
        """
        return self._page_size

    @builtins.property
    def sort(self) -> "secrets_api_SortOptions":
        return self._sort

    @builtins.property
    def token(self) -> Optional[str]:
        return self._token

    @builtins.property
    def archived_statuses(self) -> Optional[List["api_ArchivedStatus"]]:
        """Default search status is NOT_ARCHIVED if none are provided. Allows for including archived secrets in search.
        """
        return self._archived_statuses


secrets_api_SearchSecretsRequest.__name__ = "SearchSecretsRequest"
secrets_api_SearchSecretsRequest.__qualname__ = "SearchSecretsRequest"
secrets_api_SearchSecretsRequest.__module__ = "nominal_api.secrets_api"


class secrets_api_SearchSecretsResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'results': ConjureFieldDefinition('results', List[secrets_api_Secret]),
            'next_page_token': ConjureFieldDefinition('nextPageToken', OptionalTypeWrapper[api_Token])
        }

    __slots__: List[str] = ['_results', '_next_page_token']

    def __init__(self, results: List["secrets_api_Secret"], next_page_token: Optional[str] = None) -> None:
        self._results = results
        self._next_page_token = next_page_token

    @builtins.property
    def results(self) -> List["secrets_api_Secret"]:
        return self._results

    @builtins.property
    def next_page_token(self) -> Optional[str]:
        return self._next_page_token


secrets_api_SearchSecretsResponse.__name__ = "SearchSecretsResponse"
secrets_api_SearchSecretsResponse.__qualname__ = "SearchSecretsResponse"
secrets_api_SearchSecretsResponse.__module__ = "nominal_api.secrets_api"


class secrets_api_Secret(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', secrets_api_SecretRid),
            'name': ConjureFieldDefinition('name', str),
            'description': ConjureFieldDefinition('description', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'properties': ConjureFieldDefinition('properties', Dict[api_PropertyName, api_PropertyValue]),
            'labels': ConjureFieldDefinition('labels', List[api_Label]),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'is_archived': ConjureFieldDefinition('isArchived', bool)
        }

    __slots__: List[str] = ['_rid', '_name', '_description', '_created_by', '_properties', '_labels', '_created_at', '_is_archived']

    def __init__(self, created_at: str, created_by: str, description: str, is_archived: bool, labels: List[str], name: str, properties: Dict[str, str], rid: str) -> None:
        self._rid = rid
        self._name = name
        self._description = description
        self._created_by = created_by
        self._properties = properties
        self._labels = labels
        self._created_at = created_at
        self._is_archived = is_archived

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def description(self) -> str:
        return self._description

    @builtins.property
    def created_by(self) -> str:
        return self._created_by

    @builtins.property
    def properties(self) -> Dict[str, str]:
        return self._properties

    @builtins.property
    def labels(self) -> List[str]:
        return self._labels

    @builtins.property
    def created_at(self) -> str:
        return self._created_at

    @builtins.property
    def is_archived(self) -> bool:
        return self._is_archived


secrets_api_Secret.__name__ = "Secret"
secrets_api_Secret.__qualname__ = "Secret"
secrets_api_Secret.__module__ = "nominal_api.secrets_api"


class secrets_api_SecretService(Service):
    """The secrets service provides functionality for creating and retrieving customer secrets (e.g. influx passwords, API keys, etc)
    """

    def create(self, auth_header: str, request: "secrets_api_CreateSecretRequest") -> "secrets_api_Secret":
        """Create a new secret.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/secrets/v1/secrets'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def get(self, auth_header: str, rid: str) -> "secrets_api_Secret":
        """Get secret by rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def get_batch(self, auth_header: str, request: "secrets_api_GetSecretsRequest") -> "secrets_api_GetSecretsResponse":
        """Get secrets by a set of rids.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/secrets/v1/secrets/batch'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_GetSecretsResponse, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "secrets_api_UpdateSecretRequest", rid: str) -> "secrets_api_Secret":
        """Update a secret by rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_Secret, self._return_none_for_unknown_union_types)

    def delete(self, auth_header: str, rid: str) -> None:
        """Delete a secret by rid. This is a permanent deletion. To perform a soft delete,
use the archive endpoint.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def archive(self, auth_header: str, rid: str) -> None:
        """Archive a secret by rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}/archive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def unarchive(self, auth_header: str, rid: str) -> None:
        """Unarchive a secret by rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/secrets/v1/secrets/{rid}/unarchive'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def search(self, auth_header: str, request: "secrets_api_SearchSecretsRequest") -> "secrets_api_SearchSecretsResponse":
        """Returns metadata about secrets that match a given query.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/secrets/v1/secrets/search'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), secrets_api_SearchSecretsResponse, self._return_none_for_unknown_union_types)


secrets_api_SecretService.__name__ = "SecretService"
secrets_api_SecretService.__qualname__ = "SecretService"
secrets_api_SecretService.__module__ = "nominal_api.secrets_api"


class secrets_api_SortField(ConjureEnumType):

    CREATED_AT = 'CREATED_AT'
    '''CREATED_AT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


secrets_api_SortField.__name__ = "SortField"
secrets_api_SortField.__qualname__ = "SortField"
secrets_api_SortField.__module__ = "nominal_api.secrets_api"


class secrets_api_SortOptions(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'is_descending': ConjureFieldDefinition('isDescending', bool),
            'field': ConjureFieldDefinition('field', secrets_api_SortField)
        }

    __slots__: List[str] = ['_is_descending', '_field']

    def __init__(self, field: "secrets_api_SortField", is_descending: bool) -> None:
        self._is_descending = is_descending
        self._field = field

    @builtins.property
    def is_descending(self) -> bool:
        return self._is_descending

    @builtins.property
    def field(self) -> "secrets_api_SortField":
        return self._field


secrets_api_SortOptions.__name__ = "SortOptions"
secrets_api_SortOptions.__qualname__ = "SortOptions"
secrets_api_SortOptions.__module__ = "nominal_api.secrets_api"


class secrets_api_UpdateSecretRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', OptionalTypeWrapper[str]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'properties': ConjureFieldDefinition('properties', OptionalTypeWrapper[Dict[api_PropertyName, api_PropertyValue]]),
            'labels': ConjureFieldDefinition('labels', OptionalTypeWrapper[List[api_Label]]),
            'decrypted_value': ConjureFieldDefinition('decryptedValue', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_name', '_description', '_properties', '_labels', '_decrypted_value']

    def __init__(self, decrypted_value: Optional[str] = None, description: Optional[str] = None, labels: Optional[List[str]] = None, name: Optional[str] = None, properties: Optional[Dict[str, str]] = None) -> None:
        self._name = name
        self._description = description
        self._properties = properties
        self._labels = labels
        self._decrypted_value = decrypted_value

    @builtins.property
    def name(self) -> Optional[str]:
        return self._name

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def properties(self) -> Optional[Dict[str, str]]:
        return self._properties

    @builtins.property
    def labels(self) -> Optional[List[str]]:
        return self._labels

    @builtins.property
    def decrypted_value(self) -> Optional[str]:
        return self._decrypted_value


secrets_api_UpdateSecretRequest.__name__ = "UpdateSecretRequest"
secrets_api_UpdateSecretRequest.__qualname__ = "UpdateSecretRequest"
secrets_api_UpdateSecretRequest.__module__ = "nominal_api.secrets_api"


class security_api_workspace_PreferredRefNameConfiguration(ConjureUnionType):
    _v1: Optional[List["api_RefNameAndType"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', List[api_RefNameAndType])
        }

    def __init__(
            self,
            v1: Optional[List["api_RefNameAndType"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional[List["api_RefNameAndType"]]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, security_api_workspace_PreferredRefNameConfigurationVisitor):
            raise ValueError('{} is not an instance of security_api_workspace_PreferredRefNameConfigurationVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


security_api_workspace_PreferredRefNameConfiguration.__name__ = "PreferredRefNameConfiguration"
security_api_workspace_PreferredRefNameConfiguration.__qualname__ = "PreferredRefNameConfiguration"
security_api_workspace_PreferredRefNameConfiguration.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_PreferredRefNameConfigurationVisitor:

    @abstractmethod
    def _v1(self, v1: List["api_RefNameAndType"]) -> Any:
        pass


security_api_workspace_PreferredRefNameConfigurationVisitor.__name__ = "PreferredRefNameConfigurationVisitor"
security_api_workspace_PreferredRefNameConfigurationVisitor.__qualname__ = "PreferredRefNameConfigurationVisitor"
security_api_workspace_PreferredRefNameConfigurationVisitor.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_ProcedureSettings(ConjureUnionType):
    _v1: Optional["security_api_workspace_ProcedureSettingsV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', security_api_workspace_ProcedureSettingsV1)
        }

    def __init__(
            self,
            v1: Optional["security_api_workspace_ProcedureSettingsV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["security_api_workspace_ProcedureSettingsV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, security_api_workspace_ProcedureSettingsVisitor):
            raise ValueError('{} is not an instance of security_api_workspace_ProcedureSettingsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


security_api_workspace_ProcedureSettings.__name__ = "ProcedureSettings"
security_api_workspace_ProcedureSettings.__qualname__ = "ProcedureSettings"
security_api_workspace_ProcedureSettings.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_ProcedureSettingsVisitor:

    @abstractmethod
    def _v1(self, v1: "security_api_workspace_ProcedureSettingsV1") -> Any:
        pass


security_api_workspace_ProcedureSettingsVisitor.__name__ = "ProcedureSettingsVisitor"
security_api_workspace_ProcedureSettingsVisitor.__qualname__ = "ProcedureSettingsVisitor"
security_api_workspace_ProcedureSettingsVisitor.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_ProcedureSettingsV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'workspace_procedures': ConjureFieldDefinition('workspaceProcedures', List[api_rids_ProcedureRid])
        }

    __slots__: List[str] = ['_workspace_procedures']

    def __init__(self, workspace_procedures: List[str]) -> None:
        self._workspace_procedures = workspace_procedures

    @builtins.property
    def workspace_procedures(self) -> List[str]:
        """A list of procedures that are elevated to the workspace-level.
They will be available for execution in a top-level context, rather
than just from the procedure details page.
        """
        return self._workspace_procedures


security_api_workspace_ProcedureSettingsV1.__name__ = "ProcedureSettingsV1"
security_api_workspace_ProcedureSettingsV1.__qualname__ = "ProcedureSettingsV1"
security_api_workspace_ProcedureSettingsV1.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_RemoveType(ConjureBeanType):
    """The request to remove a field from a workspace.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
        }

    __slots__: List[str] = []



security_api_workspace_RemoveType.__name__ = "RemoveType"
security_api_workspace_RemoveType.__qualname__ = "RemoveType"
security_api_workspace_RemoveType.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_UpdateOrRemoveWorkspaceDisplayName(ConjureUnionType):
    """The request to update the display name of the workspace. The request will replace the existing display name
with the display name specified if it's provided. Otherwise, the current display name will be removed from
the workspace.
    """
    _display_name: Optional[str] = None
    _remove_type: Optional["security_api_workspace_RemoveType"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', str),
            'remove_type': ConjureFieldDefinition('removeType', security_api_workspace_RemoveType)
        }

    def __init__(
            self,
            display_name: Optional[str] = None,
            remove_type: Optional["security_api_workspace_RemoveType"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (display_name is not None) + (remove_type is not None) != 1:
                raise ValueError('a union must contain a single member')

            if display_name is not None:
                self._display_name = display_name
                self._type = 'displayName'
            if remove_type is not None:
                self._remove_type = remove_type
                self._type = 'removeType'

        elif type_of_union == 'displayName':
            if display_name is None:
                raise ValueError('a union value must not be None')
            self._display_name = display_name
            self._type = 'displayName'
        elif type_of_union == 'removeType':
            if remove_type is None:
                raise ValueError('a union value must not be None')
            self._remove_type = remove_type
            self._type = 'removeType'

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def remove_type(self) -> Optional["security_api_workspace_RemoveType"]:
        return self._remove_type

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor):
            raise ValueError('{} is not an instance of security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor'.format(visitor.__class__.__name__))
        if self._type == 'displayName' and self.display_name is not None:
            return visitor._display_name(self.display_name)
        if self._type == 'removeType' and self.remove_type is not None:
            return visitor._remove_type(self.remove_type)


security_api_workspace_UpdateOrRemoveWorkspaceDisplayName.__name__ = "UpdateOrRemoveWorkspaceDisplayName"
security_api_workspace_UpdateOrRemoveWorkspaceDisplayName.__qualname__ = "UpdateOrRemoveWorkspaceDisplayName"
security_api_workspace_UpdateOrRemoveWorkspaceDisplayName.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor:

    @abstractmethod
    def _display_name(self, display_name: str) -> Any:
        pass

    @abstractmethod
    def _remove_type(self, remove_type: "security_api_workspace_RemoveType") -> Any:
        pass


security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor.__name__ = "UpdateOrRemoveWorkspaceDisplayNameVisitor"
security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor.__qualname__ = "UpdateOrRemoveWorkspaceDisplayNameVisitor"
security_api_workspace_UpdateOrRemoveWorkspaceDisplayNameVisitor.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_UpdateOrRemoveWorkspaceSymbol(ConjureUnionType):
    """The request to update the symbol of the workspace. The request will replace the existing symbol
with the symbol specified if it's provided. Otherwise, the current symbol will be removed from
the workspace.
    """
    _symbol: Optional["security_api_workspace_WorkspaceSymbol"] = None
    _remove_type: Optional["security_api_workspace_RemoveType"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'symbol': ConjureFieldDefinition('symbol', security_api_workspace_WorkspaceSymbol),
            'remove_type': ConjureFieldDefinition('removeType', security_api_workspace_RemoveType)
        }

    def __init__(
            self,
            symbol: Optional["security_api_workspace_WorkspaceSymbol"] = None,
            remove_type: Optional["security_api_workspace_RemoveType"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (symbol is not None) + (remove_type is not None) != 1:
                raise ValueError('a union must contain a single member')

            if symbol is not None:
                self._symbol = symbol
                self._type = 'symbol'
            if remove_type is not None:
                self._remove_type = remove_type
                self._type = 'removeType'

        elif type_of_union == 'symbol':
            if symbol is None:
                raise ValueError('a union value must not be None')
            self._symbol = symbol
            self._type = 'symbol'
        elif type_of_union == 'removeType':
            if remove_type is None:
                raise ValueError('a union value must not be None')
            self._remove_type = remove_type
            self._type = 'removeType'

    @builtins.property
    def symbol(self) -> Optional["security_api_workspace_WorkspaceSymbol"]:
        return self._symbol

    @builtins.property
    def remove_type(self) -> Optional["security_api_workspace_RemoveType"]:
        return self._remove_type

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor):
            raise ValueError('{} is not an instance of security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor'.format(visitor.__class__.__name__))
        if self._type == 'symbol' and self.symbol is not None:
            return visitor._symbol(self.symbol)
        if self._type == 'removeType' and self.remove_type is not None:
            return visitor._remove_type(self.remove_type)


security_api_workspace_UpdateOrRemoveWorkspaceSymbol.__name__ = "UpdateOrRemoveWorkspaceSymbol"
security_api_workspace_UpdateOrRemoveWorkspaceSymbol.__qualname__ = "UpdateOrRemoveWorkspaceSymbol"
security_api_workspace_UpdateOrRemoveWorkspaceSymbol.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor:

    @abstractmethod
    def _symbol(self, symbol: "security_api_workspace_WorkspaceSymbol") -> Any:
        pass

    @abstractmethod
    def _remove_type(self, remove_type: "security_api_workspace_RemoveType") -> Any:
        pass


security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor.__name__ = "UpdateOrRemoveWorkspaceSymbolVisitor"
security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor.__qualname__ = "UpdateOrRemoveWorkspaceSymbolVisitor"
security_api_workspace_UpdateOrRemoveWorkspaceSymbolVisitor.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_UpdateWorkspaceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[security_api_workspace_UpdateOrRemoveWorkspaceDisplayName]),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[security_api_workspace_UpdateOrRemoveWorkspaceSymbol]),
            'settings': ConjureFieldDefinition('settings', OptionalTypeWrapper[security_api_workspace_WorkspaceSettings])
        }

    __slots__: List[str] = ['_display_name', '_symbol', '_settings']

    def __init__(self, display_name: Optional["security_api_workspace_UpdateOrRemoveWorkspaceDisplayName"] = None, settings: Optional["security_api_workspace_WorkspaceSettings"] = None, symbol: Optional["security_api_workspace_UpdateOrRemoveWorkspaceSymbol"] = None) -> None:
        self._display_name = display_name
        self._symbol = symbol
        self._settings = settings

    @builtins.property
    def display_name(self) -> Optional["security_api_workspace_UpdateOrRemoveWorkspaceDisplayName"]:
        return self._display_name

    @builtins.property
    def symbol(self) -> Optional["security_api_workspace_UpdateOrRemoveWorkspaceSymbol"]:
        return self._symbol

    @builtins.property
    def settings(self) -> Optional["security_api_workspace_WorkspaceSettings"]:
        return self._settings


security_api_workspace_UpdateWorkspaceRequest.__name__ = "UpdateWorkspaceRequest"
security_api_workspace_UpdateWorkspaceRequest.__qualname__ = "UpdateWorkspaceRequest"
security_api_workspace_UpdateWorkspaceRequest.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_Workspace(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', api_ids_WorkspaceId),
            'rid': ConjureFieldDefinition('rid', api_rids_WorkspaceRid),
            'org': ConjureFieldDefinition('org', authentication_api_OrgRid),
            'display_name': ConjureFieldDefinition('displayName', OptionalTypeWrapper[str]),
            'symbol': ConjureFieldDefinition('symbol', OptionalTypeWrapper[security_api_workspace_WorkspaceSymbol]),
            'settings': ConjureFieldDefinition('settings', security_api_workspace_WorkspaceSettings)
        }

    __slots__: List[str] = ['_id', '_rid', '_org', '_display_name', '_symbol', '_settings']

    def __init__(self, id: str, org: str, rid: str, settings: "security_api_workspace_WorkspaceSettings", display_name: Optional[str] = None, symbol: Optional["security_api_workspace_WorkspaceSymbol"] = None) -> None:
        self._id = id
        self._rid = rid
        self._org = org
        self._display_name = display_name
        self._symbol = symbol
        self._settings = settings

    @builtins.property
    def id(self) -> str:
        """A unique identifier for the workspace within the organization. The workspace ID must be lower case alphanumeric characters, optionally separated by hyphens.
        """
        return self._id

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def org(self) -> str:
        return self._org

    @builtins.property
    def display_name(self) -> Optional[str]:
        return self._display_name

    @builtins.property
    def symbol(self) -> Optional["security_api_workspace_WorkspaceSymbol"]:
        return self._symbol

    @builtins.property
    def settings(self) -> "security_api_workspace_WorkspaceSettings":
        return self._settings


security_api_workspace_Workspace.__name__ = "Workspace"
security_api_workspace_Workspace.__qualname__ = "Workspace"
security_api_workspace_Workspace.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_WorkspaceService(Service):
    """This service provides information about workspaces. Workspaces provide access control boundaries. All resources in
Nominal live within a workspace.
    """

    def get_workspaces(self, auth_header: str) -> List["security_api_workspace_Workspace"]:
        """Gets all workspaces that the requesting user belongs to.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/workspaces/v1/workspaces'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[security_api_workspace_Workspace], self._return_none_for_unknown_union_types)

    def get_workspace(self, auth_header: str, workspace_rid: str) -> "security_api_workspace_Workspace":
        """Gets the workspace with the specified WorkspaceRid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'workspaceRid': quote(str(_conjure_encoder.default(workspace_rid)), safe=''),
        }

        _json: Any = None

        _path = '/workspaces/v1/workspaces/{workspaceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), security_api_workspace_Workspace, self._return_none_for_unknown_union_types)

    def update_workspace(self, auth_header: str, request: "security_api_workspace_UpdateWorkspaceRequest", rid: str) -> "security_api_workspace_Workspace":
        """Updates the settings of the workspace with the specified WorkspaceRid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/workspaces/v1/workspaces/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), security_api_workspace_Workspace, self._return_none_for_unknown_union_types)

    def get_default_workspace(self, auth_header: str) -> Optional["security_api_workspace_Workspace"]:
        """Gets the default workspace for the requesting user. If the user belongs to a single workspace,
that workspace is returned. Otherwise, if the user's organization has a default workspace and
the user belongs to it, that will be returned.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/workspaces/v1/default-workspace'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return None if _response.status_code == 204 else _decoder.decode(_response.json(), OptionalTypeWrapper[security_api_workspace_Workspace], self._return_none_for_unknown_union_types)


security_api_workspace_WorkspaceService.__name__ = "WorkspaceService"
security_api_workspace_WorkspaceService.__qualname__ = "WorkspaceService"
security_api_workspace_WorkspaceService.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_WorkspaceSettings(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'ref_names': ConjureFieldDefinition('refNames', OptionalTypeWrapper[security_api_workspace_PreferredRefNameConfiguration]),
            'procedures': ConjureFieldDefinition('procedures', OptionalTypeWrapper[security_api_workspace_ProcedureSettings])
        }

    __slots__: List[str] = ['_ref_names', '_procedures']

    def __init__(self, procedures: Optional["security_api_workspace_ProcedureSettings"] = None, ref_names: Optional["security_api_workspace_PreferredRefNameConfiguration"] = None) -> None:
        self._ref_names = ref_names
        self._procedures = procedures

    @builtins.property
    def ref_names(self) -> Optional["security_api_workspace_PreferredRefNameConfiguration"]:
        return self._ref_names

    @builtins.property
    def procedures(self) -> Optional["security_api_workspace_ProcedureSettings"]:
        return self._procedures


security_api_workspace_WorkspaceSettings.__name__ = "WorkspaceSettings"
security_api_workspace_WorkspaceSettings.__qualname__ = "WorkspaceSettings"
security_api_workspace_WorkspaceSettings.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_WorkspaceSymbol(ConjureUnionType):
    _icon: Optional[str] = None
    _emoji: Optional[str] = None
    _image: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'icon': ConjureFieldDefinition('icon', str),
            'emoji': ConjureFieldDefinition('emoji', str),
            'image': ConjureFieldDefinition('image', str)
        }

    def __init__(
            self,
            icon: Optional[str] = None,
            emoji: Optional[str] = None,
            image: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (icon is not None) + (emoji is not None) + (image is not None) != 1:
                raise ValueError('a union must contain a single member')

            if icon is not None:
                self._icon = icon
                self._type = 'icon'
            if emoji is not None:
                self._emoji = emoji
                self._type = 'emoji'
            if image is not None:
                self._image = image
                self._type = 'image'

        elif type_of_union == 'icon':
            if icon is None:
                raise ValueError('a union value must not be None')
            self._icon = icon
            self._type = 'icon'
        elif type_of_union == 'emoji':
            if emoji is None:
                raise ValueError('a union value must not be None')
            self._emoji = emoji
            self._type = 'emoji'
        elif type_of_union == 'image':
            if image is None:
                raise ValueError('a union value must not be None')
            self._image = image
            self._type = 'image'

    @builtins.property
    def icon(self) -> Optional[str]:
        """Workspace icon name (e.g. castle)
        """
        return self._icon

    @builtins.property
    def emoji(self) -> Optional[str]:
        """Workspace emoji name (e.g. :castle:)
        """
        return self._emoji

    @builtins.property
    def image(self) -> Optional[str]:
        """Workspace image url (e.g. https://example.com/image.png)
        """
        return self._image

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, security_api_workspace_WorkspaceSymbolVisitor):
            raise ValueError('{} is not an instance of security_api_workspace_WorkspaceSymbolVisitor'.format(visitor.__class__.__name__))
        if self._type == 'icon' and self.icon is not None:
            return visitor._icon(self.icon)
        if self._type == 'emoji' and self.emoji is not None:
            return visitor._emoji(self.emoji)
        if self._type == 'image' and self.image is not None:
            return visitor._image(self.image)


security_api_workspace_WorkspaceSymbol.__name__ = "WorkspaceSymbol"
security_api_workspace_WorkspaceSymbol.__qualname__ = "WorkspaceSymbol"
security_api_workspace_WorkspaceSymbol.__module__ = "nominal_api.security_api_workspace"


class security_api_workspace_WorkspaceSymbolVisitor:

    @abstractmethod
    def _icon(self, icon: str) -> Any:
        pass

    @abstractmethod
    def _emoji(self, emoji: str) -> Any:
        pass

    @abstractmethod
    def _image(self, image: str) -> Any:
        pass


security_api_workspace_WorkspaceSymbolVisitor.__name__ = "WorkspaceSymbolVisitor"
security_api_workspace_WorkspaceSymbolVisitor.__qualname__ = "WorkspaceSymbolVisitor"
security_api_workspace_WorkspaceSymbolVisitor.__module__ = "nominal_api.security_api_workspace"


class storage_datasource_api_CreateNominalDataSourceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'id': ConjureFieldDefinition('id', storage_datasource_api_NominalDataSourceId),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'granularity': ConjureFieldDefinition('granularity', OptionalTypeWrapper[api_Granularity]),
            'in_memory_streaming_enabled': ConjureFieldDefinition('inMemoryStreamingEnabled', OptionalTypeWrapper[bool]),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_id', '_description', '_granularity', '_in_memory_streaming_enabled', '_workspace']

    def __init__(self, id: str, description: Optional[str] = None, granularity: Optional["api_Granularity"] = None, in_memory_streaming_enabled: Optional[bool] = None, workspace: Optional[str] = None) -> None:
        self._id = id
        self._description = description
        self._granularity = granularity
        self._in_memory_streaming_enabled = in_memory_streaming_enabled
        self._workspace = workspace

    @builtins.property
    def id(self) -> str:
        """A human readable identifier. Must be unique within an organization.
        """
        return self._id

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def granularity(self) -> Optional["api_Granularity"]:
        """Specifies the timestamp granularity of the datasource (i.e., picosecond or nanosecond scale).
Defaults to nanosecond granularity.
        """
        return self._granularity

    @builtins.property
    def in_memory_streaming_enabled(self) -> Optional[bool]:
        return self._in_memory_streaming_enabled

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the datasource. If not provided, the datasource will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


storage_datasource_api_CreateNominalDataSourceRequest.__name__ = "CreateNominalDataSourceRequest"
storage_datasource_api_CreateNominalDataSourceRequest.__qualname__ = "CreateNominalDataSourceRequest"
storage_datasource_api_CreateNominalDataSourceRequest.__module__ = "nominal_api.storage_datasource_api"


class storage_datasource_api_NominalDataSource(ConjureBeanType):
    """A logical grouping of series.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_NominalDataSourceRid),
            'id': ConjureFieldDefinition('id', storage_datasource_api_NominalDataSourceId),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'data_last_written_at': ConjureFieldDefinition('dataLastWrittenAt', OptionalTypeWrapper[str]),
            'granularity': ConjureFieldDefinition('granularity', api_Granularity),
            'in_memory_streaming_enabled': ConjureFieldDefinition('inMemoryStreamingEnabled', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_rid', '_id', '_description', '_data_last_written_at', '_granularity', '_in_memory_streaming_enabled']

    def __init__(self, granularity: "api_Granularity", id: str, rid: str, data_last_written_at: Optional[str] = None, description: Optional[str] = None, in_memory_streaming_enabled: Optional[bool] = None) -> None:
        self._rid = rid
        self._id = id
        self._description = description
        self._data_last_written_at = data_last_written_at
        self._granularity = granularity
        self._in_memory_streaming_enabled = in_memory_streaming_enabled

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def id(self) -> str:
        return self._id

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def data_last_written_at(self) -> Optional[str]:
        """Returns the approximate timestamp at which data was written to the data source.
Will be accurate to within 1 minute.
        """
        return self._data_last_written_at

    @builtins.property
    def granularity(self) -> "api_Granularity":
        return self._granularity

    @builtins.property
    def in_memory_streaming_enabled(self) -> Optional[bool]:
        return self._in_memory_streaming_enabled


storage_datasource_api_NominalDataSource.__name__ = "NominalDataSource"
storage_datasource_api_NominalDataSource.__qualname__ = "NominalDataSource"
storage_datasource_api_NominalDataSource.__module__ = "nominal_api.storage_datasource_api"


class storage_datasource_api_NominalDataSourceService(Service):
    """Manages data sources (logical groupings of series) that are stored by Nominal.
    """

    def create(self, auth_header: str, request: "storage_datasource_api_CreateNominalDataSourceRequest") -> "storage_datasource_api_NominalDataSource":
        """Creates a data source.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/data-source/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_datasource_api_NominalDataSource, self._return_none_for_unknown_union_types)

    def update(self, auth_header: str, request: "storage_datasource_api_UpdateNominalDataSourceRequest", rid: str) -> "storage_datasource_api_NominalDataSource":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/data-source/v1/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), storage_datasource_api_NominalDataSource, self._return_none_for_unknown_union_types)

    def batch_get(self, auth_header: str, rids: List[str] = None) -> List["storage_datasource_api_NominalDataSource"]:
        """Retrieves the data sources for the given data source RIDs.

Excludes data sources that do not exist or are unauthorized. A maximum of 1000 rids can be requested.
        """
        rids = rids if rids is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(rids)

        _path = '/storage/data-source/v1/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[storage_datasource_api_NominalDataSource], self._return_none_for_unknown_union_types)

    def update_last_written_timestamp(self, auth_header: str, rid: str, timestamp: str) -> None:
        """Sets the timestamp that the Nominal Data Source in question was last written to. Only needs to be called once per minute.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(timestamp)

        _path = '/storage/data-source/v1/{rid}/last-written'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def ensure_dataset_for_data_source(self, auth_header: str, rid: str) -> str:
        """Ensures a corresponding dataset exists for the given NominalDataSource.
If the dataset already exists, this is a no-op. If it doesn't exist, creates one
with the same UUID as the NominalDataSource. This is to facilitate the migration from NominalDataSource to Dataset.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/storage/data-source/v1/{rid}/ensure-dataset'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), api_rids_DatasetRid, self._return_none_for_unknown_union_types)


storage_datasource_api_NominalDataSourceService.__name__ = "NominalDataSourceService"
storage_datasource_api_NominalDataSourceService.__qualname__ = "NominalDataSourceService"
storage_datasource_api_NominalDataSourceService.__module__ = "nominal_api.storage_datasource_api"


class storage_datasource_api_UpdateNominalDataSourceRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'in_memory_streaming_enabled': ConjureFieldDefinition('inMemoryStreamingEnabled', bool)
        }

    __slots__: List[str] = ['_in_memory_streaming_enabled']

    def __init__(self, in_memory_streaming_enabled: bool) -> None:
        self._in_memory_streaming_enabled = in_memory_streaming_enabled

    @builtins.property
    def in_memory_streaming_enabled(self) -> bool:
        return self._in_memory_streaming_enabled


storage_datasource_api_UpdateNominalDataSourceRequest.__name__ = "UpdateNominalDataSourceRequest"
storage_datasource_api_UpdateNominalDataSourceRequest.__qualname__ = "UpdateNominalDataSourceRequest"
storage_datasource_api_UpdateNominalDataSourceRequest.__module__ = "nominal_api.storage_datasource_api"


class storage_deletion_api_DataDeletionService(Service):

    def delete(self, auth_header: str, request: "storage_deletion_api_DeleteDataRequest") -> None:
        """Deletes stored data. This is an irreversible operation so be careful about specified
time range, channel names, and tag scope. requires the user to be an admin for the organization.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/data-deletion/v1/delete-data'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


storage_deletion_api_DataDeletionService.__name__ = "DataDeletionService"
storage_deletion_api_DataDeletionService.__qualname__ = "DataDeletionService"
storage_deletion_api_DataDeletionService.__module__ = "nominal_api.storage_deletion_api"


class storage_deletion_api_DeleteDataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_NominalDataSourceOrDatasetRid),
            'time_range': ConjureFieldDefinition('timeRange', OptionalTypeWrapper[api_Range]),
            'tags': ConjureFieldDefinition('tags', OptionalTypeWrapper[Dict[api_TagName, api_TagValue]]),
            'channel_names': ConjureFieldDefinition('channelNames', OptionalTypeWrapper[List[api_Channel]]),
            'delete_metadata': ConjureFieldDefinition('deleteMetadata', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_data_source_rid', '_time_range', '_tags', '_channel_names', '_delete_metadata']

    def __init__(self, data_source_rid: str, channel_names: Optional[List[str]] = None, delete_metadata: Optional[bool] = None, tags: Optional[Dict[str, str]] = None, time_range: Optional["api_Range"] = None) -> None:
        self._data_source_rid = data_source_rid
        self._time_range = time_range
        self._tags = tags
        self._channel_names = channel_names
        self._delete_metadata = delete_metadata

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def time_range(self) -> Optional["api_Range"]:
        """If specified, will only delete data within the given time range.
If not specified, will delete data across all time.
        """
        return self._time_range

    @builtins.property
    def tags(self) -> Optional[Dict[str, str]]:
        """If specified, will only delete data that fully matches the given tags.
If not specified, will delete data across all tags.
        """
        return self._tags

    @builtins.property
    def channel_names(self) -> Optional[List[str]]:
        """If specified, will only delete data that has an exact channel name match with the given names.
If not specified, will delete data across all channels.
        """
        return self._channel_names

    @builtins.property
    def delete_metadata(self) -> Optional[bool]:
        """If true and tags and channelNames are empty, will also delete associated channel metadata.
Otherwise, will only delete raw data. This is to guarantee that you are not orphaning data unintentionally
by deleting the metadata.
        """
        return self._delete_metadata


storage_deletion_api_DeleteDataRequest.__name__ = "DeleteDataRequest"
storage_deletion_api_DeleteDataRequest.__qualname__ = "DeleteDataRequest"
storage_deletion_api_DeleteDataRequest.__module__ = "nominal_api.storage_deletion_api"


class storage_series_api_NominalDataType(ConjureEnumType):
    """The data types supported by Nominal's database.
    """

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    LOG = 'LOG'
    '''LOG'''
    INT64 = 'INT64'
    '''INT64'''
    UINT64 = 'UINT64'
    '''UINT64'''
    DOUBLE_ARRAY = 'DOUBLE_ARRAY'
    '''DOUBLE_ARRAY'''
    STRING_ARRAY = 'STRING_ARRAY'
    '''STRING_ARRAY'''
    STRUCT = 'STRUCT'
    '''STRUCT'''
    VIDEO = 'VIDEO'
    '''VIDEO'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


storage_series_api_NominalDataType.__name__ = "NominalDataType"
storage_series_api_NominalDataType.__qualname__ = "NominalDataType"
storage_series_api_NominalDataType.__module__ = "nominal_api.storage_series_api"


class storage_writer_api_ArrayPoints(ConjureUnionType):
    """Array points for the internal API for directly writing points which supports all points types.
    """
    _double: Optional[List["storage_writer_api_DoubleArrayPoint"]] = None
    _string: Optional[List["storage_writer_api_StringArrayPoint"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'double': ConjureFieldDefinition('double', List[storage_writer_api_DoubleArrayPoint]),
            'string': ConjureFieldDefinition('string', List[storage_writer_api_StringArrayPoint])
        }

    def __init__(
            self,
            double: Optional[List["storage_writer_api_DoubleArrayPoint"]] = None,
            string: Optional[List["storage_writer_api_StringArrayPoint"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (double is not None) + (string is not None) != 1:
                raise ValueError('a union must contain a single member')

            if double is not None:
                self._double = double
                self._type = 'double'
            if string is not None:
                self._string = string
                self._type = 'string'

        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'

    @builtins.property
    def double(self) -> Optional[List["storage_writer_api_DoubleArrayPoint"]]:
        return self._double

    @builtins.property
    def string(self) -> Optional[List["storage_writer_api_StringArrayPoint"]]:
        return self._string

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_ArrayPointsVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_ArrayPointsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)


storage_writer_api_ArrayPoints.__name__ = "ArrayPoints"
storage_writer_api_ArrayPoints.__qualname__ = "ArrayPoints"
storage_writer_api_ArrayPoints.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ArrayPointsVisitor:

    @abstractmethod
    def _double(self, double: List["storage_writer_api_DoubleArrayPoint"]) -> Any:
        pass

    @abstractmethod
    def _string(self, string: List["storage_writer_api_StringArrayPoint"]) -> Any:
        pass


storage_writer_api_ArrayPointsVisitor.__name__ = "ArrayPointsVisitor"
storage_writer_api_ArrayPointsVisitor.__qualname__ = "ArrayPointsVisitor"
storage_writer_api_ArrayPointsVisitor.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ArraysValues(ConjureUnionType):
    """Each element within the outer list corresponds to an Array point. Subsequent inner lists contain the array 
values recorded for that point.
    """
    _strings1d: Optional[List[List[str]]] = None
    _doubles1d: Optional[List[List[float]]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'strings1d': ConjureFieldDefinition('strings1d', List[List[str]]),
            'doubles1d': ConjureFieldDefinition('doubles1d', List[List[float]])
        }

    def __init__(
            self,
            strings1d: Optional[List[List[str]]] = None,
            doubles1d: Optional[List[List[float]]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (strings1d is not None) + (doubles1d is not None) != 1:
                raise ValueError('a union must contain a single member')

            if strings1d is not None:
                self._strings1d = strings1d
                self._type = 'strings1d'
            if doubles1d is not None:
                self._doubles1d = doubles1d
                self._type = 'doubles1d'

        elif type_of_union == 'strings1d':
            if strings1d is None:
                raise ValueError('a union value must not be None')
            self._strings1d = strings1d
            self._type = 'strings1d'
        elif type_of_union == 'doubles1d':
            if doubles1d is None:
                raise ValueError('a union value must not be None')
            self._doubles1d = doubles1d
            self._type = 'doubles1d'

    @builtins.property
    def strings1d(self) -> Optional[List[List[str]]]:
        return self._strings1d

    @builtins.property
    def doubles1d(self) -> Optional[List[List[float]]]:
        return self._doubles1d

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_ArraysValuesVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_ArraysValuesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'strings1d' and self.strings1d is not None:
            return visitor._strings1d(self.strings1d)
        if self._type == 'doubles1d' and self.doubles1d is not None:
            return visitor._doubles1d(self.doubles1d)


storage_writer_api_ArraysValues.__name__ = "ArraysValues"
storage_writer_api_ArraysValues.__qualname__ = "ArraysValues"
storage_writer_api_ArraysValues.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ArraysValuesVisitor:

    @abstractmethod
    def _strings1d(self, strings1d: List[List[str]]) -> Any:
        pass

    @abstractmethod
    def _doubles1d(self, doubles1d: List[List[float]]) -> Any:
        pass


storage_writer_api_ArraysValuesVisitor.__name__ = "ArraysValuesVisitor"
storage_writer_api_ArraysValuesVisitor.__qualname__ = "ArraysValuesVisitor"
storage_writer_api_ArraysValuesVisitor.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ColumnBatch(ConjureBeanType):
    """Batch of data to stream for a single channel with their associated timestamps.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'timestamps': ConjureFieldDefinition('timestamps', List[api_Timestamp]),
            'values': ConjureFieldDefinition('values', storage_writer_api_ColumnValues)
        }

    __slots__: List[str] = ['_channel', '_tags', '_timestamps', '_values']

    def __init__(self, channel: str, tags: Dict[str, str], timestamps: List["api_Timestamp"], values: "storage_writer_api_ColumnValues") -> None:
        self._channel = channel
        self._tags = tags
        self._timestamps = timestamps
        self._values = values

    @builtins.property
    def channel(self) -> str:
        """Channel within nominal to stream data to.
        """
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """Mapping of key-value pairs to provide as tags to all points within the batch
        """
        return self._tags

    @builtins.property
    def timestamps(self) -> List["api_Timestamp"]:
        """List of timestamp values that correspond to the provided list of column values. The number of timestamps
provided MUST match the number of columnar values provided, otherwise a 400 error will be returned.
        """
        return self._timestamps

    @builtins.property
    def values(self) -> "storage_writer_api_ColumnValues":
        """List of time series values that should be ingested to a single channel. The number of columnar values
provided MUST match the number of timestamps provided, otherwise a 400 error will be returned.
        """
        return self._values


storage_writer_api_ColumnBatch.__name__ = "ColumnBatch"
storage_writer_api_ColumnBatch.__qualname__ = "ColumnBatch"
storage_writer_api_ColumnBatch.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ColumnValues(ConjureUnionType):
    """List of values for a set of points to ingest from a single channel.
    """
    _strings: Optional[List[str]] = None
    _doubles: Optional[List[float]] = None
    _ints: Optional[List[int]] = None
    _arrays: Optional["storage_writer_api_ArraysValues"] = None
    _structs: Optional[List[str]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'strings': ConjureFieldDefinition('strings', List[str]),
            'doubles': ConjureFieldDefinition('doubles', List[float]),
            'ints': ConjureFieldDefinition('ints', List[int]),
            'arrays': ConjureFieldDefinition('arrays', storage_writer_api_ArraysValues),
            'structs': ConjureFieldDefinition('structs', List[str])
        }

    def __init__(
            self,
            strings: Optional[List[str]] = None,
            doubles: Optional[List[float]] = None,
            ints: Optional[List[int]] = None,
            arrays: Optional["storage_writer_api_ArraysValues"] = None,
            structs: Optional[List[str]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (strings is not None) + (doubles is not None) + (ints is not None) + (arrays is not None) + (structs is not None) != 1:
                raise ValueError('a union must contain a single member')

            if strings is not None:
                self._strings = strings
                self._type = 'strings'
            if doubles is not None:
                self._doubles = doubles
                self._type = 'doubles'
            if ints is not None:
                self._ints = ints
                self._type = 'ints'
            if arrays is not None:
                self._arrays = arrays
                self._type = 'arrays'
            if structs is not None:
                self._structs = structs
                self._type = 'structs'

        elif type_of_union == 'strings':
            if strings is None:
                raise ValueError('a union value must not be None')
            self._strings = strings
            self._type = 'strings'
        elif type_of_union == 'doubles':
            if doubles is None:
                raise ValueError('a union value must not be None')
            self._doubles = doubles
            self._type = 'doubles'
        elif type_of_union == 'ints':
            if ints is None:
                raise ValueError('a union value must not be None')
            self._ints = ints
            self._type = 'ints'
        elif type_of_union == 'arrays':
            if arrays is None:
                raise ValueError('a union value must not be None')
            self._arrays = arrays
            self._type = 'arrays'
        elif type_of_union == 'structs':
            if structs is None:
                raise ValueError('a union value must not be None')
            self._structs = structs
            self._type = 'structs'

    @builtins.property
    def strings(self) -> Optional[List[str]]:
        return self._strings

    @builtins.property
    def doubles(self) -> Optional[List[float]]:
        return self._doubles

    @builtins.property
    def ints(self) -> Optional[List[int]]:
        return self._ints

    @builtins.property
    def arrays(self) -> Optional["storage_writer_api_ArraysValues"]:
        return self._arrays

    @builtins.property
    def structs(self) -> Optional[List[str]]:
        return self._structs

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_ColumnValuesVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_ColumnValuesVisitor'.format(visitor.__class__.__name__))
        if self._type == 'strings' and self.strings is not None:
            return visitor._strings(self.strings)
        if self._type == 'doubles' and self.doubles is not None:
            return visitor._doubles(self.doubles)
        if self._type == 'ints' and self.ints is not None:
            return visitor._ints(self.ints)
        if self._type == 'arrays' and self.arrays is not None:
            return visitor._arrays(self.arrays)
        if self._type == 'structs' and self.structs is not None:
            return visitor._structs(self.structs)


storage_writer_api_ColumnValues.__name__ = "ColumnValues"
storage_writer_api_ColumnValues.__qualname__ = "ColumnValues"
storage_writer_api_ColumnValues.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_ColumnValuesVisitor:

    @abstractmethod
    def _strings(self, strings: List[str]) -> Any:
        pass

    @abstractmethod
    def _doubles(self, doubles: List[float]) -> Any:
        pass

    @abstractmethod
    def _ints(self, ints: List[int]) -> Any:
        pass

    @abstractmethod
    def _arrays(self, arrays: "storage_writer_api_ArraysValues") -> Any:
        pass

    @abstractmethod
    def _structs(self, structs: List[str]) -> Any:
        pass


storage_writer_api_ColumnValuesVisitor.__name__ = "ColumnValuesVisitor"
storage_writer_api_ColumnValuesVisitor.__qualname__ = "ColumnValuesVisitor"
storage_writer_api_ColumnValuesVisitor.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_DirectNominalChannelWriterService(Service):
    """Writes data points directly to Nominal's managed database offering.
    """

    def write_batches(self, auth_header: str, request: "storage_writer_api_WriteBatchesRequest") -> None:
        """Synchronously writes batches of records to a Nominal data source. This endpoint bypasses the
Channel Writer service entirely, and should only be used if the implications are well understood.

If you call this endpoint, writes will go directly into Nominal DB and will not be placed in Nominal's
durable queue. This results in lower latency, but also consequently lower durability.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/direct-writer/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


storage_writer_api_DirectNominalChannelWriterService.__name__ = "DirectNominalChannelWriterService"
storage_writer_api_DirectNominalChannelWriterService.__qualname__ = "DirectNominalChannelWriterService"
storage_writer_api_DirectNominalChannelWriterService.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_DoubleArrayPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', List[float])
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: List[float]) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> List[float]:
        return self._value


storage_writer_api_DoubleArrayPoint.__name__ = "DoubleArrayPoint"
storage_writer_api_DoubleArrayPoint.__qualname__ = "DoubleArrayPoint"
storage_writer_api_DoubleArrayPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_DoublePoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', float)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: float) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> float:
        return self._value


storage_writer_api_DoublePoint.__name__ = "DoublePoint"
storage_writer_api_DoublePoint.__qualname__ = "DoublePoint"
storage_writer_api_DoublePoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_IntPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', int)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: int) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> int:
        return self._value


storage_writer_api_IntPoint.__name__ = "IntPoint"
storage_writer_api_IntPoint.__qualname__ = "IntPoint"
storage_writer_api_IntPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_LogPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', storage_writer_api_LogValue)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: "storage_writer_api_LogValue") -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> "storage_writer_api_LogValue":
        return self._value


storage_writer_api_LogPoint.__name__ = "LogPoint"
storage_writer_api_LogPoint.__qualname__ = "LogPoint"
storage_writer_api_LogPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_LogValue(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str),
            'args': ConjureFieldDefinition('args', Dict[str, str])
        }

    __slots__: List[str] = ['_message', '_args']

    def __init__(self, args: Dict[str, str], message: str) -> None:
        self._message = message
        self._args = args

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def args(self) -> Dict[str, str]:
        return self._args


storage_writer_api_LogValue.__name__ = "LogValue"
storage_writer_api_LogValue.__qualname__ = "LogValue"
storage_writer_api_LogValue.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_NominalChannelWriterService(Service):
    """Write data points to Nominal data sources.
    """

    def write_batches(self, auth_header: str, request: "storage_writer_api_WriteBatchesRequestExternal") -> None:
        """Synchronously writes batches of records to a Nominal data source.

If the request is too large, either due to the number of individual batches (> 10) or the number of points
across batches (> 500k), the request may be split up into multiple requests internally when writing to the
Nominal data source. Generally, it's advisable to limit the number of points to 50k.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/writer/v1'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def write_column_batches(self, auth_header: str, request: "storage_writer_api_WriteColumnBatchesRequest") -> None:
        """Synchronously writes batches of columns of data to a Nominal data source.

This is a column-major variant of writeBatches (which is row-major) to optimize serialization and compression
time for client applications streaming large numbers of points from a single column at a time. This has the
tradeoff of slightly larger sizes post-gzipping of requests, so should be used in the particular case where
the main bottleneck is in encoding columnar data into the row-based format found in writeBatches.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/writer/v1/columnar'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def write_telegraf_batches(self, auth_header: str, data_source_rid: str, request: "storage_writer_api_WriteTelegrafBatchesRequest") -> None:
        """Synchronously writes batches of records to a Nominal data source.

Has the same functionality as writeBatches, but is compatible with the Telegraf output format.
Assumes that the Telegraf batch format is used. Timestamp is assumed to be in nanoseconds.
The URL in the Telegraf output plugin configuration should be the fully qualified URL,
including the dataSourceRid query parameter.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/writer/v1/telegraf/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def write_prometheus_batches(self, auth_header: str, data_source_rid: str, request: Any) -> None:
        """Synchronously writes batches of records to a Nominal data source.

Has the same functionality as writeBatches, but is encoded using the Prometheus remote write
format. We follow the specification defined here: https://prometheus.io/docs/specs/remote_write_spec/
There are a few notable caveats:
  1. Must be content encoded as application/x-protobuf
  2. Must be compressed using snappy compression
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _data: Any = request

        _path = '/storage/writer/v1/prometheus/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            data=_data)

        return

    def prometheus_remote_write_health_check(self, auth_header: str, data_source_rid: str) -> bool:
        """Performs a health check for prometheus remote write Vector sink. All this endpoint does
is verify if the caller is authenticated and the server is online. Once Vector allows the Prometheus
remote write endpoint to configure the healthcheck url, we can remove this endpoint.

See: https://github.com/vectordotdev/vector/issues/8279
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = None

        _path = '/storage/writer/v1/prometheus/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), bool, self._return_none_for_unknown_union_types)

    def write_nominal_batches(self, auth_header: str, data_source_rid: str, request: Any) -> None:
        """Synchronously writes a Nominal Write Request to a Nominal data source using the NominalWrite Protobuf schema.
The request must be Protobuf-encoded and accompanied by the appropriate content encoding headers if compressed.

The request should follow this Protobuf schema:
```proto
message WriteRequestNominal {
  repeated Series series = 1;
}

message Series {
  Channel channel = 1;            
  map<string, string> tags = 2;   // Key-value pairs for series tags
  Points points = 3;              // Contains double, string, integer, array, or struct points
}

message Channel {
  string name = 1;
} 

message Points {
  oneof points_type {
    DoublePoints double_points = 1;
    StringPoints string_points = 2;
    IntegerPoints integer_points = 3;
    ArrayPoints array_points = 4;
    StructPoints struct_points = 5;
    Uint64Points uint64_points = 6;
  }
}

message DoublePoints {
  repeated DoublePoint points = 1;
}

message StringPoints {
  repeated StringPoint points = 1;
}

message IntegerPoints {
  repeated IntegerPoint points = 1;
}

message Uint64Points {
  repeated Uint64Point points = 1;
}

message ArrayPoints {
  oneof array_type {
    DoubleArrayPoints double_array_points = 1;
    StringArrayPoints string_array_points = 2;
  }
}

message DoubleArrayPoints {
  repeated DoubleArrayPoint points = 1;
}

message StringArrayPoints {
  repeated StringArrayPoint points = 1;
}

message StructPoints {
  repeated StructPoint points = 1;
}

message DoublePoint {
  google.protobuf.Timestamp timestamp = 1;
  double value = 2;
}

message StringPoint {
  google.protobuf.Timestamp timestamp = 1;
  string value = 2;
}

message IntegerPoint {
  google.protobuf.Timestamp timestamp = 1;
  int64 value = 2;
}

message Uint64Point {
  google.protobuf.Timestamp timestamp = 1;
  uint64 value = 2;
}

message DoubleArrayPoint {
  google.protobuf.Timestamp timestamp = 1;
  repeated double value = 2;
}

message StringArrayPoint {
  google.protobuf.Timestamp timestamp = 1;
  repeated string value = 2;
}

message StructPoint {
  google.protobuf.Timestamp timestamp = 1;
  string jsonString = 2;
}
```

Each request can contain multiple series, where each series consists of:
- A channel name
- A map of tags (key-value pairs)
- A collection of points, which can be double, string, integer, array (double/string), or struct (json) values
- Each point includes a timestamp (using google.protobuf.Timestamp) and its value
- Array points contain repeated values (array<double> or array<string>)
- Struct points are represented using strings that contain the JSON formatted blobs, with all keys being strings

The endpoint requires the Content-Type header to be set to "application/x-protobuf".
If the payload is compressed, the appropriate Content-Encoding header must be included.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _data: Any = request

        _path = '/storage/writer/v1/nominal/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            data=_data)

        return

    def write_logs(self, auth_header: str, data_source_rid: str, request: "storage_writer_api_WriteLogsRequest") -> None:
        """Synchronously writes logs to a Nominal data source.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'dataSourceRid': quote(str(_conjure_encoder.default(data_source_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/storage/writer/v1/logs/{dataSourceRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


storage_writer_api_NominalChannelWriterService.__name__ = "NominalChannelWriterService"
storage_writer_api_NominalChannelWriterService.__qualname__ = "NominalChannelWriterService"
storage_writer_api_NominalChannelWriterService.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_Points(ConjureUnionType):
    """Points for internal API for directly writing points which supports all points types.
Logs specifically are supported externally via a separate endpoint.
    """
    _string: Optional[List["storage_writer_api_StringPoint"]] = None
    _double: Optional[List["storage_writer_api_DoublePoint"]] = None
    _log: Optional[List["storage_writer_api_LogPoint"]] = None
    _int_: Optional[List["storage_writer_api_IntPoint"]] = None
    _uint64: Optional[List["storage_writer_api_Uint64Point"]] = None
    _array: Optional["storage_writer_api_ArrayPoints"] = None
    _struct: Optional[List["storage_writer_api_StructPoint"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'string': ConjureFieldDefinition('string', List[storage_writer_api_StringPoint]),
            'double': ConjureFieldDefinition('double', List[storage_writer_api_DoublePoint]),
            'log': ConjureFieldDefinition('log', List[storage_writer_api_LogPoint]),
            'int_': ConjureFieldDefinition('int', List[storage_writer_api_IntPoint]),
            'uint64': ConjureFieldDefinition('uint64', List[storage_writer_api_Uint64Point]),
            'array': ConjureFieldDefinition('array', storage_writer_api_ArrayPoints),
            'struct': ConjureFieldDefinition('struct', List[storage_writer_api_StructPoint])
        }

    def __init__(
            self,
            string: Optional[List["storage_writer_api_StringPoint"]] = None,
            double: Optional[List["storage_writer_api_DoublePoint"]] = None,
            log: Optional[List["storage_writer_api_LogPoint"]] = None,
            int_: Optional[List["storage_writer_api_IntPoint"]] = None,
            uint64: Optional[List["storage_writer_api_Uint64Point"]] = None,
            array: Optional["storage_writer_api_ArrayPoints"] = None,
            struct: Optional[List["storage_writer_api_StructPoint"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (string is not None) + (double is not None) + (log is not None) + (int_ is not None) + (uint64 is not None) + (array is not None) + (struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if string is not None:
                self._string = string
                self._type = 'string'
            if double is not None:
                self._double = double
                self._type = 'double'
            if log is not None:
                self._log = log
                self._type = 'log'
            if int_ is not None:
                self._int_ = int_
                self._type = 'int'
            if uint64 is not None:
                self._uint64 = uint64
                self._type = 'uint64'
            if array is not None:
                self._array = array
                self._type = 'array'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'

        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'
        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'log':
            if log is None:
                raise ValueError('a union value must not be None')
            self._log = log
            self._type = 'log'
        elif type_of_union == 'int':
            if int_ is None:
                raise ValueError('a union value must not be None')
            self._int_ = int_
            self._type = 'int'
        elif type_of_union == 'uint64':
            if uint64 is None:
                raise ValueError('a union value must not be None')
            self._uint64 = uint64
            self._type = 'uint64'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'

    @builtins.property
    def string(self) -> Optional[List["storage_writer_api_StringPoint"]]:
        return self._string

    @builtins.property
    def double(self) -> Optional[List["storage_writer_api_DoublePoint"]]:
        return self._double

    @builtins.property
    def log(self) -> Optional[List["storage_writer_api_LogPoint"]]:
        return self._log

    @builtins.property
    def int_(self) -> Optional[List["storage_writer_api_IntPoint"]]:
        return self._int_

    @builtins.property
    def uint64(self) -> Optional[List["storage_writer_api_Uint64Point"]]:
        return self._uint64

    @builtins.property
    def array(self) -> Optional["storage_writer_api_ArrayPoints"]:
        return self._array

    @builtins.property
    def struct(self) -> Optional[List["storage_writer_api_StructPoint"]]:
        return self._struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_PointsVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_PointsVisitor'.format(visitor.__class__.__name__))
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'log' and self.log is not None:
            return visitor._log(self.log)
        if self._type == 'int' and self.int_ is not None:
            return visitor._int(self.int_)
        if self._type == 'uint64' and self.uint64 is not None:
            return visitor._uint64(self.uint64)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)


storage_writer_api_Points.__name__ = "Points"
storage_writer_api_Points.__qualname__ = "Points"
storage_writer_api_Points.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_PointsVisitor:

    @abstractmethod
    def _string(self, string: List["storage_writer_api_StringPoint"]) -> Any:
        pass

    @abstractmethod
    def _double(self, double: List["storage_writer_api_DoublePoint"]) -> Any:
        pass

    @abstractmethod
    def _log(self, log: List["storage_writer_api_LogPoint"]) -> Any:
        pass

    @abstractmethod
    def _int(self, int_: List["storage_writer_api_IntPoint"]) -> Any:
        pass

    @abstractmethod
    def _uint64(self, uint64: List["storage_writer_api_Uint64Point"]) -> Any:
        pass

    @abstractmethod
    def _array(self, array: "storage_writer_api_ArrayPoints") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: List["storage_writer_api_StructPoint"]) -> Any:
        pass


storage_writer_api_PointsVisitor.__name__ = "PointsVisitor"
storage_writer_api_PointsVisitor.__qualname__ = "PointsVisitor"
storage_writer_api_PointsVisitor.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_PointsExternal(ConjureUnionType):
    _string: Optional[List["storage_writer_api_StringPoint"]] = None
    _double: Optional[List["storage_writer_api_DoublePoint"]] = None
    _int_: Optional[List["storage_writer_api_IntPoint"]] = None
    _array: Optional["storage_writer_api_ArrayPoints"] = None
    _struct: Optional[List["storage_writer_api_StructPoint"]] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'string': ConjureFieldDefinition('string', List[storage_writer_api_StringPoint]),
            'double': ConjureFieldDefinition('double', List[storage_writer_api_DoublePoint]),
            'int_': ConjureFieldDefinition('int', List[storage_writer_api_IntPoint]),
            'array': ConjureFieldDefinition('array', storage_writer_api_ArrayPoints),
            'struct': ConjureFieldDefinition('struct', List[storage_writer_api_StructPoint])
        }

    def __init__(
            self,
            string: Optional[List["storage_writer_api_StringPoint"]] = None,
            double: Optional[List["storage_writer_api_DoublePoint"]] = None,
            int_: Optional[List["storage_writer_api_IntPoint"]] = None,
            array: Optional["storage_writer_api_ArrayPoints"] = None,
            struct: Optional[List["storage_writer_api_StructPoint"]] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (string is not None) + (double is not None) + (int_ is not None) + (array is not None) + (struct is not None) != 1:
                raise ValueError('a union must contain a single member')

            if string is not None:
                self._string = string
                self._type = 'string'
            if double is not None:
                self._double = double
                self._type = 'double'
            if int_ is not None:
                self._int_ = int_
                self._type = 'int'
            if array is not None:
                self._array = array
                self._type = 'array'
            if struct is not None:
                self._struct = struct
                self._type = 'struct'

        elif type_of_union == 'string':
            if string is None:
                raise ValueError('a union value must not be None')
            self._string = string
            self._type = 'string'
        elif type_of_union == 'double':
            if double is None:
                raise ValueError('a union value must not be None')
            self._double = double
            self._type = 'double'
        elif type_of_union == 'int':
            if int_ is None:
                raise ValueError('a union value must not be None')
            self._int_ = int_
            self._type = 'int'
        elif type_of_union == 'array':
            if array is None:
                raise ValueError('a union value must not be None')
            self._array = array
            self._type = 'array'
        elif type_of_union == 'struct':
            if struct is None:
                raise ValueError('a union value must not be None')
            self._struct = struct
            self._type = 'struct'

    @builtins.property
    def string(self) -> Optional[List["storage_writer_api_StringPoint"]]:
        return self._string

    @builtins.property
    def double(self) -> Optional[List["storage_writer_api_DoublePoint"]]:
        return self._double

    @builtins.property
    def int_(self) -> Optional[List["storage_writer_api_IntPoint"]]:
        return self._int_

    @builtins.property
    def array(self) -> Optional["storage_writer_api_ArrayPoints"]:
        return self._array

    @builtins.property
    def struct(self) -> Optional[List["storage_writer_api_StructPoint"]]:
        return self._struct

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, storage_writer_api_PointsExternalVisitor):
            raise ValueError('{} is not an instance of storage_writer_api_PointsExternalVisitor'.format(visitor.__class__.__name__))
        if self._type == 'string' and self.string is not None:
            return visitor._string(self.string)
        if self._type == 'double' and self.double is not None:
            return visitor._double(self.double)
        if self._type == 'int' and self.int_ is not None:
            return visitor._int(self.int_)
        if self._type == 'array' and self.array is not None:
            return visitor._array(self.array)
        if self._type == 'struct' and self.struct is not None:
            return visitor._struct(self.struct)


storage_writer_api_PointsExternal.__name__ = "PointsExternal"
storage_writer_api_PointsExternal.__qualname__ = "PointsExternal"
storage_writer_api_PointsExternal.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_PointsExternalVisitor:

    @abstractmethod
    def _string(self, string: List["storage_writer_api_StringPoint"]) -> Any:
        pass

    @abstractmethod
    def _double(self, double: List["storage_writer_api_DoublePoint"]) -> Any:
        pass

    @abstractmethod
    def _int(self, int_: List["storage_writer_api_IntPoint"]) -> Any:
        pass

    @abstractmethod
    def _array(self, array: "storage_writer_api_ArrayPoints") -> Any:
        pass

    @abstractmethod
    def _struct(self, struct: List["storage_writer_api_StructPoint"]) -> Any:
        pass


storage_writer_api_PointsExternalVisitor.__name__ = "PointsExternalVisitor"
storage_writer_api_PointsExternalVisitor.__qualname__ = "PointsExternalVisitor"
storage_writer_api_PointsExternalVisitor.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_RecordsBatch(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'points': ConjureFieldDefinition('points', storage_writer_api_Points)
        }

    __slots__: List[str] = ['_channel', '_tags', '_points']

    def __init__(self, channel: str, points: "storage_writer_api_Points", tags: Dict[str, str]) -> None:
        self._channel = channel
        self._tags = tags
        self._points = points

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def points(self) -> "storage_writer_api_Points":
        return self._points


storage_writer_api_RecordsBatch.__name__ = "RecordsBatch"
storage_writer_api_RecordsBatch.__qualname__ = "RecordsBatch"
storage_writer_api_RecordsBatch.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_RecordsBatchExternal(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'points': ConjureFieldDefinition('points', storage_writer_api_PointsExternal)
        }

    __slots__: List[str] = ['_channel', '_tags', '_points']

    def __init__(self, channel: str, points: "storage_writer_api_PointsExternal", tags: Dict[str, str]) -> None:
        self._channel = channel
        self._tags = tags
        self._points = points

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def points(self) -> "storage_writer_api_PointsExternal":
        return self._points


storage_writer_api_RecordsBatchExternal.__name__ = "RecordsBatchExternal"
storage_writer_api_RecordsBatchExternal.__qualname__ = "RecordsBatchExternal"
storage_writer_api_RecordsBatchExternal.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_StringArrayPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', List[str])
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: List[str]) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> List[str]:
        return self._value


storage_writer_api_StringArrayPoint.__name__ = "StringArrayPoint"
storage_writer_api_StringArrayPoint.__qualname__ = "StringArrayPoint"
storage_writer_api_StringArrayPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_StringPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', str)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: str) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> str:
        return self._value


storage_writer_api_StringPoint.__name__ = "StringPoint"
storage_writer_api_StringPoint.__qualname__ = "StringPoint"
storage_writer_api_StringPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_StructPoint(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'json_string': ConjureFieldDefinition('jsonString', str)
        }

    __slots__: List[str] = ['_timestamp', '_json_string']

    def __init__(self, json_string: str, timestamp: "api_Timestamp") -> None:
        self._timestamp = timestamp
        self._json_string = json_string

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def json_string(self) -> str:
        return self._json_string


storage_writer_api_StructPoint.__name__ = "StructPoint"
storage_writer_api_StructPoint.__qualname__ = "StructPoint"
storage_writer_api_StructPoint.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_TelegrafMetric(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'fields': ConjureFieldDefinition('fields', Dict[storage_writer_api_Field, object]),
            'name': ConjureFieldDefinition('name', storage_writer_api_MeasurementName),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'timestamp': ConjureFieldDefinition('timestamp', object)
        }

    __slots__: List[str] = ['_fields_', '_name', '_tags', '_timestamp']

    def __init__(self, fields: Dict[str, Any], name: str, tags: Dict[str, str], timestamp: Any) -> None:
        self._fields_ = fields
        self._name = name
        self._tags = tags
        self._timestamp = timestamp

    @builtins.property
    def fields(self) -> Dict[str, Any]:
        """The values are expected to be either numeric or string values
        """
        return self._fields_

    @builtins.property
    def name(self) -> str:
        """The measurement name. Measurement name and field are concatenated when creating the Nominal channel name.
        """
        return self._name

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def timestamp(self) -> Any:
        return self._timestamp


storage_writer_api_TelegrafMetric.__name__ = "TelegrafMetric"
storage_writer_api_TelegrafMetric.__qualname__ = "TelegrafMetric"
storage_writer_api_TelegrafMetric.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_Uint64Point(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timestamp': ConjureFieldDefinition('timestamp', api_Timestamp),
            'value': ConjureFieldDefinition('value', int)
        }

    __slots__: List[str] = ['_timestamp', '_value']

    def __init__(self, timestamp: "api_Timestamp", value: int) -> None:
        self._timestamp = timestamp
        self._value = value

    @builtins.property
    def timestamp(self) -> "api_Timestamp":
        return self._timestamp

    @builtins.property
    def value(self) -> int:
        return self._value


storage_writer_api_Uint64Point.__name__ = "Uint64Point"
storage_writer_api_Uint64Point.__qualname__ = "Uint64Point"
storage_writer_api_Uint64Point.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteBatchesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'batches': ConjureFieldDefinition('batches', List[storage_writer_api_RecordsBatch]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_NominalDataSourceOrDatasetRid),
            'asynchronous_insert': ConjureFieldDefinition('asynchronousInsert', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_batches', '_data_source_rid', '_asynchronous_insert']

    def __init__(self, batches: List["storage_writer_api_RecordsBatch"], data_source_rid: str, asynchronous_insert: Optional[bool] = None) -> None:
        self._batches = batches
        self._data_source_rid = data_source_rid
        self._asynchronous_insert = asynchronous_insert

    @builtins.property
    def batches(self) -> List["storage_writer_api_RecordsBatch"]:
        return self._batches

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def asynchronous_insert(self) -> Optional[bool]:
        """Is always true - setting this to false will do nothing.
        """
        return self._asynchronous_insert


storage_writer_api_WriteBatchesRequest.__name__ = "WriteBatchesRequest"
storage_writer_api_WriteBatchesRequest.__qualname__ = "WriteBatchesRequest"
storage_writer_api_WriteBatchesRequest.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteBatchesRequestExternal(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'batches': ConjureFieldDefinition('batches', List[storage_writer_api_RecordsBatchExternal]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_NominalDataSourceOrDatasetRid),
            'asynchronous_insert': ConjureFieldDefinition('asynchronousInsert', OptionalTypeWrapper[bool])
        }

    __slots__: List[str] = ['_batches', '_data_source_rid', '_asynchronous_insert']

    def __init__(self, batches: List["storage_writer_api_RecordsBatchExternal"], data_source_rid: str, asynchronous_insert: Optional[bool] = None) -> None:
        self._batches = batches
        self._data_source_rid = data_source_rid
        self._asynchronous_insert = asynchronous_insert

    @builtins.property
    def batches(self) -> List["storage_writer_api_RecordsBatchExternal"]:
        return self._batches

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def asynchronous_insert(self) -> Optional[bool]:
        """Is always true - setting this to false will do nothing.
        """
        return self._asynchronous_insert


storage_writer_api_WriteBatchesRequestExternal.__name__ = "WriteBatchesRequestExternal"
storage_writer_api_WriteBatchesRequestExternal.__qualname__ = "WriteBatchesRequestExternal"
storage_writer_api_WriteBatchesRequestExternal.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteColumnBatchesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'batches': ConjureFieldDefinition('batches', List[storage_writer_api_ColumnBatch]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_NominalDataSourceOrDatasetRid)
        }

    __slots__: List[str] = ['_batches', '_data_source_rid']

    def __init__(self, batches: List["storage_writer_api_ColumnBatch"], data_source_rid: str) -> None:
        self._batches = batches
        self._data_source_rid = data_source_rid

    @builtins.property
    def batches(self) -> List["storage_writer_api_ColumnBatch"]:
        """Batches of columnar data to stream to Nominal. Each channel's data are provided as a column batch.
        """
        return self._batches

    @builtins.property
    def data_source_rid(self) -> str:
        """RID of the datasource (e.g., for a Connection) or dataset to stream data into.
        """
        return self._data_source_rid


storage_writer_api_WriteColumnBatchesRequest.__name__ = "WriteColumnBatchesRequest"
storage_writer_api_WriteColumnBatchesRequest.__qualname__ = "WriteColumnBatchesRequest"
storage_writer_api_WriteColumnBatchesRequest.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteLogsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logs': ConjureFieldDefinition('logs', List[storage_writer_api_LogPoint]),
            'channel': ConjureFieldDefinition('channel', OptionalTypeWrapper[api_Channel])
        }

    __slots__: List[str] = ['_logs', '_channel']

    def __init__(self, logs: List["storage_writer_api_LogPoint"], channel: Optional[str] = None) -> None:
        self._logs = logs
        self._channel = channel

    @builtins.property
    def logs(self) -> List["storage_writer_api_LogPoint"]:
        return self._logs

    @builtins.property
    def channel(self) -> Optional[str]:
        """If provided, the channel to which to write logs.
If not provided, defaults to "logs"
        """
        return self._channel


storage_writer_api_WriteLogsRequest.__name__ = "WriteLogsRequest"
storage_writer_api_WriteLogsRequest.__qualname__ = "WriteLogsRequest"
storage_writer_api_WriteLogsRequest.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteStructsRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'structs': ConjureFieldDefinition('structs', List[storage_writer_api_StructPoint]),
            'channel': ConjureFieldDefinition('channel', OptionalTypeWrapper[api_Channel])
        }

    __slots__: List[str] = ['_structs', '_channel']

    def __init__(self, structs: List["storage_writer_api_StructPoint"], channel: Optional[str] = None) -> None:
        self._structs = structs
        self._channel = channel

    @builtins.property
    def structs(self) -> List["storage_writer_api_StructPoint"]:
        return self._structs

    @builtins.property
    def channel(self) -> Optional[str]:
        """If provided, the channel to which to write structs.
If not provided, defaults to "structs"
        """
        return self._channel


storage_writer_api_WriteStructsRequest.__name__ = "WriteStructsRequest"
storage_writer_api_WriteStructsRequest.__qualname__ = "WriteStructsRequest"
storage_writer_api_WriteStructsRequest.__module__ = "nominal_api.storage_writer_api"


class storage_writer_api_WriteTelegrafBatchesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'metrics': ConjureFieldDefinition('metrics', List[storage_writer_api_TelegrafMetric])
        }

    __slots__: List[str] = ['_metrics']

    def __init__(self, metrics: List["storage_writer_api_TelegrafMetric"]) -> None:
        self._metrics = metrics

    @builtins.property
    def metrics(self) -> List["storage_writer_api_TelegrafMetric"]:
        return self._metrics


storage_writer_api_WriteTelegrafBatchesRequest.__name__ = "WriteTelegrafBatchesRequest"
storage_writer_api_WriteTelegrafBatchesRequest.__qualname__ = "WriteTelegrafBatchesRequest"
storage_writer_api_WriteTelegrafBatchesRequest.__module__ = "nominal_api.storage_writer_api"


class themes_api_ChartTheme(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', themes_api_ChartThemeRid),
            'name': ConjureFieldDefinition('name', str),
            'created_by': ConjureFieldDefinition('createdBy', str),
            'created_at': ConjureFieldDefinition('createdAt', str),
            'updated_by': ConjureFieldDefinition('updatedBy', OptionalTypeWrapper[str]),
            'updated_at': ConjureFieldDefinition('updatedAt', OptionalTypeWrapper[str]),
            'content': ConjureFieldDefinition('content', themes_api_ChartThemeContent)
        }

    __slots__: List[str] = ['_rid', '_name', '_created_by', '_created_at', '_updated_by', '_updated_at', '_content']

    def __init__(self, content: "themes_api_ChartThemeContent", created_at: str, created_by: str, name: str, rid: str, updated_at: Optional[str] = None, updated_by: Optional[str] = None) -> None:
        self._rid = rid
        self._name = name
        self._created_by = created_by
        self._created_at = created_at
        self._updated_by = updated_by
        self._updated_at = updated_at
        self._content = content

    @builtins.property
    def rid(self) -> str:
        """Unique resource identifier for the theme.
        """
        return self._rid

    @builtins.property
    def name(self) -> str:
        """The name of the theme as defined by the user.
        """
        return self._name

    @builtins.property
    def created_by(self) -> str:
        """The rid of the user who first created the theme.
        """
        return self._created_by

    @builtins.property
    def created_at(self) -> str:
        """The time the theme was created.
        """
        return self._created_at

    @builtins.property
    def updated_by(self) -> Optional[str]:
        """The rid of the user who last updated the theme.
        """
        return self._updated_by

    @builtins.property
    def updated_at(self) -> Optional[str]:
        """The rid of the user who last updated the theme.
        """
        return self._updated_at

    @builtins.property
    def content(self) -> "themes_api_ChartThemeContent":
        """Specifies the chart theme styling (e.g. font, legends, axes)
        """
        return self._content


themes_api_ChartTheme.__name__ = "ChartTheme"
themes_api_ChartTheme.__qualname__ = "ChartTheme"
themes_api_ChartTheme.__module__ = "nominal_api.themes_api"


class themes_api_ChartThemeContent(ConjureUnionType):
    _v1: Optional["themes_api_ChartThemeContentV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', themes_api_ChartThemeContentV1)
        }

    def __init__(
            self,
            v1: Optional["themes_api_ChartThemeContentV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["themes_api_ChartThemeContentV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, themes_api_ChartThemeContentVisitor):
            raise ValueError('{} is not an instance of themes_api_ChartThemeContentVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


themes_api_ChartThemeContent.__name__ = "ChartThemeContent"
themes_api_ChartThemeContent.__qualname__ = "ChartThemeContent"
themes_api_ChartThemeContent.__module__ = "nominal_api.themes_api"


class themes_api_ChartThemeContentVisitor:

    @abstractmethod
    def _v1(self, v1: "themes_api_ChartThemeContentV1") -> Any:
        pass


themes_api_ChartThemeContentVisitor.__name__ = "ChartThemeContentVisitor"
themes_api_ChartThemeContentVisitor.__qualname__ = "ChartThemeContentVisitor"
themes_api_ChartThemeContentVisitor.__module__ = "nominal_api.themes_api"


class themes_api_ChartThemeContentV1(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'title_enabled': ConjureFieldDefinition('titleEnabled', bool),
            'title_alignment': ConjureFieldDefinition('titleAlignment', themes_api_TextAlignment),
            'title_font_size': ConjureFieldDefinition('titleFontSize', int),
            'title_font_color': ConjureFieldDefinition('titleFontColor', themes_api_HexColor),
            'caption_enabled': ConjureFieldDefinition('captionEnabled', bool),
            'caption_alignment': ConjureFieldDefinition('captionAlignment', themes_api_TextAlignment),
            'caption_font_size': ConjureFieldDefinition('captionFontSize', int),
            'caption_font_color': ConjureFieldDefinition('captionFontColor', themes_api_HexColor),
            'background_enabled': ConjureFieldDefinition('backgroundEnabled', bool),
            'legend_enabled': ConjureFieldDefinition('legendEnabled', bool),
            'legend_position': ConjureFieldDefinition('legendPosition', themes_api_LegendPosition),
            'legend_font_size': ConjureFieldDefinition('legendFontSize', int),
            'legend_font_color': ConjureFieldDefinition('legendFontColor', themes_api_HexColor),
            'legend_placement': ConjureFieldDefinition('legendPlacement', themes_api_LegendPlacement),
            'row_gap_enabled': ConjureFieldDefinition('rowGapEnabled', bool),
            'row_gap_size': ConjureFieldDefinition('rowGapSize', OptionalTypeWrapper[int]),
            'aspect_ratio_width': ConjureFieldDefinition('aspectRatioWidth', int),
            'aspect_ratio_height': ConjureFieldDefinition('aspectRatioHeight', int),
            'chart_type_themes': ConjureFieldDefinition('chartTypeThemes', themes_api_ChartTypeThemes)
        }

    __slots__: List[str] = ['_title_enabled', '_title_alignment', '_title_font_size', '_title_font_color', '_caption_enabled', '_caption_alignment', '_caption_font_size', '_caption_font_color', '_background_enabled', '_legend_enabled', '_legend_position', '_legend_font_size', '_legend_font_color', '_legend_placement', '_row_gap_enabled', '_row_gap_size', '_aspect_ratio_width', '_aspect_ratio_height', '_chart_type_themes']

    def __init__(self, aspect_ratio_height: int, aspect_ratio_width: int, background_enabled: bool, caption_alignment: "themes_api_TextAlignment", caption_enabled: bool, caption_font_color: str, caption_font_size: int, chart_type_themes: "themes_api_ChartTypeThemes", legend_enabled: bool, legend_font_color: str, legend_font_size: int, legend_placement: "themes_api_LegendPlacement", legend_position: "themes_api_LegendPosition", row_gap_enabled: bool, title_alignment: "themes_api_TextAlignment", title_enabled: bool, title_font_color: str, title_font_size: int, row_gap_size: Optional[int] = None) -> None:
        self._title_enabled = title_enabled
        self._title_alignment = title_alignment
        self._title_font_size = title_font_size
        self._title_font_color = title_font_color
        self._caption_enabled = caption_enabled
        self._caption_alignment = caption_alignment
        self._caption_font_size = caption_font_size
        self._caption_font_color = caption_font_color
        self._background_enabled = background_enabled
        self._legend_enabled = legend_enabled
        self._legend_position = legend_position
        self._legend_font_size = legend_font_size
        self._legend_font_color = legend_font_color
        self._legend_placement = legend_placement
        self._row_gap_enabled = row_gap_enabled
        self._row_gap_size = row_gap_size
        self._aspect_ratio_width = aspect_ratio_width
        self._aspect_ratio_height = aspect_ratio_height
        self._chart_type_themes = chart_type_themes

    @builtins.property
    def title_enabled(self) -> bool:
        """Whether to show a title in the export.
        """
        return self._title_enabled

    @builtins.property
    def title_alignment(self) -> "themes_api_TextAlignment":
        """How to align the text of the title.
        """
        return self._title_alignment

    @builtins.property
    def title_font_size(self) -> int:
        """Font size of the title.
        """
        return self._title_font_size

    @builtins.property
    def title_font_color(self) -> str:
        """Font color of the title.
        """
        return self._title_font_color

    @builtins.property
    def caption_enabled(self) -> bool:
        """Whether to show a caption in the export.
        """
        return self._caption_enabled

    @builtins.property
    def caption_alignment(self) -> "themes_api_TextAlignment":
        """How to align the text of the caption.
        """
        return self._caption_alignment

    @builtins.property
    def caption_font_size(self) -> int:
        """Font size of the caption.
        """
        return self._caption_font_size

    @builtins.property
    def caption_font_color(self) -> str:
        """Font color of the caption.
        """
        return self._caption_font_color

    @builtins.property
    def background_enabled(self) -> bool:
        """Whether to include a default background with the export.
(`false` indicates that the background should be transparent)
        """
        return self._background_enabled

    @builtins.property
    def legend_enabled(self) -> bool:
        """Whether to include a legend in the export.
        """
        return self._legend_enabled

    @builtins.property
    def legend_position(self) -> "themes_api_LegendPosition":
        """Which side the legend should appear on.
        """
        return self._legend_position

    @builtins.property
    def legend_font_size(self) -> int:
        """Font size of the legend.
        """
        return self._legend_font_size

    @builtins.property
    def legend_font_color(self) -> str:
        """Font color of the legend.
        """
        return self._legend_font_color

    @builtins.property
    def legend_placement(self) -> "themes_api_LegendPlacement":
        """Where on the chart the legend should be placed.
        """
        return self._legend_placement

    @builtins.property
    def row_gap_enabled(self) -> bool:
        """Whether rows will be separated.
        """
        return self._row_gap_enabled

    @builtins.property
    def row_gap_size(self) -> Optional[int]:
        """The size of the row gap.
        """
        return self._row_gap_size

    @builtins.property
    def aspect_ratio_width(self) -> int:
        """The relative width of the chart export.
        """
        return self._aspect_ratio_width

    @builtins.property
    def aspect_ratio_height(self) -> int:
        """The relative height of the chart export.
        """
        return self._aspect_ratio_height

    @builtins.property
    def chart_type_themes(self) -> "themes_api_ChartTypeThemes":
        """Theme parameters specific to chart types.
        """
        return self._chart_type_themes


themes_api_ChartThemeContentV1.__name__ = "ChartThemeContentV1"
themes_api_ChartThemeContentV1.__qualname__ = "ChartThemeContentV1"
themes_api_ChartThemeContentV1.__module__ = "nominal_api.themes_api"


class themes_api_ChartTypeThemes(ConjureBeanType):
    """Theme parameters specific to chart types.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'time_series': ConjureFieldDefinition('timeSeries', themes_api_TimeSeriesChartTheme)
        }

    __slots__: List[str] = ['_time_series']

    def __init__(self, time_series: "themes_api_TimeSeriesChartTheme") -> None:
        self._time_series = time_series

    @builtins.property
    def time_series(self) -> "themes_api_TimeSeriesChartTheme":
        """The theme specific to parameters of the time series chart.
        """
        return self._time_series


themes_api_ChartTypeThemes.__name__ = "ChartTypeThemes"
themes_api_ChartTypeThemes.__qualname__ = "ChartTypeThemes"
themes_api_ChartTypeThemes.__module__ = "nominal_api.themes_api"


class themes_api_CreateChartThemeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'content': ConjureFieldDefinition('content', themes_api_ChartThemeContent),
            'workspace': ConjureFieldDefinition('workspace', OptionalTypeWrapper[api_rids_WorkspaceRid])
        }

    __slots__: List[str] = ['_name', '_content', '_workspace']

    def __init__(self, content: "themes_api_ChartThemeContent", name: str, workspace: Optional[str] = None) -> None:
        self._name = name
        self._content = content
        self._workspace = workspace

    @builtins.property
    def name(self) -> str:
        """The name of the theme.
        """
        return self._name

    @builtins.property
    def content(self) -> "themes_api_ChartThemeContent":
        """The theme fields.
        """
        return self._content

    @builtins.property
    def workspace(self) -> Optional[str]:
        """The workspace in which to create the theme. If not provided, the theme will be created in the default workspace for
the user's organization, if the default workspace for the organization is configured.
        """
        return self._workspace


themes_api_CreateChartThemeRequest.__name__ = "CreateChartThemeRequest"
themes_api_CreateChartThemeRequest.__qualname__ = "CreateChartThemeRequest"
themes_api_CreateChartThemeRequest.__module__ = "nominal_api.themes_api"


class themes_api_LegendPlacement(ConjureEnumType):

    OUTSIDE = 'OUTSIDE'
    '''OUTSIDE'''
    INSIDE = 'INSIDE'
    '''INSIDE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


themes_api_LegendPlacement.__name__ = "LegendPlacement"
themes_api_LegendPlacement.__qualname__ = "LegendPlacement"
themes_api_LegendPlacement.__module__ = "nominal_api.themes_api"


class themes_api_LegendPosition(ConjureEnumType):

    TOP = 'TOP'
    '''TOP'''
    BOTTOM = 'BOTTOM'
    '''BOTTOM'''
    LEFT = 'LEFT'
    '''LEFT'''
    RIGHT = 'RIGHT'
    '''RIGHT'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


themes_api_LegendPosition.__name__ = "LegendPosition"
themes_api_LegendPosition.__qualname__ = "LegendPosition"
themes_api_LegendPosition.__module__ = "nominal_api.themes_api"


class themes_api_TextAlignment(ConjureEnumType):

    START = 'START'
    '''START'''
    END = 'END'
    '''END'''
    CENTER = 'CENTER'
    '''CENTER'''
    JUSTIFY = 'JUSTIFY'
    '''JUSTIFY'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


themes_api_TextAlignment.__name__ = "TextAlignment"
themes_api_TextAlignment.__qualname__ = "TextAlignment"
themes_api_TextAlignment.__module__ = "nominal_api.themes_api"


class themes_api_TextDirection(ConjureEnumType):

    HORIZONTAL = 'HORIZONTAL'
    '''HORIZONTAL'''
    VERTICAL = 'VERTICAL'
    '''VERTICAL'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


themes_api_TextDirection.__name__ = "TextDirection"
themes_api_TextDirection.__qualname__ = "TextDirection"
themes_api_TextDirection.__module__ = "nominal_api.themes_api"


class themes_api_ThemesService(Service):
    """Themes service manages themes for exporting charts.
    """

    def list_chart_themes(self, auth_header: str, workspaces: List[str] = None) -> List["themes_api_ChartTheme"]:
        """Get all chart themes saved to the requested workspaces.
        """
        workspaces = workspaces if workspaces is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'workspaces': _conjure_encoder.default(workspaces),
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/themes/v1/chart-themes'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[themes_api_ChartTheme], self._return_none_for_unknown_union_types)

    def get_chart_theme(self, auth_header: str, chart_theme_rid: str) -> "themes_api_ChartTheme":
        """Get a specific chart theme by RID.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'chartThemeRid': quote(str(_conjure_encoder.default(chart_theme_rid)), safe=''),
        }

        _json: Any = None

        _path = '/themes/v1/chart-themes/{chartThemeRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), themes_api_ChartTheme, self._return_none_for_unknown_union_types)

    def create_chart_theme(self, auth_header: str, request: "themes_api_CreateChartThemeRequest") -> "themes_api_ChartTheme":
        """Create a new chart theme.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/themes/v1/chart-themes'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), themes_api_ChartTheme, self._return_none_for_unknown_union_types)

    def update_chart_theme(self, auth_header: str, chart_theme_rid: str, request: "themes_api_UpdateChartThemeRequest") -> "themes_api_ChartTheme":
        """Update an existing chart theme.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'chartThemeRid': quote(str(_conjure_encoder.default(chart_theme_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/themes/v1/chart-themes/{chartThemeRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), themes_api_ChartTheme, self._return_none_for_unknown_union_types)

    def delete_chart_theme(self, auth_header: str, chart_theme_rid: str) -> None:
        """Delete an existing comment.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'chartThemeRid': quote(str(_conjure_encoder.default(chart_theme_rid)), safe=''),
        }

        _json: Any = None

        _path = '/themes/v1/chart-themes/{chartThemeRid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'DELETE',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


themes_api_ThemesService.__name__ = "ThemesService"
themes_api_ThemesService.__qualname__ = "ThemesService"
themes_api_ThemesService.__module__ = "nominal_api.themes_api"


class themes_api_TimeSeriesChartTheme(ConjureUnionType):
    _v1: Optional["themes_api_TimeSeriesChartThemeV1"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'v1': ConjureFieldDefinition('v1', themes_api_TimeSeriesChartThemeV1)
        }

    def __init__(
            self,
            v1: Optional["themes_api_TimeSeriesChartThemeV1"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (v1 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if v1 is not None:
                self._v1 = v1
                self._type = 'v1'

        elif type_of_union == 'v1':
            if v1 is None:
                raise ValueError('a union value must not be None')
            self._v1 = v1
            self._type = 'v1'

    @builtins.property
    def v1(self) -> Optional["themes_api_TimeSeriesChartThemeV1"]:
        return self._v1

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, themes_api_TimeSeriesChartThemeVisitor):
            raise ValueError('{} is not an instance of themes_api_TimeSeriesChartThemeVisitor'.format(visitor.__class__.__name__))
        if self._type == 'v1' and self.v1 is not None:
            return visitor._v1(self.v1)


themes_api_TimeSeriesChartTheme.__name__ = "TimeSeriesChartTheme"
themes_api_TimeSeriesChartTheme.__qualname__ = "TimeSeriesChartTheme"
themes_api_TimeSeriesChartTheme.__module__ = "nominal_api.themes_api"


class themes_api_TimeSeriesChartThemeVisitor:

    @abstractmethod
    def _v1(self, v1: "themes_api_TimeSeriesChartThemeV1") -> Any:
        pass


themes_api_TimeSeriesChartThemeVisitor.__name__ = "TimeSeriesChartThemeVisitor"
themes_api_TimeSeriesChartThemeVisitor.__qualname__ = "TimeSeriesChartThemeVisitor"
themes_api_TimeSeriesChartThemeVisitor.__module__ = "nominal_api.themes_api"


class themes_api_TimeSeriesChartThemeV1(ConjureBeanType):
    """Theme parameters specific to the time series chart.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'x_axis_tick_font_size': ConjureFieldDefinition('xAxisTickFontSize', int),
            'x_axis_tick_font_color': ConjureFieldDefinition('xAxisTickFontColor', themes_api_HexColor),
            'y_axis_title_font_size': ConjureFieldDefinition('yAxisTitleFontSize', int),
            'y_axis_tick_font_size': ConjureFieldDefinition('yAxisTickFontSize', int),
            'threshold_line_width': ConjureFieldDefinition('thresholdLineWidth', OptionalTypeWrapper[int])
        }

    __slots__: List[str] = ['_x_axis_tick_font_size', '_x_axis_tick_font_color', '_y_axis_title_font_size', '_y_axis_tick_font_size', '_threshold_line_width']

    def __init__(self, x_axis_tick_font_color: str, x_axis_tick_font_size: int, y_axis_tick_font_size: int, y_axis_title_font_size: int, threshold_line_width: Optional[int] = None) -> None:
        self._x_axis_tick_font_size = x_axis_tick_font_size
        self._x_axis_tick_font_color = x_axis_tick_font_color
        self._y_axis_title_font_size = y_axis_title_font_size
        self._y_axis_tick_font_size = y_axis_tick_font_size
        self._threshold_line_width = threshold_line_width

    @builtins.property
    def x_axis_tick_font_size(self) -> int:
        """The font size of the x-axis ticks.
        """
        return self._x_axis_tick_font_size

    @builtins.property
    def x_axis_tick_font_color(self) -> str:
        """The font color of the x-axis ticks.
        """
        return self._x_axis_tick_font_color

    @builtins.property
    def y_axis_title_font_size(self) -> int:
        """The font size of the y-axis labels.
        """
        return self._y_axis_title_font_size

    @builtins.property
    def y_axis_tick_font_size(self) -> int:
        """The font size of the y-axis ticks.
        """
        return self._y_axis_tick_font_size

    @builtins.property
    def threshold_line_width(self) -> Optional[int]:
        """The line thickness in px of the threshold line.
        """
        return self._threshold_line_width


themes_api_TimeSeriesChartThemeV1.__name__ = "TimeSeriesChartThemeV1"
themes_api_TimeSeriesChartThemeV1.__qualname__ = "TimeSeriesChartThemeV1"
themes_api_TimeSeriesChartThemeV1.__module__ = "nominal_api.themes_api"


class themes_api_UpdateChartThemeRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', str),
            'content': ConjureFieldDefinition('content', themes_api_ChartThemeContent)
        }

    __slots__: List[str] = ['_name', '_content']

    def __init__(self, content: "themes_api_ChartThemeContent", name: str) -> None:
        self._name = name
        self._content = content

    @builtins.property
    def name(self) -> str:
        """The name of the theme.
        """
        return self._name

    @builtins.property
    def content(self) -> "themes_api_ChartThemeContent":
        """The theme fields.
        """
        return self._content


themes_api_UpdateChartThemeRequest.__name__ = "UpdateChartThemeRequest"
themes_api_UpdateChartThemeRequest.__qualname__ = "UpdateChartThemeRequest"
themes_api_UpdateChartThemeRequest.__module__ = "nominal_api.themes_api"


class timeseries_channelmetadata_ChannelMetadataService(Service):
    """Endpoints for retrieving and updating channel metadata.
    """

    def get_channel_metadata(self, auth_header: str, request: "timeseries_channelmetadata_api_GetChannelMetadataRequest") -> "timeseries_channelmetadata_api_ChannelMetadata":
        """Get the metadata for a channel.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/channel-metadata/v1/channel-metadata/get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_channelmetadata_api_ChannelMetadata, self._return_none_for_unknown_union_types)

    def batch_get_channel_metadata(self, auth_header: str, request: "timeseries_channelmetadata_api_BatchGetChannelMetadataRequest") -> "timeseries_channelmetadata_api_BatchGetChannelMetadataResponse":
        """Batch get the metadata for multiple channels. If some channels cannot be found or authorized, 
they will be omitted from the response.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/channel-metadata/v1/channel-metadata/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_channelmetadata_api_BatchGetChannelMetadataResponse, self._return_none_for_unknown_union_types)

    def update_channel_metadata(self, auth_header: str, request: "timeseries_channelmetadata_api_UpdateChannelMetadataRequest") -> "timeseries_channelmetadata_api_ChannelMetadata":
        """Update the metadata for a channel.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/channel-metadata/v1/channel-metadata/update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_channelmetadata_api_ChannelMetadata, self._return_none_for_unknown_union_types)

    def batch_update_channel_metadata(self, auth_header: str, request: "timeseries_channelmetadata_api_BatchUpdateChannelMetadataRequest") -> "timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse":
        """Batch update the metadata for multiple channels. If some channels cannot be found or authorized,
no metadata will be updated for any of the channels in the request.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/channel-metadata/v1/channel-metadata/batch-update'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse, self._return_none_for_unknown_union_types)


timeseries_channelmetadata_ChannelMetadataService.__name__ = "ChannelMetadataService"
timeseries_channelmetadata_ChannelMetadataService.__qualname__ = "ChannelMetadataService"
timeseries_channelmetadata_ChannelMetadataService.__module__ = "nominal_api.timeseries_channelmetadata"


class timeseries_channelmetadata_api_BatchGetChannelMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_channelmetadata_api_GetChannelMetadataRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_channelmetadata_api_GetChannelMetadataRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_channelmetadata_api_GetChannelMetadataRequest"]:
        return self._requests


timeseries_channelmetadata_api_BatchGetChannelMetadataRequest.__name__ = "BatchGetChannelMetadataRequest"
timeseries_channelmetadata_api_BatchGetChannelMetadataRequest.__qualname__ = "BatchGetChannelMetadataRequest"
timeseries_channelmetadata_api_BatchGetChannelMetadataRequest.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_BatchGetChannelMetadataResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_channelmetadata_api_ChannelMetadata])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_channelmetadata_api_ChannelMetadata"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_channelmetadata_api_ChannelMetadata"]:
        return self._responses


timeseries_channelmetadata_api_BatchGetChannelMetadataResponse.__name__ = "BatchGetChannelMetadataResponse"
timeseries_channelmetadata_api_BatchGetChannelMetadataResponse.__qualname__ = "BatchGetChannelMetadataResponse"
timeseries_channelmetadata_api_BatchGetChannelMetadataResponse.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_BatchUpdateChannelMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_channelmetadata_api_UpdateChannelMetadataRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_channelmetadata_api_UpdateChannelMetadataRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_channelmetadata_api_UpdateChannelMetadataRequest"]:
        return self._requests


timeseries_channelmetadata_api_BatchUpdateChannelMetadataRequest.__name__ = "BatchUpdateChannelMetadataRequest"
timeseries_channelmetadata_api_BatchUpdateChannelMetadataRequest.__qualname__ = "BatchUpdateChannelMetadataRequest"
timeseries_channelmetadata_api_BatchUpdateChannelMetadataRequest.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_channelmetadata_api_ChannelMetadata])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_channelmetadata_api_ChannelMetadata"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_channelmetadata_api_ChannelMetadata"]:
        return self._responses


timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse.__name__ = "BatchUpdateChannelMetadataResponse"
timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse.__qualname__ = "BatchUpdateChannelMetadataResponse"
timeseries_channelmetadata_api_BatchUpdateChannelMetadataResponse.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_ChannelIdentifier(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_name': ConjureFieldDefinition('channelName', api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid)
        }

    __slots__: List[str] = ['_channel_name', '_data_source_rid']

    def __init__(self, channel_name: str, data_source_rid: str) -> None:
        self._channel_name = channel_name
        self._data_source_rid = data_source_rid

    @builtins.property
    def channel_name(self) -> str:
        return self._channel_name

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid


timeseries_channelmetadata_api_ChannelIdentifier.__name__ = "ChannelIdentifier"
timeseries_channelmetadata_api_ChannelIdentifier.__qualname__ = "ChannelIdentifier"
timeseries_channelmetadata_api_ChannelIdentifier.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_ChannelMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_identifier': ConjureFieldDefinition('channelIdentifier', timeseries_channelmetadata_api_ChannelIdentifier),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'data_type': ConjureFieldDefinition('dataType', OptionalTypeWrapper[api_SeriesDataType])
        }

    __slots__: List[str] = ['_channel_identifier', '_description', '_unit', '_data_type']

    def __init__(self, channel_identifier: "timeseries_channelmetadata_api_ChannelIdentifier", data_type: Optional["api_SeriesDataType"] = None, description: Optional[str] = None, unit: Optional[str] = None) -> None:
        self._channel_identifier = channel_identifier
        self._description = description
        self._unit = unit
        self._data_type = data_type

    @builtins.property
    def channel_identifier(self) -> "timeseries_channelmetadata_api_ChannelIdentifier":
        return self._channel_identifier

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def data_type(self) -> Optional["api_SeriesDataType"]:
        return self._data_type


timeseries_channelmetadata_api_ChannelMetadata.__name__ = "ChannelMetadata"
timeseries_channelmetadata_api_ChannelMetadata.__qualname__ = "ChannelMetadata"
timeseries_channelmetadata_api_ChannelMetadata.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_GetChannelMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_identifier': ConjureFieldDefinition('channelIdentifier', timeseries_channelmetadata_api_ChannelIdentifier)
        }

    __slots__: List[str] = ['_channel_identifier']

    def __init__(self, channel_identifier: "timeseries_channelmetadata_api_ChannelIdentifier") -> None:
        self._channel_identifier = channel_identifier

    @builtins.property
    def channel_identifier(self) -> "timeseries_channelmetadata_api_ChannelIdentifier":
        return self._channel_identifier


timeseries_channelmetadata_api_GetChannelMetadataRequest.__name__ = "GetChannelMetadataRequest"
timeseries_channelmetadata_api_GetChannelMetadataRequest.__qualname__ = "GetChannelMetadataRequest"
timeseries_channelmetadata_api_GetChannelMetadataRequest.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_channelmetadata_api_UpdateChannelMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel_identifier': ConjureFieldDefinition('channelIdentifier', timeseries_channelmetadata_api_ChannelIdentifier),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit_update': ConjureFieldDefinition('unitUpdate', OptionalTypeWrapper[timeseries_logicalseries_api_UnitUpdate])
        }

    __slots__: List[str] = ['_channel_identifier', '_description', '_unit_update']

    def __init__(self, channel_identifier: "timeseries_channelmetadata_api_ChannelIdentifier", description: Optional[str] = None, unit_update: Optional["timeseries_logicalseries_api_UnitUpdate"] = None) -> None:
        self._channel_identifier = channel_identifier
        self._description = description
        self._unit_update = unit_update

    @builtins.property
    def channel_identifier(self) -> "timeseries_channelmetadata_api_ChannelIdentifier":
        return self._channel_identifier

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit_update(self) -> Optional["timeseries_logicalseries_api_UnitUpdate"]:
        return self._unit_update


timeseries_channelmetadata_api_UpdateChannelMetadataRequest.__name__ = "UpdateChannelMetadataRequest"
timeseries_channelmetadata_api_UpdateChannelMetadataRequest.__qualname__ = "UpdateChannelMetadataRequest"
timeseries_channelmetadata_api_UpdateChannelMetadataRequest.__module__ = "nominal_api.timeseries_channelmetadata_api"


class timeseries_logicalseries_api_ApiLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_ApiType)
        }

    __slots__: List[str] = ['_channel', '_tags', '_type']

    def __init__(self, channel: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_ApiType") -> None:
        self._channel = channel
        self._tags = tags
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_ApiType":
        return self._type


timeseries_logicalseries_api_ApiLocator.__name__ = "ApiLocator"
timeseries_logicalseries_api_ApiLocator.__qualname__ = "ApiLocator"
timeseries_logicalseries_api_ApiLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ApiType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    INT64 = 'INT64'
    '''INT64'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_ApiType.__name__ = "ApiType"
timeseries_logicalseries_api_ApiType.__qualname__ = "ApiType"
timeseries_logicalseries_api_ApiType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchCreateExternalStorageLocatorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_CreateExternalStorageLocator])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_CreateExternalStorageLocator"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_CreateExternalStorageLocator"]:
        return self._requests


timeseries_logicalseries_api_BatchCreateExternalStorageLocatorRequest.__name__ = "BatchCreateExternalStorageLocatorRequest"
timeseries_logicalseries_api_BatchCreateExternalStorageLocatorRequest.__qualname__ = "BatchCreateExternalStorageLocatorRequest"
timeseries_logicalseries_api_BatchCreateExternalStorageLocatorRequest.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchCreateExternalStorageLocatorResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_logicalseries_api_ExternalStorageLocator])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_logicalseries_api_ExternalStorageLocator"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_logicalseries_api_ExternalStorageLocator"]:
        return self._responses


timeseries_logicalseries_api_BatchCreateExternalStorageLocatorResponse.__name__ = "BatchCreateExternalStorageLocatorResponse"
timeseries_logicalseries_api_BatchCreateExternalStorageLocatorResponse.__qualname__ = "BatchCreateExternalStorageLocatorResponse"
timeseries_logicalseries_api_BatchCreateExternalStorageLocatorResponse.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchResolveSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_ResolveSeriesRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_ResolveSeriesRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_ResolveSeriesRequest"]:
        return self._requests


timeseries_logicalseries_api_BatchResolveSeriesRequest.__name__ = "BatchResolveSeriesRequest"
timeseries_logicalseries_api_BatchResolveSeriesRequest.__qualname__ = "BatchResolveSeriesRequest"
timeseries_logicalseries_api_BatchResolveSeriesRequest.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchResolveSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series': ConjureFieldDefinition('series', List[timeseries_logicalseries_api_ResolveSeriesResponse])
        }

    __slots__: List[str] = ['_series']

    def __init__(self, series: List["timeseries_logicalseries_api_ResolveSeriesResponse"]) -> None:
        self._series = series

    @builtins.property
    def series(self) -> List["timeseries_logicalseries_api_ResolveSeriesResponse"]:
        return self._series


timeseries_logicalseries_api_BatchResolveSeriesResponse.__name__ = "BatchResolveSeriesResponse"
timeseries_logicalseries_api_BatchResolveSeriesResponse.__qualname__ = "BatchResolveSeriesResponse"
timeseries_logicalseries_api_BatchResolveSeriesResponse.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_logicalseries_api_UpdateExternalStorageLocator])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_logicalseries_api_UpdateExternalStorageLocator"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_logicalseries_api_UpdateExternalStorageLocator"]:
        return self._requests


timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorRequest.__name__ = "BatchUpdateExternalStorageLocatorRequest"
timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorRequest.__qualname__ = "BatchUpdateExternalStorageLocatorRequest"
timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorRequest.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_logicalseries_api_ExternalStorageLocator])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_logicalseries_api_ExternalStorageLocator"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_logicalseries_api_ExternalStorageLocator"]:
        return self._responses


timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorResponse.__name__ = "BatchUpdateExternalStorageLocatorResponse"
timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorResponse.__qualname__ = "BatchUpdateExternalStorageLocatorResponse"
timeseries_logicalseries_api_BatchUpdateExternalStorageLocatorResponse.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BigQueryLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value_column': ConjureFieldDefinition('valueColumn', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'tag_values': ConjureFieldDefinition('tagValues', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_BigQueryType)
        }

    __slots__: List[str] = ['_value_column', '_time_column', '_tag_values', '_type']

    def __init__(self, tag_values: Dict[str, str], time_column: str, type: "timeseries_logicalseries_api_BigQueryType", value_column: str) -> None:
        self._value_column = value_column
        self._time_column = time_column
        self._tag_values = tag_values
        self._type = type

    @builtins.property
    def value_column(self) -> str:
        """The name of the column which has the values for this series
        """
        return self._value_column

    @builtins.property
    def time_column(self) -> str:
        """The name of the column which has the timestamps for this series
        """
        return self._time_column

    @builtins.property
    def tag_values(self) -> Dict[str, str]:
        """The mapping of columns to column values to filter on
        """
        return self._tag_values

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_BigQueryType":
        return self._type


timeseries_logicalseries_api_BigQueryLocator.__name__ = "BigQueryLocator"
timeseries_logicalseries_api_BigQueryLocator.__qualname__ = "BigQueryLocator"
timeseries_logicalseries_api_BigQueryLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_BigQueryType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_BigQueryType.__name__ = "BigQueryType"
timeseries_logicalseries_api_BigQueryType.__qualname__ = "BigQueryType"
timeseries_logicalseries_api_BigQueryType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Context(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'properties': ConjureFieldDefinition('properties', Dict[str, timeseries_logicalseries_api_ContextProperty])
        }

    __slots__: List[str] = ['_properties']

    def __init__(self, properties: Dict[str, "timeseries_logicalseries_api_ContextProperty"]) -> None:
        self._properties = properties

    @builtins.property
    def properties(self) -> Dict[str, "timeseries_logicalseries_api_ContextProperty"]:
        return self._properties


timeseries_logicalseries_api_Context.__name__ = "Context"
timeseries_logicalseries_api_Context.__qualname__ = "Context"
timeseries_logicalseries_api_Context.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ContextProperty(ConjureUnionType):
    _value: Optional[str] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value': ConjureFieldDefinition('value', str)
        }

    def __init__(
            self,
            value: Optional[str] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (value is not None) != 1:
                raise ValueError('a union must contain a single member')

            if value is not None:
                self._value = value
                self._type = 'value'

        elif type_of_union == 'value':
            if value is None:
                raise ValueError('a union value must not be None')
            self._value = value
            self._type = 'value'

    @builtins.property
    def value(self) -> Optional[str]:
        return self._value

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_ContextPropertyVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_ContextPropertyVisitor'.format(visitor.__class__.__name__))
        if self._type == 'value' and self.value is not None:
            return visitor._value(self.value)


timeseries_logicalseries_api_ContextProperty.__name__ = "ContextProperty"
timeseries_logicalseries_api_ContextProperty.__qualname__ = "ContextProperty"
timeseries_logicalseries_api_ContextProperty.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ContextPropertyVisitor:

    @abstractmethod
    def _value(self, value: str) -> Any:
        pass


timeseries_logicalseries_api_ContextPropertyVisitor.__name__ = "ContextPropertyVisitor"
timeseries_logicalseries_api_ContextPropertyVisitor.__qualname__ = "ContextPropertyVisitor"
timeseries_logicalseries_api_ContextPropertyVisitor.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_CreateExternalStorageLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'locator': ConjureFieldDefinition('locator', timeseries_logicalseries_api_Locator),
            'id_locator': ConjureFieldDefinition('idLocator', OptionalTypeWrapper[str]),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[api_SeriesDataType]),
            'granularity': ConjureFieldDefinition('granularity', OptionalTypeWrapper[api_Granularity]),
            'series_archetype_rid': ConjureFieldDefinition('seriesArchetypeRid', OptionalTypeWrapper[api_SeriesArchetypeRid])
        }

    __slots__: List[str] = ['_channel', '_locator', '_id_locator', '_data_source_rid', '_description', '_unit', '_series_data_type', '_granularity', '_series_archetype_rid']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_logicalseries_api_Locator", description: Optional[str] = None, granularity: Optional["api_Granularity"] = None, id_locator: Optional[str] = None, series_archetype_rid: Optional[str] = None, series_data_type: Optional["api_SeriesDataType"] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._locator = locator
        self._id_locator = id_locator
        self._data_source_rid = data_source_rid
        self._description = description
        self._unit = unit
        self._series_data_type = series_data_type
        self._granularity = granularity
        self._series_archetype_rid = series_archetype_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def locator(self) -> "timeseries_logicalseries_api_Locator":
        return self._locator

    @builtins.property
    def id_locator(self) -> Optional[str]:
        """If present, will be used as the locator of the LogicalSeriesRid. If a logical series already exists
with this id, will throw a CONFLICT.
        """
        return self._id_locator

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def series_data_type(self) -> Optional["api_SeriesDataType"]:
        return self._series_data_type

    @builtins.property
    def granularity(self) -> Optional["api_Granularity"]:
        return self._granularity

    @builtins.property
    def series_archetype_rid(self) -> Optional[str]:
        """Deprecated. Do not use.
        """
        return self._series_archetype_rid


timeseries_logicalseries_api_CreateExternalStorageLocator.__name__ = "CreateExternalStorageLocator"
timeseries_logicalseries_api_CreateExternalStorageLocator.__qualname__ = "CreateExternalStorageLocator"
timeseries_logicalseries_api_CreateExternalStorageLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ExternalStorageLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_LogicalSeriesRid),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_logicalseries_api_Locator),
            'time_locator': ConjureFieldDefinition('timeLocator', OptionalTypeWrapper[timeseries_logicalseries_api_Locator]),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[api_SeriesDataType]),
            'granularity': ConjureFieldDefinition('granularity', OptionalTypeWrapper[api_Granularity])
        }

    __slots__: List[str] = ['_rid', '_data_source_rid', '_locator', '_time_locator', '_channel', '_description', '_unit', '_series_data_type', '_granularity']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_logicalseries_api_Locator", rid: str, description: Optional[str] = None, granularity: Optional["api_Granularity"] = None, series_data_type: Optional["api_SeriesDataType"] = None, time_locator: Optional["timeseries_logicalseries_api_Locator"] = None, unit: Optional[str] = None) -> None:
        self._rid = rid
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._time_locator = time_locator
        self._channel = channel
        self._description = description
        self._unit = unit
        self._series_data_type = series_data_type
        self._granularity = granularity

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_logicalseries_api_Locator":
        return self._locator

    @builtins.property
    def time_locator(self) -> Optional["timeseries_logicalseries_api_Locator"]:
        """Only required to be present for legacy CSVs.
        """
        return self._time_locator

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def series_data_type(self) -> Optional["api_SeriesDataType"]:
        return self._series_data_type

    @builtins.property
    def granularity(self) -> Optional["api_Granularity"]:
        """Time granularity of the series. If omitted, defaults to nanoseconds.
        """
        return self._granularity


timeseries_logicalseries_api_ExternalStorageLocator.__name__ = "ExternalStorageLocator"
timeseries_logicalseries_api_ExternalStorageLocator.__qualname__ = "ExternalStorageLocator"
timeseries_logicalseries_api_ExternalStorageLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Influx1Locator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', timeseries_logicalseries_api_DatabaseName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_database', '_measurement', '_field', '_tags', '_type']

    def __init__(self, database: str, field: str, measurement: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_InfluxType") -> None:
        self._database = database
        self._measurement = measurement
        self._field = field
        self._tags = tags
        self._type = type

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_logicalseries_api_Influx1Locator.__name__ = "Influx1Locator"
timeseries_logicalseries_api_Influx1Locator.__qualname__ = "Influx1Locator"
timeseries_logicalseries_api_Influx1Locator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Influx2Locator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', timeseries_logicalseries_api_BucketName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'value_column': ConjureFieldDefinition('valueColumn', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_bucket', '_measurement', '_field', '_value_column', '_tags', '_type']

    def __init__(self, bucket: str, field: str, measurement: str, tags: Dict[str, str], type: "timeseries_logicalseries_api_InfluxType", value_column: Optional[str] = None) -> None:
        self._bucket = bucket
        self._measurement = measurement
        self._field = field
        self._value_column = value_column
        self._tags = tags
        self._type = type

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def value_column(self) -> Optional[str]:
        """If omitted, defaults to `_value`. Can be used to extract tag values.
        """
        return self._value_column

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_logicalseries_api_Influx2Locator.__name__ = "Influx2Locator"
timeseries_logicalseries_api_Influx2Locator.__qualname__ = "Influx2Locator"
timeseries_logicalseries_api_Influx2Locator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_InfluxType(ConjureEnumType):

    BOOLEAN = 'BOOLEAN'
    '''BOOLEAN'''
    NUMERIC = 'NUMERIC'
    '''NUMERIC'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_InfluxType.__name__ = "InfluxType"
timeseries_logicalseries_api_InfluxType.__qualname__ = "InfluxType"
timeseries_logicalseries_api_InfluxType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_Locator(ConjureUnionType):
    _timescale_db_locator: Optional["timeseries_logicalseries_api_TimescaleDbLocator"] = None
    _influx_locator: Optional["timeseries_logicalseries_api_Influx2Locator"] = None
    _influx1_locator: Optional["timeseries_logicalseries_api_Influx1Locator"] = None
    _nominal_locator: Optional["timeseries_logicalseries_api_NominalLocator"] = None
    _timestream_locator: Optional["timeseries_logicalseries_api_TimestreamLocator"] = None
    _visual_crossing_locator: Optional["timeseries_logicalseries_api_VisualCrossingLocator"] = None
    _big_query_locator: Optional["timeseries_logicalseries_api_BigQueryLocator"] = None
    _api_locator: Optional["timeseries_logicalseries_api_ApiLocator"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timescale_db_locator': ConjureFieldDefinition('timescaleDbLocator', timeseries_logicalseries_api_TimescaleDbLocator),
            'influx_locator': ConjureFieldDefinition('influxLocator', timeseries_logicalseries_api_Influx2Locator),
            'influx1_locator': ConjureFieldDefinition('influx1Locator', timeseries_logicalseries_api_Influx1Locator),
            'nominal_locator': ConjureFieldDefinition('nominalLocator', timeseries_logicalseries_api_NominalLocator),
            'timestream_locator': ConjureFieldDefinition('timestreamLocator', timeseries_logicalseries_api_TimestreamLocator),
            'visual_crossing_locator': ConjureFieldDefinition('visualCrossingLocator', timeseries_logicalseries_api_VisualCrossingLocator),
            'big_query_locator': ConjureFieldDefinition('bigQueryLocator', timeseries_logicalseries_api_BigQueryLocator),
            'api_locator': ConjureFieldDefinition('apiLocator', timeseries_logicalseries_api_ApiLocator)
        }

    def __init__(
            self,
            timescale_db_locator: Optional["timeseries_logicalseries_api_TimescaleDbLocator"] = None,
            influx_locator: Optional["timeseries_logicalseries_api_Influx2Locator"] = None,
            influx1_locator: Optional["timeseries_logicalseries_api_Influx1Locator"] = None,
            nominal_locator: Optional["timeseries_logicalseries_api_NominalLocator"] = None,
            timestream_locator: Optional["timeseries_logicalseries_api_TimestreamLocator"] = None,
            visual_crossing_locator: Optional["timeseries_logicalseries_api_VisualCrossingLocator"] = None,
            big_query_locator: Optional["timeseries_logicalseries_api_BigQueryLocator"] = None,
            api_locator: Optional["timeseries_logicalseries_api_ApiLocator"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timescale_db_locator is not None) + (influx_locator is not None) + (influx1_locator is not None) + (nominal_locator is not None) + (timestream_locator is not None) + (visual_crossing_locator is not None) + (big_query_locator is not None) + (api_locator is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timescale_db_locator is not None:
                self._timescale_db_locator = timescale_db_locator
                self._type = 'timescaleDbLocator'
            if influx_locator is not None:
                self._influx_locator = influx_locator
                self._type = 'influxLocator'
            if influx1_locator is not None:
                self._influx1_locator = influx1_locator
                self._type = 'influx1Locator'
            if nominal_locator is not None:
                self._nominal_locator = nominal_locator
                self._type = 'nominalLocator'
            if timestream_locator is not None:
                self._timestream_locator = timestream_locator
                self._type = 'timestreamLocator'
            if visual_crossing_locator is not None:
                self._visual_crossing_locator = visual_crossing_locator
                self._type = 'visualCrossingLocator'
            if big_query_locator is not None:
                self._big_query_locator = big_query_locator
                self._type = 'bigQueryLocator'
            if api_locator is not None:
                self._api_locator = api_locator
                self._type = 'apiLocator'

        elif type_of_union == 'timescaleDbLocator':
            if timescale_db_locator is None:
                raise ValueError('a union value must not be None')
            self._timescale_db_locator = timescale_db_locator
            self._type = 'timescaleDbLocator'
        elif type_of_union == 'influxLocator':
            if influx_locator is None:
                raise ValueError('a union value must not be None')
            self._influx_locator = influx_locator
            self._type = 'influxLocator'
        elif type_of_union == 'influx1Locator':
            if influx1_locator is None:
                raise ValueError('a union value must not be None')
            self._influx1_locator = influx1_locator
            self._type = 'influx1Locator'
        elif type_of_union == 'nominalLocator':
            if nominal_locator is None:
                raise ValueError('a union value must not be None')
            self._nominal_locator = nominal_locator
            self._type = 'nominalLocator'
        elif type_of_union == 'timestreamLocator':
            if timestream_locator is None:
                raise ValueError('a union value must not be None')
            self._timestream_locator = timestream_locator
            self._type = 'timestreamLocator'
        elif type_of_union == 'visualCrossingLocator':
            if visual_crossing_locator is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing_locator = visual_crossing_locator
            self._type = 'visualCrossingLocator'
        elif type_of_union == 'bigQueryLocator':
            if big_query_locator is None:
                raise ValueError('a union value must not be None')
            self._big_query_locator = big_query_locator
            self._type = 'bigQueryLocator'
        elif type_of_union == 'apiLocator':
            if api_locator is None:
                raise ValueError('a union value must not be None')
            self._api_locator = api_locator
            self._type = 'apiLocator'

    @builtins.property
    def timescale_db_locator(self) -> Optional["timeseries_logicalseries_api_TimescaleDbLocator"]:
        return self._timescale_db_locator

    @builtins.property
    def influx_locator(self) -> Optional["timeseries_logicalseries_api_Influx2Locator"]:
        return self._influx_locator

    @builtins.property
    def influx1_locator(self) -> Optional["timeseries_logicalseries_api_Influx1Locator"]:
        return self._influx1_locator

    @builtins.property
    def nominal_locator(self) -> Optional["timeseries_logicalseries_api_NominalLocator"]:
        return self._nominal_locator

    @builtins.property
    def timestream_locator(self) -> Optional["timeseries_logicalseries_api_TimestreamLocator"]:
        return self._timestream_locator

    @builtins.property
    def visual_crossing_locator(self) -> Optional["timeseries_logicalseries_api_VisualCrossingLocator"]:
        return self._visual_crossing_locator

    @builtins.property
    def big_query_locator(self) -> Optional["timeseries_logicalseries_api_BigQueryLocator"]:
        return self._big_query_locator

    @builtins.property
    def api_locator(self) -> Optional["timeseries_logicalseries_api_ApiLocator"]:
        return self._api_locator

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_LocatorVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_LocatorVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timescaleDbLocator' and self.timescale_db_locator is not None:
            return visitor._timescale_db_locator(self.timescale_db_locator)
        if self._type == 'influxLocator' and self.influx_locator is not None:
            return visitor._influx_locator(self.influx_locator)
        if self._type == 'influx1Locator' and self.influx1_locator is not None:
            return visitor._influx1_locator(self.influx1_locator)
        if self._type == 'nominalLocator' and self.nominal_locator is not None:
            return visitor._nominal_locator(self.nominal_locator)
        if self._type == 'timestreamLocator' and self.timestream_locator is not None:
            return visitor._timestream_locator(self.timestream_locator)
        if self._type == 'visualCrossingLocator' and self.visual_crossing_locator is not None:
            return visitor._visual_crossing_locator(self.visual_crossing_locator)
        if self._type == 'bigQueryLocator' and self.big_query_locator is not None:
            return visitor._big_query_locator(self.big_query_locator)
        if self._type == 'apiLocator' and self.api_locator is not None:
            return visitor._api_locator(self.api_locator)


timeseries_logicalseries_api_Locator.__name__ = "Locator"
timeseries_logicalseries_api_Locator.__qualname__ = "Locator"
timeseries_logicalseries_api_Locator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_LocatorVisitor:

    @abstractmethod
    def _timescale_db_locator(self, timescale_db_locator: "timeseries_logicalseries_api_TimescaleDbLocator") -> Any:
        pass

    @abstractmethod
    def _influx_locator(self, influx_locator: "timeseries_logicalseries_api_Influx2Locator") -> Any:
        pass

    @abstractmethod
    def _influx1_locator(self, influx1_locator: "timeseries_logicalseries_api_Influx1Locator") -> Any:
        pass

    @abstractmethod
    def _nominal_locator(self, nominal_locator: "timeseries_logicalseries_api_NominalLocator") -> Any:
        pass

    @abstractmethod
    def _timestream_locator(self, timestream_locator: "timeseries_logicalseries_api_TimestreamLocator") -> Any:
        pass

    @abstractmethod
    def _visual_crossing_locator(self, visual_crossing_locator: "timeseries_logicalseries_api_VisualCrossingLocator") -> Any:
        pass

    @abstractmethod
    def _big_query_locator(self, big_query_locator: "timeseries_logicalseries_api_BigQueryLocator") -> Any:
        pass

    @abstractmethod
    def _api_locator(self, api_locator: "timeseries_logicalseries_api_ApiLocator") -> Any:
        pass


timeseries_logicalseries_api_LocatorVisitor.__name__ = "LocatorVisitor"
timeseries_logicalseries_api_LocatorVisitor.__qualname__ = "LocatorVisitor"
timeseries_logicalseries_api_LocatorVisitor.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_NominalLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', storage_series_api_NominalDataType)
        }

    __slots__: List[str] = ['_channel', '_tags', '_type']

    def __init__(self, channel: str, tags: Dict[str, str], type: "storage_series_api_NominalDataType") -> None:
        self._channel = channel
        self._tags = tags
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def type(self) -> "storage_series_api_NominalDataType":
        return self._type


timeseries_logicalseries_api_NominalLocator.__name__ = "NominalLocator"
timeseries_logicalseries_api_NominalLocator.__qualname__ = "NominalLocator"
timeseries_logicalseries_api_NominalLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesError(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'message': ConjureFieldDefinition('message', str),
            'args': ConjureFieldDefinition('args', Dict[str, str])
        }

    __slots__: List[str] = ['_message', '_args']

    def __init__(self, args: Dict[str, str], message: str) -> None:
        self._message = message
        self._args = args

    @builtins.property
    def message(self) -> str:
        return self._message

    @builtins.property
    def args(self) -> Dict[str, str]:
        return self._args


timeseries_logicalseries_api_ResolveSeriesError.__name__ = "ResolveSeriesError"
timeseries_logicalseries_api_ResolveSeriesError.__qualname__ = "ResolveSeriesError"
timeseries_logicalseries_api_ResolveSeriesError.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'name': ConjureFieldDefinition('name', api_Channel),
            'datasource': ConjureFieldDefinition('datasource', api_rids_DataSourceRid),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_name', '_datasource', '_tags']

    def __init__(self, datasource: str, name: str, tags: Dict[str, str]) -> None:
        self._name = name
        self._datasource = datasource
        self._tags = tags

    @builtins.property
    def name(self) -> str:
        return self._name

    @builtins.property
    def datasource(self) -> str:
        return self._datasource

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags


timeseries_logicalseries_api_ResolveSeriesRequest.__name__ = "ResolveSeriesRequest"
timeseries_logicalseries_api_ResolveSeriesRequest.__qualname__ = "ResolveSeriesRequest"
timeseries_logicalseries_api_ResolveSeriesRequest.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesResponse(ConjureUnionType):
    _rid: Optional[str] = None
    _error: Optional["timeseries_logicalseries_api_ResolveSeriesError"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_LogicalSeriesRid),
            'error': ConjureFieldDefinition('error', timeseries_logicalseries_api_ResolveSeriesError)
        }

    def __init__(
            self,
            rid: Optional[str] = None,
            error: Optional["timeseries_logicalseries_api_ResolveSeriesError"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (rid is not None) + (error is not None) != 1:
                raise ValueError('a union must contain a single member')

            if rid is not None:
                self._rid = rid
                self._type = 'rid'
            if error is not None:
                self._error = error
                self._type = 'error'

        elif type_of_union == 'rid':
            if rid is None:
                raise ValueError('a union value must not be None')
            self._rid = rid
            self._type = 'rid'
        elif type_of_union == 'error':
            if error is None:
                raise ValueError('a union value must not be None')
            self._error = error
            self._type = 'error'

    @builtins.property
    def rid(self) -> Optional[str]:
        return self._rid

    @builtins.property
    def error(self) -> Optional["timeseries_logicalseries_api_ResolveSeriesError"]:
        return self._error

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_ResolveSeriesResponseVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_ResolveSeriesResponseVisitor'.format(visitor.__class__.__name__))
        if self._type == 'rid' and self.rid is not None:
            return visitor._rid(self.rid)
        if self._type == 'error' and self.error is not None:
            return visitor._error(self.error)


timeseries_logicalseries_api_ResolveSeriesResponse.__name__ = "ResolveSeriesResponse"
timeseries_logicalseries_api_ResolveSeriesResponse.__qualname__ = "ResolveSeriesResponse"
timeseries_logicalseries_api_ResolveSeriesResponse.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_ResolveSeriesResponseVisitor:

    @abstractmethod
    def _rid(self, rid: str) -> Any:
        pass

    @abstractmethod
    def _error(self, error: "timeseries_logicalseries_api_ResolveSeriesError") -> Any:
        pass


timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__name__ = "ResolveSeriesResponseVisitor"
timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__qualname__ = "ResolveSeriesResponseVisitor"
timeseries_logicalseries_api_ResolveSeriesResponseVisitor.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimescaleDbLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'schema': ConjureFieldDefinition('schema', timeseries_logicalseries_api_SchemaName),
            'column': ConjureFieldDefinition('column', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'dimensions': ConjureFieldDefinition('dimensions', Dict[api_TagName, api_TagValue]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimescaleType)
        }

    __slots__: List[str] = ['_table', '_schema', '_column', '_time_column', '_dimensions', '_type']

    def __init__(self, column: str, dimensions: Dict[str, str], schema: str, table: str, time_column: str, type: "timeseries_logicalseries_api_TimescaleType") -> None:
        self._table = table
        self._schema = schema
        self._column = column
        self._time_column = time_column
        self._dimensions = dimensions
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def schema(self) -> str:
        return self._schema

    @builtins.property
    def column(self) -> str:
        return self._column

    @builtins.property
    def time_column(self) -> str:
        return self._time_column

    @builtins.property
    def dimensions(self) -> Dict[str, str]:
        return self._dimensions

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimescaleType":
        return self._type


timeseries_logicalseries_api_TimescaleDbLocator.__name__ = "TimescaleDbLocator"
timeseries_logicalseries_api_TimescaleDbLocator.__qualname__ = "TimescaleDbLocator"
timeseries_logicalseries_api_TimescaleDbLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimescaleType(ConjureEnumType):

    BOOLEAN = 'BOOLEAN'
    '''BOOLEAN'''
    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_TimescaleType.__name__ = "TimescaleType"
timeseries_logicalseries_api_TimescaleType.__qualname__ = "TimescaleType"
timeseries_logicalseries_api_TimescaleType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimestreamLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'dimensions': ConjureFieldDefinition('dimensions', Dict[api_TagName, api_TagValue]),
            'measure': ConjureFieldDefinition('measure', timeseries_logicalseries_api_MeasureName),
            'attribute': ConjureFieldDefinition('attribute', OptionalTypeWrapper[timeseries_logicalseries_api_AttributeName]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimestreamType)
        }

    __slots__: List[str] = ['_table', '_dimensions', '_measure', '_attribute', '_type']

    def __init__(self, dimensions: Dict[str, str], measure: str, table: str, type: "timeseries_logicalseries_api_TimestreamType", attribute: Optional[str] = None) -> None:
        self._table = table
        self._dimensions = dimensions
        self._measure = measure
        self._attribute = attribute
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def dimensions(self) -> Dict[str, str]:
        return self._dimensions

    @builtins.property
    def measure(self) -> str:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional[str]:
        """If present, will be the attribute within the measurement for multi-measures.
        """
        return self._attribute

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimestreamType":
        return self._type


timeseries_logicalseries_api_TimestreamLocator.__name__ = "TimestreamLocator"
timeseries_logicalseries_api_TimestreamLocator.__qualname__ = "TimestreamLocator"
timeseries_logicalseries_api_TimestreamLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_TimestreamType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_TimestreamType.__name__ = "TimestreamType"
timeseries_logicalseries_api_TimestreamType.__qualname__ = "TimestreamType"
timeseries_logicalseries_api_TimestreamType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UnitUpdate(ConjureUnionType):
    """UnitUpdate is used to either set a unit, or to clear an existing unit.
    """
    _unit: Optional[str] = None
    _clear_unit: Optional["api_Empty"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', api_Unit),
            'clear_unit': ConjureFieldDefinition('clearUnit', api_Empty)
        }

    def __init__(
            self,
            unit: Optional[str] = None,
            clear_unit: Optional["api_Empty"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (unit is not None) + (clear_unit is not None) != 1:
                raise ValueError('a union must contain a single member')

            if unit is not None:
                self._unit = unit
                self._type = 'unit'
            if clear_unit is not None:
                self._clear_unit = clear_unit
                self._type = 'clearUnit'

        elif type_of_union == 'unit':
            if unit is None:
                raise ValueError('a union value must not be None')
            self._unit = unit
            self._type = 'unit'
        elif type_of_union == 'clearUnit':
            if clear_unit is None:
                raise ValueError('a union value must not be None')
            self._clear_unit = clear_unit
            self._type = 'clearUnit'

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def clear_unit(self) -> Optional["api_Empty"]:
        return self._clear_unit

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_logicalseries_api_UnitUpdateVisitor):
            raise ValueError('{} is not an instance of timeseries_logicalseries_api_UnitUpdateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'unit' and self.unit is not None:
            return visitor._unit(self.unit)
        if self._type == 'clearUnit' and self.clear_unit is not None:
            return visitor._clear_unit(self.clear_unit)


timeseries_logicalseries_api_UnitUpdate.__name__ = "UnitUpdate"
timeseries_logicalseries_api_UnitUpdate.__qualname__ = "UnitUpdate"
timeseries_logicalseries_api_UnitUpdate.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UnitUpdateVisitor:

    @abstractmethod
    def _unit(self, unit: str) -> Any:
        pass

    @abstractmethod
    def _clear_unit(self, clear_unit: "api_Empty") -> Any:
        pass


timeseries_logicalseries_api_UnitUpdateVisitor.__name__ = "UnitUpdateVisitor"
timeseries_logicalseries_api_UnitUpdateVisitor.__qualname__ = "UnitUpdateVisitor"
timeseries_logicalseries_api_UnitUpdateVisitor.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_UpdateExternalStorageLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', api_LogicalSeriesRid),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'unit_update': ConjureFieldDefinition('unitUpdate', OptionalTypeWrapper[timeseries_logicalseries_api_UnitUpdate])
        }

    __slots__: List[str] = ['_logical_series_rid', '_description', '_unit', '_unit_update']

    def __init__(self, logical_series_rid: str, description: Optional[str] = None, unit: Optional[str] = None, unit_update: Optional["timeseries_logicalseries_api_UnitUpdate"] = None) -> None:
        self._logical_series_rid = logical_series_rid
        self._description = description
        self._unit = unit
        self._unit_update = unit_update

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def unit_update(self) -> Optional["timeseries_logicalseries_api_UnitUpdate"]:
        return self._unit_update


timeseries_logicalseries_api_UpdateExternalStorageLocator.__name__ = "UpdateExternalStorageLocator"
timeseries_logicalseries_api_UpdateExternalStorageLocator.__qualname__ = "UpdateExternalStorageLocator"
timeseries_logicalseries_api_UpdateExternalStorageLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingEndpointUri(ConjureEnumType):

    HISTORY = 'HISTORY'
    '''HISTORY'''
    TIMELINE = 'TIMELINE'
    '''TIMELINE'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_VisualCrossingEndpointUri.__name__ = "VisualCrossingEndpointUri"
timeseries_logicalseries_api_VisualCrossingEndpointUri.__qualname__ = "VisualCrossingEndpointUri"
timeseries_logicalseries_api_VisualCrossingEndpointUri.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingLocator(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'location': ConjureFieldDefinition('location', timeseries_logicalseries_api_LocationName),
            'endpoint': ConjureFieldDefinition('endpoint', OptionalTypeWrapper[timeseries_logicalseries_api_VisualCrossingEndpointUri]),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_location', '_endpoint', '_field', '_type']

    def __init__(self, field: str, location: str, type: "timeseries_logicalseries_api_VisualCrossingType", endpoint: Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"] = None) -> None:
        self._location = location
        self._endpoint = endpoint
        self._field = field
        self._type = type

    @builtins.property
    def location(self) -> str:
        """Location to fetch data from.  Can be any arbitrary string (i.e. name, abbreviation,
zip code, lat/long, etc.) as remote endpoint performs location resolution.
        """
        return self._location

    @builtins.property
    def endpoint(self) -> Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"]:
        """Defaults to HISTORY.  Endpoint to fetch data from for this series.
        """
        return self._endpoint

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_VisualCrossingType":
        return self._type


timeseries_logicalseries_api_VisualCrossingLocator.__name__ = "VisualCrossingLocator"
timeseries_logicalseries_api_VisualCrossingLocator.__qualname__ = "VisualCrossingLocator"
timeseries_logicalseries_api_VisualCrossingLocator.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_logicalseries_api_VisualCrossingType(ConjureEnumType):

    DOUBLE = 'DOUBLE'
    '''DOUBLE'''
    STRING = 'STRING'
    '''STRING'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_logicalseries_api_VisualCrossingType.__name__ = "VisualCrossingType"
timeseries_logicalseries_api_VisualCrossingType.__qualname__ = "VisualCrossingType"
timeseries_logicalseries_api_VisualCrossingType.__module__ = "nominal_api.timeseries_logicalseries_api"


class timeseries_metadata_SeriesMetadataService(Service):
    """[INTERNAL]
Series metadata represents the constant information about data in a series - specifically, the name, units, a
description, and the tags. Series metadata can be used to query points from specific series depending on the tag
value selections.
    """

    def batch_get(self, auth_header: str, request: "timeseries_metadata_api_BatchGetSeriesMetadataRequest") -> "timeseries_metadata_api_BatchGetSeriesMetadataResponse":
        """Batch get series metadata by DataSourceRid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/archetype/v1/series-archetype/batch-get'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_metadata_api_BatchGetSeriesMetadataResponse, self._return_none_for_unknown_union_types)

    def create(self, auth_header: str, request: "timeseries_metadata_api_CreateSeriesMetadataRequest") -> None:
        """Create new series metadata.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/archetype/v1/series-archetype'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def batch_create(self, auth_header: str, request: "timeseries_metadata_api_BatchCreateSeriesMetadataRequest") -> None:
        """Idempotently creates series metadata.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/archetype/v1/series-archetype/batch-create'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def get(self, auth_header: str, rid: str) -> "timeseries_metadata_api_SeriesMetadata":
        """Get series metadata from its series metadata rid.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = None

        _path = '/timeseries/archetype/v1/series-archetype/{rid}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_metadata_api_SeriesMetadata, self._return_none_for_unknown_union_types)

    def update_metadata(self, auth_header: str, request: "timeseries_metadata_api_UpdateSeriesMetadataRequest", rid: str) -> "timeseries_metadata_api_SeriesMetadata":
        """Update existing series metadata. 
Throws SeriesMetadataNotFound if the series metadata does not exist.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'rid': quote(str(_conjure_encoder.default(rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/archetype/v1/series-archetype/{rid}/metadata'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_metadata_api_SeriesMetadata, self._return_none_for_unknown_union_types)

    def batch_create_video_series(self, auth_header: str, request: "timeseries_metadata_api_BatchCreateVideoSeriesRequest") -> "timeseries_metadata_api_BatchCreateVideoSeriesResponse":
        """Batch creates series metadata for video channels if they don't exist.
Idempotent - returns existing SeriesMetadataRid if already exists.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/archetype/v1/series-archetype/video-channel'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_metadata_api_BatchCreateVideoSeriesResponse, self._return_none_for_unknown_union_types)


timeseries_metadata_SeriesMetadataService.__name__ = "SeriesMetadataService"
timeseries_metadata_SeriesMetadataService.__qualname__ = "SeriesMetadataService"
timeseries_metadata_SeriesMetadataService.__module__ = "nominal_api.timeseries_metadata"


class timeseries_metadata_api_ApiLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_ApiType)
        }

    __slots__: List[str] = ['_channel', '_type']

    def __init__(self, channel: str, type: "timeseries_logicalseries_api_ApiType") -> None:
        self._channel = channel
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_ApiType":
        return self._type


timeseries_metadata_api_ApiLocatorTemplate.__name__ = "ApiLocatorTemplate"
timeseries_metadata_api_ApiLocatorTemplate.__qualname__ = "ApiLocatorTemplate"
timeseries_metadata_api_ApiLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BatchCreateSeriesMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_metadata_api_CreateSeriesMetadataRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_metadata_api_CreateSeriesMetadataRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_metadata_api_CreateSeriesMetadataRequest"]:
        return self._requests


timeseries_metadata_api_BatchCreateSeriesMetadataRequest.__name__ = "BatchCreateSeriesMetadataRequest"
timeseries_metadata_api_BatchCreateSeriesMetadataRequest.__qualname__ = "BatchCreateSeriesMetadataRequest"
timeseries_metadata_api_BatchCreateSeriesMetadataRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BatchCreateVideoSeriesRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'requests': ConjureFieldDefinition('requests', List[timeseries_metadata_api_CreateVideoSeriesRequest])
        }

    __slots__: List[str] = ['_requests']

    def __init__(self, requests: List["timeseries_metadata_api_CreateVideoSeriesRequest"]) -> None:
        self._requests = requests

    @builtins.property
    def requests(self) -> List["timeseries_metadata_api_CreateVideoSeriesRequest"]:
        return self._requests


timeseries_metadata_api_BatchCreateVideoSeriesRequest.__name__ = "BatchCreateVideoSeriesRequest"
timeseries_metadata_api_BatchCreateVideoSeriesRequest.__qualname__ = "BatchCreateVideoSeriesRequest"
timeseries_metadata_api_BatchCreateVideoSeriesRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BatchCreateVideoSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', List[timeseries_metadata_api_CreateVideoSeriesResponse])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: List["timeseries_metadata_api_CreateVideoSeriesResponse"]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> List["timeseries_metadata_api_CreateVideoSeriesResponse"]:
        return self._responses


timeseries_metadata_api_BatchCreateVideoSeriesResponse.__name__ = "BatchCreateVideoSeriesResponse"
timeseries_metadata_api_BatchCreateVideoSeriesResponse.__qualname__ = "BatchCreateVideoSeriesResponse"
timeseries_metadata_api_BatchCreateVideoSeriesResponse.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BatchGetSeriesMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'datasources': ConjureFieldDefinition('datasources', List[api_rids_DataSourceRid])
        }

    __slots__: List[str] = ['_datasources']

    def __init__(self, datasources: List[str]) -> None:
        self._datasources = datasources

    @builtins.property
    def datasources(self) -> List[str]:
        return self._datasources


timeseries_metadata_api_BatchGetSeriesMetadataRequest.__name__ = "BatchGetSeriesMetadataRequest"
timeseries_metadata_api_BatchGetSeriesMetadataRequest.__qualname__ = "BatchGetSeriesMetadataRequest"
timeseries_metadata_api_BatchGetSeriesMetadataRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BatchGetSeriesMetadataResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'responses': ConjureFieldDefinition('responses', Dict[api_rids_DataSourceRid, List[timeseries_metadata_api_SeriesMetadata]])
        }

    __slots__: List[str] = ['_responses']

    def __init__(self, responses: Dict[str, List["timeseries_metadata_api_SeriesMetadata"]]) -> None:
        self._responses = responses

    @builtins.property
    def responses(self) -> Dict[str, List["timeseries_metadata_api_SeriesMetadata"]]:
        return self._responses


timeseries_metadata_api_BatchGetSeriesMetadataResponse.__name__ = "BatchGetSeriesMetadataResponse"
timeseries_metadata_api_BatchGetSeriesMetadataResponse.__qualname__ = "BatchGetSeriesMetadataResponse"
timeseries_metadata_api_BatchGetSeriesMetadataResponse.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_BigQueryLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'value_column': ConjureFieldDefinition('valueColumn', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_BigQueryType)
        }

    __slots__: List[str] = ['_value_column', '_time_column', '_type']

    def __init__(self, time_column: str, type: "timeseries_logicalseries_api_BigQueryType", value_column: str) -> None:
        self._value_column = value_column
        self._time_column = time_column
        self._type = type

    @builtins.property
    def value_column(self) -> str:
        return self._value_column

    @builtins.property
    def time_column(self) -> str:
        return self._time_column

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_BigQueryType":
        return self._type


timeseries_metadata_api_BigQueryLocatorTemplate.__name__ = "BigQueryLocatorTemplate"
timeseries_metadata_api_BigQueryLocatorTemplate.__qualname__ = "BigQueryLocatorTemplate"
timeseries_metadata_api_BigQueryLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_CreateSeriesMetadataRequest(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_metadata_api_LocatorTemplate),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue])
        }

    __slots__: List[str] = ['_channel', '_data_source_rid', '_locator', '_unit', '_description', '_tags']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_metadata_api_LocatorTemplate", tags: Dict[str, str], description: Optional[str] = None, unit: Optional[str] = None) -> None:
        self._channel = channel
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._unit = unit
        self._description = description
        self._tags = tags

    @builtins.property
    def channel(self) -> str:
        """This name should be unique amongst SeriesMetadata within the data source. All series created from this
metadata will share this name.
        """
        return self._channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_metadata_api_LocatorTemplate":
        return self._locator

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.
        """
        return self._tags


timeseries_metadata_api_CreateSeriesMetadataRequest.__name__ = "CreateSeriesMetadataRequest"
timeseries_metadata_api_CreateSeriesMetadataRequest.__qualname__ = "CreateSeriesMetadataRequest"
timeseries_metadata_api_CreateSeriesMetadataRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_CreateVideoSeriesRequest(ConjureBeanType):
    """Creates series and metadata for a video channel if it doesn't exist.
Returns the SeriesMetadataRid of the created or existing series metadata.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'dataset_rid': ConjureFieldDefinition('datasetRid', api_rids_DatasetRid),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'time_bounds': ConjureFieldDefinition('timeBounds', timeseries_metadata_api_TimeBounds)
        }

    __slots__: List[str] = ['_dataset_rid', '_channel', '_tags', '_time_bounds']

    def __init__(self, channel: str, dataset_rid: str, tags: Dict[str, str], time_bounds: "timeseries_metadata_api_TimeBounds") -> None:
        self._dataset_rid = dataset_rid
        self._channel = channel
        self._tags = tags
        self._time_bounds = time_bounds

    @builtins.property
    def dataset_rid(self) -> str:
        return self._dataset_rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def tags(self) -> Dict[str, str]:
        return self._tags

    @builtins.property
    def time_bounds(self) -> "timeseries_metadata_api_TimeBounds":
        return self._time_bounds


timeseries_metadata_api_CreateVideoSeriesRequest.__name__ = "CreateVideoSeriesRequest"
timeseries_metadata_api_CreateVideoSeriesRequest.__qualname__ = "CreateVideoSeriesRequest"
timeseries_metadata_api_CreateVideoSeriesRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_CreateVideoSeriesResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'series_metadata_rid': ConjureFieldDefinition('seriesMetadataRid', api_SeriesMetadataRid),
            'series_uuid': ConjureFieldDefinition('seriesUuid', str)
        }

    __slots__: List[str] = ['_series_metadata_rid', '_series_uuid']

    def __init__(self, series_metadata_rid: str, series_uuid: str) -> None:
        self._series_metadata_rid = series_metadata_rid
        self._series_uuid = series_uuid

    @builtins.property
    def series_metadata_rid(self) -> str:
        return self._series_metadata_rid

    @builtins.property
    def series_uuid(self) -> str:
        return self._series_uuid


timeseries_metadata_api_CreateVideoSeriesResponse.__name__ = "CreateVideoSeriesResponse"
timeseries_metadata_api_CreateVideoSeriesResponse.__qualname__ = "CreateVideoSeriesResponse"
timeseries_metadata_api_CreateVideoSeriesResponse.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_Influx1LocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'database': ConjureFieldDefinition('database', timeseries_logicalseries_api_DatabaseName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_database', '_measurement', '_field', '_type']

    def __init__(self, database: str, field: str, measurement: str, type: "timeseries_logicalseries_api_InfluxType") -> None:
        self._database = database
        self._measurement = measurement
        self._field = field
        self._type = type

    @builtins.property
    def database(self) -> str:
        return self._database

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_metadata_api_Influx1LocatorTemplate.__name__ = "Influx1LocatorTemplate"
timeseries_metadata_api_Influx1LocatorTemplate.__qualname__ = "Influx1LocatorTemplate"
timeseries_metadata_api_Influx1LocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_Influx2LocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'bucket': ConjureFieldDefinition('bucket', timeseries_logicalseries_api_BucketName),
            'measurement': ConjureFieldDefinition('measurement', timeseries_logicalseries_api_MeasurementName),
            'value_column': ConjureFieldDefinition('valueColumn', OptionalTypeWrapper[str]),
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_InfluxType)
        }

    __slots__: List[str] = ['_bucket', '_measurement', '_value_column', '_field', '_type']

    def __init__(self, bucket: str, field: str, measurement: str, type: "timeseries_logicalseries_api_InfluxType", value_column: Optional[str] = None) -> None:
        self._bucket = bucket
        self._measurement = measurement
        self._value_column = value_column
        self._field = field
        self._type = type

    @builtins.property
    def bucket(self) -> str:
        return self._bucket

    @builtins.property
    def measurement(self) -> str:
        return self._measurement

    @builtins.property
    def value_column(self) -> Optional[str]:
        """If omitted, defaults to `_value`. Can be used to extract tag values.
        """
        return self._value_column

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_InfluxType":
        return self._type


timeseries_metadata_api_Influx2LocatorTemplate.__name__ = "Influx2LocatorTemplate"
timeseries_metadata_api_Influx2LocatorTemplate.__qualname__ = "Influx2LocatorTemplate"
timeseries_metadata_api_Influx2LocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_LocatorTemplate(ConjureUnionType):
    _timescale_db: Optional["timeseries_metadata_api_TimescaleDbLocatorTemplate"] = None
    _influx: Optional["timeseries_metadata_api_Influx2LocatorTemplate"] = None
    _influx1: Optional["timeseries_metadata_api_Influx1LocatorTemplate"] = None
    _nominal: Optional["timeseries_metadata_api_NominalLocatorTemplate"] = None
    _timestream: Optional["timeseries_metadata_api_TimestreamLocatorTemplate"] = None
    _visual_crossing: Optional["timeseries_metadata_api_VisualCrossingLocatorTemplate"] = None
    _big_query: Optional["timeseries_metadata_api_BigQueryLocatorTemplate"] = None
    _api: Optional["timeseries_metadata_api_ApiLocatorTemplate"] = None
    _video: Optional["timeseries_metadata_api_VideoLocatorTemplate"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'timescale_db': ConjureFieldDefinition('timescaleDb', timeseries_metadata_api_TimescaleDbLocatorTemplate),
            'influx': ConjureFieldDefinition('influx', timeseries_metadata_api_Influx2LocatorTemplate),
            'influx1': ConjureFieldDefinition('influx1', timeseries_metadata_api_Influx1LocatorTemplate),
            'nominal': ConjureFieldDefinition('nominal', timeseries_metadata_api_NominalLocatorTemplate),
            'timestream': ConjureFieldDefinition('timestream', timeseries_metadata_api_TimestreamLocatorTemplate),
            'visual_crossing': ConjureFieldDefinition('visualCrossing', timeseries_metadata_api_VisualCrossingLocatorTemplate),
            'big_query': ConjureFieldDefinition('bigQuery', timeseries_metadata_api_BigQueryLocatorTemplate),
            'api': ConjureFieldDefinition('api', timeseries_metadata_api_ApiLocatorTemplate),
            'video': ConjureFieldDefinition('video', timeseries_metadata_api_VideoLocatorTemplate)
        }

    def __init__(
            self,
            timescale_db: Optional["timeseries_metadata_api_TimescaleDbLocatorTemplate"] = None,
            influx: Optional["timeseries_metadata_api_Influx2LocatorTemplate"] = None,
            influx1: Optional["timeseries_metadata_api_Influx1LocatorTemplate"] = None,
            nominal: Optional["timeseries_metadata_api_NominalLocatorTemplate"] = None,
            timestream: Optional["timeseries_metadata_api_TimestreamLocatorTemplate"] = None,
            visual_crossing: Optional["timeseries_metadata_api_VisualCrossingLocatorTemplate"] = None,
            big_query: Optional["timeseries_metadata_api_BigQueryLocatorTemplate"] = None,
            api: Optional["timeseries_metadata_api_ApiLocatorTemplate"] = None,
            video: Optional["timeseries_metadata_api_VideoLocatorTemplate"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (timescale_db is not None) + (influx is not None) + (influx1 is not None) + (nominal is not None) + (timestream is not None) + (visual_crossing is not None) + (big_query is not None) + (api is not None) + (video is not None) != 1:
                raise ValueError('a union must contain a single member')

            if timescale_db is not None:
                self._timescale_db = timescale_db
                self._type = 'timescaleDb'
            if influx is not None:
                self._influx = influx
                self._type = 'influx'
            if influx1 is not None:
                self._influx1 = influx1
                self._type = 'influx1'
            if nominal is not None:
                self._nominal = nominal
                self._type = 'nominal'
            if timestream is not None:
                self._timestream = timestream
                self._type = 'timestream'
            if visual_crossing is not None:
                self._visual_crossing = visual_crossing
                self._type = 'visualCrossing'
            if big_query is not None:
                self._big_query = big_query
                self._type = 'bigQuery'
            if api is not None:
                self._api = api
                self._type = 'api'
            if video is not None:
                self._video = video
                self._type = 'video'

        elif type_of_union == 'timescaleDb':
            if timescale_db is None:
                raise ValueError('a union value must not be None')
            self._timescale_db = timescale_db
            self._type = 'timescaleDb'
        elif type_of_union == 'influx':
            if influx is None:
                raise ValueError('a union value must not be None')
            self._influx = influx
            self._type = 'influx'
        elif type_of_union == 'influx1':
            if influx1 is None:
                raise ValueError('a union value must not be None')
            self._influx1 = influx1
            self._type = 'influx1'
        elif type_of_union == 'nominal':
            if nominal is None:
                raise ValueError('a union value must not be None')
            self._nominal = nominal
            self._type = 'nominal'
        elif type_of_union == 'timestream':
            if timestream is None:
                raise ValueError('a union value must not be None')
            self._timestream = timestream
            self._type = 'timestream'
        elif type_of_union == 'visualCrossing':
            if visual_crossing is None:
                raise ValueError('a union value must not be None')
            self._visual_crossing = visual_crossing
            self._type = 'visualCrossing'
        elif type_of_union == 'bigQuery':
            if big_query is None:
                raise ValueError('a union value must not be None')
            self._big_query = big_query
            self._type = 'bigQuery'
        elif type_of_union == 'api':
            if api is None:
                raise ValueError('a union value must not be None')
            self._api = api
            self._type = 'api'
        elif type_of_union == 'video':
            if video is None:
                raise ValueError('a union value must not be None')
            self._video = video
            self._type = 'video'

    @builtins.property
    def timescale_db(self) -> Optional["timeseries_metadata_api_TimescaleDbLocatorTemplate"]:
        return self._timescale_db

    @builtins.property
    def influx(self) -> Optional["timeseries_metadata_api_Influx2LocatorTemplate"]:
        return self._influx

    @builtins.property
    def influx1(self) -> Optional["timeseries_metadata_api_Influx1LocatorTemplate"]:
        return self._influx1

    @builtins.property
    def nominal(self) -> Optional["timeseries_metadata_api_NominalLocatorTemplate"]:
        return self._nominal

    @builtins.property
    def timestream(self) -> Optional["timeseries_metadata_api_TimestreamLocatorTemplate"]:
        return self._timestream

    @builtins.property
    def visual_crossing(self) -> Optional["timeseries_metadata_api_VisualCrossingLocatorTemplate"]:
        return self._visual_crossing

    @builtins.property
    def big_query(self) -> Optional["timeseries_metadata_api_BigQueryLocatorTemplate"]:
        return self._big_query

    @builtins.property
    def api(self) -> Optional["timeseries_metadata_api_ApiLocatorTemplate"]:
        return self._api

    @builtins.property
    def video(self) -> Optional["timeseries_metadata_api_VideoLocatorTemplate"]:
        return self._video

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_metadata_api_LocatorTemplateVisitor):
            raise ValueError('{} is not an instance of timeseries_metadata_api_LocatorTemplateVisitor'.format(visitor.__class__.__name__))
        if self._type == 'timescaleDb' and self.timescale_db is not None:
            return visitor._timescale_db(self.timescale_db)
        if self._type == 'influx' and self.influx is not None:
            return visitor._influx(self.influx)
        if self._type == 'influx1' and self.influx1 is not None:
            return visitor._influx1(self.influx1)
        if self._type == 'nominal' and self.nominal is not None:
            return visitor._nominal(self.nominal)
        if self._type == 'timestream' and self.timestream is not None:
            return visitor._timestream(self.timestream)
        if self._type == 'visualCrossing' and self.visual_crossing is not None:
            return visitor._visual_crossing(self.visual_crossing)
        if self._type == 'bigQuery' and self.big_query is not None:
            return visitor._big_query(self.big_query)
        if self._type == 'api' and self.api is not None:
            return visitor._api(self.api)
        if self._type == 'video' and self.video is not None:
            return visitor._video(self.video)


timeseries_metadata_api_LocatorTemplate.__name__ = "LocatorTemplate"
timeseries_metadata_api_LocatorTemplate.__qualname__ = "LocatorTemplate"
timeseries_metadata_api_LocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_LocatorTemplateVisitor:

    @abstractmethod
    def _timescale_db(self, timescale_db: "timeseries_metadata_api_TimescaleDbLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _influx(self, influx: "timeseries_metadata_api_Influx2LocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _influx1(self, influx1: "timeseries_metadata_api_Influx1LocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _nominal(self, nominal: "timeseries_metadata_api_NominalLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _timestream(self, timestream: "timeseries_metadata_api_TimestreamLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _visual_crossing(self, visual_crossing: "timeseries_metadata_api_VisualCrossingLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _big_query(self, big_query: "timeseries_metadata_api_BigQueryLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _api(self, api: "timeseries_metadata_api_ApiLocatorTemplate") -> Any:
        pass

    @abstractmethod
    def _video(self, video: "timeseries_metadata_api_VideoLocatorTemplate") -> Any:
        pass


timeseries_metadata_api_LocatorTemplateVisitor.__name__ = "LocatorTemplateVisitor"
timeseries_metadata_api_LocatorTemplateVisitor.__qualname__ = "LocatorTemplateVisitor"
timeseries_metadata_api_LocatorTemplateVisitor.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_NominalLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'type': ConjureFieldDefinition('type', storage_series_api_NominalDataType)
        }

    __slots__: List[str] = ['_channel', '_type']

    def __init__(self, channel: str, type: "storage_series_api_NominalDataType") -> None:
        self._channel = channel
        self._type = type

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def type(self) -> "storage_series_api_NominalDataType":
        return self._type


timeseries_metadata_api_NominalLocatorTemplate.__name__ = "NominalLocatorTemplate"
timeseries_metadata_api_NominalLocatorTemplate.__qualname__ = "NominalLocatorTemplate"
timeseries_metadata_api_NominalLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_SeriesMetadata(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_SeriesMetadataRid),
            'channel': ConjureFieldDefinition('channel', api_Channel),
            'data_source_rid': ConjureFieldDefinition('dataSourceRid', api_rids_DataSourceRid),
            'locator': ConjureFieldDefinition('locator', timeseries_metadata_api_LocatorTemplate),
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str]),
            'tags': ConjureFieldDefinition('tags', Dict[api_TagName, api_TagValue]),
            'series_data_type': ConjureFieldDefinition('seriesDataType', OptionalTypeWrapper[api_SeriesDataType])
        }

    __slots__: List[str] = ['_rid', '_channel', '_data_source_rid', '_locator', '_unit', '_description', '_tags', '_series_data_type']

    def __init__(self, channel: str, data_source_rid: str, locator: "timeseries_metadata_api_LocatorTemplate", rid: str, tags: Dict[str, str], description: Optional[str] = None, series_data_type: Optional["api_SeriesDataType"] = None, unit: Optional[str] = None) -> None:
        self._rid = rid
        self._channel = channel
        self._data_source_rid = data_source_rid
        self._locator = locator
        self._unit = unit
        self._description = description
        self._tags = tags
        self._series_data_type = series_data_type

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def channel(self) -> str:
        return self._channel

    @builtins.property
    def data_source_rid(self) -> str:
        return self._data_source_rid

    @builtins.property
    def locator(self) -> "timeseries_metadata_api_LocatorTemplate":
        return self._locator

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description

    @builtins.property
    def tags(self) -> Dict[str, str]:
        """Tags specified here will take precedence over tags specified in the RunDatasource, in the case that both specify the same TagName.
        """
        return self._tags

    @builtins.property
    def series_data_type(self) -> Optional["api_SeriesDataType"]:
        return self._series_data_type


timeseries_metadata_api_SeriesMetadata.__name__ = "SeriesMetadata"
timeseries_metadata_api_SeriesMetadata.__qualname__ = "SeriesMetadata"
timeseries_metadata_api_SeriesMetadata.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_TimeBounds(ConjureBeanType):
    """Time bounds for the video file. Used to update the series time bounds
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start': ConjureFieldDefinition('start', api_Timestamp),
            'end': ConjureFieldDefinition('end', api_Timestamp)
        }

    __slots__: List[str] = ['_start', '_end']

    def __init__(self, end: "api_Timestamp", start: "api_Timestamp") -> None:
        self._start = start
        self._end = end

    @builtins.property
    def start(self) -> "api_Timestamp":
        return self._start

    @builtins.property
    def end(self) -> "api_Timestamp":
        return self._end


timeseries_metadata_api_TimeBounds.__name__ = "TimeBounds"
timeseries_metadata_api_TimeBounds.__qualname__ = "TimeBounds"
timeseries_metadata_api_TimeBounds.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_TimescaleDbLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'schema': ConjureFieldDefinition('schema', timeseries_logicalseries_api_SchemaName),
            'column': ConjureFieldDefinition('column', timeseries_logicalseries_api_ColumnName),
            'time_column': ConjureFieldDefinition('timeColumn', timeseries_logicalseries_api_ColumnName),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimescaleType)
        }

    __slots__: List[str] = ['_table', '_schema', '_column', '_time_column', '_type']

    def __init__(self, column: str, schema: str, table: str, time_column: str, type: "timeseries_logicalseries_api_TimescaleType") -> None:
        self._table = table
        self._schema = schema
        self._column = column
        self._time_column = time_column
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def schema(self) -> str:
        return self._schema

    @builtins.property
    def column(self) -> str:
        return self._column

    @builtins.property
    def time_column(self) -> str:
        return self._time_column

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimescaleType":
        return self._type


timeseries_metadata_api_TimescaleDbLocatorTemplate.__name__ = "TimescaleDbLocatorTemplate"
timeseries_metadata_api_TimescaleDbLocatorTemplate.__qualname__ = "TimescaleDbLocatorTemplate"
timeseries_metadata_api_TimescaleDbLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_TimestreamLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'table': ConjureFieldDefinition('table', timeseries_logicalseries_api_TableName),
            'measure': ConjureFieldDefinition('measure', timeseries_logicalseries_api_MeasureName),
            'attribute': ConjureFieldDefinition('attribute', OptionalTypeWrapper[timeseries_logicalseries_api_AttributeName]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_TimestreamType)
        }

    __slots__: List[str] = ['_table', '_measure', '_attribute', '_type']

    def __init__(self, measure: str, table: str, type: "timeseries_logicalseries_api_TimestreamType", attribute: Optional[str] = None) -> None:
        self._table = table
        self._measure = measure
        self._attribute = attribute
        self._type = type

    @builtins.property
    def table(self) -> str:
        return self._table

    @builtins.property
    def measure(self) -> str:
        return self._measure

    @builtins.property
    def attribute(self) -> Optional[str]:
        return self._attribute

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_TimestreamType":
        return self._type


timeseries_metadata_api_TimestreamLocatorTemplate.__name__ = "TimestreamLocatorTemplate"
timeseries_metadata_api_TimestreamLocatorTemplate.__qualname__ = "TimestreamLocatorTemplate"
timeseries_metadata_api_TimestreamLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_UpdateSeriesMetadataRequest(ConjureBeanType):
    """If fields are present, will override existing values.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'unit': ConjureFieldDefinition('unit', OptionalTypeWrapper[api_Unit]),
            'unit_update': ConjureFieldDefinition('unitUpdate', OptionalTypeWrapper[timeseries_logicalseries_api_UnitUpdate]),
            'description': ConjureFieldDefinition('description', OptionalTypeWrapper[str])
        }

    __slots__: List[str] = ['_unit', '_unit_update', '_description']

    def __init__(self, description: Optional[str] = None, unit: Optional[str] = None, unit_update: Optional["timeseries_logicalseries_api_UnitUpdate"] = None) -> None:
        self._unit = unit
        self._unit_update = unit_update
        self._description = description

    @builtins.property
    def unit(self) -> Optional[str]:
        return self._unit

    @builtins.property
    def unit_update(self) -> Optional["timeseries_logicalseries_api_UnitUpdate"]:
        return self._unit_update

    @builtins.property
    def description(self) -> Optional[str]:
        return self._description


timeseries_metadata_api_UpdateSeriesMetadataRequest.__name__ = "UpdateSeriesMetadataRequest"
timeseries_metadata_api_UpdateSeriesMetadataRequest.__qualname__ = "UpdateSeriesMetadataRequest"
timeseries_metadata_api_UpdateSeriesMetadataRequest.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_VideoLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'channel': ConjureFieldDefinition('channel', api_Channel)
        }

    __slots__: List[str] = ['_channel']

    def __init__(self, channel: str) -> None:
        self._channel = channel

    @builtins.property
    def channel(self) -> str:
        return self._channel


timeseries_metadata_api_VideoLocatorTemplate.__name__ = "VideoLocatorTemplate"
timeseries_metadata_api_VideoLocatorTemplate.__qualname__ = "VideoLocatorTemplate"
timeseries_metadata_api_VideoLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_metadata_api_VisualCrossingLocatorTemplate(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'field': ConjureFieldDefinition('field', timeseries_logicalseries_api_FieldName),
            'endpoint': ConjureFieldDefinition('endpoint', OptionalTypeWrapper[timeseries_logicalseries_api_VisualCrossingEndpointUri]),
            'type': ConjureFieldDefinition('type', timeseries_logicalseries_api_VisualCrossingType)
        }

    __slots__: List[str] = ['_field', '_endpoint', '_type']

    def __init__(self, field: str, type: "timeseries_logicalseries_api_VisualCrossingType", endpoint: Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"] = None) -> None:
        self._field = field
        self._endpoint = endpoint
        self._type = type

    @builtins.property
    def field(self) -> str:
        return self._field

    @builtins.property
    def endpoint(self) -> Optional["timeseries_logicalseries_api_VisualCrossingEndpointUri"]:
        """Defaults to HISTORY.
        """
        return self._endpoint

    @builtins.property
    def type(self) -> "timeseries_logicalseries_api_VisualCrossingType":
        return self._type


timeseries_metadata_api_VisualCrossingLocatorTemplate.__name__ = "VisualCrossingLocatorTemplate"
timeseries_metadata_api_VisualCrossingLocatorTemplate.__qualname__ = "VisualCrossingLocatorTemplate"
timeseries_metadata_api_VisualCrossingLocatorTemplate.__module__ = "nominal_api.timeseries_metadata_api"


class timeseries_seriescache_SeriesCacheService(Service):
    """The Series Cache service manages internal chunks of data cached by Nominal's backend.
    """

    def get_chunks(self, auth_header: str, get_chunks_parameters: "timeseries_seriescache_api_GetChunksParameters", logical_series_rid: str) -> "timeseries_seriescache_api_GetChunksResponse":
        """Fetches "chunks" of series that are stored as Arrow files in S3.
This endpoint is being deprecated for new series in favor of batchGetCachedSeries
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'logicalSeriesRid': quote(str(_conjure_encoder.default(logical_series_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(get_chunks_parameters)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/get-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_GetChunksResponse, self._return_none_for_unknown_union_types)

    def create_chunks(self, auth_header: str, create_chunks_parameters: "timeseries_seriescache_api_CreateChunksParameters", logical_series_rid: str) -> "timeseries_seriescache_api_CreateChunksResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'logicalSeriesRid': quote(str(_conjure_encoder.default(logical_series_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(create_chunks_parameters)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/create-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_CreateChunksResponse, self._return_none_for_unknown_union_types)

    def batch_create_chunks(self, auth_header: str, request: "timeseries_seriescache_api_CreateChunksParameters") -> "timeseries_seriescache_api_CreateChunksResponse":
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/series-cache/v1/batch-create-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_CreateChunksResponse, self._return_none_for_unknown_union_types)

    def delete_chunks(self, auth_header: str, logical_series_rid: str, request: "timeseries_seriescache_api_DeleteChunksParameters") -> "timeseries_seriescache_api_DeleteChunksResponse":
        """Deletes the chunks that intersect the given time range. Does not delete the corresponding files from S3.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
            'logicalSeriesRid': quote(str(_conjure_encoder.default(logical_series_rid)), safe=''),
        }

        _json: Any = _conjure_encoder.default(request)

        _path = '/timeseries/series-cache/v1/logical-series/{logicalSeriesRid}/delete-chunks'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), timeseries_seriescache_api_DeleteChunksResponse, self._return_none_for_unknown_union_types)


timeseries_seriescache_SeriesCacheService.__name__ = "SeriesCacheService"
timeseries_seriescache_SeriesCacheService.__qualname__ = "SeriesCacheService"
timeseries_seriescache_SeriesCacheService.__module__ = "nominal_api.timeseries_seriescache"


class timeseries_seriescache_api_Chunk(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'rid': ConjureFieldDefinition('rid', api_rids_ChunkRid),
            'type': ConjureFieldDefinition('type', timeseries_seriescache_api_ChunkType),
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', api_LogicalSeriesRid),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int),
            'size_in_bytes': ConjureFieldDefinition('sizeInBytes', int),
            'resolution': ConjureFieldDefinition('resolution', timeseries_seriescache_api_Resolution),
            'handle': ConjureFieldDefinition('handle', timeseries_seriescache_api_Handle)
        }

    __slots__: List[str] = ['_rid', '_type', '_logical_series_rid', '_start_timestamp', '_end_timestamp', '_count', '_size_in_bytes', '_resolution', '_handle']

    def __init__(self, count: int, end_timestamp: "api_Timestamp", handle: "timeseries_seriescache_api_Handle", logical_series_rid: str, resolution: int, rid: str, size_in_bytes: int, start_timestamp: "api_Timestamp", type: "timeseries_seriescache_api_ChunkType") -> None:
        self._rid = rid
        self._type = type
        self._logical_series_rid = logical_series_rid
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._count = count
        self._size_in_bytes = size_in_bytes
        self._resolution = resolution
        self._handle = handle

    @builtins.property
    def rid(self) -> str:
        return self._rid

    @builtins.property
    def type(self) -> "timeseries_seriescache_api_ChunkType":
        return self._type

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def count(self) -> int:
        """The number of distinct timestamps contained within the chunk.
        """
        return self._count

    @builtins.property
    def size_in_bytes(self) -> int:
        return self._size_in_bytes

    @builtins.property
    def resolution(self) -> int:
        return self._resolution

    @builtins.property
    def handle(self) -> "timeseries_seriescache_api_Handle":
        return self._handle


timeseries_seriescache_api_Chunk.__name__ = "Chunk"
timeseries_seriescache_api_Chunk.__qualname__ = "Chunk"
timeseries_seriescache_api_Chunk.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_ChunkType(ConjureEnumType):

    ARROW_WITH_RELATIVE_TIMESTAMPS = 'ARROW_WITH_RELATIVE_TIMESTAMPS'
    '''ARROW_WITH_RELATIVE_TIMESTAMPS'''
    ARROW_WITH_ABSOLUTE_TIMESTAMPS = 'ARROW_WITH_ABSOLUTE_TIMESTAMPS'
    '''ARROW_WITH_ABSOLUTE_TIMESTAMPS'''
    UNKNOWN = 'UNKNOWN'
    '''UNKNOWN'''

    def __reduce_ex__(self, proto):
        return self.__class__, (self.name,)


timeseries_seriescache_api_ChunkType.__name__ = "ChunkType"
timeseries_seriescache_api_ChunkType.__qualname__ = "ChunkType"
timeseries_seriescache_api_ChunkType.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunk(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'type': ConjureFieldDefinition('type', timeseries_seriescache_api_ChunkType),
            'logical_series_rid': ConjureFieldDefinition('logicalSeriesRid', api_LogicalSeriesRid),
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'count': ConjureFieldDefinition('count', int),
            'size_in_bytes': ConjureFieldDefinition('sizeInBytes', int),
            'resolution': ConjureFieldDefinition('resolution', timeseries_seriescache_api_Resolution),
            'handle': ConjureFieldDefinition('handle', timeseries_seriescache_api_Handle)
        }

    __slots__: List[str] = ['_type', '_logical_series_rid', '_start_timestamp', '_end_timestamp', '_count', '_size_in_bytes', '_resolution', '_handle']

    def __init__(self, count: int, end_timestamp: "api_Timestamp", handle: "timeseries_seriescache_api_Handle", logical_series_rid: str, resolution: int, size_in_bytes: int, start_timestamp: "api_Timestamp", type: "timeseries_seriescache_api_ChunkType") -> None:
        self._type = type
        self._logical_series_rid = logical_series_rid
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._count = count
        self._size_in_bytes = size_in_bytes
        self._resolution = resolution
        self._handle = handle

    @builtins.property
    def type(self) -> "timeseries_seriescache_api_ChunkType":
        return self._type

    @builtins.property
    def logical_series_rid(self) -> str:
        return self._logical_series_rid

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def count(self) -> int:
        return self._count

    @builtins.property
    def size_in_bytes(self) -> int:
        return self._size_in_bytes

    @builtins.property
    def resolution(self) -> int:
        return self._resolution

    @builtins.property
    def handle(self) -> "timeseries_seriescache_api_Handle":
        return self._handle


timeseries_seriescache_api_CreateChunk.__name__ = "CreateChunk"
timeseries_seriescache_api_CreateChunk.__qualname__ = "CreateChunk"
timeseries_seriescache_api_CreateChunk.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'create_chunks': ConjureFieldDefinition('createChunks', List[timeseries_seriescache_api_CreateChunk])
        }

    __slots__: List[str] = ['_create_chunks']

    def __init__(self, create_chunks: List["timeseries_seriescache_api_CreateChunk"]) -> None:
        self._create_chunks = create_chunks

    @builtins.property
    def create_chunks(self) -> List["timeseries_seriescache_api_CreateChunk"]:
        return self._create_chunks


timeseries_seriescache_api_CreateChunksParameters.__name__ = "CreateChunksParameters"
timeseries_seriescache_api_CreateChunksParameters.__qualname__ = "CreateChunksParameters"
timeseries_seriescache_api_CreateChunksParameters.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_CreateChunksResponse(ConjureBeanType):
    """Responses are returned in the same order as the requests.
    """

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'chunk_rids': ConjureFieldDefinition('chunkRids', List[api_rids_ChunkRid])
        }

    __slots__: List[str] = ['_chunk_rids']

    def __init__(self, chunk_rids: List[str]) -> None:
        self._chunk_rids = chunk_rids

    @builtins.property
    def chunk_rids(self) -> List[str]:
        return self._chunk_rids


timeseries_seriescache_api_CreateChunksResponse.__name__ = "CreateChunksResponse"
timeseries_seriescache_api_CreateChunksResponse.__qualname__ = "CreateChunksResponse"
timeseries_seriescache_api_CreateChunksResponse.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_DeleteChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp)
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp']

    def __init__(self, end_timestamp: "api_Timestamp", start_timestamp: "api_Timestamp") -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp


timeseries_seriescache_api_DeleteChunksParameters.__name__ = "DeleteChunksParameters"
timeseries_seriescache_api_DeleteChunksParameters.__qualname__ = "DeleteChunksParameters"
timeseries_seriescache_api_DeleteChunksParameters.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_DeleteChunksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'deleted_chunk_rids': ConjureFieldDefinition('deletedChunkRids', List[api_rids_ChunkRid])
        }

    __slots__: List[str] = ['_deleted_chunk_rids']

    def __init__(self, deleted_chunk_rids: List[str]) -> None:
        self._deleted_chunk_rids = deleted_chunk_rids

    @builtins.property
    def deleted_chunk_rids(self) -> List[str]:
        return self._deleted_chunk_rids


timeseries_seriescache_api_DeleteChunksResponse.__name__ = "DeleteChunksResponse"
timeseries_seriescache_api_DeleteChunksResponse.__qualname__ = "DeleteChunksResponse"
timeseries_seriescache_api_DeleteChunksResponse.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_GetChunksParameters(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'start_timestamp': ConjureFieldDefinition('startTimestamp', api_Timestamp),
            'end_timestamp': ConjureFieldDefinition('endTimestamp', api_Timestamp),
            'resolution_nanos': ConjureFieldDefinition('resolutionNanos', int)
        }

    __slots__: List[str] = ['_start_timestamp', '_end_timestamp', '_resolution_nanos']

    def __init__(self, end_timestamp: "api_Timestamp", resolution_nanos: int, start_timestamp: "api_Timestamp") -> None:
        self._start_timestamp = start_timestamp
        self._end_timestamp = end_timestamp
        self._resolution_nanos = resolution_nanos

    @builtins.property
    def start_timestamp(self) -> "api_Timestamp":
        return self._start_timestamp

    @builtins.property
    def end_timestamp(self) -> "api_Timestamp":
        return self._end_timestamp

    @builtins.property
    def resolution_nanos(self) -> int:
        return self._resolution_nanos


timeseries_seriescache_api_GetChunksParameters.__name__ = "GetChunksParameters"
timeseries_seriescache_api_GetChunksParameters.__qualname__ = "GetChunksParameters"
timeseries_seriescache_api_GetChunksParameters.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_GetChunksResponse(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            'chunks': ConjureFieldDefinition('chunks', List[timeseries_seriescache_api_Chunk])
        }

    __slots__: List[str] = ['_chunks']

    def __init__(self, chunks: List["timeseries_seriescache_api_Chunk"]) -> None:
        self._chunks = chunks

    @builtins.property
    def chunks(self) -> List["timeseries_seriescache_api_Chunk"]:
        return self._chunks


timeseries_seriescache_api_GetChunksResponse.__name__ = "GetChunksResponse"
timeseries_seriescache_api_GetChunksResponse.__qualname__ = "GetChunksResponse"
timeseries_seriescache_api_GetChunksResponse.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_Handle(ConjureUnionType):
    _s3: Optional["timeseries_seriescache_api_S3Handle"] = None

    @builtins.classmethod
    def _options(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3': ConjureFieldDefinition('s3', timeseries_seriescache_api_S3Handle)
        }

    def __init__(
            self,
            s3: Optional["timeseries_seriescache_api_S3Handle"] = None,
            type_of_union: Optional[str] = None
            ) -> None:
        if type_of_union is None:
            if (s3 is not None) != 1:
                raise ValueError('a union must contain a single member')

            if s3 is not None:
                self._s3 = s3
                self._type = 's3'

        elif type_of_union == 's3':
            if s3 is None:
                raise ValueError('a union value must not be None')
            self._s3 = s3
            self._type = 's3'

    @builtins.property
    def s3(self) -> Optional["timeseries_seriescache_api_S3Handle"]:
        return self._s3

    def accept(self, visitor) -> Any:
        if not isinstance(visitor, timeseries_seriescache_api_HandleVisitor):
            raise ValueError('{} is not an instance of timeseries_seriescache_api_HandleVisitor'.format(visitor.__class__.__name__))
        if self._type == 's3' and self.s3 is not None:
            return visitor._s3(self.s3)


timeseries_seriescache_api_Handle.__name__ = "Handle"
timeseries_seriescache_api_Handle.__qualname__ = "Handle"
timeseries_seriescache_api_Handle.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_HandleVisitor:

    @abstractmethod
    def _s3(self, s3: "timeseries_seriescache_api_S3Handle") -> Any:
        pass


timeseries_seriescache_api_HandleVisitor.__name__ = "HandleVisitor"
timeseries_seriescache_api_HandleVisitor.__qualname__ = "HandleVisitor"
timeseries_seriescache_api_HandleVisitor.__module__ = "nominal_api.timeseries_seriescache_api"


class timeseries_seriescache_api_S3Handle(ConjureBeanType):

    @builtins.classmethod
    def _fields(cls) -> Dict[str, ConjureFieldDefinition]:
        return {
            's3_path': ConjureFieldDefinition('s3Path', api_S3Path)
        }

    __slots__: List[str] = ['_s3_path']

    def __init__(self, s3_path: str) -> None:
        self._s3_path = s3_path

    @builtins.property
    def s3_path(self) -> str:
        return self._s3_path


timeseries_seriescache_api_S3Handle.__name__ = "S3Handle"
timeseries_seriescache_api_S3Handle.__qualname__ = "S3Handle"
timeseries_seriescache_api_S3Handle.__module__ = "nominal_api.timeseries_seriescache_api"


class upload_api_UploadService(Service):
    """The Upload Service manages file uploads to object storage.
    """

    def initiate_multipart_upload(self, auth_header: str, upload_request: "ingest_api_InitiateMultipartUploadRequest") -> "ingest_api_InitiateMultipartUploadResponse":
        """Initiates a multipart upload to object storage.
Returns an uploadId that should be used with listParts, signPart, and completeMultipartUpload.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = _conjure_encoder.default(upload_request)

        _path = '/upload/v1/multipart-upload'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_InitiateMultipartUploadResponse, self._return_none_for_unknown_union_types)

    def list_parts(self, auth_header: str, key: str, upload_id: str) -> List["ingest_api_PartWithSize"]:
        """Lists the parts that have been uploaded for a given uploadId.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': _conjure_encoder.default(key),
        }

        _path_params: Dict[str, str] = {
            'uploadId': quote(str(_conjure_encoder.default(upload_id)), safe=''),
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'GET',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), List[ingest_api_PartWithSize], self._return_none_for_unknown_union_types)

    def sign_part(self, auth_header: str, key: str, part_number: int, upload_id: str) -> "ingest_api_SignPartResponse":
        """Signs an upload request for a single part.
Returns a URL that will execute the upload without further authentication.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': _conjure_encoder.default(key),
            'partNumber': _conjure_encoder.default(part_number),
        }

        _path_params: Dict[str, str] = {
            'uploadId': quote(str(_conjure_encoder.default(upload_id)), safe=''),
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_SignPartResponse, self._return_none_for_unknown_union_types)

    def complete_multipart_upload(self, auth_header: str, key: str, upload_id: str, parts: List["ingest_api_Part"] = None) -> "ingest_api_CompleteMultipartUploadResponse":
        """Completes a multipart upload to object storage.
This should be called after all parts have been uploaded.
Will throw EmptyMultipartUpload if there are 0 parts.
        """
        parts = parts if parts is not None else []
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': _conjure_encoder.default(key),
        }

        _path_params: Dict[str, str] = {
            'uploadId': quote(str(_conjure_encoder.default(upload_id)), safe=''),
        }

        _json: Any = _conjure_encoder.default(parts)

        _path = '/upload/v1/multipart-upload/{uploadId}/complete'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), ingest_api_CompleteMultipartUploadResponse, self._return_none_for_unknown_union_types)

    def abort_multipart_upload(self, auth_header: str, key: str, upload_id: str) -> None:
        """Aborts a multipart upload to S3.
Frees storage used by previously uploaded parts and prevents further uploads to the same uploadId.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'key': _conjure_encoder.default(key),
        }

        _path_params: Dict[str, str] = {
            'uploadId': quote(str(_conjure_encoder.default(upload_id)), safe=''),
        }

        _json: Any = None

        _path = '/upload/v1/multipart-upload/{uploadId}/abort'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return

    def upload_file(self, auth_header: str, body: Any, file_name: str, size_bytes: Optional[int] = None, workspace: Optional[str] = None) -> str:
        """Uploads a file to S3. Intended for smaller files.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Content-Type': 'application/octet-stream',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
            'fileName': _conjure_encoder.default(file_name),
            'sizeBytes': _conjure_encoder.default(size_bytes),
            'workspace': _conjure_encoder.default(workspace),
        }

        _path_params: Dict[str, str] = {
        }

        _data: Any = body

        _path = '/upload/v1/upload-file'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'POST',
            self._uri + _path,
            params=_params,
            headers=_headers,
            data=_data)

        _decoder = ConjureDecoder()
        return _decoder.decode(_response.json(), api_S3Path, self._return_none_for_unknown_union_types)


upload_api_UploadService.__name__ = "UploadService"
upload_api_UploadService.__qualname__ = "UploadService"
upload_api_UploadService.__module__ = "nominal_api.upload_api"


class usercreation_api_InternalUserCreationService(Service):
    """Internal service responsible for handling creation of new users.
    """

    def ensure_database_user_exists(self, auth_header: str) -> None:
        """Ensures that the user corresponding to the auth header provided exists in the database.
Will do nothing if the user already exists.
        """
        _conjure_encoder = ConjureEncoder()

        _headers: Dict[str, Any] = {
            'Accept': 'application/json',
            'Authorization': auth_header,
        }

        _params: Dict[str, Any] = {
        }

        _path_params: Dict[str, str] = {
        }

        _json: Any = None

        _path = '/user-creation/v1/database'
        _path = _path.format(**_path_params)

        _response: Response = self._request(
            'PUT',
            self._uri + _path,
            params=_params,
            headers=_headers,
            json=_json)

        return


usercreation_api_InternalUserCreationService.__name__ = "InternalUserCreationService"
usercreation_api_InternalUserCreationService.__qualname__ = "InternalUserCreationService"
usercreation_api_InternalUserCreationService.__module__ = "nominal_api.usercreation_api"


api_ColumnName = str

api_Label = str

scout_datasource_connection_api_influx_OrgId = str

timeseries_metadata_api_SeriesMetadataName = str

api_PropertyValue = str

module_ParameterName = str

scout_workbookcommon_api_TimeRange = api_Range

timeseries_logicalseries_api_AttributeName = str

themes_api_ChartThemeRid = str

scout_rids_api_SnapshotRid = str

scout_units_api_UnitName = str

ingest_api_FileSuffix = str

scout_datasource_connection_api_TableName = str

timeseries_seriescache_api_Resolution = int

api_PropertyName = str

scout_integrations_api_IntegrationRid = str

scout_api_DataSourceRefName = str

api_rids_VideoFileRid = str

api_Unit = str

ingest_workflow_api_McapTopicName = str

scout_versioning_api_BranchRid = str

datasource_DatasetFileId = str

api_rids_AiConversationRid = str

api_rids_LinkRid = str

api_rids_WorkspaceRid = str

persistent_compute_api_SubscriptionId = str

api_McapChannelTopic = str

modules_api_ModuleApplicationRid = str

scout_compute_api_VariableName = str

scout_datasource_connection_api_MeasurementName = str

scout_compute_api_FunctionParameterName = str

scout_compute_api_LocalVariableName = str

scout_channelvariables_api_ChannelVariableName = str

scout_datareview_api_ManualCheckEvaluationRid = str

api_ids_WorkspaceId = str

scout_asset_api_Channel = str

scout_rids_api_FunctionRid = str

scout_units_api_UnitSystem = str

secrets_api_SecretRid = str

timeseries_logicalseries_api_ColumnName = str

scout_datasource_connection_api_LocationName = str

scout_layout_api_PanelId = str

api_rids_NominalDataSourceRid = str

scout_compute_api_ErrorCode = int

api_rids_ChunkRid = str

api_rids_ProcedureRid = str

scout_rids_api_CheckAlertRid = str

ingest_api_ContainerizedExtractorRid = str

scout_chart_api_JsonString = str

scout_chartdefinition_api_LogTagFilter = Dict[str, List[str]]

api_rids_LocalResourceRid = str

scout_checks_api_JobRid = str

api_rids_VideoRid = str

api_rids_AttachmentRid = str

datasource_pagination_api_PageToken = str

scout_datasource_connection_api_ProjectName = str

scout_rids_api_DataReviewRid = str

api_rids_SegmentRid = str

scout_comparisonnotebook_api_VariableName = str

scout_run_api_RunRid = str

scout_datasource_connection_api_DatasetName = str

api_TagValue = str

scout_rids_api_RunRefName = str

scout_versioning_api_TagName = str

scout_compute_api_SeriesName = str

timeseries_logicalseries_api_MeasureName = str

scout_run_api_LogSetRid = str

module_VariableName = str

scout_units_api_UnitProperty = str

timeseries_logicalseries_api_MeasurementName = str

api_rids_RemoteConnectionRid = str

datasource_VideoFileId = str

themes_api_HexColor = str

scout_datasource_connection_api_ColumnName = str

storage_writer_api_Field = str

api_TagName = str

authentication_api_UserRid = str

ingest_api_EnvironmentVariable = str

scout_datasource_connection_api_ConnectionRid = str

scout_channelvariables_api_ComputeSpecV1 = str

timeseries_logicalseries_api_TableName = str

scout_rids_api_NotebookRid = str

scout_rids_api_UserRid = str

api_rids_DatasetRid = str

scout_units_api_UnitSymbol = str

timeseries_logicalseries_api_LocationName = str

api_rids_DataSourceRid = str

scout_rids_api_CheckLineageRid = str

api_DataSourceRefName = str

scout_rids_api_VizId = str

scout_comparisonnotebook_api_ComparisonVizDefinitionMap = Dict[scout_rids_api_VizId, scout_comparisonnotebook_api_VizDefinition]

scout_video_api_ErrorType = str

scout_comparisonnotebook_api_ComparisonChannelVariableMap = Dict[scout_comparisonnotebook_api_VariableName, scout_comparisonnotebook_api_ChannelVariable]

ingest_workflow_api_PresignedUrl = str

timeseries_logicalseries_api_FieldName = str

scout_channelvariables_api_WorkbookChannelVariableMap = Dict[scout_channelvariables_api_ChannelVariableName, scout_channelvariables_api_ChannelVariable]

scout_rids_api_TypeRid = str

scout_compute_api_FunctionReference = str

api_rids_AutomaticCheckEvaluationRid = str

scout_rids_api_TemplateRid = str

timeseries_logicalseries_api_BucketName = str

api_SeriesMetadataRid = str

ingest_api_DataSourceRefName = str

api_ErrorType = str

api_rids_ProcedureExecutionRid = str

scout_compute_api_ComputeWithUnitsRequest = scout_compute_api_ComputeNodeRequest

scout_rids_api_GroupRid = str

scout_rids_api_Version = int

scout_versioning_api_BranchName = str

storage_writer_api_MeasurementName = str

storage_datasource_api_NominalDataSourceId = str

api_rids_EventRid = str

module_ModuleVersion = str

api_rids_RemoteResourceRid = str

persistent_compute_api_Milliseconds = int

ingest_api_IngestJobRid = str

scout_compute_api_ErrorType = str

scout_rids_api_SavedViewRid = str

scout_rids_api_FunctionLineageRid = str

timeseries_logicalseries_api_DatabaseName = str

modules_api_ModuleRid = str

timeseries_logicalseries_api_SchemaName = str

scout_rids_api_MarkingRid = str

scout_datasource_connection_api_BucketName = str

api_S3Path = str

api_rids_StreamingConnectionRid = str

comments_api_ReactionRid = str

scout_versioning_api_CommitId = str

api_rids_DataConnectorRid = str

scout_run_api_ConnectionRid = str

timeseries_logicalseries_api_DatasetName = str

api_rids_NominalDataSourceOrDatasetRid = str

scout_versioning_api_TagRid = str

scout_chartdefinition_api_AxisId = str

scout_datasource_connection_api_SchemaName = str

scout_savedviews_api_ColumnId = str

scout_api_HexColor = str

scout_datasource_connection_api_SecretRid = str

authorization_ApiKeyRid = str

scout_rids_api_ApiKeyRid = str

ingest_api_ChannelPrefix = OptionalTypeWrapper[str]

scout_chartdefinition_api_LogColumnName = str

scout_rids_api_AssetRid = str

comments_api_CommentRid = str

scout_chartdefinition_api_DataSourceRefName = str

api_LogicalSeriesRid = str

api_SeriesArchetypeRid = api_SeriesMetadataRid

authentication_api_OrgRid = str

scout_rids_api_ChecklistRid = str

scout_chartdefinition_api_WorkbookVizDefinitionMap = Dict[scout_rids_api_VizId, scout_chartdefinition_api_VizDefinition]

api_McapChannelId = int

api_rids_ConnectAppRid = str

scout_rids_api_CheckRid = str

scout_rids_api_AssetRefName = str

api_Token = str

timeseries_logicalseries_api_ProjectName = str

api_Channel = str

scout_datasource_connection_api_SecretName = str

