"""
Geek Cafe, LLC
MIT License.  See Project Root for the license information.

CommunityMember model for scalable community membership using single-table design.
"""

from boto3_assist.dynamodb.dynamodb_index import DynamoDBIndex, DynamoDBKey
import datetime as dt
from geek_cafe_saas_sdk.core.models.base_tenant_user_model import BaseTenantUserModel


class CommunityMember(BaseTenantUserModel):
    """
    CommunityMember model for scalable membership tracking.
    
    Single-table design pattern:
    - PK: community#<community_id>
    - SK: member#<user_id>
    - GSI1PK: user#<user_id> (for "what communities am I in?")
    - GSI1SK: community#<community_id>#<joined_utc_ts>
    
    Benefits:
    - Unlimited members per community
    - Fast membership checks (single GetItem)
    - Member metadata (role, status, join date)
    - Efficient pagination
    - Concurrent updates without contention
    """

    def __init__(self):
        super().__init__()
        # Note: Uses normal UUID id, but pk/sk create adjacent record pattern
        self._community_id: str | None = None
        self._user_id: str | None = None
        
        # Member metadata
        self._status: str = "active"  # active, pending, banned, left
        self._joined_utc_ts: float | None = None
        self._invited_by_id: str | None = None
        
        # Dues tracking
        self._dues_status: str = "current"  # current, overdue, exempt, pending
        self._last_payment_at: float | None = None
        self._next_payment_due: float | None = None
        
        # Activity tracking
        self._last_active_at: float | None = None
        self._event_attendance_count: int = 0
        
        # Setup DynamoDB indexes (adjacent record pattern)
        self._setup_indexes()
    
    def _setup_indexes(self):
        """Setup DynamoDB indexes for member queries."""
        
        # Primary index: Adjacent record pattern - members grouped by community
        # Query: pk="community#<id>" AND sk BEGINS_WITH "member#" to get all members
        primary: DynamoDBIndex = DynamoDBIndex()
        primary.name = "primary"
        primary.partition_key.attribute_name = "pk"
        primary.partition_key.value = lambda: DynamoDBKey.build_key(("community", self.community_id))
        primary.sort_key.attribute_name = "sk"
        primary.sort_key.value = lambda: DynamoDBKey.build_key(("member", self.user_id))
        self.indexes.add_primary(primary)
        
        # GSI1: User's communities - query communities by user
        gsi: DynamoDBIndex = DynamoDBIndex()
        gsi.name = "gsi1"
        gsi.partition_key.attribute_name = f"{gsi.name}_pk"
        gsi.partition_key.value = lambda: DynamoDBKey.build_key(("user", self.user_id))
        gsi.sort_key.attribute_name = f"{gsi.name}_sk"
        gsi.sort_key.value = lambda: DynamoDBKey.build_key(("community", self.community_id), ("ts", self.joined_utc_ts))
        self.indexes.add_secondary(gsi)
        
        # GSI2: Members by status - query members by status within community
        gsi: DynamoDBIndex = DynamoDBIndex()
        gsi.name = "gsi2"
        gsi.partition_key.attribute_name = f"{gsi.name}_pk"
        gsi.partition_key.value = lambda: DynamoDBKey.build_key(("community", self.community_id), ("status", self.status))
        gsi.sort_key.attribute_name = f"{gsi.name}_sk"
        gsi.sort_key.value = lambda: DynamoDBKey.build_key(("member", self.user_id))
        self.indexes.add_secondary(gsi)
        
        # GSI3: Members by dues status - query members with overdue dues
        gsi: DynamoDBIndex = DynamoDBIndex()
        gsi.name = "gsi3"
        gsi.partition_key.attribute_name = f"{gsi.name}_pk"
        gsi.partition_key.value = lambda: DynamoDBKey.build_key(("community", self.community_id), ("dues", self.dues_status))
        gsi.sort_key.attribute_name = f"{gsi.name}_sk"
        gsi.sort_key.value = lambda: DynamoDBKey.build_key(("due_date", self.next_payment_due or 0))
        self.indexes.add_secondary(gsi)

    @property
    def model_version(self) -> str:
        return "1.0"

    def prep_for_save(self, preserve_timestamps: bool = False):
        """
        Prepare member record for save.
        
        Note: CommunityMember uses adjacent record pattern where:
        - Normal UUID id (generated by parent)
        - pk = "community#<community_id>" (groups by community)
        - sk = "member#<user_id>" (enables begins_with queries)
        """
        # Validate required fields for adjacent record pattern
        if not self.community_id:
            raise ValueError("community_id is required for CommunityMember")
        if not self.user_id:
            raise ValueError("user_id is required for CommunityMember")
        
        # Set joined_utc_ts if not already set
        if not self.joined_utc_ts:
            self.joined_utc_ts = dt.datetime.now(dt.UTC).timestamp()
        
        # Call parent to generate normal UUID id and set timestamps
        super().prep_for_save(preserve_timestamps=preserve_timestamps)

    # Properties
    @property
    def community_id(self) -> str:
        return self._community_id

    @community_id.setter
    def community_id(self, value: str | None):
        self._community_id = value

    @property
    def user_id(self) -> str:
        return self._user_id

    @user_id.setter
    def user_id(self, value: str | None):
        self._user_id = value

    @property
    def status(self) -> str:
        return self._status

    @status.setter
    def status(self, value: str | None):
        valid_statuses = ["active", "pending", "banned", "left"]
        self._status = value if value in valid_statuses else "active"

    @property
    def joined_utc_ts(self) -> float:
        return self._joined_utc_ts

    @joined_utc_ts.setter
    def joined_utc_ts(self, value: float | None):
        self._joined_utc_ts = value

    @property
    def invited_by_id(self) -> str:
        return self._invited_by_id

    @invited_by_id.setter
    def invited_by_id(self, value: str | None):
        self._invited_by_id = value

    @property
    def dues_status(self) -> str:
        return self._dues_status

    @dues_status.setter
    def dues_status(self, value: str | None):
        valid_statuses = ["current", "overdue", "exempt", "pending"]
        self._dues_status = value if value in valid_statuses else "current"

    @property
    def last_payment_at(self) -> float:
        return self._last_payment_at

    @last_payment_at.setter
    def last_payment_at(self, value: float | None):
        self._last_payment_at = value

    @property
    def next_payment_due(self) -> float:
        return self._next_payment_due

    @next_payment_due.setter
    def next_payment_due(self, value: float | None):
        self._next_payment_due = value

    @property
    def last_active_at(self) -> float:
        return self._last_active_at

    @last_active_at.setter
    def last_active_at(self, value: float | None):
        self._last_active_at = value

    @property
    def event_attendance_count(self) -> int:
        return self._event_attendance_count

    @event_attendance_count.setter
    def event_attendance_count(self, value: int | None):
        self._event_attendance_count = value if isinstance(value, int) and value >= 0 else 0

    # Helper methods
    def is_active(self) -> bool:
        """Check if member is active."""
        return self.status == "active"

    def is_pending(self) -> bool:
        """Check if membership is pending approval."""
        return self.status == "pending"

    def is_banned(self) -> bool:
        """Check if member is banned."""
        return self.status == "banned"

    def has_left(self) -> bool:
        """Check if member has left the community."""
        return self.status == "left"

    def is_dues_current(self) -> bool:
        """Check if member's dues are current."""
        return self.dues_status == "current" or self.dues_status == "exempt"

    def is_dues_overdue(self) -> bool:
        """Check if member's dues are overdue."""
        return self.dues_status == "overdue"
