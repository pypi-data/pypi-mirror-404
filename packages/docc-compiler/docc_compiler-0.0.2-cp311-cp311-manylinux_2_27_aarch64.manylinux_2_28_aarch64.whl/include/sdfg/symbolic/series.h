/**
 * @file series.h
 * @brief Analysis of symbolic series and sequences
 *
 * This file provides functions for analyzing symbolic series.
 *
 * ## Series Analysis
 *
 * In some scenarios, it is useful to analyze the evolution of symbolic
 * expressions as a series rather than a function. Example:
 * - Induction variable `i` evolving as `i' = 2 * i` generates the series init, 2 * i_0, 4 * i_0, 8 * i_0, ...
 *   rather than the closed-form function `f(i) = 2^i * i_0`.
 *
 * ## Example Usage
 *
 * @see maps.h for related map analysis functions
 * @see assumptions.h for symbol assumptions and evolution maps
 */

#pragma once

#include "sdfg/symbolic/assumptions.h"
#include "sdfg/symbolic/symbolic.h"

namespace sdfg {
namespace symbolic {
namespace series {

/**
 * @brief Extracts affine coefficients from a series
 * @param expr Expression to analyze (should be affine in sym)
 * @param sym Symbol to analyze with respect to
 * @param assums Assumptions about symbols
 * @return Pair of (is_affine, (stride, offset)) where is_affine indicates success
 *
 * Attempts to extract the affine coefficient of a series.
 *
 * @code
 * auto [is_affine, coeffs] = affine_int_coeffs(expr, i, assums);
 * if (is_affine) {
 *     auto [stride, offset] = coeffs;
 *     // Use stride and offset for optimization
 * }
 * @endcode
 */
std::pair<bool, std::pair<Integer, Integer>>
affine_int_coeffs(const Expression expr, const Symbol sym, const Assumptions& assums);

/**
 * @brief Checks if an expression is monotonic as a symbol evolves
 * @param expr Expression to check
 * @param sym Symbol that evolves
 * @param assums Assumptions including evolution map for sym
 * @return true if expr is monotonically increasing or decreasing as sym evolves
 *
 * Determines if the expression consistently increases or decreases as the symbol
 * evolves according to its map.
 *
 * @code
 * // Check if 2*i is monotonic when i goes 0, 1, 2, ...
 * bool mono = is_monotonic(expr, i, assums);  // true
 * @endcode
 */
bool is_monotonic(const Expression expr, const Symbol sym, const Assumptions& assums);

/**
 * @brief Checks if an expression generates contiguous values
 * @param expr Expression to check
 * @param sym Symbol that evolves
 * @param assums Assumptions including evolution map for sym
 * @return true if expr generates consecutive integer values as sym evolves
 *
 * Determines if the series of values generated by the expression are contiguous
 *
 */
bool is_contiguous(const Expression expr, const Symbol sym, const Assumptions& assums);

} // namespace series
} // namespace symbolic
} // namespace sdfg
