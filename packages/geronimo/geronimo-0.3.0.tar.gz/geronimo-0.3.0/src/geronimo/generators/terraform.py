"""Terraform generator for Geronimo.

Generates modular Terraform configuration for AWS ECS deployments.
"""

from pathlib import Path

from geronimo.config.schema import GeronimoConfig
from geronimo.generators.base import BaseGenerator


class TerraformGenerator(BaseGenerator):
    """Generates Terraform infrastructure files for AWS ECS deployments."""

    TEMPLATE_DIR = "terraform"

    def __init__(
        self,
        config: GeronimoConfig,
        output_dir: str = "infrastructure",
    ) -> None:
        """Initialize the Terraform generator.

        Args:
            config: Geronimo configuration.
            output_dir: Directory to write Terraform files.
        """
        super().__init__()
        self.config = config
        self.output_dir = Path(output_dir)

    def generate(self) -> list[str]:
        """Generate all Terraform files.

        Returns:
            List of generated file paths.
        """
        self.output_dir.mkdir(parents=True, exist_ok=True)

        files = []

        # Generate each Terraform file
        files.append(self._generate_main())
        files.append(self._generate_variables())
        files.append(self._generate_ecr())
        files.append(self._generate_ecs())
        files.append(self._generate_alb())
        files.append(self._generate_cloudwatch())
        files.append(self._generate_iam())
        files.append(self._generate_outputs())

        return files

    def _generate_main(self) -> str:
        """Generate main.tf with provider configuration."""
        content = '''# Terraform configuration for {project_name}
# Generated by Geronimo

terraform {{
  required_version = ">= 1.5.0"

  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }}
  }}

  # Backend configuration - customize for your environment
  # backend "s3" {{
  #   bucket         = "your-terraform-state-bucket"
  #   key            = "{project_name}/terraform.tfstate"
  #   region         = "us-east-1"
  #   encrypt        = true
  #   dynamodb_table = "terraform-locks"
  # }}
}}

provider "aws" {{
  region = var.aws_region

  default_tags {{
    tags = {{
      Project     = "{project_name}"
      Environment = var.environment
      ManagedBy   = "terraform"
      Generator   = "geronimo"
    }}
  }}
}}

# Data sources for VPC networking
data "aws_vpc" "main" {{
  id = var.vpc_id
}}

data "aws_subnets" "private" {{
  filter {{
    name   = "vpc-id"
    values = [var.vpc_id]
  }}

  tags = {{
    Type = "private"
  }}
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "main.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_variables(self) -> str:
        """Generate variables.tf."""
        content = '''# Input variables for {project_name}
# Generated by Geronimo

variable "aws_region" {{
  description = "AWS region for deployment"
  type        = string
  default     = "us-east-1"
}}

variable "environment" {{
  description = "Deployment environment (dev, staging, prod)"
  type        = string
  default     = "dev"
}}

variable "vpc_id" {{
  description = "VPC ID for deployment"
  type        = string
}}

variable "private_subnets" {{
  description = "List of private subnet IDs"
  type        = list(string)
  default     = []
}}

variable "public_subnets" {{
  description = "List of public subnet IDs for ALB"
  type        = list(string)
  default     = []
}}

# Container configuration
variable "container_cpu" {{
  description = "CPU units for the container (256, 512, 1024, 2048, 4096)"
  type        = number
  default     = {cpu}
}}

variable "container_memory" {{
  description = "Memory for the container in MB"
  type        = number
  default     = {memory}
}}

variable "container_port" {{
  description = "Port the container listens on"
  type        = number
  default     = 8000
}}

# Scaling configuration
variable "min_capacity" {{
  description = "Minimum number of tasks"
  type        = number
  default     = {min_instances}
}}

variable "max_capacity" {{
  description = "Maximum number of tasks"
  type        = number
  default     = {max_instances}
}}

variable "target_cpu_percent" {{
  description = "Target CPU utilization for auto-scaling"
  type        = number
  default     = {target_cpu}
}}

# Image configuration
variable "image_tag" {{
  description = "Docker image tag to deploy"
  type        = string
  default     = "latest"
}}
'''.format(
            project_name=self.config.project.name,
            cpu=self.config.infrastructure.cpu,
            memory=self.config.infrastructure.memory,
            min_instances=self.config.infrastructure.scaling.min_instances,
            max_instances=self.config.infrastructure.scaling.max_instances,
            target_cpu=self.config.infrastructure.scaling.target_cpu_percent,
        )

        path = self.output_dir / "variables.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_ecr(self) -> str:
        """Generate ecr.tf for container registry."""
        content = '''# ECR Repository for {project_name}
# Generated by Geronimo

resource "aws_ecr_repository" "main" {{
  name                 = "{project_name}"
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {{
    scan_on_push = true
  }}

  encryption_configuration {{
    encryption_type = "AES256"
  }}
}}

# Lifecycle policy to clean up old images
resource "aws_ecr_lifecycle_policy" "main" {{
  repository = aws_ecr_repository.main.name

  policy = jsonencode({{
    rules = [
      {{
        rulePriority = 1
        description  = "Keep last 10 images"
        selection = {{
          tagStatus     = "any"
          countType     = "imageCountMoreThan"
          countNumber   = 10
        }}
        action = {{
          type = "expire"
        }}
      }}
    ]
  }})
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "ecr.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_ecs(self) -> str:
        """Generate ecs.tf for Fargate deployment."""
        content = '''# ECS Cluster and Service for {project_name}
# Generated by Geronimo

# ECS Cluster
resource "aws_ecs_cluster" "main" {{
  name = "{project_name}-${{var.environment}}"

  setting {{
    name  = "containerInsights"
    value = "enabled"
  }}
}}

resource "aws_ecs_cluster_capacity_providers" "main" {{
  cluster_name = aws_ecs_cluster.main.name

  capacity_providers = ["FARGATE", "FARGATE_SPOT"]

  default_capacity_provider_strategy {{
    base              = 1
    weight            = 100
    capacity_provider = "FARGATE"
  }}
}}

# Task Definition
resource "aws_ecs_task_definition" "main" {{
  family                   = "{project_name}"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.container_cpu
  memory                   = var.container_memory
  execution_role_arn       = aws_iam_role.ecs_execution.arn
  task_role_arn            = aws_iam_role.ecs_task.arn

  container_definitions = jsonencode([
    {{
      name  = "{project_name}"
      image = "${{aws_ecr_repository.main.repository_url}}:${{var.image_tag}}"

      portMappings = [
        {{
          containerPort = var.container_port
          hostPort      = var.container_port
          protocol      = "tcp"
        }}
      ]

      environment = [
        {{
          name  = "ENVIRONMENT"
          value = var.environment
        }}
      ]

      logConfiguration = {{
        logDriver = "awslogs"
        options = {{
          "awslogs-group"         = aws_cloudwatch_log_group.main.name
          "awslogs-region"        = var.aws_region
          "awslogs-stream-prefix" = "ecs"
        }}
      }}

      healthCheck = {{
        command     = ["CMD-SHELL", "curl -f http://localhost:${{var.container_port}}/health || exit 1"]
        interval    = 30
        timeout     = 5
        retries     = 3
        startPeriod = 60
      }}

      essential = true
    }}
  ])
}}

# ECS Service
resource "aws_ecs_service" "main" {{
  name            = "{project_name}"
  cluster         = aws_ecs_cluster.main.id
  task_definition = aws_ecs_task_definition.main.arn
  desired_count   = var.min_capacity
  launch_type     = "FARGATE"

  network_configuration {{
    subnets          = var.private_subnets
    security_groups  = [aws_security_group.ecs_tasks.id]
    assign_public_ip = false
  }}

  load_balancer {{
    target_group_arn = aws_lb_target_group.main.arn
    container_name   = "{project_name}"
    container_port   = var.container_port
  }}

  health_check_grace_period_seconds = 60

  deployment_circuit_breaker {{
    enable   = true
    rollback = true
  }}

  lifecycle {{
    ignore_changes = [desired_count]
  }}

  depends_on = [aws_lb_listener.http]
}}

# Security Group for ECS Tasks
resource "aws_security_group" "ecs_tasks" {{
  name        = "{project_name}-ecs-tasks"
  description = "Security group for ECS tasks"
  vpc_id      = var.vpc_id

  ingress {{
    protocol        = "tcp"
    from_port       = var.container_port
    to_port         = var.container_port
    security_groups = [aws_security_group.alb.id]
  }}

  egress {{
    protocol    = "-1"
    from_port   = 0
    to_port     = 0
    cidr_blocks = ["0.0.0.0/0"]
  }}
}}

# Auto Scaling
resource "aws_appautoscaling_target" "ecs" {{
  max_capacity       = var.max_capacity
  min_capacity       = var.min_capacity
  resource_id        = "service/${{aws_ecs_cluster.main.name}}/${{aws_ecs_service.main.name}}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}}

resource "aws_appautoscaling_policy" "ecs_cpu" {{
  name               = "{project_name}-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace

  target_tracking_scaling_policy_configuration {{
    predefined_metric_specification {{
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }}
    target_value = var.target_cpu_percent
  }}
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "ecs.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_alb(self) -> str:
        """Generate alb.tf for Application Load Balancer."""
        content = '''# Application Load Balancer for {project_name}
# Generated by Geronimo

resource "aws_lb" "main" {{
  name               = "{project_name}-${{var.environment}}"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.public_subnets

  enable_deletion_protection = var.environment == "prod" ? true : false
}}

resource "aws_lb_target_group" "main" {{
  name        = "{project_name}-${{var.environment}}"
  port        = var.container_port
  protocol    = "HTTP"
  vpc_id      = var.vpc_id
  target_type = "ip"

  health_check {{
    enabled             = true
    healthy_threshold   = 2
    interval            = 30
    matcher             = "200"
    path                = "/health"
    port                = "traffic-port"
    protocol            = "HTTP"
    timeout             = 5
    unhealthy_threshold = 3
  }}

  deregistration_delay = 30
}}

resource "aws_lb_listener" "http" {{
  load_balancer_arn = aws_lb.main.arn
  port              = "80"
  protocol          = "HTTP"

  default_action {{
    type             = "forward"
    target_group_arn = aws_lb_target_group.main.arn
  }}
}}

# Security Group for ALB
resource "aws_security_group" "alb" {{
  name        = "{project_name}-alb"
  description = "Security group for ALB"
  vpc_id      = var.vpc_id

  ingress {{
    protocol    = "tcp"
    from_port   = 80
    to_port     = 80
    cidr_blocks = ["0.0.0.0/0"]
  }}

  ingress {{
    protocol    = "tcp"
    from_port   = 443
    to_port     = 443
    cidr_blocks = ["0.0.0.0/0"]
  }}

  egress {{
    protocol    = "-1"
    from_port   = 0
    to_port     = 0
    cidr_blocks = ["0.0.0.0/0"]
  }}
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "alb.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_cloudwatch(self) -> str:
        """Generate cloudwatch.tf for logging and monitoring."""
        content = '''# CloudWatch configuration for {project_name}
# Generated by Geronimo

# Log Group
resource "aws_cloudwatch_log_group" "main" {{
  name              = "/ecs/{project_name}"
  retention_in_days = 30
}}

# CloudWatch Dashboard
resource "aws_cloudwatch_dashboard" "main" {{
  dashboard_name = "{project_name}-${{var.environment}}"

  dashboard_body = jsonencode({{
    widgets = [
      {{
        type   = "metric"
        x      = 0
        y      = 0
        width  = 12
        height = 6
        properties = {{
          title  = "Request Count"
          region = var.aws_region
          metrics = [
            ["AWS/ApplicationELB", "RequestCount", "LoadBalancer", aws_lb.main.arn_suffix]
          ]
          period = 60
          stat   = "Sum"
        }}
      }},
      {{
        type   = "metric"
        x      = 12
        y      = 0
        width  = 12
        height = 6
        properties = {{
          title  = "Target Response Time"
          region = var.aws_region
          metrics = [
            ["AWS/ApplicationELB", "TargetResponseTime", "LoadBalancer", aws_lb.main.arn_suffix, {{ stat = "p50", label = "P50" }}],
            ["AWS/ApplicationELB", "TargetResponseTime", "LoadBalancer", aws_lb.main.arn_suffix, {{ stat = "p99", label = "P99" }}]
          ]
          period = 60
        }}
      }},
      {{
        type   = "metric"
        x      = 0
        y      = 6
        width  = 12
        height = 6
        properties = {{
          title  = "HTTP Response Codes"
          region = var.aws_region
          metrics = [
            ["AWS/ApplicationELB", "HTTPCode_Target_2XX_Count", "LoadBalancer", aws_lb.main.arn_suffix, {{ label = "2XX" }}],
            ["AWS/ApplicationELB", "HTTPCode_Target_4XX_Count", "LoadBalancer", aws_lb.main.arn_suffix, {{ label = "4XX" }}],
            ["AWS/ApplicationELB", "HTTPCode_Target_5XX_Count", "LoadBalancer", aws_lb.main.arn_suffix, {{ label = "5XX" }}]
          ]
          period = 60
          stat   = "Sum"
        }}
      }},
      {{
        type   = "metric"
        x      = 12
        y      = 6
        width  = 12
        height = 6
        properties = {{
          title  = "ECS CPU & Memory"
          region = var.aws_region
          metrics = [
            ["AWS/ECS", "CPUUtilization", "ClusterName", aws_ecs_cluster.main.name, "ServiceName", aws_ecs_service.main.name],
            ["AWS/ECS", "MemoryUtilization", "ClusterName", aws_ecs_cluster.main.name, "ServiceName", aws_ecs_service.main.name]
          ]
          period = 60
          stat   = "Average"
        }}
      }}
    ]
  }})
}}

# Alarms
resource "aws_cloudwatch_metric_alarm" "high_error_rate" {{
  alarm_name          = "{project_name}-high-error-rate"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "HTTPCode_Target_5XX_Count"
  namespace           = "AWS/ApplicationELB"
  period              = 60
  statistic           = "Sum"
  threshold           = 10
  alarm_description   = "High 5XX error rate detected"
  treat_missing_data  = "notBreaching"

  dimensions = {{
    LoadBalancer = aws_lb.main.arn_suffix
  }}
}}

resource "aws_cloudwatch_metric_alarm" "high_latency" {{
  alarm_name          = "{project_name}-high-latency"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "TargetResponseTime"
  namespace           = "AWS/ApplicationELB"
  period              = 60
  extended_statistic  = "p99"
  threshold           = 0.5  # 500ms
  alarm_description   = "High P99 latency detected"
  treat_missing_data  = "notBreaching"

  dimensions = {{
    LoadBalancer = aws_lb.main.arn_suffix
  }}
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "cloudwatch.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_iam(self) -> str:
        """Generate iam.tf for IAM roles and policies."""
        content = '''# IAM configuration for {project_name}
# Generated by Geronimo

# ECS Execution Role (for pulling images, writing logs)
resource "aws_iam_role" "ecs_execution" {{
  name = "{project_name}-ecs-execution"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "ecs-tasks.amazonaws.com"
        }}
      }}
    ]
  }})
}}

resource "aws_iam_role_policy_attachment" "ecs_execution" {{
  role       = aws_iam_role.ecs_execution.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}}

# ECS Task Role (for application permissions)
resource "aws_iam_role" "ecs_task" {{
  name = "{project_name}-ecs-task"

  assume_role_policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {{
          Service = "ecs-tasks.amazonaws.com"
        }}
      }}
    ]
  }})
}}

# Add custom permissions for your ML model here
# For example, access to S3 for model artifacts:
resource "aws_iam_role_policy" "ecs_task_custom" {{
  name = "{project_name}-task-policy"
  role = aws_iam_role.ecs_task.id

  policy = jsonencode({{
    Version = "2012-10-17"
    Statement = [
      {{
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:ListBucket"
        ]
        Resource = [
          "arn:aws:s3:::your-model-bucket/*",
          "arn:aws:s3:::your-model-bucket"
        ]
      }},
      {{
        Effect = "Allow"
        Action = [
          "cloudwatch:PutMetricData"
        ]
        Resource = "*"
      }}
    ]
  }})
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "iam.tf"
        self.write_file(path, content)
        return str(path)

    def _generate_outputs(self) -> str:
        """Generate outputs.tf."""
        content = '''# Outputs for {project_name}
# Generated by Geronimo

output "ecr_repository_url" {{
  description = "ECR repository URL"
  value       = aws_ecr_repository.main.repository_url
}}

output "ecs_cluster_name" {{
  description = "ECS cluster name"
  value       = aws_ecs_cluster.main.name
}}

output "ecs_service_name" {{
  description = "ECS service name"
  value       = aws_ecs_service.main.name
}}

output "alb_dns_name" {{
  description = "ALB DNS name"
  value       = aws_lb.main.dns_name
}}

output "api_endpoint" {{
  description = "API endpoint URL"
  value       = "http://${{aws_lb.main.dns_name}}"
}}

output "cloudwatch_dashboard_url" {{
  description = "CloudWatch dashboard URL"
  value       = "https://${{var.aws_region}}.console.aws.amazon.com/cloudwatch/home?region=${{var.aws_region}}#dashboards:name={project_name}-${{var.environment}}"
}}
'''.format(project_name=self.config.project.name)

        path = self.output_dir / "outputs.tf"
        self.write_file(path, content)
        return str(path)
