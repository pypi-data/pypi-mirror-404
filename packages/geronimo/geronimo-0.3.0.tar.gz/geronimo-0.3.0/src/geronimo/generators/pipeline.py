"""Pipeline generator for Geronimo.

Generates Azure DevOps pipeline YAML for CI/CD.
"""

from pathlib import Path

from geronimo.config.schema import GeronimoConfig
from geronimo.generators.base import BaseGenerator


class PipelineGenerator(BaseGenerator):
    """Generates Azure DevOps pipeline configuration."""

    TEMPLATE_DIR = "pipeline"

    def __init__(
        self,
        config: GeronimoConfig,
        output_path: str = "azure-pipelines.yaml",
    ) -> None:
        """Initialize the pipeline generator.

        Args:
            config: Geronimo configuration.
            output_path: Path to write the pipeline file.
        """
        super().__init__()
        self.config = config
        self.output_path = Path(output_path)

    def generate(self) -> str:
        """Generate the Azure DevOps pipeline.

        Returns:
            Path to the generated pipeline file.
        """
        project_name = self.config.project.name
        environments = self.config.deployment.environments

        # Build environment-specific deploy stages
        deploy_stages = []
        for env in environments:
            stage = self._generate_deploy_stage(env.name, env.approval_required)
            deploy_stages.append(stage)

        content = f'''# Azure DevOps Pipeline for {project_name}
# Generated by Geronimo

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    exclude:
      - '*.md'
      - 'docs/**'

pr:
  branches:
    include:
      - main
      - develop

variables:
  - name: projectName
    value: '{project_name}'
  - name: pythonVersion
    value: '{self.config.runtime.python_version}'
  - name: AWS_REGION
    value: 'us-east-1'

stages:
  # ============================================================================
  # Build & Test Stage
  # ============================================================================
  - stage: Build
    displayName: 'Build & Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build and Test'
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: UsePythonVersion@0
            displayName: 'Set up Python'
            inputs:
              versionSpec: '$(pythonVersion)'

          - script: |
              curl -LsSf https://astral.sh/uv/install.sh | sh
              echo "##vso[task.prependpath]$HOME/.local/bin"
            displayName: 'Install uv'

          - script: |
              uv sync
            displayName: 'Install dependencies'

          - script: |
              uv run pytest tests/ -v --junitxml=test-results.xml --cov=src --cov-report=xml
            displayName: 'Run tests'

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: 'test-results.xml'
            condition: always()

          - task: PublishCodeCoverageResults@1
            displayName: 'Publish coverage'
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: 'coverage.xml'
            condition: always()

  # ============================================================================
  # Security Scan Stage
  # ============================================================================
  - stage: Security
    displayName: 'Security Scan'
    dependsOn: Build
    jobs:
      - job: SecurityScan
        displayName: 'Security Scanning'
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: UsePythonVersion@0
            inputs:
              versionSpec: '$(pythonVersion)'

          - script: |
              pip install safety bandit
            displayName: 'Install security tools'

          - script: |
              safety check --file pyproject.toml || true
            displayName: 'Check dependency vulnerabilities'

          - script: |
              bandit -r src/ -f json -o bandit-report.json || true
            displayName: 'Run static security analysis'

          - task: PublishBuildArtifacts@1
            displayName: 'Publish security reports'
            inputs:
              pathToPublish: 'bandit-report.json'
              artifactName: 'security-reports'
            condition: always()

  # ============================================================================
  # Docker Build Stage
  # ============================================================================
  - stage: Docker
    displayName: 'Build Docker Image'
    dependsOn: Security
    jobs:
      - job: DockerBuild
        displayName: 'Build and Push Image'
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: AWSShellScript@1
            displayName: 'Login to ECR'
            inputs:
              awsCredentials: 'AWS-Connection'
              regionName: '$(AWS_REGION)'
              scriptType: 'inline'
              inlineScript: |
                aws ecr get-login-password --region $(AWS_REGION) | \\
                  podman login --username AWS --password-stdin \\
                  $(aws sts get-caller-identity --query Account --output text).dkr.ecr.$(AWS_REGION).amazonaws.com

          - script: |
              IMAGE_TAG=$(Build.BuildNumber)
              ECR_REPO=$(projectName)

              podman build -t $ECR_REPO:$IMAGE_TAG -t $ECR_REPO:latest .

              echo "##vso[task.setvariable variable=imageTag;isOutput=true]$IMAGE_TAG"
            displayName: 'Build Docker image'
            name: dockerBuild

          - task: AWSShellScript@1
            displayName: 'Push to ECR'
            inputs:
              awsCredentials: 'AWS-Connection'
              regionName: '$(AWS_REGION)'
              scriptType: 'inline'
              inlineScript: |
                ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
                ECR_URI=$ACCOUNT_ID.dkr.ecr.$(AWS_REGION).amazonaws.com

                podman push $(projectName):$(Build.BuildNumber) $ECR_URI/$(projectName):$(Build.BuildNumber)
                podman push $(projectName):latest $ECR_URI/$(projectName):latest

{chr(10).join(deploy_stages)}
'''

        self.write_file(self.output_path, content)
        return str(self.output_path)

    def _generate_deploy_stage(self, environment: str, approval_required: bool) -> str:
        """Generate a deployment stage for an environment."""
        env_upper = environment.upper()
        env_title = environment.title()

        approval_block = ""
        if approval_required:
            approval_block = f'''
        environment: '{self.config.project.name}-{environment}'  # Requires approval in ADO'''

        depends_on = "Docker" if environment == "dev" else self.config.deployment.environments[0].name.title()

        return f'''
  # ============================================================================
  # Deploy to {env_title}
  # ============================================================================
  - stage: Deploy{env_title}
    displayName: 'Deploy to {env_title}'
    dependsOn: {depends_on}
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: Deploy{env_title}
        displayName: 'Deploy to {env_title}'
        pool:
          vmImage: 'ubuntu-latest'{approval_block}
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AWSShellScript@1
                  displayName: 'Update ECS Service'
                  inputs:
                    awsCredentials: 'AWS-Connection-{env_upper}'
                    regionName: '$(AWS_REGION)'
                    scriptType: 'inline'
                    inlineScript: |
                      aws ecs update-service \\
                        --cluster $(projectName)-{environment} \\
                        --service $(projectName) \\
                        --force-new-deployment

                - task: AWSShellScript@1
                  displayName: 'Wait for deployment'
                  inputs:
                    awsCredentials: 'AWS-Connection-{env_upper}'
                    regionName: '$(AWS_REGION)'
                    scriptType: 'inline'
                    inlineScript: |
                      aws ecs wait services-stable \\
                        --cluster $(projectName)-{environment} \\
                        --services $(projectName)

                - script: |
                    echo "Deployment to {environment} completed successfully"
                  displayName: 'Deployment complete' '''
