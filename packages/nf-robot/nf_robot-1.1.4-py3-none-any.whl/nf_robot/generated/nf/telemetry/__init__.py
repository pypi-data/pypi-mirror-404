# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: telemetry.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "AnchorPoses",
    "CommandedVelocity",
    "ComponentConnStatus",
    "ConnStatus",
    "GantrySightings",
    "GripCamPredictions",
    "GripperModel",
    "GripperSensors",
    "NamedObjectPosition",
    "OneTarget",
    "Popup",
    "PositionEstimate",
    "PositionFactors",
    "TargetList",
    "TargetStatus",
    "TelemetryBatchUpdate",
    "TelemetryItem",
    "UplinkStatus",
    "VidStats",
    "VideoReady",
)

from dataclasses import dataclass

import betterproto2

from ...message_pool import default_message_pool

_COMPILER_VERSION = "0.9.0"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class ConnStatus(betterproto2.Enum):
    NOT_DETECTED = 0

    CONNECTING = 1

    CONNECTED = 2

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "CONNSTATUS_NOT_DETECTED",
            1: "CONNSTATUS_CONNECTING",
            2: "CONNSTATUS_CONNECTED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "CONNSTATUS_NOT_DETECTED": 0,
            "CONNSTATUS_CONNECTING": 1,
            "CONNSTATUS_CONNECTED": 2,
        }


class GripperModel(betterproto2.Enum):
    PILOT = 0

    ARPEGGIO = 1

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "GRIPPERMODEL_PILOT",
            1: "GRIPPERMODEL_ARPEGGIO",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "GRIPPERMODEL_PILOT": 0,
            "GRIPPERMODEL_ARPEGGIO": 1,
        }


class TargetStatus(betterproto2.Enum):
    SEEN = 0

    SELECTED = 1

    PICKED_UP = 2

    DROPPED = 3

    @classmethod
    def betterproto_value_to_renamed_proto_names(cls) -> dict[int, str]:
        return {
            0: "TARGETSTATUS_SEEN",
            1: "TARGETSTATUS_SELECTED",
            2: "TARGETSTATUS_PICKED_UP",
            3: "TARGETSTATUS_DROPPED",
        }

    @classmethod
    def betterproto_renamed_proto_names_to_value(cls) -> dict[str, int]:
        return {
            "TARGETSTATUS_SEEN": 0,
            "TARGETSTATUS_SELECTED": 1,
            "TARGETSTATUS_PICKED_UP": 2,
            "TARGETSTATUS_DROPPED": 3,
        }


@dataclass(eq=False, repr=False)
class AnchorPoses(betterproto2.Message):
    """
    Send by the observer to UIs when calibration or config file reading has set the anchor poses
    """

    poses: "list[_common__.Pose]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    always send all four poses in order of anchor num
    """


default_message_pool.register_message("nf.telemetry", "AnchorPoses", AnchorPoses)


@dataclass(eq=False, repr=False)
class CommandedVelocity(betterproto2.Message):
    """
    When the gantry has been commanded to move with a velocity eitehr by AI or human, it gives this velocity to the UI for visualization.
    """

    velocity: "_common__.Vec3 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "nf.telemetry", "CommandedVelocity", CommandedVelocity
)


@dataclass(eq=False, repr=False)
class ComponentConnStatus(betterproto2.Message):
    """
    Update about the status of the connection between observer and a robot component such as an anchor or gripper
    """

    is_gripper: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)

    anchor_num: "int" = betterproto2.field(2, betterproto2.TYPE_UINT32)
    """
    will be set only for anchors
    """

    websocket_status: "ConnStatus" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, default_factory=lambda: ConnStatus(0)
    )

    video_status: "ConnStatus" = betterproto2.field(
        4, betterproto2.TYPE_ENUM, default_factory=lambda: ConnStatus(0)
    )

    ip_address: "str" = betterproto2.field(5, betterproto2.TYPE_STRING)
    """
    On the wifi network in the house where the robot is.
    """

    gripper_model: "GripperModel | None" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, optional=True
    )


default_message_pool.register_message(
    "nf.telemetry", "ComponentConnStatus", ComponentConnStatus
)


@dataclass(eq=False, repr=False)
class GantrySightings(betterproto2.Message):
    """
    Individual sightings of the gantry by apriltag
    """

    sightings: "list[_common__.Vec3]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "nf.telemetry", "GantrySightings", GantrySightings
)


@dataclass(eq=False, repr=False)
class GripCamPredictions(betterproto2.Message):
    """
    values predicted by model using the gripper camera provided to UI for diagnostic visualization
    """

    move_x: "float" = betterproto2.field(1, betterproto2.TYPE_FLOAT)
    """
    prediction motion vector to center gripper over target
    """

    move_y: "float" = betterproto2.field(2, betterproto2.TYPE_FLOAT)

    prob_target_in_view: "float" = betterproto2.field(3, betterproto2.TYPE_FLOAT)
    """
    probability a target is in view
    """

    prob_holding: "float" = betterproto2.field(4, betterproto2.TYPE_FLOAT)
    """
    probability an object is held in the gripper (visual only)
    """


default_message_pool.register_message(
    "nf.telemetry", "GripCamPredictions", GripCamPredictions
)


@dataclass(eq=False, repr=False)
class GripperSensors(betterproto2.Message):
    """
    Latest state of sensors in the gripper
    """

    range: "float" = betterproto2.field(1, betterproto2.TYPE_FLOAT)
    """
    measured laser range from palm to obstacle in meters. Unset when infinite
    """

    angle: "float" = betterproto2.field(2, betterproto2.TYPE_FLOAT)
    """
    Finger angle from full open to full closed [-90,90]
    In the pilot gripper this is the value last commanded of the finger servo.
    In the arpeggio gripper, this is the last measured value
    map this to [0,60] to get the angle in degrees of the first finger bone.
    the second bone is a deterministic function of the first one, but I don't know the function.
    """

    pressure: "float" = betterproto2.field(3, betterproto2.TYPE_FLOAT)
    """
    The voltage on the sensing finger pad, higher is more pressure. [0,3.3]
    """

    wrist: "float" = betterproto2.field(4, betterproto2.TYPE_FLOAT)
    """
    Wrist angle in degrees [0,360]
    """


default_message_pool.register_message("nf.telemetry", "GripperSensors", GripperSensors)


@dataclass(eq=False, repr=False)
class NamedObjectPosition(betterproto2.Message):
    """
    Position of a named object that UI might want to visually represent.
    only sent when it moves
    """

    position: "_common__.Vec3 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    if position is unset, the UI should hide the indicator. 
    """

    name: "str" = betterproto2.field(2, betterproto2.TYPE_STRING)
    """
    Name of the object
    Could be the name of a tag like 'hamper' or 'gamepad'
    When the observer is moving the gantry to a particular goal position, it gives this position with the name 'gantry_goal'
    """


default_message_pool.register_message(
    "nf.telemetry", "NamedObjectPosition", NamedObjectPosition
)


@dataclass(eq=False, repr=False)
class OneTarget(betterproto2.Message):
    """


    Oneofs:
        - dropoff: intended dropoff location
    """

    id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)
    """
    stable target identifier
    """

    position: "_common__.Vec3 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    position in world space
    """

    coords: "_common__.Vec3 | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="dropoff"
    )

    tag: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True, group="dropoff"
    )

    status: "TargetStatus" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, default_factory=lambda: TargetStatus(0)
    )
    """
    status of target
    """

    source: "str" = betterproto2.field(6, betterproto2.TYPE_STRING)
    """
    the entity that submitted the target to the observer.
    """


default_message_pool.register_message("nf.telemetry", "OneTarget", OneTarget)


@dataclass(eq=False, repr=False)
class Popup(betterproto2.Message):
    """
    A connected UI should immediately display this message in a popup with an OK button.
    """

    message: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)


default_message_pool.register_message("nf.telemetry", "Popup", Popup)


@dataclass(eq=False, repr=False)
class PositionEstimate(betterproto2.Message):
    """
    estimate of the robot's position
    """

    gantry_position: "_common__.Vec3 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    gantry_velocity: "_common__.Vec3 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    gripper_pose: "_common__.Pose | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    in world space
    """

    data_ts: "float" = betterproto2.field(4, betterproto2.TYPE_DOUBLE)
    """
    the wall time in seconds since the epoch UTC when the robot was at this position
    """

    slack: "list[bool]" = betterproto2.field(5, betterproto2.TYPE_BOOL, repeated=True)
    """
    an array of bools for each anchor. true meaning the line should be drawn with a droop
    """


default_message_pool.register_message(
    "nf.telemetry", "PositionEstimate", PositionEstimate
)


@dataclass(eq=False, repr=False)
class PositionFactors(betterproto2.Message):
    """
    Diagnostic information about factors used in estimating the robot's positon
    """

    visual_pos: "_common__.Vec3 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Visually determined (apriltags) position and velocity
    """

    visual_vel: "_common__.Vec3 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    hanging_pos: "_common__.Vec3 | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Encoder determined position and velocity of hang point
    """

    hanging_vel: "_common__.Vec3 | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "nf.telemetry", "PositionFactors", PositionFactors
)


@dataclass(eq=False, repr=False)
class TargetList(betterproto2.Message):
    """
    A full snapshot of the list of targets known to the observer and their statuses. replace previous
    """

    targets: "list[OneTarget]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    order of targets is the order in which the observer will try to pick them up
    """


default_message_pool.register_message("nf.telemetry", "TargetList", TargetList)


@dataclass(eq=False, repr=False)
class TelemetryBatchUpdate(betterproto2.Message):
    """
    the frame sent over the wire
    """

    robot_id: "str" = betterproto2.field(1, betterproto2.TYPE_STRING)

    updates: "list[TelemetryItem]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "nf.telemetry", "TelemetryBatchUpdate", TelemetryBatchUpdate
)


@dataclass(eq=False, repr=False)
class TelemetryItem(betterproto2.Message):
    """
    A single kind of update that the observer is providing to an external UI
    Typically about the robot's state such as it's position

    Oneofs:
        - payload:
    """

    pos_estimate: "PositionEstimate | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    pos_factors_debug: "PositionFactors | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    gantry_sightings: "GantrySightings | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    new_anchor_poses: "AnchorPoses | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    component_conn_status: "ComponentConnStatus | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    vid_stats: "VidStats | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    named_position: "NamedObjectPosition | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    last_commanded_vel: "CommandedVelocity | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    pop_message: "Popup | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    grip_sensors: "GripperSensors | None" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    grip_cam_preditions: "GripCamPredictions | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    target_list: "TargetList | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    video_ready: "VideoReady | None" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )

    uplink_status: "UplinkStatus | None" = betterproto2.field(
        15, betterproto2.TYPE_MESSAGE, optional=True, group="payload"
    )
    """
    only sent from control plane
    """

    retain_key: "str | None" = betterproto2.field(
        14, betterproto2.TYPE_STRING, optional=True
    )
    """
    If set, the Control Plane will cache this item using this string as the key.
    When a new UI connects, it receives the latest item for every unique key.
    e.g., "anchor_poses", "conn_status_anchor_0", "conn_status_gripper"
    """


default_message_pool.register_message("nf.telemetry", "TelemetryItem", TelemetryItem)


@dataclass(eq=False, repr=False)
class UplinkStatus(betterproto2.Message):
    online: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)


default_message_pool.register_message("nf.telemetry", "UplinkStatus", UplinkStatus)


@dataclass(eq=False, repr=False)
class VideoReady(betterproto2.Message):
    """
    Indicates the availability of a video stream
    """

    is_gripper: "bool" = betterproto2.field(1, betterproto2.TYPE_BOOL)
    """
    is this the gripper camera?
    """

    anchor_num: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Camera anchor num 
    """

    local_uri: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    for local UI's connect at this address
    udp:127.0.0.1:1234
    """

    stream_path: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    for remote UI's construct a url using this stream path
    for example http://localhost:8889/${streamPath}/whep
    """


default_message_pool.register_message("nf.telemetry", "VideoReady", VideoReady)


@dataclass(eq=False, repr=False)
class VidStats(betterproto2.Message):
    """
    Info on the throughput and latency of video connections and apriltag processing
    """

    detection_rate: "float" = betterproto2.field(1, betterproto2.TYPE_FLOAT)
    """
    tags detected per second summed accross all cameras
    """

    video_latency: "float" = betterproto2.field(2, betterproto2.TYPE_FLOAT)
    """
    seconds between when frames are captured and when the observer can process them.
    """

    video_framerate: "float" = betterproto2.field(3, betterproto2.TYPE_FLOAT)
    """
    average framerate across all cameras
    """


default_message_pool.register_message("nf.telemetry", "VidStats", VidStats)


from .. import common as _common__
