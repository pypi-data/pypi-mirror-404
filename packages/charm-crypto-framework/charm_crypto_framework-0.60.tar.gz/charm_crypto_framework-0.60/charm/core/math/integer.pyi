"""Type stubs for charm.core.math.integer C extension module."""

from __future__ import annotations

from typing import overload

class Element:
    """Integer element, optionally with modulus for modular arithmetic."""

    @overload
    def __init__(self, number: int) -> None: ...
    @overload
    def __init__(self, number: Element) -> None: ...
    @overload
    def __init__(self, number: int, modulus: int) -> None: ...
    @overload
    def __init__(self, number: int, modulus: Element) -> None: ...
    @overload
    def __init__(self, number: Element, modulus: int) -> None: ...
    @overload
    def __init__(self, number: Element, modulus: Element) -> None: ...
    def set(self, other: Element) -> bool: ...
    def isCoPrime(self, other: Element | int) -> bool: ...
    def isCongruent(self, a: int, n: int) -> bool: ...

    # Arithmetic operations
    def __add__(self, other: Element | int) -> Element: ...
    def __radd__(self, other: Element | int) -> Element: ...
    def __sub__(self, other: Element | int) -> Element: ...
    def __rsub__(self, other: Element | int) -> Element: ...
    def __mul__(self, other: Element | int) -> Element: ...
    def __rmul__(self, other: Element | int) -> Element: ...
    def __truediv__(self, other: Element | int) -> Element: ...
    def __rtruediv__(self, other: Element | int) -> Element: ...
    def __mod__(self, other: Element | int) -> Element: ...
    def __rmod__(self, other: Element | int) -> Element: ...
    def __pow__(self, other: Element | int) -> Element: ...
    def __rpow__(self, other: Element | int) -> Element: ...
    def __neg__(self) -> Element: ...
    def __invert__(self) -> Element: ...
    def __xor__(self, other: Element | int) -> Element: ...
    def __rxor__(self, other: Element | int) -> Element: ...

    # Comparison operations
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Element | int) -> bool: ...
    def __le__(self, other: Element | int) -> bool: ...
    def __gt__(self, other: Element | int) -> bool: ...
    def __ge__(self, other: Element | int) -> bool: ...

    # Conversion
    def __int__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...

# Module-level functions
def randomBits(bits: int) -> Element: ...
def random(n: Element | int) -> Element: ...
def randomPrime(bits: int) -> Element: ...
def isPrime(n: Element | int) -> bool: ...
def encode(message: bytes, modulus: Element | int) -> Element: ...
def decode(element: Element) -> bytes: ...
def hashInt(value: bytes, modulus: Element | int) -> Element: ...
def bitsize(n: Element | int) -> int: ...
def legendre(a: Element | int, p: Element | int) -> int: ...
def gcd(a: Element | int, b: Element | int) -> Element: ...
def lcm(a: Element | int, b: Element | int) -> Element: ...
def serialize(element: Element) -> bytes: ...
def deserialize(data: bytes) -> Element: ...
def int2Bytes(element: Element) -> bytes: ...
def toInt(element: Element) -> Element: ...
def getMod(element: Element) -> Element: ...
def reduce(element: Element) -> Element: ...

