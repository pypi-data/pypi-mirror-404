"""Type stubs for charm.core.math.elliptic_curve C extension module."""

from typing import overload

# Module-level constants (group types)
ZR: int
G: int

class ECGroup:
    """Elliptic curve group initialized with an OpenSSL NID (curve identifier)."""

    def __init__(self, nid: int) -> None: ...

class Element:
    """Element in an elliptic curve group (either ZR or G)."""

    type: int
    initialized: int

    def __init__(self) -> None: ...
    def isInf(self) -> bool: ...

    # Arithmetic operations
    def __add__(self, other: Element) -> Element: ...
    def __radd__(self, other: Element) -> Element: ...
    def __sub__(self, other: Element) -> Element: ...
    def __rsub__(self, other: Element) -> Element: ...
    def __mul__(self, other: Element | int) -> Element: ...
    def __rmul__(self, other: Element | int) -> Element: ...
    def __mod__(self, other: Element) -> Element: ...
    def __pow__(self, exp: Element | int) -> Element: ...
    def __neg__(self) -> Element: ...
    def __invert__(self) -> Element: ...

    # Comparison operations
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: Element) -> bool: ...
    def __le__(self, other: Element) -> bool: ...
    def __gt__(self, other: Element) -> bool: ...
    def __ge__(self, other: Element) -> bool: ...

    # Conversion
    def __int__(self) -> int: ...
    def __hash__(self) -> int: ...

# Module-level functions
def init(group: ECGroup, type: int, value: int = ...) -> Element: ...
def random(group: ECGroup, type: int) -> Element: ...
def order(group: ECGroup) -> Element: ...
def getGenerator(group: ECGroup) -> Element: ...
def bitsize(group: ECGroup) -> int: ...
def serialize(element: Element) -> bytes: ...
def deserialize(group: ECGroup, data: bytes, type: int) -> Element: ...
def hashEC(group: ECGroup, data: bytes, type: int) -> Element: ...
def encode(group: ECGroup, message: bytes) -> Element: ...
def decode(element: Element) -> bytes: ...

@overload
def getXY(group: ECGroup, element: Element, x_only: bool = True) -> Element: ...
@overload
def getXY(group: ECGroup, element: Element, x_only: bool = False) -> tuple[Element, Element]: ...

