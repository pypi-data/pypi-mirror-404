#!/usr/bin/env python
"""
Post-process generated enum documentation to add human-readable query descriptions.

This script enriches the markdown files generated by gen-doc with:
- Human-readable descriptions of dynamic enum queries
- Links to source ontology terms
"""

import re
import sys
import yaml
from pathlib import Path

from valuesets.utils.query_describer import describe_enum_query, fetch_label_from_ols


def find_all_enums(schema_dir: Path) -> dict[str, dict]:
    """Find all enum definitions and their metadata."""
    enums = {}

    for yaml_file in schema_dir.rglob("*.yaml"):
        schema = yaml.safe_load(yaml_file.read_text())
        if not schema or "enums" not in schema:
            continue

        prefix_map = schema.get("prefixes", {})

        for name, defn in schema["enums"].items():
            if defn:  # Include all enums, not just dynamic ones
                enums[name] = {
                    "definition": defn,
                    "prefix_map": prefix_map,
                    "source_file": yaml_file,
                }

    return enums


def build_annotation_table(defn: dict, prefix_map: dict) -> str | None:
    """Build a wide markdown table with pivoted annotations and mappings.

    Returns markdown table string or None if no extra columns to add.
    """
    from valuesets.utils.query_describer import curie_to_uri

    pvs = defn.get("permissible_values", {})
    if not pvs:
        return None

    # Mapping field names to look for
    mapping_fields = ["exact_mappings", "close_mappings", "related_mappings", "narrow_mappings", "broad_mappings"]

    # Collect all unique annotation keys and check for mappings and titles
    all_annotation_keys = set()
    has_mappings = {field: False for field in mapping_fields}
    has_title = False

    for pv_def in pvs.values():
        if not pv_def:
            continue
        if "annotations" in pv_def:
            all_annotation_keys.update(pv_def["annotations"].keys())
        for field in mapping_fields:
            if pv_def.get(field):
                has_mappings[field] = True
        if pv_def.get("title"):
            has_title = True

    # Determine which mapping columns to include
    mapping_columns = [field for field in mapping_fields if has_mappings[field]]

    # If no annotations, no mappings, and no titles, nothing to enrich
    if not all_annotation_keys and not mapping_columns and not has_title:
        return None

    # Sort annotation keys for consistent output
    annotation_keys = sorted(all_annotation_keys)

    # Build header: Value, Title (if present), Meaning, Description, then mappings, then annotations
    headers = ["Value"]
    if has_title:
        headers.append("Title")
    headers += ["Meaning", "Description"]
    headers += [field.replace("_", " ").title() for field in mapping_columns]
    headers += [k.replace("_", " ").title() for k in annotation_keys]

    header_row = "| " + " | ".join(headers) + " |"
    separator = "| " + " | ".join(["---"] * len(headers)) + " |"

    def format_curie_link(curie: str) -> str:
        """Format a CURIE as a markdown link."""
        if curie and ":" in curie:
            uri = curie_to_uri(curie, prefix_map)
            if uri:
                return f"[{curie}]({uri})"
        return curie

    def format_mapping_list(mappings: list) -> str:
        """Format a list of mappings as comma-separated links."""
        if not mappings:
            return ""
        formatted = [format_curie_link(m) for m in mappings]
        return ", ".join(formatted)

    # Build rows
    rows = []
    for pv_name, pv_def in pvs.items():
        pv_def = pv_def or {}
        meaning = pv_def.get("meaning", "")

        # Format meaning as link if it's a CURIE
        meaning_formatted = format_curie_link(meaning) if meaning else ""

        title = pv_def.get("title", "")
        description = pv_def.get("description", "")
        annotations = pv_def.get("annotations", {})

        row_values = [str(pv_name)]
        if has_title:
            row_values.append(title or "")
        row_values += [
            meaning_formatted,
            description or "",
        ]

        # Add mapping columns
        for field in mapping_columns:
            mappings = pv_def.get(field, []) or []
            row_values.append(format_mapping_list(mappings))

        # Add annotation columns
        for key in annotation_keys:
            val = annotations.get(key, "")
            row_values.append(str(val) if val else "")

        rows.append("| " + " | ".join(row_values) + " |")

    return "\n".join([header_row, separator] + rows)


def enrich_enum_doc(doc_path: Path, enum_name: str, enum_info: dict, label_cache: dict) -> bool:
    """Enrich a single enum documentation file.

    Returns True if the file was modified.
    """
    if not doc_path.exists():
        return False

    content = doc_path.read_text()

    # Check if already enriched (for dynamic enum query)
    already_has_query = "## Dynamic Enum Query" in content
    already_has_annotations = "<!-- annotations-table -->" in content

    defn = enum_info["definition"]
    prefix_map = enum_info["prefix_map"]
    modified = False

    # Enrich dynamic enums with query description
    if not already_has_query and "reachable_from" in defn:
        label_lookup = {}
        for node in defn.get("reachable_from", {}).get("source_nodes", []):
            if node in label_cache:
                label_lookup[node] = label_cache[node]
            else:
                label = fetch_label_from_ols(node)
                if label:
                    label_lookup[node] = label
                    label_cache[node] = label

        desc = describe_enum_query(defn, label_lookup, prefix_map)
        if desc:
            enrichment = f"""
## Dynamic Enum Query

This value set is dynamically populated from an ontology.

**Query:** {desc.markdown}

**Prefixes used:** `{', '.join(sorted(desc.prefixes))}`

"""
            pattern = r"(_This is a dynamic enum_\n)"
            if re.search(pattern, content):
                content = re.sub(pattern, r"\1" + enrichment, content)
                modified = True

    # Enrich static enums with annotation table (if they have annotations)
    if not already_has_annotations:
        annotation_table = build_annotation_table(defn, prefix_map)
        if annotation_table:
            # Replace the existing Permissible Values table
            # Look for the pattern: ## Permissible Values followed by a table
            pv_pattern = r"(## Permissible Values\n+)\| Value \| Meaning \| Description \|\n\| --- \| --- \| --- \|\n((?:\|[^\n]+\|\n)+)"
            if re.search(pv_pattern, content):
                replacement = r"\1<!-- annotations-table -->\n" + annotation_table + "\n"
                content = re.sub(pv_pattern, replacement, content)
                modified = True

    if modified:
        doc_path.write_text(content)

    return modified


def main():
    import argparse

    parser = argparse.ArgumentParser(description="Enrich enum docs with query descriptions")
    parser.add_argument(
        "--schema-dir",
        type=Path,
        default=Path("src/valuesets/schema"),
        help="Schema directory",
    )
    parser.add_argument(
        "--docs-dir",
        type=Path,
        default=Path("docs/elements"),
        help="Generated docs directory",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be changed without modifying files",
    )

    args = parser.parse_args()

    print(f"Finding enums in {args.schema_dir}...")
    all_enums = find_all_enums(args.schema_dir)
    print(f"Found {len(all_enums)} enums")

    label_cache: dict[str, str] = {}
    enriched = 0

    for enum_name, enum_info in all_enums.items():
        doc_path = args.docs_dir / f"{enum_name}.md"

        if args.dry_run:
            if doc_path.exists():
                print(f"Would enrich: {doc_path}")
        else:
            if enrich_enum_doc(doc_path, enum_name, enum_info, label_cache):
                print(f"Enriched: {doc_path}")
                enriched += 1

    if not args.dry_run:
        print(f"Enriched {enriched} documentation files")


if __name__ == "__main__":
    main()
