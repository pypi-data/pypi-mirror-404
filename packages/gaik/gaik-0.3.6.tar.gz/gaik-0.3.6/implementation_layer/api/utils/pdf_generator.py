"""
Generate PDF documents from structured data.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any

from pydantic import BaseModel

try:
    from fpdf import FPDF
except ImportError:
    FPDF = None  # type: ignore


class GAIKPdf(FPDF):
    """Custom FPDF class with header and footer for GAIK branding."""

    def __init__(self, title: str = "Document", logo_path: Path | None = None) -> None:
        super().__init__()
        self.doc_title = title
        self.logo_path = logo_path
        self._header_height = 0

    def header(self) -> None:
        """Add header with logo and title."""
        if self.logo_path and self.logo_path.exists():
            self.image(str(self.logo_path), x=10, y=8, w=30)
            self._header_height = 25
        else:
            self._header_height = 15

        if self.logo_path and self.logo_path.exists():
            self.set_xy(45, 12)
            self.set_font_size(18)
            self.cell(0, 10, self.doc_title, align="L")
        else:
            self.set_y(10)
            self.set_font_size(18)
            self.cell(0, 10, self.doc_title, align="C")

        self.set_y(self._header_height + 5)
        self.set_draw_color(200, 200, 200)
        self.set_line_width(0.5)
        self.line(10, self.get_y(), 200, self.get_y())
        self.ln(10)

    def footer(self) -> None:
        """Add footer with page number and generation date."""
        self.set_y(-20)
        self.set_draw_color(200, 200, 200)
        self.set_line_width(0.3)
        self.line(10, self.get_y(), 200, self.get_y())

        self.set_y(-15)
        self.set_font_size(8)
        self.set_text_color(128, 128, 128)

        self.cell(0, 5, "Generated by GAIK Toolkit", align="L")

        self.set_y(-15)
        date_str = datetime.now().strftime("%d.%m.%Y %H:%M")
        self.cell(0, 5, date_str, align="C")

        self.set_y(-15)
        self.cell(0, 5, f"Page {self.page_no()}/{{nb}}", align="R")

        self.set_text_color(0, 0, 0)


@dataclass
class PDFResult:
    """Result from PDF generation."""

    output_path: Path
    page_count: int


class StructuredDataToPDF:
    """Generate PDF documents from Pydantic model instances or dicts."""

    def __init__(
        self, title: str = "Document", logo_path: str | Path | None = None
    ) -> None:
        """Initialize the PDF generator.

        Args:
            title: Title shown at the top of the PDF document.
            logo_path: Optional path to logo image file (PNG recommended).
        """
        if FPDF is None:
            raise ImportError(
                "fpdf2 is required for PDF generation. Install with: pip install fpdf2"
            )
        self.title = title
        self.logo_path = Path(logo_path) if logo_path else None
        self._font_family = "CustomFont"
        self._has_custom_font = False

    def run(self, data: BaseModel | dict | list, output_path: str | Path) -> PDFResult:
        """Generate a PDF from a Pydantic model instance or dict.

        Args:
            data: Pydantic model instance, dict, or list of dicts to render.
            output_path: Path where the PDF file will be saved.

        Returns:
            PDFResult with output path and page count.
        """
        pdf = GAIKPdf(title=self.title, logo_path=self.logo_path)
        pdf.alias_nb_pages()
        pdf.set_auto_page_break(auto=True, margin=25)

        self._setup_font(pdf)

        pdf.add_page()

        pdf.set_font_size(11)

        if isinstance(data, BaseModel):
            self._render_value(pdf, data.model_dump(), indent=0)
        elif isinstance(data, list):
            for i, item in enumerate(data, 1):
                self._write_line(pdf, f"Item {i}", indent=0, bold=True)
                if isinstance(item, BaseModel):
                    self._render_value(pdf, item.model_dump(), indent=1)
                elif isinstance(item, dict):
                    self._render_value(pdf, item, indent=1)
                else:
                    self._write_line(pdf, str(item), indent=1)
                pdf.ln(4)
        else:
            self._render_value(pdf, data, indent=0)

        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        pdf.output(str(output_path))

        return PDFResult(output_path=output_path, page_count=pdf.page_no())

    def _setup_font(self, pdf: FPDF) -> None:
        """Set up a Unicode-capable font for Finnish language support."""
        font_configs = [
            {
                "regular": "C:/Windows/Fonts/arial.ttf",
                "bold": "C:/Windows/Fonts/arialbd.ttf",
            },
            {
                "regular": "C:/Windows/Fonts/segoeui.ttf",
                "bold": "C:/Windows/Fonts/segoeuib.ttf",
            },
            {
                "regular": "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",
                "bold": "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
            },
            {
                "regular": "/usr/share/fonts/TTF/DejaVuSans.ttf",
                "bold": "/usr/share/fonts/TTF/DejaVuSans-Bold.ttf",
            },
            {
                "regular": "/Library/Fonts/Arial.ttf",
                "bold": "/Library/Fonts/Arial Bold.ttf",
            },
        ]

        for config in font_configs:
            regular_path = config["regular"]
            bold_path = config["bold"]
            if Path(regular_path).exists():
                try:
                    pdf.add_font("CustomFont", "", regular_path)
                    if Path(bold_path).exists():
                        pdf.add_font("CustomFont", "B", bold_path)
                    pdf.set_font("CustomFont", size=11)
                    self._font_family = "CustomFont"
                    self._has_custom_font = True
                    return
                except Exception:
                    continue

        pdf.set_font("Helvetica", size=11)
        self._font_family = "Helvetica"
        self._has_custom_font = False

    def _render_value(
        self, pdf: FPDF, value: Any, indent: int = 0, is_top_level: bool = True
    ) -> None:
        """Recursively render a value to the PDF."""
        if isinstance(value, dict):
            for key, val in value.items():
                label = self._format_key(key)
                if isinstance(val, dict):
                    self._write_section_header(pdf, label, indent)
                    self._render_value(pdf, val, indent + 1, is_top_level=False)
                    pdf.ln(2)
                elif isinstance(val, list):
                    self._write_section_header(pdf, label, indent)
                    self._render_list(pdf, val, indent + 1)
                    pdf.ln(2)
                else:
                    display_value = self._format_value(val)
                    self._write_key_value(pdf, label, display_value, indent)
        else:
            self._write_line(pdf, str(value), indent)

    def _render_list(self, pdf: FPDF, items: list, indent: int) -> None:
        """Render a list of items."""
        for i, item in enumerate(items, 1):
            if isinstance(item, dict):
                self._write_line(pdf, f"{i}.", indent, bold=True)
                self._render_value(pdf, item, indent + 1, is_top_level=False)
                pdf.ln(1)
            else:
                self._write_line(pdf, f"â€¢ {item}", indent)

    def _write_section_header(self, pdf: FPDF, text: str, indent: int = 0) -> None:
        """Write a section header with background styling."""
        left_margin = 10 + (indent * 10)
        pdf.set_x(left_margin)

        pdf.set_fill_color(245, 245, 245)
        pdf.set_font(self._font_family, style="B", size=11)
        pdf.cell(0, 8, f"  {text}", ln=True, fill=True)
        pdf.set_font(self._font_family, style="", size=11)
        pdf.ln(1)

    def _write_key_value(
        self, pdf: FPDF, key: str, value: str, indent: int = 0
    ) -> None:
        """Write a key-value pair with bold key."""
        left_margin = 10 + (indent * 10)
        pdf.set_x(left_margin)

        pdf.set_font(self._font_family, style="B", size=11)
        key_width = pdf.get_string_width(f"{key}: ") + 2
        pdf.cell(key_width, 7, f"{key}: ")

        pdf.set_font(self._font_family, style="", size=11)
        remaining_width = pdf.w - pdf.get_x() - 10
        if pdf.get_string_width(value) > remaining_width:
            pdf.multi_cell(0, 7, value)
        else:
            pdf.cell(0, 7, value, ln=True)

    def _write_line(
        self, pdf: FPDF, text: str, indent: int = 0, bold: bool = False
    ) -> None:
        """Write a line of text to the PDF."""
        left_margin = 10 + (indent * 10)
        pdf.set_x(left_margin)
        if bold:
            pdf.set_font(self._font_family, style="B", size=11)
        pdf.multi_cell(0, 7, text.strip())
        if bold:
            pdf.set_font(self._font_family, style="", size=11)

    @staticmethod
    def _format_key(key: str) -> str:
        """Format a field key for display."""
        return key.replace("_", " ").title()

    @staticmethod
    def _format_value(value: Any) -> str:
        """Format a value for display."""
        if value is None:
            return "-"
        if isinstance(value, bool):
            return "Yes" if value else "No"
        if isinstance(value, float):
            return f"{value:.2f}"
        return str(value)
