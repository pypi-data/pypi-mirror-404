/**
 * Generated API Client
 * Auto-generated thin wrapper - DO NOT EDIT
 *
 * @generated {{ generated_at }}
 */

{% if models %}
import type {
{% for model_name in models | unique | sort %}  {{ model_name }},
{% endfor %}} from './types';
{% endif %}

/**
 * API contract version - changes when methods or models change.
 * Use checkVersion() to verify client/server compatibility.
 */
export const API_VERSION = '{{ api_version }}';

/**
 * Timestamp when this client was generated.
 */
export const GENERATED_AT = '{{ generated_at }}';

// Interface for Centrifugo client with namedRPC
// Compatible with @djangocfg/centrifugo client
interface CentrifugoClient {
  namedRPC<T = any>(method: string, params: any, options?: { timeout?: number }): Promise<T>;
  /** Optional: fire-and-forget RPC (no response expected) */
  namedRPCNoWait?(method: string, params: any): void;
}

// Re-export WsVersionCheckResult from types (generated from Pydantic model)
export type { WsVersionCheckResult } from './types';

export class APIClient {
  constructor(private client: CentrifugoClient) {}

  /**
   * Check if client API version is compatible with server.
   * Call this after connecting to ensure contract compatibility.
   *
   * @throws Error if versions are incompatible
   * @returns WsVersionCheckResult with compatibility info
   *
   * @example
   * const apiClient = new APIClient(client);
   * const result = await apiClient.checkVersion();
   * if (!result.compatible) {
   *   console.error('API version mismatch! Please regenerate client.');
   * }
   */
  async checkVersion(): Promise<WsVersionCheckResult> {
    try {
      const result = await this.client.namedRPC<WsVersionCheckResult>(
        'system.check_version',
        { client_version: API_VERSION }
      );
      return result;
    } catch (error) {
      // If endpoint doesn't exist, assume compatible (for backwards compatibility)
      return {
        compatible: true,
        client_version: API_VERSION,
        server_version: 'unknown',
        message: 'Version check endpoint not available',
      };
    }
  }

  /**
   * Get the API contract version of this client.
   */
  getVersion(): string {
    return API_VERSION;
  }

{% for method in methods %}
  /**
   * {{ method.docstring.split('\n')[0] if method.docstring else 'No description' }}
   */
  async {{ method.name_ts }}(params: {{ method.param_type }}): Promise<{{ method.return_type }}> {
    {% if method.name.startswith('ai_chat.') %}
    // AI methods use longer timeout (60s) for safety, though RPC returns immediately
    return this.client.namedRPC<{{ method.return_type }}>('{{ method.name }}', params, { timeout: 60000 });
    {% else %}
    return this.client.namedRPC<{{ method.return_type }}>('{{ method.name }}', params);
    {% endif %}
  }

  {% if method.no_wait %}
  /**
   * {{ method.docstring.split('\n')[0] if method.docstring else 'No description' }} (fire-and-forget)
   */
  {{ method.name_ts }}NoWait(params: {{ method.param_type }}): void {
    // Fire-and-forget: don't wait for response
    if (this.client.namedRPCNoWait) {
      this.client.namedRPCNoWait('{{ method.name }}', params);
    } else {
      this.client.namedRPC('{{ method.name }}', params).catch(() => {});
    }
  }

  {% endif %}
{% endfor %}
}
