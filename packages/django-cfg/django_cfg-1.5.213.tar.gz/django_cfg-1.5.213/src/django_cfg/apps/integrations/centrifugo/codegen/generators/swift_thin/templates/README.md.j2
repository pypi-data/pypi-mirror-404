# {{ package_name }}

Generated Swift client for Centrifugo RPC methods.

## Requirements

- iOS {{ minimum_ios_version }}+ / macOS {{ minimum_macos_version }}+
- Swift 5.5+
- Xcode 13.0+

## Installation

### Swift Package Manager

Add the following to your `Package.swift`:

```swift
dependencies: [
    .package(path: "./{{ package_name }}")
]
```

Or add it via Xcode:
1. File â†’ Add Packages
2. Select "Add Local..."
3. Navigate to this directory

## Quick Start

```swift
import {{ package_name }}

// Create client
let api = try APIClient(
    url: "ws://your-server/connection/websocket",
    token: "your-jwt-token",
    userId: "user-123"
)

// Connect
try await api.connect()

// Make RPC calls
{% if methods %}
{% set method = methods[0] %}
let result = try await api.{{ method.swift_name }}(params: {{ method.param_type }}(...))
{% endif %}

// Disconnect when done
await api.disconnect()
```

## Available Methods

{% if methods %}
| Method | Parameters | Returns |
|--------|------------|---------|
{% for method in methods %}
| `{{ method.swift_name }}` | `{{ method.param_type }}` | `{{ method.return_type }}` |
{% endfor %}
{% if total_methods > 5 %}
| ... | ... | ... |
| *{{ total_methods }} methods total* | | |
{% endif %}
{% else %}
No methods available.
{% endif %}

## Available Types

{% if models %}
{% for model in models %}
- `{{ model }}`
{% endfor %}
{% else %}
No custom types.
{% endif %}

## Error Handling

```swift
do {
    let result = try await api.someMethod(params: params)
} catch RPCError.notConnected {
    print("Not connected to server")
} catch RPCError.timeout {
    print("Request timed out")
} catch RPCError.serverError(let code, let message) {
    print("Server error \(code): \(message)")
} catch {
    print("Unknown error: \(error)")
}
```

## Connection State

```swift
// Check connection state
let state = await api.connectionState

switch state {
case .disconnected:
    print("Disconnected")
case .connecting:
    print("Connecting...")
case .connected:
    print("Connected")
}

// Convenience check
if await api.isConnected {
    // Ready to make calls
}
```

## Architecture

This client uses the correlation ID pattern to implement RPC over Centrifugo's pub/sub:

1. Client generates a unique correlation ID
2. Request is published to `rpc.requests` channel
3. Server processes and publishes response to user's reply channel
4. Client matches response by correlation ID

## Thread Safety

Both `CentrifugoRPCClient` and `APIClient` are implemented as Swift actors,
providing automatic thread safety for all operations.

## Generated Files

- `Package.swift` - SPM manifest
- `Sources/{{ package_name }}/`
  - `Types.swift` - Generated Codable models
  - `AnyCodable.swift` - Dynamic JSON handling
  - `RPCClient.swift` - Base WebSocket RPC client
  - `APIClient.swift` - Type-safe API wrapper

---

*Auto-generated by Centrifugo Codegen*
