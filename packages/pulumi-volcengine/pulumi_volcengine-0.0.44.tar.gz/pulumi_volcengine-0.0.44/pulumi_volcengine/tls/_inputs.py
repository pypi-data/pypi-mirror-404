# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'AlarmAlarmPeriodDetailArgs',
    'AlarmContentTemplateDingTalkArgs',
    'AlarmContentTemplateEmailArgs',
    'AlarmContentTemplateLarkArgs',
    'AlarmContentTemplateSmArgs',
    'AlarmContentTemplateVmArgs',
    'AlarmContentTemplateWebhookArgs',
    'AlarmContentTemplateWechatArgs',
    'AlarmJoinConfigurationArgs',
    'AlarmNotifyGroupNoticeRuleArgs',
    'AlarmNotifyGroupNoticeRuleReceiverInfoArgs',
    'AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs',
    'AlarmNotifyGroupNoticeRuleRuleNodeArgs',
    'AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs',
    'AlarmNotifyGroupReceiverArgs',
    'AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs',
    'AlarmQueryRequestArgs',
    'AlarmRequestCycleArgs',
    'AlarmTriggerConditionArgs',
    'AlarmWebhookIntegrationWebhookHeaderArgs',
    'DownloadTaskLogContextInfosArgs',
    'EtlTaskTargetResourceArgs',
    'ImportTaskImportSourceInfoArgs',
    'ImportTaskImportSourceInfoKafkaSourceInfoArgs',
    'ImportTaskImportSourceInfoTosSourceInfoArgs',
    'ImportTaskTargetInfoArgs',
    'ImportTaskTargetInfoExtractRuleArgs',
    'IndexFullTextArgs',
    'IndexKeyValueArgs',
    'IndexKeyValueJsonKeyArgs',
    'IndexUserInnerKeyValueArgs',
    'IndexUserInnerKeyValueJsonKeyArgs',
    'ProjectTagArgs',
    'ProjectsTagArgs',
    'RuleContainerRuleArgs',
    'RuleContainerRuleKubernetesRuleArgs',
    'RuleExcludePathArgs',
    'RuleExtractRuleArgs',
    'RuleExtractRuleFilterKeyRegexArgs',
    'RuleExtractRuleLogTemplateArgs',
    'RuleUserDefineRuleArgs',
    'RuleUserDefineRuleAdvancedArgs',
    'RuleUserDefineRuleParsePathRuleArgs',
    'RuleUserDefineRulePluginArgs',
    'RuleUserDefineRuleShardHashKeyArgs',
    'ScheduleSqlTaskRequestCycleArgs',
    'SearchTracesQueryArgs',
    'SearchTracesQueryAttributeArgs',
    'ShardShardArgs',
    'ShipperContentInfoArgs',
    'ShipperContentInfoCsvInfoArgs',
    'ShipperContentInfoJsonInfoArgs',
    'ShipperKafkaShipperInfoArgs',
    'ShipperTosShipperInfoArgs',
    'TagResourceTagArgs',
    'TagResourcesTagFilterArgs',
    'TagTagArgs',
    'TagsTagFilterArgs',
    'TopicEncryptConfArgs',
    'TopicEncryptConfUserCmkInfoArgs',
    'TopicTagArgs',
    'TopicsTagArgs',
    'TraceInstanceBackendConfigArgs',
    'GetProjectsTagArgs',
    'GetSearchTracesQueryArgs',
    'GetSearchTracesQueryAttributeArgs',
    'GetTagResourcesTagFilterArgs',
    'GetTagsTagFilterArgs',
    'GetTopicsTagArgs',
]

@pulumi.input_type
class AlarmAlarmPeriodDetailArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[int],
                 general_webhook: pulumi.Input[int],
                 phone: pulumi.Input[int],
                 sms: pulumi.Input[int]):
        """
        :param pulumi.Input[int] email: Email alarm period, the unit is minutes, and the value range is 1~1440.
        :param pulumi.Input[int] general_webhook: Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
        :param pulumi.Input[int] phone: Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
        :param pulumi.Input[int] sms: SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "general_webhook", general_webhook)
        pulumi.set(__self__, "phone", phone)
        pulumi.set(__self__, "sms", sms)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[int]:
        """
        Email alarm period, the unit is minutes, and the value range is 1~1440.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[int]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="generalWebhook")
    def general_webhook(self) -> pulumi.Input[int]:
        """
        Customize the webhook alarm period, the unit is minutes, and the value range is 1~1440.
        """
        return pulumi.get(self, "general_webhook")

    @general_webhook.setter
    def general_webhook(self, value: pulumi.Input[int]):
        pulumi.set(self, "general_webhook", value)

    @property
    @pulumi.getter
    def phone(self) -> pulumi.Input[int]:
        """
        Telephone alarm cycle, the unit is minutes, and the value range is 10~1440.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: pulumi.Input[int]):
        pulumi.set(self, "phone", value)

    @property
    @pulumi.getter
    def sms(self) -> pulumi.Input[int]:
        """
        SMS alarm cycle, the unit is minutes, and the value range is 10~1440.
        """
        return pulumi.get(self, "sms")

    @sms.setter
    def sms(self, value: pulumi.Input[int]):
        pulumi.set(self, "sms", value)


@pulumi.input_type
class AlarmContentTemplateDingTalkArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str],
                 title: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the ding_talk content template.
        :param pulumi.Input[str] locale: The locale of the ding_talk content template.
        :param pulumi.Input[str] title: The title of the ding_talk content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the ding_talk content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the ding_talk content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        The title of the ding_talk content template.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class AlarmContentTemplateEmailArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str],
                 subject: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the email content template.
        :param pulumi.Input[str] locale: The locale of the email content template.
        :param pulumi.Input[str] subject: The subject of the email content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the email content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the email content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[str]:
        """
        The subject of the email content template.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class AlarmContentTemplateLarkArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str],
                 title: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the lark content template.
        :param pulumi.Input[str] locale: The locale of the lark content template.
        :param pulumi.Input[str] title: The title of the lark content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)
        pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the lark content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the lark content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        The title of the lark content template.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)


@pulumi.input_type
class AlarmContentTemplateSmArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the sms content template.
        :param pulumi.Input[str] locale: The locale of the sms content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the sms content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the sms content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)


@pulumi.input_type
class AlarmContentTemplateVmArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the vms content template.
        :param pulumi.Input[str] locale: The locale of the vms content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the vms content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the vms content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)


@pulumi.input_type
class AlarmContentTemplateWebhookArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the webhook content template.
        """
        pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the webhook content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)


@pulumi.input_type
class AlarmContentTemplateWechatArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 locale: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The content of the wechat content template.
        :param pulumi.Input[str] locale: The locale of the wechat content template.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "locale", locale)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The content of the wechat content template.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def locale(self) -> pulumi.Input[str]:
        """
        The locale of the wechat content template.
        """
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale", value)


@pulumi.input_type
class AlarmJoinConfigurationArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 set_operation_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The condition.
        :param pulumi.Input[str] set_operation_type: The set operation type.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if set_operation_type is not None:
            pulumi.set(__self__, "set_operation_type", set_operation_type)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="setOperationType")
    def set_operation_type(self) -> Optional[pulumi.Input[str]]:
        """
        The set operation type.
        """
        return pulumi.get(self, "set_operation_type")

    @set_operation_type.setter
    def set_operation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "set_operation_type", value)


@pulumi.input_type
class AlarmNotifyGroupNoticeRuleArgs:
    def __init__(__self__, *,
                 has_end_node: Optional[pulumi.Input[bool]] = None,
                 has_next: Optional[pulumi.Input[bool]] = None,
                 receiver_infos: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoArgs']]]] = None,
                 rule_node: Optional[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeArgs']] = None):
        """
        :param pulumi.Input[bool] has_end_node: Whether there is an end node behind.
        :param pulumi.Input[bool] has_next: Whether to continue to the next level of condition judgment.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoArgs']]] receiver_infos: List of IAM users to receive alerts.
        :param pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeArgs'] rule_node: The rule node.
        """
        if has_end_node is not None:
            pulumi.set(__self__, "has_end_node", has_end_node)
        if has_next is not None:
            pulumi.set(__self__, "has_next", has_next)
        if receiver_infos is not None:
            pulumi.set(__self__, "receiver_infos", receiver_infos)
        if rule_node is not None:
            pulumi.set(__self__, "rule_node", rule_node)

    @property
    @pulumi.getter(name="hasEndNode")
    def has_end_node(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether there is an end node behind.
        """
        return pulumi.get(self, "has_end_node")

    @has_end_node.setter
    def has_end_node(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_end_node", value)

    @property
    @pulumi.getter(name="hasNext")
    def has_next(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to continue to the next level of condition judgment.
        """
        return pulumi.get(self, "has_next")

    @has_next.setter
    def has_next(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_next", value)

    @property
    @pulumi.getter(name="receiverInfos")
    def receiver_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoArgs']]]]:
        """
        List of IAM users to receive alerts.
        """
        return pulumi.get(self, "receiver_infos")

    @receiver_infos.setter
    def receiver_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoArgs']]]]):
        pulumi.set(self, "receiver_infos", value)

    @property
    @pulumi.getter(name="ruleNode")
    def rule_node(self) -> Optional[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeArgs']]:
        """
        The rule node.
        """
        return pulumi.get(self, "rule_node")

    @rule_node.setter
    def rule_node(self, value: Optional[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeArgs']]):
        pulumi.set(self, "rule_node", value)


@pulumi.input_type
class AlarmNotifyGroupNoticeRuleReceiverInfoArgs:
    def __init__(__self__, *,
                 alarm_content_template_id: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_at_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alarm_webhook_integration_id: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_integration_name: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_is_at_all: Optional[pulumi.Input[bool]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 general_webhook_body: Optional[pulumi.Input[str]] = None,
                 general_webhook_headers: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs']]]] = None,
                 general_webhook_method: Optional[pulumi.Input[str]] = None,
                 general_webhook_url: Optional[pulumi.Input[str]] = None,
                 receiver_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 receiver_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 receiver_type: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alarm_content_template_id: The alarm content template id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alarm_webhook_at_users: The alarm webhook at users.
        :param pulumi.Input[str] alarm_webhook_integration_id: The alarm webhook integration id.
        :param pulumi.Input[str] alarm_webhook_integration_name: The alarm webhook integration name.
        :param pulumi.Input[bool] alarm_webhook_is_at_all: The alarm webhook is at all.
        :param pulumi.Input[str] end_time: The end time.
        :param pulumi.Input[str] general_webhook_body: The webhook body.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs']]] general_webhook_headers: The general webhook headers.
        :param pulumi.Input[str] general_webhook_method: The general webhook method.
        :param pulumi.Input[str] general_webhook_url: The webhook url.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] receiver_channels: The list of the receiver channels.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] receiver_names: List of the receiver names.
        :param pulumi.Input[str] receiver_type: The receiver type.
        :param pulumi.Input[str] start_time: The start time.
        """
        if alarm_content_template_id is not None:
            pulumi.set(__self__, "alarm_content_template_id", alarm_content_template_id)
        if alarm_webhook_at_users is not None:
            pulumi.set(__self__, "alarm_webhook_at_users", alarm_webhook_at_users)
        if alarm_webhook_integration_id is not None:
            pulumi.set(__self__, "alarm_webhook_integration_id", alarm_webhook_integration_id)
        if alarm_webhook_integration_name is not None:
            pulumi.set(__self__, "alarm_webhook_integration_name", alarm_webhook_integration_name)
        if alarm_webhook_is_at_all is not None:
            pulumi.set(__self__, "alarm_webhook_is_at_all", alarm_webhook_is_at_all)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if general_webhook_body is not None:
            pulumi.set(__self__, "general_webhook_body", general_webhook_body)
        if general_webhook_headers is not None:
            pulumi.set(__self__, "general_webhook_headers", general_webhook_headers)
        if general_webhook_method is not None:
            pulumi.set(__self__, "general_webhook_method", general_webhook_method)
        if general_webhook_url is not None:
            pulumi.set(__self__, "general_webhook_url", general_webhook_url)
        if receiver_channels is not None:
            pulumi.set(__self__, "receiver_channels", receiver_channels)
        if receiver_names is not None:
            pulumi.set(__self__, "receiver_names", receiver_names)
        if receiver_type is not None:
            pulumi.set(__self__, "receiver_type", receiver_type)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="alarmContentTemplateId")
    def alarm_content_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm content template id.
        """
        return pulumi.get(self, "alarm_content_template_id")

    @alarm_content_template_id.setter
    def alarm_content_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_content_template_id", value)

    @property
    @pulumi.getter(name="alarmWebhookAtUsers")
    def alarm_webhook_at_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The alarm webhook at users.
        """
        return pulumi.get(self, "alarm_webhook_at_users")

    @alarm_webhook_at_users.setter
    def alarm_webhook_at_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarm_webhook_at_users", value)

    @property
    @pulumi.getter(name="alarmWebhookIntegrationId")
    def alarm_webhook_integration_id(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm webhook integration id.
        """
        return pulumi.get(self, "alarm_webhook_integration_id")

    @alarm_webhook_integration_id.setter
    def alarm_webhook_integration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_webhook_integration_id", value)

    @property
    @pulumi.getter(name="alarmWebhookIntegrationName")
    def alarm_webhook_integration_name(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm webhook integration name.
        """
        return pulumi.get(self, "alarm_webhook_integration_name")

    @alarm_webhook_integration_name.setter
    def alarm_webhook_integration_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_webhook_integration_name", value)

    @property
    @pulumi.getter(name="alarmWebhookIsAtAll")
    def alarm_webhook_is_at_all(self) -> Optional[pulumi.Input[bool]]:
        """
        The alarm webhook is at all.
        """
        return pulumi.get(self, "alarm_webhook_is_at_all")

    @alarm_webhook_is_at_all.setter
    def alarm_webhook_is_at_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alarm_webhook_is_at_all", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="generalWebhookBody")
    def general_webhook_body(self) -> Optional[pulumi.Input[str]]:
        """
        The webhook body.
        """
        return pulumi.get(self, "general_webhook_body")

    @general_webhook_body.setter
    def general_webhook_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_body", value)

    @property
    @pulumi.getter(name="generalWebhookHeaders")
    def general_webhook_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs']]]]:
        """
        The general webhook headers.
        """
        return pulumi.get(self, "general_webhook_headers")

    @general_webhook_headers.setter
    def general_webhook_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs']]]]):
        pulumi.set(self, "general_webhook_headers", value)

    @property
    @pulumi.getter(name="generalWebhookMethod")
    def general_webhook_method(self) -> Optional[pulumi.Input[str]]:
        """
        The general webhook method.
        """
        return pulumi.get(self, "general_webhook_method")

    @general_webhook_method.setter
    def general_webhook_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_method", value)

    @property
    @pulumi.getter(name="generalWebhookUrl")
    def general_webhook_url(self) -> Optional[pulumi.Input[str]]:
        """
        The webhook url.
        """
        return pulumi.get(self, "general_webhook_url")

    @general_webhook_url.setter
    def general_webhook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_url", value)

    @property
    @pulumi.getter(name="receiverChannels")
    def receiver_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the receiver channels.
        """
        return pulumi.get(self, "receiver_channels")

    @receiver_channels.setter
    def receiver_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "receiver_channels", value)

    @property
    @pulumi.getter(name="receiverNames")
    def receiver_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of the receiver names.
        """
        return pulumi.get(self, "receiver_names")

    @receiver_names.setter
    def receiver_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "receiver_names", value)

    @property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> Optional[pulumi.Input[str]]:
        """
        The receiver type.
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "receiver_type", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class AlarmNotifyGroupNoticeRuleReceiverInfoGeneralWebhookHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the header.
        :param pulumi.Input[str] value: The value of the header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AlarmNotifyGroupNoticeRuleRuleNodeArgs:
    def __init__(__self__, *,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs']]] childrens: The children of the rule node.
        :param pulumi.Input[str] type: The type of the rule node.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The value of the rule node.
        """
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs']]]]:
        """
        The children of the rule node.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the rule node.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The value of the rule node.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class AlarmNotifyGroupNoticeRuleRuleNodeChildrenArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: The type of the rule node.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The value of the rule node.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the rule node.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The value of the rule node.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class AlarmNotifyGroupReceiverArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 receiver_channels: pulumi.Input[Sequence[pulumi.Input[str]]],
                 receiver_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 receiver_type: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 alarm_content_template_id: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_at_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 alarm_webhook_integration_id: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_integration_name: Optional[pulumi.Input[str]] = None,
                 alarm_webhook_is_at_all: Optional[pulumi.Input[bool]] = None,
                 general_webhook_body: Optional[pulumi.Input[str]] = None,
                 general_webhook_headers: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs']]]] = None,
                 general_webhook_method: Optional[pulumi.Input[str]] = None,
                 general_webhook_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_time: The end time.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] receiver_channels: The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] receiver_names: List of the receiver names.
        :param pulumi.Input[str] receiver_type: The receiver type, Can be set as: `User`(The id of user).
        :param pulumi.Input[str] start_time: The start time.
        :param pulumi.Input[str] alarm_content_template_id: The alarm content template id.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alarm_webhook_at_users: The alarm webhook at users.
        :param pulumi.Input[str] alarm_webhook_integration_id: The alarm webhook integration id.
        :param pulumi.Input[str] alarm_webhook_integration_name: The alarm webhook integration name.
        :param pulumi.Input[bool] alarm_webhook_is_at_all: The alarm webhook is at all.
        :param pulumi.Input[str] general_webhook_body: The webhook body.
        :param pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs']]] general_webhook_headers: The general webhook headers.
        :param pulumi.Input[str] general_webhook_method: The general webhook method.
        :param pulumi.Input[str] general_webhook_url: The webhook url.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "receiver_channels", receiver_channels)
        pulumi.set(__self__, "receiver_names", receiver_names)
        pulumi.set(__self__, "receiver_type", receiver_type)
        pulumi.set(__self__, "start_time", start_time)
        if alarm_content_template_id is not None:
            pulumi.set(__self__, "alarm_content_template_id", alarm_content_template_id)
        if alarm_webhook_at_users is not None:
            pulumi.set(__self__, "alarm_webhook_at_users", alarm_webhook_at_users)
        if alarm_webhook_integration_id is not None:
            pulumi.set(__self__, "alarm_webhook_integration_id", alarm_webhook_integration_id)
        if alarm_webhook_integration_name is not None:
            pulumi.set(__self__, "alarm_webhook_integration_name", alarm_webhook_integration_name)
        if alarm_webhook_is_at_all is not None:
            pulumi.set(__self__, "alarm_webhook_is_at_all", alarm_webhook_is_at_all)
        if general_webhook_body is not None:
            pulumi.set(__self__, "general_webhook_body", general_webhook_body)
        if general_webhook_headers is not None:
            pulumi.set(__self__, "general_webhook_headers", general_webhook_headers)
        if general_webhook_method is not None:
            pulumi.set(__self__, "general_webhook_method", general_webhook_method)
        if general_webhook_url is not None:
            pulumi.set(__self__, "general_webhook_url", general_webhook_url)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        """
        The end time.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="receiverChannels")
    def receiver_channels(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of the receiver channels. Currently supported channels: Email, Sms, Phone.
        """
        return pulumi.get(self, "receiver_channels")

    @receiver_channels.setter
    def receiver_channels(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "receiver_channels", value)

    @property
    @pulumi.getter(name="receiverNames")
    def receiver_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of the receiver names.
        """
        return pulumi.get(self, "receiver_names")

    @receiver_names.setter
    def receiver_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "receiver_names", value)

    @property
    @pulumi.getter(name="receiverType")
    def receiver_type(self) -> pulumi.Input[str]:
        """
        The receiver type, Can be set as: `User`(The id of user).
        """
        return pulumi.get(self, "receiver_type")

    @receiver_type.setter
    def receiver_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "receiver_type", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        The start time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="alarmContentTemplateId")
    def alarm_content_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm content template id.
        """
        return pulumi.get(self, "alarm_content_template_id")

    @alarm_content_template_id.setter
    def alarm_content_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_content_template_id", value)

    @property
    @pulumi.getter(name="alarmWebhookAtUsers")
    def alarm_webhook_at_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The alarm webhook at users.
        """
        return pulumi.get(self, "alarm_webhook_at_users")

    @alarm_webhook_at_users.setter
    def alarm_webhook_at_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alarm_webhook_at_users", value)

    @property
    @pulumi.getter(name="alarmWebhookIntegrationId")
    def alarm_webhook_integration_id(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm webhook integration id.
        """
        return pulumi.get(self, "alarm_webhook_integration_id")

    @alarm_webhook_integration_id.setter
    def alarm_webhook_integration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_webhook_integration_id", value)

    @property
    @pulumi.getter(name="alarmWebhookIntegrationName")
    def alarm_webhook_integration_name(self) -> Optional[pulumi.Input[str]]:
        """
        The alarm webhook integration name.
        """
        return pulumi.get(self, "alarm_webhook_integration_name")

    @alarm_webhook_integration_name.setter
    def alarm_webhook_integration_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alarm_webhook_integration_name", value)

    @property
    @pulumi.getter(name="alarmWebhookIsAtAll")
    def alarm_webhook_is_at_all(self) -> Optional[pulumi.Input[bool]]:
        """
        The alarm webhook is at all.
        """
        return pulumi.get(self, "alarm_webhook_is_at_all")

    @alarm_webhook_is_at_all.setter
    def alarm_webhook_is_at_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alarm_webhook_is_at_all", value)

    @property
    @pulumi.getter(name="generalWebhookBody")
    def general_webhook_body(self) -> Optional[pulumi.Input[str]]:
        """
        The webhook body.
        """
        return pulumi.get(self, "general_webhook_body")

    @general_webhook_body.setter
    def general_webhook_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_body", value)

    @property
    @pulumi.getter(name="generalWebhookHeaders")
    def general_webhook_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs']]]]:
        """
        The general webhook headers.
        """
        return pulumi.get(self, "general_webhook_headers")

    @general_webhook_headers.setter
    def general_webhook_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs']]]]):
        pulumi.set(self, "general_webhook_headers", value)

    @property
    @pulumi.getter(name="generalWebhookMethod")
    def general_webhook_method(self) -> Optional[pulumi.Input[str]]:
        """
        The general webhook method.
        """
        return pulumi.get(self, "general_webhook_method")

    @general_webhook_method.setter
    def general_webhook_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_method", value)

    @property
    @pulumi.getter(name="generalWebhookUrl")
    def general_webhook_url(self) -> Optional[pulumi.Input[str]]:
        """
        The webhook url.
        """
        return pulumi.get(self, "general_webhook_url")

    @general_webhook_url.setter
    def general_webhook_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "general_webhook_url", value)


@pulumi.input_type
class AlarmNotifyGroupReceiverGeneralWebhookHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the header.
        :param pulumi.Input[str] value: The value of the header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AlarmQueryRequestArgs:
    def __init__(__self__, *,
                 end_time_offset: pulumi.Input[int],
                 number: pulumi.Input[int],
                 query: pulumi.Input[str],
                 start_time_offset: pulumi.Input[int],
                 topic_id: pulumi.Input[str],
                 end_time_offset_unit: Optional[pulumi.Input[str]] = None,
                 start_time_offset_unit: Optional[pulumi.Input[str]] = None,
                 time_span_type: Optional[pulumi.Input[str]] = None,
                 truncated_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] end_time_offset: The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
        :param pulumi.Input[int] number: Alarm object sequence number; increments from 1.
        :param pulumi.Input[str] query: Query statement, the maximum supported length is 1024.
        :param pulumi.Input[int] start_time_offset: The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
        :param pulumi.Input[str] topic_id: The id of the topic.
        :param pulumi.Input[str] end_time_offset_unit: The end time offset unit.
        :param pulumi.Input[str] start_time_offset_unit: The start time offset unit.
        :param pulumi.Input[str] time_span_type: The time span type.
        :param pulumi.Input[str] truncated_time: The truncated time.
        """
        pulumi.set(__self__, "end_time_offset", end_time_offset)
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        pulumi.set(__self__, "topic_id", topic_id)
        if end_time_offset_unit is not None:
            pulumi.set(__self__, "end_time_offset_unit", end_time_offset_unit)
        if start_time_offset_unit is not None:
            pulumi.set(__self__, "start_time_offset_unit", start_time_offset_unit)
        if time_span_type is not None:
            pulumi.set(__self__, "time_span_type", time_span_type)
        if truncated_time is not None:
            pulumi.set(__self__, "truncated_time", truncated_time)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> pulumi.Input[int]:
        """
        The end time of the query range is relative to the current historical time. The unit is minutes. The value is not positive and must be greater than StartTimeOffset. The maximum value is 0 and the minimum value is -1440.
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[int]:
        """
        Alarm object sequence number; increments from 1.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[int]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        Query statement, the maximum supported length is 1024.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> pulumi.Input[int]:
        """
        The start time of the query range is relative to the current historical time, in minutes. The value is non-positive, the maximum value is 0, and the minimum value is -1440.
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_time_offset", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        The id of the topic.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)

    @property
    @pulumi.getter(name="endTimeOffsetUnit")
    def end_time_offset_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The end time offset unit.
        """
        return pulumi.get(self, "end_time_offset_unit")

    @end_time_offset_unit.setter
    def end_time_offset_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_offset_unit", value)

    @property
    @pulumi.getter(name="startTimeOffsetUnit")
    def start_time_offset_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The start time offset unit.
        """
        return pulumi.get(self, "start_time_offset_unit")

    @start_time_offset_unit.setter
    def start_time_offset_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_offset_unit", value)

    @property
    @pulumi.getter(name="timeSpanType")
    def time_span_type(self) -> Optional[pulumi.Input[str]]:
        """
        The time span type.
        """
        return pulumi.get(self, "time_span_type")

    @time_span_type.setter
    def time_span_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_span_type", value)

    @property
    @pulumi.getter(name="truncatedTime")
    def truncated_time(self) -> Optional[pulumi.Input[str]]:
        """
        The truncated time.
        """
        return pulumi.get(self, "truncated_time")

    @truncated_time.setter
    def truncated_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "truncated_time", value)


@pulumi.input_type
class AlarmRequestCycleArgs:
    def __init__(__self__, *,
                 cron_tab: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cron_tab: The cron tab.
        :param pulumi.Input[int] time: The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
        :param pulumi.Input[str] type: Execution cycle type.
        """
        if cron_tab is not None:
            pulumi.set(__self__, "cron_tab", cron_tab)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cronTab")
    def cron_tab(self) -> Optional[pulumi.Input[str]]:
        """
        The cron tab.
        """
        return pulumi.get(self, "cron_tab")

    @cron_tab.setter
    def cron_tab(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_tab", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[int]]:
        """
        The cycle of alarm task execution, or the time point of periodic execution. The unit is minutes, and the value range is 1~1440.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Execution cycle type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AlarmTriggerConditionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 count_condition: Optional[pulumi.Input[str]] = None,
                 no_data: Optional[pulumi.Input[bool]] = None,
                 severity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: The condition.
        :param pulumi.Input[str] count_condition: The count condition.
        :param pulumi.Input[bool] no_data: The no data.
        :param pulumi.Input[str] severity: The severity.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if count_condition is not None:
            pulumi.set(__self__, "count_condition", count_condition)
        if no_data is not None:
            pulumi.set(__self__, "no_data", no_data)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        The condition.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="countCondition")
    def count_condition(self) -> Optional[pulumi.Input[str]]:
        """
        The count condition.
        """
        return pulumi.get(self, "count_condition")

    @count_condition.setter
    def count_condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count_condition", value)

    @property
    @pulumi.getter(name="noData")
    def no_data(self) -> Optional[pulumi.Input[bool]]:
        """
        The no data.
        """
        return pulumi.get(self, "no_data")

    @no_data.setter
    def no_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_data", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        The severity.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)


@pulumi.input_type
class AlarmWebhookIntegrationWebhookHeaderArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the header.
        :param pulumi.Input[str] value: The value of the header.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key of the header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DownloadTaskLogContextInfosArgs:
    def __init__(__self__, *,
                 context_flow: Optional[pulumi.Input[str]] = None,
                 package_offset: Optional[pulumi.Input[int]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] context_flow: The context flow of the log.
        :param pulumi.Input[int] package_offset: The package offset of the log.
        :param pulumi.Input[str] source: The source of the log.
        """
        if context_flow is not None:
            pulumi.set(__self__, "context_flow", context_flow)
        if package_offset is not None:
            pulumi.set(__self__, "package_offset", package_offset)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="contextFlow")
    def context_flow(self) -> Optional[pulumi.Input[str]]:
        """
        The context flow of the log.
        """
        return pulumi.get(self, "context_flow")

    @context_flow.setter
    def context_flow(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "context_flow", value)

    @property
    @pulumi.getter(name="packageOffset")
    def package_offset(self) -> Optional[pulumi.Input[int]]:
        """
        The package offset of the log.
        """
        return pulumi.get(self, "package_offset")

    @package_offset.setter
    def package_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "package_offset", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the log.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class EtlTaskTargetResourceArgs:
    def __init__(__self__, *,
                 alias: pulumi.Input[str],
                 topic_id: pulumi.Input[str],
                 role_trn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alias: Customize the name of the output target, which needs to be used to refer to the output target in the data processing rules.
        :param pulumi.Input[str] topic_id: Log topics used for storing processed logs.
        :param pulumi.Input[str] role_trn: Cross-account authorized character names.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "topic_id", topic_id)
        if role_trn is not None:
            pulumi.set(__self__, "role_trn", role_trn)

    @property
    @pulumi.getter
    def alias(self) -> pulumi.Input[str]:
        """
        Customize the name of the output target, which needs to be used to refer to the output target in the data processing rules.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: pulumi.Input[str]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        Log topics used for storing processed logs.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)

    @property
    @pulumi.getter(name="roleTrn")
    def role_trn(self) -> Optional[pulumi.Input[str]]:
        """
        Cross-account authorized character names.
        """
        return pulumi.get(self, "role_trn")

    @role_trn.setter
    def role_trn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_trn", value)


@pulumi.input_type
class ImportTaskImportSourceInfoArgs:
    def __init__(__self__, *,
                 kafka_source_info: Optional[pulumi.Input['ImportTaskImportSourceInfoKafkaSourceInfoArgs']] = None,
                 tos_source_info: Optional[pulumi.Input['ImportTaskImportSourceInfoTosSourceInfoArgs']] = None):
        """
        :param pulumi.Input['ImportTaskImportSourceInfoKafkaSourceInfoArgs'] kafka_source_info: TOS imports source information.
        :param pulumi.Input['ImportTaskImportSourceInfoTosSourceInfoArgs'] tos_source_info: TOS imports source information.
        """
        if kafka_source_info is not None:
            pulumi.set(__self__, "kafka_source_info", kafka_source_info)
        if tos_source_info is not None:
            pulumi.set(__self__, "tos_source_info", tos_source_info)

    @property
    @pulumi.getter(name="kafkaSourceInfo")
    def kafka_source_info(self) -> Optional[pulumi.Input['ImportTaskImportSourceInfoKafkaSourceInfoArgs']]:
        """
        TOS imports source information.
        """
        return pulumi.get(self, "kafka_source_info")

    @kafka_source_info.setter
    def kafka_source_info(self, value: Optional[pulumi.Input['ImportTaskImportSourceInfoKafkaSourceInfoArgs']]):
        pulumi.set(self, "kafka_source_info", value)

    @property
    @pulumi.getter(name="tosSourceInfo")
    def tos_source_info(self) -> Optional[pulumi.Input['ImportTaskImportSourceInfoTosSourceInfoArgs']]:
        """
        TOS imports source information.
        """
        return pulumi.get(self, "tos_source_info")

    @tos_source_info.setter
    def tos_source_info(self, value: Optional[pulumi.Input['ImportTaskImportSourceInfoTosSourceInfoArgs']]):
        pulumi.set(self, "tos_source_info", value)


@pulumi.input_type
class ImportTaskImportSourceInfoKafkaSourceInfoArgs:
    def __init__(__self__, *,
                 encode: Optional[pulumi.Input[str]] = None,
                 group: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 initial_offset: Optional[pulumi.Input[int]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 is_need_auth: Optional[pulumi.Input[bool]] = None,
                 mechanism: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 time_source_default: Optional[pulumi.Input[int]] = None,
                 topic: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] encode: The encoding format of the data.
        :param pulumi.Input[str] group: Kafka consumer group.
        :param pulumi.Input[str] host: The service addresses corresponding to different types of Kafka clusters are different.
        :param pulumi.Input[int] initial_offset: The starting position of data import.
        :param pulumi.Input[str] instance_id: When you are using the Volcano Engine Message Queue Kafka version, it should be set to the Kafka instance ID.
        :param pulumi.Input[bool] is_need_auth: Whether to enable authentication.
        :param pulumi.Input[str] mechanism: Password authentication mechanism.
        :param pulumi.Input[str] password: The Kafka SASL user password used for identity authentication.
        :param pulumi.Input[str] protocol: Secure Transport protocol.
        :param pulumi.Input[int] time_source_default: Specify the log time.
        :param pulumi.Input[str] topic: Kafka Topic name.
        :param pulumi.Input[str] username: The Kafka SASL username used for identity authentication.
        """
        if encode is not None:
            pulumi.set(__self__, "encode", encode)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if initial_offset is not None:
            pulumi.set(__self__, "initial_offset", initial_offset)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if is_need_auth is not None:
            pulumi.set(__self__, "is_need_auth", is_need_auth)
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if time_source_default is not None:
            pulumi.set(__self__, "time_source_default", time_source_default)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def encode(self) -> Optional[pulumi.Input[str]]:
        """
        The encoding format of the data.
        """
        return pulumi.get(self, "encode")

    @encode.setter
    def encode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encode", value)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka consumer group.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The service addresses corresponding to different types of Kafka clusters are different.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="initialOffset")
    def initial_offset(self) -> Optional[pulumi.Input[int]]:
        """
        The starting position of data import.
        """
        return pulumi.get(self, "initial_offset")

    @initial_offset.setter
    def initial_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_offset", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        When you are using the Volcano Engine Message Queue Kafka version, it should be set to the Kafka instance ID.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="isNeedAuth")
    def is_need_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable authentication.
        """
        return pulumi.get(self, "is_need_auth")

    @is_need_auth.setter
    def is_need_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_need_auth", value)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[pulumi.Input[str]]:
        """
        Password authentication mechanism.
        """
        return pulumi.get(self, "mechanism")

    @mechanism.setter
    def mechanism(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mechanism", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka SASL user password used for identity authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Secure Transport protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="timeSourceDefault")
    def time_source_default(self) -> Optional[pulumi.Input[int]]:
        """
        Specify the log time.
        """
        return pulumi.get(self, "time_source_default")

    @time_source_default.setter
    def time_source_default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_source_default", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka Topic name.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka SASL username used for identity authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ImportTaskImportSourceInfoTosSourceInfoArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[str]] = None,
                 compress_type: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The TOS bucket where the log file is located.
        :param pulumi.Input[str] compress_type: The compression mode of data in the TOS bucket.
        :param pulumi.Input[str] prefix: The path of the file to be imported in the TOS bucket.
        :param pulumi.Input[str] region: The region where the TOS bucket is located. Support cross-regional data import.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if compress_type is not None:
            pulumi.set(__self__, "compress_type", compress_type)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The TOS bucket where the log file is located.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="compressType")
    def compress_type(self) -> Optional[pulumi.Input[str]]:
        """
        The compression mode of data in the TOS bucket.
        """
        return pulumi.get(self, "compress_type")

    @compress_type.setter
    def compress_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compress_type", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The path of the file to be imported in the TOS bucket.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region where the TOS bucket is located. Support cross-regional data import.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class ImportTaskTargetInfoArgs:
    def __init__(__self__, *,
                 log_type: pulumi.Input[str],
                 region: pulumi.Input[str],
                 extract_rule: Optional[pulumi.Input['ImportTaskTargetInfoExtractRuleArgs']] = None,
                 log_sample: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] log_type: Specify the log parsing type when importing.
        :param pulumi.Input[str] region: Regional ID.
        :param pulumi.Input['ImportTaskTargetInfoExtractRuleArgs'] extract_rule: Log extraction rules.
        :param pulumi.Input[str] log_sample: Log sample.
        """
        pulumi.set(__self__, "log_type", log_type)
        pulumi.set(__self__, "region", region)
        if extract_rule is not None:
            pulumi.set(__self__, "extract_rule", extract_rule)
        if log_sample is not None:
            pulumi.set(__self__, "log_sample", log_sample)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input[str]:
        """
        Specify the log parsing type when importing.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_type", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Regional ID.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="extractRule")
    def extract_rule(self) -> Optional[pulumi.Input['ImportTaskTargetInfoExtractRuleArgs']]:
        """
        Log extraction rules.
        """
        return pulumi.get(self, "extract_rule")

    @extract_rule.setter
    def extract_rule(self, value: Optional[pulumi.Input['ImportTaskTargetInfoExtractRuleArgs']]):
        pulumi.set(self, "extract_rule", value)

    @property
    @pulumi.getter(name="logSample")
    def log_sample(self) -> Optional[pulumi.Input[str]]:
        """
        Log sample.
        """
        return pulumi.get(self, "log_sample")

    @log_sample.setter
    def log_sample(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_sample", value)


@pulumi.input_type
class ImportTaskTargetInfoExtractRuleArgs:
    def __init__(__self__, *,
                 begin_regex: Optional[pulumi.Input[str]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote: Optional[pulumi.Input[str]] = None,
                 skip_line_count: Optional[pulumi.Input[int]] = None,
                 time_extract_regex: Optional[pulumi.Input[str]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 time_key: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 un_match_log_key: Optional[pulumi.Input[str]] = None,
                 un_match_up_load_switch: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] begin_regex: The regular expression used to identify the first line in each log, and its matching part will serve as the beginning of the log.
        :param pulumi.Input[str] delimiter: Log delimiter.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: List of log field names (Keys).
        :param pulumi.Input[str] quote: Reference symbol. The content wrapped by the reference will not be separated but will be parsed into a complete field. It is valid if and only if the LogType is delimiter_log.
        :param pulumi.Input[int] skip_line_count: The number of log lines skipped.
        :param pulumi.Input[str] time_extract_regex: A regular expression for extracting time, used to extract the time value in the TimeKey field and parse it into the corresponding collection time.
        :param pulumi.Input[str] time_format: The parsing format of the time field.
        :param pulumi.Input[str] time_key: The field name of the log time field.
        :param pulumi.Input[str] time_zone: Time zone, supporting both machine time zone (default) and custom time zone. Among them, the custom time zone supports GMT and UTC.
        :param pulumi.Input[str] un_match_log_key: When uploading a log that failed to parse, the key name of the parse failed log.
        :param pulumi.Input[bool] un_match_up_load_switch: Whether to upload the logs of failed parsing.
        """
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if quote is not None:
            pulumi.set(__self__, "quote", quote)
        if skip_line_count is not None:
            pulumi.set(__self__, "skip_line_count", skip_line_count)
        if time_extract_regex is not None:
            pulumi.set(__self__, "time_extract_regex", time_extract_regex)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The regular expression used to identify the first line in each log, and its matching part will serve as the beginning of the log.
        """
        return pulumi.get(self, "begin_regex")

    @begin_regex.setter
    def begin_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_regex", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Log delimiter.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of log field names (Keys).
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter
    def quote(self) -> Optional[pulumi.Input[str]]:
        """
        Reference symbol. The content wrapped by the reference will not be separated but will be parsed into a complete field. It is valid if and only if the LogType is delimiter_log.
        """
        return pulumi.get(self, "quote")

    @quote.setter
    def quote(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote", value)

    @property
    @pulumi.getter(name="skipLineCount")
    def skip_line_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of log lines skipped.
        """
        return pulumi.get(self, "skip_line_count")

    @skip_line_count.setter
    def skip_line_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_line_count", value)

    @property
    @pulumi.getter(name="timeExtractRegex")
    def time_extract_regex(self) -> Optional[pulumi.Input[str]]:
        """
        A regular expression for extracting time, used to extract the time value in the TimeKey field and parse it into the corresponding collection time.
        """
        return pulumi.get(self, "time_extract_regex")

    @time_extract_regex.setter
    def time_extract_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_extract_regex", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        The parsing format of the time field.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[str]]:
        """
        The field name of the log time field.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_key", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone, supporting both machine time zone (default) and custom time zone. Among them, the custom time zone supports GMT and UTC.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[str]]:
        """
        When uploading a log that failed to parse, the key name of the parse failed log.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "un_match_log_key", value)

    @property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to upload the logs of failed parsing.
        """
        return pulumi.get(self, "un_match_up_load_switch")

    @un_match_up_load_switch.setter
    def un_match_up_load_switch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "un_match_up_load_switch", value)


@pulumi.input_type
class IndexFullTextArgs:
    def __init__(__self__, *,
                 case_sensitive: pulumi.Input[bool],
                 delimiter: Optional[pulumi.Input[str]] = None,
                 include_chinese: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] case_sensitive: Whether the FullTextInfo is case sensitive.
        :param pulumi.Input[str] delimiter: The delimiter of the FullTextInfo.
        :param pulumi.Input[bool] include_chinese: Whether the FullTextInfo include chinese.
        """
        pulumi.set(__self__, "case_sensitive", case_sensitive)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> pulumi.Input[bool]:
        """
        Whether the FullTextInfo is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: pulumi.Input[bool]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter of the FullTextInfo.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the FullTextInfo include chinese.
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_chinese", value)


@pulumi.input_type
class IndexKeyValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value_type: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 include_chinese: Optional[pulumi.Input[bool]] = None,
                 index_all: Optional[pulumi.Input[bool]] = None,
                 json_keys: Optional[pulumi.Input[Sequence[pulumi.Input['IndexKeyValueJsonKeyArgs']]]] = None,
                 sql_flag: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] key: The key of the KeyValueInfo.
        :param pulumi.Input[str] value_type: The type of value. Valid values: `long`, `double`, `text`, `json`.
        :param pulumi.Input[bool] case_sensitive: Whether the value is case sensitive.
        :param pulumi.Input[str] delimiter: The delimiter of the value.
        :param pulumi.Input[bool] include_chinese: Whether the value include chinese.
        :param pulumi.Input[bool] index_all: Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `value_type` is `json`.
        :param pulumi.Input[Sequence[pulumi.Input['IndexKeyValueJsonKeyArgs']]] json_keys: The JSON subfield key value index.
        :param pulumi.Input[bool] sql_flag: Whether the filed is enabled for analysis.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value_type", value_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if index_all is not None:
            pulumi.set(__self__, "index_all", index_all)
        if json_keys is not None:
            pulumi.set(__self__, "json_keys", json_keys)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the KeyValueInfo.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[str]:
        """
        The type of value. Valid values: `long`, `double`, `text`, `json`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_type", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the value is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter of the value.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the value include chinese.
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_chinese", value)

    @property
    @pulumi.getter(name="indexAll")
    def index_all(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to create indexes for all fields in JSON fields with text values. This field is valid when the `value_type` is `json`.
        """
        return pulumi.get(self, "index_all")

    @index_all.setter
    def index_all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "index_all", value)

    @property
    @pulumi.getter(name="jsonKeys")
    def json_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexKeyValueJsonKeyArgs']]]]:
        """
        The JSON subfield key value index.
        """
        return pulumi.get(self, "json_keys")

    @json_keys.setter
    def json_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexKeyValueJsonKeyArgs']]]]):
        pulumi.set(self, "json_keys", value)

    @property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the filed is enabled for analysis.
        """
        return pulumi.get(self, "sql_flag")

    @sql_flag.setter
    def sql_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sql_flag", value)


@pulumi.input_type
class IndexKeyValueJsonKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the subfield key value index.
        :param pulumi.Input[str] value_type: The type of value. Valid values: `long`, `double`, `text`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the subfield key value index.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[str]:
        """
        The type of value. Valid values: `long`, `double`, `text`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_type", value)


@pulumi.input_type
class IndexUserInnerKeyValueArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value_type: pulumi.Input[str],
                 case_sensitive: Optional[pulumi.Input[bool]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 include_chinese: Optional[pulumi.Input[bool]] = None,
                 json_keys: Optional[pulumi.Input[Sequence[pulumi.Input['IndexUserInnerKeyValueJsonKeyArgs']]]] = None,
                 sql_flag: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] key: The key of the KeyValueInfo.
        :param pulumi.Input[str] value_type: The type of value. Valid values: `long`, `double`, `text`, `json`.
        :param pulumi.Input[bool] case_sensitive: Whether the value is case sensitive.
        :param pulumi.Input[str] delimiter: The delimiter of the value.
        :param pulumi.Input[bool] include_chinese: Whether the value include chinese.
        :param pulumi.Input[Sequence[pulumi.Input['IndexUserInnerKeyValueJsonKeyArgs']]] json_keys: The JSON subfield key value index.
        :param pulumi.Input[bool] sql_flag: Whether the filed is enabled for analysis.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value_type", value_type)
        if case_sensitive is not None:
            pulumi.set(__self__, "case_sensitive", case_sensitive)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_chinese is not None:
            pulumi.set(__self__, "include_chinese", include_chinese)
        if json_keys is not None:
            pulumi.set(__self__, "json_keys", json_keys)
        if sql_flag is not None:
            pulumi.set(__self__, "sql_flag", sql_flag)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the KeyValueInfo.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[str]:
        """
        The type of value. Valid values: `long`, `double`, `text`, `json`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_type", value)

    @property
    @pulumi.getter(name="caseSensitive")
    def case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the value is case sensitive.
        """
        return pulumi.get(self, "case_sensitive")

    @case_sensitive.setter
    def case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_sensitive", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter of the value.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="includeChinese")
    def include_chinese(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the value include chinese.
        """
        return pulumi.get(self, "include_chinese")

    @include_chinese.setter
    def include_chinese(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_chinese", value)

    @property
    @pulumi.getter(name="jsonKeys")
    def json_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IndexUserInnerKeyValueJsonKeyArgs']]]]:
        """
        The JSON subfield key value index.
        """
        return pulumi.get(self, "json_keys")

    @json_keys.setter
    def json_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IndexUserInnerKeyValueJsonKeyArgs']]]]):
        pulumi.set(self, "json_keys", value)

    @property
    @pulumi.getter(name="sqlFlag")
    def sql_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the filed is enabled for analysis.
        """
        return pulumi.get(self, "sql_flag")

    @sql_flag.setter
    def sql_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sql_flag", value)


@pulumi.input_type
class IndexUserInnerKeyValueJsonKeyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the subfield key value index.
        :param pulumi.Input[str] value_type: The type of value. Valid values: `long`, `double`, `text`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the subfield key value index.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[str]:
        """
        The type of value. Valid values: `long`, `double`, `text`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_type", value)


@pulumi.input_type
class ProjectTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The Key of Tags.
        :param pulumi.Input[str] value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ProjectsTagArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The Key of Tags.
        :param str value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleContainerRuleArgs:
    def __init__(__self__, *,
                 stream: pulumi.Input[str],
                 container_name_regex: Optional[pulumi.Input[str]] = None,
                 env_tag: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exclude_container_env_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exclude_container_label_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 include_container_env_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 include_container_label_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 kubernetes_rule: Optional[pulumi.Input['RuleContainerRuleKubernetesRuleArgs']] = None):
        """
        :param pulumi.Input[str] stream: The collection mode.
        :param pulumi.Input[str] container_name_regex: The name of the container to be collected.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] env_tag: Whether to add environment variables as log tags to raw log data.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclude_container_env_regex: The container environment variable blacklist is used to specify the range of containers not to be collected.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclude_container_label_regex: The container Label blacklist is used to specify the range of containers not to be collected.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] include_container_env_regex: The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] include_container_label_regex: The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
        :param pulumi.Input['RuleContainerRuleKubernetesRuleArgs'] kubernetes_rule: Collection rules for Kubernetes containers.
        """
        pulumi.set(__self__, "stream", stream)
        if container_name_regex is not None:
            pulumi.set(__self__, "container_name_regex", container_name_regex)
        if env_tag is not None:
            pulumi.set(__self__, "env_tag", env_tag)
        if exclude_container_env_regex is not None:
            pulumi.set(__self__, "exclude_container_env_regex", exclude_container_env_regex)
        if exclude_container_label_regex is not None:
            pulumi.set(__self__, "exclude_container_label_regex", exclude_container_label_regex)
        if include_container_env_regex is not None:
            pulumi.set(__self__, "include_container_env_regex", include_container_env_regex)
        if include_container_label_regex is not None:
            pulumi.set(__self__, "include_container_label_regex", include_container_label_regex)
        if kubernetes_rule is not None:
            pulumi.set(__self__, "kubernetes_rule", kubernetes_rule)

    @property
    @pulumi.getter
    def stream(self) -> pulumi.Input[str]:
        """
        The collection mode.
        """
        return pulumi.get(self, "stream")

    @stream.setter
    def stream(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream", value)

    @property
    @pulumi.getter(name="containerNameRegex")
    def container_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the container to be collected.
        """
        return pulumi.get(self, "container_name_regex")

    @container_name_regex.setter
    def container_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_name_regex", value)

    @property
    @pulumi.getter(name="envTag")
    def env_tag(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Whether to add environment variables as log tags to raw log data.
        """
        return pulumi.get(self, "env_tag")

    @env_tag.setter
    def env_tag(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "env_tag", value)

    @property
    @pulumi.getter(name="excludeContainerEnvRegex")
    def exclude_container_env_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The container environment variable blacklist is used to specify the range of containers not to be collected.
        """
        return pulumi.get(self, "exclude_container_env_regex")

    @exclude_container_env_regex.setter
    def exclude_container_env_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_container_env_regex", value)

    @property
    @pulumi.getter(name="excludeContainerLabelRegex")
    def exclude_container_label_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The container Label blacklist is used to specify the range of containers not to be collected.
        """
        return pulumi.get(self, "exclude_container_label_regex")

    @exclude_container_label_regex.setter
    def exclude_container_label_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_container_label_regex", value)

    @property
    @pulumi.getter(name="includeContainerEnvRegex")
    def include_container_env_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The container environment variable whitelist specifies the container to be collected through the container environment variable. If the whitelist is not enabled, it means that all containers are specified to be collected.
        """
        return pulumi.get(self, "include_container_env_regex")

    @include_container_env_regex.setter
    def include_container_env_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "include_container_env_regex", value)

    @property
    @pulumi.getter(name="includeContainerLabelRegex")
    def include_container_label_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The container label whitelist specifies the containers to be collected through the container label. If the whitelist is not enabled, all containers are specified to be collected.
        """
        return pulumi.get(self, "include_container_label_regex")

    @include_container_label_regex.setter
    def include_container_label_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "include_container_label_regex", value)

    @property
    @pulumi.getter(name="kubernetesRule")
    def kubernetes_rule(self) -> Optional[pulumi.Input['RuleContainerRuleKubernetesRuleArgs']]:
        """
        Collection rules for Kubernetes containers.
        """
        return pulumi.get(self, "kubernetes_rule")

    @kubernetes_rule.setter
    def kubernetes_rule(self, value: Optional[pulumi.Input['RuleContainerRuleKubernetesRuleArgs']]):
        pulumi.set(self, "kubernetes_rule", value)


@pulumi.input_type
class RuleContainerRuleKubernetesRuleArgs:
    def __init__(__self__, *,
                 annotation_tag: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 exclude_pod_label_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 include_pod_label_regex: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 label_tag: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 namespace_name_regex: Optional[pulumi.Input[str]] = None,
                 pod_name_regex: Optional[pulumi.Input[str]] = None,
                 workload_name_regex: Optional[pulumi.Input[str]] = None,
                 workload_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotation_tag: Whether to add Kubernetes Annotation as a log tag to the raw log data.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] exclude_pod_label_regex: Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] include_pod_label_regex: The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] label_tag: Whether to add Kubernetes Label as a log label to the original log data.
        :param pulumi.Input[str] namespace_name_regex: The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
        :param pulumi.Input[str] pod_name_regex: The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
        :param pulumi.Input[str] workload_name_regex: Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
        :param pulumi.Input[str] workload_type: Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
               Deployment: stateless workload.
               StatefulSet: stateful workload.
               DaemonSet: daemon process.
               Job: task.
               CronJob: scheduled task.
        """
        if annotation_tag is not None:
            pulumi.set(__self__, "annotation_tag", annotation_tag)
        if exclude_pod_label_regex is not None:
            pulumi.set(__self__, "exclude_pod_label_regex", exclude_pod_label_regex)
        if include_pod_label_regex is not None:
            pulumi.set(__self__, "include_pod_label_regex", include_pod_label_regex)
        if label_tag is not None:
            pulumi.set(__self__, "label_tag", label_tag)
        if namespace_name_regex is not None:
            pulumi.set(__self__, "namespace_name_regex", namespace_name_regex)
        if pod_name_regex is not None:
            pulumi.set(__self__, "pod_name_regex", pod_name_regex)
        if workload_name_regex is not None:
            pulumi.set(__self__, "workload_name_regex", workload_name_regex)
        if workload_type is not None:
            pulumi.set(__self__, "workload_type", workload_type)

    @property
    @pulumi.getter(name="annotationTag")
    def annotation_tag(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Whether to add Kubernetes Annotation as a log tag to the raw log data.
        """
        return pulumi.get(self, "annotation_tag")

    @annotation_tag.setter
    def annotation_tag(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotation_tag", value)

    @property
    @pulumi.getter(name="excludePodLabelRegex")
    def exclude_pod_label_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specify the containers not to be collected through the Pod Label blacklist, and not enable means to collect all containers.
        """
        return pulumi.get(self, "exclude_pod_label_regex")

    @exclude_pod_label_regex.setter
    def exclude_pod_label_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_pod_label_regex", value)

    @property
    @pulumi.getter(name="includePodLabelRegex")
    def include_pod_label_regex(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The Pod Label whitelist is used to specify containers to be collected. When the Pod Label whitelist is not enabled, it means that all containers are collected.
        """
        return pulumi.get(self, "include_pod_label_regex")

    @include_pod_label_regex.setter
    def include_pod_label_regex(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "include_pod_label_regex", value)

    @property
    @pulumi.getter(name="labelTag")
    def label_tag(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Whether to add Kubernetes Label as a log label to the original log data.
        """
        return pulumi.get(self, "label_tag")

    @label_tag.setter
    def label_tag(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "label_tag", value)

    @property
    @pulumi.getter(name="namespaceNameRegex")
    def namespace_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Kubernetes Namespace to be collected. If no Namespace name is specified, all containers will be collected. Namespace names support regular matching.
        """
        return pulumi.get(self, "namespace_name_regex")

    @namespace_name_regex.setter
    def namespace_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_name_regex", value)

    @property
    @pulumi.getter(name="podNameRegex")
    def pod_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The Pod name is used to specify the container to be collected. When no Pod name is specified, it means to collect all containers.
        """
        return pulumi.get(self, "pod_name_regex")

    @pod_name_regex.setter
    def pod_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_name_regex", value)

    @property
    @pulumi.getter(name="workloadNameRegex")
    def workload_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the container to be collected by the name of the workload. When no workload name is specified, all containers are collected. The workload name supports regular matching.
        """
        return pulumi.get(self, "workload_name_regex")

    @workload_name_regex.setter
    def workload_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_name_regex", value)

    @property
    @pulumi.getter(name="workloadType")
    def workload_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specify the containers to be collected by the type of workload, only one type can be selected. When no type is specified, it means all types of containers are collected. The supported types of workloads are:
        Deployment: stateless workload.
        StatefulSet: stateful workload.
        DaemonSet: daemon process.
        Job: task.
        CronJob: scheduled task.
        """
        return pulumi.get(self, "workload_type")

    @workload_type.setter
    def workload_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "workload_type", value)


@pulumi.input_type
class RuleExcludePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type: Collection path type. The path type can be `File` or `Path`.
        :param pulumi.Input[str] value: Collection path.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Collection path type. The path type can be `File` or `Path`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Collection path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleExtractRuleArgs:
    def __init__(__self__, *,
                 begin_regex: Optional[pulumi.Input[str]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 filter_key_regexes: Optional[pulumi.Input[Sequence[pulumi.Input['RuleExtractRuleFilterKeyRegexArgs']]]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 log_regex: Optional[pulumi.Input[str]] = None,
                 log_template: Optional[pulumi.Input['RuleExtractRuleLogTemplateArgs']] = None,
                 quote: Optional[pulumi.Input[str]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 time_key: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 un_match_log_key: Optional[pulumi.Input[str]] = None,
                 un_match_up_load_switch: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] begin_regex: The first log line needs to match the regular expression.
        :param pulumi.Input[str] delimiter: The delimiter of the log.
        :param pulumi.Input[Sequence[pulumi.Input['RuleExtractRuleFilterKeyRegexArgs']]] filter_key_regexes: The filter key list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: A list of log field names (Key).
        :param pulumi.Input[str] log_regex: The entire log needs to match the regular expression.
        :param pulumi.Input['RuleExtractRuleLogTemplateArgs'] log_template: Automatically extract log fields according to the specified log template.
        :param pulumi.Input[str] quote: The quote symbol.
        :param pulumi.Input[str] time_format: Parsing format of the time field.
        :param pulumi.Input[str] time_key: The field name of the log time field.
        :param pulumi.Input[str] time_zone: The time zone.
        :param pulumi.Input[str] un_match_log_key: When uploading the failed log, the key name of the failed log.
        :param pulumi.Input[bool] un_match_up_load_switch: Whether to upload the log of parsing failure.
        """
        if begin_regex is not None:
            pulumi.set(__self__, "begin_regex", begin_regex)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if filter_key_regexes is not None:
            pulumi.set(__self__, "filter_key_regexes", filter_key_regexes)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if log_regex is not None:
            pulumi.set(__self__, "log_regex", log_regex)
        if log_template is not None:
            pulumi.set(__self__, "log_template", log_template)
        if quote is not None:
            pulumi.set(__self__, "quote", quote)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_key is not None:
            pulumi.set(__self__, "time_key", time_key)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if un_match_log_key is not None:
            pulumi.set(__self__, "un_match_log_key", un_match_log_key)
        if un_match_up_load_switch is not None:
            pulumi.set(__self__, "un_match_up_load_switch", un_match_up_load_switch)

    @property
    @pulumi.getter(name="beginRegex")
    def begin_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The first log line needs to match the regular expression.
        """
        return pulumi.get(self, "begin_regex")

    @begin_regex.setter
    def begin_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "begin_regex", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The delimiter of the log.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="filterKeyRegexes")
    def filter_key_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleExtractRuleFilterKeyRegexArgs']]]]:
        """
        The filter key list.
        """
        return pulumi.get(self, "filter_key_regexes")

    @filter_key_regexes.setter
    def filter_key_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleExtractRuleFilterKeyRegexArgs']]]]):
        pulumi.set(self, "filter_key_regexes", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of log field names (Key).
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="logRegex")
    def log_regex(self) -> Optional[pulumi.Input[str]]:
        """
        The entire log needs to match the regular expression.
        """
        return pulumi.get(self, "log_regex")

    @log_regex.setter
    def log_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_regex", value)

    @property
    @pulumi.getter(name="logTemplate")
    def log_template(self) -> Optional[pulumi.Input['RuleExtractRuleLogTemplateArgs']]:
        """
        Automatically extract log fields according to the specified log template.
        """
        return pulumi.get(self, "log_template")

    @log_template.setter
    def log_template(self, value: Optional[pulumi.Input['RuleExtractRuleLogTemplateArgs']]):
        pulumi.set(self, "log_template", value)

    @property
    @pulumi.getter
    def quote(self) -> Optional[pulumi.Input[str]]:
        """
        The quote symbol.
        """
        return pulumi.get(self, "quote")

    @quote.setter
    def quote(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        Parsing format of the time field.
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter(name="timeKey")
    def time_key(self) -> Optional[pulumi.Input[str]]:
        """
        The field name of the log time field.
        """
        return pulumi.get(self, "time_key")

    @time_key.setter
    def time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_key", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="unMatchLogKey")
    def un_match_log_key(self) -> Optional[pulumi.Input[str]]:
        """
        When uploading the failed log, the key name of the failed log.
        """
        return pulumi.get(self, "un_match_log_key")

    @un_match_log_key.setter
    def un_match_log_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "un_match_log_key", value)

    @property
    @pulumi.getter(name="unMatchUpLoadSwitch")
    def un_match_up_load_switch(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to upload the log of parsing failure.
        """
        return pulumi.get(self, "un_match_up_load_switch")

    @un_match_up_load_switch.setter
    def un_match_up_load_switch(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "un_match_up_load_switch", value)


@pulumi.input_type
class RuleExtractRuleFilterKeyRegexArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 regex: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The name of the filter key.
        :param pulumi.Input[str] regex: The log content of the filter field needs to match the regular expression.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The name of the filter key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        The log content of the filter field needs to match the regular expression.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class RuleExtractRuleLogTemplateArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] format: Log template content.
        :param pulumi.Input[str] type: The type of the log template.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Log template content.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the log template.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RuleUserDefineRuleArgs:
    def __init__(__self__, *,
                 advanced: Optional[pulumi.Input['RuleUserDefineRuleAdvancedArgs']] = None,
                 enable_raw_log: Optional[pulumi.Input[bool]] = None,
                 fields: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 parse_path_rule: Optional[pulumi.Input['RuleUserDefineRuleParsePathRuleArgs']] = None,
                 plugin: Optional[pulumi.Input['RuleUserDefineRulePluginArgs']] = None,
                 shard_hash_key: Optional[pulumi.Input['RuleUserDefineRuleShardHashKeyArgs']] = None,
                 tail_files: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['RuleUserDefineRuleAdvancedArgs'] advanced: LogCollector extension configuration.
        :param pulumi.Input[bool] enable_raw_log: Whether to upload raw logs.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] fields: Add constant fields to logs.
        :param pulumi.Input['RuleUserDefineRuleParsePathRuleArgs'] parse_path_rule: Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
        :param pulumi.Input['RuleUserDefineRulePluginArgs'] plugin: Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
        :param pulumi.Input['RuleUserDefineRuleShardHashKeyArgs'] shard_hash_key: Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
        :param pulumi.Input[bool] tail_files: LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
        """
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if enable_raw_log is not None:
            pulumi.set(__self__, "enable_raw_log", enable_raw_log)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if parse_path_rule is not None:
            pulumi.set(__self__, "parse_path_rule", parse_path_rule)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if shard_hash_key is not None:
            pulumi.set(__self__, "shard_hash_key", shard_hash_key)
        if tail_files is not None:
            pulumi.set(__self__, "tail_files", tail_files)

    @property
    @pulumi.getter
    def advanced(self) -> Optional[pulumi.Input['RuleUserDefineRuleAdvancedArgs']]:
        """
        LogCollector extension configuration.
        """
        return pulumi.get(self, "advanced")

    @advanced.setter
    def advanced(self, value: Optional[pulumi.Input['RuleUserDefineRuleAdvancedArgs']]):
        pulumi.set(self, "advanced", value)

    @property
    @pulumi.getter(name="enableRawLog")
    def enable_raw_log(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to upload raw logs.
        """
        return pulumi.get(self, "enable_raw_log")

    @enable_raw_log.setter
    def enable_raw_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_raw_log", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Add constant fields to logs.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="parsePathRule")
    def parse_path_rule(self) -> Optional[pulumi.Input['RuleUserDefineRuleParsePathRuleArgs']]:
        """
        Rules for parsing collection paths. After the rules are set, the fields in the collection path will be extracted through the regular expressions specified in the rules, and added to the log data as metadata.
        """
        return pulumi.get(self, "parse_path_rule")

    @parse_path_rule.setter
    def parse_path_rule(self, value: Optional[pulumi.Input['RuleUserDefineRuleParsePathRuleArgs']]):
        pulumi.set(self, "parse_path_rule", value)

    @property
    @pulumi.getter
    def plugin(self) -> Optional[pulumi.Input['RuleUserDefineRulePluginArgs']]:
        """
        Plugin configuration. After the plugin configuration is enabled, one or more LogCollector processor plugins can be added to parse logs with complex or variable structures.
        """
        return pulumi.get(self, "plugin")

    @plugin.setter
    def plugin(self, value: Optional[pulumi.Input['RuleUserDefineRulePluginArgs']]):
        pulumi.set(self, "plugin", value)

    @property
    @pulumi.getter(name="shardHashKey")
    def shard_hash_key(self) -> Optional[pulumi.Input['RuleUserDefineRuleShardHashKeyArgs']]:
        """
        Rules for routing log partitions. Setting this parameter indicates that the HashKey routing shard mode is used when collecting logs, and Log Service will write the data to the shard containing the specified Key value.
        """
        return pulumi.get(self, "shard_hash_key")

    @shard_hash_key.setter
    def shard_hash_key(self, value: Optional[pulumi.Input['RuleUserDefineRuleShardHashKeyArgs']]):
        pulumi.set(self, "shard_hash_key", value)

    @property
    @pulumi.getter(name="tailFiles")
    def tail_files(self) -> Optional[pulumi.Input[bool]]:
        """
        LogCollector collection strategy, which specifies whether LogCollector collects incremental logs or full logs. The default is false, which means to collect all logs.
        """
        return pulumi.get(self, "tail_files")

    @tail_files.setter
    def tail_files(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tail_files", value)


@pulumi.input_type
class RuleUserDefineRuleAdvancedArgs:
    def __init__(__self__, *,
                 close_eof: Optional[pulumi.Input[bool]] = None,
                 close_inactive: Optional[pulumi.Input[int]] = None,
                 close_removed: Optional[pulumi.Input[bool]] = None,
                 close_renamed: Optional[pulumi.Input[bool]] = None,
                 close_timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] close_eof: Whether to release the log file handle after reading to the end of the log file. The default is false.
        :param pulumi.Input[int] close_inactive: The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
        :param pulumi.Input[bool] close_removed: After the log file is removed, whether to release the handle of the log file. The default is false.
        :param pulumi.Input[bool] close_renamed: After the log file is renamed, whether to release the handle of the log file. The default is false.
        :param pulumi.Input[int] close_timeout: The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
        """
        if close_eof is not None:
            pulumi.set(__self__, "close_eof", close_eof)
        if close_inactive is not None:
            pulumi.set(__self__, "close_inactive", close_inactive)
        if close_removed is not None:
            pulumi.set(__self__, "close_removed", close_removed)
        if close_renamed is not None:
            pulumi.set(__self__, "close_renamed", close_renamed)
        if close_timeout is not None:
            pulumi.set(__self__, "close_timeout", close_timeout)

    @property
    @pulumi.getter(name="closeEof")
    def close_eof(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to release the log file handle after reading to the end of the log file. The default is false.
        """
        return pulumi.get(self, "close_eof")

    @close_eof.setter
    def close_eof(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "close_eof", value)

    @property
    @pulumi.getter(name="closeInactive")
    def close_inactive(self) -> Optional[pulumi.Input[int]]:
        """
        The wait time to release the log file handle. When the log file has not written a new log for more than the specified time, release the handle of the log file.
        """
        return pulumi.get(self, "close_inactive")

    @close_inactive.setter
    def close_inactive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "close_inactive", value)

    @property
    @pulumi.getter(name="closeRemoved")
    def close_removed(self) -> Optional[pulumi.Input[bool]]:
        """
        After the log file is removed, whether to release the handle of the log file. The default is false.
        """
        return pulumi.get(self, "close_removed")

    @close_removed.setter
    def close_removed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "close_removed", value)

    @property
    @pulumi.getter(name="closeRenamed")
    def close_renamed(self) -> Optional[pulumi.Input[bool]]:
        """
        After the log file is renamed, whether to release the handle of the log file. The default is false.
        """
        return pulumi.get(self, "close_renamed")

    @close_renamed.setter
    def close_renamed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "close_renamed", value)

    @property
    @pulumi.getter(name="closeTimeout")
    def close_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum length of time that LogCollector monitors log files. The unit is seconds, and the default is 0 seconds, which means that there is no limit to the length of time LogCollector monitors log files.
        """
        return pulumi.get(self, "close_timeout")

    @close_timeout.setter
    def close_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "close_timeout", value)


@pulumi.input_type
class RuleUserDefineRuleParsePathRuleArgs:
    def __init__(__self__, *,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path_sample: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
        :param pulumi.Input[str] path_sample: Sample capture path for a real scene.
        :param pulumi.Input[str] regex: Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
        """
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if path_sample is not None:
            pulumi.set(__self__, "path_sample", path_sample)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of field names. Log Service will parse the path sample (PathSample) into multiple fields according to the regular expression (Regex), and Keys is used to specify the field name of each field.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="pathSample")
    def path_sample(self) -> Optional[pulumi.Input[str]]:
        """
        Sample capture path for a real scene.
        """
        return pulumi.get(self, "path_sample")

    @path_sample.setter
    def path_sample(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_sample", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regular expression for extracting path fields. It must match the collection path sample, otherwise it cannot be extracted successfully.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class RuleUserDefineRulePluginArgs:
    def __init__(__self__, *,
                 processors: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] processors: LogCollector plugin.
        """
        pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def processors(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        LogCollector plugin.
        """
        return pulumi.get(self, "processors")

    @processors.setter
    def processors(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "processors", value)


@pulumi.input_type
class RuleUserDefineRuleShardHashKeyArgs:
    def __init__(__self__, *,
                 hash_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] hash_key: The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
        """
        pulumi.set(__self__, "hash_key", hash_key)

    @property
    @pulumi.getter(name="hashKey")
    def hash_key(self) -> pulumi.Input[str]:
        """
        The HashKey of the log group is used to specify the partition (shard) to be written to by the current log group.
        """
        return pulumi.get(self, "hash_key")

    @hash_key.setter
    def hash_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key", value)


@pulumi.input_type
class ScheduleSqlTaskRequestCycleArgs:
    def __init__(__self__, *,
                 time: pulumi.Input[int],
                 type: pulumi.Input[str],
                 cron_tab: Optional[pulumi.Input[str]] = None,
                 cron_time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] time: The scheduling cycle or the time point of regular execution (the number of minutes away from 00:00), with a value range of 1 to 1440, and the unit is minutes.
        :param pulumi.Input[str] type: The type of Scheduling cycle.
        :param pulumi.Input[str] cron_tab: Cron expression. The log service specifies the timed execution of alarm tasks through the Cron expression. The minimum granularity of Cron expressions is minutes, 24 hours. For example, 0 18 * * * indicates that an alarm task is executed exactly at 18:00 every day.
        :param pulumi.Input[str] cron_time_zone: When setting the Type to Cron, the time zone also needs to be set.
        """
        pulumi.set(__self__, "time", time)
        pulumi.set(__self__, "type", type)
        if cron_tab is not None:
            pulumi.set(__self__, "cron_tab", cron_tab)
        if cron_time_zone is not None:
            pulumi.set(__self__, "cron_time_zone", cron_time_zone)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[int]:
        """
        The scheduling cycle or the time point of regular execution (the number of minutes away from 00:00), with a value range of 1 to 1440, and the unit is minutes.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[int]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of Scheduling cycle.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cronTab")
    def cron_tab(self) -> Optional[pulumi.Input[str]]:
        """
        Cron expression. The log service specifies the timed execution of alarm tasks through the Cron expression. The minimum granularity of Cron expressions is minutes, 24 hours. For example, 0 18 * * * indicates that an alarm task is executed exactly at 18:00 every day.
        """
        return pulumi.get(self, "cron_tab")

    @cron_tab.setter
    def cron_tab(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_tab", value)

    @property
    @pulumi.getter(name="cronTimeZone")
    def cron_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        When setting the Type to Cron, the time zone also needs to be set.
        """
        return pulumi.get(self, "cron_time_zone")

    @cron_time_zone.setter
    def cron_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_time_zone", value)


@pulumi.input_type
class SearchTracesQueryArgs:
    def __init__(__self__, *,
                 asc: Optional[bool] = None,
                 attributes: Optional[Sequence['SearchTracesQueryAttributeArgs']] = None,
                 duration_max: Optional[int] = None,
                 duration_min: Optional[int] = None,
                 kind: Optional[str] = None,
                 limit: Optional[int] = None,
                 offset: Optional[int] = None,
                 operation_name: Optional[str] = None,
                 order: Optional[str] = None,
                 service_name: Optional[str] = None,
                 start_time_max: Optional[int] = None,
                 start_time_min: Optional[int] = None,
                 status_code: Optional[str] = None,
                 trace_id: Optional[str] = None):
        """
        :param bool asc: Whether to sort results in ascending order. true means ascending, false means descending.
        :param Sequence['SearchTracesQueryAttributeArgs'] attributes: Attributes.
        :param int duration_max: Maximum trace duration in microseconds.
        :param int duration_min: Minimum trace duration in microseconds.
        :param str kind: Type of the trace.
        :param int limit: Maximum number of records to return, used for pagination.
        :param int offset: Offset for paginated query.
        :param str operation_name: Operation name, used to filter traces with specific operation.
        :param str order: Sorting field. Supported fields: Kind, Name, ServiceName, Start, End, Duration, and indexed fields in Attributes.
        :param str service_name: Service name, used to filter traces from specific service.
        :param int start_time_max: Maximum start time for searching traces, in microsecond timestamp format.
        :param int start_time_min: Minimum start time for searching traces, in microsecond timestamp format.
        :param str status_code: Trace status code, used to filter traces with specific status.
        :param str trace_id: Trace ID.
        """
        if asc is not None:
            pulumi.set(__self__, "asc", asc)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if duration_max is not None:
            pulumi.set(__self__, "duration_max", duration_max)
        if duration_min is not None:
            pulumi.set(__self__, "duration_min", duration_min)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if start_time_max is not None:
            pulumi.set(__self__, "start_time_max", start_time_max)
        if start_time_min is not None:
            pulumi.set(__self__, "start_time_min", start_time_min)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if trace_id is not None:
            pulumi.set(__self__, "trace_id", trace_id)

    @property
    @pulumi.getter
    def asc(self) -> Optional[bool]:
        """
        Whether to sort results in ascending order. true means ascending, false means descending.
        """
        return pulumi.get(self, "asc")

    @asc.setter
    def asc(self, value: Optional[bool]):
        pulumi.set(self, "asc", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence['SearchTracesQueryAttributeArgs']]:
        """
        Attributes.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[Sequence['SearchTracesQueryAttributeArgs']]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="durationMax")
    def duration_max(self) -> Optional[int]:
        """
        Maximum trace duration in microseconds.
        """
        return pulumi.get(self, "duration_max")

    @duration_max.setter
    def duration_max(self, value: Optional[int]):
        pulumi.set(self, "duration_max", value)

    @property
    @pulumi.getter(name="durationMin")
    def duration_min(self) -> Optional[int]:
        """
        Minimum trace duration in microseconds.
        """
        return pulumi.get(self, "duration_min")

    @duration_min.setter
    def duration_min(self, value: Optional[int]):
        pulumi.set(self, "duration_min", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of the trace.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Maximum number of records to return, used for pagination.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def offset(self) -> Optional[int]:
        """
        Offset for paginated query.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[int]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Operation name, used to filter traces with specific operation.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Sorting field. Supported fields: Kind, Name, ServiceName, Start, End, Duration, and indexed fields in Attributes.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name, used to filter traces from specific service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="startTimeMax")
    def start_time_max(self) -> Optional[int]:
        """
        Maximum start time for searching traces, in microsecond timestamp format.
        """
        return pulumi.get(self, "start_time_max")

    @start_time_max.setter
    def start_time_max(self, value: Optional[int]):
        pulumi.set(self, "start_time_max", value)

    @property
    @pulumi.getter(name="startTimeMin")
    def start_time_min(self) -> Optional[int]:
        """
        Minimum start time for searching traces, in microsecond timestamp format.
        """
        return pulumi.get(self, "start_time_min")

    @start_time_min.setter
    def start_time_min(self, value: Optional[int]):
        pulumi.set(self, "start_time_min", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        Trace status code, used to filter traces with specific status.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="traceId")
    def trace_id(self) -> Optional[str]:
        """
        Trace ID.
        """
        return pulumi.get(self, "trace_id")

    @trace_id.setter
    def trace_id(self, value: Optional[str]):
        pulumi.set(self, "trace_id", value)


@pulumi.input_type
class SearchTracesQueryAttributeArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Attribute key.
        :param str value: Attribute value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Attribute key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Attribute value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ShardShardArgs:
    def __init__(__self__, *,
                 exclusive_end_key: Optional[pulumi.Input[str]] = None,
                 inclusive_begin_key: Optional[pulumi.Input[str]] = None,
                 modify_time: Optional[pulumi.Input[str]] = None,
                 shard_id: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 stop_write_time: Optional[pulumi.Input[str]] = None,
                 topic_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exclusive_end_key: The exclusive end key of the shard.
        :param pulumi.Input[str] inclusive_begin_key: The inclusive begin key of the shard.
        :param pulumi.Input[str] modify_time: The modification time of the shard.
        :param pulumi.Input[int] shard_id: The ID of the shard to split.
        :param pulumi.Input[str] status: The status of the shard.
        :param pulumi.Input[str] stop_write_time: The stop write time of the shard.
        :param pulumi.Input[str] topic_id: The ID of the topic.
        """
        if exclusive_end_key is not None:
            pulumi.set(__self__, "exclusive_end_key", exclusive_end_key)
        if inclusive_begin_key is not None:
            pulumi.set(__self__, "inclusive_begin_key", inclusive_begin_key)
        if modify_time is not None:
            pulumi.set(__self__, "modify_time", modify_time)
        if shard_id is not None:
            pulumi.set(__self__, "shard_id", shard_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stop_write_time is not None:
            pulumi.set(__self__, "stop_write_time", stop_write_time)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter(name="exclusiveEndKey")
    def exclusive_end_key(self) -> Optional[pulumi.Input[str]]:
        """
        The exclusive end key of the shard.
        """
        return pulumi.get(self, "exclusive_end_key")

    @exclusive_end_key.setter
    def exclusive_end_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclusive_end_key", value)

    @property
    @pulumi.getter(name="inclusiveBeginKey")
    def inclusive_begin_key(self) -> Optional[pulumi.Input[str]]:
        """
        The inclusive begin key of the shard.
        """
        return pulumi.get(self, "inclusive_begin_key")

    @inclusive_begin_key.setter
    def inclusive_begin_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inclusive_begin_key", value)

    @property
    @pulumi.getter(name="modifyTime")
    def modify_time(self) -> Optional[pulumi.Input[str]]:
        """
        The modification time of the shard.
        """
        return pulumi.get(self, "modify_time")

    @modify_time.setter
    def modify_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modify_time", value)

    @property
    @pulumi.getter(name="shardId")
    def shard_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the shard to split.
        """
        return pulumi.get(self, "shard_id")

    @shard_id.setter
    def shard_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shard_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the shard.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="stopWriteTime")
    def stop_write_time(self) -> Optional[pulumi.Input[str]]:
        """
        The stop write time of the shard.
        """
        return pulumi.get(self, "stop_write_time")

    @stop_write_time.setter
    def stop_write_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stop_write_time", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the topic.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_id", value)


@pulumi.input_type
class ShipperContentInfoArgs:
    def __init__(__self__, *,
                 csv_info: Optional[pulumi.Input['ShipperContentInfoCsvInfoArgs']] = None,
                 format: Optional[pulumi.Input[str]] = None,
                 json_info: Optional[pulumi.Input['ShipperContentInfoJsonInfoArgs']] = None):
        """
        :param pulumi.Input['ShipperContentInfoCsvInfoArgs'] csv_info: CSV format log content configuration.
        :param pulumi.Input[str] format: Log content parsing format.
        :param pulumi.Input['ShipperContentInfoJsonInfoArgs'] json_info: JSON format log content configuration.
        """
        if csv_info is not None:
            pulumi.set(__self__, "csv_info", csv_info)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if json_info is not None:
            pulumi.set(__self__, "json_info", json_info)

    @property
    @pulumi.getter(name="csvInfo")
    def csv_info(self) -> Optional[pulumi.Input['ShipperContentInfoCsvInfoArgs']]:
        """
        CSV format log content configuration.
        """
        return pulumi.get(self, "csv_info")

    @csv_info.setter
    def csv_info(self, value: Optional[pulumi.Input['ShipperContentInfoCsvInfoArgs']]):
        pulumi.set(self, "csv_info", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Log content parsing format.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="jsonInfo")
    def json_info(self) -> Optional[pulumi.Input['ShipperContentInfoJsonInfoArgs']]:
        """
        JSON format log content configuration.
        """
        return pulumi.get(self, "json_info")

    @json_info.setter
    def json_info(self, value: Optional[pulumi.Input['ShipperContentInfoJsonInfoArgs']]):
        pulumi.set(self, "json_info", value)


@pulumi.input_type
class ShipperContentInfoCsvInfoArgs:
    def __init__(__self__, *,
                 delimiter: pulumi.Input[str],
                 escape_char: pulumi.Input[str],
                 keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 non_field_content: pulumi.Input[str],
                 print_header: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] delimiter: Delimiters are supported, including commas, tabs, vertical bars, semicolons, and Spaces.
        :param pulumi.Input[str] escape_char: When the field content contains a delimiter, use an escape character to wrap the field. Currently, only single quotes, double quotes, and null characters are supported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: Configure the fields that need to be delivered.
        :param pulumi.Input[str] non_field_content: Invalid field filling content, with a length ranging from 0 to 128.
        :param pulumi.Input[bool] print_header: Whether to print the Key on the first line.
        """
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "escape_char", escape_char)
        pulumi.set(__self__, "keys", keys)
        pulumi.set(__self__, "non_field_content", non_field_content)
        pulumi.set(__self__, "print_header", print_header)

    @property
    @pulumi.getter
    def delimiter(self) -> pulumi.Input[str]:
        """
        Delimiters are supported, including commas, tabs, vertical bars, semicolons, and Spaces.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: pulumi.Input[str]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> pulumi.Input[str]:
        """
        When the field content contains a delimiter, use an escape character to wrap the field. Currently, only single quotes, double quotes, and null characters are supported.
        """
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: pulumi.Input[str]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Configure the fields that need to be delivered.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="nonFieldContent")
    def non_field_content(self) -> pulumi.Input[str]:
        """
        Invalid field filling content, with a length ranging from 0 to 128.
        """
        return pulumi.get(self, "non_field_content")

    @non_field_content.setter
    def non_field_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "non_field_content", value)

    @property
    @pulumi.getter(name="printHeader")
    def print_header(self) -> pulumi.Input[bool]:
        """
        Whether to print the Key on the first line.
        """
        return pulumi.get(self, "print_header")

    @print_header.setter
    def print_header(self, value: pulumi.Input[bool]):
        pulumi.set(self, "print_header", value)


@pulumi.input_type
class ShipperContentInfoJsonInfoArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[bool],
                 escape: Optional[pulumi.Input[bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enable: Enable the flag.
        :param pulumi.Input[bool] escape: Whether to escape or not. It must be configured as true.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
        """
        pulumi.set(__self__, "enable", enable)
        if escape is not None:
            pulumi.set(__self__, "escape", escape)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)

    @property
    @pulumi.getter
    def enable(self) -> pulumi.Input[bool]:
        """
        Enable the flag.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter
    def escape(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to escape or not. It must be configured as true.
        """
        return pulumi.get(self, "escape")

    @escape.setter
    def escape(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "escape", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        When delivering in JSON format, if this parameter is not configured, it indicates that all fields have been delivered. Including __content__ (choice), __source__, __path__, __time__, __image_name__, __container_name__, __pod_name__, __pod_uid__, namespace, __tag____client_ip__, __tag____receive_time__.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)


@pulumi.input_type
class ShipperKafkaShipperInfoArgs:
    def __init__(__self__, *,
                 compress: pulumi.Input[str],
                 instance: pulumi.Input[str],
                 kafka_topic: pulumi.Input[str],
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] compress: Compression formats currently supported include snappy, gzip, lz4, and none.
        :param pulumi.Input[str] instance: Kafka instance.
        :param pulumi.Input[str] kafka_topic: The name of the Kafka Topic.
        :param pulumi.Input[int] end_time: Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
        :param pulumi.Input[int] start_time: Delivery start time, millisecond timestamp. If not configured, the default is the current time.
        """
        pulumi.set(__self__, "compress", compress)
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "kafka_topic", kafka_topic)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def compress(self) -> pulumi.Input[str]:
        """
        Compression formats currently supported include snappy, gzip, lz4, and none.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: pulumi.Input[str]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input[str]:
        """
        Kafka instance.
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="kafkaTopic")
    def kafka_topic(self) -> pulumi.Input[str]:
        """
        The name of the Kafka Topic.
        """
        return pulumi.get(self, "kafka_topic")

    @kafka_topic.setter
    def kafka_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "kafka_topic", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        """
        Delivery end time, millisecond timestamp. If not configured, it will keep delivering.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Delivery start time, millisecond timestamp. If not configured, the default is the current time.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ShipperTosShipperInfoArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 compress: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[int]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 partition_format: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: When choosing a TOS bucket, it must be located in the same region as the source log topic.
        :param pulumi.Input[str] compress: Compression formats currently supported include snappy, gzip, lz4, and none.
        :param pulumi.Input[int] interval: The delivery time interval, measured in seconds, ranges from 300 to 900.
        :param pulumi.Input[int] max_size: The maximum size of the original file that can be delivered to each partition (Shard), that is, the size of the uncompressed log file. The unit is MiB, and the value range is 5 to 256.
        :param pulumi.Input[str] partition_format: Partition rules for delivering logs.
        :param pulumi.Input[str] prefix: The top-level directory name of the storage bucket. All log data delivered through this delivery configuration will be delivered to this directory.
        """
        pulumi.set(__self__, "bucket", bucket)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if partition_format is not None:
            pulumi.set(__self__, "partition_format", partition_format)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        When choosing a TOS bucket, it must be located in the same region as the source log topic.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[str]]:
        """
        Compression formats currently supported include snappy, gzip, lz4, and none.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        The delivery time interval, measured in seconds, ranges from 300 to 900.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of the original file that can be delivered to each partition (Shard), that is, the size of the uncompressed log file. The unit is MiB, and the value range is 5 to 256.
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="partitionFormat")
    def partition_format(self) -> Optional[pulumi.Input[str]]:
        """
        Partition rules for delivering logs.
        """
        return pulumi.get(self, "partition_format")

    @partition_format.setter
    def partition_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition_format", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The top-level directory name of the storage bucket. All log data delivered through this delivery configuration will be delivered to this directory.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class TagResourceTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The Key of Tags.
        :param pulumi.Input[str] value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TagResourcesTagFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The key of the tag filter.
        :param Sequence[str] values: The values of the tag filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the tag filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TagTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The Key of Tags.
        :param pulumi.Input[str] value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TagsTagFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The key of the tag filter.
        :param Sequence[str] values: The values of the tag filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the tag filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class TopicEncryptConfArgs:
    def __init__(__self__, *,
                 enable: Optional[pulumi.Input[bool]] = None,
                 encrypt_type: Optional[pulumi.Input[str]] = None,
                 user_cmk_info: Optional[pulumi.Input['TopicEncryptConfUserCmkInfoArgs']] = None):
        """
        :param pulumi.Input[bool] enable: Whether to enable data encryption.
        :param pulumi.Input[str] encrypt_type: The encryption type.
        :param pulumi.Input['TopicEncryptConfUserCmkInfoArgs'] user_cmk_info: The user custom key.
        """
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if encrypt_type is not None:
            pulumi.set(__self__, "encrypt_type", encrypt_type)
        if user_cmk_info is not None:
            pulumi.set(__self__, "user_cmk_info", user_cmk_info)

    @property
    @pulumi.getter
    def enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable data encryption.
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="encryptType")
    def encrypt_type(self) -> Optional[pulumi.Input[str]]:
        """
        The encryption type.
        """
        return pulumi.get(self, "encrypt_type")

    @encrypt_type.setter
    def encrypt_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encrypt_type", value)

    @property
    @pulumi.getter(name="userCmkInfo")
    def user_cmk_info(self) -> Optional[pulumi.Input['TopicEncryptConfUserCmkInfoArgs']]:
        """
        The user custom key.
        """
        return pulumi.get(self, "user_cmk_info")

    @user_cmk_info.setter
    def user_cmk_info(self, value: Optional[pulumi.Input['TopicEncryptConfUserCmkInfoArgs']]):
        pulumi.set(self, "user_cmk_info", value)


@pulumi.input_type
class TopicEncryptConfUserCmkInfoArgs:
    def __init__(__self__, *,
                 region_id: Optional[pulumi.Input[str]] = None,
                 trn: Optional[pulumi.Input[str]] = None,
                 user_cmk_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region_id: The key region.
        :param pulumi.Input[str] trn: The key trn.
        :param pulumi.Input[str] user_cmk_id: The key id.
        """
        if region_id is not None:
            pulumi.set(__self__, "region_id", region_id)
        if trn is not None:
            pulumi.set(__self__, "trn", trn)
        if user_cmk_id is not None:
            pulumi.set(__self__, "user_cmk_id", user_cmk_id)

    @property
    @pulumi.getter(name="regionId")
    def region_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key region.
        """
        return pulumi.get(self, "region_id")

    @region_id.setter
    def region_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_id", value)

    @property
    @pulumi.getter
    def trn(self) -> Optional[pulumi.Input[str]]:
        """
        The key trn.
        """
        return pulumi.get(self, "trn")

    @trn.setter
    def trn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trn", value)

    @property
    @pulumi.getter(name="userCmkId")
    def user_cmk_id(self) -> Optional[pulumi.Input[str]]:
        """
        The key id.
        """
        return pulumi.get(self, "user_cmk_id")

    @user_cmk_id.setter
    def user_cmk_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_cmk_id", value)


@pulumi.input_type
class TopicTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The Key of Tags.
        :param pulumi.Input[str] value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TopicsTagArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The Key of Tags.
        :param str value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class TraceInstanceBackendConfigArgs:
    def __init__(__self__, *,
                 archive_ttl: Optional[pulumi.Input[int]] = None,
                 auto_split: Optional[pulumi.Input[bool]] = None,
                 cold_ttl: Optional[pulumi.Input[int]] = None,
                 enable_hot_ttl: Optional[pulumi.Input[bool]] = None,
                 hot_ttl: Optional[pulumi.Input[int]] = None,
                 max_split_partitions: Optional[pulumi.Input[int]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] archive_ttl: Archive storage duration in days.
        :param pulumi.Input[bool] auto_split: Whether to enable auto split.
        :param pulumi.Input[int] cold_ttl: Infrequent storage duration in days.
        :param pulumi.Input[bool] enable_hot_ttl: Whether to enable tiered storage.
        :param pulumi.Input[int] hot_ttl: Standard storage duration in days.
        :param pulumi.Input[int] max_split_partitions: Max split partitions.
        :param pulumi.Input[int] ttl: Total log retention time in days.
        """
        if archive_ttl is not None:
            pulumi.set(__self__, "archive_ttl", archive_ttl)
        if auto_split is not None:
            pulumi.set(__self__, "auto_split", auto_split)
        if cold_ttl is not None:
            pulumi.set(__self__, "cold_ttl", cold_ttl)
        if enable_hot_ttl is not None:
            pulumi.set(__self__, "enable_hot_ttl", enable_hot_ttl)
        if hot_ttl is not None:
            pulumi.set(__self__, "hot_ttl", hot_ttl)
        if max_split_partitions is not None:
            pulumi.set(__self__, "max_split_partitions", max_split_partitions)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="archiveTtl")
    def archive_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Archive storage duration in days.
        """
        return pulumi.get(self, "archive_ttl")

    @archive_ttl.setter
    def archive_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "archive_ttl", value)

    @property
    @pulumi.getter(name="autoSplit")
    def auto_split(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable auto split.
        """
        return pulumi.get(self, "auto_split")

    @auto_split.setter
    def auto_split(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_split", value)

    @property
    @pulumi.getter(name="coldTtl")
    def cold_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Infrequent storage duration in days.
        """
        return pulumi.get(self, "cold_ttl")

    @cold_ttl.setter
    def cold_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cold_ttl", value)

    @property
    @pulumi.getter(name="enableHotTtl")
    def enable_hot_ttl(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable tiered storage.
        """
        return pulumi.get(self, "enable_hot_ttl")

    @enable_hot_ttl.setter
    def enable_hot_ttl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_hot_ttl", value)

    @property
    @pulumi.getter(name="hotTtl")
    def hot_ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Standard storage duration in days.
        """
        return pulumi.get(self, "hot_ttl")

    @hot_ttl.setter
    def hot_ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hot_ttl", value)

    @property
    @pulumi.getter(name="maxSplitPartitions")
    def max_split_partitions(self) -> Optional[pulumi.Input[int]]:
        """
        Max split partitions.
        """
        return pulumi.get(self, "max_split_partitions")

    @max_split_partitions.setter
    def max_split_partitions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_split_partitions", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        Total log retention time in days.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class GetProjectsTagArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The Key of Tags.
        :param str value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetSearchTracesQueryArgs:
    def __init__(__self__, *,
                 asc: Optional[bool] = None,
                 attributes: Optional[Sequence['GetSearchTracesQueryAttributeArgs']] = None,
                 duration_max: Optional[int] = None,
                 duration_min: Optional[int] = None,
                 kind: Optional[str] = None,
                 limit: Optional[int] = None,
                 offset: Optional[int] = None,
                 operation_name: Optional[str] = None,
                 order: Optional[str] = None,
                 service_name: Optional[str] = None,
                 start_time_max: Optional[int] = None,
                 start_time_min: Optional[int] = None,
                 status_code: Optional[str] = None,
                 trace_id: Optional[str] = None):
        """
        :param bool asc: Whether to sort results in ascending order. true means ascending, false means descending.
        :param Sequence['GetSearchTracesQueryAttributeArgs'] attributes: Attributes.
        :param int duration_max: Maximum trace duration in microseconds.
        :param int duration_min: Minimum trace duration in microseconds.
        :param str kind: Type of the trace.
        :param int limit: Maximum number of records to return, used for pagination.
        :param int offset: Offset for paginated query.
        :param str operation_name: Operation name, used to filter traces with specific operation.
        :param str order: Sorting field. Supported fields: Kind, Name, ServiceName, Start, End, Duration, and indexed fields in Attributes.
        :param str service_name: Service name, used to filter traces from specific service.
        :param int start_time_max: Maximum start time for searching traces, in microsecond timestamp format.
        :param int start_time_min: Minimum start time for searching traces, in microsecond timestamp format.
        :param str status_code: Trace status code, used to filter traces with specific status.
        :param str trace_id: Trace ID.
        """
        if asc is not None:
            pulumi.set(__self__, "asc", asc)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if duration_max is not None:
            pulumi.set(__self__, "duration_max", duration_max)
        if duration_min is not None:
            pulumi.set(__self__, "duration_min", duration_min)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if offset is not None:
            pulumi.set(__self__, "offset", offset)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if start_time_max is not None:
            pulumi.set(__self__, "start_time_max", start_time_max)
        if start_time_min is not None:
            pulumi.set(__self__, "start_time_min", start_time_min)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if trace_id is not None:
            pulumi.set(__self__, "trace_id", trace_id)

    @property
    @pulumi.getter
    def asc(self) -> Optional[bool]:
        """
        Whether to sort results in ascending order. true means ascending, false means descending.
        """
        return pulumi.get(self, "asc")

    @asc.setter
    def asc(self, value: Optional[bool]):
        pulumi.set(self, "asc", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Sequence['GetSearchTracesQueryAttributeArgs']]:
        """
        Attributes.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[Sequence['GetSearchTracesQueryAttributeArgs']]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="durationMax")
    def duration_max(self) -> Optional[int]:
        """
        Maximum trace duration in microseconds.
        """
        return pulumi.get(self, "duration_max")

    @duration_max.setter
    def duration_max(self, value: Optional[int]):
        pulumi.set(self, "duration_max", value)

    @property
    @pulumi.getter(name="durationMin")
    def duration_min(self) -> Optional[int]:
        """
        Minimum trace duration in microseconds.
        """
        return pulumi.get(self, "duration_min")

    @duration_min.setter
    def duration_min(self, value: Optional[int]):
        pulumi.set(self, "duration_min", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Type of the trace.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Maximum number of records to return, used for pagination.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def offset(self) -> Optional[int]:
        """
        Offset for paginated query.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: Optional[int]):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Operation name, used to filter traces with specific operation.
        """
        return pulumi.get(self, "operation_name")

    @operation_name.setter
    def operation_name(self, value: Optional[str]):
        pulumi.set(self, "operation_name", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Sorting field. Supported fields: Kind, Name, ServiceName, Start, End, Duration, and indexed fields in Attributes.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name, used to filter traces from specific service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="startTimeMax")
    def start_time_max(self) -> Optional[int]:
        """
        Maximum start time for searching traces, in microsecond timestamp format.
        """
        return pulumi.get(self, "start_time_max")

    @start_time_max.setter
    def start_time_max(self, value: Optional[int]):
        pulumi.set(self, "start_time_max", value)

    @property
    @pulumi.getter(name="startTimeMin")
    def start_time_min(self) -> Optional[int]:
        """
        Minimum start time for searching traces, in microsecond timestamp format.
        """
        return pulumi.get(self, "start_time_min")

    @start_time_min.setter
    def start_time_min(self, value: Optional[int]):
        pulumi.set(self, "start_time_min", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[str]:
        """
        Trace status code, used to filter traces with specific status.
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[str]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter(name="traceId")
    def trace_id(self) -> Optional[str]:
        """
        Trace ID.
        """
        return pulumi.get(self, "trace_id")

    @trace_id.setter
    def trace_id(self, value: Optional[str]):
        pulumi.set(self, "trace_id", value)


@pulumi.input_type
class GetSearchTracesQueryAttributeArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Attribute key.
        :param str value: Attribute value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Attribute key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Attribute value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


@pulumi.input_type
class GetTagResourcesTagFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The key of the tag filter.
        :param Sequence[str] values: The values of the tag filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the tag filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetTagsTagFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str]):
        """
        :param str key: The key of the tag filter.
        :param Sequence[str] values: The values of the tag filter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the tag filter.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values of the tag filter.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetTopicsTagArgs:
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The Key of Tags.
        :param str value: The Value of Tags.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The Key of Tags.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Value of Tags.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


