// TypeQL Schema Grammar for TypeBridge Generator
// Based on TypeDB 3.0 syntax

start: define_block*

define_block: "define" statement+

statement: attribute_def
         | entity_def
         | relation_def
         | function_def
         | struct_def
         | comment_annotation

// --- Attributes ---
attribute_def: "attribute" IDENTIFIER [attribute_opts] ";"

// Allow optional commas between options for flexibility
attribute_opts: (","? (sub_clause | abstract_annotation | independent_annotation | value_type_clause | regex_annotation | values_annotation | range_annotation))+

// Match the entire range value flexibly - will be parsed in the transformer
range_annotation: "@range" "(" RANGE_EXPR ")"
RANGE_EXPR: /[^)]+/

sub_clause: "sub" IDENTIFIER
value_type_clause: "value" value_type
regex_annotation: "@regex" "(" STRING ")"
values_annotation: "@values" "(" string_list ")"
abstract_annotation: "@abstract"
independent_annotation: "@independent"

// --- Entities ---
entity_def: "entity" IDENTIFIER (","? entity_clause)* ";"

entity_clause: sub_clause | abstract_annotation | owns_statement | plays_statement

owns_statement: "owns" IDENTIFIER [owns_opts]

owns_opts: (key_annotation | unique_annotation | cascade_annotation | subkey_annotation | card_annotation)+
key_annotation: "@key"
unique_annotation: "@unique"
cascade_annotation: "@cascade"
subkey_annotation: "@subkey" "(" IDENTIFIER ")"
card_annotation: "@card" "(" INT [DOT_DOT [INT]] ")"

plays_statement: "plays" IDENTIFIER [":" IDENTIFIER] [card_annotation]

// --- Relations ---
relation_def: "relation" IDENTIFIER (","? relation_clause)* ";"

relation_clause: sub_clause | abstract_annotation | relates_statement | owns_statement | plays_statement

relates_statement: "relates" IDENTIFIER ["as" IDENTIFIER] [relates_opts]
relates_opts: (card_annotation | distinct_annotation)+
distinct_annotation: "@distinct"

// --- Structs (TypeDB 3.0) ---
struct_def: "struct" IDENTIFIER ","? struct_fields ";"
struct_fields: struct_field (","? struct_field)* ","?
struct_field: "value" IDENTIFIER value_type OPTIONAL?

// --- Functions ---
function_def: "fun" IDENTIFIER "(" param_list? ")" "->" return_type_clause ":" func_body

param_list: param ("," param)*
param: "$" IDENTIFIER ":" (VALUE_TYPE_NAME | IDENTIFIER)

// Match function body - any content up to and including a return statement ending with ;
func_body: /.*?return[^;]*;/s

// Return types: stream { type, ... }, single type, or tuple type1, type2
return_type_clause: stream_return | single_return
stream_return: "{" return_type_list "}"
single_return: return_type_list
return_type_list: return_type ("," return_type)*
return_type: (IDENTIFIER | VALUE_TYPE_NAME) OPTIONAL?
OPTIONAL: "?"

// --- Common ---
value_type: VALUE_TYPE_NAME

VALUE_TYPE_NAME: "string" | "integer" | "int" | "long" | "double" | "boolean" | "bool" | "date" | "datetime" | "datetime-tz" | "decimal" | "duration"

string_list: STRING ("," STRING)*

// Custom annotations in comments: # @name or # @name(value) or # @name(a, b, c)
comment_annotation: /#\s*@[\w-]+(?:\([^)]*\))?/

// Note: This ASCII pattern covers common use cases. For full Unicode XID support
// (TypeQL 3.8.0+), see type_bridge.validation._is_xid_start/_is_xid_continue
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_-]*/
STRING: /"[^"]*"/ | /'[^']*'/
INT: /[0-9]+/
DOT_DOT: ".."
// Range values: ISO dates/datetimes, OR integers/floats (with optional sign)
// Date patterns must come first to avoid partial matching
RANGE_VALUE: /\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/ | /-?[0-9]+(\.[0-9]+)?/

%import common.WS
%import common.SH_COMMENT
%import common.CPP_COMMENT
%ignore WS
%ignore SH_COMMENT
%ignore CPP_COMMENT
