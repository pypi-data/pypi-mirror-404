"""TypeBridge registry - Pre-computed schema metadata.

This module provides static, type-safe access to schema information
without runtime introspection. All data is computed at generation time.
"""

from __future__ import annotations

from dataclasses import dataclass
from enum import StrEnum
from typing import TYPE_CHECKING

from . import attributes, entities, relations

if TYPE_CHECKING:
    from type_bridge import Attribute, Entity, Relation

# ======================================================================
# SCHEMA METADATA
# ======================================================================

SCHEMA_VERSION: str = "{{ schema_version }}"
SCHEMA_HASH: str = "{{ schema_hash }}"

# ======================================================================
# TYPE NAME COLLECTIONS
# ======================================================================

ENTITY_TYPES: tuple[str, ...] = (
{% for name in entity_names %}
    "{{ name }}",
{% endfor %}
)

RELATION_TYPES: tuple[str, ...] = (
{% for name in relation_names %}
    "{{ name }}",
{% endfor %}
)

ATTRIBUTE_TYPES: tuple[str, ...] = (
{% for name in attribute_names %}
    "{{ name }}",
{% endfor %}
)

# ======================================================================
# TYPE NAME ENUMS (for API validation, Pydantic models)
# ======================================================================

class EntityType(StrEnum):
    """Enum of all entity type names."""
{% if entity_names %}
{% for name in entity_names %}
    {{ name | upper | replace("-", "_") }} = "{{ name }}"
{% endfor %}
{% else %}
    pass
{% endif %}


class RelationType(StrEnum):
    """Enum of all relation type names."""
{% if relation_names %}
{% for name in relation_names %}
    {{ name | upper | replace("-", "_") }} = "{{ name }}"
{% endfor %}
{% else %}
    pass
{% endif %}


class AttributeType(StrEnum):
    """Enum of all attribute type names."""
{% if attribute_names %}
{% for name in attribute_names %}
    {{ name | upper | replace("-", "_") }} = "{{ name }}"
{% endfor %}
{% else %}
    pass
{% endif %}

# ======================================================================
# TYPE-TO-CLASS MAPPINGS
# ======================================================================

ENTITY_MAP: dict[str, type["Entity"]] = {
{% for name, class_name in entity_map.items() %}
    "{{ name }}": entities.{{ class_name }},
{% endfor %}
}

RELATION_MAP: dict[str, type["Relation"]] = {
{% for name, class_name in relation_map.items() %}
    "{{ name }}": relations.{{ class_name }},
{% endfor %}
}

ATTRIBUTE_MAP: dict[str, type["Attribute"]] = {
{% for name, class_name in attribute_map.items() %}
    "{{ name }}": attributes.{{ class_name }},
{% endfor %}
}

# ======================================================================
# RELATION ROLE METADATA
# ======================================================================

@dataclass(frozen=True, slots=True)
class RoleInfo:
    """Metadata for a relation role."""

    role_name: str
    player_types: tuple[str, ...]


RELATION_ROLES: dict[str, dict[str, RoleInfo]] = {
{% for rel_name, roles in relation_roles.items() %}
    "{{ rel_name }}": {
{% for role in roles %}
        "{{ role.name }}": RoleInfo("{{ role.name }}", ({{ role.players | map('tojson') | join(', ') }}{% if role.players | length == 1 %},{% endif %})),
{% endfor %}
    },
{% endfor %}
}

# ======================================================================
# ENTITY ATTRIBUTE METADATA
# ======================================================================

ENTITY_ATTRIBUTES: dict[str, frozenset[str]] = {
{% for name, attrs in entity_attributes.items() %}
{% if attrs %}
    "{{ name }}": frozenset({{"{"}}{{ attrs | map('tojson') | join(', ') }}{{"}"}}),
{% else %}
    "{{ name }}": frozenset(),
{% endif %}
{% endfor %}
}

ENTITY_KEYS: dict[str, frozenset[str]] = {
{% for name, keys in entity_keys.items() %}
{% if keys %}
    "{{ name }}": frozenset({{"{"}}{{ keys | map('tojson') | join(', ') }}{{"}"}}),
{% endif %}
{% endfor %}
}

# ======================================================================
# ATTRIBUTE VALUE TYPES
# ======================================================================

ATTRIBUTE_VALUE_TYPES: dict[str, str] = {
{% for name, value_type in attribute_value_types.items() %}
    "{{ name }}": "{{ value_type }}",
{% endfor %}
}

# ======================================================================
# INHERITANCE METADATA
# ======================================================================

ENTITY_PARENTS: dict[str, str | None] = {
{% for name, parent in entity_parents.items() %}
{% if parent %}
    "{{ name }}": "{{ parent }}",
{% else %}
    "{{ name }}": None,
{% endif %}
{% endfor %}
}

RELATION_PARENTS: dict[str, str | None] = {
{% for name, parent in relation_parents.items() %}
{% if parent %}
    "{{ name }}": "{{ parent }}",
{% else %}
    "{{ name }}": None,
{% endif %}
{% endfor %}
}

ENTITY_ABSTRACT: frozenset[str] = frozenset({
{% for name in entity_abstract %}
    "{{ name }}",
{% endfor %}
})

RELATION_ABSTRACT: frozenset[str] = frozenset({
{% for name in relation_abstract %}
    "{{ name }}",
{% endfor %}
})

# ======================================================================
# CUSTOM ANNOTATIONS (from TQL comments)
# ======================================================================

ENTITY_ANNOTATIONS: dict[str, dict[str, bool | int | float | str | list]] = {
{% for name, annots in entity_annotations.items() %}
    "{{ name }}": {
{% for key, value in annots.items() %}
        "{{ key }}": {{ value | render_annotation }},
{% endfor %}
    },
{% endfor %}
}

ATTRIBUTE_ANNOTATIONS: dict[str, dict[str, bool | int | float | str | list]] = {
{% for name, annots in attribute_annotations.items() %}
    "{{ name }}": {
{% for key, value in annots.items() %}
        "{{ key }}": {{ value | render_annotation }},
{% endfor %}
    },
{% endfor %}
}

RELATION_ANNOTATIONS: dict[str, dict[str, bool | int | float | str | list]] = {
{% for name, annots in relation_annotations.items() %}
    "{{ name }}": {
{% for key, value in annots.items() %}
        "{{ key }}": {{ value | render_annotation }},
{% endfor %}
    },
{% endfor %}
}

# ======================================================================
# JSON SCHEMA FRAGMENTS (for LLM tools, OpenAPI)
# ======================================================================

ENTITY_TYPE_JSON_SCHEMA: dict = {
    "type": "string",
    "enum": list(ENTITY_TYPES),
    "description": "Valid entity type names",
}

RELATION_TYPE_JSON_SCHEMA: dict = {
    "type": "string",
    "enum": list(RELATION_TYPES),
    "description": "Valid relation type names",
}

ATTRIBUTE_TYPE_JSON_SCHEMA: dict = {
    "type": "string",
    "enum": list(ATTRIBUTE_TYPES),
    "description": "Valid attribute type names",
}

# ======================================================================
# CONVENIENCE FUNCTIONS
# ======================================================================


def get_entity_class(type_name: str) -> type["Entity"] | None:
    """Get entity class by TypeDB type name."""
    return ENTITY_MAP.get(type_name)


def get_relation_class(type_name: str) -> type["Relation"] | None:
    """Get relation class by TypeDB type name."""
    return RELATION_MAP.get(type_name)


def get_attribute_class(type_name: str) -> type["Attribute"] | None:
    """Get attribute class by TypeDB type name."""
    return ATTRIBUTE_MAP.get(type_name)


def get_role_players(relation_type: str, role_name: str) -> tuple[str, ...]:
    """Get allowed player entity types for a relation role."""
    roles = RELATION_ROLES.get(relation_type, {})
    role_info = roles.get(role_name)
    return role_info.player_types if role_info else ()


def get_entity_attributes(entity_type: str) -> frozenset[str]:
    """Get attribute names owned by an entity type."""
    return ENTITY_ATTRIBUTES.get(entity_type, frozenset())


def get_entity_keys(entity_type: str) -> frozenset[str]:
    """Get key attribute names for an entity type."""
    return ENTITY_KEYS.get(entity_type, frozenset())


def is_abstract_entity(entity_type: str) -> bool:
    """Check if an entity type is abstract."""
    return entity_type in ENTITY_ABSTRACT


def is_abstract_relation(relation_type: str) -> bool:
    """Check if a relation type is abstract."""
    return relation_type in RELATION_ABSTRACT


__all__ = [
    "SCHEMA_VERSION",
    "SCHEMA_HASH",
    "ENTITY_TYPES",
    "RELATION_TYPES",
    "ATTRIBUTE_TYPES",
    "EntityType",
    "RelationType",
    "AttributeType",
    "ENTITY_MAP",
    "RELATION_MAP",
    "ATTRIBUTE_MAP",
    "RoleInfo",
    "RELATION_ROLES",
    "ENTITY_ATTRIBUTES",
    "ENTITY_KEYS",
    "ATTRIBUTE_VALUE_TYPES",
    "ENTITY_PARENTS",
    "RELATION_PARENTS",
    "ENTITY_ABSTRACT",
    "RELATION_ABSTRACT",
    "ENTITY_ANNOTATIONS",
    "ATTRIBUTE_ANNOTATIONS",
    "RELATION_ANNOTATIONS",
    "ENTITY_TYPE_JSON_SCHEMA",
    "RELATION_TYPE_JSON_SCHEMA",
    "ATTRIBUTE_TYPE_JSON_SCHEMA",
    "get_entity_class",
    "get_relation_class",
    "get_attribute_class",
    "get_role_players",
    "get_entity_attributes",
    "get_entity_keys",
    "is_abstract_entity",
    "is_abstract_relation",
]
