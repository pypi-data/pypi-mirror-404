"""
Exploit Chain Correlation Module
Chains multiple findings into exploit paths
"""

from typing import Dict, Any, List


class ExploitChainer:
    """Correlate findings into exploit chains"""
    
    def __init__(self, results: Dict[str, Any], config):
        self.results = results
        self.config = config
    
    def chain(self) -> List[Dict[str, Any]]:
        """
        Find exploit chains by correlating vulnerabilities
        
        REASONING: Multi-hop chains (3-5 steps) show realistic attack paths
        Impact classification helps prioritize remediation
        
        Returns:
            List of exploit chains with impact classification
        """
        chains = []
        
        # Chain 1: Debuggable + Exported Activity → Runtime Manipulation
        chains.extend(self._chain_debuggable_export())
        
        # Chain 2: Hardcoded API Key + Admin Endpoint → Account Takeover
        chains.extend(self._chain_secret_endpoint())
        
        # Chain 3: Backup + Sensitive Data → Data Exfiltration
        chains.extend(self._chain_backup_data())
        
        # Chain 4: Deep Link + Exported Activity → Auth Bypass
        chains.extend(self._chain_deeplink_activity())
        
        # Chain 5: WebView + Exported Activity → XSS to RCE
        chains.extend(self._chain_webview_export())
        
        # Chain 6: Client Auth + IDOR → Privilege Escalation
        chains.extend(self._chain_client_auth_idor())
        
        # Chain 7: Weak Crypto + Backup → Credential Theft
        chains.extend(self._chain_weak_crypto_backup())
        
        # Chain 8: PendingIntent + Broadcast → Intent Hijacking
        chains.extend(self._chain_pending_intent())
        
        return chains
    
    def _chain_debuggable_export(self) -> List[Dict[str, Any]]:
        """Chain: Debuggable app + Exported components"""
        chains = []
        
        security_flags = self.results.get('security_flags', {})
        components = self.results.get('components', {})
        
        is_debuggable = security_flags.get('debuggable', False)
        exported_activities = components.get('exported_activities', [])
        
        if is_debuggable and exported_activities:
            # Generate human-readable attack narrative
            narrative = (
                f"An attacker can exploit the debuggable flag to attach a debugger to the running application. "
                f"With {len(exported_activities)} exported activities available, the attacker can launch any of these "
                f"activities externally and then manipulate the app's runtime behavior, bypassing authentication checks, "
                f"modifying business logic, or extracting sensitive data from memory. This represents a complete "
                f"application compromise."
            )
            
            chains.append({
                'title': 'Runtime Manipulation via Debuggable Exported Activity',
                'severity': 'critical',
                'impact_type': 'Account Takeover',  # Impact classification
                'narrative': narrative,  # Human-readable attack story
                'preconditions': [
                    'Physical or ADB access to device',
                    'App must be running',
                    'USB debugging enabled'
                ],
                'steps': [
                    'App is debuggable (android:debuggable="true")',
                    f'Found {len(exported_activities)} exported activities',
                    'Attacker can attach debugger to running app',
                    'Manipulate runtime behavior and bypass security checks'
                ],
                'impact': 'Complete application compromise - attacker can modify app behavior in real-time',
                'business_impact': 'Full account takeover, unauthorized transactions, data theft, and reputational damage',
                'poc_outline': [
                    '1. Install app on device',
                    '2. Start exported activity via ADB',
                    '3. Attach debugger (jdb or Android Studio)',
                    '4. Set breakpoints and modify variables',
                    '5. Bypass authentication or access restricted features'
                ],
                'cvss': 9.1
            })
        
        return chains
    
    def _chain_secret_endpoint(self) -> List[Dict[str, Any]]:
        """Chain: Hardcoded secrets + API endpoints"""
        chains = []
        
        secrets = self.results.get('secrets', [])
        endpoints = self.results.get('endpoints', [])
        
        # Find critical secrets
        api_keys = [s for s in secrets if 'api' in s['type'] or 'key' in s['type']]
        admin_endpoints = [e for e in endpoints if e.get('is_admin')]
        
        if api_keys and admin_endpoints:
            narrative = (
                f"An attacker can decompile the APK to extract {len(api_keys)} hardcoded API keys. "
                f"By analyzing the code, they can identify {len(admin_endpoints)} admin or internal endpoints. "
                f"Using the extracted API keys for authentication, the attacker can access these privileged endpoints, "
                f"potentially gaining full administrative access to the backend system, accessing all user data, "
                f"or performing unauthorized operations."
            )
            
            chains.append({
                'title': 'API Key Abuse → Unauthorized Access',
                'severity': 'critical',
                'impact_type': 'Account Takeover',
                'narrative': narrative,
                'preconditions': [
                    'APK file access (publicly available)',
                    'Decompilation tools (jadx, apktool)'
                ],
                'steps': [
                    f'Extracted {len(api_keys)} hardcoded API keys from decompiled code',
                    f'Identified {len(admin_endpoints)} admin/internal endpoints',
                    'Use extracted keys to authenticate to admin endpoints',
                    'Access privileged functionality or sensitive data'
                ],
                'impact': 'Unauthorized access to backend APIs, potential account takeover or data breach',
                'business_impact': 'Complete backend compromise, mass data breach, unauthorized administrative actions',
                'poc_outline': [
                    '1. Decompile APK and extract API keys',
                    '2. Identify admin endpoints from code',
                    '3. Craft requests with extracted credentials',
                    '4. Access admin functionality or user data'
                ],
                'cvss': 8.8,
                'evidence': {
                    'api_keys': [k['type'] for k in api_keys[:3]],
                    'endpoints': [e['url'] for e in admin_endpoints[:3]]
                }
            })
        
        return chains
    
    def _chain_backup_data(self) -> List[Dict[str, Any]]:
        """Chain: Backup enabled + Sensitive data"""
        chains = []
        
        security_flags = self.results.get('security_flags', {})
        secrets = self.results.get('secrets', [])
        
        allow_backup = security_flags.get('allow_backup', False)
        
        if allow_backup and secrets:
            chains.append({
                'title': 'ADB Backup → Sensitive Data Extraction',
                'severity': 'high',
                'steps': [
                    'App allows backup (android:allowBackup not disabled)',
                    f'App contains {len(secrets)} hardcoded secrets',
                    'Attacker can extract app data via ADB backup',
                    'Recover secrets, tokens, and sensitive information'
                ],
                'impact': 'Exposure of app data including credentials, tokens, and user information',
                'poc_outline': [
                    '1. Enable USB debugging on device',
                    '2. Run: adb backup -f backup.ab com.target.app',
                    '3. Convert backup to tar: dd if=backup.ab bs=24 skip=1 | openssl zlib -d > backup.tar',
                    '4. Extract and analyze app data',
                    '5. Recover secrets and sensitive files'
                ],
                'cvss': 7.5
            })
        
        return chains
    
    def _chain_deeplink_activity(self) -> List[Dict[str, Any]]:
        """Chain: Deep links + Exported activities"""
        chains = []
        
        components = self.results.get('components', {})
        deeplinks = components.get('deeplinks', [])
        
        if len(deeplinks) > 0:
            chains.append({
                'title': 'Deep Link Injection → Unauthorized Access',
                'severity': 'high',
                'steps': [
                    f'Found {len(deeplinks)} deep link handlers',
                    'Deep links may lack proper validation',
                    'Craft malicious deep link to bypass authentication',
                    'Access restricted activities or trigger sensitive actions'
                ],
                'impact': 'Authentication bypass, unauthorized feature access, or sensitive action triggering',
                'poc_outline': [
                    '1. Analyze deep link schemes and parameters',
                    '2. Craft malicious deep link URL',
                    '3. Send link via SMS, email, or QR code',
                    '4. Victim opens link, triggering vulnerable activity',
                    '5. Bypass authentication or access restricted features'
                ],
                'cvss': 7.3,
                'evidence': {
                    'deeplinks': deeplinks[:5]
                }
            })
        
        return chains
    
    def _chain_webview_export(self) -> List[Dict[str, Any]]:
        """Chain: WebView + Exported Activity → XSS to RCE"""
        chains = []
        
        vulnerabilities = self.results.get('vulnerabilities', [])
        components = self.results.get('components', {})
        
        # Find WebView issues
        webview_vulns = [v for v in vulnerabilities if 'webview' in v.get('category', '').lower() or 'javascript' in v.get('title', '').lower()]
        exported_activities = components.get('exported_activities', [])
        
        if webview_vulns and exported_activities:
            narrative = (
                f"An attacker can exploit {len(webview_vulns)} WebView security issues in combination with "
                f"{len(exported_activities)} exported activities. By crafting a malicious URL and triggering an "
                f"exported activity that loads content in a WebView, the attacker can execute JavaScript code, "
                f"potentially leading to XSS attacks, data theft via JavaScript interfaces, or even Remote Code "
                f"Execution if addJavascriptInterface is improperly used."
            )
            
            chains.append({
                'title': 'WebView XSS → Remote Code Execution',
                'severity': 'critical',
                'impact_type': 'Account Takeover',
                'narrative': narrative,
                'preconditions': [
                    'Exported activity that loads WebView',
                    'JavaScript enabled or JavaScript interface exposed',
                    'Ability to control loaded URL'
                ],
                'steps': [
                    f'Found {len(webview_vulns)} WebView security issues',
                    f'Found {len(exported_activities)} exported activities',
                    'Craft malicious URL with XSS payload',
                    'Trigger exported activity to load malicious URL',
                    'Execute JavaScript to steal data or achieve RCE'
                ],
                'impact': 'Cross-Site Scripting leading to data theft or Remote Code Execution',
                'business_impact': 'Complete device compromise, credential theft, malware installation',
                'poc_outline': [
                    '1. Identify exported activity that uses WebView',
                    '2. Craft XSS payload or JavaScript interface exploit',
                    '3. Host malicious page or use data: URI',
                    '4. Trigger activity via Intent with malicious URL',
                    '5. Execute payload to steal tokens or achieve RCE'
                ],
                'cvss': 8.5
            })
        
        return chains
    
    def _chain_client_auth_idor(self) -> List[Dict[str, Any]]:
        """Chain: Client-side Auth + IDOR → Privilege Escalation"""
        chains = []
        
        vulnerabilities = self.results.get('vulnerabilities', [])
        endpoints = self.results.get('endpoints', [])
        
        # Find client-side auth checks
        client_auth = [v for v in vulnerabilities if 'client' in v.get('title', '').lower() and 'auth' in v.get('title', '').lower()]
        # Find endpoints with user IDs
        user_endpoints = [e for e in endpoints if any(x in e['url'].lower() for x in ['/user/', '/profile/', '/account/', '{id}', '{userId}'])]
        
        if client_auth and user_endpoints:
            narrative = (
                f"An attacker can bypass {len(client_auth)} client-side authorization checks by modifying the APK. "
                f"Combined with {len(user_endpoints)} API endpoints containing user IDs, this enables horizontal "
                f"privilege escalation. The attacker can access or modify other users' data by simply changing the "
                f"user ID in API requests, as the server relies on client-side checks that have been bypassed."
            )
            
            chains.append({
                'title': 'Client Auth Bypass + IDOR → Horizontal Privilege Escalation',
                'severity': 'critical',
                'impact_type': 'Privilege Escalation',
                'narrative': narrative,
                'preconditions': [
                    'APK modification capability',
                    'Valid user account',
                    'Knowledge of target user ID'
                ],
                'steps': [
                    f'Bypass {len(client_auth)} client-side authorization checks',
                    f'Identify {len(user_endpoints)} endpoints with user IDs',
                    'Modify APK to remove client-side checks',
                    'Access API endpoints with other users\' IDs',
                    'Read or modify other users\' data'
                ],
                'impact': 'Horizontal privilege escalation allowing access to any user\'s data',
                'business_impact': 'Mass data breach, privacy violations, regulatory penalties',
                'poc_outline': [
                    '1. Decompile APK and identify client-side auth checks',
                    '2. Modify code to bypass authorization logic',
                    '3. Recompile and sign modified APK',
                    '4. Identify user ID parameters in API calls',
                    '5. Change user IDs to access other users\' data'
                ],
                'cvss': 8.2
            })
        
        return chains
    
    def _chain_weak_crypto_backup(self) -> List[Dict[str, Any]]:
        """Chain: Weak Crypto + Backup → Credential Theft"""
        chains = []
        
        vulnerabilities = self.results.get('vulnerabilities', [])
        security_flags = self.results.get('security_flags', {})
        
        # Find crypto issues
        crypto_vulns = [v for v in vulnerabilities if 'crypto' in v.get('category', '').lower() or 'encryption' in v.get('title', '').lower()]
        allow_backup = security_flags.get('allow_backup', False)
        
        if crypto_vulns and allow_backup:
            narrative = (
                f"An attacker can exploit {len(crypto_vulns)} cryptographic weaknesses in combination with "
                f"enabled backup functionality. By extracting the app's data via ADB backup, the attacker can "
                f"obtain encrypted credentials. Due to weak encryption (MD5, ECB mode, or hardcoded keys), "
                f"these credentials can be easily decrypted, leading to complete account compromise."
            )
            
            chains.append({
                'title': 'Weak Crypto + Backup → Credential Decryption',
                'severity': 'high',
                'impact_type': 'Data Exfiltration',
                'narrative': narrative,
                'preconditions': [
                    'Physical device access or ADB access',
                    'USB debugging enabled',
                    'Encrypted credentials stored locally'
                ],
                'steps': [
                    f'Identified {len(crypto_vulns)} weak cryptographic implementations',
                    'App allows backup (android:allowBackup enabled)',
                    'Extract app data via ADB backup',
                    'Locate encrypted credentials in backup',
                    'Decrypt using weak algorithm or hardcoded key'
                ],
                'impact': 'Credential theft through weak encryption and backup extraction',
                'business_impact': 'Account takeover, identity theft, unauthorized access',
                'poc_outline': [
                    '1. Run: adb backup -f backup.ab com.target.app',
                    '2. Convert backup: dd if=backup.ab bs=24 skip=1 | openssl zlib -d > backup.tar',
                    '3. Extract and locate encrypted credentials',
                    '4. Identify weak encryption algorithm from code',
                    '5. Decrypt credentials using known weaknesses'
                ],
                'cvss': 7.8
            })
        
        return chains
    
    def _chain_pending_intent(self) -> List[Dict[str, Any]]:
        """Chain: PendingIntent + Broadcast → Intent Hijacking"""
        chains = []
        
        vulnerabilities = self.results.get('vulnerabilities', [])
        components = self.results.get('components', {})
        
        # Find PendingIntent issues
        pending_intent_vulns = [v for v in vulnerabilities if 'pendingintent' in v.get('title', '').lower()]
        broadcast_receivers = components.get('exported_receivers', [])
        
        if pending_intent_vulns and broadcast_receivers:
            narrative = (
                f"An attacker can exploit {len(pending_intent_vulns)} mutable PendingIntent vulnerabilities "
                f"in combination with {len(broadcast_receivers)} exported broadcast receivers. By intercepting "
                f"and modifying the PendingIntent, the attacker can inject malicious extras or redirect the intent "
                f"to a different component, potentially triggering unauthorized actions or stealing sensitive data."
            )
            
            chains.append({
                'title': 'PendingIntent Hijacking → Unauthorized Actions',
                'severity': 'high',
                'impact_type': 'Privilege Escalation',
                'narrative': narrative,
                'preconditions': [
                    'Malicious app installed on device',
                    'Mutable PendingIntent created',
                    'Exported broadcast receiver available'
                ],
                'steps': [
                    f'Found {len(pending_intent_vulns)} mutable PendingIntent issues',
                    f'Found {len(broadcast_receivers)} exported broadcast receivers',
                    'Malicious app intercepts PendingIntent',
                    'Inject malicious extras or redirect intent',
                    'Trigger unauthorized actions or steal data'
                ],
                'impact': 'Intent hijacking leading to unauthorized actions or data theft',
                'business_impact': 'Unauthorized transactions, privilege escalation, data theft',
                'poc_outline': [
                    '1. Identify mutable PendingIntent in target app',
                    '2. Create malicious app to intercept intent',
                    '3. Modify intent extras or destination',
                    '4. Trigger PendingIntent execution',
                    '5. Perform unauthorized action or steal data'
                ],
                'cvss': 7.2
            })
        
        return chains
