package llmswitch

import (
	"encoding/json"
	"os"
	"path/filepath"
	"testing"
)

func TestHasGLMEnv_True(t *testing.T) {
	dir := t.TempDir()
	settingsPath := filepath.Join(dir, "settings.local.json")

	data := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_BASE_URL":   "https://glm.example.com",
			"ANTHROPIC_AUTH_TOKEN": "test-token",
		},
	}
	writeTestJSON(t, settingsPath, data)

	if !HasGLMEnv(settingsPath) {
		t.Error("expected HasGLMEnv to return true when ANTHROPIC_BASE_URL exists")
	}
}

func TestHasGLMEnv_False(t *testing.T) {
	dir := t.TempDir()
	settingsPath := filepath.Join(dir, "settings.local.json")

	data := map[string]any{
		"env": map[string]any{
			"SOME_OTHER_VAR": "value",
		},
	}
	writeTestJSON(t, settingsPath, data)

	if HasGLMEnv(settingsPath) {
		t.Error("expected HasGLMEnv to return false when ANTHROPIC_BASE_URL is absent")
	}
}

func TestHasGLMEnv_NoFile(t *testing.T) {
	if HasGLMEnv("/nonexistent/path/settings.local.json") {
		t.Error("expected HasGLMEnv to return false for nonexistent file")
	}
}

func TestSwitchToClaude_RemovesGLMEnv(t *testing.T) {
	dir := t.TempDir()
	claudeDir := filepath.Join(dir, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	data := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN":           "token",
			"ANTHROPIC_BASE_URL":             "https://glm.example.com",
			"ANTHROPIC_DEFAULT_HAIKU_MODEL":  "glm-4-flash",
			"ANTHROPIC_DEFAULT_SONNET_MODEL": "glm-4",
			"ANTHROPIC_DEFAULT_OPUS_MODEL":   "glm-4-turbo",
			"OTHER_VAR":                      "keep-this",
		},
	}
	writeTestJSON(t, settingsPath, data)

	if err := SwitchToClaude(dir); err != nil {
		t.Fatalf("SwitchToClaude failed: %v", err)
	}

	// Verify GLM keys removed
	result := readTestJSON(t, settingsPath)
	env, ok := result["env"].(map[string]any)
	if !ok {
		t.Fatal("env section missing after switch")
	}

	for _, key := range GLMEnvKeys {
		if _, exists := env[key]; exists {
			t.Errorf("expected %s to be removed, but it still exists", key)
		}
	}

	// Verify other vars preserved
	if env["OTHER_VAR"] != "keep-this" {
		t.Error("expected OTHER_VAR to be preserved")
	}
}

func TestSwitchToClaude_RemovesEmptyEnv(t *testing.T) {
	dir := t.TempDir()
	claudeDir := filepath.Join(dir, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	data := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN": "token",
			"ANTHROPIC_BASE_URL":   "https://glm.example.com",
		},
	}
	writeTestJSON(t, settingsPath, data)

	if err := SwitchToClaude(dir); err != nil {
		t.Fatalf("SwitchToClaude failed: %v", err)
	}

	result := readTestJSON(t, settingsPath)
	if _, exists := result["env"]; exists {
		t.Error("expected empty env section to be removed entirely")
	}
}

func TestSwitchToClaude_AlreadyClaude(t *testing.T) {
	dir := t.TempDir()
	claudeDir := filepath.Join(dir, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	data := map[string]any{
		"env": map[string]any{
			"SOME_VAR": "value",
		},
	}
	writeTestJSON(t, settingsPath, data)

	// Should not error when already on Claude
	err := SwitchToClaude(dir)
	if err != nil {
		t.Fatalf("SwitchToClaude should not error when already on Claude: %v", err)
	}
}

func TestUpdateGLMKey(t *testing.T) {
	// Override home dir for test
	origHome := os.Getenv("HOME")
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)
	defer func() { //nolint:errcheck
		os.Setenv("HOME", origHome)
	}()

	err := UpdateGLMKey("test-api-key-12345")
	if err != nil {
		t.Fatalf("UpdateGLMKey failed: %v", err)
	}

	envPath := filepath.Join(tmpHome, ".moai", ".env.glm")
	content, err := os.ReadFile(envPath)
	if err != nil {
		t.Fatalf("failed to read .env.glm: %v", err)
	}

	if got := parseEnvFile(string(content), "GLM_API_KEY"); got != "test-api-key-12345" {
		t.Errorf("expected GLM_API_KEY=test-api-key-12345, got %s", got)
	}

	// Check file permissions
	info, err := os.Stat(envPath)
	if err != nil {
		t.Fatal(err)
	}
	if info.Mode().Perm() != 0600 {
		t.Errorf("expected permissions 0600, got %o", info.Mode().Perm())
	}
}

func TestLoadGLMKeyFromEnv(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}

	envContent := `# GLM API Key for MoAI-ADK
# Generated by moai-go
GLM_API_KEY="my-secret-key"
`
	envPath := filepath.Join(moaiDir, ".env.glm")
	if err := os.WriteFile(envPath, []byte(envContent), 0600); err != nil {
		t.Fatal(err)
	}

	key, err := LoadGLMKeyFromEnv()
	if err != nil {
		t.Fatalf("LoadGLMKeyFromEnv failed: %v", err)
	}
	if key != "my-secret-key" {
		t.Errorf("expected 'my-secret-key', got '%s'", key)
	}
}

func TestGLMEnvExists(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	if GLMEnvExists() {
		t.Error("expected GLMEnvExists to return false when file doesn't exist")
	}

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	envPath := filepath.Join(moaiDir, ".env.glm")
	if err := os.WriteFile(envPath, []byte("GLM_API_KEY=\"key\""), 0600); err != nil {
		t.Fatal(err)
	}

	if !GLMEnvExists() {
		t.Error("expected GLMEnvExists to return true when file exists")
	}
}

func TestSubstituteEnvVars(t *testing.T) {
	t.Setenv("MY_VAR", "hello")

	result, missing := substituteEnvVars("prefix-${MY_VAR}-suffix")
	if result != "prefix-hello-suffix" {
		t.Errorf("expected 'prefix-hello-suffix', got '%s'", result)
	}
	if len(missing) != 0 {
		t.Errorf("expected no missing vars, got %v", missing)
	}
}

func TestSubstituteEnvVars_Missing(t *testing.T) {
	result, missing := substituteEnvVars("${NONEXISTENT_VAR_12345}")
	if result != "${NONEXISTENT_VAR_12345}" {
		t.Errorf("expected original pattern preserved, got '%s'", result)
	}
	if len(missing) != 1 || missing[0] != "NONEXISTENT_VAR_12345" {
		t.Errorf("expected missing var NONEXISTENT_VAR_12345, got %v", missing)
	}
}

func TestSubstituteEnvVars_GLMKey(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	envPath := filepath.Join(moaiDir, ".env.glm")
	if err := os.WriteFile(envPath, []byte("GLM_API_KEY=\"from-env-file\""), 0600); err != nil {
		t.Fatal(err)
	}

	result, missing := substituteEnvVars("${GLM_API_KEY}")
	if result != "from-env-file" {
		t.Errorf("expected 'from-env-file', got '%s'", result)
	}
	if len(missing) != 0 {
		t.Errorf("expected no missing vars, got %v", missing)
	}
}

func TestParseEnvFile(t *testing.T) {
	content := `# Comment
KEY1="value1"
KEY2='value2'
KEY3=value3
`
	tests := []struct {
		key      string
		expected string
	}{
		{"KEY1", "value1"},
		{"KEY2", "value2"},
		{"KEY3", "value3"},
		{"MISSING", ""},
	}

	for _, tt := range tests {
		got := parseEnvFile(content, tt.key)
		if got != tt.expected {
			t.Errorf("parseEnvFile(%s): expected '%s', got '%s'", tt.key, tt.expected, got)
		}
	}
}

func TestSwitchToGLM_Success(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Create .env.glm
	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte("GLM_API_KEY=\"test-key\""), 0600); err != nil {
		t.Fatal(err)
	}

	// Create project dir with GLM config
	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	glmConfig := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN": "${GLM_API_KEY}",
			"ANTHROPIC_BASE_URL":   "https://glm.example.com",
		},
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	if err := SwitchToGLM(projectDir); err != nil {
		t.Fatalf("SwitchToGLM failed: %v", err)
	}

	// Verify settings.local.json
	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	result := readTestJSON(t, settingsPath)
	env, ok := result["env"].(map[string]any)
	if !ok {
		t.Fatal("env section missing after switch to GLM")
	}

	if env["ANTHROPIC_AUTH_TOKEN"] != "test-key" {
		t.Errorf("expected ANTHROPIC_AUTH_TOKEN=test-key, got %v", env["ANTHROPIC_AUTH_TOKEN"])
	}
	if env["ANTHROPIC_BASE_URL"] != "https://glm.example.com" {
		t.Errorf("expected ANTHROPIC_BASE_URL=https://glm.example.com, got %v", env["ANTHROPIC_BASE_URL"])
	}
}

func TestSwitchToGLM_MissingEnvFile(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	projectDir := t.TempDir()
	err := SwitchToGLM(projectDir)
	if err == nil {
		t.Error("expected error when .env.glm is missing")
	}
}

// ---------------------------------------------------------------------------
// uniqueStrings tests (was 0% coverage)
// ---------------------------------------------------------------------------

func TestUniqueStrings_WithDuplicates(t *testing.T) {
	result := uniqueStrings([]string{"a", "b", "a", "c", "b", "c"})
	expected := []string{"a", "b", "c"}
	if len(result) != len(expected) {
		t.Fatalf("expected %d elements, got %d: %v", len(expected), len(result), result)
	}
	for i, v := range expected {
		if result[i] != v {
			t.Errorf("index %d: expected %q, got %q", i, v, result[i])
		}
	}
}

func TestUniqueStrings_Empty(t *testing.T) {
	result := uniqueStrings([]string{})
	if len(result) != 0 {
		t.Errorf("expected empty slice, got %v", result)
	}
}

func TestUniqueStrings_NoDuplicates(t *testing.T) {
	result := uniqueStrings([]string{"x", "y", "z"})
	expected := []string{"x", "y", "z"}
	if len(result) != len(expected) {
		t.Fatalf("expected %d elements, got %d", len(expected), len(result))
	}
	for i, v := range expected {
		if result[i] != v {
			t.Errorf("index %d: expected %q, got %q", i, v, result[i])
		}
	}
}

func TestUniqueStrings_Nil(t *testing.T) {
	result := uniqueStrings(nil)
	if result != nil {
		t.Errorf("expected nil, got %v", result)
	}
}

// ---------------------------------------------------------------------------
// SwitchToGLM additional tests (was 73.8% coverage)
// ---------------------------------------------------------------------------

func TestSwitchToGLM_AlreadyGLM(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Create .env.glm so GLMEnvExists returns true
	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}

	// settings.local.json WITH ANTHROPIC_BASE_URL already present
	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	data := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_BASE_URL": "https://glm.example.com",
		},
	}
	writeTestJSON(t, settingsPath, data)

	// Should return nil (already using GLM)
	if err := SwitchToGLM(projectDir); err != nil {
		t.Errorf("expected no error when already using GLM, got %v", err)
	}
}

func TestSwitchToGLM_MissingGLMConfig(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Create .env.glm
	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	// Project dir without glm.json config
	projectDir := t.TempDir()

	err := SwitchToGLM(projectDir)
	if err == nil {
		t.Error("expected error when GLM config is missing")
	}
}

func TestSwitchToGLM_InvalidGLMConfig(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Write invalid JSON to glm.json
	glmConfigPath := filepath.Join(llmConfigDir, "glm.json")
	if err := os.WriteFile(glmConfigPath, []byte("{invalid json}"), 0644); err != nil {
		t.Fatal(err)
	}

	err := SwitchToGLM(projectDir)
	if err == nil {
		t.Error("expected error when GLM config has invalid JSON")
	}
}

func TestSwitchToGLM_MissingEnvSection(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// GLM config WITHOUT "env" section
	glmConfig := map[string]any{
		"description": "no env section here",
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	err := SwitchToGLM(projectDir)
	if err == nil {
		t.Error("expected error when GLM config has no env section")
	}
}

func TestSwitchToGLM_MissingCredentials(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// GLM config referencing a variable that does not exist anywhere
	glmConfig := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN": "${TOTALLY_NONEXISTENT_VAR_XYZ_99}",
		},
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	err := SwitchToGLM(projectDir)
	if err == nil {
		t.Error("expected error when credentials are missing")
	}
}

func TestSwitchToGLM_NonStringEnvValues(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// GLM config with non-string env values (number, bool) to cover the !ok branch
	glmConfig := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_BASE_URL": "https://glm.example.com",
			"SOME_NUMBER":        42,
			"SOME_BOOL":          true,
		},
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	if err := SwitchToGLM(projectDir); err != nil {
		t.Fatalf("SwitchToGLM failed with non-string values: %v", err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	result := readTestJSON(t, settingsPath)
	env, ok := result["env"].(map[string]any)
	if !ok {
		t.Fatal("env section missing after switch")
	}

	if env["ANTHROPIC_BASE_URL"] != "https://glm.example.com" {
		t.Errorf("expected ANTHROPIC_BASE_URL=https://glm.example.com, got %v", env["ANTHROPIC_BASE_URL"])
	}
}

func TestSwitchToGLM_EnvVarSubstitutionWithMultipleVars(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)
	t.Setenv("CUSTOM_GLM_HOST", "glm.custom.com")

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	// Key longer than 8 chars to cover the masking branch (len > 8)
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="my-long-api-key-value"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Config with multiple ${VAR} references including a regular env var
	glmConfig := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN": "${GLM_API_KEY}",
			"ANTHROPIC_BASE_URL":   "https://${CUSTOM_GLM_HOST}/v1",
		},
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	if err := SwitchToGLM(projectDir); err != nil {
		t.Fatalf("SwitchToGLM failed: %v", err)
	}

	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	result := readTestJSON(t, settingsPath)
	env, ok := result["env"].(map[string]any)
	if !ok {
		t.Fatal("env section missing")
	}

	if env["ANTHROPIC_AUTH_TOKEN"] != "my-long-api-key-value" {
		t.Errorf("expected ANTHROPIC_AUTH_TOKEN=my-long-api-key-value, got %v", env["ANTHROPIC_AUTH_TOKEN"])
	}
	if env["ANTHROPIC_BASE_URL"] != "https://glm.custom.com/v1" {
		t.Errorf("expected ANTHROPIC_BASE_URL=https://glm.custom.com/v1, got %v", env["ANTHROPIC_BASE_URL"])
	}
}

func TestSwitchToGLM_MergesWithExistingEnv(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(filepath.Join(moaiDir, ".env.glm"), []byte(`GLM_API_KEY="key"`), 0600); err != nil {
		t.Fatal(err)
	}

	projectDir := t.TempDir()
	claudeDir := filepath.Join(projectDir, ".claude")
	llmConfigDir := filepath.Join(projectDir, ".moai", "llm-configs")
	if err := os.MkdirAll(claudeDir, 0755); err != nil {
		t.Fatal(err)
	}
	if err := os.MkdirAll(llmConfigDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Pre-existing settings.local.json with some env vars
	settingsPath := filepath.Join(claudeDir, "settings.local.json")
	existingSettings := map[string]any{
		"env": map[string]any{
			"MY_EXISTING_VAR": "preserved-value",
		},
	}
	writeTestJSON(t, settingsPath, existingSettings)

	glmConfig := map[string]any{
		"env": map[string]any{
			"ANTHROPIC_AUTH_TOKEN": "${GLM_API_KEY}",
			"ANTHROPIC_BASE_URL":   "https://glm.example.com",
		},
	}
	writeTestJSON(t, filepath.Join(llmConfigDir, "glm.json"), glmConfig)

	if err := SwitchToGLM(projectDir); err != nil {
		t.Fatalf("SwitchToGLM failed: %v", err)
	}

	result := readTestJSON(t, settingsPath)
	env, ok := result["env"].(map[string]any)
	if !ok {
		t.Fatal("env section missing after merge")
	}

	// Existing var should be preserved
	if env["MY_EXISTING_VAR"] != "preserved-value" {
		t.Errorf("expected MY_EXISTING_VAR=preserved-value, got %v", env["MY_EXISTING_VAR"])
	}
	// GLM vars should be added
	if env["ANTHROPIC_AUTH_TOKEN"] != "key" {
		t.Errorf("expected ANTHROPIC_AUTH_TOKEN=key, got %v", env["ANTHROPIC_AUTH_TOKEN"])
	}
	if env["ANTHROPIC_BASE_URL"] != "https://glm.example.com" {
		t.Errorf("expected ANTHROPIC_BASE_URL=https://glm.example.com, got %v", env["ANTHROPIC_BASE_URL"])
	}
}

// ---------------------------------------------------------------------------
// saveJSON error tests (was 75% coverage)
// ---------------------------------------------------------------------------

func TestSaveJSON_MarshalError(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "test.json")

	// Channel values cannot be marshaled to JSON
	data := map[string]any{
		"invalid": make(chan int),
	}
	err := saveJSON(path, data)
	if err == nil {
		t.Error("expected error from MarshalIndent with unmarshalable data")
	}
}

func TestSaveJSON_WriteError(t *testing.T) {
	// Path inside a nonexistent directory
	path := filepath.Join(t.TempDir(), "nonexistent", "subdir", "test.json")
	data := map[string]any{"key": "value"}
	err := saveJSON(path, data)
	if err == nil {
		t.Error("expected error when writing to invalid path")
	}
}

// ---------------------------------------------------------------------------
// loadJSON error tests
// ---------------------------------------------------------------------------

func TestLoadJSON_InvalidJSON(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "bad.json")
	if err := os.WriteFile(path, []byte("{not valid json"), 0644); err != nil {
		t.Fatal(err)
	}

	_, err := loadJSON(path)
	if err == nil {
		t.Error("expected error when loading invalid JSON")
	}
}

// ---------------------------------------------------------------------------
// LoadGLMKeyFromEnv error tests (was 71.4% coverage)
// ---------------------------------------------------------------------------

func TestLoadGLMKeyFromEnv_NoFile(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Do not create .env.glm
	_, err := LoadGLMKeyFromEnv()
	if err == nil {
		t.Error("expected error when .env.glm does not exist")
	}
}

// ---------------------------------------------------------------------------
// UpdateGLMKey error tests (was 75% coverage)
// ---------------------------------------------------------------------------

func TestUpdateGLMKey_MkdirError(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	// Create .moai as a regular FILE so MkdirAll fails
	moaiPath := filepath.Join(tmpHome, ".moai")
	if err := os.WriteFile(moaiPath, []byte("not a directory"), 0644); err != nil {
		t.Fatal(err)
	}

	err := UpdateGLMKey("test-key")
	if err == nil {
		t.Error("expected error when .moai is a file not directory")
	}
}

func TestUpdateGLMKey_WriteError(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)

	moaiDir := filepath.Join(tmpHome, ".moai")
	if err := os.MkdirAll(moaiDir, 0700); err != nil {
		t.Fatal(err)
	}

	// Make directory read-only so WriteFile fails
	if err := os.Chmod(moaiDir, 0500); err != nil {
		t.Fatal(err)
	}
	defer func() {
		// Restore permissions for cleanup
		if err := os.Chmod(moaiDir, 0700); err != nil {
			t.Logf("warning: could not restore permissions: %v", err)
		}
	}()

	err := UpdateGLMKey("test-key")
	if err == nil {
		t.Error("expected error when directory is read-only")
	}
}

// ---------------------------------------------------------------------------
// substituteEnvVars additional tests
// ---------------------------------------------------------------------------

func TestSubstituteEnvVars_GLMKeyFallbackToOsEnv(t *testing.T) {
	tmpHome := t.TempDir()
	t.Setenv("HOME", tmpHome)
	// No .env.glm file created, but set GLM_API_KEY as an env var
	t.Setenv("GLM_API_KEY", "from-os-env")

	result, missing := substituteEnvVars("${GLM_API_KEY}")
	if result != "from-os-env" {
		t.Errorf("expected 'from-os-env', got '%s'", result)
	}
	if len(missing) != 0 {
		t.Errorf("expected no missing vars, got %v", missing)
	}
}

func TestSubstituteEnvVars_NoPattern(t *testing.T) {
	result, missing := substituteEnvVars("no-variables-here")
	if result != "no-variables-here" {
		t.Errorf("expected unchanged string, got '%s'", result)
	}
	if len(missing) != 0 {
		t.Errorf("expected no missing vars, got %v", missing)
	}
}

// ---------------------------------------------------------------------------
// HasGLMEnv additional tests
// ---------------------------------------------------------------------------

func TestHasGLMEnv_NoEnvSection(t *testing.T) {
	dir := t.TempDir()
	settingsPath := filepath.Join(dir, "settings.local.json")

	// JSON without "env" key at all
	data := map[string]any{
		"someOtherKey": "value",
	}
	writeTestJSON(t, settingsPath, data)

	if HasGLMEnv(settingsPath) {
		t.Error("expected HasGLMEnv to return false when no env section exists")
	}
}

// ---------------------------------------------------------------------------
// parseEnvFile additional tests
// ---------------------------------------------------------------------------

func TestParseEnvFile_MalformedLine(t *testing.T) {
	// Lines without '=' should be skipped
	content := "NO_EQUALS_HERE\nVALID_KEY=valid_value\n"
	got := parseEnvFile(content, "VALID_KEY")
	if got != "valid_value" {
		t.Errorf("expected 'valid_value', got '%s'", got)
	}
	got = parseEnvFile(content, "NO_EQUALS_HERE")
	if got != "" {
		t.Errorf("expected empty for malformed line, got '%s'", got)
	}
}

// Test helpers

func writeTestJSON(t *testing.T, path string, data map[string]any) {
	t.Helper()
	content, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		t.Fatal(err)
	}
	if err := os.WriteFile(path, content, 0644); err != nil {
		t.Fatal(err)
	}
}

func readTestJSON(t *testing.T, path string) map[string]any {
	t.Helper()
	content, err := os.ReadFile(path)
	if err != nil {
		t.Fatal(err)
	}
	var data map[string]any
	if err := json.Unmarshal(content, &data); err != nil {
		t.Fatal(err)
	}
	return data
}
