"""Visp wavelength calibration task."""

import astropy.units as u
import numpy as np
from astropy.time import Time
from astropy.units import Quantity
from astropy.wcs import WCS
from dkist_processing_common.codecs.fits import fits_array_decoder
from dkist_processing_common.codecs.json import json_encoder
from dkist_processing_common.models.dkist_location import location_of_dkist
from dkist_processing_common.tasks.mixin.quality import QualityMixin
from dkist_service_configuration.logging import logger
from solar_wavelength_calibration import Atlas
from solar_wavelength_calibration import WavelengthCalibrationFitter
from solar_wavelength_calibration.fitter.parameters import AngleBoundRange
from solar_wavelength_calibration.fitter.parameters import BoundsModel
from solar_wavelength_calibration.fitter.parameters import DispersionBoundRange
from solar_wavelength_calibration.fitter.parameters import FitFlagsModel
from solar_wavelength_calibration.fitter.parameters import LengthBoundRange
from solar_wavelength_calibration.fitter.parameters import UnitlessBoundRange
from solar_wavelength_calibration.fitter.parameters import WavelengthCalibrationParameters
from solar_wavelength_calibration.fitter.wavelength_fitter import WavelengthParameters
from solar_wavelength_calibration.fitter.wavelength_fitter import calculate_initial_crval_guess
from sunpy.coordinates import HeliocentricInertial

from dkist_processing_visp.models.tags import VispTag
from dkist_processing_visp.tasks.visp_base import VispTaskBase


class WavelengthCalibration(VispTaskBase, QualityMixin):
    """Task class for correcting the dispersion axis wavelength values.

    Parameters
    ----------
    recipe_run_id : int
        id of the recipe run used to identify the workflow run this task is part of
    workflow_name : str
        name of the workflow to which this instance of the task belongs
    workflow_version : str
        version of the workflow to which this instance of the task belongs

    """

    record_provenance = True

    def run(self) -> None:
        """
        Run method for the task.

        #. Gather 2D characteristic spectra for beam 1 generated by solar gain task.
        #. Compute spatial median of characteristic spectra as initial spectrum.
        #. Compute the theoretical dispersion and order.
        #. Compute the incident light angle.
        #. Generate the input wavelength vector from the spectrum and instrument parameters.
        #. Estimate the Doppler velocity and set the resolving power.
        #. Define fitting bounds and initialize model parameters.
        #. Set up and run the wavelength calibration fit.
        #. Save the resulting wavelength solution and quality metrics.

        Returns
        -------
        None
        """
        with self.telemetry_span("Compute input spectrum and wavelength"):
            logger.info("Loading characteristic spectrum")
            char_spectra = next(
                self.read(
                    tags=[
                        VispTag.intermediate_frame(beam=1),
                        VispTag.task_characteristic_spectra(),
                    ],
                    decoder=fits_array_decoder,
                )
            )

            logger.info("Calculating input spectrum")
            # average along spatial dimension
            med_char_spectrum = np.nanmedian(char_spectra, axis=1)
            input_spectrum, nan_chop_amount = self.chop_and_clean_NaNs(med_char_spectrum)

            incident_light_angle = self.constants.incident_light_angle_deg
            logger.info(f"{incident_light_angle = !s}")

            wavelength = self.constants.wavelength * u.nm
            reflected_light_angle = self.constants.reflected_light_angle_deg
            order = compute_order(
                central_wavelength=wavelength,
                incident_light_angle=incident_light_angle,
                reflected_light_angle=reflected_light_angle,
                grating_constant=self.constants.grating_constant_inverse_mm,
            )
            logger.info(f"{order = }")

            pixpitch = self.parameters.wavecal_pixel_pitch_micron_per_pix
            dispersion = compute_initial_dispersion(
                central_wavelength=wavelength,
                incident_light_angle=incident_light_angle,
                reflected_light_angle=reflected_light_angle,
                lens_parameters=self.parameters.wavecal_camera_lens_parameters,
                pixel_pitch=pixpitch,
            )
            logger.info(f"{dispersion = !s}")

        with self.telemetry_span("Compute brute-force CRVAL initial guess"):
            logger.info("Computing initial wavelength vector.")
            input_wavelength_vector = compute_input_wavelength_vector(
                central_wavelength=wavelength,
                dispersion=dispersion,
                grating_constant=self.constants.grating_constant_inverse_mm,
                order=order,
                incident_light_angle=incident_light_angle,
                num_spec_px=input_spectrum.size,
            )

            wavelength_range = input_wavelength_vector[-1] - input_wavelength_vector[0]
            logger.info(f"{wavelength_range = !s}")

            atlas = Atlas(config=self.parameters.wavecal_atlas_download_config)
            crval_initial_guess = calculate_initial_crval_guess(
                input_wavelength_vector=input_wavelength_vector,
                input_spectrum=input_spectrum,
                atlas=atlas,
                negative_limit=-wavelength_range / 2,
                positive_limit=wavelength_range / 2,
                num_steps=550,
                normalization_percentile=self.parameters.wavecal_init_crval_guess_normalization_percentile,
            )
            logger.info(f"{crval_initial_guess = !s}")

        with self.telemetry_span("Set up wavelength fit"):
            doppler_velocity = get_doppler_velocity(self.constants.solar_gain_ip_start_time)
            logger.info(f"{doppler_velocity = !s}")

            resolving_power = self.parameters.wavecal_init_resolving_power
            logger.info(f"{resolving_power = }")

            init_continuum_level = estimate_relative_continuum_level(
                crval_init=crval_initial_guess,
                wavelength_range=wavelength_range,
                atlas=atlas,
                representative_spectrum=input_spectrum,
                normalization_percentile=self.parameters.wavecal_init_crval_guess_normalization_percentile,
            )
            logger.info(f"{init_continuum_level = !s}")

            logger.info("Setting bounds")
            wavelength_search_width = dispersion * self.parameters.wavecal_crval_bounds_px
            bounds = BoundsModel(
                crval=LengthBoundRange(
                    min=crval_initial_guess - wavelength_search_width,
                    max=crval_initial_guess + wavelength_search_width,
                ),
                dispersion=DispersionBoundRange(
                    min=dispersion * (1 - self.parameters.wavecal_dispersion_bounds_fraction),
                    max=dispersion * (1 + self.parameters.wavecal_dispersion_bounds_fraction),
                ),
                incident_light_angle=AngleBoundRange(
                    min=incident_light_angle
                    - self.parameters.wavecal_incident_light_angle_bounds_deg,
                    max=incident_light_angle
                    + self.parameters.wavecal_incident_light_angle_bounds_deg,
                ),
                resolving_power=UnitlessBoundRange(
                    min=resolving_power - (resolving_power * 0.1),
                    max=resolving_power + (resolving_power * 0.1),
                ),
                opacity_factor=UnitlessBoundRange(min=0.0, max=10.0),
                straylight_fraction=UnitlessBoundRange(min=0.0, max=0.4),
                continuum_level=UnitlessBoundRange(
                    min=init_continuum_level * 0.7, max=init_continuum_level * 1.3
                ),
            )

            fit_flags = FitFlagsModel(
                crval=True,
                dispersion=True,
                incident_light_angle=True,
                resolving_power=True,
                opacity_factor=True,
                straylight_fraction=True,
                continuum_level=True,
            )

            logger.info("Initializing parameters")
            input_parameters = WavelengthCalibrationParameters(
                crval=crval_initial_guess,
                dispersion=dispersion,
                incident_light_angle=incident_light_angle,
                resolving_power=resolving_power,
                opacity_factor=self.parameters.wavecal_init_opacity_factor,
                straylight_fraction=self.parameters.wavecal_init_straylight_fraction,
                grating_constant=self.constants.grating_constant_inverse_mm,
                continuum_level=init_continuum_level,
                doppler_velocity=doppler_velocity,
                order=order,
                bounds=bounds,
                fit_flags=fit_flags,
            )

            fitter = WavelengthCalibrationFitter(
                input_parameters=input_parameters,
            )

            logger.info(f"Input parameters: {input_parameters.lmfit_parameters.pretty_repr()}")

        with self.telemetry_span("Run wavelength solution fit"):
            extra_kwargs = self.parameters.wavecal_fit_kwargs
            logger.info(f"Calling fitter with extra kwargs: {extra_kwargs}")
            fit_result = fitter(
                input_spectrum=input_spectrum,
                **extra_kwargs,
            )

        with self.telemetry_span("Save wavelength solution and quality metrics"):
            axis_number = next(
                (i for i in range(1, 4) if getattr(self.constants, f"axis_{i}_type") == "AWAV"),
                None,
            )

            if axis_number is None:
                raise ValueError("No axis equal to AWAV. This should never happen!")

            solution_header = fit_result.wavelength_parameters.to_header(
                axis_num=axis_number, add_alternate_keys=True
            )

            # update the fit value of CRPIX to account for the fact that we may have chopped some NaN pixels away from the start of the data array
            solution_header[f"CRPIX{axis_number}"] += nan_chop_amount
            solution_header[f"CRPIX{axis_number}A"] += nan_chop_amount

            self.write(
                data=solution_header,
                tags=[VispTag.task_wavelength_calibration(), VispTag.intermediate()],
                encoder=json_encoder,
            )

            self.quality_store_wavecal_results(
                input_wavelength=input_wavelength_vector,
                input_spectrum=input_spectrum,
                fit_result=fit_result,
            )

    def chop_and_clean_NaNs(self, spectrum: np.ndarray) -> tuple[np.ndarray, int]:
        """
        Chop contiguous regions of NaN from either end of an array.

        Returns
        -------
        np.ndarray
            The input array with NaN's removed

        int
            The number of pixels chopped from the start of the array. This is needed to correctly adjust CRPIX later.
        """
        starting_non_nan_idx = 0
        while np.isnan(spectrum[starting_non_nan_idx]):
            starting_non_nan_idx += 1

        ending_non_nan_idx = spectrum.size - 1
        while np.isnan(spectrum[ending_non_nan_idx]):
            ending_non_nan_idx -= 1

        logger.info(
            f"Chopping NaN values from end of spectrum with slice [{starting_non_nan_idx}:{ending_non_nan_idx + 1}]"
        )
        chopped_spectrum = spectrum[starting_non_nan_idx : ending_non_nan_idx + 1]

        return chopped_spectrum, starting_non_nan_idx


def get_doppler_velocity(solar_gain_ip_start_time) -> u.Quantity:
    """Find the speed at which DKIST is moving relative to the Sun's center.

    Positive values refer to when DKIST is moving away from the sun.
    """
    coord = location_of_dkist.get_gcrs(obstime=Time(solar_gain_ip_start_time))
    heliocentric_coord = coord.transform_to(
        HeliocentricInertial(obstime=Time(solar_gain_ip_start_time))
    )
    obs_vr_kms = heliocentric_coord.d_distance
    return obs_vr_kms


def compute_order(
    central_wavelength: Quantity,
    incident_light_angle: Quantity,
    reflected_light_angle: Quantity,
    grating_constant: Quantity,
) -> int:
    r"""
    Compute the spectral order from the spectrograph setup.

    From the grating equation, the spectral order, :math:`m`:, is

    .. math::
        m = \frac{\sin\alpha + \sin\beta}{G \lambda}

    where :math:`\alpha` and :math:`\beta` are the incident and reflected light angles, respectively, :math:`G` is the
    grating constant (lines per mm), and :math:`\lambda` is the central wavelength. All of these values come from the
    input headers.

    Parameters
    ----------
    central_wavelength
        Wavelength of the center of the spectral window.

    incident_light_angle
        Angle of light incident to the spectrograph grating. Often called :math:`\alpha`.

    reflected_light_angle
        Angle of light reflected from spectrograph grating. Often called :math:`\beta`.

    grating_constant
        Grating constant of the spectrograph grating [lines per mm]

    Returns
    -------
    spectral_order
        The order of the given spectrograph configuration
    """
    return int(
        (np.sin(incident_light_angle) + np.sin(reflected_light_angle))
        / (grating_constant * central_wavelength)
    )


def compute_input_wavelength_vector(
    *,
    central_wavelength: Quantity,
    dispersion: Quantity,
    grating_constant: Quantity,
    order: int,
    incident_light_angle: Quantity,
    num_spec_px: int,
) -> u.Quantity:
    r"""
    Compute a wavelength vector based on information about the spectrograph setup.

    The parameterization of the grating equation is via `astropy.wcs.WCS`, which follows section 5 of
    `Greisen et al (2006) <https://ui.adsabs.harvard.edu/abs/2006A%26A...446..747G/abstract>`_.

    Parameters
    ----------
    central_wavelength
        Wavelength at the center of the spectral window. This function forces the value of the output vector to be
        ``wavelength`` at index ``num_spec // 2 + 1``.

    dispersion
        Spectrograph dispersion [nm / px]

    grating_constant
        Grating constant of the spectrograph grating [lines per mm]

    order
        Spectrograph order

    incident_light_angle
        Angle of light incident to the spectrograph grating. Often called :math:`\alpha`.

    num_spec_px
        The length of the output wavelength vector. Defines size and physical limits of the output.

    Returns
    -------
    wave_vec
        1D array of length ``num_spec`` containing the wavelength values described by the input WCS parameterization.
        The units of this array will be nanometers.
    """
    wavelength_parameters = WavelengthParameters(
        crpix=num_spec_px // 2 + 1,
        crval=central_wavelength.to_value(u.nm),
        dispersion=dispersion.to_value(u.nm / u.pix),
        grating_constant=grating_constant.to_value(1 / u.mm),
        order=order,
        incident_light_angle=incident_light_angle.to_value(u.deg),
        cunit="nm",
    )
    header = wavelength_parameters.to_header(axis_num=1)
    wcs = WCS(header)
    input_wavelength_vector = wcs.spectral.pixel_to_world(np.arange(num_spec_px)).to(u.nm)

    return input_wavelength_vector


def compute_initial_dispersion(
    central_wavelength: Quantity,
    incident_light_angle: Quantity,
    reflected_light_angle: Quantity,
    lens_parameters: list[Quantity],
    pixel_pitch: Quantity,
) -> Quantity:
    r"""
    Compute the dispersion (:math:`d\,\lambda/d\, px`) given the spectrograph setup.

    The dispersion is given via

    .. math::
        d\,\lambda / d\, px = \frac{p \lambda_0 \cos\beta}{f (\sin\alpha + \sin\beta)}

    where :math:`p` is the pixel pitch (microns per pix), :math:`\lambda_0` is the central wavelength, :math:`f` is the
    camera focal length, and :math:`\alpha` and :math:`\beta` are the incident and reflected light angles, respectively.
    :math:`\lambda_0`, :math:`\alpha`, and :math:`\beta` are taken from input headers, while :math:`f` and :math:`p` are
    pipeline parameters.

    Parameters
    ----------
    central_wavelength
        Wavelength of the center of the spectral window.

    incident_light_angle
        Angle of light incident to the spectrograph grating. Often called :math:`\alpha`.

    reflected_light_angle
        Angle of light reflected from spectrograph grating. Often called :math:`\beta`.

    lens_parameters
        Parameterization of lens focal length as zero, first, and second orders of wavelength. If the total focal
        length of the lens is :math:`f = a_0 + a_1\lambda + a_2\lambda^2` then this list is :math:`[a_0, a_1, a_2]`.

    pixel_pitch
        The physical size of a single pixel

    Returns
    -------
    dispersion
       The computed dispersion in units of nm / px
    """
    camera_focal_length = lens_parameters[0] + central_wavelength * (
        lens_parameters[1] + central_wavelength * lens_parameters[2]
    )
    logger.info(f"{camera_focal_length = !s}")

    linear_dispersion = (
        camera_focal_length
        * (np.sin(incident_light_angle) + np.sin(reflected_light_angle))
        / (np.cos(reflected_light_angle) * central_wavelength)
    )

    dispersion = pixel_pitch / linear_dispersion

    return dispersion.to(u.nm / u.pix)


def estimate_relative_continuum_level(
    *,
    crval_init: Quantity,
    wavelength_range: Quantity,
    atlas: Atlas,
    representative_spectrum: np.ndarray,
    normalization_percentile: float,
) -> float:
    """
    Estimate the multiplicative scaling between the representative spectrum and atlas solar transmission.

    This scaling is used to set the initial guess of 0th-order continuum scaling. We estimate the scaling factor by
    comparing the values of the two spectra at a given percent of the CDF. This percent is taken from the
    `~dkist_processing_visp.models.parameters.VispParameters.wavecal_init_crval_guess_normalization_percentile`
    pipeline parameter.
    """
    wave_min = crval_init - wavelength_range / 2
    wave_max = crval_init + wavelength_range / 2

    atlas_idx = np.where(
        (atlas.solar_atlas_wavelength >= wave_min) & (atlas.solar_atlas_wavelength <= wave_max)
    )
    atlas_norm = np.nanpercentile(
        atlas.solar_atlas_transmission[atlas_idx], normalization_percentile
    )
    spec_norm = np.nanpercentile(representative_spectrum, normalization_percentile)

    return spec_norm / atlas_norm
