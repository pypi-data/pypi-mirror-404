"""
Auto-generated posts resource.

DO NOT EDIT THIS FILE MANUALLY.
Run `python scripts/generate_resources.py` to regenerate.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from datetime import datetime

    from ..client.base import BaseClient


class PostsResource:
    """
    Create, schedule, and manage social media posts.
    """

    def __init__(self, client: BaseClient) -> None:
        self._client = client

    def _build_params(self, **kwargs: Any) -> dict[str, Any]:
        """Build query parameters, filtering None values."""

        def to_camel(s: str) -> str:
            parts = s.split("_")
            return parts[0] + "".join(p.title() for p in parts[1:])

        return {to_camel(k): v for k, v in kwargs.items() if v is not None}

    def _build_payload(self, **kwargs: Any) -> dict[str, Any]:
        """Build request payload, filtering None values."""
        from datetime import datetime

        def to_camel(s: str) -> str:
            parts = s.split("_")
            return parts[0] + "".join(p.title() for p in parts[1:])

        result: dict[str, Any] = {}
        for k, v in kwargs.items():
            if v is None:
                continue
            if isinstance(v, datetime):
                result[to_camel(k)] = v.isoformat()
            else:
                result[to_camel(k)] = v
        return result

    def list_posts(
        self,
        *,
        page: int | None = 1,
        limit: int | None = 10,
        status: str | None = None,
        platform: str | None = None,
        profile_id: str | None = None,
        created_by: str | None = None,
        date_from: str | None = None,
        date_to: str | None = None,
        include_hidden: bool | None = False,
    ) -> dict[str, Any]:
        """List posts visible to the authenticated user"""
        params = self._build_params(
            page=page,
            limit=limit,
            status=status,
            platform=platform,
            profile_id=profile_id,
            created_by=created_by,
            date_from=date_from,
            date_to=date_to,
            include_hidden=include_hidden,
        )
        return self._client._get("/v1/posts", params=params)

    def create_post(
        self,
        *,
        title: str | None = None,
        content: str | None = None,
        media_items: list[dict[str, Any]] | None = None,
        platforms: list[dict[str, Any]] | None = None,
        scheduled_for: datetime | str | None = None,
        publish_now: bool | None = False,
        is_draft: bool | None = False,
        timezone: str | None = "UTC",
        tags: list[str] | None = None,
        hashtags: list[str] | None = None,
        mentions: list[str] | None = None,
        crossposting_enabled: bool | None = True,
        metadata: dict[str, Any] | None = None,
        tiktok_settings: Any | None = None,
        queued_from_profile: str | None = None,
        queue_id: str | None = None,
    ) -> dict[str, Any]:
        """Create a draft, scheduled, or immediate post"""
        payload = self._build_payload(
            title=title,
            content=content,
            media_items=media_items,
            platforms=platforms,
            scheduled_for=scheduled_for,
            publish_now=publish_now,
            is_draft=is_draft,
            timezone=timezone,
            tags=tags,
            hashtags=hashtags,
            mentions=mentions,
            crossposting_enabled=crossposting_enabled,
            metadata=metadata,
            tiktok_settings=tiktok_settings,
            queued_from_profile=queued_from_profile,
            queue_id=queue_id,
        )
        return self._client._post("/v1/posts", data=payload)

    def get_post(self, post_id: str) -> dict[str, Any]:
        """Get a single post"""
        return self._client._get(f"/v1/posts/{post_id}")

    def update_post(self, post_id: str) -> dict[str, Any]:
        """Update a post"""
        return self._client._put(f"/v1/posts/{post_id}")

    def delete_post(self, post_id: str) -> dict[str, Any]:
        """Delete a post"""
        return self._client._delete(f"/v1/posts/{post_id}")

    def bulk_upload_posts(self, *, dry_run: bool | None = False) -> dict[str, Any]:
        """Validate and schedule multiple posts from CSV"""
        params = self._build_params(
            dry_run=dry_run,
        )
        return self._client._post("/v1/posts/bulk-upload", params=params)

    def retry_post(self, post_id: str) -> dict[str, Any]:
        """Retry publishing a failed or partial post"""
        return self._client._post(f"/v1/posts/{post_id}/retry")

    async def alist_posts(
        self,
        *,
        page: int | None = 1,
        limit: int | None = 10,
        status: str | None = None,
        platform: str | None = None,
        profile_id: str | None = None,
        created_by: str | None = None,
        date_from: str | None = None,
        date_to: str | None = None,
        include_hidden: bool | None = False,
    ) -> dict[str, Any]:
        """List posts visible to the authenticated user (async)"""
        params = self._build_params(
            page=page,
            limit=limit,
            status=status,
            platform=platform,
            profile_id=profile_id,
            created_by=created_by,
            date_from=date_from,
            date_to=date_to,
            include_hidden=include_hidden,
        )
        return await self._client._aget("/v1/posts", params=params)

    async def acreate_post(
        self,
        *,
        title: str | None = None,
        content: str | None = None,
        media_items: list[dict[str, Any]] | None = None,
        platforms: list[dict[str, Any]] | None = None,
        scheduled_for: datetime | str | None = None,
        publish_now: bool | None = False,
        is_draft: bool | None = False,
        timezone: str | None = "UTC",
        tags: list[str] | None = None,
        hashtags: list[str] | None = None,
        mentions: list[str] | None = None,
        crossposting_enabled: bool | None = True,
        metadata: dict[str, Any] | None = None,
        tiktok_settings: Any | None = None,
        queued_from_profile: str | None = None,
        queue_id: str | None = None,
    ) -> dict[str, Any]:
        """Create a draft, scheduled, or immediate post (async)"""
        payload = self._build_payload(
            title=title,
            content=content,
            media_items=media_items,
            platforms=platforms,
            scheduled_for=scheduled_for,
            publish_now=publish_now,
            is_draft=is_draft,
            timezone=timezone,
            tags=tags,
            hashtags=hashtags,
            mentions=mentions,
            crossposting_enabled=crossposting_enabled,
            metadata=metadata,
            tiktok_settings=tiktok_settings,
            queued_from_profile=queued_from_profile,
            queue_id=queue_id,
        )
        return await self._client._apost("/v1/posts", data=payload)

    async def aget_post(self, post_id: str) -> dict[str, Any]:
        """Get a single post (async)"""
        return await self._client._aget(f"/v1/posts/{post_id}")

    async def aupdate_post(self, post_id: str) -> dict[str, Any]:
        """Update a post (async)"""
        return await self._client._aput(f"/v1/posts/{post_id}")

    async def adelete_post(self, post_id: str) -> dict[str, Any]:
        """Delete a post (async)"""
        return await self._client._adelete(f"/v1/posts/{post_id}")

    async def abulk_upload_posts(
        self, *, dry_run: bool | None = False
    ) -> dict[str, Any]:
        """Validate and schedule multiple posts from CSV (async)"""
        params = self._build_params(
            dry_run=dry_run,
        )
        return await self._client._apost("/v1/posts/bulk-upload", params=params)

    async def aretry_post(self, post_id: str) -> dict[str, Any]:
        """Retry publishing a failed or partial post (async)"""
        return await self._client._apost(f"/v1/posts/{post_id}/retry")
