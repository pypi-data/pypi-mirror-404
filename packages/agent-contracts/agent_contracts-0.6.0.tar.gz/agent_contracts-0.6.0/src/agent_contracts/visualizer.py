"""ContractVisualizer - Architecture Document Generator.

Generates comprehensive architecture documentation from NodeRegistry
contracts, including Mermaid diagrams for visual representation.
"""
from __future__ import annotations

import inspect
import os
import sys
from collections import defaultdict
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from langgraph.graph.state import CompiledStateGraph
    from agent_contracts.registry import NodeRegistry
    from agent_contracts.contracts import NodeContract, TriggerCondition


class ContractVisualizer:
    """Generate architecture documentation from node contracts.

    Args:
        - registry: NodeRegistry with registered nodes.
        - graph: Optional compiled LangGraph for flow visualization.
    Returns:
        - ContractVisualizer instance.
    """
    
    def __init__(self, registry: "NodeRegistry", graph: "CompiledStateGraph | None" = None):
        """Initialize the visualizer.

        Args:
            - registry: NodeRegistry with registered nodes.
            - graph: Optional compiled LangGraph for flow visualization.
        Returns:
            - None.
        """
        self.registry = registry
        self.graph = graph
    
    def generate_architecture_doc(self) -> str:
        """Generate the complete architecture document.

        Args:
            - None.
        Returns:
            - Markdown document with all sections.
        """
        sections = [
            self._generate_header(),
            self.generate_langgraph_flow(),  # Added LangGraph flow
            self.generate_state_slices_section(),
            self.generate_hierarchy_diagram(),
            self.generate_dataflow_diagram(),
            self.generate_trigger_hierarchy(),
            self.generate_nodes_reference(),
            self._generate_footer(),
        ]
        return "\n\n---\n\n".join(s for s in sections if s)
    
    def _generate_header(self) -> str:
        """Generate document header."""
        return """# üèóÔ∏è Agent Architecture

> Auto-generated from `NodeRegistry` contracts"""
    
    def _generate_footer(self) -> str:
        """Generate document footer."""
        return "<sub>Generated by `agent-contracts` visualizer</sub>"
    
    def generate_langgraph_flow(self) -> str:
        """Generate a LangGraph flow visualization section.

        Args:
            - None.
        Returns:
            - Markdown section with Mermaid diagram or empty string.
        """
        if not self.graph:
            self._debug("LangGraph flow skipped: graph is None")
            return ""

        mermaid = self._try_render_langgraph_mermaid()
        if not mermaid:
            self._debug("LangGraph flow skipped: mermaid rendering returned empty")
            return ""

        return f"""## üîó LangGraph Node Flow

> Auto-generated from compiled LangGraph

```mermaid
{mermaid}
```"""

    def _try_render_langgraph_mermaid(self) -> str:
        candidates: list[object] = []
        get_graph = getattr(self.graph, "get_graph", None)
        if callable(get_graph):
            try:
                candidates.append(self._call_get_graph(get_graph))
            except Exception as e:
                self._debug(
                    f"LangGraph get_graph() failed: {type(e).__name__}: {e}"
                )
                pass
        candidates.append(self.graph)

        for obj in candidates:
            for method_name in ("draw_mermaid", "to_mermaid"):
                method = getattr(obj, method_name, None)
                if not callable(method):
                    continue
                try:
                    rendered = method()
                except Exception as e:
                    self._debug(
                        f"LangGraph {type(obj).__name__}.{method_name}() failed: "
                        f"{type(e).__name__}: {e}"
                    )
                    continue

                if isinstance(rendered, bytes):
                    try:
                        rendered = rendered.decode("utf-8")
                    except Exception:
                        rendered = rendered.decode()
                elif not isinstance(rendered, str):
                    self._debug(
                        f"LangGraph {type(obj).__name__}.{method_name}() returned non-string; ignored"
                    )
                    continue

                rendered = rendered.strip()
                if rendered:
                    self._debug(f"LangGraph mermaid rendered via {type(obj).__name__}.{method_name}()")
                    return rendered

        return ""

    def _debug(self, message: str) -> None:
        if os.getenv("AGENT_CONTRACTS_DEBUG", "").strip().lower() in {"1", "true", "yes", "on"}:
            print(f"[agent-contracts][debug] {message}", file=sys.stderr)

    def _call_get_graph(self, get_graph) -> object:
        try:
            return get_graph()
        except TypeError as e:
            try:
                signature = inspect.signature(get_graph)
            except (TypeError, ValueError):
                raise e

            required = [
                p
                for p in signature.parameters.values()
                if p.default is inspect.Parameter.empty
                and p.kind
                in (inspect.Parameter.POSITIONAL_ONLY, inspect.Parameter.POSITIONAL_OR_KEYWORD)
            ]
            if len(required) == 1:
                return get_graph({})
            raise e

    
    # =========================================================================
    # State Slices Section
    # =========================================================================
    
    def generate_state_slices_section(self) -> str:
        """Generate the state slices documentation section.

        Args:
            - None.
        Returns:
            - Markdown section describing slice readers/writers.
        """
        # Collect slices from all nodes
        all_reads: set[str] = set()
        all_writes: set[str] = set()
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                all_reads.update(contract.reads)
                all_writes.update(contract.writes)
        
        all_slices = sorted(all_reads | all_writes)
        
        if not all_slices:
            return ""
        
        # Build table
        lines = [
            "## üì¶ State Slices",
            "",
            "State is organized into isolated **slices** for separation of concerns.",
            "",
            "| Slice | Read By | Written By |",
            "|:------|:--------|:-----------|",
        ]
        
        for slice_name in all_slices:
            readers = [n for n in self.registry.get_all_nodes() 
                      if slice_name in (self.registry.get_contract(n).reads or [])]
            writers = [n for n in self.registry.get_all_nodes()
                      if slice_name in (self.registry.get_contract(n).writes or [])]
            
            readers_str = ", ".join(f"`{r}`" for r in readers)
            writers_str = ", ".join(f"`{w}`" for w in writers)
                
            lines.append(f"| `{slice_name}` | {readers_str or '-'} | {writers_str or '-'} |")
        
        return "\n".join(lines)
    
    def _build_slice_relationships(self) -> list[tuple[str, str, str]]:
        """Build slice relationships from node I/O patterns."""
        # Count how many nodes transform from one slice to another
        transform_counts: dict[tuple[str, str], int] = defaultdict(int)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            for read_slice in contract.reads:
                for write_slice in contract.writes:
                    if read_slice != write_slice:
                        transform_counts[(read_slice, write_slice)] += 1
        
        # Sort by count and take top relationships
        sorted_transforms = sorted(
            transform_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:10]  # Limit to 10 most common to avoid diagram clutter
        
        return [
            (src, dst, f"{count} nodes")
            for (src, dst), count in sorted_transforms
        ]
    
    # =========================================================================
    # Hierarchy Diagram
    # =========================================================================
    
    def generate_hierarchy_diagram(self) -> str:
        """Generate the supervisor-node hierarchy diagram section.

        Args:
            - None.
        Returns:
            - Markdown section with Mermaid hierarchy diagram.
        """
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        subgraphs = self._export_subgraphs()
        if not subgraphs:
            return self._generate_flat_hierarchy_diagram(supervisors)

        return self._generate_subgraph_hierarchy_diagram(supervisors, subgraphs)

    def _generate_flat_hierarchy_diagram(self, supervisors: dict[str, list[str]]) -> str:
        lines = [
            "## üéØ System Hierarchy",
            "",
            "```mermaid",
            "flowchart TB",
        ]

        # Generate subgraphs for each supervisor
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = self._safe_id(sup_name)
            lines.append(f'    subgraph {safe_sup}["üéØ {sup_name.replace("_", " ").title()}"]')
            lines.append("        direction LR")

            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')

            lines.append("    end")

        # Add terminal node styling
        terminal_nodes = [
            self._safe_id(n) for n in self.registry.get_all_nodes()
            if self.registry.get_contract(n) and self.registry.get_contract(n).is_terminal
        ]
        if terminal_nodes:
            lines.append("")
            lines.append("    classDef terminal fill:#e94560,stroke:#16213e,color:#fff")
            lines.append(f"    class {','.join(terminal_nodes)} terminal")

        lines.append("```")

        return "\n".join(lines)

    def _generate_subgraph_hierarchy_diagram(
        self,
        supervisors: dict[str, list[str]],
        subgraphs: dict[str, dict],
    ) -> str:
        lines = [
            "## üéØ System Hierarchy",
            "",
            "```mermaid",
            "flowchart TB",
        ]

        node_to_supervisor: dict[str, str] = {}
        for sup_name, nodes in supervisors.items():
            for node_name in nodes:
                node_to_supervisor[node_name] = sup_name

        all_supervisors = set(supervisors.keys())
        subgraph_infos: list[dict[str, object]] = []
        subgraph_nodes: set[str] = set()
        subgraph_supervisors: set[str] = set()
        all_nodes = set(node_to_supervisor.keys())

        for subgraph_id, payload in sorted(subgraphs.items()):
            contract = payload.get("contract") or {}
            definition = payload.get("definition") or {}
            nodes, sub_sups = self._resolve_subgraph_scope(contract, definition)
            nodes = {node for node in nodes if node in all_nodes}
            entrypoint = contract.get("entrypoint")
            entrypoint_is_node = entrypoint in all_nodes if isinstance(entrypoint, str) else False
            entrypoint_kind = "node" if entrypoint_is_node else "supervisor"
            subgraph_infos.append(
                {
                    "id": subgraph_id,
                    "nodes": nodes,
                    "supervisors": set(sub_sups),
                    "entrypoint": entrypoint,
                    "entrypoint_kind": entrypoint_kind,
                }
            )
            subgraph_nodes.update(nodes)
            subgraph_supervisors.update(sub_sups)

        outside_nodes_by_supervisor: dict[str, list[str]] = {}
        for sup_name, nodes in supervisors.items():
            outside_nodes = [node for node in nodes if node not in subgraph_nodes]
            if outside_nodes:
                outside_nodes_by_supervisor[sup_name] = outside_nodes

        # Detect root supervisor from graph entrypoint (for supervisors without nodes)
        root_supervisors = all_supervisors - subgraph_supervisors
        root_supervisors_from_graph: set[str] = set()
        if self.graph is not None:
            # Try to detect entrypoint from graph
            if hasattr(self.graph, "get_graph"):
                try:
                    drawable = self.graph.get_graph()
                    if hasattr(drawable, "nodes"):
                        for node_name in drawable.nodes:
                            # Look for supervisor nodes that are NOT in subgraph_supervisors
                            if node_name.endswith("_supervisor"):
                                sup_name = node_name[:-11]  # Remove "_supervisor" suffix
                                if sup_name not in subgraph_supervisors and sup_name not in all_supervisors:
                                    root_supervisors_from_graph.add(sup_name)
                                    root_supervisors.add(sup_name)
                except Exception:
                    pass

        parent_supervisors_by_subgraph: dict[str, set[str]] = {}
        supervisors_needing_anchor: set[str] = set()
        for info in subgraph_infos:
            subgraph_id = info["id"]
            child_supervisors = info["supervisors"]
            if root_supervisors:
                parent_supervisors = set(root_supervisors)
            else:
                parent_supervisors = set(all_supervisors - child_supervisors)
            parent_supervisors_by_subgraph[subgraph_id] = parent_supervisors
            supervisors_needing_anchor.update(parent_supervisors)
            if info["entrypoint_kind"] == "supervisor":
                entrypoint = info["entrypoint"]
                if isinstance(entrypoint, str) and entrypoint in all_supervisors:
                    supervisors_needing_anchor.add(entrypoint)

        anchor_ids = {
            sup: self._safe_mermaid_id(f"supervisor__{sup}") for sup in supervisors_needing_anchor
        }
        anchor_locations: dict[str, tuple[str, str | None]] = {}
        for sup in supervisors_needing_anchor:
            if sup in outside_nodes_by_supervisor:
                anchor_locations[sup] = ("outside", None)
                continue
            location = None
            for info in subgraph_infos:
                if sup in info["supervisors"]:
                    location = ("subgraph", info["id"])
                    break
            if location is None:
                location = ("outside", None)
            anchor_locations[sup] = location

        # Render subgraph clusters
        for info in subgraph_infos:
            subgraph_id = info["id"]
            subgraph_label = f"üß© {subgraph_id}"
            subgraph_safe_id = self._safe_mermaid_id(f"subgraph__{subgraph_id}")
            lines.append(f'    subgraph {subgraph_safe_id}["{subgraph_label}"]')
            lines.append("        direction TB")

            nodes_by_supervisor: dict[str, list[str]] = defaultdict(list)
            for node_name in sorted(info["nodes"]):
                supervisor = node_to_supervisor.get(node_name)
                if supervisor:
                    nodes_by_supervisor[supervisor].append(node_name)

            supervisors_in_subgraph = set(nodes_by_supervisor.keys()) | set(info["supervisors"])
            for sup_name in sorted(supervisors_in_subgraph):
                nodes = nodes_by_supervisor.get(sup_name, [])
                anchor_here = anchor_locations.get(sup_name) == ("subgraph", subgraph_id)
                if not nodes and not anchor_here:
                    continue
                sup_safe_id = self._safe_mermaid_id(f"{subgraph_safe_id}__sup__{sup_name}")
                lines.append(
                    f'        subgraph {sup_safe_id}["üéØ {sup_name.replace("_", " ").title()}"]'
                )
                lines.append("            direction LR")
                if anchor_here:
                    anchor_id = anchor_ids[sup_name]
                    lines.append(f'            {anchor_id}["üß≠ {sup_name} supervisor"]')
                for node_name in nodes:
                    contract = self.registry.get_contract(node_name)
                    icon = self._get_node_icon(contract)
                    safe_node = self._safe_id(node_name)
                    lines.append(f'            {safe_node}["{icon} {node_name}"]')
                lines.append("        end")

            lines.append("    end")

        # Render top-level supervisors
        for sup_name, nodes in sorted(outside_nodes_by_supervisor.items()):
            anchor_here = anchor_locations.get(sup_name) == ("outside", None)
            if not nodes and not anchor_here:
                continue
            sup_safe_id = self._safe_mermaid_id(f"sup__{sup_name}")
            lines.append(f'    subgraph {sup_safe_id}["üéØ {sup_name.replace("_", " ").title()}"]')
            lines.append("        direction LR")
            if anchor_here:
                anchor_id = anchor_ids[sup_name]
                lines.append(f'        {anchor_id}["üß≠ {sup_name} supervisor"]')
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            lines.append("    end")

        # Render root supervisors without nodes (e.g., domain supervisor)
        for sup_name in sorted(root_supervisors_from_graph):
            anchor_id = self._safe_mermaid_id(f"supervisor__{sup_name}")
            lines.append(f'    {anchor_id}["üß≠ {sup_name} supervisor"]')

        # Render call_subgraph nodes
        call_node_ids: dict[str, str] = {}
        for info in subgraph_infos:
            subgraph_id = info["id"]
            call_node_id = self._safe_mermaid_id(f"call_subgraph__{subgraph_id}")
            call_node_ids[subgraph_id] = call_node_id
            lines.append(f'    {call_node_id}["üß© call_subgraph::{subgraph_id}"]')

        # Call edges
        for info in subgraph_infos:
            subgraph_id = info["id"]
            call_node_id = call_node_ids[subgraph_id]
            
            # Edge from root supervisors (without nodes) to call_subgraph
            for root_sup in sorted(root_supervisors_from_graph):
                root_anchor = self._safe_mermaid_id(f"supervisor__{root_sup}")
                lines.append(f"    {root_anchor} -.-> {call_node_id}")
            
            # Edge from parent supervisors to call_subgraph
            for sup_name in sorted(parent_supervisors_by_subgraph.get(subgraph_id, [])):
                if sup_name in root_supervisors_from_graph:
                    continue  # Already handled above
                anchor_id = anchor_ids.get(sup_name)
                if anchor_id:
                    lines.append(f"    {anchor_id} -.-> {call_node_id}")

            entrypoint = info["entrypoint"]
            entrypoint_label = None
            target_id = None
            if isinstance(entrypoint, str):
                if info["entrypoint_kind"] == "node" and entrypoint in all_nodes:
                    target_id = self._safe_id(entrypoint)
                    entrypoint_label = entrypoint
                elif info["entrypoint_kind"] == "supervisor":
                    target_id = anchor_ids.get(entrypoint)
                    entrypoint_label = entrypoint
            if target_id:
                label = ""
                if entrypoint_label:
                    safe_label = entrypoint_label.replace('"', "'").replace("|", "/")
                    label = f"|entry: {safe_label}| "
                lines.append(f"    {call_node_id} -->{label}{target_id}")

        # Add terminal node styling
        terminal_nodes = [
            self._safe_id(n) for n in self.registry.get_all_nodes()
            if self.registry.get_contract(n) and self.registry.get_contract(n).is_terminal
        ]
        if terminal_nodes:
            lines.append("")
            lines.append("    classDef terminal fill:#e94560,stroke:#16213e,color:#fff")
            lines.append(f"    class {','.join(terminal_nodes)} terminal")

        lines.append("```")

        return "\n".join(lines)

    def _export_subgraphs(self) -> dict[str, dict]:
        export_fn = getattr(self.registry, "export_subgraphs", None)
        if not callable(export_fn):
            return {}
        try:
            return export_fn() or {}
        except Exception as exc:
            self._debug(
                f"Subgraph export failed: {type(exc).__name__}: {exc}"
            )
            return {}

    def _resolve_subgraph_scope(
        self,
        contract: dict,
        definition: dict,
    ) -> tuple[set[str], set[str]]:
        node_names = set(definition.get("nodes") or [])
        supervisors = set(definition.get("supervisors") or [])

        entrypoint = contract.get("entrypoint")
        all_nodes = set(self.registry.get_all_nodes())

        if isinstance(entrypoint, str):
            if entrypoint in all_nodes:
                node_names.add(entrypoint)
            else:
                supervisors.add(entrypoint)

        for node_name in node_names:
            node_contract = self.registry.get_contract(node_name)
            if node_contract:
                supervisors.add(node_contract.supervisor)

        if definition.get("nodes") is None:
            nodes: set[str] = set()
            for supervisor in supervisors:
                nodes.update(self.registry.get_supervisor_nodes(supervisor))
            return nodes, supervisors

        return node_names, supervisors

    def _safe_mermaid_id(self, name: str) -> str:
        safe = self._safe_id(name)
        return safe.replace(":", "_").replace("/", "_")
    
    def _get_node_icon(self, contract: "NodeContract | None") -> str:
        """Get emoji icon for node based on its properties.
        
        Priority: 
        1. Custom icon from contract
        2. Terminal node icon
        3. LLM indicator + base icon
        4. Default icon based on common node name patterns
        """
        if not contract:
            return "üì¶"
        
        # 1. Use custom icon if provided
        if contract.icon:
            base_icon = contract.icon
        # 2. Terminal nodes
        elif contract.is_terminal:
            base_icon = "üîö"
        # 3. Common patterns (generic)
        elif "search" in contract.name.lower():
            base_icon = "üîç"
        elif "process" in contract.name.lower():
            base_icon = "‚öôÔ∏è"
        elif "validate" in contract.name.lower():
            base_icon = "‚úÖ"
        elif "notify" in contract.name.lower():
            base_icon = "üì¢"
        else:
            base_icon = "üì¶"
            
        # Add LLM indicator if applicable
        if contract.requires_llm:
            return f"ü§ñ{base_icon}"
            
        return base_icon
    
    def _safe_id(self, name: str) -> str:
        """Convert name to safe Mermaid ID."""
        return name.replace("-", "_").replace(" ", "_")
    
    # =========================================================================
    # Data Flow Diagram
    # =========================================================================
    
    def generate_dataflow_diagram(self) -> str:
        """Generate the data flow diagram section.

        Args:
            - None.
        Returns:
            - Markdown section with data flow diagram and tables.
        """
        # Group nodes by supervisor
        supervisors: dict[str, list[str]] = defaultdict(list)
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append(name)
        
        if not supervisors:
            return ""
        
        lines = [
            "## üîÄ Data Flow",
            "",
            "> Key data paths through the system",
            "",
            "```mermaid",
            "flowchart TB",
        ]
        
        # Find key nodes: entry points (read request) and terminals
        entry_nodes: list[str] = []
        terminal_nodes: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                if "request" in contract.reads:
                    entry_nodes.append(name)
                if contract.is_terminal:
                    terminal_nodes.append(name)
        
        # Add slices (excluding _internal)
        key_slices = ["request", "response"]
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                for s in contract.reads + contract.writes:
                    if not s.startswith('_') and s not in key_slices:
                        key_slices.append(s)
        
        # Slices subgraph
        lines.append('    subgraph slices["üì¶ State"]')
        for slice_name in sorted(set(key_slices)):
            icon = "üì•" if slice_name == "request" else "üì§" if slice_name == "response" else "üìÅ"
            slice_id = f"slice_{self._safe_id(slice_name)}"
            lines.append(f'        {slice_id}[("{icon} {slice_name}")]')
        lines.append("    end")
        lines.append("")
        
        # Add supervisor subgraphs with their nodes
        for sup_name, nodes in sorted(supervisors.items()):
            safe_sup = f"sup_{self._safe_id(sup_name)}"
            lines.append(f'    subgraph {safe_sup}["üéØ {sup_name}"]')
            lines.append("        direction LR")
            for node_name in nodes:
                contract = self.registry.get_contract(node_name)
                icon = self._get_node_icon(contract)
                safe_node = self._safe_id(node_name)
                lines.append(f'        {safe_node}["{icon} {node_name}"]')
            lines.append("    end")
        
        lines.append("")
        
        # Add edges: request -> entry nodes
        lines.append("    %% Entry points")
        for node_name in entry_nodes:  # Show all entry points
            lines.append(f"    slice_request --> {self._safe_id(node_name)}")
        
        # Add edges: nodes writing to response -> response
        lines.append("    %% Response outputs")
        response_writers: list[str] = []
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract and "response" in contract.writes:
                response_writers.append(name)
        for node_name in response_writers:  # Show all response writers
            lines.append(f"    {self._safe_id(node_name)} --> slice_response")
        
        # Add edges for other slices (excluding request/response/_internal)
        lines.append("    %% Slice data flows")
        other_slices = [s for s in key_slices if s not in ["request", "response"]]
        for slice_name in other_slices:
            slice_id = f"slice_{self._safe_id(slice_name)}"
            # Find readers and writers for this slice
            readers: list[str] = []
            writers: list[str] = []
            for name in self.registry.get_all_nodes():
                contract = self.registry.get_contract(name)
                if contract:
                    if slice_name in contract.reads:
                        readers.append(name)
                    if slice_name in contract.writes:
                        writers.append(name)
            # Add writer -> slice edges
            for node_name in writers:
                lines.append(f"    {self._safe_id(node_name)} -.-> {slice_id}")
            # Add slice -> reader edges
            for node_name in readers:
                lines.append(f"    {slice_id} -.-> {self._safe_id(node_name)}")
        
        # Styling
        lines.extend([
            "",
            "    classDef slice fill:#f5f5f5,stroke:#999",
            "    classDef terminal fill:#e94560,stroke:#16213e,color:#fff",
        ])
        terminal_ids = [self._safe_id(n) for n in terminal_nodes]
        if terminal_ids:
            lines.append(f"    class {','.join(terminal_ids)} terminal")
        
        lines.append("```")
        
        # Add detailed node dependencies in collapsible section
        lines.extend([
            "",
            "<details>",
            "<summary>üìä Detailed Node Dependencies</summary>",
            "",
        ])
        
        # Build dependency table grouped by supervisor
        dependencies = self.registry.analyze_data_flow()
        
        for sup_name, nodes in sorted(supervisors.items()):
            sup_deps = [(n, dependencies.get(n, [])) for n in nodes if dependencies.get(n)]
            if not sup_deps:
                continue
                
            lines.append(f"**{sup_name}**")
            lines.append("")
            lines.append("| Node | Depends On (via shared slices) |")
            lines.append("|:-----|:-------------------------------|")
            
            for node_name, deps in sup_deps:
                if deps:
                    # Find shared slices for each dependency
                    dep_info = []
                    node_contract = self.registry.get_contract(node_name)
                    for dep in deps:  # Show all dependencies
                        dep_contract = self.registry.get_contract(dep)
                        if node_contract and dep_contract:
                            shared = set(node_contract.reads) & set(dep_contract.writes)
                            shared_str = ", ".join(sorted(s for s in shared if not s.startswith('_')))
                            if shared_str:
                                dep_info.append(f"`{dep}` ({shared_str})")
                            else:
                                dep_info.append(f"`{dep}`")
                    if dep_info:
                        lines.append(f"| `{node_name}` | {', '.join(dep_info)} |")
            
            lines.append("")
        
        lines.extend([
            "</details>",
        ])
        
        return "\n".join(lines)
    
    # =========================================================================
    # Trigger Hierarchy
    # =========================================================================
    
    def generate_trigger_hierarchy(self) -> str:
        """Generate the trigger hierarchy documentation section.

        Args:
            - None.
        Returns:
            - Markdown section describing trigger priorities.
        """
        # Group by supervisor
        supervisors: dict[str, list[tuple[str, "NodeContract"]]] = defaultdict(list)
        
        for name in self.registry.get_all_nodes():
            contract = self.registry.get_contract(name)
            if contract:
                supervisors[contract.supervisor].append((name, contract))
        
        if not supervisors:
            return ""
        
        lines = [
            "## ‚ö° Trigger Hierarchy",
            "",
            "> Nodes are evaluated by **priority** (highest first)",
        ]
        
        for sup_name, nodes in sorted(supervisors.items()):
            lines.extend([
                "",
                f"### üéØ {sup_name.replace('_', ' ').title()}",
                "",
                "| Priority | Node | Condition | Hint |",
                "|:--------:|:-----|:----------|:-----|",
            ])
            
            # Sort nodes by highest trigger priority
            def get_max_priority(item: tuple[str, "NodeContract"]) -> int:
                _, contract = item
                if not contract.trigger_conditions:
                    return -1
                return max(c.priority for c in contract.trigger_conditions)
            
            sorted_nodes = sorted(nodes, key=get_max_priority, reverse=True)
            
            for name, contract in sorted_nodes:
                if not contract.trigger_conditions:
                    # No trigger conditions - default node
                    lines.append(f"| üü¢ _(default)_ | `{name}` | _(default)_ | - |")
                else:
                    # Sort conditions by priority (highest first)
                    sorted_conditions = sorted(
                        contract.trigger_conditions,
                        key=lambda c: c.priority,
                        reverse=True
                    )
                    
                    # First condition: show node name
                    first_cond = sorted_conditions[0]
                    priority_icon = self._get_priority_icon(first_cond.priority)
                    condition_str = self._format_single_condition(first_cond)
                    hint = first_cond.llm_hint or "-"
                    
                    lines.append(
                        f"| {priority_icon} **{first_cond.priority}** | "
                        f"`{name}` | {condition_str} | {hint} |"
                    )
                    
                    # Remaining conditions: use continuation symbol
                    for cond in sorted_conditions[1:]:
                        priority_icon = self._get_priority_icon(cond.priority)
                        condition_str = self._format_single_condition(cond)
                        hint = cond.llm_hint or "-"
                        
                        lines.append(
                            f"| {priority_icon} **{cond.priority}** | "
                            f"‚Ü≥ | {condition_str} | {hint} |"
                        )
            
            # Add Mermaid diagram for this supervisor
            lines.extend([
                "",
                "<details>",
                f"<summary>üìä {sup_name} Priority Chain</summary>",
                "",
                "```mermaid",
                "flowchart TD",
                f'    subgraph {self._safe_id(sup_name)}["{sup_name}"]',
                "        direction TB",
            ])
            
            prev_node = None
            for name, contract in sorted_nodes:
                if not contract.trigger_conditions:
                    # Default node
                    safe_name = self._safe_id(name)
                    lines.append(f'        {safe_name}["üü¢ P-1: {name}"]')
                    if prev_node:
                        lines.append(f'        {prev_node} -->|"not matched"| {safe_name}')
                    prev_node = safe_name
                else:
                    # Node with multiple conditions - show all in diagram
                    sorted_conditions = sorted(
                        contract.trigger_conditions,
                        key=lambda c: c.priority,
                        reverse=True
                    )
                    
                    for idx, cond in enumerate(sorted_conditions):
                        priority_icon = self._get_priority_icon(cond.priority)
                        safe_name = self._safe_id(f"{name}_cond{idx}")
                        condition_label = self._format_single_condition(cond)
                        # Escape quotes and use <br/> for line break
                        condition_label = condition_label.replace('"', "'")
                        node_label = f"{priority_icon} P{cond.priority}: {name}"
                        if len(sorted_conditions) > 1:
                            node_label += f" [{idx+1}/{len(sorted_conditions)}]"
                        lines.append(f'        {safe_name}["{node_label}<br/>{condition_label}"]')
                        
                        if prev_node:
                            lines.append(f'        {prev_node} -->|"not matched"| {safe_name}')
                        prev_node = safe_name
            
            lines.extend([
                "    end",
                "```",
                "",
                "</details>",
            ])
        
        return "\n".join(lines)
    
    def _get_priority_icon(self, priority: int) -> str:
        """Get priority indicator icon."""
        if priority >= 100:
            return "üî¥"
        elif priority >= 50:
            return "üü°"
        elif priority >= 10:
            return "üü¢"
        else:
            return "‚ö™"
    
    def _format_single_condition(self, condition: "TriggerCondition") -> str:
        """Format a single trigger condition for display.
        
        Args:
            condition: The trigger condition to format
            
        Returns:
            Formatted condition string
        """
        if not condition.when and not condition.when_not:
            return "_(always)_"
        
        parts = []
        if condition.when:
            for key, value in list(condition.when.items())[:2]:
                parts.append(f"`{key}={value}`")
        if condition.when_not:
            for key, value in list(condition.when_not.items())[:1]:
                parts.append(f"`{key}‚â†{value}`")
        
        result = ", ".join(parts) if parts else "_(always)_"
        
        # Show count if truncated
        total_items = len(condition.when or {}) + len(condition.when_not or {})
        if total_items > 3:
            result += f" _(+{total_items - 3} more)_"
        
        return result
    
    def _summarize_conditions(self, conditions: list["TriggerCondition"]) -> str:
        """Summarize trigger conditions for display.
        
        DEPRECATED: Use _format_single_condition() for individual conditions.
        This method only returns the highest priority condition.
        """
        if not conditions:
            return "_(default)_"
        
        # Get highest priority condition
        highest = max(conditions, key=lambda c: c.priority)
        return self._format_single_condition(highest)
    
    # =========================================================================
    # Nodes Reference
    # =========================================================================
    
    def generate_nodes_reference(self) -> str:
        """Generate the nodes reference table section.

        Args:
            - None.
        Returns:
            - Markdown section with node references.
        """
        nodes = self.registry.get_all_nodes()
        
        if not nodes:
            return ""
        
        lines = [
            "## üìö Nodes Reference",
            "",
            "| Node | Supervisor | Reads | Writes | LLM | Terminal |",
            "|:-----|:-----------|:------|:-------|:---:|:--------:|",
        ]
        
        for name in sorted(nodes):
            contract = self.registry.get_contract(name)
            if not contract:
                continue
            
            reads = ", ".join(f"`{r}`" for r in contract.reads) or "-"
            writes = ", ".join(f"`{w}`" for w in contract.writes) or "-"
            llm = "‚úÖ" if contract.requires_llm else ""
            terminal = "üîö" if contract.is_terminal else ""
            
            lines.append(f"| `{name}` | {contract.supervisor} | {reads} | {writes} | {llm} | {terminal} |")
        
        lines.extend([
            "",
            "<details>",
            "<summary>üîç Legend</summary>",
            "",
            "- ‚úÖ = Requires LLM",
            "- üîö = Terminal node (exits to END)",
            "- Reads/Writes = State slices accessed",
            "",
            "</details>",
        ])
        
        return "\n".join(lines)
