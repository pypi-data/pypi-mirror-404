"""Tests for ContractVisualizer."""
import pytest
from unittest.mock import MagicMock
from agent_contracts import (
    NodeRegistry,
    NodeContract,
    TriggerCondition,
    ModularNode,
    NodeInputs,
    NodeOutputs,
    ContractVisualizer,
    SubgraphContract,
    SubgraphDefinition,
)


# =============================================================================
# Test Fixtures
# =============================================================================

class InterviewerNode(ModularNode):
    """Mock interviewer node."""
    CONTRACT = NodeContract(
        name="interviewer",
        description="Conducts user interview",
        reads=["request", "shopping"],
        writes=["shopping", "response"],
        supervisor="shopping",
        requires_llm=True,
        trigger_conditions=[
            TriggerCondition(
                priority=10,
                when={"request.action": "interview"},
                llm_hint="Continue interview when action is interview",
            ),
        ],
    )
    
    async def execute(self, inputs: NodeInputs) -> NodeOutputs:
        return NodeOutputs(response={})


class LikeHandlerNode(ModularNode):
    """Mock like handler node."""
    CONTRACT = NodeContract(
        name="like_handler",
        description="Handles product likes",
        reads=["request", "card", "shopping"],
        writes=["card", "shopping"],
        supervisor="shopping",
        trigger_conditions=[
            TriggerCondition(
                priority=100,
                when={"request.action": "like"},
                llm_hint="Handle LIKE action",
            ),
        ],
    )
    
    async def execute(self, inputs: NodeInputs) -> NodeOutputs:
        return NodeOutputs(card={})


class CardCreatorNode(ModularNode):
    """Mock card creator node."""
    CONTRACT = NodeContract(
        name="card_creator",
        description="Creates the final card",
        reads=["card"],
        writes=["response"],
        supervisor="card",
        requires_llm=True,
        is_terminal=True,
    )
    
    async def execute(self, inputs: NodeInputs) -> NodeOutputs:
        return NodeOutputs(response={})


@pytest.fixture
def registry() -> NodeRegistry:
    """Create registry with test nodes."""
    reg = NodeRegistry(valid_slices={"request", "response", "shopping", "card", "_internal"})
    reg.register(InterviewerNode)
    reg.register(LikeHandlerNode)
    reg.register(CardCreatorNode)
    return reg


@pytest.fixture
def visualizer(registry: NodeRegistry) -> ContractVisualizer:
    """Create visualizer instance."""
    return ContractVisualizer(registry)


# =============================================================================
# Test Cases
# =============================================================================

class TestContractVisualizer:
    """Tests for ContractVisualizer."""
    
    def test_generate_architecture_doc(self, visualizer: ContractVisualizer):
        """Test full document generation."""
        doc = visualizer.generate_architecture_doc()
        
        # Check header
        assert "# ğŸ—ï¸ Agent Architecture" in doc
        
        # Check all major sections exist
        assert "## ğŸ“¦ State Slices" in doc
        assert "## ğŸ¯ System Hierarchy" in doc
        assert "## âš¡ Trigger Hierarchy" in doc
        assert "## ğŸ“š Nodes Reference" in doc
        
        # Check footer
        assert "Generated by `agent-contracts`" in doc
    
    def test_state_slices_section(self, visualizer: ContractVisualizer):
        """Test state slices section generation."""
        section = visualizer.generate_state_slices_section()
        
        # Check header
        assert "## ğŸ“¦ State Slices" in section
        
        # Check table headers
        assert "| Slice | Read By | Written By |" in section
        
        # Check slices are listed
        assert "`request`" in section
        assert "`response`" in section
    
    def test_hierarchy_diagram(self, visualizer: ContractVisualizer):
        """Test supervisor hierarchy diagram."""
        section = visualizer.generate_hierarchy_diagram()
        
        # Check Mermaid flowchart
        assert "```mermaid" in section
        assert "flowchart TB" in section
        
        # Check supervisors as subgraphs
        assert "Shopping" in section or "shopping" in section
        assert "Card" in section or "card" in section
        
        # Check nodes are included
        assert "interviewer" in section
        assert "like_handler" in section
        assert "card_creator" in section
        
        # Check terminal styling
        assert "classDef terminal" in section
    
    def test_trigger_hierarchy(self, visualizer: ContractVisualizer):
        """Test trigger hierarchy documentation."""
        section = visualizer.generate_trigger_hierarchy()
        
        # Check priority indicators
        assert "ğŸ”´" in section  # High priority (100)
        assert "ğŸŸ¢" in section  # Low priority (10)
        
        # Check table structure
        assert "| Priority |" in section
        assert "| Node |" in section
        
        # Check nodes are listed
        assert "`like_handler`" in section
        assert "`interviewer`" in section
        
        # Check conditions are shown
        assert "request.action" in section
    
    def test_nodes_reference(self, visualizer: ContractVisualizer):
        """Test nodes reference table."""
        section = visualizer.generate_nodes_reference()
        
        # Check table headers
        assert "| Node |" in section
        assert "| Supervisor |" in section
        assert "| Reads |" in section
        assert "| Writes |" in section
        assert "| LLM |" in section
        assert "| Terminal |" in section
        
        # Check LLM indicators
        assert "âœ…" in section  # LLM required
        
        # Check terminal indicator
        assert "ğŸ”š" in section  # Terminal node
        
        # Check legend
        assert "<details>" in section
        assert "Legend" in section
    
    def test_empty_registry(self):
        """Test with empty registry."""
        reg = NodeRegistry()
        viz = ContractVisualizer(reg)
        
        doc = viz.generate_architecture_doc()
        
        # Should still have header and footer
        assert "# ğŸ—ï¸ Agent Architecture" in doc
        assert "Generated by" in doc
    
    def test_dataflow_diagram(self, visualizer: ContractVisualizer):
        """Test data flow diagram generation."""
        section = visualizer.generate_dataflow_diagram()
        
        # Check Mermaid flowchart
        assert "```mermaid" in section
        assert "flowchart TB" in section
        
        # Check slices are shown in State subgraph
        assert "request" in section
        assert "response" in section
        
        # Check supervisors are shown as subgraphs
        assert "shopping" in section
        assert "card" in section
        
        # Check terminal node styling
        assert "terminal" in section

    def test_generate_langgraph_flow_with_graph(self, registry: NodeRegistry):
        mock_graph = MagicMock()
        mock_graph.get_graph.return_value.draw_mermaid.return_value = "flowchart TD\n  A --> B"
        viz = ContractVisualizer(registry, graph=mock_graph)

        section = viz.generate_langgraph_flow()
        assert "LangGraph Node Flow" in section
        assert "```mermaid" in section
        assert "A --> B" in section

    def test_generate_langgraph_flow_with_direct_draw_mermaid(self, registry: NodeRegistry):
        mock_graph = MagicMock()
        del mock_graph.get_graph
        mock_graph.draw_mermaid.return_value = "flowchart TD\n  X --> Y"
        viz = ContractVisualizer(registry, graph=mock_graph)

        section = viz.generate_langgraph_flow()
        assert "LangGraph Node Flow" in section
        assert "```mermaid" in section
        assert "X --> Y" in section


class TestPriorityIcons:
    """Tests for priority icon assignment."""
    
    def test_priority_icons(self, visualizer: ContractVisualizer):
        """Test priority icon thresholds."""
        assert visualizer._get_priority_icon(100) == "ğŸ”´"
        assert visualizer._get_priority_icon(150) == "ğŸ”´"
        assert visualizer._get_priority_icon(50) == "ğŸŸ¡"
        assert visualizer._get_priority_icon(75) == "ğŸŸ¡"
        assert visualizer._get_priority_icon(10) == "ğŸŸ¢"
        assert visualizer._get_priority_icon(25) == "ğŸŸ¢"
        assert visualizer._get_priority_icon(5) == "âšª"
        assert visualizer._get_priority_icon(-1) == "âšª"


class TestNodeIcons:
    """Tests for node icon assignment."""
    
    def test_terminal_icon(self, registry: NodeRegistry, visualizer: ContractVisualizer):
        """Test terminal node gets terminal icon."""
        contract = registry.get_contract("card_creator")
        icon = visualizer._get_node_icon(contract)
        # LLM + Terminal
        assert icon == "ğŸ¤–ğŸ”š"
    
    def test_llm_icon(self, registry: NodeRegistry, visualizer: ContractVisualizer):
        """Test LLM node gets robot icon."""
        contract = registry.get_contract("interviewer")
        icon = visualizer._get_node_icon(contract)
        # LLM + default (ğŸ“¦) since 'interview' icon was removed
        assert icon == "ğŸ¤–ğŸ“¦"
    
    def test_like_icon(self, registry: NodeRegistry, visualizer: ContractVisualizer):
        """Test like handler gets default icon (domain icons removed)."""
        contract = registry.get_contract("like_handler")
        icon = visualizer._get_node_icon(contract)
        # Domain-specific icons removed, now uses default
        assert icon == "ğŸ“¦"

    def test_search_icon(self, visualizer: ContractVisualizer):
        """Test search node gets search icon."""
        contract = NodeContract(
            name="search_node",
            description="Search",
            reads=[], writes=[],
            supervisor="main"
        )
        icon = visualizer._get_node_icon(contract)
        assert icon == "ğŸ”"

    def test_default_icon(self, visualizer: ContractVisualizer):
        """Test unknown node type gets default icon."""
        contract = NodeContract(
            name="unknown_node",
            description="Unknown",
            reads=[], writes=[],
            supervisor="main"
        )
        icon = visualizer._get_node_icon(contract)
        assert icon == "ğŸ“¦"

    def test_none_contract_icon(self, visualizer: ContractVisualizer):
        """Test None contract returns default icon."""
        assert visualizer._get_node_icon(None) == "ğŸ“¦"


class TestConditionSummaries:
    """Tests for condition summarization."""

    def test_summarize_when_not(self, visualizer: ContractVisualizer):
        """Test summarizing when_not conditions."""
        conditions = [
            TriggerCondition(when_not={"done": True}, priority=10)
        ]
        summary = visualizer._summarize_conditions(conditions)
        assert "doneâ‰ True" in summary

    def test_summarize_no_conditions(self, visualizer: ContractVisualizer):
        """Test summarizing empty conditions."""
        assert visualizer._summarize_conditions([]) == "_(default)_"

    def test_summarize_always(self, visualizer: ContractVisualizer):
        """Test summarizing always valid condition."""
        conditions = [
            TriggerCondition(priority=10)
        ]
        summary = visualizer._summarize_conditions(conditions)
        assert "_(always)_" in summary


class TestLangGraphFlow:
    """Tests for LangGraph flow generation."""

    def test_generate_langgraph_flow_no_graph(self, visualizer: ContractVisualizer):
        """Test returns empty string when no graph provided."""
        visualizer.graph = None
        assert visualizer.generate_langgraph_flow() == ""

    def test_generate_langgraph_flow_success(self, visualizer: ContractVisualizer):
        """Test returns mermaid diagram when graph provided."""
        mock_graph = MagicMock()
        mock_graph.get_graph.return_value.draw_mermaid.return_value = "graph TD"
        
        visualizer.graph = mock_graph
        flow = visualizer.generate_langgraph_flow()
        
        assert "LangGraph Node Flow" in flow
        assert "graph TD" in flow

    def test_generate_langgraph_flow_error(self, visualizer: ContractVisualizer):
        """Test handles graph generation errors gracefully."""
        mock_graph = MagicMock()
        mock_graph.get_graph.side_effect = RuntimeError("Graph error")
        
        visualizer.graph = mock_graph
        assert visualizer.generate_langgraph_flow() == ""

    def test_generate_langgraph_flow_bytes_mermaid(self, registry: NodeRegistry):
        class Drawable:
            def draw_mermaid(self):
                return b"graph TD\n  A --> B"

        class Graph:
            def get_graph(self):
                return Drawable()

        viz = ContractVisualizer(registry, graph=Graph())
        section = viz.generate_langgraph_flow()
        assert "graph TD" in section
        assert "A --> B" in section

    def test_generate_langgraph_flow_non_string_mermaid(self, registry: NodeRegistry):
        class Graph:
            def draw_mermaid(self):
                return 123

        viz = ContractVisualizer(registry, graph=Graph())
        assert viz.generate_langgraph_flow() == ""

    def test_generate_langgraph_flow_get_graph_requires_arg(self, registry: NodeRegistry):
        class Drawable:
            def to_mermaid(self):
                return "graph TD\n  X --> Y"

        class Graph:
            def get_graph(self, _payload):
                return Drawable()

        viz = ContractVisualizer(registry, graph=Graph())
        section = viz.generate_langgraph_flow()
        assert "graph TD" in section
        assert "X --> Y" in section


class TestSubgraphExport:
    def test_export_subgraphs_handles_exception(self):
        registry = MagicMock()

        def _raise():
            raise RuntimeError("boom")

        registry.export_subgraphs = _raise
        viz = ContractVisualizer(registry)
        assert viz._export_subgraphs() == {}


class TestDetailedDependencies:
    """Tests for detailed dependency generation."""

    def test_detailed_dependencies_table(self, visualizer: ContractVisualizer):
        """Test detailed dependency table in dataflow diagram."""
        # Setup nodes with clear dependencies via slices
        class Producer(ModularNode):
            CONTRACT = NodeContract(
                name="producer",
                description="Produces data",
                reads=[],
                writes=["shared_data"],
                supervisor="main"
            )
            async def execute(self, inputs): return NodeOutputs()

        class Consumer(ModularNode):
            CONTRACT = NodeContract(
                name="consumer",
                description="Consumes data",
                reads=["shared_data"],
                writes=[],
                supervisor="main"
            )
            async def execute(self, inputs): return NodeOutputs()

        registry = NodeRegistry()
        registry.register(Producer)
        registry.register(Consumer)
        
        viz = ContractVisualizer(registry)
        section = viz.generate_dataflow_diagram()
        
        # Check for dependency table entries
        assert "Detailed Node Dependencies" in section
        assert "| Node | Depends On (via shared slices) |" in section
        # Consumer depends on Producer via shared_data
        assert "`consumer`" in section
        assert "`producer`" in section
        assert "shared_data" in section

    def test_build_slice_relationships(self, visualizer: ContractVisualizer):
        """Test building slice relationship statistics."""
        class TransformNode(ModularNode):
            CONTRACT = NodeContract(
                name="transform",
                description="Transforms A to B",
                reads=["slice_a"],
                writes=["slice_b"],
                supervisor="main"
            )
            async def execute(self, inputs): return NodeOutputs()
            
        registry = NodeRegistry()
        registry.register(TransformNode)
        
        viz = ContractVisualizer(registry)
        relationships = viz._build_slice_relationships()
        
        # Should find one relationship: slice_a -> slice_b
        assert len(relationships) == 1
        src, dst, count = relationships[0]
        assert src == "slice_a"
        assert dst == "slice_b"
        assert "1 nodes" in count

    def test_card_icon(self, registry: NodeRegistry, visualizer: ContractVisualizer):
        """Test card node gets default icon (domain icons removed)."""
        # Need to register a node with 'card' in name but not terminal
        class CardNode(ModularNode):
            CONTRACT = NodeContract(
                name="card_viewer",
                description="View card",
                reads=[], writes=[],
                supervisor="main"
            )
            async def execute(self, inputs): return NodeOutputs()
            
        registry.register(CardNode)
        contract = registry.get_contract("card_viewer")
        icon = visualizer._get_node_icon(contract)
        # Domain-specific icons removed, now uses default
        assert icon == "ğŸ“¦"


class TestMultipleTriggerConditions:
    """Tests for nodes with multiple trigger conditions."""
    
    def test_multiple_triggers_display_all_conditions(self):
        """Test that all trigger conditions are displayed for a node."""
        class MultiTriggerNode(ModularNode):
            CONTRACT = NodeContract(
                name="multi_trigger",
                description="Multiple triggers",
                reads=["request"],
                writes=["response"],
                supervisor="main",
                trigger_conditions=[
                    TriggerCondition(
                        priority=100,
                        when={"request.action": "like"},
                        llm_hint="Handle LIKE action"
                    ),
                    TriggerCondition(
                        priority=90,
                        when={"request.action": "dislike"},
                        llm_hint="Handle DISLIKE action"
                    ),
                    TriggerCondition(
                        priority=80,
                        when={"request.action": "skip"},
                        llm_hint="Handle SKIP action"
                    ),
                ]
            )
            async def execute(self, inputs): return NodeOutputs()
        
        registry = NodeRegistry()
        registry.register(MultiTriggerNode)
        viz = ContractVisualizer(registry)
        
        section = viz.generate_trigger_hierarchy()
        
        # Check that node name appears once
        assert section.count("`multi_trigger`") == 1
        
        # Check that continuation symbol appears for additional conditions
        assert section.count("â†³") == 2
        
        # Check all conditions are visible
        assert "request.action=like" in section or "action=like" in section
        assert "request.action=dislike" in section or "action=dislike" in section
        assert "request.action=skip" in section or "action=skip" in section
        
        # Check all priorities are shown
        assert "**100**" in section
        assert "**90**" in section
        assert "**80**" in section
        
        # Check all hints are shown
        assert "Handle LIKE action" in section
        assert "Handle DISLIKE action" in section
        assert "Handle SKIP action" in section
    
    def test_multiple_triggers_in_mermaid_diagram(self):
        """Test that Mermaid diagram shows all trigger conditions."""
        class MultiTriggerNode(ModularNode):
            CONTRACT = NodeContract(
                name="multi_trigger",
                description="Multiple triggers",
                reads=[], writes=[],
                supervisor="main",
                trigger_conditions=[
                    TriggerCondition(priority=100, when={"action": "a"}),
                    TriggerCondition(priority=90, when={"action": "b"}),
                ]
            )
            async def execute(self, inputs): return NodeOutputs()
        
        registry = NodeRegistry()
        registry.register(MultiTriggerNode)
        viz = ContractVisualizer(registry)
        
        section = viz.generate_trigger_hierarchy()
        
        # Check Mermaid diagram contains multiple condition nodes
        assert "multi_trigger_cond0" in section
        assert "multi_trigger_cond1" in section
        
        # Check priorities in diagram
        assert "P100" in section
        assert "P90" in section
        
        # Check condition counter [1/2], [2/2]
        assert "[1/2]" in section
        assert "[2/2]" in section
    
    def test_single_trigger_no_continuation_symbol(self):
        """Test that single trigger condition doesn't show continuation symbol."""
        class SingleTriggerNode(ModularNode):
            CONTRACT = NodeContract(
                name="single_trigger",
                description="Single trigger",
                reads=[], writes=[],
                supervisor="main",
                trigger_conditions=[
                    TriggerCondition(priority=50, when={"action": "test"}),
                ]
            )
            async def execute(self, inputs): return NodeOutputs()
        
        registry = NodeRegistry()
        registry.register(SingleTriggerNode)
        viz = ContractVisualizer(registry)
        
        section = viz.generate_trigger_hierarchy()
        
        # Should not have continuation symbol
        assert "â†³" not in section
        
        # Should show the node name normally
        assert "`single_trigger`" in section
        assert "**50**" in section
    
    def test_format_single_condition_truncation(self, visualizer: ContractVisualizer):
        """Test that _format_single_condition truncates long conditions."""
        # Create a condition with many fields
        condition = TriggerCondition(
            priority=50,
            when={
                "field1": "value1",
                "field2": "value2",
                "field3": "value3",
                "field4": "value4",
            },
            when_not={"field5": "value5"}
        )
        
        result = visualizer._format_single_condition(condition)
        
        # Should show truncation indicator
        assert "more" in result
        
        # Should show at least some fields
        assert "field1" in result or "field2" in result
    
    def test_format_single_condition_always(self, visualizer: ContractVisualizer):
        """Test formatting condition with no when/when_not."""
        condition = TriggerCondition(priority=50)
        result = visualizer._format_single_condition(condition)
        assert result == "_(always)_"
    
    def test_format_single_condition_with_when_not(self, visualizer: ContractVisualizer):
        """Test formatting condition with when_not."""
        condition = TriggerCondition(
            priority=50,
            when={"action": "test"},
            when_not={"done": True}
        )
        result = visualizer._format_single_condition(condition)
        
        assert "action=test" in result or "action='test'" in result
        assert "doneâ‰ True" in result or "doneâ‰ " in result


class TestVisualizerEdgeCases:
    """Test edge cases and defensive code paths in visualizer."""
    
    def test_build_relationships_missing_contract(self):
        """Test _build_slice_relationships passes when contract is missing."""
        registry = MagicMock()
        registry.get_all_nodes.return_value = ["node1"]
        registry.get_contract.return_value = None  # Force missing contract
        
        viz = ContractVisualizer(registry)
        relationships = viz._build_slice_relationships()
        assert relationships == []
        
    def test_dataflow_missing_contract_in_deps(self):
        """Test data flow diagram with node having dependencies but no shared slices."""
        # This covers lines 399 (else branch)
        registry = MagicMock()
        
        node_contract = NodeContract(
            name="node1", description="desc",
            reads=["slice_a"], writes=[], supervisor="sup"
        )
        dep_contract = NodeContract(
            name="node2", description="desc",
            reads=[], writes=["slice_b"], supervisor="sup"
        )
        
        registry.get_all_nodes.return_value = ["node1", "node2"]
        # Allow looking up contracts
        registry.get_contract.side_effect = lambda n: {
            "node1": node_contract, 
            "node2": dep_contract
        }.get(n)
        
        # Force a dependency relationship even without shared slices
        registry.analyze_data_flow.return_value = {"node1": ["node2"]}
        
        viz = ContractVisualizer(registry)
        section = viz.generate_dataflow_diagram()
        
        # Check that we have the Detailed Node Dependencies section
        assert "Detailed Node Dependencies" in section
        
        # Check that node1 is listed as having dependencies
        assert "| `node1` |" in section
        
        # Check that node2 is listed as a dependency
        # It should appear as `node2` since there are no shared slices
        assert "`node2`" in section
        
        # Ensure slice_a (which is not shared) is NOT mentioned in the dependency column
        # It might appear elsewhere in the diagram, but we check nearby context if possible
        # Or simpler: just ensure it's generated successfully without crashing

    def test_dataflow_no_dependencies(self):
        """Test data flow diagram gracefully handles nodes with no dependencies."""
        # This covers line 379 (continue when no sup_deps)
        registry = MagicMock()
        
        node_contract = NodeContract(
            name="node1", description="desc",
            reads=[], writes=[], supervisor="sup"
        )
        
        registry.get_all_nodes.return_value = ["node1"]
        registry.get_contract.return_value = node_contract
        registry.analyze_data_flow.return_value = {}  # No dependencies
        
        viz = ContractVisualizer(registry)
        section = viz.generate_dataflow_diagram()
        
        # Should NOT have the supervisor section in the table since no deps
        assert "**sup**" not in section
        assert "| Node | Depends On" not in section
        
    def test_nodes_reference_missing_contract(self):
        """Test generate_nodes_reference passes when contract is missing."""
        # Covers line 545
        registry = MagicMock()
        registry.get_all_nodes.return_value = ["node1"]
        registry.get_contract.return_value = None
        
        viz = ContractVisualizer(registry)
        section = viz.generate_nodes_reference()
        
        # Header exists but no rows
        assert "Nodes Reference" in section
        assert "| Node | Supervisor |" in section
        assert "| node1 |" not in section


class TestHierarchySubgraphs:
    """Tests for hierarchy diagram with subgraphs."""

    def test_hierarchy_diagram_includes_subgraph_calls(self):
        class ParentNode(ModularNode):
            CONTRACT = NodeContract(
                name="parent_node",
                description="Parent node",
                reads=["request"],
                writes=["response"],
                supervisor="main",
            )

            async def execute(self, inputs): return NodeOutputs()

        class ChildNode(ModularNode):
            CONTRACT = NodeContract(
                name="child_node",
                description="Child node",
                reads=["request"],
                writes=["response"],
                supervisor="child",
            )

            async def execute(self, inputs): return NodeOutputs()

        registry = NodeRegistry()
        registry.register(ParentNode)
        registry.register(ChildNode)

        contract = SubgraphContract(
            subgraph_id="child_graph",
            description="Child subgraph",
            reads=["request"],
            writes=["response"],
            entrypoint="child",
        )
        definition = SubgraphDefinition(
            subgraph_id="child_graph",
            supervisors=["child"],
            nodes=["child_node"],
        )
        registry.register_subgraph(contract, definition)

        viz = ContractVisualizer(registry)
        section = viz.generate_hierarchy_diagram()

        assert "ğŸ§© child_graph" in section
        assert "call_subgraph::child_graph" in section
        assert "entry: child" in section
        assert any(
            "call_subgraph__child_graph" in line and "-.->" in line
            for line in section.splitlines()
        )
