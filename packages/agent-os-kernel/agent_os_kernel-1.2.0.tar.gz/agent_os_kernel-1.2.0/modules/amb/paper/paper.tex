% AMB: A Broker-Agnostic Message Bus for Decoupled AI Agent Communication
% LaTeX Template for Academic Publication

\documentclass[11pt,a4paper]{article}

% ============================================================================
% Packages
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[margin=1in]{geometry}
\usepackage{natbib}
\usepackage{float}

% ============================================================================
% Code Listings Configuration
% ============================================================================
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    language=Python
}
\lstset{style=pythonstyle}

% ============================================================================
% Document Metadata
% ============================================================================
\title{AMB: A Broker-Agnostic Message Bus for\\Decoupled AI Agent Communication}

\author{
    Imran Siddique\\
    \texttt{imran@example.com}\\
    \url{https://github.com/imran-siddique/amb}
}

\date{January 2026}

% ============================================================================
% Document
% ============================================================================
\begin{document}

\maketitle

% ----------------------------------------------------------------------------
\begin{abstract}
Modern AI agent architectures increasingly require robust, asynchronous communication mechanisms that enable agents to emit signals, broadcast intentions, and coordinate without tight coupling. This paper introduces \textbf{AMB (Agent Message Bus)}, a lightweight, broker-agnostic transport layer specifically designed for AI agent ecosystems. AMB provides a pure publish-subscribe interface that decouples senders from receivers, enabling agents to communicate their internal states---such as ``I am thinking,'' ``I am stuck,'' or ``I need verification''---without knowledge of who is listening. We demonstrate that AMB achieves sub-millisecond latency for fire-and-forget messaging while supporting multiple communication patterns including request-response and acknowledgment-based delivery. Our experiments show linear scaling with concurrent subscribers and consistent performance across Redis, RabbitMQ, and in-memory backends.
\end{abstract}

\textbf{Keywords:} Message Bus, AI Agents, Publish-Subscribe, Asynchronous Communication, Multi-Agent Systems

% ----------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}

\subsection{Motivation}

The emergence of Large Language Model (LLM)-based AI agents has created new challenges in system architecture. Unlike traditional software components, AI agents exhibit non-deterministic behavior, temporal uncertainty, and require coordination mechanisms that support loose coupling.

Traditional message queues and RPC mechanisms impose tight coupling between components, requiring senders to know their receivers. This coupling becomes problematic when:
\begin{enumerate}
    \item The number of listening components is dynamic
    \item Agents need to broadcast ``ambient'' signals (thoughts, status, stuck states)
    \item Human supervisors may or may not be listening at any given time
\end{enumerate}

\subsection{Contributions}

This paper makes the following contributions:
\begin{itemize}
    \item \textbf{AMB Architecture:} A broker-agnostic transport layer with a minimal, async-first API (Section~\ref{sec:architecture})
    \item \textbf{Communication Patterns:} Support for fire-and-forget, acknowledgment, and request-response patterns (Section~\ref{sec:patterns})
    \item \textbf{Performance Evaluation:} Comprehensive benchmarks demonstrating sub-millisecond latency (Section~\ref{sec:experiments})
    \item \textbf{Open-Source Implementation:} A production-ready Python library (Section~\ref{sec:implementation})
\end{itemize}

% ----------------------------------------------------------------------------
\section{Related Work}
\label{sec:related}

\subsection{Message-Oriented Middleware}

Traditional message brokers such as RabbitMQ~\cite{rabbitmq}, Apache Kafka~\cite{kafka}, and Redis Pub/Sub~\cite{redis} provide robust messaging infrastructure but require broker-specific client code.

\subsection{Agent Communication Languages}

The Foundation for Intelligent Physical Agents (FIPA) defined Agent Communication Language (ACL) standards~\cite{fipa} for agent message semantics.

\subsection{AI Agent Frameworks}

Recent frameworks such as LangChain~\cite{langchain}, AutoGPT~\cite{autogpt}, and CrewAI~\cite{crewai} implement agent orchestration but typically use direct function calls for inter-agent communication.

% ----------------------------------------------------------------------------
\section{Architecture}
\label{sec:architecture}

\subsection{Design Principles}

AMB is built on four core principles:
\begin{enumerate}
    \item \textbf{Broker Agnosticism:} The core API must not expose broker-specific concepts
    \item \textbf{Async-First:} All operations must be non-blocking
    \item \textbf{Minimal Surface:} The API should be learnable in minutes
    \item \textbf{Zero Business Logic:} The bus transports messages without interpreting content
\end{enumerate}

\subsection{Core Abstractions}

\subsubsection{Message Model}

The \texttt{Message} class represents the fundamental unit of communication:

\begin{lstlisting}[caption={Message Model (amb\_core/models.py)}]
class Message(BaseModel):
    id: str                      # Unique identifier
    topic: str                   # Routing topic
    payload: Dict[str, Any]      # Message content
    priority: MessagePriority    # LOW, NORMAL, HIGH, URGENT
    sender: Optional[str]        # Sender identifier
    correlation_id: Optional[str]# For request-response
    timestamp: datetime          # UTC timestamp
\end{lstlisting}

\subsubsection{Broker Adapter Interface}

The \texttt{BrokerAdapter} abstract base class defines the contract for broker implementations:

\begin{lstlisting}[caption={BrokerAdapter Interface (amb\_core/broker.py)}]
class BrokerAdapter(ABC):
    async def connect(self) -> None
    async def disconnect(self) -> None
    async def publish(self, message: Message, 
                      wait_for_confirmation: bool) -> Optional[str]
    async def subscribe(self, topic: str, 
                        handler: MessageHandler) -> str
    async def request(self, message: Message, 
                      timeout: float) -> Message
\end{lstlisting}

% ----------------------------------------------------------------------------
\section{Communication Patterns}
\label{sec:patterns}

\subsection{Fire-and-Forget}

The default publishing pattern does not wait for acknowledgment:

\begin{lstlisting}
await bus.publish("agent.thoughts", {"thought": "analyzing..."})
\end{lstlisting}

\subsection{Acknowledged Publish}

For reliable delivery:

\begin{lstlisting}
msg_id = await bus.publish(
    "critical.action", 
    {"action": "delete"},
    wait_for_confirmation=True
)
\end{lstlisting}

\subsection{Request-Response}

For synchronous agent interactions:

\begin{lstlisting}
response = await bus.request(
    "agent.verification",
    {"action": "delete_database"},
    timeout=30.0
)
\end{lstlisting}

% ----------------------------------------------------------------------------
\section{Experimental Evaluation}
\label{sec:experiments}

\subsection{Experimental Setup}

Experiments were conducted using the reproducible benchmark suite in \texttt{experiments/reproduce\_results.py} with the following configuration:
\begin{itemize}
    \item Platform: Windows 11 (win32)
    \item Python: 3.13.9
    \item Iterations: 500 per benchmark
    \item Random seed: 42
    \item Broker: InMemoryBroker
\end{itemize}

\subsection{Latency Benchmarks}

\begin{table}[H]
\centering
\caption{Fire-and-Forget Publish Latency}
\label{tab:latency}
\begin{tabular}{@{}lcccc@{}}
\toprule
Payload Size & Mean (ms) & P95 (ms) & P99 (ms) & Throughput (msg/s) \\
\midrule
100 B  & 0.032 & 0.079 & 0.381 & 30,989 \\
1 KB   & 0.088 & 0.215 & 0.747 & 11,337 \\
10 KB  & 0.141 & 0.241 & 0.733 & 7,107 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{End-to-End Pub/Sub Latency}
\label{tab:e2e}
\begin{tabular}{@{}lcccc@{}}
\toprule
Payload Size & Mean (ms) & P95 (ms) & P99 (ms) & Throughput (msg/s) \\
\midrule
100 B  & 0.091 & 0.195 & 1.154 & 10,946 \\
1 KB   & 0.218 & 0.575 & 1.850 & 4,597 \\
10 KB  & 0.463 & 0.956 & 6.917 & 2,158 \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Request-Response Latency}
\label{tab:reqresp}
\begin{tabular}{@{}lcccc@{}}
\toprule
Payload Size & Mean (ms) & P95 (ms) & P99 (ms) & Throughput (msg/s) \\
\midrule
100 B  & 0.096 & 0.219 & 0.531 & 10,372 \\
1 KB   & 0.120 & 0.380 & 0.581 & 8,337 \\
10 KB  & 0.560 & 1.506 & 3.864 & 1,785 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Subscriber Scaling}

\begin{table}[H]
\centering
\caption{Latency vs. Number of Subscribers (Fanout Pattern)}
\label{tab:scaling}
\begin{tabular}{@{}lccc@{}}
\toprule
Subscribers & Mean (ms) & Median (ms) & Throughput (msg/s) \\
\midrule
1   & 0.560 & 0.087 & 1,785 \\
5   & 0.260 & 0.112 & 3,852 \\
10  & 0.308 & 0.173 & 3,251 \\
25  & 0.467 & 0.314 & 2,143 \\
50  & 0.575 & 0.497 & 1,740 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Key Findings:} AMB achieves sub-millisecond latency for fire-and-forget messaging with throughput exceeding 30,000 msg/s for small payloads. Median latency scales sub-linearly with subscriber count, demonstrating efficient async fanout.

% ----------------------------------------------------------------------------
\section{Implementation}
\label{sec:implementation}

\subsection{Code Organization}

The implementation is organized as follows:

\begin{verbatim}
amb_core/
├── __init__.py          # Public API exports
├── models.py            # Message and MessagePriority
├── broker.py            # BrokerAdapter ABC
├── bus.py               # MessageBus facade
├── memory_broker.py     # In-memory implementation
└── adapters/            # Broker-specific adapters
\end{verbatim}

\subsection{Installation}

\begin{verbatim}
pip install amb-core           # Core only
pip install amb-core[redis]    # With Redis adapter
pip install amb-core[all]      # All adapters
\end{verbatim}

% ----------------------------------------------------------------------------
\section{Limitations and Future Work}
\label{sec:future}

Current limitations include:
\begin{itemize}
    \item No built-in message persistence
    \item Single-language implementation (Python)
    \item No distributed tracing integration
\end{itemize}

Future directions include schema registry integration, OpenTelemetry support, and TypeScript/Rust bindings.

% ----------------------------------------------------------------------------
\section{Conclusion}
\label{sec:conclusion}

We presented AMB, a broker-agnostic message bus designed for AI agent communication. AMB achieves sub-millisecond latency while providing clean abstraction over multiple broker backends.

\textbf{Code:} \url{https://github.com/imran-siddique/amb}

% ----------------------------------------------------------------------------
\section*{Acknowledgments}

[Add acknowledgments here]

% ----------------------------------------------------------------------------
\bibliographystyle{plainnat}
\begin{thebibliography}{9}

\bibitem{rabbitmq}
RabbitMQ. \url{https://www.rabbitmq.com/}

\bibitem{kafka}
Apache Kafka. \url{https://kafka.apache.org/}

\bibitem{redis}
Redis Pub/Sub. \url{https://redis.io/docs/manual/pubsub/}

\bibitem{fipa}
FIPA Agent Communication Language Specifications. \url{http://www.fipa.org/}

\bibitem{langchain}
LangChain. \url{https://github.com/langchain-ai/langchain}

\bibitem{autogpt}
AutoGPT. \url{https://github.com/Significant-Gravitas/AutoGPT}

\bibitem{crewai}
CrewAI. \url{https://github.com/joaomdmoura/crewAI}

\end{thebibliography}

\end{document}
