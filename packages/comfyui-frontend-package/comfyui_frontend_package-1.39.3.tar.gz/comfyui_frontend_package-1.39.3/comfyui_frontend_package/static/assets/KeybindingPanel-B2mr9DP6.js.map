{"version":3,"file":"KeybindingPanel-B2mr9DP6.js","names":[],"sources":["../../src/components/dialog/content/setting/keybinding/KeyComboDisplay.vue","../../src/components/dialog/content/setting/keybinding/KeyComboDisplay.vue","../../src/components/dialog/content/setting/KeybindingPanel.vue","../../src/components/dialog/content/setting/KeybindingPanel.vue","../../src/components/dialog/content/setting/KeybindingPanel.vue"],"sourcesContent":["<template>\n  <span>\n    <template v-for=\"(sequence, index) in keySequences\" :key=\"index\">\n      <Tag :severity=\"isModified ? 'info' : 'secondary'\">\n        {{ sequence }}\n      </Tag>\n      <span v-if=\"index < keySequences.length - 1\" class=\"px-2\">+</span>\n    </template>\n  </span>\n</template>\n\n<script setup lang=\"ts\">\nimport Tag from 'primevue/tag'\nimport { computed } from 'vue'\n\nimport type { KeyComboImpl } from '@/platform/keybindings/keyCombo'\n\nconst { keyCombo, isModified = false } = defineProps<{\n  keyCombo: KeyComboImpl\n  isModified?: boolean\n}>()\n\nconst keySequences = computed(() => keyCombo.getKeySequences())\n</script>\n","<template>\n  <span>\n    <template v-for=\"(sequence, index) in keySequences\" :key=\"index\">\n      <Tag :severity=\"isModified ? 'info' : 'secondary'\">\n        {{ sequence }}\n      </Tag>\n      <span v-if=\"index < keySequences.length - 1\" class=\"px-2\">+</span>\n    </template>\n  </span>\n</template>\n\n<script setup lang=\"ts\">\nimport Tag from 'primevue/tag'\nimport { computed } from 'vue'\n\nimport type { KeyComboImpl } from '@/platform/keybindings/keyCombo'\n\nconst { keyCombo, isModified = false } = defineProps<{\n  keyCombo: KeyComboImpl\n  isModified?: boolean\n}>()\n\nconst keySequences = computed(() => keyCombo.getKeySequences())\n</script>\n","<template>\n  <PanelTemplate value=\"Keybinding\" class=\"keybinding-panel\">\n    <template #header>\n      <SearchBox\n        v-model=\"filters['global'].value\"\n        :placeholder=\"$t('g.searchKeybindings') + '...'\"\n      />\n    </template>\n\n    <DataTable\n      v-model:selection=\"selectedCommandData\"\n      :value=\"commandsData\"\n      :global-filter-fields=\"['id', 'label']\"\n      :filters=\"filters\"\n      selection-mode=\"single\"\n      striped-rows\n      :pt=\"{\n        header: 'px-0'\n      }\"\n      @row-dblclick=\"editKeybinding($event.data)\"\n    >\n      <Column field=\"actions\" header=\"\">\n        <template #body=\"slotProps\">\n          <div class=\"actions invisible flex flex-row\">\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.edit')\"\n              @click=\"editKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-pencil\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.reset')\"\n              :disabled=\"\n                !keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n              \"\n              @click=\"resetKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-replay\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.delete')\"\n              :disabled=\"!slotProps.data.keybinding\"\n              @click=\"removeKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-trash\" />\n            </Button>\n          </div>\n        </template>\n      </Column>\n      <Column\n        field=\"id\"\n        :header=\"$t('g.command')\"\n        sortable\n        class=\"max-w-64 2xl:max-w-full\"\n      >\n        <template #body=\"slotProps\">\n          <div class=\"truncate\" :title=\"slotProps.data.id\">\n            {{ slotProps.data.label }}\n          </div>\n        </template>\n      </Column>\n      <Column field=\"keybinding\" :header=\"$t('g.keybinding')\">\n        <template #body=\"slotProps\">\n          <KeyComboDisplay\n            v-if=\"slotProps.data.keybinding\"\n            :key-combo=\"slotProps.data.keybinding.combo\"\n            :is-modified=\"\n              keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n            \"\n          />\n          <span v-else>-</span>\n        </template>\n      </Column>\n      <Column field=\"source\" :header=\"$t('g.source')\">\n        <template #body=\"slotProps\">\n          <span class=\"overflow-hidden text-ellipsis\">{{\n            slotProps.data.source || '-'\n          }}</span>\n        </template>\n      </Column>\n    </DataTable>\n\n    <Dialog\n      v-model:visible=\"editDialogVisible\"\n      class=\"min-w-96\"\n      modal\n      :header=\"currentEditingCommand?.label\"\n      @hide=\"cancelEdit\"\n    >\n      <div>\n        <InputText\n          ref=\"keybindingInput\"\n          class=\"mb-2 text-center\"\n          :model-value=\"newBindingKeyCombo?.toString() ?? ''\"\n          :placeholder=\"$t('g.pressKeysForNewBinding')\"\n          autocomplete=\"off\"\n          fluid\n          @keydown.stop.prevent=\"captureKeybinding\"\n        />\n        <Message v-if=\"existingKeybindingOnCombo\" severity=\"warn\">\n          {{ $t('g.keybindingAlreadyExists') }}\n          <Tag\n            severity=\"secondary\"\n            :value=\"existingKeybindingOnCombo.commandId\"\n          />\n        </Message>\n      </div>\n      <template #footer>\n        <Button\n          :variant=\"existingKeybindingOnCombo ? 'destructive' : 'primary'\"\n          autofocus\n          @click=\"saveKeybinding\"\n        >\n          <i\n            :class=\"existingKeybindingOnCombo ? 'pi pi-pencil' : 'pi pi-check'\"\n          />\n          {{ existingKeybindingOnCombo ? $t('g.overwrite') : $t('g.save') }}\n        </Button>\n      </template>\n    </Dialog>\n    <Button\n      v-tooltip=\"$t('g.resetAllKeybindingsTooltip')\"\n      class=\"mt-4 w-full\"\n      variant=\"destructive-textonly\"\n      @click=\"resetAllKeybindings\"\n    >\n      <i class=\"pi pi-replay\" />\n      {{ $t('g.resetAll') }}\n    </Button>\n  </PanelTemplate>\n</template>\n\n<script setup lang=\"ts\">\nimport { FilterMatchMode } from '@primevue/core/api'\nimport Column from 'primevue/column'\nimport DataTable from 'primevue/datatable'\nimport Dialog from 'primevue/dialog'\nimport InputText from 'primevue/inputtext'\nimport Message from 'primevue/message'\nimport Tag from 'primevue/tag'\nimport { useToast } from 'primevue/usetoast'\nimport { computed, ref, watchEffect } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\nimport SearchBox from '@/components/common/SearchBox.vue'\nimport Button from '@/components/ui/button/Button.vue'\nimport { KeyComboImpl } from '@/platform/keybindings/keyCombo'\nimport { KeybindingImpl } from '@/platform/keybindings/keybinding'\nimport { useKeybindingService } from '@/platform/keybindings/keybindingService'\nimport { useKeybindingStore } from '@/platform/keybindings/keybindingStore'\nimport { useCommandStore } from '@/stores/commandStore'\nimport { normalizeI18nKey } from '@/utils/formatUtil'\n\nimport PanelTemplate from './PanelTemplate.vue'\nimport KeyComboDisplay from './keybinding/KeyComboDisplay.vue'\n\nconst filters = ref({\n  global: { value: '', matchMode: FilterMatchMode.CONTAINS }\n})\n\nconst keybindingStore = useKeybindingStore()\nconst keybindingService = useKeybindingService()\nconst commandStore = useCommandStore()\nconst { t } = useI18n()\n\ninterface ICommandData {\n  id: string\n  keybinding: KeybindingImpl | null\n  label: string\n  source?: string\n}\n\nconst commandsData = computed<ICommandData[]>(() => {\n  return Object.values(commandStore.commands).map((command) => ({\n    id: command.id,\n    label: t(\n      `commands.${normalizeI18nKey(command.id)}.label`,\n      command.label ?? ''\n    ),\n    keybinding: keybindingStore.getKeybindingByCommandId(command.id),\n    source: command.source\n  }))\n})\n\nconst selectedCommandData = ref<ICommandData | null>(null)\nconst editDialogVisible = ref(false)\nconst newBindingKeyCombo = ref<KeyComboImpl | null>(null)\nconst currentEditingCommand = ref<ICommandData | null>(null)\nconst keybindingInput = ref<InstanceType<typeof InputText> | null>(null)\n\nconst existingKeybindingOnCombo = computed<KeybindingImpl | null>(() => {\n  if (!currentEditingCommand.value) {\n    return null\n  }\n\n  // If the new keybinding is the same as the current editing command, then don't show the error\n  if (\n    currentEditingCommand.value.keybinding?.combo?.equals(\n      newBindingKeyCombo.value\n    )\n  ) {\n    return null\n  }\n\n  if (!newBindingKeyCombo.value) {\n    return null\n  }\n\n  return keybindingStore.getKeybinding(newBindingKeyCombo.value)\n})\n\nfunction editKeybinding(commandData: ICommandData) {\n  currentEditingCommand.value = commandData\n  newBindingKeyCombo.value = commandData.keybinding\n    ? commandData.keybinding.combo\n    : null\n  editDialogVisible.value = true\n}\n\nwatchEffect(() => {\n  if (editDialogVisible.value) {\n    // nextTick doesn't work here, so we use a timeout instead\n    setTimeout(() => {\n      // @ts-expect-error - $el is an internal property of the InputText component\n      keybindingInput.value?.$el?.focus()\n    }, 300)\n  }\n})\n\nasync function removeKeybinding(commandData: ICommandData) {\n  if (commandData.keybinding) {\n    keybindingStore.unsetKeybinding(commandData.keybinding)\n    await keybindingService.persistUserKeybindings()\n  }\n}\n\nasync function captureKeybinding(event: KeyboardEvent) {\n  // Allow the use of keyboard shortcuts when adding keyboard shortcuts\n  if (!event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {\n    switch (event.key) {\n      case 'Escape':\n        cancelEdit()\n        return\n      case 'Enter':\n        await saveKeybinding()\n        return\n    }\n  }\n  const keyCombo = KeyComboImpl.fromEvent(event)\n  newBindingKeyCombo.value = keyCombo\n}\n\nfunction cancelEdit() {\n  editDialogVisible.value = false\n  currentEditingCommand.value = null\n  newBindingKeyCombo.value = null\n}\n\nasync function saveKeybinding() {\n  const commandId = currentEditingCommand.value?.id\n  const combo = newBindingKeyCombo.value\n  cancelEdit()\n  if (!combo || commandId == undefined) return\n\n  const updated = keybindingStore.updateKeybindingOnCommand(\n    new KeybindingImpl({ commandId, combo })\n  )\n  if (updated) await keybindingService.persistUserKeybindings()\n}\n\nasync function resetKeybinding(commandData: ICommandData) {\n  if (keybindingStore.resetKeybindingForCommand(commandData.id)) {\n    await keybindingService.persistUserKeybindings()\n  } else {\n    console.warn(\n      `No changes made when resetting keybinding for command: ${commandData.id}`\n    )\n  }\n}\n\nconst toast = useToast()\nasync function resetAllKeybindings() {\n  keybindingStore.resetAllKeybindings()\n  await keybindingService.persistUserKeybindings()\n  toast.add({\n    severity: 'info',\n    summary: 'Info',\n    detail: 'All keybindings reset',\n    life: 3000\n  })\n}\n</script>\n\n<style scoped>\n@reference '../../../../assets/css/style.css';\n\n:deep(.p-datatable-tbody) > tr > td {\n  @apply p-1;\n  min-height: 2rem;\n}\n\n:deep(.p-datatable-row-selected) .actions,\n:deep(.p-datatable-selectable-row:hover) .actions {\n  @apply visible;\n}\n</style>\n","<template>\n  <PanelTemplate value=\"Keybinding\" class=\"keybinding-panel\">\n    <template #header>\n      <SearchBox\n        v-model=\"filters['global'].value\"\n        :placeholder=\"$t('g.searchKeybindings') + '...'\"\n      />\n    </template>\n\n    <DataTable\n      v-model:selection=\"selectedCommandData\"\n      :value=\"commandsData\"\n      :global-filter-fields=\"['id', 'label']\"\n      :filters=\"filters\"\n      selection-mode=\"single\"\n      striped-rows\n      :pt=\"{\n        header: 'px-0'\n      }\"\n      @row-dblclick=\"editKeybinding($event.data)\"\n    >\n      <Column field=\"actions\" header=\"\">\n        <template #body=\"slotProps\">\n          <div class=\"actions invisible flex flex-row\">\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.edit')\"\n              @click=\"editKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-pencil\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.reset')\"\n              :disabled=\"\n                !keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n              \"\n              @click=\"resetKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-replay\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.delete')\"\n              :disabled=\"!slotProps.data.keybinding\"\n              @click=\"removeKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-trash\" />\n            </Button>\n          </div>\n        </template>\n      </Column>\n      <Column\n        field=\"id\"\n        :header=\"$t('g.command')\"\n        sortable\n        class=\"max-w-64 2xl:max-w-full\"\n      >\n        <template #body=\"slotProps\">\n          <div class=\"truncate\" :title=\"slotProps.data.id\">\n            {{ slotProps.data.label }}\n          </div>\n        </template>\n      </Column>\n      <Column field=\"keybinding\" :header=\"$t('g.keybinding')\">\n        <template #body=\"slotProps\">\n          <KeyComboDisplay\n            v-if=\"slotProps.data.keybinding\"\n            :key-combo=\"slotProps.data.keybinding.combo\"\n            :is-modified=\"\n              keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n            \"\n          />\n          <span v-else>-</span>\n        </template>\n      </Column>\n      <Column field=\"source\" :header=\"$t('g.source')\">\n        <template #body=\"slotProps\">\n          <span class=\"overflow-hidden text-ellipsis\">{{\n            slotProps.data.source || '-'\n          }}</span>\n        </template>\n      </Column>\n    </DataTable>\n\n    <Dialog\n      v-model:visible=\"editDialogVisible\"\n      class=\"min-w-96\"\n      modal\n      :header=\"currentEditingCommand?.label\"\n      @hide=\"cancelEdit\"\n    >\n      <div>\n        <InputText\n          ref=\"keybindingInput\"\n          class=\"mb-2 text-center\"\n          :model-value=\"newBindingKeyCombo?.toString() ?? ''\"\n          :placeholder=\"$t('g.pressKeysForNewBinding')\"\n          autocomplete=\"off\"\n          fluid\n          @keydown.stop.prevent=\"captureKeybinding\"\n        />\n        <Message v-if=\"existingKeybindingOnCombo\" severity=\"warn\">\n          {{ $t('g.keybindingAlreadyExists') }}\n          <Tag\n            severity=\"secondary\"\n            :value=\"existingKeybindingOnCombo.commandId\"\n          />\n        </Message>\n      </div>\n      <template #footer>\n        <Button\n          :variant=\"existingKeybindingOnCombo ? 'destructive' : 'primary'\"\n          autofocus\n          @click=\"saveKeybinding\"\n        >\n          <i\n            :class=\"existingKeybindingOnCombo ? 'pi pi-pencil' : 'pi pi-check'\"\n          />\n          {{ existingKeybindingOnCombo ? $t('g.overwrite') : $t('g.save') }}\n        </Button>\n      </template>\n    </Dialog>\n    <Button\n      v-tooltip=\"$t('g.resetAllKeybindingsTooltip')\"\n      class=\"mt-4 w-full\"\n      variant=\"destructive-textonly\"\n      @click=\"resetAllKeybindings\"\n    >\n      <i class=\"pi pi-replay\" />\n      {{ $t('g.resetAll') }}\n    </Button>\n  </PanelTemplate>\n</template>\n\n<script setup lang=\"ts\">\nimport { FilterMatchMode } from '@primevue/core/api'\nimport Column from 'primevue/column'\nimport DataTable from 'primevue/datatable'\nimport Dialog from 'primevue/dialog'\nimport InputText from 'primevue/inputtext'\nimport Message from 'primevue/message'\nimport Tag from 'primevue/tag'\nimport { useToast } from 'primevue/usetoast'\nimport { computed, ref, watchEffect } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\nimport SearchBox from '@/components/common/SearchBox.vue'\nimport Button from '@/components/ui/button/Button.vue'\nimport { KeyComboImpl } from '@/platform/keybindings/keyCombo'\nimport { KeybindingImpl } from '@/platform/keybindings/keybinding'\nimport { useKeybindingService } from '@/platform/keybindings/keybindingService'\nimport { useKeybindingStore } from '@/platform/keybindings/keybindingStore'\nimport { useCommandStore } from '@/stores/commandStore'\nimport { normalizeI18nKey } from '@/utils/formatUtil'\n\nimport PanelTemplate from './PanelTemplate.vue'\nimport KeyComboDisplay from './keybinding/KeyComboDisplay.vue'\n\nconst filters = ref({\n  global: { value: '', matchMode: FilterMatchMode.CONTAINS }\n})\n\nconst keybindingStore = useKeybindingStore()\nconst keybindingService = useKeybindingService()\nconst commandStore = useCommandStore()\nconst { t } = useI18n()\n\ninterface ICommandData {\n  id: string\n  keybinding: KeybindingImpl | null\n  label: string\n  source?: string\n}\n\nconst commandsData = computed<ICommandData[]>(() => {\n  return Object.values(commandStore.commands).map((command) => ({\n    id: command.id,\n    label: t(\n      `commands.${normalizeI18nKey(command.id)}.label`,\n      command.label ?? ''\n    ),\n    keybinding: keybindingStore.getKeybindingByCommandId(command.id),\n    source: command.source\n  }))\n})\n\nconst selectedCommandData = ref<ICommandData | null>(null)\nconst editDialogVisible = ref(false)\nconst newBindingKeyCombo = ref<KeyComboImpl | null>(null)\nconst currentEditingCommand = ref<ICommandData | null>(null)\nconst keybindingInput = ref<InstanceType<typeof InputText> | null>(null)\n\nconst existingKeybindingOnCombo = computed<KeybindingImpl | null>(() => {\n  if (!currentEditingCommand.value) {\n    return null\n  }\n\n  // If the new keybinding is the same as the current editing command, then don't show the error\n  if (\n    currentEditingCommand.value.keybinding?.combo?.equals(\n      newBindingKeyCombo.value\n    )\n  ) {\n    return null\n  }\n\n  if (!newBindingKeyCombo.value) {\n    return null\n  }\n\n  return keybindingStore.getKeybinding(newBindingKeyCombo.value)\n})\n\nfunction editKeybinding(commandData: ICommandData) {\n  currentEditingCommand.value = commandData\n  newBindingKeyCombo.value = commandData.keybinding\n    ? commandData.keybinding.combo\n    : null\n  editDialogVisible.value = true\n}\n\nwatchEffect(() => {\n  if (editDialogVisible.value) {\n    // nextTick doesn't work here, so we use a timeout instead\n    setTimeout(() => {\n      // @ts-expect-error - $el is an internal property of the InputText component\n      keybindingInput.value?.$el?.focus()\n    }, 300)\n  }\n})\n\nasync function removeKeybinding(commandData: ICommandData) {\n  if (commandData.keybinding) {\n    keybindingStore.unsetKeybinding(commandData.keybinding)\n    await keybindingService.persistUserKeybindings()\n  }\n}\n\nasync function captureKeybinding(event: KeyboardEvent) {\n  // Allow the use of keyboard shortcuts when adding keyboard shortcuts\n  if (!event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {\n    switch (event.key) {\n      case 'Escape':\n        cancelEdit()\n        return\n      case 'Enter':\n        await saveKeybinding()\n        return\n    }\n  }\n  const keyCombo = KeyComboImpl.fromEvent(event)\n  newBindingKeyCombo.value = keyCombo\n}\n\nfunction cancelEdit() {\n  editDialogVisible.value = false\n  currentEditingCommand.value = null\n  newBindingKeyCombo.value = null\n}\n\nasync function saveKeybinding() {\n  const commandId = currentEditingCommand.value?.id\n  const combo = newBindingKeyCombo.value\n  cancelEdit()\n  if (!combo || commandId == undefined) return\n\n  const updated = keybindingStore.updateKeybindingOnCommand(\n    new KeybindingImpl({ commandId, combo })\n  )\n  if (updated) await keybindingService.persistUserKeybindings()\n}\n\nasync function resetKeybinding(commandData: ICommandData) {\n  if (keybindingStore.resetKeybindingForCommand(commandData.id)) {\n    await keybindingService.persistUserKeybindings()\n  } else {\n    console.warn(\n      `No changes made when resetting keybinding for command: ${commandData.id}`\n    )\n  }\n}\n\nconst toast = useToast()\nasync function resetAllKeybindings() {\n  keybindingStore.resetAllKeybindings()\n  await keybindingService.persistUserKeybindings()\n  toast.add({\n    severity: 'info',\n    summary: 'Info',\n    detail: 'All keybindings reset',\n    life: 3000\n  })\n}\n</script>\n\n<style scoped>\n@reference '../../../../assets/css/style.css';\n\n:deep(.p-datatable-tbody) > tr > td {\n  @apply p-1;\n  min-height: 2rem;\n}\n\n:deep(.p-datatable-row-selected) .actions,\n:deep(.p-datatable-selectable-row:hover) .actions {\n  @apply visible;\n}\n</style>\n","<template>\n  <PanelTemplate value=\"Keybinding\" class=\"keybinding-panel\">\n    <template #header>\n      <SearchBox\n        v-model=\"filters['global'].value\"\n        :placeholder=\"$t('g.searchKeybindings') + '...'\"\n      />\n    </template>\n\n    <DataTable\n      v-model:selection=\"selectedCommandData\"\n      :value=\"commandsData\"\n      :global-filter-fields=\"['id', 'label']\"\n      :filters=\"filters\"\n      selection-mode=\"single\"\n      striped-rows\n      :pt=\"{\n        header: 'px-0'\n      }\"\n      @row-dblclick=\"editKeybinding($event.data)\"\n    >\n      <Column field=\"actions\" header=\"\">\n        <template #body=\"slotProps\">\n          <div class=\"actions invisible flex flex-row\">\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.edit')\"\n              @click=\"editKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-pencil\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.reset')\"\n              :disabled=\"\n                !keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n              \"\n              @click=\"resetKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-replay\" />\n            </Button>\n            <Button\n              variant=\"textonly\"\n              size=\"icon\"\n              :aria-label=\"$t('g.delete')\"\n              :disabled=\"!slotProps.data.keybinding\"\n              @click=\"removeKeybinding(slotProps.data)\"\n            >\n              <i class=\"pi pi-trash\" />\n            </Button>\n          </div>\n        </template>\n      </Column>\n      <Column\n        field=\"id\"\n        :header=\"$t('g.command')\"\n        sortable\n        class=\"max-w-64 2xl:max-w-full\"\n      >\n        <template #body=\"slotProps\">\n          <div class=\"truncate\" :title=\"slotProps.data.id\">\n            {{ slotProps.data.label }}\n          </div>\n        </template>\n      </Column>\n      <Column field=\"keybinding\" :header=\"$t('g.keybinding')\">\n        <template #body=\"slotProps\">\n          <KeyComboDisplay\n            v-if=\"slotProps.data.keybinding\"\n            :key-combo=\"slotProps.data.keybinding.combo\"\n            :is-modified=\"\n              keybindingStore.isCommandKeybindingModified(slotProps.data.id)\n            \"\n          />\n          <span v-else>-</span>\n        </template>\n      </Column>\n      <Column field=\"source\" :header=\"$t('g.source')\">\n        <template #body=\"slotProps\">\n          <span class=\"overflow-hidden text-ellipsis\">{{\n            slotProps.data.source || '-'\n          }}</span>\n        </template>\n      </Column>\n    </DataTable>\n\n    <Dialog\n      v-model:visible=\"editDialogVisible\"\n      class=\"min-w-96\"\n      modal\n      :header=\"currentEditingCommand?.label\"\n      @hide=\"cancelEdit\"\n    >\n      <div>\n        <InputText\n          ref=\"keybindingInput\"\n          class=\"mb-2 text-center\"\n          :model-value=\"newBindingKeyCombo?.toString() ?? ''\"\n          :placeholder=\"$t('g.pressKeysForNewBinding')\"\n          autocomplete=\"off\"\n          fluid\n          @keydown.stop.prevent=\"captureKeybinding\"\n        />\n        <Message v-if=\"existingKeybindingOnCombo\" severity=\"warn\">\n          {{ $t('g.keybindingAlreadyExists') }}\n          <Tag\n            severity=\"secondary\"\n            :value=\"existingKeybindingOnCombo.commandId\"\n          />\n        </Message>\n      </div>\n      <template #footer>\n        <Button\n          :variant=\"existingKeybindingOnCombo ? 'destructive' : 'primary'\"\n          autofocus\n          @click=\"saveKeybinding\"\n        >\n          <i\n            :class=\"existingKeybindingOnCombo ? 'pi pi-pencil' : 'pi pi-check'\"\n          />\n          {{ existingKeybindingOnCombo ? $t('g.overwrite') : $t('g.save') }}\n        </Button>\n      </template>\n    </Dialog>\n    <Button\n      v-tooltip=\"$t('g.resetAllKeybindingsTooltip')\"\n      class=\"mt-4 w-full\"\n      variant=\"destructive-textonly\"\n      @click=\"resetAllKeybindings\"\n    >\n      <i class=\"pi pi-replay\" />\n      {{ $t('g.resetAll') }}\n    </Button>\n  </PanelTemplate>\n</template>\n\n<script setup lang=\"ts\">\nimport { FilterMatchMode } from '@primevue/core/api'\nimport Column from 'primevue/column'\nimport DataTable from 'primevue/datatable'\nimport Dialog from 'primevue/dialog'\nimport InputText from 'primevue/inputtext'\nimport Message from 'primevue/message'\nimport Tag from 'primevue/tag'\nimport { useToast } from 'primevue/usetoast'\nimport { computed, ref, watchEffect } from 'vue'\nimport { useI18n } from 'vue-i18n'\n\nimport SearchBox from '@/components/common/SearchBox.vue'\nimport Button from '@/components/ui/button/Button.vue'\nimport { KeyComboImpl } from '@/platform/keybindings/keyCombo'\nimport { KeybindingImpl } from '@/platform/keybindings/keybinding'\nimport { useKeybindingService } from '@/platform/keybindings/keybindingService'\nimport { useKeybindingStore } from '@/platform/keybindings/keybindingStore'\nimport { useCommandStore } from '@/stores/commandStore'\nimport { normalizeI18nKey } from '@/utils/formatUtil'\n\nimport PanelTemplate from './PanelTemplate.vue'\nimport KeyComboDisplay from './keybinding/KeyComboDisplay.vue'\n\nconst filters = ref({\n  global: { value: '', matchMode: FilterMatchMode.CONTAINS }\n})\n\nconst keybindingStore = useKeybindingStore()\nconst keybindingService = useKeybindingService()\nconst commandStore = useCommandStore()\nconst { t } = useI18n()\n\ninterface ICommandData {\n  id: string\n  keybinding: KeybindingImpl | null\n  label: string\n  source?: string\n}\n\nconst commandsData = computed<ICommandData[]>(() => {\n  return Object.values(commandStore.commands).map((command) => ({\n    id: command.id,\n    label: t(\n      `commands.${normalizeI18nKey(command.id)}.label`,\n      command.label ?? ''\n    ),\n    keybinding: keybindingStore.getKeybindingByCommandId(command.id),\n    source: command.source\n  }))\n})\n\nconst selectedCommandData = ref<ICommandData | null>(null)\nconst editDialogVisible = ref(false)\nconst newBindingKeyCombo = ref<KeyComboImpl | null>(null)\nconst currentEditingCommand = ref<ICommandData | null>(null)\nconst keybindingInput = ref<InstanceType<typeof InputText> | null>(null)\n\nconst existingKeybindingOnCombo = computed<KeybindingImpl | null>(() => {\n  if (!currentEditingCommand.value) {\n    return null\n  }\n\n  // If the new keybinding is the same as the current editing command, then don't show the error\n  if (\n    currentEditingCommand.value.keybinding?.combo?.equals(\n      newBindingKeyCombo.value\n    )\n  ) {\n    return null\n  }\n\n  if (!newBindingKeyCombo.value) {\n    return null\n  }\n\n  return keybindingStore.getKeybinding(newBindingKeyCombo.value)\n})\n\nfunction editKeybinding(commandData: ICommandData) {\n  currentEditingCommand.value = commandData\n  newBindingKeyCombo.value = commandData.keybinding\n    ? commandData.keybinding.combo\n    : null\n  editDialogVisible.value = true\n}\n\nwatchEffect(() => {\n  if (editDialogVisible.value) {\n    // nextTick doesn't work here, so we use a timeout instead\n    setTimeout(() => {\n      // @ts-expect-error - $el is an internal property of the InputText component\n      keybindingInput.value?.$el?.focus()\n    }, 300)\n  }\n})\n\nasync function removeKeybinding(commandData: ICommandData) {\n  if (commandData.keybinding) {\n    keybindingStore.unsetKeybinding(commandData.keybinding)\n    await keybindingService.persistUserKeybindings()\n  }\n}\n\nasync function captureKeybinding(event: KeyboardEvent) {\n  // Allow the use of keyboard shortcuts when adding keyboard shortcuts\n  if (!event.shiftKey && !event.altKey && !event.ctrlKey && !event.metaKey) {\n    switch (event.key) {\n      case 'Escape':\n        cancelEdit()\n        return\n      case 'Enter':\n        await saveKeybinding()\n        return\n    }\n  }\n  const keyCombo = KeyComboImpl.fromEvent(event)\n  newBindingKeyCombo.value = keyCombo\n}\n\nfunction cancelEdit() {\n  editDialogVisible.value = false\n  currentEditingCommand.value = null\n  newBindingKeyCombo.value = null\n}\n\nasync function saveKeybinding() {\n  const commandId = currentEditingCommand.value?.id\n  const combo = newBindingKeyCombo.value\n  cancelEdit()\n  if (!combo || commandId == undefined) return\n\n  const updated = keybindingStore.updateKeybindingOnCommand(\n    new KeybindingImpl({ commandId, combo })\n  )\n  if (updated) await keybindingService.persistUserKeybindings()\n}\n\nasync function resetKeybinding(commandData: ICommandData) {\n  if (keybindingStore.resetKeybindingForCommand(commandData.id)) {\n    await keybindingService.persistUserKeybindings()\n  } else {\n    console.warn(\n      `No changes made when resetting keybinding for command: ${commandData.id}`\n    )\n  }\n}\n\nconst toast = useToast()\nasync function resetAllKeybindings() {\n  keybindingStore.resetAllKeybindings()\n  await keybindingService.persistUserKeybindings()\n  toast.add({\n    severity: 'info',\n    summary: 'Info',\n    detail: 'All keybindings reset',\n    life: 3000\n  })\n}\n</script>\n\n<style scoped>\n@reference '../../../../assets/css/style.css';\n\n:deep(.p-datatable-tbody) > tr > td {\n  @apply p-1;\n  min-height: 2rem;\n}\n\n:deep(.p-datatable-row-selected) .actions,\n:deep(.p-datatable-selectable-row:hover) .actions {\n  @apply visible;\n}\n</style>\n"],"mappings":"01BCYgB,wHAUhB,IAAM,EAAe,MAAe,EAAA,SAAS,iBAAiB,CAAA,0TGqH9B,IACb,IACG,IACH,IACG,IACF,IACJ,IACS,KAED,IAEF,KACH,IACU,IACE,KACM,IACF,KACH,IACC,KAEP,KACE,oJAE5B,IAAM,EAAU,EAAI,CAClB,OAAQ,CAAE,MAAO,GAAI,UAAW,EAAgB,SAAS,CAC1D,CAAA,CAEK,EAAkB,IAAmB,CACrC,EAAoB,IAAqB,CACzC,EAAe,GAAgB,CAC/B,CAAE,KAAM,IAAQ,CAShB,EAAe,MACZ,OAAO,OAAO,EAAa,SAAS,CAAC,IAAK,IAAa,CAC5D,GAAI,EAAQ,GACZ,MAAO,EACL,YAAY,EAAiB,EAAQ,GAAG,CAAC,QACzC,EAAQ,OAAS,GAClB,CACD,WAAY,EAAgB,yBAAyB,EAAQ,GAAG,CAChE,OAAQ,EAAQ,OACjB,EAAC,CACH,CAEK,EAAsB,EAAyB,KAAI,CACnD,EAAoB,EAAI,GAAK,CAC7B,EAAqB,EAAyB,KAAI,CAClD,EAAwB,EAAyB,KAAI,CACrD,EAAkB,EAA2C,KAAI,CAEjE,EAA4B,MAC5B,CAAC,EAAsB,OAMzB,EAAsB,MAAM,YAAY,OAAO,OAC7C,EAAmB,MACrB,EAKE,CAAC,EAAmB,MACf,KAGF,EAAgB,cAAc,EAAmB,MAAK,CAC9D,CAED,SAAS,eAAe,EAA2B,CACjD,EAAsB,MAAQ,EAC9B,EAAmB,MAAQ,EAAY,WACnC,EAAY,WAAW,MACvB,KACJ,EAAkB,MAAQ,GAG5B,MAAkB,CACZ,EAAkB,OAEpB,eAAiB,CAEf,EAAgB,OAAO,KAAK,OAAM,EACjC,IAAG,EAET,CAED,eAAe,iBAAiB,EAA2B,CACrD,EAAY,aACd,EAAgB,gBAAgB,EAAY,WAAU,CACtD,MAAM,EAAkB,wBAAuB,EAInD,eAAe,kBAAkB,EAAsB,CAErD,GAAI,CAAC,EAAM,UAAY,CAAC,EAAM,QAAU,CAAC,EAAM,SAAW,CAAC,EAAM,QAC/D,OAAQ,EAAM,IAAd,CACE,IAAK,SACH,YAAW,CACX,OACF,IAAK,QACH,MAAM,gBAAe,CACrB,OAIN,EAAmB,MADF,EAAa,UAAU,EAAK,CAI/C,SAAS,YAAa,CACpB,EAAkB,MAAQ,GAC1B,EAAsB,MAAQ,KAC9B,EAAmB,MAAQ,KAG7B,eAAe,gBAAiB,CAC9B,IAAM,EAAY,EAAsB,OAAO,GACzC,EAAQ,EAAmB,MACjC,YAAW,CACP,GAAC,GAAS,GAAa,OAEX,EAAgB,0BAC9B,IAAI,GAAe,CAAE,YAAW,QAAO,CAAA,CACzC,EACa,MAAM,EAAkB,wBAAuB,CAG9D,eAAe,gBAAgB,EAA2B,CACpD,EAAgB,0BAA0B,EAAY,GAAG,CAC3D,MAAM,EAAkB,wBAAuB,CAE/C,QAAQ,KACN,0DAA0D,EAAY,KACxE,CAIJ,IAAM,EAAQ,GAAS,CACvB,eAAe,qBAAsB,CACnC,EAAgB,qBAAoB,CACpC,MAAM,EAAkB,wBAAuB,CAC/C,EAAM,IAAI,CACR,SAAU,OACV,QAAS,OACT,OAAQ,wBACR,KAAM,IACP,CAAA"}