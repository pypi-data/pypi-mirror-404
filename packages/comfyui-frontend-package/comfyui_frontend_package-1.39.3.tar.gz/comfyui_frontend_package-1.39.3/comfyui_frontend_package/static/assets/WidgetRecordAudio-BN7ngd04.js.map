{"version":3,"file":"WidgetRecordAudio-BN7ngd04.js","names":[],"sources":["../../src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioPlayback.ts","../../src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioRecorder.ts","../../src/renderer/extensions/vueNodes/widgets/composables/audio/useAudioWaveform.ts","../../src/renderer/extensions/vueNodes/widgets/components/WidgetRecordAudio.vue","../../src/renderer/extensions/vueNodes/widgets/components/WidgetRecordAudio.vue"],"sourcesContent":["import { nextTick, ref } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface AudioPlaybackOptions {\n  onPlaybackEnded?: () => void\n  onMetadataLoaded?: (duration: number) => void\n}\n\nexport function useAudioPlayback(\n  audioRef: Ref<HTMLAudioElement | undefined>,\n  options: AudioPlaybackOptions = {}\n) {\n  const isPlaying = ref(false)\n  const audioElementKey = ref(0)\n  const playbackTimerInterval = ref<ReturnType<typeof setInterval> | null>(null)\n\n  async function play() {\n    if (!audioRef.value) return false\n\n    try {\n      await audioRef.value.play()\n      isPlaying.value = true\n      return true\n    } catch (error) {\n      console.warn('Audio playback failed:', error)\n      isPlaying.value = false\n      return false\n    }\n  }\n\n  function stop() {\n    if (audioRef.value) {\n      audioRef.value.pause()\n      audioRef.value.currentTime = 0\n    }\n    isPlaying.value = false\n    if (options.onPlaybackEnded) {\n      options.onPlaybackEnded()\n    }\n  }\n\n  function onPlaybackEnded() {\n    isPlaying.value = false\n    if (options.onPlaybackEnded) {\n      options.onPlaybackEnded()\n    }\n  }\n\n  function onMetadataLoaded() {\n    if (audioRef.value?.duration && options.onMetadataLoaded) {\n      options.onMetadataLoaded(audioRef.value.duration)\n    }\n  }\n\n  async function resetAudioElement() {\n    audioElementKey.value += 1\n    await nextTick()\n  }\n\n  function getCurrentTime() {\n    return audioRef.value?.currentTime || 0\n  }\n\n  function getDuration() {\n    return audioRef.value?.duration || 0\n  }\n\n  return {\n    isPlaying,\n    audioElementKey,\n    play,\n    stop,\n    onPlaybackEnded,\n    onMetadataLoaded,\n    resetAudioElement,\n    getCurrentTime,\n    getDuration,\n    playbackTimerInterval\n  }\n}\n","import { MediaRecorder as ExtendableMediaRecorder } from 'extendable-media-recorder'\nimport { onUnmounted, ref } from 'vue'\n\nimport { useAudioService } from '@/services/audioService'\n\ninterface AudioRecorderOptions {\n  onRecordingComplete?: (audioBlob: Blob) => Promise<void>\n  onError?: (error: Error) => void\n}\n\nexport function useAudioRecorder(options: AudioRecorderOptions = {}) {\n  const isRecording = ref(false)\n  const mediaRecorder = ref<MediaRecorder | null>(null)\n  const audioChunks = ref<Blob[]>([])\n  const stream = ref<MediaStream | null>(null)\n  const recordedURL = ref<string | null>(null)\n\n  async function startRecording() {\n    try {\n      // Clean up previous recording\n      if (recordedURL.value?.startsWith('blob:')) {\n        URL.revokeObjectURL(recordedURL.value)\n      }\n\n      // Initialize\n      audioChunks.value = []\n      recordedURL.value = null\n\n      // Register wav encoder and get media stream\n      await useAudioService().registerWavEncoder()\n      stream.value = await navigator.mediaDevices.getUserMedia({ audio: true })\n\n      // Create media recorder\n      mediaRecorder.value = new ExtendableMediaRecorder(stream.value, {\n        mimeType: 'audio/wav'\n      }) as unknown as MediaRecorder\n\n      mediaRecorder.value.ondataavailable = (e) => {\n        audioChunks.value.push(e.data)\n      }\n\n      mediaRecorder.value.onstop = async () => {\n        const blob = new Blob(audioChunks.value, { type: 'audio/wav' })\n\n        // Create blob URL for preview\n        if (recordedURL.value?.startsWith('blob:')) {\n          URL.revokeObjectURL(recordedURL.value)\n        }\n        recordedURL.value = URL.createObjectURL(blob)\n\n        // Notify completion\n        if (options.onRecordingComplete) {\n          await options.onRecordingComplete(blob)\n        }\n\n        cleanup()\n      }\n\n      // Start recording\n      mediaRecorder.value.start(100)\n      isRecording.value = true\n    } catch (err) {\n      if (options.onError) {\n        options.onError(err as Error)\n      }\n      throw err\n    }\n  }\n\n  function stopRecording() {\n    if (mediaRecorder.value && mediaRecorder.value.state !== 'inactive') {\n      mediaRecorder.value.stop()\n    } else {\n      cleanup()\n    }\n  }\n\n  function cleanup() {\n    isRecording.value = false\n\n    if (stream.value) {\n      stream.value.getTracks().forEach((track) => track.stop())\n      stream.value = null\n    }\n  }\n\n  function dispose() {\n    stopRecording()\n    if (recordedURL.value) {\n      URL.revokeObjectURL(recordedURL.value)\n      recordedURL.value = null\n    }\n  }\n\n  onUnmounted(() => {\n    dispose()\n  })\n\n  return {\n    isRecording,\n    recordedURL,\n    mediaRecorder,\n    startRecording,\n    stopRecording,\n    dispose\n  }\n}\n","import { onUnmounted, ref } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface WaveformBar {\n  height: number\n}\n\ninterface AudioWaveformOptions {\n  barCount?: number\n  minHeight?: number\n  maxHeight?: number\n}\n\nexport function useAudioWaveform(options: AudioWaveformOptions = {}) {\n  const { barCount = 18, minHeight = 4, maxHeight = 32 } = options\n\n  const waveformBars = ref<WaveformBar[]>(\n    Array.from({ length: barCount }, () => ({ height: 16 }))\n  )\n  const audioContext = ref<AudioContext | null>(null)\n  const analyser = ref<AnalyserNode | null>(null)\n  const dataArray = ref<Uint8Array | null>(null)\n  const animationId = ref<number | null>(null)\n  const mediaElementSource = ref<MediaElementAudioSourceNode | null>(null)\n\n  function initWaveform() {\n    waveformBars.value = Array.from({ length: barCount }, () => ({\n      height: Math.random() * (maxHeight - minHeight) + minHeight\n    }))\n  }\n\n  function updateWaveform(isActive: Ref<boolean>) {\n    if (!isActive.value) return\n\n    if (analyser.value && dataArray.value) {\n      updateWaveformFromAudio()\n    } else {\n      updateWaveformRandom()\n    }\n\n    animationId.value = requestAnimationFrame(() => updateWaveform(isActive))\n  }\n\n  function updateWaveformFromAudio() {\n    if (!analyser.value || !dataArray.value) return\n\n    analyser.value.getByteFrequencyData(\n      dataArray.value as Uint8Array<ArrayBuffer>\n    )\n    const samplesPerBar = Math.floor(dataArray.value.length / barCount)\n\n    waveformBars.value = waveformBars.value.map((_, i) => {\n      let sum = 0\n      for (let j = 0; j < samplesPerBar; j++) {\n        sum += dataArray.value![i * samplesPerBar + j] || 0\n      }\n      const average = sum / samplesPerBar\n      const normalizedHeight =\n        (average / 255) * (maxHeight - minHeight) + minHeight\n      return { height: normalizedHeight }\n    })\n  }\n\n  function updateWaveformRandom() {\n    waveformBars.value = waveformBars.value.map((bar) => ({\n      height: Math.max(\n        minHeight,\n        Math.min(maxHeight, bar.height + (Math.random() - 0.5) * 4)\n      )\n    }))\n  }\n\n  async function setupAudioContext() {\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      await audioContext.value.close()\n    }\n    audioContext.value = null\n    mediaElementSource.value = null\n  }\n\n  async function setupRecordingVisualization(stream: MediaStream) {\n    audioContext.value = new window.AudioContext()\n    analyser.value = audioContext.value.createAnalyser()\n    const source = audioContext.value.createMediaStreamSource(stream)\n    source.connect(analyser.value)\n\n    analyser.value.fftSize = 256\n    dataArray.value = new Uint8Array(analyser.value.frequencyBinCount)\n  }\n\n  async function setupPlaybackVisualization(audioElement: HTMLAudioElement) {\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      await audioContext.value.close()\n    }\n\n    mediaElementSource.value = null\n\n    if (!audioElement) return false\n\n    audioContext.value = new window.AudioContext()\n    analyser.value = audioContext.value.createAnalyser()\n\n    mediaElementSource.value =\n      audioContext.value.createMediaElementSource(audioElement)\n\n    mediaElementSource.value.connect(analyser.value)\n    analyser.value.connect(audioContext.value.destination)\n\n    analyser.value.fftSize = 256\n    dataArray.value = new Uint8Array(analyser.value.frequencyBinCount)\n\n    return true\n  }\n\n  function stopWaveform() {\n    if (animationId.value) {\n      cancelAnimationFrame(animationId.value)\n      animationId.value = null\n    }\n  }\n\n  function dispose() {\n    stopWaveform()\n    if (audioContext.value && audioContext.value.state !== 'closed') {\n      void audioContext.value.close()\n    }\n    audioContext.value = null\n    mediaElementSource.value = null\n  }\n\n  onUnmounted(() => {\n    dispose()\n  })\n\n  return {\n    waveformBars,\n    initWaveform,\n    updateWaveform,\n    setupAudioContext,\n    setupRecordingVisualization,\n    setupPlaybackVisualization,\n    stopWaveform,\n    dispose\n  }\n}\n","<template>\n  <div class=\"relative\">\n    <div class=\"mb-4\">\n      <Button\n        class=\"text-base-foreground w-full border-0 bg-secondary-background hover:bg-secondary-background-hover\"\n        :disabled=\"isRecording || readonly\"\n        @click=\"handleStartRecording\"\n      >\n        {{ t('g.startRecording', 'Start Recording') }}\n        <i-lucide:mic class=\"ml-1\" />\n      </Button>\n    </div>\n    <div\n      v-if=\"isRecording || isPlaying || recordedURL\"\n      class=\"flex h-14 w-full min-w-0 items-center gap-2 rounded-lg px-3 bg-node-component-surface text-text-secondary\"\n    >\n      <!-- Recording Status -->\n      <div class=\"flex shrink-0 items-center gap-1\">\n        <span class=\"text-xs\">\n          {{\n            isRecording\n              ? t('g.listening', 'Listening...')\n              : isPlaying\n                ? t('g.playing', 'Playing...')\n                : recordedURL\n                  ? t('g.ready', 'Ready')\n                  : ''\n          }}\n        </span>\n        <span class=\"text-sm\">{{ formatTime(timer) }}</span>\n      </div>\n\n      <!-- Waveform Visualization -->\n      <div class=\"flex h-8 min-w-0 flex-1 items-center gap-2 overflow-hidden\">\n        <div\n          v-for=\"(bar, index) in waveformBars\"\n          :key=\"index\"\n          class=\"max-h-8 min-h-1 w-0.75 rounded-[1.5px] bg-slate-100 transition-all duration-100\"\n          :style=\"{ height: bar.height + 'px' }\"\n          :title=\"`Bar ${index + 1}: ${bar.height}px`\"\n        />\n      </div>\n\n      <!-- Control Button -->\n      <button\n        v-if=\"isRecording\"\n        :title=\"t('g.stopRecording', 'Stop Recording')\"\n        class=\"flex shrink-0 size-8 animate-pulse items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopRecording\"\n      >\n        <div class=\"size-2.5 rounded-sm bg-danger-100\" />\n      </button>\n\n      <button\n        v-else-if=\"!isRecording && recordedURL && !isPlaying\"\n        :title=\"t('g.playRecording') || 'Play Recording'\"\n        class=\"flex shrink-0 size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handlePlayRecording\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--play] size-4\" />\n      </button>\n\n      <button\n        v-else-if=\"isPlaying\"\n        :title=\"t('g.stopPlayback') || 'Stop Playback'\"\n        class=\"flex shrink-0 size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopPlayback\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--square] size-4\" />\n      </button>\n    </div>\n    <audio\n      v-if=\"recordedURL\"\n      ref=\"audioRef\"\n      :key=\"audioElementKey\"\n      :src=\"recordedURL\"\n      class=\"hidden\"\n      @ended=\"playback.onPlaybackEnded\"\n      @loadedmetadata=\"playback.onMetadataLoaded\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useIntervalFn } from '@vueuse/core'\nimport { Button } from 'primevue'\nimport { computed, onMounted, onUnmounted, ref } from 'vue'\n\nimport { t } from '@/i18n'\nimport type { LGraphNode } from '@/lib/litegraph/src/LGraphNode'\nimport type { IBaseWidget } from '@/lib/litegraph/src/types/widgets'\nimport { useToastStore } from '@/platform/updates/common/toastStore'\nimport { app } from '@/scripts/app'\nimport { useAudioService } from '@/services/audioService'\n\nimport { useAudioPlayback } from '../composables/audio/useAudioPlayback'\nimport { useAudioRecorder } from '../composables/audio/useAudioRecorder'\nimport { useAudioWaveform } from '../composables/audio/useAudioWaveform'\nimport { formatTime } from '../utils/audioUtils'\n\nconst props = defineProps<{\n  readonly?: boolean\n  nodeId: string\n}>()\n\n// Audio element ref\nconst audioRef = ref<HTMLAudioElement>()\n\n// Keep track of the last uploaded path as a backup\nlet lastUploadedPath = ''\n\n// Composables\nconst recorder = useAudioRecorder({\n  onRecordingComplete: handleRecordingComplete,\n  onError: () => {\n    useToastStore().addAlert(\n      t('g.micPermissionDenied') || 'Microphone permission denied'\n    )\n  }\n})\n\nconst waveform = useAudioWaveform({\n  barCount: 18,\n  minHeight: 4,\n  maxHeight: 32\n})\n\nconst playback = useAudioPlayback(audioRef, {\n  onPlaybackEnded: handlePlaybackEnded,\n  onMetadataLoaded: (duration) => {\n    if (!isPlaying.value && !isRecording.value) {\n      timer.value = Math.floor(duration)\n    }\n  }\n})\n\n// Timer for recording\nconst timer = ref(0)\nconst { pause: pauseTimer, resume: resumeTimer } = useIntervalFn(\n  () => {\n    timer.value += 1\n  },\n  1000,\n  { immediate: false }\n)\n\n// Destructure for template access\nconst { isRecording, recordedURL } = recorder\nconst { waveformBars } = waveform\nconst { isPlaying, audioElementKey } = playback\n\n// Computed for waveform animation\nconst isWaveformActive = computed(() => isRecording.value || isPlaying.value)\n\nconst modelValue = defineModel<string>({ default: '' })\n\nconst litegraphNode = computed(() => {\n  if (!props.nodeId || !app.canvas.graph) return null\n  return app.canvas.graph.getNodeById(props.nodeId) as LGraphNode | null\n})\n\nasync function handleRecordingComplete(blob: Blob) {\n  try {\n    const path = await useAudioService().convertBlobToFileAndSubmit(blob)\n    modelValue.value = path\n    lastUploadedPath = path\n  } catch (e) {\n    useToastStore().addAlert('Failed to upload recorded audio')\n  }\n}\n\nasync function handleStartRecording() {\n  if (props.readonly) return\n\n  try {\n    await waveform.setupAudioContext()\n    await recorder.startRecording()\n\n    // Setup waveform visualization for recording\n    if (recorder.mediaRecorder.value) {\n      const stream = recorder.mediaRecorder.value.stream\n      if (stream) {\n        await waveform.setupRecordingVisualization(stream)\n      }\n    }\n\n    // Start timer\n    timer.value = 0\n    resumeTimer()\n    waveform.initWaveform()\n    waveform.updateWaveform(isWaveformActive)\n  } catch (err) {\n    console.error('Failed to start recording:', err)\n  }\n}\n\nfunction handleStopRecording() {\n  recorder.stopRecording()\n  pauseTimer()\n  waveform.stopWaveform()\n}\n\nasync function handlePlayRecording() {\n  if (!recordedURL.value) return\n\n  // Reset timer\n  timer.value = 0\n\n  // Reset and setup audio element\n  await playback.resetAudioElement()\n\n  // Wait for audio element to be ready\n  await new Promise((resolve) => setTimeout(resolve, 50))\n\n  if (!audioRef.value) return\n\n  // Setup waveform visualization for playback\n  const setupSuccess = await waveform.setupPlaybackVisualization(audioRef.value)\n  if (!setupSuccess) return\n\n  // Start playback\n  await playback.play()\n\n  // Update waveform\n  waveform.initWaveform()\n  waveform.updateWaveform(isWaveformActive)\n\n  // Update timer from audio current time\n  const timerInterval = setInterval(() => {\n    timer.value = Math.floor(playback.getCurrentTime())\n  }, 100)\n\n  // Store interval for cleanup\n  playback.playbackTimerInterval.value = timerInterval\n}\n\nfunction handleStopPlayback() {\n  playback.stop()\n  handlePlaybackEnded()\n}\n\nfunction handlePlaybackEnded() {\n  waveform.stopWaveform()\n\n  // Clear playback timer interval\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n\n  const duration = playback.getDuration()\n  if (duration) {\n    timer.value = Math.floor(duration)\n  } else {\n    timer.value = 0\n  }\n}\n\n// Serialization function for workflow execution\nasync function serializeValue() {\n  if (isRecording.value && recorder.mediaRecorder.value) {\n    recorder.mediaRecorder.value.stop()\n\n    await new Promise((resolve, reject) => {\n      let attempts = 0\n      const maxAttempts = 50 // 5 seconds max (50 * 100ms)\n      const checkRecording = () => {\n        if (!isRecording.value && modelValue.value) {\n          resolve(undefined)\n        } else if (++attempts >= maxAttempts) {\n          reject(new Error('Recording serialization timeout after 5 seconds'))\n        } else {\n          setTimeout(checkRecording, 100)\n        }\n      }\n      checkRecording()\n    })\n  }\n\n  return modelValue.value || lastUploadedPath || ''\n}\n\nfunction registerWidgetSerialization() {\n  const node = litegraphNode.value\n  if (!node?.widgets) return\n  const targetWidget = node.widgets.find((w: IBaseWidget) => w.name === 'audio')\n  if (targetWidget) {\n    targetWidget.serializeValue = serializeValue\n  }\n}\n\nonMounted(() => {\n  waveform.initWaveform()\n  registerWidgetSerialization()\n})\n\nonUnmounted(() => {\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n})\n</script>\n","<template>\n  <div class=\"relative\">\n    <div class=\"mb-4\">\n      <Button\n        class=\"text-base-foreground w-full border-0 bg-secondary-background hover:bg-secondary-background-hover\"\n        :disabled=\"isRecording || readonly\"\n        @click=\"handleStartRecording\"\n      >\n        {{ t('g.startRecording', 'Start Recording') }}\n        <i-lucide:mic class=\"ml-1\" />\n      </Button>\n    </div>\n    <div\n      v-if=\"isRecording || isPlaying || recordedURL\"\n      class=\"flex h-14 w-full min-w-0 items-center gap-2 rounded-lg px-3 bg-node-component-surface text-text-secondary\"\n    >\n      <!-- Recording Status -->\n      <div class=\"flex shrink-0 items-center gap-1\">\n        <span class=\"text-xs\">\n          {{\n            isRecording\n              ? t('g.listening', 'Listening...')\n              : isPlaying\n                ? t('g.playing', 'Playing...')\n                : recordedURL\n                  ? t('g.ready', 'Ready')\n                  : ''\n          }}\n        </span>\n        <span class=\"text-sm\">{{ formatTime(timer) }}</span>\n      </div>\n\n      <!-- Waveform Visualization -->\n      <div class=\"flex h-8 min-w-0 flex-1 items-center gap-2 overflow-hidden\">\n        <div\n          v-for=\"(bar, index) in waveformBars\"\n          :key=\"index\"\n          class=\"max-h-8 min-h-1 w-0.75 rounded-[1.5px] bg-slate-100 transition-all duration-100\"\n          :style=\"{ height: bar.height + 'px' }\"\n          :title=\"`Bar ${index + 1}: ${bar.height}px`\"\n        />\n      </div>\n\n      <!-- Control Button -->\n      <button\n        v-if=\"isRecording\"\n        :title=\"t('g.stopRecording', 'Stop Recording')\"\n        class=\"flex shrink-0 size-8 animate-pulse items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopRecording\"\n      >\n        <div class=\"size-2.5 rounded-sm bg-danger-100\" />\n      </button>\n\n      <button\n        v-else-if=\"!isRecording && recordedURL && !isPlaying\"\n        :title=\"t('g.playRecording') || 'Play Recording'\"\n        class=\"flex shrink-0 size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handlePlayRecording\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--play] size-4\" />\n      </button>\n\n      <button\n        v-else-if=\"isPlaying\"\n        :title=\"t('g.stopPlayback') || 'Stop Playback'\"\n        class=\"flex shrink-0 size-8 items-center justify-center rounded-full border-0 bg-smoke-500/33 transition-colors\"\n        @click=\"handleStopPlayback\"\n      >\n        <i class=\"text-text-secondary icon-[lucide--square] size-4\" />\n      </button>\n    </div>\n    <audio\n      v-if=\"recordedURL\"\n      ref=\"audioRef\"\n      :key=\"audioElementKey\"\n      :src=\"recordedURL\"\n      class=\"hidden\"\n      @ended=\"playback.onPlaybackEnded\"\n      @loadedmetadata=\"playback.onMetadataLoaded\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { useIntervalFn } from '@vueuse/core'\nimport { Button } from 'primevue'\nimport { computed, onMounted, onUnmounted, ref } from 'vue'\n\nimport { t } from '@/i18n'\nimport type { LGraphNode } from '@/lib/litegraph/src/LGraphNode'\nimport type { IBaseWidget } from '@/lib/litegraph/src/types/widgets'\nimport { useToastStore } from '@/platform/updates/common/toastStore'\nimport { app } from '@/scripts/app'\nimport { useAudioService } from '@/services/audioService'\n\nimport { useAudioPlayback } from '../composables/audio/useAudioPlayback'\nimport { useAudioRecorder } from '../composables/audio/useAudioRecorder'\nimport { useAudioWaveform } from '../composables/audio/useAudioWaveform'\nimport { formatTime } from '../utils/audioUtils'\n\nconst props = defineProps<{\n  readonly?: boolean\n  nodeId: string\n}>()\n\n// Audio element ref\nconst audioRef = ref<HTMLAudioElement>()\n\n// Keep track of the last uploaded path as a backup\nlet lastUploadedPath = ''\n\n// Composables\nconst recorder = useAudioRecorder({\n  onRecordingComplete: handleRecordingComplete,\n  onError: () => {\n    useToastStore().addAlert(\n      t('g.micPermissionDenied') || 'Microphone permission denied'\n    )\n  }\n})\n\nconst waveform = useAudioWaveform({\n  barCount: 18,\n  minHeight: 4,\n  maxHeight: 32\n})\n\nconst playback = useAudioPlayback(audioRef, {\n  onPlaybackEnded: handlePlaybackEnded,\n  onMetadataLoaded: (duration) => {\n    if (!isPlaying.value && !isRecording.value) {\n      timer.value = Math.floor(duration)\n    }\n  }\n})\n\n// Timer for recording\nconst timer = ref(0)\nconst { pause: pauseTimer, resume: resumeTimer } = useIntervalFn(\n  () => {\n    timer.value += 1\n  },\n  1000,\n  { immediate: false }\n)\n\n// Destructure for template access\nconst { isRecording, recordedURL } = recorder\nconst { waveformBars } = waveform\nconst { isPlaying, audioElementKey } = playback\n\n// Computed for waveform animation\nconst isWaveformActive = computed(() => isRecording.value || isPlaying.value)\n\nconst modelValue = defineModel<string>({ default: '' })\n\nconst litegraphNode = computed(() => {\n  if (!props.nodeId || !app.canvas.graph) return null\n  return app.canvas.graph.getNodeById(props.nodeId) as LGraphNode | null\n})\n\nasync function handleRecordingComplete(blob: Blob) {\n  try {\n    const path = await useAudioService().convertBlobToFileAndSubmit(blob)\n    modelValue.value = path\n    lastUploadedPath = path\n  } catch (e) {\n    useToastStore().addAlert('Failed to upload recorded audio')\n  }\n}\n\nasync function handleStartRecording() {\n  if (props.readonly) return\n\n  try {\n    await waveform.setupAudioContext()\n    await recorder.startRecording()\n\n    // Setup waveform visualization for recording\n    if (recorder.mediaRecorder.value) {\n      const stream = recorder.mediaRecorder.value.stream\n      if (stream) {\n        await waveform.setupRecordingVisualization(stream)\n      }\n    }\n\n    // Start timer\n    timer.value = 0\n    resumeTimer()\n    waveform.initWaveform()\n    waveform.updateWaveform(isWaveformActive)\n  } catch (err) {\n    console.error('Failed to start recording:', err)\n  }\n}\n\nfunction handleStopRecording() {\n  recorder.stopRecording()\n  pauseTimer()\n  waveform.stopWaveform()\n}\n\nasync function handlePlayRecording() {\n  if (!recordedURL.value) return\n\n  // Reset timer\n  timer.value = 0\n\n  // Reset and setup audio element\n  await playback.resetAudioElement()\n\n  // Wait for audio element to be ready\n  await new Promise((resolve) => setTimeout(resolve, 50))\n\n  if (!audioRef.value) return\n\n  // Setup waveform visualization for playback\n  const setupSuccess = await waveform.setupPlaybackVisualization(audioRef.value)\n  if (!setupSuccess) return\n\n  // Start playback\n  await playback.play()\n\n  // Update waveform\n  waveform.initWaveform()\n  waveform.updateWaveform(isWaveformActive)\n\n  // Update timer from audio current time\n  const timerInterval = setInterval(() => {\n    timer.value = Math.floor(playback.getCurrentTime())\n  }, 100)\n\n  // Store interval for cleanup\n  playback.playbackTimerInterval.value = timerInterval\n}\n\nfunction handleStopPlayback() {\n  playback.stop()\n  handlePlaybackEnded()\n}\n\nfunction handlePlaybackEnded() {\n  waveform.stopWaveform()\n\n  // Clear playback timer interval\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n\n  const duration = playback.getDuration()\n  if (duration) {\n    timer.value = Math.floor(duration)\n  } else {\n    timer.value = 0\n  }\n}\n\n// Serialization function for workflow execution\nasync function serializeValue() {\n  if (isRecording.value && recorder.mediaRecorder.value) {\n    recorder.mediaRecorder.value.stop()\n\n    await new Promise((resolve, reject) => {\n      let attempts = 0\n      const maxAttempts = 50 // 5 seconds max (50 * 100ms)\n      const checkRecording = () => {\n        if (!isRecording.value && modelValue.value) {\n          resolve(undefined)\n        } else if (++attempts >= maxAttempts) {\n          reject(new Error('Recording serialization timeout after 5 seconds'))\n        } else {\n          setTimeout(checkRecording, 100)\n        }\n      }\n      checkRecording()\n    })\n  }\n\n  return modelValue.value || lastUploadedPath || ''\n}\n\nfunction registerWidgetSerialization() {\n  const node = litegraphNode.value\n  if (!node?.widgets) return\n  const targetWidget = node.widgets.find((w: IBaseWidget) => w.name === 'audio')\n  if (targetWidget) {\n    targetWidget.serializeValue = serializeValue\n  }\n}\n\nonMounted(() => {\n  waveform.initWaveform()\n  registerWidgetSerialization()\n})\n\nonUnmounted(() => {\n  if (playback.playbackTimerInterval.value !== null) {\n    clearInterval(playback.playbackTimerInterval.value)\n    playback.playbackTimerInterval.value = null\n  }\n})\n</script>\n"],"mappings":"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"}