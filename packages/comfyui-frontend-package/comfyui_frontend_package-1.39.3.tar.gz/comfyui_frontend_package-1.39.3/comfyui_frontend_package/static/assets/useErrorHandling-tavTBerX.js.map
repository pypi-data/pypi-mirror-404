{"version":3,"file":"useErrorHandling-tavTBerX.js","names":[],"sources":["../../src/composables/useFeatureFlags.ts","../../src/composables/useErrorHandling.ts"],"sourcesContent":["import { computed, reactive, readonly } from 'vue'\n\nimport { isCloud } from '@/platform/distribution/types'\nimport {\n  isAuthenticatedConfigLoaded,\n  remoteConfig\n} from '@/platform/remoteConfig/remoteConfig'\nimport { api } from '@/scripts/api'\n\n/**\n * Known server feature flags (top-level, not extensions)\n */\nexport enum ServerFeatureFlag {\n  SUPPORTS_PREVIEW_METADATA = 'supports_preview_metadata',\n  MAX_UPLOAD_SIZE = 'max_upload_size',\n  MANAGER_SUPPORTS_V4 = 'extension.manager.supports_v4',\n  MODEL_UPLOAD_BUTTON_ENABLED = 'model_upload_button_enabled',\n  ASSET_DELETION_ENABLED = 'asset_deletion_enabled',\n  ASSET_RENAME_ENABLED = 'asset_rename_enabled',\n  PRIVATE_MODELS_ENABLED = 'private_models_enabled',\n  ONBOARDING_SURVEY_ENABLED = 'onboarding_survey_enabled',\n  HUGGINGFACE_MODEL_IMPORT_ENABLED = 'huggingface_model_import_enabled',\n  LINEAR_TOGGLE_ENABLED = 'linear_toggle_enabled',\n  ASYNC_MODEL_UPLOAD_ENABLED = 'async_model_upload_enabled',\n  TEAM_WORKSPACES_ENABLED = 'team_workspaces_enabled'\n}\n\n/**\n * Composable for reactive access to server-side feature flags\n */\nexport function useFeatureFlags() {\n  const flags = reactive({\n    get supportsPreviewMetadata() {\n      return api.getServerFeature(ServerFeatureFlag.SUPPORTS_PREVIEW_METADATA)\n    },\n    get maxUploadSize() {\n      return api.getServerFeature(ServerFeatureFlag.MAX_UPLOAD_SIZE)\n    },\n    get supportsManagerV4() {\n      return api.getServerFeature(ServerFeatureFlag.MANAGER_SUPPORTS_V4)\n    },\n    get modelUploadButtonEnabled() {\n      // Check remote config first (from /api/features), fall back to websocket feature flags\n      return (\n        remoteConfig.value.model_upload_button_enabled ??\n        api.getServerFeature(\n          ServerFeatureFlag.MODEL_UPLOAD_BUTTON_ENABLED,\n          false\n        )\n      )\n    },\n    get assetDeletionEnabled() {\n      return (\n        remoteConfig.value.asset_deletion_enabled ??\n        api.getServerFeature(ServerFeatureFlag.ASSET_DELETION_ENABLED, false)\n      )\n    },\n    get assetRenameEnabled() {\n      return (\n        remoteConfig.value.asset_rename_enabled ??\n        api.getServerFeature(ServerFeatureFlag.ASSET_RENAME_ENABLED, false)\n      )\n    },\n    get privateModelsEnabled() {\n      // Check remote config first (from /api/features), fall back to websocket feature flags\n      return (\n        remoteConfig.value.private_models_enabled ??\n        api.getServerFeature(ServerFeatureFlag.PRIVATE_MODELS_ENABLED, false)\n      )\n    },\n    get onboardingSurveyEnabled() {\n      return (\n        remoteConfig.value.onboarding_survey_enabled ??\n        api.getServerFeature(ServerFeatureFlag.ONBOARDING_SURVEY_ENABLED, true)\n      )\n    },\n    get huggingfaceModelImportEnabled() {\n      return (\n        remoteConfig.value.huggingface_model_import_enabled ??\n        api.getServerFeature(\n          ServerFeatureFlag.HUGGINGFACE_MODEL_IMPORT_ENABLED,\n          false\n        )\n      )\n    },\n    get linearToggleEnabled() {\n      return (\n        remoteConfig.value.linear_toggle_enabled ??\n        api.getServerFeature(ServerFeatureFlag.LINEAR_TOGGLE_ENABLED, false)\n      )\n    },\n    get asyncModelUploadEnabled() {\n      return (\n        remoteConfig.value.async_model_upload_enabled ??\n        api.getServerFeature(\n          ServerFeatureFlag.ASYNC_MODEL_UPLOAD_ENABLED,\n          false\n        )\n      )\n    },\n    /**\n     * Whether team workspaces feature is enabled.\n     * IMPORTANT: Returns false until authenticated remote config is loaded.\n     * This ensures we never use workspace tokens when the feature is disabled,\n     * and prevents race conditions during initialization.\n     */\n    get teamWorkspacesEnabled() {\n      if (!isCloud) return false\n\n      // Only return true if authenticated config has been loaded.\n      // This prevents race conditions where code checks this flag before\n      // WorkspaceAuthGate has refreshed the config with auth.\n      if (!isAuthenticatedConfigLoaded.value) return false\n\n      return (\n        remoteConfig.value.team_workspaces_enabled ??\n        api.getServerFeature(ServerFeatureFlag.TEAM_WORKSPACES_ENABLED, false)\n      )\n    }\n  })\n\n  const featureFlag = <T = unknown>(featurePath: string, defaultValue?: T) =>\n    computed(() => api.getServerFeature(featurePath, defaultValue))\n\n  return {\n    flags: readonly(flags),\n    featureFlag\n  }\n}\n","import { t } from '@/i18n'\nimport { useToastStore } from '@/platform/updates/common/toastStore'\n\n/**\n * Strategy for recovering from specific error conditions.\n * Allows operations to be retried after resolving the error condition.\n *\n * @template TArgs - The argument types of the operation to be retried\n * @template TReturn - The return type of the operation\n *\n * @example\n * ```typescript\n * const networkRecovery: ErrorRecoveryStrategy = {\n *   shouldHandle: (error) => error instanceof NetworkError,\n *   recover: async (error, retry) => {\n *     await waitForNetwork()\n *     await retry()\n *   }\n * }\n * ```\n */\nexport interface ErrorRecoveryStrategy<\n  TArgs extends unknown[] = unknown[],\n  TReturn = unknown\n> {\n  /**\n   * Determines if this strategy should handle the given error.\n   * @param error - The error to check\n   * @returns true if this strategy can handle the error\n   */\n  shouldHandle: (error: unknown) => boolean\n\n  /**\n   * Attempts to recover from the error and retry the operation.\n   * This function is responsible for:\n   * 1. Resolving the error condition (e.g., reauthentication, network reconnect)\n   * 2. Calling retry() to re-execute the original operation\n   * 3. Handling the retry result (success or failure)\n   *\n   * @param error - The error that occurred\n   * @param retry - Function to retry the original operation\n   * @param args - Original arguments passed to the operation\n   * @returns Promise that resolves when recovery completes (whether successful or not)\n   */\n  recover: (\n    error: unknown,\n    retry: (...args: TArgs) => Promise<TReturn> | TReturn,\n    args: TArgs\n  ) => Promise<void>\n}\n\nexport function useErrorHandling() {\n  const toast = useToastStore()\n  const toastErrorHandler = (error: unknown) => {\n    toast.add({\n      severity: 'error',\n      summary: t('g.error'),\n      detail: error instanceof Error ? error.message : t('g.unknownError')\n    })\n    console.error(error)\n  }\n\n  const wrapWithErrorHandling =\n    <TArgs extends unknown[], TReturn>(\n      action: (...args: TArgs) => TReturn,\n      errorHandler?: (error: unknown) => void,\n      finallyHandler?: () => void\n    ) =>\n    (...args: TArgs): TReturn | undefined => {\n      try {\n        return action(...args)\n      } catch (e) {\n        ;(errorHandler ?? toastErrorHandler)(e)\n      } finally {\n        finallyHandler?.()\n      }\n    }\n\n  const wrapWithErrorHandlingAsync =\n    <TArgs extends unknown[], TReturn>(\n      action: (...args: TArgs) => Promise<TReturn> | TReturn,\n      errorHandler?: (error: unknown) => void,\n      finallyHandler?: () => void,\n      recoveryStrategies: ErrorRecoveryStrategy<TArgs, TReturn>[] = []\n    ) =>\n    async (...args: TArgs): Promise<TReturn | undefined> => {\n      try {\n        return await action(...args)\n      } catch (e) {\n        for (const strategy of recoveryStrategies) {\n          if (strategy.shouldHandle(e)) {\n            try {\n              await strategy.recover(e, action, args)\n              return\n            } catch (recoveryError) {\n              console.error('Recovery strategy failed:', recoveryError)\n            }\n          }\n        }\n\n        ;(errorHandler ?? toastErrorHandler)(e)\n      } finally {\n        finallyHandler?.()\n      }\n    }\n\n  return {\n    wrapWithErrorHandling,\n    wrapWithErrorHandlingAsync,\n    toastErrorHandler\n  }\n}\n"],"mappings":"6TA8BA,SAAgB,iBAAkB,CAChC,IAAM,EAAQ,EAAS,CACrB,IAAI,yBAA0B,CAC5B,OAAO,EAAI,iBAAiB,EAAkB,0BAA0B,EAE1E,IAAI,eAAgB,CAClB,OAAO,EAAI,iBAAiB,EAAkB,gBAAgB,EAEhE,IAAI,mBAAoB,CACtB,OAAO,EAAI,iBAAiB,EAAkB,oBAAoB,EAEpE,IAAI,0BAA2B,CAE7B,OACE,EAAa,MAAM,6BACnB,EAAI,iBACF,EAAkB,4BAClB,GACD,EAGL,IAAI,sBAAuB,CACzB,OACE,EAAa,MAAM,wBACnB,EAAI,iBAAiB,EAAkB,uBAAwB,GAAM,EAGzE,IAAI,oBAAqB,CACvB,OACE,EAAa,MAAM,sBACnB,EAAI,iBAAiB,EAAkB,qBAAsB,GAAM,EAGvE,IAAI,sBAAuB,CAEzB,OACE,EAAa,MAAM,wBACnB,EAAI,iBAAiB,EAAkB,uBAAwB,GAAM,EAGzE,IAAI,yBAA0B,CAC5B,OACE,EAAa,MAAM,2BACnB,EAAI,iBAAiB,EAAkB,0BAA2B,GAAK,EAG3E,IAAI,+BAAgC,CAClC,OACE,EAAa,MAAM,kCACnB,EAAI,iBACF,EAAkB,iCAClB,GACD,EAGL,IAAI,qBAAsB,CACxB,OACE,EAAa,MAAM,uBACnB,EAAI,iBAAiB,EAAkB,sBAAuB,GAAM,EAGxE,IAAI,yBAA0B,CAC5B,OACE,EAAa,MAAM,4BACnB,EAAI,iBACF,EAAkB,2BAClB,GACD,EASL,IAAI,uBAAwB,CAQ1B,MAPI,CAAC,GAKD,CAAC,EAA4B,MAAc,GAG7C,EAAa,MAAM,yBACnB,EAAI,iBAAiB,EAAkB,wBAAyB,GAAM,EAG3E,CAAC,CAEI,aAA4B,EAAqB,IACrD,MAAe,EAAI,iBAAiB,EAAa,EAAa,CAAC,CAEjE,MAAO,CACL,MAAO,EAAS,EAAM,CACtB,YACD,oBA/H0C,IAErB,IAIjB,IACa,CAKR,EAAA,SAAA,EAAL,OACL,GAAA,0BAAA,4BACA,EAAA,gBAAA,kBACA,EAAA,oBAAA,gCACA,EAAA,4BAAA,8BACA,EAAA,uBAAA,yBACA,EAAA,qBAAA,uBACA,EAAA,uBAAA,yBACA,EAAA,0BAAA,4BACA,EAAA,iCAAA,mCACA,EAAA,sBAAA,wBACA,EAAA,2BAAA,6BACA,EAAA,wBAAA,oCC2BF,SAAgB,kBAAmB,CACjC,IAAM,EAAQ,GAAe,CACvB,kBAAqB,GAAmB,CAC5C,EAAM,IAAI,CACR,SAAU,QACV,QAAS,EAAE,UAAU,CACrB,OAAQ,aAAiB,MAAQ,EAAM,QAAU,EAAE,iBAAiB,CACrE,CAAC,CACF,QAAQ,MAAM,EAAM,EAGhB,uBAEF,EACA,EACA,KAED,GAAG,IAAqC,CACvC,GAAI,CACF,OAAO,EAAO,GAAG,EAAK,OACf,EAAG,EACR,GAAgB,mBAAmB,EAAE,QAC/B,CACR,KAAkB,GAIlB,4BAEF,EACA,EACA,EACA,EAA8D,EAAE,GAElE,MAAO,GAAG,IAA8C,CACtD,GAAI,CACF,OAAO,MAAM,EAAO,GAAG,EAAK,OACrB,EAAG,CACV,IAAK,IAAM,KAAY,EACrB,GAAI,EAAS,aAAa,EAAE,CAC1B,GAAI,CACF,MAAM,EAAS,QAAQ,EAAG,EAAQ,EAAK,CACvC,aACO,EAAe,CACtB,QAAQ,MAAM,4BAA6B,EAAc,EAK7D,GAAgB,mBAAmB,EAAE,QAC/B,CACR,KAAkB,GAIxB,MAAO,CACL,sBACA,2BACA,kBACD,kBA9Ge,IACY"}