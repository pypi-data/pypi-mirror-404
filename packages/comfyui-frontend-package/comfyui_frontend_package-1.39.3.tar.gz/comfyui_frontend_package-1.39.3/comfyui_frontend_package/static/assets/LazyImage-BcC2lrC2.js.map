{"version":3,"file":"LazyImage-BcC2lrC2.js","names":[],"sources":["../../src/renderer/extensions/vueNodes/widgets/components/form/FormSearchInput.vue","../../src/renderer/extensions/vueNodes/widgets/components/form/FormSearchInput.vue","../../../../../../../assets/images/default-template.png","../../src/composables/useIntersectionObserver.ts","../../src/services/mediaCacheService.ts","../../src/components/common/LazyImage.vue","../../src/components/common/LazyImage.vue"],"sourcesContent":["<script setup lang=\"ts\">\nimport { refDebounced } from '@vueuse/core'\nimport { ref, toRef, toValue, watch } from 'vue'\nimport type { HTMLAttributes, MaybeRefOrGetter } from 'vue'\n\nimport { cn } from '@/utils/tailwindUtil'\n\nconst {\n  searcher = async () => {},\n  updateKey,\n  autofocus = false,\n  class: customClass\n} = defineProps<{\n  searcher?: (\n    query: string,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => Promise<void>\n  updateKey?: MaybeRefOrGetter<unknown>\n  autofocus?: boolean\n  class?: HTMLAttributes['class']\n}>()\n\nconst searchQuery = defineModel<string>({ default: '' })\n\nconst isQuerying = ref(false)\nconst debouncedSearchQuery = refDebounced(searchQuery, 250, {\n  maxWait: 1000\n})\nwatch(searchQuery, (value) => {\n  isQuerying.value = value !== debouncedSearchQuery.value\n})\nconst updateKeyRef = toRef(() => toValue(updateKey))\n\nwatch(\n  [debouncedSearchQuery, updateKeyRef],\n  (_, __, onCleanup) => {\n    let isCleanup = false\n    let cleanupFn: undefined | (() => void)\n    onCleanup(() => {\n      isCleanup = true\n      cleanupFn?.()\n    })\n\n    void searcher(debouncedSearchQuery.value, (cb) => (cleanupFn = cb))\n      .catch((error) => {\n        console.error('[SidePanelSearch] searcher failed', error)\n      })\n      .finally(() => {\n        if (!isCleanup) isQuerying.value = false\n      })\n  },\n  { immediate: true }\n)\n\nfunction handleFocus(event: FocusEvent) {\n  const target = event.target as HTMLInputElement\n  target.select()\n}\n</script>\n\n<template>\n  <label\n    :class=\"\n      cn(\n        'group',\n        'bg-component-node-widget-background rounded-lg transition-all duration-150',\n        'flex-1 flex items-center',\n        'text-base-foreground border-0',\n        'focus-within:ring focus-within:ring-component-node-widget-background-highlighted/80',\n        customClass\n      )\n    \"\n  >\n    <i\n      :class=\"\n        cn(\n          'size-4 ml-2 shrink-0 transition-colors duration-150',\n          isQuerying\n            ? 'icon-[lucide--loader-circle] animate-spin'\n            : 'icon-[lucide--search]',\n          searchQuery?.trim() !== ''\n            ? 'text-base-foreground'\n            : 'text-muted-foreground group-hover:text-base-foreground group-focus-within:text-base-foreground'\n        )\n      \"\n    />\n    <input\n      v-model=\"searchQuery\"\n      type=\"text\"\n      class=\"bg-transparent border-0 outline-0 ring-0 h-5 w-full my-1.5 mx-2\"\n      :placeholder=\"$t('g.searchPlaceholder')\"\n      :autofocus\n      @focus=\"handleFocus\"\n    />\n    <button\n      v-if=\"searchQuery.trim().length > 0\"\n      class=\"text-muted-foreground hover:text-base-foreground bg-transparent shrink-0 border-0 outline-0 ring-0 p-0 m-0 pr-3 pl-1 flex items-center justify-center transition-all duration-150 hover:scale-108\"\n      :aria-label=\"$t('g.clear')\"\n      @click=\"searchQuery = ''\"\n    >\n      <i :class=\"cn('icon-[lucide--delete] size-4 cursor-pointer')\" />\n    </button>\n  </label>\n</template>\n","<script setup lang=\"ts\">\nimport { refDebounced } from '@vueuse/core'\nimport { ref, toRef, toValue, watch } from 'vue'\nimport type { HTMLAttributes, MaybeRefOrGetter } from 'vue'\n\nimport { cn } from '@/utils/tailwindUtil'\n\nconst {\n  searcher = async () => {},\n  updateKey,\n  autofocus = false,\n  class: customClass\n} = defineProps<{\n  searcher?: (\n    query: string,\n    onCleanup: (cleanupFn: () => void) => void\n  ) => Promise<void>\n  updateKey?: MaybeRefOrGetter<unknown>\n  autofocus?: boolean\n  class?: HTMLAttributes['class']\n}>()\n\nconst searchQuery = defineModel<string>({ default: '' })\n\nconst isQuerying = ref(false)\nconst debouncedSearchQuery = refDebounced(searchQuery, 250, {\n  maxWait: 1000\n})\nwatch(searchQuery, (value) => {\n  isQuerying.value = value !== debouncedSearchQuery.value\n})\nconst updateKeyRef = toRef(() => toValue(updateKey))\n\nwatch(\n  [debouncedSearchQuery, updateKeyRef],\n  (_, __, onCleanup) => {\n    let isCleanup = false\n    let cleanupFn: undefined | (() => void)\n    onCleanup(() => {\n      isCleanup = true\n      cleanupFn?.()\n    })\n\n    void searcher(debouncedSearchQuery.value, (cb) => (cleanupFn = cb))\n      .catch((error) => {\n        console.error('[SidePanelSearch] searcher failed', error)\n      })\n      .finally(() => {\n        if (!isCleanup) isQuerying.value = false\n      })\n  },\n  { immediate: true }\n)\n\nfunction handleFocus(event: FocusEvent) {\n  const target = event.target as HTMLInputElement\n  target.select()\n}\n</script>\n\n<template>\n  <label\n    :class=\"\n      cn(\n        'group',\n        'bg-component-node-widget-background rounded-lg transition-all duration-150',\n        'flex-1 flex items-center',\n        'text-base-foreground border-0',\n        'focus-within:ring focus-within:ring-component-node-widget-background-highlighted/80',\n        customClass\n      )\n    \"\n  >\n    <i\n      :class=\"\n        cn(\n          'size-4 ml-2 shrink-0 transition-colors duration-150',\n          isQuerying\n            ? 'icon-[lucide--loader-circle] animate-spin'\n            : 'icon-[lucide--search]',\n          searchQuery?.trim() !== ''\n            ? 'text-base-foreground'\n            : 'text-muted-foreground group-hover:text-base-foreground group-focus-within:text-base-foreground'\n        )\n      \"\n    />\n    <input\n      v-model=\"searchQuery\"\n      type=\"text\"\n      class=\"bg-transparent border-0 outline-0 ring-0 h-5 w-full my-1.5 mx-2\"\n      :placeholder=\"$t('g.searchPlaceholder')\"\n      :autofocus\n      @focus=\"handleFocus\"\n    />\n    <button\n      v-if=\"searchQuery.trim().length > 0\"\n      class=\"text-muted-foreground hover:text-base-foreground bg-transparent shrink-0 border-0 outline-0 ring-0 p-0 m-0 pr-3 pl-1 flex items-center justify-center transition-all duration-150 hover:scale-108\"\n      :aria-label=\"$t('g.clear')\"\n      @click=\"searchQuery = ''\"\n    >\n      <i :class=\"cn('icon-[lucide--delete] size-4 cursor-pointer')\" />\n    </button>\n  </label>\n</template>\n","export default \"__VITE_PUBLIC_ASSET__c8cdd13f__\"","import { onBeforeUnmount, ref, watch } from 'vue'\nimport type { Ref } from 'vue'\n\ninterface UseIntersectionObserverOptions extends IntersectionObserverInit {\n  immediate?: boolean\n}\n\nexport function useIntersectionObserver(\n  target: Ref<Element | null>,\n  callback: IntersectionObserverCallback,\n  options: UseIntersectionObserverOptions = {}\n) {\n  const { immediate = true, ...observerOptions } = options\n\n  const isSupported =\n    typeof window !== 'undefined' && 'IntersectionObserver' in window\n  const isIntersecting = ref(false)\n\n  let observer: IntersectionObserver | null = null\n\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect()\n      observer = null\n    }\n  }\n\n  const observe = () => {\n    cleanup()\n\n    if (!isSupported || !target.value) return\n\n    observer = new IntersectionObserver((entries) => {\n      isIntersecting.value = entries.some((entry) => entry.isIntersecting)\n      callback(entries, observer!)\n    }, observerOptions)\n\n    observer.observe(target.value)\n  }\n\n  const unobserve = () => {\n    if (observer && target.value) {\n      observer.unobserve(target.value)\n    }\n  }\n\n  if (immediate) {\n    watch(target, observe, { immediate: true, flush: 'post' })\n  }\n\n  onBeforeUnmount(cleanup)\n\n  return {\n    isSupported,\n    isIntersecting,\n    observe,\n    unobserve,\n    cleanup\n  }\n}\n","import { reactive } from 'vue'\n\ninterface CachedMedia {\n  src: string\n  blob?: Blob\n  objectUrl?: string\n  error?: boolean\n  isLoading: boolean\n  lastAccessed: number\n}\n\ninterface MediaCacheOptions {\n  maxSize?: number\n  maxAge?: number // in milliseconds\n  preloadDistance?: number // pixels from viewport\n}\n\nclass MediaCacheService {\n  public cache = reactive(new Map<string, CachedMedia>())\n  private readonly maxSize: number\n  private readonly maxAge: number\n  private cleanupInterval: number | null = null\n  private urlRefCount = new Map<string, number>()\n\n  constructor(options: MediaCacheOptions = {}) {\n    this.maxSize = options.maxSize ?? 100\n    this.maxAge = options.maxAge ?? 30 * 60 * 1000 // 30 minutes\n\n    // Start cleanup interval\n    this.startCleanupInterval()\n  }\n\n  private startCleanupInterval() {\n    // Clean up every 5 minutes\n    this.cleanupInterval = window.setInterval(\n      () => {\n        this.cleanup()\n      },\n      5 * 60 * 1000\n    )\n  }\n\n  private cleanup() {\n    const now = Date.now()\n    const keysToDelete: string[] = []\n\n    // Find expired entries\n    for (const [key, entry] of Array.from(this.cache.entries())) {\n      if (now - entry.lastAccessed > this.maxAge) {\n        // Only revoke object URL if no components are using it\n        if (entry.objectUrl) {\n          const refCount = this.urlRefCount.get(entry.objectUrl) || 0\n          if (refCount === 0) {\n            URL.revokeObjectURL(entry.objectUrl)\n            this.urlRefCount.delete(entry.objectUrl)\n            keysToDelete.push(key)\n          }\n          // Don't delete cache entry if URL is still in use\n        } else {\n          keysToDelete.push(key)\n        }\n      }\n    }\n\n    // Remove expired entries\n    keysToDelete.forEach((key) => this.cache.delete(key))\n\n    // If still over size limit, remove oldest entries that aren't in use\n    if (this.cache.size > this.maxSize) {\n      const entries = Array.from(this.cache.entries())\n      entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed)\n\n      let removedCount = 0\n      const targetRemoveCount = this.cache.size - this.maxSize\n\n      for (const [key, entry] of entries) {\n        if (removedCount >= targetRemoveCount) break\n\n        if (entry.objectUrl) {\n          const refCount = this.urlRefCount.get(entry.objectUrl) || 0\n          if (refCount === 0) {\n            URL.revokeObjectURL(entry.objectUrl)\n            this.urlRefCount.delete(entry.objectUrl)\n            this.cache.delete(key)\n            removedCount++\n          }\n        } else {\n          this.cache.delete(key)\n          removedCount++\n        }\n      }\n    }\n  }\n\n  async getCachedMedia(src: string): Promise<CachedMedia> {\n    let entry = this.cache.get(src)\n\n    if (entry) {\n      // Update last accessed time\n      entry.lastAccessed = Date.now()\n      return entry\n    }\n\n    // Create new entry\n    entry = {\n      src,\n      isLoading: true,\n      lastAccessed: Date.now()\n    }\n\n    // Update cache with loading entry\n    this.cache.set(src, entry)\n\n    try {\n      // Fetch the media\n      const response = await fetch(src, { cache: 'force-cache' })\n      if (!response.ok) {\n        throw new Error(`Failed to fetch: ${response.status}`)\n      }\n\n      const blob = await response.blob()\n      const objectUrl = URL.createObjectURL(blob)\n\n      // Update entry with successful result\n      const updatedEntry: CachedMedia = {\n        src,\n        blob,\n        objectUrl,\n        isLoading: false,\n        lastAccessed: Date.now()\n      }\n\n      this.cache.set(src, updatedEntry)\n      return updatedEntry\n    } catch (error) {\n      console.warn('Failed to cache media:', src, error)\n\n      // Update entry with error\n      const errorEntry: CachedMedia = {\n        src,\n        error: true,\n        isLoading: false,\n        lastAccessed: Date.now()\n      }\n\n      this.cache.set(src, errorEntry)\n      return errorEntry\n    }\n  }\n\n  acquireUrl(src: string): string | undefined {\n    const entry = this.cache.get(src)\n    if (entry?.objectUrl) {\n      const currentCount = this.urlRefCount.get(entry.objectUrl) || 0\n      this.urlRefCount.set(entry.objectUrl, currentCount + 1)\n      return entry.objectUrl\n    }\n    return undefined\n  }\n\n  releaseUrl(src: string): void {\n    const entry = this.cache.get(src)\n    if (entry?.objectUrl) {\n      const count = (this.urlRefCount.get(entry.objectUrl) || 1) - 1\n      if (count <= 0) {\n        URL.revokeObjectURL(entry.objectUrl)\n        this.urlRefCount.delete(entry.objectUrl)\n        // Remove from cache as well\n        this.cache.delete(src)\n      } else {\n        this.urlRefCount.set(entry.objectUrl, count)\n      }\n    }\n  }\n\n  clearCache() {\n    // Revoke all object URLs\n    for (const entry of Array.from(this.cache.values())) {\n      if (entry.objectUrl) {\n        URL.revokeObjectURL(entry.objectUrl)\n      }\n    }\n    this.cache.clear()\n    this.urlRefCount.clear()\n  }\n\n  destroy() {\n    if (this.cleanupInterval) {\n      clearInterval(this.cleanupInterval)\n      this.cleanupInterval = null\n    }\n    this.clearCache()\n  }\n}\n\n// Global instance\nlet mediaCacheInstance: MediaCacheService | null = null\n\nexport function useMediaCache(options?: MediaCacheOptions) {\n  if (!mediaCacheInstance) {\n    mediaCacheInstance = new MediaCacheService(options)\n  }\n\n  const getCachedMedia = (src: string) =>\n    mediaCacheInstance!.getCachedMedia(src)\n  const clearCache = () => mediaCacheInstance!.clearCache()\n  const acquireUrl = (src: string) => mediaCacheInstance!.acquireUrl(src)\n  const releaseUrl = (src: string) => mediaCacheInstance!.releaseUrl(src)\n\n  return {\n    getCachedMedia,\n    clearCache,\n    acquireUrl,\n    releaseUrl,\n    cache: mediaCacheInstance.cache\n  }\n}\n\n// Cleanup on page unload\nif (typeof window !== 'undefined') {\n  window.addEventListener('beforeunload', () => {\n    if (mediaCacheInstance) {\n      mediaCacheInstance.destroy()\n    }\n  })\n}\n","<template>\n  <div\n    ref=\"containerRef\"\n    class=\"relative flex h-full w-full items-center justify-center overflow-hidden\"\n    :class=\"containerClass\"\n  >\n    <Skeleton\n      v-if=\"!isImageLoaded\"\n      width=\"100%\"\n      height=\"100%\"\n      class=\"absolute inset-0\"\n    />\n    <img\n      v-if=\"cachedSrc\"\n      :src=\"cachedSrc\"\n      :alt=\"alt\"\n      draggable=\"false\"\n      :class=\"imageClass\"\n      :style=\"imageStyle\"\n      @load=\"onImageLoad\"\n      @error=\"onImageError\"\n    />\n    <div\n      v-if=\"hasError\"\n      class=\"absolute inset-0 flex items-center justify-center\"\n    >\n      <img\n        src=\"/assets/images/default-template.png\"\n        :alt=\"alt\"\n        draggable=\"false\"\n        :class=\"imageClass\"\n        :style=\"imageStyle\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Skeleton from 'primevue/skeleton'\nimport { computed, onUnmounted, ref, watch } from 'vue'\n\nimport { useIntersectionObserver } from '@/composables/useIntersectionObserver'\nimport { useMediaCache } from '@/services/mediaCacheService'\nimport type { ClassValue } from '@/utils/tailwindUtil'\n\nconst {\n  src,\n  alt = '',\n  containerClass = '',\n  imageClass = '',\n  imageStyle,\n  rootMargin = '300px'\n} = defineProps<{\n  src: string\n  alt?: string\n  containerClass?: ClassValue\n  imageClass?: ClassValue\n  imageStyle?: Record<string, any>\n  rootMargin?: string\n}>()\n\nconst containerRef = ref<HTMLElement | null>(null)\nconst isIntersecting = ref(false)\nconst isImageLoaded = ref(false)\nconst hasError = ref(false)\nconst cachedSrc = ref<string | undefined>(undefined)\n\nconst { getCachedMedia, acquireUrl, releaseUrl } = useMediaCache()\n\n// Use intersection observer to detect when the image container comes into view\nuseIntersectionObserver(\n  containerRef,\n  (entries) => {\n    const entry = entries[0]\n    isIntersecting.value = entry?.isIntersecting ?? false\n  },\n  {\n    rootMargin,\n    threshold: 0.1\n  }\n)\n\n// Only start loading the image when it's in view\nconst shouldLoad = computed(() => isIntersecting.value)\n\nwatch(\n  shouldLoad,\n  async (shouldLoadVal) => {\n    if (shouldLoadVal && src && !cachedSrc.value && !hasError.value) {\n      try {\n        const cachedMedia = await getCachedMedia(src)\n        if (cachedMedia.error) {\n          hasError.value = true\n        } else if (cachedMedia.objectUrl) {\n          const acquiredUrl = acquireUrl(src)\n          cachedSrc.value = acquiredUrl || cachedMedia.objectUrl\n        } else {\n          cachedSrc.value = src\n        }\n      } catch (error) {\n        console.warn('Failed to load cached media:', error)\n        cachedSrc.value = src\n      }\n    } else if (!shouldLoadVal) {\n      if (cachedSrc.value?.startsWith('blob:')) {\n        releaseUrl(src)\n      }\n      // Hide image when out of view\n      isImageLoaded.value = false\n      cachedSrc.value = undefined\n      hasError.value = false\n    }\n  },\n  { immediate: true }\n)\n\nconst onImageLoad = () => {\n  isImageLoaded.value = true\n  hasError.value = false\n}\n\nconst onImageError = () => {\n  hasError.value = true\n  isImageLoaded.value = false\n}\n\nonUnmounted(() => {\n  if (cachedSrc.value?.startsWith('blob:')) {\n    releaseUrl(src)\n  }\n})\n</script>\n","<template>\n  <div\n    ref=\"containerRef\"\n    class=\"relative flex h-full w-full items-center justify-center overflow-hidden\"\n    :class=\"containerClass\"\n  >\n    <Skeleton\n      v-if=\"!isImageLoaded\"\n      width=\"100%\"\n      height=\"100%\"\n      class=\"absolute inset-0\"\n    />\n    <img\n      v-if=\"cachedSrc\"\n      :src=\"cachedSrc\"\n      :alt=\"alt\"\n      draggable=\"false\"\n      :class=\"imageClass\"\n      :style=\"imageStyle\"\n      @load=\"onImageLoad\"\n      @error=\"onImageError\"\n    />\n    <div\n      v-if=\"hasError\"\n      class=\"absolute inset-0 flex items-center justify-center\"\n    >\n      <img\n        src=\"/assets/images/default-template.png\"\n        :alt=\"alt\"\n        draggable=\"false\"\n        :class=\"imageClass\"\n        :style=\"imageStyle\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Skeleton from 'primevue/skeleton'\nimport { computed, onUnmounted, ref, watch } from 'vue'\n\nimport { useIntersectionObserver } from '@/composables/useIntersectionObserver'\nimport { useMediaCache } from '@/services/mediaCacheService'\nimport type { ClassValue } from '@/utils/tailwindUtil'\n\nconst {\n  src,\n  alt = '',\n  containerClass = '',\n  imageClass = '',\n  imageStyle,\n  rootMargin = '300px'\n} = defineProps<{\n  src: string\n  alt?: string\n  containerClass?: ClassValue\n  imageClass?: ClassValue\n  imageStyle?: Record<string, any>\n  rootMargin?: string\n}>()\n\nconst containerRef = ref<HTMLElement | null>(null)\nconst isIntersecting = ref(false)\nconst isImageLoaded = ref(false)\nconst hasError = ref(false)\nconst cachedSrc = ref<string | undefined>(undefined)\n\nconst { getCachedMedia, acquireUrl, releaseUrl } = useMediaCache()\n\n// Use intersection observer to detect when the image container comes into view\nuseIntersectionObserver(\n  containerRef,\n  (entries) => {\n    const entry = entries[0]\n    isIntersecting.value = entry?.isIntersecting ?? false\n  },\n  {\n    rootMargin,\n    threshold: 0.1\n  }\n)\n\n// Only start loading the image when it's in view\nconst shouldLoad = computed(() => isIntersecting.value)\n\nwatch(\n  shouldLoad,\n  async (shouldLoadVal) => {\n    if (shouldLoadVal && src && !cachedSrc.value && !hasError.value) {\n      try {\n        const cachedMedia = await getCachedMedia(src)\n        if (cachedMedia.error) {\n          hasError.value = true\n        } else if (cachedMedia.objectUrl) {\n          const acquiredUrl = acquireUrl(src)\n          cachedSrc.value = acquiredUrl || cachedMedia.objectUrl\n        } else {\n          cachedSrc.value = src\n        }\n      } catch (error) {\n        console.warn('Failed to load cached media:', error)\n        cachedSrc.value = src\n      }\n    } else if (!shouldLoadVal) {\n      if (cachedSrc.value?.startsWith('blob:')) {\n        releaseUrl(src)\n      }\n      // Hide image when out of view\n      isImageLoaded.value = false\n      cachedSrc.value = undefined\n      hasError.value = false\n    }\n  },\n  { immediate: true }\n)\n\nconst onImageLoad = () => {\n  isImageLoaded.value = true\n  hasError.value = false\n}\n\nconst onImageError = () => {\n  hasError.value = true\n  isImageLoaded.value = false\n}\n\nonUnmounted(() => {\n  if (cachedSrc.value?.startsWith('blob:')) {\n    releaseUrl(src)\n  }\n})\n</script>\n"],"mappings":"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"}