# Packable { #atdata.Packable }

```python
Packable()
```

Structural protocol for packable sample types.

This protocol allows classes decorated with ``@packable`` to be recognized
as valid types for lens transformations and schema operations, even though
the decorator doesn't change the class's nominal type at static analysis time.

Both ``PackableSample`` subclasses and ``@packable``-decorated classes
satisfy this protocol structurally.

The protocol captures the full interface needed for:
- Lens type transformations (as_wds, from_data)
- Schema publishing (class introspection via dataclass fields)
- Serialization/deserialization (packed, from_bytes)

## Examples {.doc-section .doc-section-examples}

```python
>>> @packable
... class MySample:
...     name: str
...     value: int
...
>>> def process(sample_type: Type[Packable]) -> None:
...     # Type checker knows sample_type has from_bytes, packed, etc.
...     instance = sample_type.from_bytes(data)
...     print(instance.packed)
```

## Attributes

| Name | Description |
| --- | --- |
| [as_wds](#atdata.Packable.as_wds) | WebDataset-compatible representation with __key__ and msgpack. |
| [packed](#atdata.Packable.packed) | Pack this sample's data into msgpack bytes. |

## Methods

| Name | Description |
| --- | --- |
| [from_bytes](#atdata.Packable.from_bytes) | Create instance from raw msgpack bytes. |
| [from_data](#atdata.Packable.from_data) | Create instance from unpacked msgpack data dictionary. |

### from_bytes { #atdata.Packable.from_bytes }

```python
Packable.from_bytes(bs)
```

Create instance from raw msgpack bytes.

### from_data { #atdata.Packable.from_data }

```python
Packable.from_data(data)
```

Create instance from unpacked msgpack data dictionary.