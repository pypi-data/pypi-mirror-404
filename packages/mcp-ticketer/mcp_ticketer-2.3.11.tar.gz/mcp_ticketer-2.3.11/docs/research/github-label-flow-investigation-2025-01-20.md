# GitHub Adapter Label Flow Investigation

**Date**: 2025-01-20
**Status**: Complete
**Scope**: Investigate why labels may not be applied when creating tickets via MCP

## Executive Summary

The investigation found **no explicit warning message** in the codebase matching "Labels weren't applied - they may not exist in the repo yet." However, the investigation identified **a critical silent failure pattern** in the GitHub adapter's `_ensure_label_exists()` method that could cause labels to not be created without any error or warning.

## Investigation Findings

### 1. Warning Message Source - NOT FOUND

Grep searches for patterns like "may not exist", "weren't applied", "Labels weren't", and similar variations found:
- **No matches in source code** for the specific warning message
- Only reference found was in archived documentation (`docs/_archive/implementations/MCP_INSTALLER_FIX_COMPLETE.md`) which is unrelated to labels

**Conclusion**: The warning message may be:
1. Dynamically generated by an AI agent interpreting the response
2. From an older version that was removed
3. From a client-side interpretation of missing labels in the response

### 2. Critical Finding: Silent Label Creation Failure

**Location**: `src/mcp_ticketer/adapters/github/adapter.py`, lines 192-215

```python
async def _ensure_label_exists(
    self, label_name: str, color: str = "0366d6"
) -> None:
    """Ensure a label exists in the repository."""
    cache_key = "github_labels"
    cached_labels = await self._labels_cache.get(cache_key)

    if cached_labels is None:
        response = await self.client.get(f"/repos/{self.owner}/{self.repo}/labels")
        response.raise_for_status()
        cached_labels = response.json()
        await self._labels_cache.set(cache_key, cached_labels)

    # Check if label exists
    existing_labels = [label["name"].lower() for label in cached_labels]
    if label_name.lower() not in existing_labels:
        # Create the label
        response = await self.client.post(
            f"/repos/{self.owner}/{self.repo}/labels",
            json={"name": label_name, "color": color},
        )
        if response.status_code == 201:  # <-- ONLY updates cache on success
            cached_labels.append(response.json())
            await self._labels_cache.set(cache_key, cached_labels)
        # <-- NO ERROR HANDLING for non-201 responses!
```

**Problem**: When label creation fails (e.g., 403 forbidden, 422 validation error), the method:
1. Does NOT raise an exception
2. Does NOT log a warning
3. Does NOT return any indication of failure
4. Simply continues silently

**Impact**: The issue is then created with the non-existent label, and GitHub's API returns a 422 error, which DOES get raised. BUT if the user lacks permission to create labels, the `_ensure_label_exists` call fails silently, and then the issue creation might succeed with fewer labels than requested.

### 3. MCP Flow Analysis

**File**: `src/mcp_ticketer/mcp/server/tools/ticket_tools.py`

The MCP ticket creation flow:

```
1. ticket() dispatches to ticket_create() (line 507)
2. ticket_create() collects labels from:
   - User-provided tags (line 631)
   - Default tags from config (lines 632-638)
   - Auto-detected labels via detect_and_apply_labels() (lines 641-644)
3. Task object created with final_tags (line 647-654)
4. adapter.create(task) called (line 657)
5. Response includes labels_applied from created.tags (line 664)
```

**Key observation**: The `labels_applied` in the response comes from `created.tags`, which is populated by `map_github_issue_to_task()` from the actual created issue. This means:
- If GitHub rejected some labels, `labels_applied` would show fewer labels
- The user would see a mismatch between requested and applied labels

### 4. detect_and_apply_labels() - Silent Catch

**Location**: `src/mcp_ticketer/mcp/server/tools/ticket_tools.py`, lines 145-152

```python
try:
    if hasattr(adapter, "list_labels"):
        available_labels = await adapter.list_labels()
    elif hasattr(adapter, "get_labels"):
        available_labels = await adapter.get_labels()
except Exception:
    # Adapter doesn't support labels or listing failed - return user labels only
    return existing_labels or []
```

**Problem**: This silently catches ALL exceptions when listing labels. If listing fails (network error, auth error), it returns only user-provided labels without any warning.

### 5. Contrast with Linear Adapter

**File**: `src/mcp_ticketer/adapters/linear/adapter.py`, lines 1429-1559

The Linear adapter uses a **three-tier approach** with proper error handling:

```python
async def _ensure_labels_exist(self, label_names: list[str]) -> list[str]:
    # Tier 1: Check cache
    # Tier 2: Query server for existence (handles staleness)
    # Tier 3: Create if truly doesn't exist

    # Key difference: RAISES ValueError on failure
    if server_label is None:
        try:
            new_label_id = await self._create_label(name, team_id)
        except Exception as e:
            # FAIL-FAST: Propagates error with clear message
            raise ValueError(f"Failed to create label '{name}': {e}") from e
```

**Linear's approach**:
- Fail-fast behavior (1M-396)
- All-or-nothing: Partial label updates not allowed
- Clear error messages for callers
- Cache invalidation on staleness detection

### 6. GitHub Adapter's create() Method

**File**: `src/mcp_ticketer/adapters/github/adapter.py`, lines 232-303

```python
async def create(self, ticket: Task) -> Task:
    # Prepare labels
    labels = ticket.tags.copy() if ticket.tags else []

    # Add state label if needed
    state_label = self._get_state_label(ticket.state)
    if state_label:
        labels.append(state_label)
        await self._ensure_label_exists(state_label, "fbca04")  # Silent failure possible

    # Add priority label
    priority_label = self._get_priority_label(ticket.priority)
    labels.append(priority_label)
    await self._ensure_label_exists(priority_label, "d73a4a")  # Silent failure possible

    # Ensure all labels exist
    for label in labels:
        await self._ensure_label_exists(label)  # Silent failure possible for EACH

    # Build issue data
    issue_data = {
        "title": ticket.title,
        "body": ticket.description or "",
        "labels": labels,  # ALL labels passed regardless of creation success
    }

    # Create the issue
    response = await self.client.post(...)
    response.raise_for_status()  # <-- This WILL fail if labels don't exist
```

**Scenario that causes issues**:
1. User requests ticket with tags: `["bug", "urgent", "custom-tag"]`
2. `_ensure_label_exists("bug")` - exists, OK
3. `_ensure_label_exists("urgent")` - exists, OK
4. `_ensure_label_exists("custom-tag")` - creation fails (403), NO ERROR
5. Issue creation with all 3 labels - GitHub returns 422 "Validation Failed"
6. User sees: "Failed to create ticket: 422 Unprocessable Entity"

## Root Cause Summary

| Issue | Location | Impact |
|-------|----------|--------|
| Silent label creation failure | `_ensure_label_exists()` | Labels not created without any error |
| No logging on failure | `_ensure_label_exists()` | No diagnostic information |
| Silent exception catch | `detect_and_apply_labels()` | Label listing failures hidden |
| All labels passed regardless | `create()` | 422 error from GitHub API |

## Recommendations

### 1. Add Error Handling to `_ensure_label_exists()`

```python
async def _ensure_label_exists(
    self, label_name: str, color: str = "0366d6"
) -> bool:  # Return success/failure
    """Ensure a label exists in the repository."""
    # ... existing cache logic ...

    if label_name.lower() not in existing_labels:
        response = await self.client.post(
            f"/repos/{self.owner}/{self.repo}/labels",
            json={"name": label_name, "color": color},
        )
        if response.status_code == 201:
            cached_labels.append(response.json())
            await self._labels_cache.set(cache_key, cached_labels)
            return True
        elif response.status_code == 422:
            # Label might already exist (race condition)
            logger.debug(f"Label '{label_name}' already exists or validation failed")
            return True  # Continue - label exists
        else:
            logger.warning(
                f"Failed to create label '{label_name}': "
                f"HTTP {response.status_code}"
            )
            return False
    return True
```

### 2. Filter Labels in create()

```python
async def create(self, ticket: Task) -> Task:
    labels = ticket.tags.copy() if ticket.tags else []
    verified_labels = []

    for label in labels:
        if await self._ensure_label_exists(label):
            verified_labels.append(label)
        else:
            logger.warning(f"Skipping label '{label}' - could not ensure existence")

    # Only include verified labels in issue
    issue_data["labels"] = verified_labels
```

### 3. Add Warning to MCP Response

```python
response = {
    "status": "completed",
    "ticket": created.model_dump(),
    "labels_applied": created.tags or [],
    "labels_requested": final_tags,  # NEW
    "labels_warning": (
        f"Some labels could not be applied: {set(final_tags) - set(created.tags)}"
        if set(final_tags) != set(created.tags or [])
        else None
    ),
}
```

## Files Analyzed

| File | Purpose |
|------|---------|
| `adapters/github/adapter.py` | Main adapter with `_ensure_label_exists()` and `create()` |
| `adapters/github/mappers.py` | Task mapping from GitHub issue response |
| `adapters/linear/adapter.py` | Reference for better error handling patterns |
| `mcp/server/tools/ticket_tools.py` | MCP tool with `detect_and_apply_labels()` |

## Conclusion

The warning message "Labels weren't applied - they may not exist in the repo yet" was not found in the codebase. However, the investigation uncovered a significant issue: **the GitHub adapter silently swallows label creation failures**. This can cause:

1. Labels to not be created without any error
2. Subsequent issue creation to fail with a 422 error
3. Users to receive confusing error messages

The recommended fixes would add proper error handling, logging, and user-facing warnings to make label handling more transparent and debuggable.

---

*Research completed: 2025-01-20*
