"""Backend test generator for Prism.

Generates pytest tests, Factory Boy factories, and test fixtures
for backend code.
"""

from __future__ import annotations

from pathlib import Path
from typing import TYPE_CHECKING

from prisme.generators.base import GeneratedFile, ModelGenerator, create_init_file
from prisme.spec.fields import FieldType
from prisme.spec.stack import FileStrategy
from prisme.utils.case_conversion import pluralize, to_camel_case, to_snake_case

if TYPE_CHECKING:
    from prisme.spec.fields import FieldSpec
    from prisme.spec.model import ModelSpec


class BackendTestGenerator(ModelGenerator):
    """Generator for backend tests and factories."""

    def __init__(self, *args, **kwargs) -> None:  # type: ignore[no-untyped-def]
        super().__init__(*args, **kwargs)
        backend_base = Path(self.generator_config.backend_output)
        # Put tests at backend root level (e.g., packages/backend/tests/)
        # not inside src/ (e.g., packages/backend/src/tests/)
        backend_root = backend_base.parent if backend_base.name == "src" else backend_base
        self.tests_path = backend_root / self.generator_config.tests_path

    @property
    def _auth_enabled_jwt(self) -> bool:
        """Check if JWT auth is enabled."""
        return self.auth_config.enabled and self.auth_config.preset == "jwt"

    def generate_shared_files(self) -> list[GeneratedFile]:
        """Generate shared test fixtures and conftest."""
        files = [
            self._generate_conftest(),
            self._generate_migration_check_test(),
        ]

        if self.testing_config.generate_factories:
            files.append(self._generate_factories_init())

        if self._auth_enabled_jwt:
            files.extend(self._generate_auth_tests())

        return files

    def generate_model_files(self, model: ModelSpec) -> list[GeneratedFile]:
        """Generate tests and factory for a single model."""
        files = []

        if self.testing_config.generate_factories:
            files.append(self._generate_factory(model))

        if self.testing_config.generate_unit_tests:
            files.append(self._generate_service_tests(model))

        if self.testing_config.generate_integration_tests and model.expose:
            files.append(self._generate_api_tests(model))

        if self.testing_config.generate_graphql_tests and model.expose:
            files.append(self._generate_graphql_tests(model))

        return files

    def generate_index_files(self) -> list[GeneratedFile]:
        """Generate index files for test directories."""
        return []

    def _generate_conftest(self) -> GeneratedFile:
        """Generate pytest conftest.py with shared fixtures."""
        db_type = self.testing_config.test_database
        project_name = self.get_package_name()

        content = f'''"""Pytest configuration and shared fixtures.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

import asyncio
import os
from typing import AsyncGenerator, Generator

# Set test database URL before any app imports
os.environ["DATABASE_URL"] = "sqlite+aiosqlite:///:memory:"

import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import StaticPool

from {project_name}.models.base import Base

# Use {db_type} for tests
'''

        if db_type == "sqlite":
            content += '''TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"

@pytest.fixture(scope="session")
def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:
    """Create event loop for the test session."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


@pytest_asyncio.fixture(scope="session")
async def engine():
    """Create async engine for tests."""
    engine = create_async_engine(
        TEST_DATABASE_URL,
        connect_args={"check_same_thread": False},
        poolclass=StaticPool,
    )

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    await engine.dispose()

'''
        else:  # PostgreSQL
            content += '''# Configure your test database URL
TEST_DATABASE_URL = "postgresql+asyncpg://test:test@localhost:5432/test_db"

@pytest.fixture(scope="session")
def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:
    """Create event loop for the test session."""
    loop = asyncio.new_event_loop()
    yield loop
    loop.close()


@pytest_asyncio.fixture(scope="session")
async def engine():
    """Create async engine for tests."""
    engine = create_async_engine(TEST_DATABASE_URL)

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    yield engine

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

    await engine.dispose()

'''

        content += '''
@pytest_asyncio.fixture
async def db(engine) -> AsyncGenerator[AsyncSession, None]:
    """Get a test database session."""
    async_session = async_sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False,
    )

    async with async_session() as session:
        yield session
        await session.rollback()

'''

        if self._auth_enabled_jwt:
            content += f'''
@pytest_asyncio.fixture
async def client(db):
    """Create test client with database session and auth bypass."""
    from httpx import ASGITransport, AsyncClient
    from {project_name}.auth.dependencies import get_current_active_user
    from {project_name}.database import get_db
    from {project_name}.main import app
    from {project_name}.models.user import User

    async def override_get_db():
        yield db

    async def override_get_current_active_user():
        return User(
            id=1,
            email="test@example.com",
            is_active=True,
            email_verified=True,
            roles=["admin"],
        )

    app.dependency_overrides[get_db] = override_get_db
    app.dependency_overrides[get_current_active_user] = override_get_current_active_user

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()
'''
        else:
            content += f'''
@pytest_asyncio.fixture
async def client(db):
    """Create test client with database session."""
    from httpx import AsyncClient, ASGITransport
    from {project_name}.main import app
    from {project_name}.database import get_db

    async def override_get_db():
        yield db

    app.dependency_overrides[get_db] = override_get_db

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()
'''

        # Add auth fixtures when JWT auth is enabled
        if self._auth_enabled_jwt:
            content += f'''

@pytest_asyncio.fixture
async def unauthenticated_client(db):
    """Create test client without auth override (requests will be unauthenticated)."""
    from httpx import ASGITransport, AsyncClient
    from {project_name}.database import get_db
    from {project_name}.main import app

    async def override_get_db():
        yield db

    app.dependency_overrides[get_db] = override_get_db

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()


@pytest_asyncio.fixture
async def authenticated_client(db):
    """Client with a real persisted user for authenticated endpoint tests."""
    import uuid
    from httpx import ASGITransport, AsyncClient
    from {project_name}.auth.dependencies import get_current_active_user
    from {project_name}.auth.utils import hash_password
    from {project_name}.database import get_db
    from {project_name}.main import app
    from {project_name}.models.user import User

    unique = uuid.uuid4().hex[:8]
    user = User(
        email=f"authuser-{{unique}}@example.com",
        username=f"authuser-{{unique}}",
        password_hash=hash_password("StrongPass1"),
        email_verified=True,
        is_active=True,
        roles=["admin"],
        failed_login_attempts=0,
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)

    async def override_get_db():
        yield db

    async def override_get_current_active_user():
        await db.refresh(user)
        return user

    app.dependency_overrides[get_db] = override_get_db
    app.dependency_overrides[get_current_active_user] = override_get_current_active_user

    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

    app.dependency_overrides.clear()
'''

        return GeneratedFile(
            path=self.tests_path / "conftest.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description="Test conftest",
        )

    def _generate_migration_check_test(self) -> GeneratedFile:
        """Generate test that verifies alembic migrations match current models."""
        content = '''"""Verify alembic migrations match current models.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

import subprocess

import pytest


@pytest.mark.migration
def test_migrations_up_to_date():
    """Ensure no model changes are missing migrations.

    Runs 'alembic check' which compares the current model metadata
    against the migration history and fails if they diverge.
    Requires DATABASE_URL to be set.
    """
    result = subprocess.run(
        ["uv", "run", "alembic", "check"],
        capture_output=True,
        text=True,
    )
    assert result.returncode == 0, (
        f"Model/migration drift detected:\\n{result.stdout}\\n{result.stderr}"
    )
'''

        return GeneratedFile(
            path=self.tests_path / "test_migration_check.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description="Migration drift check test",
        )

    def _generate_factories_init(self) -> GeneratedFile:
        """Generate __init__.py for factories."""
        imports = []
        exports = []

        for model in self.spec.models:
            snake_name = to_snake_case(model.name)
            imports.append(f"from .{snake_name} import {model.name}Factory")
            exports.append(f"{model.name}Factory")

        return create_init_file(
            self.tests_path / "factories",
            imports,
            exports,
            "Test factories using Factory Boy.",
        )

    def _generate_factory(self, model: ModelSpec) -> GeneratedFile:
        """Generate Factory Boy factory for a model."""
        snake_name = to_snake_case(model.name)

        project_name = self.get_package_name()

        # Check if we need random import (for constrained float/decimal fields or JSON arrays)
        needs_random = any(
            (
                f.type in (FieldType.FLOAT, FieldType.DECIMAL)
                and (f.min_value is not None or f.max_value is not None)
            )
            or (
                f.type == FieldType.JSON
                and f.json_item_type
                and f.json_item_type.lower() in ("int", "integer", "float", "number")
            )
            for f in model.fields
        )

        # Check if we need uuid import (for unique UUID fields)
        needs_uuid = any(f.type == FieldType.UUID and f.unique for f in model.fields)

        random_import = "import random\n" if needs_random else ""
        uuid_import = "import uuid\n" if needs_uuid else ""

        content = f'''"""Factory for {model.name} test data.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

{random_import}{uuid_import}import factory
from factory.alchemy import SQLAlchemyModelFactory

from {project_name}.models.{snake_name} import {model.name}


class {model.name}Factory(SQLAlchemyModelFactory):
    """Factory for creating {model.name} test instances."""

    class Meta:
        model = {model.name}
        # Disable auto-commit for async SQLAlchemy - tests call await db.commit()
        sqlalchemy_session_persistence = None

{self._build_factory_fields(model)}


# Convenience function
def create_{snake_name}(**kwargs) -> {model.name}:
    """Create a {model.name} instance."""
    return {model.name}Factory.create(**kwargs)


def build_{snake_name}(**kwargs) -> {model.name}:
    """Build a {model.name} instance without saving."""
    return {model.name}Factory.build(**kwargs)
'''

        return GeneratedFile(
            path=self.tests_path / "factories" / f"{snake_name}.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description=f"Factory for {model.name}",
        )

    def _build_factory_fields(self, model: ModelSpec) -> str:
        """Build factory field definitions."""
        lines = []

        for field in model.fields:
            faker = self._get_faker_for_field(field)
            lines.append(f"    {field.name} = {faker}")

        return "\n".join(lines) if lines else "    pass"

    def _get_unique_faker(self, field: FieldSpec) -> str:
        """Get a Sequence-based faker for unique fields to avoid collisions."""
        if field.type == FieldType.STRING:
            name_lower = field.name.lower()
            if "email" in name_lower:
                return "factory.Sequence(lambda n: f'test{n}@example.com')"
            # Check for IP address fields
            elif (
                ("ip" in name_lower and "address" in name_lower)
                or name_lower == "ip"
                or name_lower.endswith("_ip")
            ):
                return "factory.Sequence(lambda n: f'192.168.1.{n % 255}')"
            # For fields with alphanumeric patterns (like subdomain names)
            elif field.pattern and "a-z" in field.pattern and "0-9" in field.pattern:
                return "factory.Sequence(lambda n: f'item{n}')"
            return f"factory.Sequence(lambda n: f'{field.name}{{n}}')"
        elif field.type == FieldType.INTEGER:
            min_val = int(field.min_value) if field.min_value is not None else 1
            return f"factory.Sequence(lambda n: {min_val} + n)"
        elif field.type == FieldType.UUID:
            return "factory.LazyFunction(uuid.uuid4)"
        else:
            # Fallback for other types - use sequence with string representation
            return "factory.Sequence(lambda n: f'unique{n}')"

    def _get_faker_for_field(self, field: FieldSpec) -> str:
        """Get Factory Boy faker for a field type."""
        # Handle unique fields with Sequence to avoid collisions
        if field.unique:
            return self._get_unique_faker(field)

        if field.type == FieldType.STRING:
            name_lower = field.name.lower()
            # Check for IP address fields
            if (
                ("ip" in name_lower and "address" in name_lower)
                or name_lower == "ip"
                or name_lower.endswith("_ip")
            ):
                return "factory.Faker('ipv4')"
            elif "email" in name_lower:
                return "factory.Faker('email')"
            elif "url" in name_lower:
                return "factory.Faker('url')"
            # For fields with patterns that suggest subdomain/domain names,
            # use a simple alphanumeric sequence instead of random strings
            elif field.pattern and "a-z" in field.pattern and "0-9" in field.pattern:
                # Pattern like ^[a-z0-9]... suggests alphanumeric only (no underscores)
                return "factory.Sequence(lambda n: f'item{n}')"
            elif "name" in name_lower:
                # For generic 'name' fields, check if there's a pattern constraint
                if field.pattern:
                    # If pattern restricts to alphanumeric, use sequence
                    return "factory.Sequence(lambda n: f'name{n}')"
                return "factory.Faker('name')"
            else:
                return f"factory.Faker('pystr', max_chars={field.max_length or 50})"

        elif field.type == FieldType.TEXT:
            return "factory.Faker('paragraph')"

        elif field.type == FieldType.INTEGER:
            min_val = int(field.min_value) if field.min_value is not None else 1
            max_val = int(field.max_value) if field.max_value is not None else 1000
            return f"factory.Faker('random_int', min={min_val}, max={max_val})"

        elif field.type in (FieldType.FLOAT, FieldType.DECIMAL):
            # Use constraint-aware generation if bounds are specified
            if field.min_value is not None or field.max_value is not None:
                min_float = float(field.min_value) if field.min_value is not None else 0.0
                max_float = float(field.max_value) if field.max_value is not None else 1000.0
                return f"factory.LazyFunction(lambda: round(random.uniform({min_float}, {max_float}), 2))"
            return "factory.Faker('pydecimal', left_digits=5, right_digits=2, positive=True)"

        elif field.type == FieldType.BOOLEAN:
            return "factory.Faker('boolean')"

        elif field.type == FieldType.DATETIME:
            return "factory.Faker('date_time')"

        elif field.type == FieldType.DATE:
            return "factory.Faker('date_object')"

        elif field.type == FieldType.TIME:
            return "factory.Faker('time_object')"

        elif field.type == FieldType.UUID:
            return "factory.Faker('uuid4')"

        elif field.type == FieldType.ENUM and field.enum_values:
            values = ", ".join(f"'{v}'" for v in field.enum_values)
            return f"factory.Faker('random_element', elements=[{values}])"

        elif field.type == FieldType.FOREIGN_KEY:
            return "factory.Faker('random_int', min=1, max=100)"

        elif field.type == FieldType.JSON:
            # If the field has json_item_type, it's a typed array
            if field.json_item_type:
                item_type = field.json_item_type.lower()
                if item_type in ("int", "integer"):
                    return (
                        "factory.LazyFunction(lambda: [random.randint(0, 255) for _ in range(3)])"
                    )
                elif item_type in ("float", "number"):
                    return "factory.LazyFunction(lambda: [round(random.random() * 100, 2) for _ in range(3)])"
                elif item_type in ("str", "string"):
                    return "factory.LazyFunction(lambda: ['item1', 'item2', 'item3'])"
                elif item_type in ("bool", "boolean"):
                    return "factory.LazyFunction(lambda: [True, False, True])"
                else:
                    return "factory.LazyFunction(lambda: ['item1', 'item2'])"
            return "factory.LazyFunction(lambda: {'key': 'value'})"

        return "factory.Faker('pystr')"

    def _get_test_imports(self, model: ModelSpec) -> str:
        """Get additional imports needed for test values based on field types."""
        imports = []

        has_datetime = any(f.type == FieldType.DATETIME for f in model.fields)
        has_date = any(f.type == FieldType.DATE for f in model.fields)
        has_time = any(f.type == FieldType.TIME for f in model.fields)
        has_uuid = any(f.type == FieldType.UUID for f in model.fields)

        datetime_types = []
        if has_datetime:
            datetime_types.append("datetime")
        if has_date:
            datetime_types.append("date")
        if has_time:
            datetime_types.append("time")

        if datetime_types:
            imports.append(f"from datetime import {', '.join(datetime_types)}")

        if has_uuid:
            imports.append("from uuid import uuid4")

        return "\n".join(imports)

    def _generate_service_tests(self, model: ModelSpec) -> GeneratedFile:
        """Generate unit tests for service class."""
        snake_name = to_snake_case(model.name)
        plural_name = pluralize(snake_name)
        project_name = self.get_package_name()

        # Get additional imports based on field types
        extra_imports = self._get_test_imports(model)
        if extra_imports:
            extra_imports = extra_imports + "\n"

        content = f'''"""Unit tests for {model.name}Service.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

{extra_imports}import pytest
import pytest_asyncio

from {project_name}.services.{snake_name} import {model.name}Service
from {project_name}.schemas.{snake_name} import {model.name}Create, {model.name}Update
from tests.factories.{snake_name} import {model.name}Factory


class Test{model.name}Service:
    """Tests for {model.name}Service CRUD operations."""

    @pytest_asyncio.fixture
    async def service(self, db):
        """Create service instance."""
        {model.name}Factory._meta.sqlalchemy_session = db
        return {model.name}Service(db)

    async def test_create(self, service, db):
        """Test creating a {snake_name}."""
        data = {model.name}Create(
{self._build_create_test_data(model)}
        )

        result = await service.create(data=data)

        assert result is not None
        assert result.id is not None
{self._build_create_assertions(model)}

    async def test_get(self, service, db):
        """Test getting a {snake_name} by ID."""
        instance = {model.name}Factory.create()
        await db.commit()

        result = await service.get(instance.id)

        assert result is not None
        assert result.id == instance.id

    async def test_get_not_found(self, service):
        """Test getting a non-existent {snake_name}."""
        result = await service.get(99999)

        assert result is None

    async def test_list(self, service, db):
        """Test listing {plural_name}."""
        # Create test data
        for _ in range(5):
            {model.name}Factory.create()
        await db.commit()

        results = await service.list(skip=0, limit=10)

        assert len(results) >= 5

    async def test_update(self, service, db):
        """Test updating a {snake_name}."""
        instance = {model.name}Factory.create()
        await db.commit()

        data = {model.name}Update(
{self._build_update_test_data(model)}
        )

        result = await service.update(id=instance.id, data=data)

        assert result is not None

    async def test_update_not_found(self, service):
        """Test updating a non-existent {snake_name}."""
        data = {model.name}Update()

        result = await service.update(id=99999, data=data)

        assert result is None

    async def test_delete(self, service, db):
        """Test deleting a {snake_name}."""
        instance = {model.name}Factory.create()
        await db.commit()

        result = await service.delete(id=instance.id)

        assert result is True

    async def test_delete_not_found(self, service):
        """Test deleting a non-existent {snake_name}."""
        result = await service.delete(id=99999)

        assert result is False
'''

        return GeneratedFile(
            path=self.tests_path / "unit" / f"test_{snake_name}_service.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description=f"Service tests for {model.name}",
        )

    def _build_create_test_data(self, model: ModelSpec) -> str:
        """Build test data for create operation."""
        lines = []
        for field in model.fields:
            if field.required and not field.default:
                # Use unique suffix for fields that might have unique constraints
                suffix = "_create" if field.unique or "email" in field.name.lower() else ""
                value = self._get_test_value(field, suffix)
                lines.append(f"            {field.name}={value},")
        return "\n".join(lines)

    def _build_create_assertions(self, model: ModelSpec) -> str:
        """Build assertions for create test."""
        lines = []
        for field in model.fields:
            if field.required and not field.default:
                lines.append(f"        assert result.{field.name} is not None")
        return "\n".join(lines)

    def _build_update_test_data(self, model: ModelSpec) -> str:
        """Build test data for update operation."""
        # Just update the first non-unique field to avoid constraint issues
        for field in model.fields:
            # Skip unique fields for updates to avoid constraint violations
            if field.unique or "email" in field.name.lower():
                continue
            value = self._get_test_value(field, "_updated")
            return f"            {field.name}={value},"
        # If all fields are unique, update the first with a unique suffix
        for field in model.fields:
            value = self._get_test_value(field, "_updated")
            return f"            {field.name}={value},"
        return "            pass"

    def _get_test_value(self, field: FieldSpec, unique_suffix: str = "") -> str:
        """Get a test value for a field."""
        if field.type == FieldType.STRING:
            # Handle special string field patterns based on name or pattern
            name_lower = field.name.lower()

            # Check for IP address fields
            if (
                ("ip" in name_lower and "address" in name_lower)
                or name_lower == "ip"
                or name_lower.endswith("_ip")
            ):
                return '"192.168.1.1"'
            # Check for URL pattern or name
            elif (
                "url" in name_lower
                or "link" in name_lower
                or "website" in name_lower
                or (field.pattern and ("http" in field.pattern or "url" in field.pattern.lower()))
            ):
                return f'"https://example{unique_suffix}.com"'
            elif "email" in name_lower:
                return f'"test{unique_suffix}@example.com"'
            elif "phone" in name_lower:
                return '"+1234567890"'
            elif "ticker" in name_lower or "symbol" in name_lower:
                return f'"TEST{unique_suffix}"'
            elif "isin" in name_lower:
                # Use unique suffix for ISIN to avoid constraint violations
                # ISIN format: 12 characters (2 country + 9 NSIN + 1 check)
                suffix_char = unique_suffix.replace("_", "")[:1].upper() if unique_suffix else "0"
                return f'"US0000000{suffix_char}00"'
            elif "cusip" in name_lower:
                return '"000000000"'
            elif "currency" in name_lower:
                return '"USD"'
            elif "country" in name_lower:
                return '"US"'

            # For fields with patterns that restrict to alphanumeric, avoid underscores
            if field.pattern and "a-z" in field.pattern and "0-9" in field.pattern:
                suffix = unique_suffix.replace("_", "")
                base_value = f"testval{suffix}"
            else:
                base_value = f"test_value{unique_suffix}"
            # Respect min_length constraint
            if field.min_length and len(base_value) < field.min_length:
                pad = "a" if field.pattern and "_" not in field.pattern else "_"
                base_value = base_value + pad * (field.min_length - len(base_value))
            return f'"{base_value}"'
        elif field.type == FieldType.TEXT:
            return '"Test text content"'
        elif field.type == FieldType.INTEGER:
            # Respect min/max value constraints
            if field.min_value is not None or field.max_value is not None:
                min_val = int(field.min_value) if field.min_value is not None else 0
                max_val = int(field.max_value) if field.max_value is not None else 1000
                # Pick a value in the middle of the range
                test_val = (min_val + max_val) // 2
                return str(test_val)
            return "42"
        elif field.type in (FieldType.FLOAT, FieldType.DECIMAL):
            return "3.14"
        elif field.type == FieldType.BOOLEAN:
            return "True"
        elif field.type == FieldType.DATETIME:
            return "datetime(2024, 1, 15, 12, 0, 0)"
        elif field.type == FieldType.DATE:
            return "date(2024, 1, 15)"
        elif field.type == FieldType.TIME:
            return "time(12, 0, 0)"
        elif field.type == FieldType.UUID:
            return "uuid4()"
        elif field.type == FieldType.ENUM and field.enum_values:
            return f'"{field.enum_values[0]}"'
        elif field.type == FieldType.FOREIGN_KEY:
            return "1"
        elif field.type == FieldType.JSON:
            # If the field has json_item_type, it's a typed array
            if field.json_item_type:
                item_type = field.json_item_type.lower()
                if item_type in ("int", "integer"):
                    return "[34, 139, 34]"
                elif item_type in ("float", "number"):
                    return "[1.5, 2.7, 3.14]"
                elif item_type in ("str", "string"):
                    return '["item1", "item2", "item3"]'
                elif item_type in ("bool", "boolean"):
                    return "[True, False, True]"
                else:
                    return '["item1", "item2"]'
            return '{"key": "value"}'
        return '"test"'

    def _generate_api_tests(self, model: ModelSpec) -> GeneratedFile:
        """Generate API integration tests."""
        snake_name = to_snake_case(model.name)
        kebab_name = pluralize(snake_name).replace("_", "-")
        content = f'''"""API integration tests for {model.name}.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

import pytest
import pytest_asyncio

from tests.factories.{snake_name} import {model.name}Factory


class Test{model.name}API:
    """API integration tests for {model.name} endpoints."""
'''

        # List test
        if model.has_operation("list"):
            content += f'''
    @pytest.mark.asyncio
    async def test_list_{snake_name}s(self, client, db):
        """Test GET /{kebab_name}"""
        # Create test data
        {model.name}Factory._meta.sqlalchemy_session = db
        for _ in range(3):
            {model.name}Factory.create()
        await db.commit()

        response = await client.get("/api/{kebab_name}")

        assert response.status_code == 200
        data = response.json()
        assert "items" in data
        assert len(data["items"]) >= 3
'''

        # Get test
        if model.has_operation("read"):
            content += f'''
    @pytest.mark.asyncio
    async def test_get_{snake_name}(self, client, db):
        """Test GET /{kebab_name}/{{id}}"""
        {model.name}Factory._meta.sqlalchemy_session = db
        instance = {model.name}Factory.create()
        await db.commit()

        response = await client.get(f"/api/{kebab_name}/{{instance.id}}")

        assert response.status_code == 200
        data = response.json()
        assert data["id"] == instance.id

    @pytest.mark.asyncio
    async def test_get_{snake_name}_not_found(self, client):
        """Test GET /{kebab_name}/{{id}} with invalid ID"""
        response = await client.get("/api/{kebab_name}/99999")

        assert response.status_code == 404
'''

        # Create test
        if model.has_operation("create"):
            content += f'''
    @pytest.mark.asyncio
    async def test_create_{snake_name}(self, client):
        """Test POST /{kebab_name}"""
        payload = {{
{self._build_api_test_payload(model)}
        }}

        response = await client.post("/api/{kebab_name}", json=payload)

        assert response.status_code == 201
        data = response.json()
        assert "id" in data
'''

        # Update test
        if model.has_operation("update"):
            content += f'''
    @pytest.mark.asyncio
    async def test_update_{snake_name}(self, client, db):
        """Test PATCH /{kebab_name}/{{id}}"""
        {model.name}Factory._meta.sqlalchemy_session = db
        instance = {model.name}Factory.create()
        await db.commit()

        payload = {{
{self._build_update_api_payload(model)}
        }}

        response = await client.patch(f"/api/{kebab_name}/{{instance.id}}", json=payload)

        assert response.status_code == 200
'''

        # Delete test - only if delete operation is enabled
        if model.has_operation("delete"):
            content += f'''
    @pytest.mark.asyncio
    async def test_delete_{snake_name}(self, client, db):
        """Test DELETE /{kebab_name}/{{id}}"""
        {model.name}Factory._meta.sqlalchemy_session = db
        instance = {model.name}Factory.create()
        await db.commit()

        response = await client.delete(f"/api/{kebab_name}/{{instance.id}}")

        assert response.status_code == 204
'''

        return GeneratedFile(
            path=self.tests_path / "integration" / f"test_{snake_name}_api.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description=f"API tests for {model.name}",
        )

    def _build_api_test_payload(self, model: ModelSpec) -> str:
        """Build JSON payload for API test."""
        lines = []
        for field in model.fields:
            if field.required and not field.default:
                # Use unique suffix for fields that might have unique constraints
                suffix = "_api" if field.unique or "email" in field.name.lower() else ""
                value = self._get_json_test_value(field, suffix)
                lines.append(f'            "{field.name}": {value},')
        return "\n".join(lines)

    def _build_update_api_payload(self, model: ModelSpec) -> str:
        """Build update payload for API test."""
        # Skip unique fields to avoid constraint violations
        for field in model.fields:
            if field.unique or "email" in field.name.lower():
                continue
            value = self._get_json_test_value(field, "_updated")
            return f'            "{field.name}": {value},'
        # If all fields are unique, update first with unique suffix
        for field in model.fields:
            value = self._get_json_test_value(field, "_api_updated")
            return f'            "{field.name}": {value},'
        return '            "id": 1,'

    def _get_json_test_value(self, field: FieldSpec, unique_suffix: str = "") -> str:
        """Get a JSON-compatible test value for a field (for API payloads)."""
        if field.type == FieldType.STRING:
            # Handle special string field patterns based on name or pattern
            name_lower = field.name.lower()

            # Check for IP address fields
            if (
                ("ip" in name_lower and "address" in name_lower)
                or name_lower == "ip"
                or name_lower.endswith("_ip")
            ):
                return '"192.168.1.1"'
            # Check for URL pattern or name
            elif (
                "url" in name_lower
                or "link" in name_lower
                or "website" in name_lower
                or (field.pattern and ("http" in field.pattern or "url" in field.pattern.lower()))
            ):
                return f'"https://example{unique_suffix}.com"'
            elif "email" in name_lower:
                return f'"test{unique_suffix}@example.com"'
            elif "phone" in name_lower:
                return '"+1234567890"'
            elif "ticker" in name_lower or "symbol" in name_lower:
                return f'"TEST{unique_suffix}"'
            elif "isin" in name_lower:
                # Use unique suffix for ISIN to avoid constraint violations
                # ISIN format: 12 characters (2 country + 9 NSIN + 1 check)
                suffix_char = unique_suffix.replace("_", "")[:1].upper() if unique_suffix else "0"
                return f'"US0000000{suffix_char}00"'
            elif "cusip" in name_lower:
                return '"000000000"'
            elif "currency" in name_lower:
                return '"USD"'
            elif "country" in name_lower:
                return '"US"'

            # For fields with patterns that restrict to alphanumeric, avoid underscores
            if field.pattern and "a-z" in field.pattern and "0-9" in field.pattern:
                suffix = unique_suffix.replace("_", "")
                base_value = f"testval{suffix}"
            else:
                base_value = f"test_value{unique_suffix}"
            # Respect min_length constraint
            if field.min_length and len(base_value) < field.min_length:
                pad = "a" if field.pattern and "_" not in field.pattern else "_"
                base_value = base_value + pad * (field.min_length - len(base_value))
            return f'"{base_value}"'
        elif field.type == FieldType.TEXT:
            return '"Test text content"'
        elif field.type == FieldType.INTEGER:
            # Respect min/max value constraints
            if field.min_value is not None or field.max_value is not None:
                min_val = int(field.min_value) if field.min_value is not None else 0
                max_val = int(field.max_value) if field.max_value is not None else 1000
                # Pick a value in the middle of the range
                test_val = (min_val + max_val) // 2
                return str(test_val)
            return "42"
        elif field.type in (FieldType.FLOAT, FieldType.DECIMAL):
            return "3.14"
        elif field.type == FieldType.BOOLEAN:
            return "True"
        elif field.type == FieldType.DATETIME:
            return '"2024-01-15T12:00:00"'
        elif field.type == FieldType.DATE:
            return '"2024-01-15"'
        elif field.type == FieldType.TIME:
            return '"12:00:00"'
        elif field.type == FieldType.UUID:
            return '"550e8400-e29b-41d4-a716-446655440000"'
        elif field.type == FieldType.ENUM and field.enum_values:
            return f'"{field.enum_values[0]}"'
        elif field.type == FieldType.FOREIGN_KEY:
            return "1"
        elif field.type == FieldType.JSON:
            # If the field has json_item_type, it's a typed array
            if field.json_item_type:
                item_type = field.json_item_type.lower()
                if item_type in ("int", "integer"):
                    return "[34, 139, 34]"
                elif item_type in ("float", "number"):
                    return "[1.5, 2.7, 3.14]"
                elif item_type in ("str", "string"):
                    return '["item1", "item2", "item3"]'
                elif item_type in ("bool", "boolean"):
                    return "[true, false, true]"
                else:
                    return '["item1", "item2"]'
            return '{"key": "value"}'
        return '"test"'

    # ── Auth test generation ───────────────────────────────────────

    def _generate_auth_tests(self) -> list[GeneratedFile]:
        """Generate all auth test files when JWT auth is enabled."""
        files = [
            self._generate_auth_utils_tests(),
            self._generate_auth_dependencies_tests(),
            self._generate_auth_api_tests(),
        ]
        return files

    def _generate_auth_utils_tests(self) -> GeneratedFile:
        """Generate unit tests for auth/utils.py."""
        project_name = self.get_package_name()
        auth = self.auth_config

        mfa_tests = ""
        if auth.mfa_enabled:
            mfa_tests = """

class TestTOTP:
    def test_generate_totp_secret(self):
        secret = generate_totp_secret()
        assert isinstance(secret, str)
        assert len(secret) >= 16  # base32 encoded

    def test_get_totp_uri(self):
        secret = generate_totp_secret()
        uri = get_totp_uri(secret, "user@example.com")
        assert uri.startswith("otpauth://totp/")
        assert "user" in uri and "example.com" in uri

    def test_verify_totp_valid(self):
        secret = generate_totp_secret()
        totp = pyotp.TOTP(secret)
        code = totp.now()
        assert verify_totp(secret, code) is True

    def test_verify_totp_invalid(self):
        secret = generate_totp_secret()
        assert verify_totp(secret, "000000") is False
"""

        mfa_imports = ""
        mfa_util_imports = ""
        if auth.mfa_enabled:
            mfa_imports = "import pyotp\n"
            mfa_util_imports = ",\n    generate_totp_secret,\n    get_totp_uri,\n    verify_totp"

        content = f'''"""Unit tests for auth/utils.py.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

{mfa_imports}from {project_name}.auth.utils import (
    generate_token,
    hash_password,
    validate_password_strength,
    verify_password{mfa_util_imports},
)


class TestPasswordHashing:
    def test_hash_and_verify_password(self):
        hashed = hash_password("SecurePass1")
        assert verify_password("SecurePass1", hashed)

    def test_verify_password_wrong(self):
        hashed = hash_password("SecurePass1")
        assert not verify_password("WrongPassword1", hashed)

    def test_hash_is_different_each_time(self):
        h1 = hash_password("SecurePass1")
        h2 = hash_password("SecurePass1")
        assert h1 != h2  # bcrypt uses random salt


class TestPasswordStrength:
    def test_too_short(self):
        assert validate_password_strength("Ab1") is not None
        assert "8 characters" in validate_password_strength("Ab1")

    def test_no_uppercase(self):
        result = validate_password_strength("abcdefg1")
        assert result is not None
        assert "uppercase" in result

    def test_no_lowercase(self):
        result = validate_password_strength("ABCDEFG1")
        assert result is not None
        assert "lowercase" in result

    def test_no_digit(self):
        result = validate_password_strength("Abcdefgh")
        assert result is not None
        assert "digit" in result

    def test_valid(self):
        assert validate_password_strength("Abcdefg1") is None


class TestTokenGeneration:
    def test_generate_token(self):
        token = generate_token()
        assert isinstance(token, str)
        assert len(token) > 20  # 32 bytes base64 -> ~43 chars

    def test_tokens_are_unique(self):
        assert generate_token() != generate_token()
{mfa_tests}'''

        return GeneratedFile(
            path=self.tests_path / "unit" / "test_auth_utils.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description="Auth utils unit tests",
        )

    def _generate_auth_dependencies_tests(self) -> GeneratedFile:
        """Generate unit tests for auth/dependencies.py (JWT, roles)."""
        project_name = self.get_package_name()

        content = f'''"""Unit tests for auth/dependencies.py.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

import time
from unittest.mock import MagicMock

import jwt
import pytest

from {project_name}.auth.config import auth_settings
from {project_name}.auth.dependencies import (
    create_session_jwt,
    decode_session_jwt,
)


class TestSessionJWT:
    def _make_user(self, **kwargs):
        user = MagicMock()
        user.id = kwargs.get("id", 1)
        user.email = kwargs.get("email", "test@example.com")
        user.roles = kwargs.get("roles", ["user"])
        return user

    def test_create_and_decode(self):
        user = self._make_user()
        token = create_session_jwt(user)
        claims = decode_session_jwt(token)
        assert claims["sub"] == "1"
        assert claims["email"] == "test@example.com"
        assert claims["roles"] == ["user"]
        assert "exp" in claims
        assert "iat" in claims

    def test_decode_expired(self):
        payload = {{
            "sub": "1",
            "email": "test@example.com",
            "roles": [],
            "iat": time.time() - 7200,
            "exp": time.time() - 3600,
        }}
        token = jwt.encode(payload, auth_settings.jwt_secret, algorithm="HS256")
        with pytest.raises(jwt.ExpiredSignatureError):
            decode_session_jwt(token)

    def test_decode_invalid(self):
        with pytest.raises(jwt.InvalidTokenError):
            decode_session_jwt("not-a-valid-token")

    def test_decode_wrong_secret(self):
        payload = {{
            "sub": "1",
            "email": "test@example.com",
            "roles": [],
            "iat": time.time(),
            "exp": time.time() + 3600,
        }}
        token = jwt.encode(payload, "wrong-secret", algorithm="HS256")
        with pytest.raises(jwt.InvalidSignatureError):
            decode_session_jwt(token)


class TestRequireRoles:
    def test_role_check_logic(self):
        required = {{"admin"}}
        user_roles = {{"user"}}
        assert not any(role in user_roles for role in required)

        user_roles = {{"admin", "user"}}
        assert any(role in user_roles for role in required)
'''

        return GeneratedFile(
            path=self.tests_path / "unit" / "test_auth_dependencies.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description="Auth dependencies unit tests",
        )

    def _generate_auth_api_tests(self) -> GeneratedFile:
        """Generate integration tests for auth REST API endpoints."""
        project_name = self.get_package_name()
        auth = self.auth_config

        # Build conditional test sections based on feature flags
        signup_tests = ""
        if auth.allow_signup:
            signup_tests = f'''

@pytest.mark.asyncio
class TestSignup:
    @patch("{project_name}.api.rest.auth._validate_email_domain", return_value=None)
    @patch("{project_name}.api.rest.auth.send_verification_email")
    async def test_signup_success(self, mock_email, mock_domain, unauthenticated_client, db):
        resp = await unauthenticated_client.post(
            "/api/auth/signup",
            json={{"email": "new@example.com", "username": "newuser", "password": "StrongPass1"}},
        )
        assert resp.status_code == 200
        data = resp.json()
        assert "message" in data
        mock_email.assert_called_once()

    @patch("{project_name}.api.rest.auth._validate_email_domain", return_value=None)
    @patch("{project_name}.api.rest.auth.send_verification_email")
    async def test_signup_duplicate_email(
        self, mock_email, mock_domain, unauthenticated_client, db
    ):
        await _create_verified_user(db, email="dup@example.com")
        resp = await unauthenticated_client.post(
            "/api/auth/signup",
            json={{"email": "dup@example.com", "username": "dup", "password": "StrongPass1"}},
        )
        assert resp.status_code == 409

    async def test_signup_weak_password(self, unauthenticated_client, db):
        resp = await unauthenticated_client.post(
            "/api/auth/signup",
            json={{"email": "weak@example.com", "username": "weak", "password": "short"}},
        )
        assert resp.status_code == 400
'''

        email_verification_tests = ""
        if auth.email_verification:
            email_verification_tests = f'''

@pytest.mark.asyncio
class TestEmailVerification:
    async def test_verify_email_success(self, unauthenticated_client, db):
        user = await _create_unverified_user(db, email="verify@example.com")
        token = user.email_verification_token
        resp = await unauthenticated_client.post("/api/auth/verify-email", json={{"token": token}})
        assert resp.status_code == 200
        data = resp.json()
        assert data["message"] == "Email verified"
        assert "user" in data

    async def test_verify_email_invalid_token(self, unauthenticated_client, db):
        resp = await unauthenticated_client.post(
            "/api/auth/verify-email", json={{"token": "bad-token"}}
        )
        assert resp.status_code == 400

    async def test_verify_email_expired_token(self, unauthenticated_client, db):
        user = await _create_unverified_user(db, email="expired@example.com")
        user.email_verification_token_expires_at = datetime.now(UTC) - timedelta(hours=1)
        await db.commit()

        resp = await unauthenticated_client.post(
            "/api/auth/verify-email",
            json={{"token": user.email_verification_token}},
        )
        assert resp.status_code == 400

    @patch("{project_name}.api.rest.auth.send_verification_email")
    async def test_resend_verification(self, mock_email, unauthenticated_client, db):
        await _create_unverified_user(db, email="resend@example.com")
        resp = await unauthenticated_client.post(
            "/api/auth/resend-verification", json={{"email": "resend@example.com"}}
        )
        assert resp.status_code == 200
        # Always 200 even for nonexistent
        resp2 = await unauthenticated_client.post(
            "/api/auth/resend-verification", json={{"email": "nobody@example.com"}}
        )
        assert resp2.status_code == 200
'''

        # Login tests - always present for JWT auth
        lockout_test = ""
        if auth.account_lockout:
            lockout_test = f"""
    @pytest.mark.xfail(
        reason="SQLite strips timezone info causing naive/aware datetime comparison error"
    )
    async def test_login_account_lockout(self, unauthenticated_client, db):
        await _create_verified_user(db, email="locked@example.com")
        for _ in range({auth.max_failed_attempts}):
            await unauthenticated_client.post(
                "/api/auth/login",
                json={{"email": "locked@example.com", "password": "WrongPassword1"}},
            )
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={{"email": "locked@example.com", "password": "StrongPass1"}},
        )
        assert resp.status_code == 423

    async def test_login_lockout_expires(self, unauthenticated_client, db):
        user = await _create_verified_user(db, email="lockexp@example.com")
        user.failed_login_attempts = {auth.max_failed_attempts}
        user.locked_until = datetime.now(UTC) - timedelta(minutes=1)
        await db.commit()
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={{"email": "lockexp@example.com", "password": "StrongPass1"}},
        )
        assert resp.status_code == 200
"""

        mfa_login_test = ""
        if auth.mfa_enabled:
            mfa_login_test = """
    async def test_login_mfa_required(self, unauthenticated_client, db):
        user = await _create_verified_user(db, email="mfauser@example.com")
        user.mfa_enabled = True
        user.mfa_secret = generate_totp_secret()
        await db.commit()
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={"email": "mfauser@example.com", "password": "StrongPass1"},
        )
        assert resp.status_code == 200
        data = resp.json()
        assert data["requires_mfa"] is True
        assert data["user"] is None
        assert "prisme_api_session" not in resp.cookies
"""

        unverified_login_test = ""
        if auth.email_verification:
            unverified_login_test = """
    async def test_login_unverified_email(self, unauthenticated_client, db):
        await _create_unverified_user(db, email="unver_login@example.com", password="StrongPass1")
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={"email": "unver_login@example.com", "password": "StrongPass1"},
        )
        assert resp.status_code == 403
"""

        login_tests = f"""

@pytest.mark.asyncio
class TestLogin:
    async def test_login_success(self, unauthenticated_client, db):
        await _create_verified_user(db, email="login@example.com", password="StrongPass1")
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={{"email": "login@example.com", "password": "StrongPass1"}},
        )
        assert resp.status_code == 200
        data = resp.json()
        assert data["user"] is not None

    async def test_login_wrong_password(self, unauthenticated_client, db):
        await _create_verified_user(db, email="wrongpw@example.com")
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={{"email": "wrongpw@example.com", "password": "WrongPassword1"}},
        )
        assert resp.status_code == 401
{unverified_login_test}
    async def test_login_inactive_user(self, unauthenticated_client, db):
        user = await _create_verified_user(db, email="inactive@example.com")
        user.is_active = False
        await db.commit()
        resp = await unauthenticated_client.post(
            "/api/auth/login",
            json={{"email": "inactive@example.com", "password": "StrongPass1"}},
        )
        assert resp.status_code == 403
{lockout_test}{mfa_login_test}"""

        # MFA Login tests
        mfa_login_tests = ""
        if auth.mfa_enabled:
            mfa_login_tests = """

@pytest.mark.asyncio
class TestMFALogin:
    async def test_login_mfa_success(self, unauthenticated_client, db):
        secret = generate_totp_secret()
        user = await _create_verified_user(db, email="mfalogin@example.com")
        user.mfa_enabled = True
        user.mfa_secret = secret
        await db.commit()

        code = pyotp.TOTP(secret).now()
        resp = await unauthenticated_client.post(
            "/api/auth/login/mfa",
            json={"email": "mfalogin@example.com", "code": code},
        )
        assert resp.status_code == 200

    async def test_login_mfa_invalid_code(self, unauthenticated_client, db):
        secret = generate_totp_secret()
        user = await _create_verified_user(db, email="mfabad@example.com")
        user.mfa_enabled = True
        user.mfa_secret = secret
        await db.commit()

        resp = await unauthenticated_client.post(
            "/api/auth/login/mfa",
            json={"email": "mfabad@example.com", "code": "000000"},
        )
        assert resp.status_code == 401
"""

        # Password reset tests
        password_reset_tests = ""
        if auth.password_reset:
            password_reset_tests = f'''

@pytest.mark.asyncio
class TestPasswordReset:
    @patch("{project_name}.api.rest.auth.send_password_reset_email")
    async def test_forgot_password(self, mock_email, unauthenticated_client, db):
        await _create_verified_user(db, email="forgot@example.com")
        resp = await unauthenticated_client.post(
            "/api/auth/forgot-password", json={{"email": "forgot@example.com"}}
        )
        assert resp.status_code == 200
        # Always 200 for non-existent too
        resp2 = await unauthenticated_client.post(
            "/api/auth/forgot-password", json={{"email": "nobody@example.com"}}
        )
        assert resp2.status_code == 200

    @patch("{project_name}.api.rest.auth.send_password_changed_notification")
    async def test_reset_password_success(self, mock_email, unauthenticated_client, db):
        user = await _create_verified_user(db, email="reset@example.com")
        token = generate_token()
        user.password_reset_token = token
        user.password_reset_token_expires_at = datetime.now(UTC) + timedelta(hours=1)
        await db.commit()

        resp = await unauthenticated_client.post(
            "/api/auth/reset-password",
            json={{"token": token, "password": "NewStrong1"}},
        )
        assert resp.status_code == 200

    async def test_reset_password_invalid_token(self, unauthenticated_client, db):
        resp = await unauthenticated_client.post(
            "/api/auth/reset-password",
            json={{"token": "bad-token", "password": "NewStrong1"}},
        )
        assert resp.status_code == 400

    @patch("{project_name}.api.rest.auth.send_password_changed_notification")
    async def test_reset_password_expired_token(self, mock_email, unauthenticated_client, db):
        user = await _create_verified_user(db, email="resetexp@example.com")
        token = generate_token()
        user.password_reset_token = token
        user.password_reset_token_expires_at = datetime.now(UTC) - timedelta(hours=1)
        await db.commit()

        resp = await unauthenticated_client.post(
            "/api/auth/reset-password",
            json={{"token": token, "password": "NewStrong1"}},
        )
        assert resp.status_code == 400

    async def test_reset_password_weak_password(self, unauthenticated_client, db):
        user = await _create_verified_user(db, email="resetweak@example.com")
        token = generate_token()
        user.password_reset_token = token
        user.password_reset_token_expires_at = datetime.now(UTC) + timedelta(hours=1)
        await db.commit()

        resp = await unauthenticated_client.post(
            "/api/auth/reset-password",
            json={{"token": token, "password": "weak"}},
        )
        assert resp.status_code == 400
'''

        # MFA setup tests
        mfa_setup_tests = ""
        if auth.mfa_enabled:
            mfa_setup_tests = """

@pytest.mark.asyncio
class TestMFASetup:
    async def test_mfa_setup(self, authenticated_client, db):
        resp = await authenticated_client.post("/api/auth/mfa/setup")
        assert resp.status_code == 200
        data = resp.json()
        assert "totp_uri" in data
        assert "secret" in data
        assert data["totp_uri"].startswith("otpauth://")

    async def test_mfa_verify_setup(self, authenticated_client, db):
        setup_resp = await authenticated_client.post("/api/auth/mfa/setup")
        secret = setup_resp.json()["secret"]

        code = pyotp.TOTP(secret).now()
        resp = await authenticated_client.post("/api/auth/mfa/verify-setup", json={"code": code})
        assert resp.status_code == 200

    async def test_mfa_verify_setup_invalid_code(self, authenticated_client, db):
        await authenticated_client.post("/api/auth/mfa/setup")
        resp = await authenticated_client.post(
            "/api/auth/mfa/verify-setup", json={"code": "000000"}
        )
        assert resp.status_code == 400

    async def test_mfa_disable(self, authenticated_client, db):
        resp = await authenticated_client.post(
            "/api/auth/mfa/disable", json={"password": "StrongPass1"}
        )
        assert resp.status_code == 200

    async def test_mfa_disable_wrong_password(self, authenticated_client, db):
        resp = await authenticated_client.post("/api/auth/mfa/disable", json={"password": "wrong"})
        assert resp.status_code == 401
"""

        # Session tests
        session_tests = """

@pytest.mark.asyncio
class TestSession:
    async def test_auth_me(self, authenticated_client, db):
        resp = await authenticated_client.get("/api/auth/me")
        assert resp.status_code == 200
        data = resp.json()
        assert "email" in data
        assert "roles" in data

    async def test_auth_me_unauthenticated(self, unauthenticated_client, db):
        resp = await unauthenticated_client.get("/api/auth/me")
        assert resp.status_code == 401

    async def test_logout(self, unauthenticated_client, db):
        resp = await unauthenticated_client.post("/api/auth/logout")
        assert resp.status_code == 200
        assert resp.json()["message"] == "Logged out successfully"
"""

        # Build imports
        needs_pyotp = auth.mfa_enabled
        needs_datetime = auth.account_lockout or auth.email_verification or auth.password_reset
        needs_patch = auth.allow_signup or auth.email_verification or auth.password_reset

        imports = '''"""Integration tests for auth REST API endpoints.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

'''
        if needs_datetime:
            imports += "from datetime import UTC, datetime, timedelta\n"
        if needs_patch:
            imports += "from unittest.mock import patch\n"
        imports += "\n"
        if needs_pyotp:
            imports += "import pyotp\n"
        imports += "import pytest\n"
        if needs_pyotp or needs_datetime:
            imports += "import pytest_asyncio\n"
        imports += f"\nfrom {project_name}.auth.utils import generate_token, hash_password"
        if auth.mfa_enabled:
            imports += ", generate_totp_secret"
        imports += f"\nfrom {project_name}.models.user import User\n"

        # Helpers
        helpers = '''

# ── Helpers ──────────────────────────────────────────────────────


async def _create_verified_user(db, email="user@example.com", password="StrongPass1") -> User:
    """Create a verified, active user in the database."""
    user = User(
        email=email,
        username=email.split("@")[0],
        password_hash=hash_password(password),
        email_verified=True,
        is_active=True,
        roles=["user"],
        failed_login_attempts=0,
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user

'''
        if auth.email_verification:
            helpers += """
async def _create_unverified_user(
    db, email="unverified@example.com", password="StrongPass1", *, expired: bool = False
) -> User:
    token = generate_token()
    user = User(
        email=email,
        username=email.split("@")[0],
        password_hash=hash_password(password),
        email_verified=False,
        email_verification_token=token,
        email_verification_token_expires_at=None,
        is_active=True,
        roles=["user"],
        failed_login_attempts=0,
    )
    db.add(user)
    await db.commit()
    await db.refresh(user)
    return user

"""

        content = (
            imports
            + helpers
            + signup_tests
            + email_verification_tests
            + login_tests
            + mfa_login_tests
            + password_reset_tests
            + mfa_setup_tests
            + session_tests
        )

        return GeneratedFile(
            path=self.tests_path / "integration" / "test_auth_api.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description="Auth API integration tests",
        )

    def _generate_graphql_tests(self, model: ModelSpec) -> GeneratedFile:
        """Generate GraphQL query tests.

        Uses flat query structure where model queries are directly on root Query type.
        """
        snake_name = to_snake_case(model.name)
        plural_snake = pluralize(snake_name)
        # camelCase names for GraphQL - must match GraphQL generator exactly
        # GraphQL generator uses: camel_plural = to_camel_case(pluralize(snake_name))
        camel_name = to_camel_case(model.name)
        camel_plural = to_camel_case(plural_snake)

        content = f'''"""GraphQL tests for {model.name}.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""

from __future__ import annotations

import pytest
import pytest_asyncio

from tests.factories.{snake_name} import {model.name}Factory


class Test{model.name}GraphQL:
    """GraphQL tests for {model.name} queries and mutations."""

    @pytest.mark.asyncio
    async def test_query_{snake_name}(self, client, db):
        """Test {camel_name} query."""
        {model.name}Factory._meta.sqlalchemy_session = db
        instance = {model.name}Factory.create()
        await db.commit()

        query = """
            query Get{model.name}($id: Int!) {{
                {camel_name}(id: $id) {{
                    id
                }}
            }}
        """

        response = await client.post(
            "/graphql",
            json={{"query": query, "variables": {{"id": instance.id}}}},
        )

        assert response.status_code == 200
        data = response.json()
        assert "data" in data
        assert data["data"]["{camel_name}"] is not None, f"Query returned None. Errors: {{data.get('errors')}}"
        assert data["data"]["{camel_name}"]["id"] == instance.id

    @pytest.mark.asyncio
    async def test_query_{snake_name}s_list(self, client, db):
        """Test {camel_plural} list query."""
        {model.name}Factory._meta.sqlalchemy_session = db
        for _ in range(3):
            {model.name}Factory.create()
        await db.commit()

        query = """
            query List{model.name}s {{
                {camel_plural} {{
                    edges {{
                        node {{
                            id
                        }}
                    }}
                    totalCount
                }}
            }}
        """

        response = await client.post("/graphql", json={{"query": query}})

        assert response.status_code == 200
        data = response.json()
        assert "data" in data
        assert data["data"]["{camel_plural}"]["totalCount"] >= 3
'''

        return GeneratedFile(
            path=self.tests_path / "graphql" / f"test_{snake_name}.py",
            content=content,
            strategy=FileStrategy.ALWAYS_OVERWRITE,
            description=f"GraphQL tests for {model.name}",
        )


__all__ = ["BackendTestGenerator"]
