"""GraphQL pagination types.

⚠️ AUTO-GENERATED BY PRISM - DO NOT EDIT
"""


from enum import Enum
from typing import Generic, TypeVar

import strawberry


T = TypeVar("T")


@strawberry.type
class PageInfo:
    """Pagination information."""

    has_next_page: bool
    has_previous_page: bool
    start_cursor: str | None = None
    end_cursor: str | None = None


@strawberry.type
class Edge(Generic[T]):
    """Edge in a connection."""

    node: T
    cursor: str


@strawberry.type
class Connection(Generic[T]):
    """Relay-style connection for pagination."""

    edges: list[Edge[T]]
    page_info: PageInfo
    total_count: int


@strawberry.input
class PaginationInput:
    """Pagination input parameters."""

    first: int | None = 20
    after: str | None = None
    last: int | None = None
    before: str | None = None


@strawberry.input
class OffsetPaginationInput:
    """Offset-based pagination input."""

    page: int = 1
    page_size: int = 20


@strawberry.enum
class SortOrder(Enum):
    """Sort order direction."""

    ASC = "asc"
    DESC = "desc"


@strawberry.input
class SortInput:
    """Sorting input."""

    field: str
    order: SortOrder = SortOrder.ASC


def paginate_results(
    items: list[T],
    total: int,
    page: int,
    page_size: int,
) -> Connection[T]:
    """Create a connection from paginated results."""
    edges = [
        Edge(node=item, cursor=str(i + (page - 1) * page_size))
        for i, item in enumerate(items)
    ]

    has_next = page * page_size < total
    has_prev = page > 1

    return Connection(
        edges=edges,
        page_info=PageInfo(
            has_next_page=has_next,
            has_previous_page=has_prev,
            start_cursor=edges[0].cursor if edges else None,
            end_cursor=edges[-1].cursor if edges else None,
        ),
        total_count=total,
    )


__all__ = [
    "Connection",
    "Edge",
    "OffsetPaginationInput",
    "PageInfo",
    "PaginationInput",
    "SortInput",
    "SortOrder",
    "paginate_results",
]
