# Writing Ideas


## MCP is Dead, Long live MCP

- Vibe Coding vs Agentic Engineering

- Agentic Engineering
  - Specification driven development
  - Automatec tests
  - Code review
  - Plus engineering experience

## A Brief History of Software Engineering

### 1940s-1950s: Machine Code & Assembly
- Programmers wrote raw binary or assembly instructions
- Programs were hardware-specific, tedious to write
- ENIAC (1945) required physical rewiring to "program"

### 1950s-1960s: High-Level Languages
- FORTRAN (1957), COBOL, LISP emerged
- Abstracted away hardware details
- Compilers translated human-readable code to machine code
- Birth of "software engineering" as a term (1968 NATO conference)

### 1970s: Structured Programming & Unix
- C language (1972) enabled portable systems programming
- Unix philosophy: small tools, composability
- Waterfall methodology dominated

### 1980s: Personal Computing & OOP
- PCs brought programming to the masses
- Object-oriented programming (Smalltalk, C++) changed design thinking
- Version control emerged (RCS, CVS)

### 1990s: The Internet Era
- World Wide Web (1991) transformed software distribution
- Java "write once, run anywhere" (1995)
- Open source movement accelerated (Linux, Apache)
- Dynamic languages (Python, PHP, JavaScript)

### 2000s: Agile & Web 2.0
- Agile Manifesto (2001) rejected waterfall rigidity
- Iterative development, continuous feedback
- Cloud computing began (AWS 2006)
- Git (2005) revolutionized collaboration

### 2007-2015: Mobile & DevOps
- iPhone (2007) created new platform paradigm
- App stores changed distribution
- DevOps merged development and operations
- Continuous integration/deployment became standard

### 2010s: Cloud-Native & Microservices
- Containerization (Docker 2013)
- Infrastructure as code
- Serverless computing

### 2020s: AI-Assisted & Agentic Engineering
- GitHub Copilot (2021) brought AI to coding
- LLMs enabled natural language programming
- Agentic Engineering (2024+): AI agents autonomously execute multi-step tasks - reading code, running tests, making commits
- Engineers shift from writing every line to directing, reviewing, and architecting

### The Pattern

Each era increased abstraction:

| Transition | Shift |
|------------|-------|
| Machine code → Assembly | symbolic names over binary |
| Assembly → High-level languages | algorithms over registers |
| Procedural → OOP | modeling over procedures |
| Waterfall → Agile | adaptive over predictive |
| Writing code → Agentic | intent over implementation |

Agentic engineering is the next abstraction layer - engineers express *what* they want, AI agents figure out *how*. The role evolves from typist to architect/reviewer, much like how compilers freed us from thinking in opcodes.

## Engineering is changing

- Engineers
  - Capability - technical skills
  - Clarity - ability to deliver value

## Onetool

- Problems
  - Context Rot
  - Context Costs
  - Extra Calls

- Stop Context Rot, Costs and extra calls
- Explicit Calls
- Config
  - Tools
  - Secrets management
  - Prompts tweaks
- Code Centric
  - Easy to extend
  - Batteries included ... almost 100 tools


Chart
- Tools vs Context vs Max context
  

References
  - 