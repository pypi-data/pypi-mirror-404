# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.log_level import LogLevel
from ..types.log_list_response import LogListResponse
from ..types.log_source import LogSource
from ..types.log_stream_event import LogStreamEvent
from ..types.otlp_log_ingestion_response import OtlpLogIngestionResponse
from ..types.otlp_resource_logs import OtlpResourceLogs
from .raw_client import AsyncRawLogsClient, RawLogsClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class LogsClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawLogsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawLogsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawLogsClient
        """
        return self._raw_client

    def list(
        self,
        *,
        agent_name: str,
        branch_id: typing.Optional[str] = None,
        task_id: typing.Optional[str] = None,
        trace_id: typing.Optional[str] = None,
        level: typing.Optional[LogLevel] = None,
        source: typing.Optional[LogSource] = None,
        since: typing.Optional[dt.datetime] = None,
        until: typing.Optional[dt.datetime] = None,
        search: typing.Optional[str] = None,
        after_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LogListResponse:
        """
        Query logs for an agent. Requires user authentication.

        Parameters
        ----------
        agent_name : str
            Name of the agent (format: namespace/name or agent ID)

        branch_id : typing.Optional[str]
            Filter by branch/deployment ID

        task_id : typing.Optional[str]
            Filter by task ID

        trace_id : typing.Optional[str]
            Filter by OTEL trace ID (32 lowercase hex chars)

        level : typing.Optional[LogLevel]
            Filter by log level

        source : typing.Optional[LogSource]
            Filter by source (stdout, stderr, server)

        since : typing.Optional[dt.datetime]
            Start timestamp filter (ISO 8601)

        until : typing.Optional[dt.datetime]
            End timestamp filter (ISO 8601)

        search : typing.Optional[str]
            Full-text search in message (case-insensitive)

        after_id : typing.Optional[str]
            Return logs after this log_id (cursor-based pagination)

        limit : typing.Optional[int]
            Maximum number of results

        offset : typing.Optional[int]
            Number of results to skip

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LogListResponse
            Successful Response

        Examples
        --------
        from terminaluse import TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.logs.list(
            agent_name="agent_name",
        )
        """
        _response = self._raw_client.list(
            agent_name=agent_name,
            branch_id=branch_id,
            task_id=task_id,
            trace_id=trace_id,
            level=level,
            source=source,
            since=since,
            until=until,
            search=search,
            after_id=after_id,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    def ingest_otlp(
        self,
        *,
        resource_logs: typing.Sequence[OtlpResourceLogs],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> OtlpLogIngestionResponse:
        """
        Ingest OpenTelemetry logs from an agent. Requires agent API key authentication.

        Parameters
        ----------
        resource_logs : typing.Sequence[OtlpResourceLogs]
            Array of ResourceLogs per OTLP spec

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        OtlpLogIngestionResponse
            Successful Response

        Examples
        --------
        from terminaluse import OtlpResourceLogs, TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.logs.ingest_otlp(
            resource_logs=[OtlpResourceLogs()],
        )
        """
        _response = self._raw_client.ingest_otlp(resource_logs=resource_logs, request_options=request_options)
        return _response.data

    def stream(
        self,
        *,
        agent_name: str,
        task_id: typing.Optional[str] = None,
        level: typing.Optional[LogLevel] = None,
        source: typing.Optional[LogSource] = None,
        branch_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[LogStreamEvent]:
        """
        Stream logs for an agent in real-time using Server-Sent Events (SSE). Emits multiple event types (connected, log, error) discriminated by 'type' field. Only streams NEW logs after connection (like tail -f). Auto-disconnects after 5 minutes for cost control.

        Parameters
        ----------
        agent_name : str
            Name of the agent (format: namespace/name or agent ID)

        task_id : typing.Optional[str]
            Filter by task ID

        level : typing.Optional[LogLevel]
            Minimum log level

        source : typing.Optional[LogSource]
            Filter by source (stdout, stderr, server)

        branch_id : typing.Optional[str]
            Filter by branch/version ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[LogStreamEvent]
            SSE stream of log events

        Examples
        --------
        from terminaluse import TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        response = client.logs.stream(
            agent_name="agent_name",
        )
        for chunk in response:
            yield chunk
        """
        with self._raw_client.stream(
            agent_name=agent_name,
            task_id=task_id,
            level=level,
            source=source,
            branch_id=branch_id,
            request_options=request_options,
        ) as r:
            yield from r.data


class AsyncLogsClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawLogsClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawLogsClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawLogsClient
        """
        return self._raw_client

    async def list(
        self,
        *,
        agent_name: str,
        branch_id: typing.Optional[str] = None,
        task_id: typing.Optional[str] = None,
        trace_id: typing.Optional[str] = None,
        level: typing.Optional[LogLevel] = None,
        source: typing.Optional[LogSource] = None,
        since: typing.Optional[dt.datetime] = None,
        until: typing.Optional[dt.datetime] = None,
        search: typing.Optional[str] = None,
        after_id: typing.Optional[str] = None,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> LogListResponse:
        """
        Query logs for an agent. Requires user authentication.

        Parameters
        ----------
        agent_name : str
            Name of the agent (format: namespace/name or agent ID)

        branch_id : typing.Optional[str]
            Filter by branch/deployment ID

        task_id : typing.Optional[str]
            Filter by task ID

        trace_id : typing.Optional[str]
            Filter by OTEL trace ID (32 lowercase hex chars)

        level : typing.Optional[LogLevel]
            Filter by log level

        source : typing.Optional[LogSource]
            Filter by source (stdout, stderr, server)

        since : typing.Optional[dt.datetime]
            Start timestamp filter (ISO 8601)

        until : typing.Optional[dt.datetime]
            End timestamp filter (ISO 8601)

        search : typing.Optional[str]
            Full-text search in message (case-insensitive)

        after_id : typing.Optional[str]
            Return logs after this log_id (cursor-based pagination)

        limit : typing.Optional[int]
            Maximum number of results

        offset : typing.Optional[int]
            Number of results to skip

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        LogListResponse
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.logs.list(
                agent_name="agent_name",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list(
            agent_name=agent_name,
            branch_id=branch_id,
            task_id=task_id,
            trace_id=trace_id,
            level=level,
            source=source,
            since=since,
            until=until,
            search=search,
            after_id=after_id,
            limit=limit,
            offset=offset,
            request_options=request_options,
        )
        return _response.data

    async def ingest_otlp(
        self,
        *,
        resource_logs: typing.Sequence[OtlpResourceLogs],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> OtlpLogIngestionResponse:
        """
        Ingest OpenTelemetry logs from an agent. Requires agent API key authentication.

        Parameters
        ----------
        resource_logs : typing.Sequence[OtlpResourceLogs]
            Array of ResourceLogs per OTLP spec

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        OtlpLogIngestionResponse
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi, OtlpResourceLogs

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.logs.ingest_otlp(
                resource_logs=[OtlpResourceLogs()],
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.ingest_otlp(resource_logs=resource_logs, request_options=request_options)
        return _response.data

    async def stream(
        self,
        *,
        agent_name: str,
        task_id: typing.Optional[str] = None,
        level: typing.Optional[LogLevel] = None,
        source: typing.Optional[LogSource] = None,
        branch_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[LogStreamEvent]:
        """
        Stream logs for an agent in real-time using Server-Sent Events (SSE). Emits multiple event types (connected, log, error) discriminated by 'type' field. Only streams NEW logs after connection (like tail -f). Auto-disconnects after 5 minutes for cost control.

        Parameters
        ----------
        agent_name : str
            Name of the agent (format: namespace/name or agent ID)

        task_id : typing.Optional[str]
            Filter by task ID

        level : typing.Optional[LogLevel]
            Minimum log level

        source : typing.Optional[LogSource]
            Filter by source (stdout, stderr, server)

        branch_id : typing.Optional[str]
            Filter by branch/version ID

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[LogStreamEvent]
            SSE stream of log events

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            response = await client.logs.stream(
                agent_name="agent_name",
            )
            async for chunk in response:
                yield chunk


        asyncio.run(main())
        """
        async with self._raw_client.stream(
            agent_name=agent_name,
            task_id=task_id,
            level=level,
            source=source,
            branch_id=branch_id,
            request_options=request_options,
        ) as r:
            async for _chunk in r.data:
                yield _chunk
