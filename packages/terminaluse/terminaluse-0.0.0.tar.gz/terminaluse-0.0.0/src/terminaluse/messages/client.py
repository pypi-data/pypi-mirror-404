# This file was auto-generated by Fern from our API Definition.

from __future__ import annotations

import typing

from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.paginated_messages_response import PaginatedMessagesResponse
from ..types.task_message import TaskMessage
from ..types.task_message_content import TaskMessageContent
from .raw_client import AsyncRawMessagesClient, RawMessagesClient
from .types.create_task_message_request_streaming_status import CreateTaskMessageRequestStreamingStatus
from .types.messages_list_paginated_request_direction import MessagesListPaginatedRequestDirection
from .types.update_task_message_request_streaming_status import UpdateTaskMessageRequestStreamingStatus

if typing.TYPE_CHECKING:
    from .batch.client import AsyncBatchClient, BatchClient
# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class MessagesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawMessagesClient(client_wrapper=client_wrapper)
        self._client_wrapper = client_wrapper
        self._batch: typing.Optional[BatchClient] = None

    @property
    def with_raw_response(self) -> RawMessagesClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawMessagesClient
        """
        return self._raw_client

    def list(
        self,
        *,
        task_id: str,
        limit: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        order_by: typing.Optional[str] = None,
        order_direction: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TaskMessage]:
        """
        List messages for a task with offset-based pagination.

        For cursor-based pagination with infinite scroll support, use /messages/paginated.

        Parameters
        ----------
        task_id : str
            The task ID

        limit : typing.Optional[int]

        page_number : typing.Optional[int]

        order_by : typing.Optional[str]

        order_direction : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TaskMessage]
            Successful Response

        Examples
        --------
        from terminaluse import TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.messages.list(
            task_id="task_id",
        )
        """
        _response = self._raw_client.list(
            task_id=task_id,
            limit=limit,
            page_number=page_number,
            order_by=order_by,
            order_direction=order_direction,
            request_options=request_options,
        )
        return _response.data

    def create(
        self,
        *,
        content: TaskMessageContent,
        task_id: str,
        streaming_status: typing.Optional[CreateTaskMessageRequestStreamingStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskMessage:
        """
        Parameters
        ----------
        content : TaskMessageContent

        task_id : str

        streaming_status : typing.Optional[CreateTaskMessageRequestStreamingStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        from terminaluse import TaskMessageContent_ClaudeMessage, TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.messages.create(
            content=TaskMessageContent_ClaudeMessage(
                author="user",
                message_type="message_type",
                raw_message={"key": "value"},
            ),
            task_id="task_id",
        )
        """
        _response = self._raw_client.create(
            content=content, task_id=task_id, streaming_status=streaming_status, request_options=request_options
        )
        return _response.data

    def list_paginated(
        self,
        *,
        task_id: str,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        direction: typing.Optional[MessagesListPaginatedRequestDirection] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedMessagesResponse:
        """
        List messages for a task with cursor-based pagination.

        This endpoint is designed for infinite scroll UIs where new messages may arrive
        while paginating through older ones.

        Args:
            task_id: The task ID to filter messages by
            limit: Maximum number of messages to return (default: 50)
            cursor: Opaque cursor string for pagination. Pass the `next_cursor` from
                    a previous response to get the next page.
            direction: Pagination direction - "older" to get older messages (default),
                       "newer" to get newer messages.

        Returns:
            PaginatedMessagesResponse with:
            - data: List of messages (newest first when direction="older")
            - next_cursor: Cursor for fetching the next page (null if no more pages)
            - has_more: Whether there are more messages to fetch

        Example:
            First request: GET /messages/paginated?task_id=xxx&limit=50
            Next page: GET /messages/paginated?task_id=xxx&limit=50&cursor=<next_cursor>

        Parameters
        ----------
        task_id : str
            The task ID

        limit : typing.Optional[int]

        cursor : typing.Optional[str]

        direction : typing.Optional[MessagesListPaginatedRequestDirection]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedMessagesResponse
            Successful Response

        Examples
        --------
        from terminaluse import TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.messages.list_paginated(
            task_id="task_id",
        )
        """
        _response = self._raw_client.list_paginated(
            task_id=task_id, limit=limit, cursor=cursor, direction=direction, request_options=request_options
        )
        return _response.data

    def retrieve(self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> TaskMessage:
        """
        Get a message by ID. Authorization is derived from the message's parent task.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        from terminaluse import TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.messages.retrieve(
            message_id="message_id",
        )
        """
        _response = self._raw_client.retrieve(message_id, request_options=request_options)
        return _response.data

    def update(
        self,
        message_id: str,
        *,
        content: TaskMessageContent,
        task_id: str,
        streaming_status: typing.Optional[UpdateTaskMessageRequestStreamingStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskMessage:
        """
        Parameters
        ----------
        message_id : str

        content : TaskMessageContent

        task_id : str

        streaming_status : typing.Optional[UpdateTaskMessageRequestStreamingStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        from terminaluse import TaskMessageContent_ClaudeMessage, TerminaluseApi

        client = TerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )
        client.messages.update(
            message_id="message_id",
            content=TaskMessageContent_ClaudeMessage(
                author="user",
                message_type="message_type",
                raw_message={"key": "value"},
            ),
            task_id="task_id",
        )
        """
        _response = self._raw_client.update(
            message_id,
            content=content,
            task_id=task_id,
            streaming_status=streaming_status,
            request_options=request_options,
        )
        return _response.data

    @property
    def batch(self):
        if self._batch is None:
            from .batch.client import BatchClient  # noqa: E402

            self._batch = BatchClient(client_wrapper=self._client_wrapper)
        return self._batch


class AsyncMessagesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawMessagesClient(client_wrapper=client_wrapper)
        self._client_wrapper = client_wrapper
        self._batch: typing.Optional[AsyncBatchClient] = None

    @property
    def with_raw_response(self) -> AsyncRawMessagesClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawMessagesClient
        """
        return self._raw_client

    async def list(
        self,
        *,
        task_id: str,
        limit: typing.Optional[int] = None,
        page_number: typing.Optional[int] = None,
        order_by: typing.Optional[str] = None,
        order_direction: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[TaskMessage]:
        """
        List messages for a task with offset-based pagination.

        For cursor-based pagination with infinite scroll support, use /messages/paginated.

        Parameters
        ----------
        task_id : str
            The task ID

        limit : typing.Optional[int]

        page_number : typing.Optional[int]

        order_by : typing.Optional[str]

        order_direction : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[TaskMessage]
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.messages.list(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list(
            task_id=task_id,
            limit=limit,
            page_number=page_number,
            order_by=order_by,
            order_direction=order_direction,
            request_options=request_options,
        )
        return _response.data

    async def create(
        self,
        *,
        content: TaskMessageContent,
        task_id: str,
        streaming_status: typing.Optional[CreateTaskMessageRequestStreamingStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskMessage:
        """
        Parameters
        ----------
        content : TaskMessageContent

        task_id : str

        streaming_status : typing.Optional[CreateTaskMessageRequestStreamingStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi, TaskMessageContent_ClaudeMessage

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.messages.create(
                content=TaskMessageContent_ClaudeMessage(
                    author="user",
                    message_type="message_type",
                    raw_message={"key": "value"},
                ),
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.create(
            content=content, task_id=task_id, streaming_status=streaming_status, request_options=request_options
        )
        return _response.data

    async def list_paginated(
        self,
        *,
        task_id: str,
        limit: typing.Optional[int] = None,
        cursor: typing.Optional[str] = None,
        direction: typing.Optional[MessagesListPaginatedRequestDirection] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PaginatedMessagesResponse:
        """
        List messages for a task with cursor-based pagination.

        This endpoint is designed for infinite scroll UIs where new messages may arrive
        while paginating through older ones.

        Args:
            task_id: The task ID to filter messages by
            limit: Maximum number of messages to return (default: 50)
            cursor: Opaque cursor string for pagination. Pass the `next_cursor` from
                    a previous response to get the next page.
            direction: Pagination direction - "older" to get older messages (default),
                       "newer" to get newer messages.

        Returns:
            PaginatedMessagesResponse with:
            - data: List of messages (newest first when direction="older")
            - next_cursor: Cursor for fetching the next page (null if no more pages)
            - has_more: Whether there are more messages to fetch

        Example:
            First request: GET /messages/paginated?task_id=xxx&limit=50
            Next page: GET /messages/paginated?task_id=xxx&limit=50&cursor=<next_cursor>

        Parameters
        ----------
        task_id : str
            The task ID

        limit : typing.Optional[int]

        cursor : typing.Optional[str]

        direction : typing.Optional[MessagesListPaginatedRequestDirection]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PaginatedMessagesResponse
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.messages.list_paginated(
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.list_paginated(
            task_id=task_id, limit=limit, cursor=cursor, direction=direction, request_options=request_options
        )
        return _response.data

    async def retrieve(
        self, message_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> TaskMessage:
        """
        Get a message by ID. Authorization is derived from the message's parent task.

        Parameters
        ----------
        message_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.messages.retrieve(
                message_id="message_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.retrieve(message_id, request_options=request_options)
        return _response.data

    async def update(
        self,
        message_id: str,
        *,
        content: TaskMessageContent,
        task_id: str,
        streaming_status: typing.Optional[UpdateTaskMessageRequestStreamingStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> TaskMessage:
        """
        Parameters
        ----------
        message_id : str

        content : TaskMessageContent

        task_id : str

        streaming_status : typing.Optional[UpdateTaskMessageRequestStreamingStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        TaskMessage
            Successful Response

        Examples
        --------
        import asyncio

        from terminaluse import AsyncTerminaluseApi, TaskMessageContent_ClaudeMessage

        client = AsyncTerminaluseApi(
            agent_api_key="YOUR_AGENT_API_KEY",
            token="YOUR_TOKEN",
            base_url="https://yourhost.com/path/to/api",
        )


        async def main() -> None:
            await client.messages.update(
                message_id="message_id",
                content=TaskMessageContent_ClaudeMessage(
                    author="user",
                    message_type="message_type",
                    raw_message={"key": "value"},
                ),
                task_id="task_id",
            )


        asyncio.run(main())
        """
        _response = await self._raw_client.update(
            message_id,
            content=content,
            task_id=task_id,
            streaming_status=streaming_status,
            request_options=request_options,
        )
        return _response.data

    @property
    def batch(self):
        if self._batch is None:
            from .batch.client import AsyncBatchClient  # noqa: E402

            self._batch = AsyncBatchClient(client_wrapper=self._client_wrapper)
        return self._batch
