"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authtypekafkaschemaregistry import (
    AuthTypeKafkaSchemaRegistry,
    AuthTypeKafkaSchemaRegistryTypedDict,
)
from .tlssettingsclientsidetypekafkaschemaregistry import (
    TLSSettingsClientSideTypeKafkaSchemaRegistry,
    TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict,
)
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class KafkaSchemaRegistryAuthenticationType1TypedDict(TypedDict):
    disabled: bool
    schema_registry_url: NotRequired[str]
    r"""URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http."""
    connection_timeout: NotRequired[float]
    r"""Maximum time to wait for a Schema Registry connection to complete successfully"""
    request_timeout: NotRequired[float]
    r"""Maximum time to wait for the Schema Registry to respond to a request"""
    max_retries: NotRequired[float]
    r"""Maximum number of times to try fetching schemas from the Schema Registry"""
    auth: NotRequired[AuthTypeKafkaSchemaRegistryTypedDict]
    r"""Credentials to use when authenticating with the schema registry using basic HTTP authentication"""
    tls: NotRequired[TLSSettingsClientSideTypeKafkaSchemaRegistryTypedDict]
    default_key_schema_id: NotRequired[float]
    r"""Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default."""
    default_value_schema_id: NotRequired[float]
    r"""Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default."""


class KafkaSchemaRegistryAuthenticationType1(BaseModel):
    disabled: bool

    schema_registry_url: Annotated[
        Optional[str], pydantic.Field(alias="schemaRegistryURL")
    ] = None
    r"""URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http."""

    connection_timeout: Annotated[
        Optional[float], pydantic.Field(alias="connectionTimeout")
    ] = None
    r"""Maximum time to wait for a Schema Registry connection to complete successfully"""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""Maximum time to wait for the Schema Registry to respond to a request"""

    max_retries: Annotated[Optional[float], pydantic.Field(alias="maxRetries")] = None
    r"""Maximum number of times to try fetching schemas from the Schema Registry"""

    auth: Optional[AuthTypeKafkaSchemaRegistry] = None
    r"""Credentials to use when authenticating with the schema registry using basic HTTP authentication"""

    tls: Optional[TLSSettingsClientSideTypeKafkaSchemaRegistry] = None

    default_key_schema_id: Annotated[
        Optional[float], pydantic.Field(alias="defaultKeySchemaId")
    ] = None
    r"""Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default."""

    default_value_schema_id: Annotated[
        Optional[float], pydantic.Field(alias="defaultValueSchemaId")
    ] = None
    r"""Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "schemaRegistryURL",
                "connectionTimeout",
                "requestTimeout",
                "maxRetries",
                "auth",
                "tls",
                "defaultKeySchemaId",
                "defaultValueSchemaId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
