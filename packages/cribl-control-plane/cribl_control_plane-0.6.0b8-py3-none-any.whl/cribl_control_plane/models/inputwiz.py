"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authenticationmethodoptions1 import AuthenticationMethodOptions1
from .itemstypeconnectionsoptional import (
    ItemsTypeConnectionsOptional,
    ItemsTypeConnectionsOptionalTypedDict,
)
from .itemstypemetadata import ItemsTypeMetadata, ItemsTypeMetadataTypedDict
from .pqtype import PqType, PqTypeTypedDict
from .retryrulestype import RetryRulesType, RetryRulesTypeTypedDict
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class InputWizType(str, Enum):
    WIZ = "wiz"


class ManageStateTypedDict(TypedDict):
    pass


class ManageState(BaseModel):
    pass


class InputWizLogLevel(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Collector runtime log level"""

    ERROR = "error"
    WARN = "warn"
    INFO = "info"
    DEBUG = "debug"
    SILLY = "silly"


class InputWizContentConfigTypedDict(TypedDict):
    content_type: str
    r"""The name of the Wiz query"""
    content_query: str
    r"""Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`."""
    cron_schedule: str
    r"""A cron schedule on which to run this job"""
    earliest: str
    r"""Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""
    latest: str
    r"""Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""
    content_description: NotRequired[str]
    enabled: NotRequired[bool]
    state_tracking: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""
    state_update_expression: NotRequired[str]
    r"""JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information."""
    state_merge_expression: NotRequired[str]
    r"""JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep."""
    manage_state: NotRequired[ManageStateTypedDict]
    job_timeout: NotRequired[str]
    r"""Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time."""
    log_level: NotRequired[InputWizLogLevel]
    r"""Collector runtime log level"""
    max_pages: NotRequired[float]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages."""


class InputWizContentConfig(BaseModel):
    content_type: Annotated[str, pydantic.Field(alias="contentType")]
    r"""The name of the Wiz query"""

    content_query: Annotated[str, pydantic.Field(alias="contentQuery")]
    r"""Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`."""

    cron_schedule: Annotated[str, pydantic.Field(alias="cronSchedule")]
    r"""A cron schedule on which to run this job"""

    earliest: str
    r"""Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""

    latest: str
    r"""Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)"""

    content_description: Annotated[
        Optional[str], pydantic.Field(alias="contentDescription")
    ] = None

    enabled: Optional[bool] = None

    state_tracking: Annotated[Optional[bool], pydantic.Field(alias="stateTracking")] = (
        None
    )
    r"""Track collection progress between consecutive scheduled executions"""

    state_update_expression: Annotated[
        Optional[str], pydantic.Field(alias="stateUpdateExpression")
    ] = None
    r"""JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information."""

    state_merge_expression: Annotated[
        Optional[str], pydantic.Field(alias="stateMergeExpression")
    ] = None
    r"""JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep."""

    manage_state: Annotated[
        Optional[ManageState], pydantic.Field(alias="manageState")
    ] = None

    job_timeout: Annotated[Optional[str], pydantic.Field(alias="jobTimeout")] = None
    r"""Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time."""

    log_level: Annotated[
        Optional[InputWizLogLevel], pydantic.Field(alias="logLevel")
    ] = None
    r"""Collector runtime log level"""

    max_pages: Annotated[Optional[float], pydantic.Field(alias="maxPages")] = None
    r"""Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages."""

    @field_serializer("log_level")
    def serialize_log_level(self, value):
        if isinstance(value, str):
            try:
                return models.InputWizLogLevel(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "contentDescription",
                "enabled",
                "stateTracking",
                "stateUpdateExpression",
                "stateMergeExpression",
                "manageState",
                "jobTimeout",
                "logLevel",
                "maxPages",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InputWizTypedDict(TypedDict):
    type: InputWizType
    endpoint: str
    r"""The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql"""
    auth_url: str
    r"""The authentication URL to generate an OAuth token"""
    client_id: str
    r"""The client ID of the Wiz application"""
    content_config: List[InputWizContentConfigTypedDict]
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    auth_audience_override: NotRequired[str]
    r"""The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used."""
    request_timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    keep_alive_time: NotRequired[float]
    r"""How often workers should check in with the scheduler to keep job subscription alive"""
    max_missed_keep_alives: NotRequired[float]
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""
    ttl: NotRequired[str]
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""
    ignore_group_jobs_limit: NotRequired[bool]
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    retry_rules: NotRequired[RetryRulesTypeTypedDict]
    auth_type: NotRequired[AuthenticationMethodOptions1]
    r"""Enter client secret directly, or select a stored secret"""
    description: NotRequired[str]
    client_secret: NotRequired[str]
    r"""The client secret of the Wiz application"""
    text_secret: NotRequired[str]
    r"""Select or create a stored text secret"""
    template_endpoint: NotRequired[str]
    r"""Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime."""
    template_auth_url: NotRequired[str]
    r"""Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime."""
    template_client_id: NotRequired[str]
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""


class InputWiz(BaseModel):
    type: InputWizType

    endpoint: str
    r"""The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql"""

    auth_url: Annotated[str, pydantic.Field(alias="authUrl")]
    r"""The authentication URL to generate an OAuth token"""

    client_id: Annotated[str, pydantic.Field(alias="clientId")]
    r"""The client ID of the Wiz application"""

    content_config: Annotated[
        List[InputWizContentConfig], pydantic.Field(alias="contentConfig")
    ]

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    auth_audience_override: Annotated[
        Optional[str], pydantic.Field(alias="authAudienceOverride")
    ] = None
    r"""The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used."""

    request_timeout: Annotated[
        Optional[float], pydantic.Field(alias="requestTimeout")
    ] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    keep_alive_time: Annotated[
        Optional[float], pydantic.Field(alias="keepAliveTime")
    ] = None
    r"""How often workers should check in with the scheduler to keep job subscription alive"""

    max_missed_keep_alives: Annotated[
        Optional[float], pydantic.Field(alias="maxMissedKeepAlives")
    ] = None
    r"""The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked."""

    ttl: Optional[str] = None
    r"""Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector."""

    ignore_group_jobs_limit: Annotated[
        Optional[bool], pydantic.Field(alias="ignoreGroupJobsLimit")
    ] = None
    r"""When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    retry_rules: Annotated[
        Optional[RetryRulesType], pydantic.Field(alias="retryRules")
    ] = None

    auth_type: Annotated[
        Optional[AuthenticationMethodOptions1], pydantic.Field(alias="authType")
    ] = None
    r"""Enter client secret directly, or select a stored secret"""

    description: Optional[str] = None

    client_secret: Annotated[Optional[str], pydantic.Field(alias="clientSecret")] = None
    r"""The client secret of the Wiz application"""

    text_secret: Annotated[Optional[str], pydantic.Field(alias="textSecret")] = None
    r"""Select or create a stored text secret"""

    template_endpoint: Annotated[
        Optional[str], pydantic.Field(alias="__template_endpoint")
    ] = None
    r"""Binds 'endpoint' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'endpoint' at runtime."""

    template_auth_url: Annotated[
        Optional[str], pydantic.Field(alias="__template_authUrl")
    ] = None
    r"""Binds 'authUrl' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'authUrl' at runtime."""

    template_client_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_clientId")
    ] = None
    r"""Binds 'clientId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'clientId' at runtime."""

    @field_serializer("auth_type")
    def serialize_auth_type(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptions1(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "id",
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "authAudienceOverride",
                "requestTimeout",
                "keepAliveTime",
                "maxMissedKeepAlives",
                "ttl",
                "ignoreGroupJobsLimit",
                "metadata",
                "retryRules",
                "authType",
                "description",
                "clientSecret",
                "textSecret",
                "__template_endpoint",
                "__template_authUrl",
                "__template_clientId",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
