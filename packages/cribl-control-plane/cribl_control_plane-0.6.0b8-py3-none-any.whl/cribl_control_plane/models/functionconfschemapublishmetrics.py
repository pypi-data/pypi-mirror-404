"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class FunctionConfSchemaPublishMetricsMetricType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # Counter
    COUNTER = "counter"
    # Timer
    TIMER = "timer"
    # Gauge
    GAUGE = "gauge"
    # Distribution
    DISTRIBUTION = "distribution"
    # Summary
    SUMMARY = "summary"
    # Histogram
    HISTOGRAM = "histogram"


class FunctionConfSchemaPublishMetricsFieldTypedDict(TypedDict):
    in_field_name: str
    r"""The name of the field in the event that contains the metric value"""
    metric_type: FunctionConfSchemaPublishMetricsMetricType
    out_field_expr: NotRequired[str]
    r"""JavaScript expression to evaluate the metric field name. Defaults to Event Field Name."""


class FunctionConfSchemaPublishMetricsField(BaseModel):
    in_field_name: Annotated[str, pydantic.Field(alias="inFieldName")]
    r"""The name of the field in the event that contains the metric value"""

    metric_type: Annotated[
        FunctionConfSchemaPublishMetricsMetricType, pydantic.Field(alias="metricType")
    ]

    out_field_expr: Annotated[Optional[str], pydantic.Field(alias="outFieldExpr")] = (
        None
    )
    r"""JavaScript expression to evaluate the metric field name. Defaults to Event Field Name."""

    @field_serializer("metric_type")
    def serialize_metric_type(self, value):
        if isinstance(value, str):
            try:
                return models.FunctionConfSchemaPublishMetricsMetricType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["outFieldExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FunctionConfSchemaPublishMetricsTypedDict(TypedDict):
    fields: NotRequired[List[FunctionConfSchemaPublishMetricsFieldTypedDict]]
    r"""List of metrics from event to extract and format. Formatted metrics can be used by a destination to pass metrics to a metrics aggregation platform."""
    overwrite: NotRequired[bool]
    r"""Overwrite previous metric specs. Leave disabled to append."""
    dimensions: NotRequired[List[str]]
    r"""Optional list of dimensions to include in events. Wildcards supported. If you don't specify metrics, values will be appended to every metric found in the event. When you add a new metric, dimensions will be present only in those new metrics."""
    remove_metrics: NotRequired[List[str]]
    r"""Optional list of metric field names to look for when removing metrics. When a metric's field name matches an element in this list, the metric will be removed from the event."""
    remove_dimensions: NotRequired[List[str]]
    r"""Optional list of dimensions to remove from every metric found in the event. Wildcards supported."""


class FunctionConfSchemaPublishMetrics(BaseModel):
    fields: Optional[List[FunctionConfSchemaPublishMetricsField]] = None
    r"""List of metrics from event to extract and format. Formatted metrics can be used by a destination to pass metrics to a metrics aggregation platform."""

    overwrite: Optional[bool] = None
    r"""Overwrite previous metric specs. Leave disabled to append."""

    dimensions: Optional[List[str]] = None
    r"""Optional list of dimensions to include in events. Wildcards supported. If you don't specify metrics, values will be appended to every metric found in the event. When you add a new metric, dimensions will be present only in those new metrics."""

    remove_metrics: Annotated[
        Optional[List[str]], pydantic.Field(alias="removeMetrics")
    ] = None
    r"""Optional list of metric field names to look for when removing metrics. When a metric's field name matches an element in this list, the metric will be removed from the event."""

    remove_dimensions: Annotated[
        Optional[List[str]], pydantic.Field(alias="removeDimensions")
    ] = None
    r"""Optional list of dimensions to remove from every metric found in the event. Wildcards supported."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["fields", "overwrite", "dimensions", "removeMetrics", "removeDimensions"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
