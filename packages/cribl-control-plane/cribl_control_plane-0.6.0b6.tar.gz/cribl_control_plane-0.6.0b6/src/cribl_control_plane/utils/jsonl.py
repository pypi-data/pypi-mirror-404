"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from typing import Callable, Generic, TypeVar, Optional, Generator, AsyncGenerator
import httpx

T = TypeVar("T")


class JsonLStream(Generic[T]):
    # Holds a reference to the SDK client to avoid it being garbage collected
    # and cause termination of the underlying httpx client.
    client_ref: Optional[object]
    response: httpx.Response
    generator: Generator[T, None, None]

    def __init__(
        self,
        response: httpx.Response,
        decoder: Callable[[str], T],
        sentinel: Optional[str] = None,
        client_ref: Optional[object] = None,
    ):
        self.response = response
        self.generator = stream_jsonl_events(response, decoder, sentinel)
        self.client_ref = client_ref

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.generator)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.response.close()


class JsonLStreamAsync(Generic[T]):
    # Holds a reference to the SDK client to avoid it being garbage collected
    # and cause termination of the underlying httpx client.
    client_ref: Optional[object]
    response: httpx.Response
    generator: AsyncGenerator[T, None]

    def __init__(
        self,
        response: httpx.Response,
        decoder: Callable[[str], T],
        sentinel: Optional[str] = None,
        client_ref: Optional[object] = None,
    ):
        self.response = response
        self.generator = stream_jsonl_events_async(response, decoder, sentinel)
        self.client_ref = client_ref

    def __aiter__(self):
        return self

    async def __anext__(self):
        return await self.generator.__anext__()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.response.aclose()


MESSAGE_BOUNDARIES = [
    b"}\n",
    b"}\r\n",
]


async def stream_jsonl_events_async(
    response: httpx.Response,
    decoder: Callable[[str], T],
    _: Optional[str] = None,
) -> AsyncGenerator[T, None]:
    buffer = bytearray()
    position = 0
    async for chunk in response.aiter_bytes():
        buffer += chunk
        for i in range(position, len(buffer)):
            char = buffer[i : i + 1]
            seq: Optional[bytes] = None
            if char in [b"}"]:
                for boundary in MESSAGE_BOUNDARIES:
                    seq = _peek_sequence(i, buffer, boundary)
                    if seq is not None:
                        break
            if seq is None:
                continue

            block = buffer[position : i + 1]
            position = i + len(seq)
            if block:
                event = decoder(block.decode())
                yield event

        if position > 0:
            buffer = buffer[position:]
            position = 0

    if position != 0:
        event = decoder(buffer.decode())
        yield event


def stream_jsonl_events(
    response: httpx.Response,
    decoder: Callable[[str], T],
    _: Optional[str] = None,
) -> Generator[T, None, None]:
    buffer = bytearray()
    position = 0
    for chunk in response.iter_bytes():
        buffer += chunk
        for i in range(position, len(buffer)):
            char = buffer[i : i + 1]
            seq: Optional[bytes] = None
            if char in [b"}"]:
                for boundary in MESSAGE_BOUNDARIES:
                    seq = _peek_sequence(i, buffer, boundary)
                    if seq is not None:
                        break
            if seq is None:
                continue

            block = buffer[position : i + 1]
            position = i + len(seq)
            if block:
                event = decoder(block.decode())
                yield event

        if position > 0:
            buffer = buffer[position:]
            position = 0

    if position != 0:
        event = decoder(buffer.decode())
        yield event


def _peek_sequence(position: int, buffer: bytearray, sequence: bytes):
    if len(sequence) > (len(buffer) - position):
        return None

    for i, seq in enumerate(sequence):
        if buffer[position + i] != seq:
            return None

    return sequence
