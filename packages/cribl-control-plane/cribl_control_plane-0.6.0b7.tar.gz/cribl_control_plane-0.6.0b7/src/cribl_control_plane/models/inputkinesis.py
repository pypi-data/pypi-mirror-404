"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .authenticationmethodoptionss3collectorconf import (
    AuthenticationMethodOptionsS3CollectorConf,
)
from .itemstypeconnectionsoptional import (
    ItemsTypeConnectionsOptional,
    ItemsTypeConnectionsOptionalTypedDict,
)
from .itemstypemetadata import ItemsTypeMetadata, ItemsTypeMetadataTypedDict
from .pqtype import PqType, PqTypeTypedDict
from .signatureversionoptions2 import SignatureVersionOptions2
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class InputKinesisType(str, Enum):
    KINESIS = "kinesis"


class ShardIteratorStart(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Location at which to start reading a shard for the first time"""

    # Earliest record
    TRIM_HORIZON = "TRIM_HORIZON"
    # Latest record
    LATEST = "LATEST"


class RecordDataFormat(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""

    # Cribl
    CRIBL = "cribl"
    # Newline JSON
    NDJSON = "ndjson"
    # Cloudwatch Logs
    CLOUDWATCH = "cloudwatch"
    # Event per line
    LINE = "line"


class ShardLoadBalancing(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""

    # Consistent Hashing
    CONSISTENT_HASHING = "ConsistentHashing"
    # Round Robin
    ROUND_ROBIN = "RoundRobin"


class InputKinesisTypedDict(TypedDict):
    type: InputKinesisType
    stream_name: str
    r"""Kinesis Data Stream to read data from"""
    region: str
    r"""Region where the Kinesis stream is located"""
    id: NotRequired[str]
    r"""Unique ID for this input"""
    disabled: NotRequired[bool]
    pipeline: NotRequired[str]
    r"""Pipeline to process data from this Source before sending it through the Routes"""
    send_to_routes: NotRequired[bool]
    r"""Select whether to send data to Routes, or directly to Destinations."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    pq_enabled: NotRequired[bool]
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    connections: NotRequired[List[ItemsTypeConnectionsOptionalTypedDict]]
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""
    pq: NotRequired[PqTypeTypedDict]
    service_interval: NotRequired[float]
    r"""Time interval in minutes between consecutive service calls"""
    shard_expr: NotRequired[str]
    r"""A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed."""
    shard_iterator_type: NotRequired[ShardIteratorStart]
    r"""Location at which to start reading a shard for the first time"""
    payload_format: NotRequired[RecordDataFormat]
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""
    get_records_limit: NotRequired[float]
    r"""Maximum number of records per getRecords call"""
    get_records_limit_total: NotRequired[float]
    r"""Maximum number of records, across all shards, to pull down at once per Worker Process"""
    load_balancing_algorithm: NotRequired[ShardLoadBalancing]
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""
    aws_authentication_method: NotRequired[AuthenticationMethodOptionsS3CollectorConf]
    r"""AWS authentication method. Choose Auto to use IAM roles."""
    aws_secret_key: NotRequired[str]
    endpoint: NotRequired[str]
    r"""Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint."""
    signature_version: NotRequired[SignatureVersionOptions2]
    r"""Signature version to use for signing Kinesis stream requests"""
    reuse_connections: NotRequired[bool]
    r"""Reuse connections between requests, which can improve performance"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""
    enable_assume_role: NotRequired[bool]
    r"""Use Assume Role credentials to access Kinesis stream"""
    assume_role_arn: NotRequired[str]
    r"""Amazon Resource Name (ARN) of the role to assume"""
    assume_role_external_id: NotRequired[str]
    r"""External ID to use when assuming role"""
    duration_seconds: NotRequired[float]
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""
    verify_kpl_check_sums: NotRequired[bool]
    r"""Verify Kinesis Producer Library (KPL) event checksums"""
    avoid_duplicates: NotRequired[bool]
    r"""When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart."""
    metadata: NotRequired[List[ItemsTypeMetadataTypedDict]]
    r"""Fields to add to events from this input"""
    description: NotRequired[str]
    aws_api_key: NotRequired[str]
    aws_secret: NotRequired[str]
    r"""Select or create a stored secret that references your access key and secret key"""
    template_stream_name: NotRequired[str]
    r"""Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime."""
    template_aws_secret_key: NotRequired[str]
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""
    template_region: NotRequired[str]
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""
    template_assume_role_arn: NotRequired[str]
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""
    template_assume_role_external_id: NotRequired[str]
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""
    template_aws_api_key: NotRequired[str]
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""


class InputKinesis(BaseModel):
    type: InputKinesisType

    stream_name: Annotated[str, pydantic.Field(alias="streamName")]
    r"""Kinesis Data Stream to read data from"""

    region: str
    r"""Region where the Kinesis stream is located"""

    id: Optional[str] = None
    r"""Unique ID for this input"""

    disabled: Optional[bool] = None

    pipeline: Optional[str] = None
    r"""Pipeline to process data from this Source before sending it through the Routes"""

    send_to_routes: Annotated[Optional[bool], pydantic.Field(alias="sendToRoutes")] = (
        None
    )
    r"""Select whether to send data to Routes, or directly to Destinations."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    pq_enabled: Annotated[Optional[bool], pydantic.Field(alias="pqEnabled")] = None
    r"""Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers)."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    connections: Optional[List[ItemsTypeConnectionsOptional]] = None
    r"""Direct connections to Destinations, and optionally via a Pipeline or a Pack"""

    pq: Optional[PqType] = None

    service_interval: Annotated[
        Optional[float], pydantic.Field(alias="serviceInterval")
    ] = None
    r"""Time interval in minutes between consecutive service calls"""

    shard_expr: Annotated[Optional[str], pydantic.Field(alias="shardExpr")] = None
    r"""A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed."""

    shard_iterator_type: Annotated[
        Optional[ShardIteratorStart], pydantic.Field(alias="shardIteratorType")
    ] = None
    r"""Location at which to start reading a shard for the first time"""

    payload_format: Annotated[
        Optional[RecordDataFormat], pydantic.Field(alias="payloadFormat")
    ] = None
    r"""Format of data inside the Kinesis Stream records. Gzip compression is automatically detected."""

    get_records_limit: Annotated[
        Optional[float], pydantic.Field(alias="getRecordsLimit")
    ] = None
    r"""Maximum number of records per getRecords call"""

    get_records_limit_total: Annotated[
        Optional[float], pydantic.Field(alias="getRecordsLimitTotal")
    ] = None
    r"""Maximum number of records, across all shards, to pull down at once per Worker Process"""

    load_balancing_algorithm: Annotated[
        Optional[ShardLoadBalancing], pydantic.Field(alias="loadBalancingAlgorithm")
    ] = None
    r"""The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes"""

    aws_authentication_method: Annotated[
        Optional[AuthenticationMethodOptionsS3CollectorConf],
        pydantic.Field(alias="awsAuthenticationMethod"),
    ] = None
    r"""AWS authentication method. Choose Auto to use IAM roles."""

    aws_secret_key: Annotated[Optional[str], pydantic.Field(alias="awsSecretKey")] = (
        None
    )

    endpoint: Optional[str] = None
    r"""Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint."""

    signature_version: Annotated[
        Optional[SignatureVersionOptions2], pydantic.Field(alias="signatureVersion")
    ] = None
    r"""Signature version to use for signing Kinesis stream requests"""

    reuse_connections: Annotated[
        Optional[bool], pydantic.Field(alias="reuseConnections")
    ] = None
    r"""Reuse connections between requests, which can improve performance"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA, such as self-signed certificates"""

    enable_assume_role: Annotated[
        Optional[bool], pydantic.Field(alias="enableAssumeRole")
    ] = None
    r"""Use Assume Role credentials to access Kinesis stream"""

    assume_role_arn: Annotated[Optional[str], pydantic.Field(alias="assumeRoleArn")] = (
        None
    )
    r"""Amazon Resource Name (ARN) of the role to assume"""

    assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="assumeRoleExternalId")
    ] = None
    r"""External ID to use when assuming role"""

    duration_seconds: Annotated[
        Optional[float], pydantic.Field(alias="durationSeconds")
    ] = None
    r"""Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours)."""

    verify_kpl_check_sums: Annotated[
        Optional[bool], pydantic.Field(alias="verifyKPLCheckSums")
    ] = None
    r"""Verify Kinesis Producer Library (KPL) event checksums"""

    avoid_duplicates: Annotated[
        Optional[bool], pydantic.Field(alias="avoidDuplicates")
    ] = None
    r"""When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart."""

    metadata: Optional[List[ItemsTypeMetadata]] = None
    r"""Fields to add to events from this input"""

    description: Optional[str] = None

    aws_api_key: Annotated[Optional[str], pydantic.Field(alias="awsApiKey")] = None

    aws_secret: Annotated[Optional[str], pydantic.Field(alias="awsSecret")] = None
    r"""Select or create a stored secret that references your access key and secret key"""

    template_stream_name: Annotated[
        Optional[str], pydantic.Field(alias="__template_streamName")
    ] = None
    r"""Binds 'streamName' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'streamName' at runtime."""

    template_aws_secret_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsSecretKey")
    ] = None
    r"""Binds 'awsSecretKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsSecretKey' at runtime."""

    template_region: Annotated[
        Optional[str], pydantic.Field(alias="__template_region")
    ] = None
    r"""Binds 'region' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'region' at runtime."""

    template_assume_role_arn: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleArn")
    ] = None
    r"""Binds 'assumeRoleArn' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleArn' at runtime."""

    template_assume_role_external_id: Annotated[
        Optional[str], pydantic.Field(alias="__template_assumeRoleExternalId")
    ] = None
    r"""Binds 'assumeRoleExternalId' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'assumeRoleExternalId' at runtime."""

    template_aws_api_key: Annotated[
        Optional[str], pydantic.Field(alias="__template_awsApiKey")
    ] = None
    r"""Binds 'awsApiKey' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'awsApiKey' at runtime."""

    @field_serializer("shard_iterator_type")
    def serialize_shard_iterator_type(self, value):
        if isinstance(value, str):
            try:
                return models.ShardIteratorStart(value)
            except ValueError:
                return value
        return value

    @field_serializer("payload_format")
    def serialize_payload_format(self, value):
        if isinstance(value, str):
            try:
                return models.RecordDataFormat(value)
            except ValueError:
                return value
        return value

    @field_serializer("load_balancing_algorithm")
    def serialize_load_balancing_algorithm(self, value):
        if isinstance(value, str):
            try:
                return models.ShardLoadBalancing(value)
            except ValueError:
                return value
        return value

    @field_serializer("aws_authentication_method")
    def serialize_aws_authentication_method(self, value):
        if isinstance(value, str):
            try:
                return models.AuthenticationMethodOptionsS3CollectorConf(value)
            except ValueError:
                return value
        return value

    @field_serializer("signature_version")
    def serialize_signature_version(self, value):
        if isinstance(value, str):
            try:
                return models.SignatureVersionOptions2(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "id",
                "disabled",
                "pipeline",
                "sendToRoutes",
                "environment",
                "pqEnabled",
                "streamtags",
                "connections",
                "pq",
                "serviceInterval",
                "shardExpr",
                "shardIteratorType",
                "payloadFormat",
                "getRecordsLimit",
                "getRecordsLimitTotal",
                "loadBalancingAlgorithm",
                "awsAuthenticationMethod",
                "awsSecretKey",
                "endpoint",
                "signatureVersion",
                "reuseConnections",
                "rejectUnauthorized",
                "enableAssumeRole",
                "assumeRoleArn",
                "assumeRoleExternalId",
                "durationSeconds",
                "verifyKPLCheckSums",
                "avoidDuplicates",
                "metadata",
                "description",
                "awsApiKey",
                "awsSecret",
                "__template_streamName",
                "__template_awsSecretKey",
                "__template_region",
                "__template_assumeRoleArn",
                "__template_assumeRoleExternalId",
                "__template_awsApiKey",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
