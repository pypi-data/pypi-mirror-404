"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .itemstyperestcollectmethodgetcollectrequestparams import (
    ItemsTypeRestCollectMethodGetCollectRequestParams,
    ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict,
)
from .paginationoptionsrestdiscoverydiscovertypehttppagination import (
    PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils import get_discriminator
from enum import Enum
import pydantic
from pydantic import Discriminator, Tag, field_serializer, model_serializer
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RestAuthenticationHmacAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationHmacDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationHmacDiscoveryTypedDict",
    Union[
        RestAuthenticationHmacRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationHmacDiscovery = Annotated[
    Union[
        Annotated[RestAuthenticationHmacRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestAuthenticationHmacRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestAuthenticationHmacRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestAuthenticationHmacRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationHmacCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationHmacRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationHmacRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationHmacRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationHmacRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationHmacRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationHmacRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationHmacRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationHmacRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationHmacPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationHmacPaginationUnionTypedDict",
    Union[
        RestAuthenticationHmacRestPaginationTypeNoneTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationHmacRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationHmacRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationHmacRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationHmacPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationHmacRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationHmacRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestAuthenticationHmacRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationHmacRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationHmacRestPaginationTypeRequestOffset, Tag("request_offset")
        ],
        Annotated[
            RestAuthenticationHmacRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationHmacRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationHmacRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationHmacRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationHmacRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationHmacRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationHmacRetryRulesTypedDict",
    Union[
        RestAuthenticationHmacRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationHmacRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationHmacRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationHmacRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationHmacRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestAuthenticationHmacRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationHmacStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationHmacStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationHmacStateTrackingTypedDict]


class RestAuthenticationHmacScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationHmacStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationHmacTypedDict(TypedDict):
    authentication: RestAuthenticationHmacAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    hmac_function_id: str
    r"""Select or create an HMAC Function to use with authentication"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationHmacCollectMethod
    discovery: NotRequired[RestAuthenticationHmacDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationHmacPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationHmacRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationHmacSchedulingTypedDict]


class RestAuthenticationHmac(BaseModel):
    authentication: RestAuthenticationHmacAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    hmac_function_id: Annotated[str, pydantic.Field(alias="hmacFunctionId")]
    r"""Select or create an HMAC Function to use with authentication"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationHmacCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationHmacDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationHmacPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationHmacRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationHmacScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationHmacCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationGoogleOauthSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretDiscovery = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationGoogleOauthSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretPaginationUnion = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeNone, Tag("none")
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationGoogleOauthSecretRetryRules = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthSecretRestRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            RestAuthenticationGoogleOauthSecretRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationGoogleOauthSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[
        RestAuthenticationGoogleOauthSecretStateTrackingTypedDict
    ]


class RestAuthenticationGoogleOauthSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSecretTypedDict(TypedDict):
    authentication: RestAuthenticationGoogleOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    text_secret: str
    r"""Select or create a text secret that contains the Google service account credentials value"""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationGoogleOauthSecretCollectMethod
    discovery: NotRequired[RestAuthenticationGoogleOauthSecretDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationGoogleOauthSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationGoogleOauthSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationGoogleOauthSecretSchedulingTypedDict]


class RestAuthenticationGoogleOauthSecret(BaseModel):
    authentication: RestAuthenticationGoogleOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the Google service account credentials value"""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationGoogleOauthSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    discovery: Optional[RestAuthenticationGoogleOauthSecretDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationGoogleOauthSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationGoogleOauthSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationGoogleOauthDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthDiscoveryTypedDict",
    Union[
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationGoogleOauthDiscovery = Annotated[
    Union[
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationGoogleOauthCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationGoogleOauthRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationGoogleOauthRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationGoogleOauthRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationGoogleOauthRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationGoogleOauthPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthPaginationUnionTypedDict",
    Union[
        RestAuthenticationGoogleOauthRestPaginationTypeNoneTypedDict,
        RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationGoogleOauthRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationGoogleOauthRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationGoogleOauthRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationGoogleOauthPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationGoogleOauthRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationGoogleOauthRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationGoogleOauthRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationGoogleOauthRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationGoogleOauthRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationGoogleOauthRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationGoogleOauthRetryRulesTypedDict",
    Union[
        RestAuthenticationGoogleOauthRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationGoogleOauthRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationGoogleOauthRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationGoogleOauthRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationGoogleOauthRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationGoogleOauthRestRetryRulesTypeStatic, Tag("static")],
        Annotated[
            RestAuthenticationGoogleOauthRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationGoogleOauthStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationGoogleOauthStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationGoogleOauthStateTrackingTypedDict]


class RestAuthenticationGoogleOauthScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationGoogleOauthStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationGoogleOauthTypedDict(TypedDict):
    authentication: RestAuthenticationGoogleOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""
    service_account_credentials: str
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""
    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationGoogleOauthCollectMethod
    discovery: NotRequired[RestAuthenticationGoogleOauthDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationGoogleOauthPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationGoogleOauthRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationGoogleOauthSchedulingTypedDict]


class RestAuthenticationGoogleOauth(BaseModel):
    authentication: RestAuthenticationGoogleOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    scopes: List[str]
    r"""Scopes to use during authentication. See [Google's docs](https://developers.google.com/identity/protocols/oauth2/scopes) for more information."""

    service_account_credentials: Annotated[
        str, pydantic.Field(alias="serviceAccountCredentials")
    ]
    r"""Contents of Google Cloud service account credentials (JSON keys) file. To upload a file, click the upload icon in this field's upper right."""

    subject: str
    r"""Email address of a user account with Super Admin permissions to the resources the collector will retrieve"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationGoogleOauthCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    discovery: Optional[RestAuthenticationGoogleOauthDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationGoogleOauthPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationGoogleOauthRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationGoogleOauthScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationGoogleOauthCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationOauthSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationOauthSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationOauthSecretDiscovery = Annotated[
    Union[
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            RestAuthenticationOauthSecretRestDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationOauthSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthSecretRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationOauthSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationOauthSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationOauthSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthSecretRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationOauthSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationOauthSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationOauthSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationOauthSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationOauthSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationOauthSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationOauthSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationOauthSecretPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationOauthSecretRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationOauthSecretRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationOauthSecretRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationOauthSecretRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthSecretRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationOauthSecretRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationOauthSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationOauthSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationOauthSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationOauthSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationOauthSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationOauthSecretRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationOauthSecretRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationOauthSecretRestRetryRulesTypeStatic, Tag("static")],
        Annotated[
            RestAuthenticationOauthSecretRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationOauthSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationOauthSecretStateTrackingTypedDict]


class RestAuthenticationOauthSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationOauthSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSecretTypedDict(TypedDict):
    authentication: RestAuthenticationOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: str
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    text_secret: str
    r"""Select or create a text secret that contains the client secret's value"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationOauthSecretCollectMethod
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationOauthSecretDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationOauthSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationOauthSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationOauthSecretSchedulingTypedDict]


class RestAuthenticationOauthSecret(BaseModel):
    authentication: RestAuthenticationOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        str, pydantic.Field(alias="clientSecretParamName")
    ]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the client secret's value"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationOauthSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationOauthSecretDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationOauthSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationOauthSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authHeaderKey",
                "authRequestParams",
                "authRequestHeaders",
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationOauthRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationOauthRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationOauthRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationOauthDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationOauthDiscoveryTypedDict",
    Union[
        RestAuthenticationOauthRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationOauthDiscovery = Annotated[
    Union[
        Annotated[RestAuthenticationOauthRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestAuthenticationOauthRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestAuthenticationOauthRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestAuthenticationOauthRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationOauthCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationOauthRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationOauthRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationOauthRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationOauthRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationOauthRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationOauthRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationOauthRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationOauthRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationOauthPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationOauthPaginationUnionTypedDict",
    Union[
        RestAuthenticationOauthRestPaginationTypeNoneTypedDict,
        RestAuthenticationOauthRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationOauthRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationOauthRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationOauthRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationOauthRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationOauthPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationOauthRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationOauthRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestAuthenticationOauthRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationOauthRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationOauthRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationOauthRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationOauthRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationOauthRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationOauthRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationOauthRetryRulesTypedDict",
    Union[
        RestAuthenticationOauthRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationOauthRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationOauthRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationOauthRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationOauthRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationOauthRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestAuthenticationOauthRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationOauthStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationOauthStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationOauthStateTrackingTypedDict]


class RestAuthenticationOauthScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationOauthStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationOauthTypedDict(TypedDict):
    authentication: RestAuthenticationOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: str
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""
    client_secret_param_value: str
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationOauthCollectMethod
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_params: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationOauthDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationOauthPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationOauthRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationOauthSchedulingTypedDict]


class RestAuthenticationOauth(BaseModel):
    authentication: RestAuthenticationOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        str, pydantic.Field(alias="clientSecretParamName")
    ]
    r"""Defaults to 'client_secret'. Automatically added to request parameters using the value specified."""

    client_secret_param_value: Annotated[
        str, pydantic.Field(alias="clientSecretParamValue")
    ]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationOauthCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_params: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationOauthDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationOauthPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationOauthRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationOauthScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationOauthCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authHeaderKey",
                "authRequestParams",
                "authRequestHeaders",
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationLoginSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationLoginSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationLoginSecretDiscovery = Annotated[
    Union[
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationLoginSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginSecretRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationLoginSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginSecretRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationLoginSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationLoginSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationLoginSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationLoginSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationLoginSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationLoginSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationLoginSecretPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationLoginSecretRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationLoginSecretRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationLoginSecretRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationLoginSecretRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginSecretRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationLoginSecretRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationLoginSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationLoginSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationLoginSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationLoginSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationLoginSecretRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationLoginSecretRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationLoginSecretRestRetryRulesTypeStatic, Tag("static")],
        Annotated[
            RestAuthenticationLoginSecretRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationLoginSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationLoginSecretStateTrackingTypedDict]


class RestAuthenticationLoginSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSecretTypedDict(TypedDict):
    authentication: RestAuthenticationLoginSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for login API call. This call is expected to be a POST."""
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    login_body: str
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationLoginSecretCollectMethod
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationLoginSecretDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationLoginSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationLoginSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationLoginSecretSchedulingTypedDict]


class RestAuthenticationLoginSecret(BaseModel):
    authentication: RestAuthenticationLoginSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call. This call is expected to be a POST."""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationLoginSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = None
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginSecretDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationLoginSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "getAuthTokenFromHeader",
                "authHeaderKey",
                "authRequestHeaders",
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationLoginRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationLoginRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationLoginRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationLoginDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationLoginDiscoveryTypedDict",
    Union[
        RestAuthenticationLoginRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationLoginDiscovery = Annotated[
    Union[
        Annotated[RestAuthenticationLoginRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestAuthenticationLoginRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestAuthenticationLoginRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestAuthenticationLoginRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationLoginCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationLoginRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationLoginRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationLoginRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationLoginRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationLoginRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationLoginRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationLoginRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationLoginPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationLoginPaginationUnionTypedDict",
    Union[
        RestAuthenticationLoginRestPaginationTypeNoneTypedDict,
        RestAuthenticationLoginRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationLoginRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationLoginRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationLoginRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationLoginRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationLoginPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationLoginRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationLoginRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestAuthenticationLoginRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationLoginRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationLoginRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationLoginRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationLoginRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationLoginRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationLoginRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationLoginRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationLoginRetryRulesTypedDict",
    Union[
        RestAuthenticationLoginRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationLoginRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationLoginRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationLoginRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationLoginRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationLoginRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestAuthenticationLoginRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationLoginStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationLoginStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationLoginStateTrackingTypedDict]


class RestAuthenticationLoginScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationLoginStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationLoginTypedDict(TypedDict):
    authentication: RestAuthenticationLoginAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for login API call. This call is expected to be a POST."""
    username: str
    password: str
    login_body: str
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""
    auth_header_expr: str
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationLoginCollectMethod
    get_auth_token_from_header: NotRequired[bool]
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""
    auth_header_key: NotRequired[str]
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""
    auth_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    discovery: NotRequired[RestAuthenticationLoginDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationLoginPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationLoginRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationLoginSchedulingTypedDict]


class RestAuthenticationLogin(BaseModel):
    authentication: RestAuthenticationLoginAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call. This call is expected to be a POST."""

    username: str

    password: str

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationLoginCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    get_auth_token_from_header: Annotated[
        Optional[bool], pydantic.Field(alias="getAuthTokenFromHeader")
    ] = None
    r"""Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response"""

    auth_header_key: Annotated[Optional[str], pydantic.Field(alias="authHeaderKey")] = (
        None
    )
    r"""Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None

    discovery: Optional[RestAuthenticationLoginDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationLoginPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationLoginRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationLoginScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationLoginCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "getAuthTokenFromHeader",
                "authHeaderKey",
                "authRequestHeaders",
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationBasicSecretDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretDiscoveryTypedDict",
    Union[
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationBasicSecretDiscovery = Annotated[
    Union[
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationBasicSecretCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicSecretRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationBasicSecretRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicSecretRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationBasicSecretPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretPaginationUnionTypedDict",
    Union[
        RestAuthenticationBasicSecretRestPaginationTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationBasicSecretRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationBasicSecretPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationBasicSecretRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicSecretRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicSecretRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationBasicSecretRetryRulesTypedDict",
    Union[
        RestAuthenticationBasicSecretRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationBasicSecretRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationBasicSecretRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationBasicSecretRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationBasicSecretRestRetryRulesTypeStatic, Tag("static")],
        Annotated[
            RestAuthenticationBasicSecretRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationBasicSecretStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicSecretStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicSecretStateTrackingTypedDict]


class RestAuthenticationBasicSecretScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicSecretStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSecretTypedDict(TypedDict):
    authentication: RestAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationBasicSecretCollectMethod
    discovery: NotRequired[RestAuthenticationBasicSecretDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicSecretPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicSecretRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSecretSchedulingTypedDict]


class RestAuthenticationBasicSecret(BaseModel):
    authentication: RestAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationBasicSecretCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    discovery: Optional[RestAuthenticationBasicSecretDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicSecretPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicSecretScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicSecretCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationBasicDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationBasicDiscoveryTypedDict",
    Union[
        RestAuthenticationBasicRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationBasicDiscovery = Annotated[
    Union[
        Annotated[RestAuthenticationBasicRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestAuthenticationBasicRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestAuthenticationBasicRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestAuthenticationBasicRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationBasicCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationBasicRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationBasicRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationBasicRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationBasicRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationBasicRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationBasicRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationBasicRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationBasicPaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationBasicPaginationUnionTypedDict",
    Union[
        RestAuthenticationBasicRestPaginationTypeNoneTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationBasicRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationBasicRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationBasicRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationBasicPaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationBasicRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationBasicRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestAuthenticationBasicRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationBasicRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestAuthenticationBasicRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationBasicRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationBasicRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationBasicRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationBasicRetryRulesTypedDict",
    Union[
        RestAuthenticationBasicRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationBasicRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationBasicRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationBasicRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationBasicRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationBasicRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestAuthenticationBasicRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationBasicStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationBasicStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationBasicStateTrackingTypedDict]


class RestAuthenticationBasicScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationBasicStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationBasicTypedDict(TypedDict):
    authentication: RestAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    username: str
    password: str
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationBasicCollectMethod
    discovery: NotRequired[RestAuthenticationBasicDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationBasicPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationBasicRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationBasicSchedulingTypedDict]


class RestAuthenticationBasic(BaseModel):
    authentication: RestAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    username: str

    password: str

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationBasicCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationBasicDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationBasicPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationBasicRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationBasicScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationBasicCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestAuthenticationNoneDiscoveryTypedDict = TypeAliasType(
    "RestAuthenticationNoneDiscoveryTypedDict",
    Union[
        RestAuthenticationNoneRestDiscoveryDiscoverTypeNoneTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeListTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeJSONTypedDict,
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestAuthenticationNoneDiscovery = Annotated[
    Union[
        Annotated[RestAuthenticationNoneRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestAuthenticationNoneRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestAuthenticationNoneRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestAuthenticationNoneRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestAuthenticationNoneCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestAuthenticationNoneRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationNoneRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestAuthenticationNoneRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestAuthenticationNoneRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestAuthenticationNoneRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestAuthenticationNoneRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestAuthenticationNoneRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestAuthenticationNoneRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestAuthenticationNonePaginationUnionTypedDict = TypeAliasType(
    "RestAuthenticationNonePaginationUnionTypedDict",
    Union[
        RestAuthenticationNoneRestPaginationTypeNoneTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseHeaderTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseBodyTypedDict,
        RestAuthenticationNoneRestPaginationTypeResponseHeaderLinkTypedDict,
        RestAuthenticationNoneRestPaginationTypeRequestOffsetTypedDict,
        RestAuthenticationNoneRestPaginationTypeRequestPageTypedDict,
    ],
)


RestAuthenticationNonePaginationUnion = Annotated[
    Union[
        Annotated[RestAuthenticationNoneRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestAuthenticationNoneRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestAuthenticationNoneRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestAuthenticationNoneRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestAuthenticationNoneRestPaginationTypeRequestOffset, Tag("request_offset")
        ],
        Annotated[
            RestAuthenticationNoneRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationNoneRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestAuthenticationNoneRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestAuthenticationNoneRetryRulesTypedDict = TypeAliasType(
    "RestAuthenticationNoneRetryRulesTypedDict",
    Union[
        RestAuthenticationNoneRestRetryRulesTypeNoneTypedDict,
        RestAuthenticationNoneRestRetryRulesTypeStaticTypedDict,
        RestAuthenticationNoneRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestAuthenticationNoneRetryRules = Annotated[
    Union[
        Annotated[RestAuthenticationNoneRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestAuthenticationNoneRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestAuthenticationNoneRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestAuthenticationNoneStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestAuthenticationNoneStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestAuthenticationNoneStateTrackingTypedDict]


class RestAuthenticationNoneScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestAuthenticationNoneStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestAuthenticationNoneTypedDict(TypedDict):
    authentication: RestAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    collect_method: RestAuthenticationNoneCollectMethod
    discovery: NotRequired[RestAuthenticationNoneDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestAuthenticationNonePaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestAuthenticationNoneRetryRulesTypedDict]
    scheduling: NotRequired[RestAuthenticationNoneSchedulingTypedDict]


class RestAuthenticationNone(BaseModel):
    authentication: RestAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    collect_method: Annotated[
        RestAuthenticationNoneCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    discovery: Optional[RestAuthenticationNoneDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestAuthenticationNonePaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestAuthenticationNoneRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestAuthenticationNoneScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestAuthenticationNoneCollectMethod(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestCollectMethodOtherDiscoveryTypedDict = TypeAliasType(
    "RestCollectMethodOtherDiscoveryTypedDict",
    Union[
        RestCollectMethodOtherRestDiscoveryDiscoverTypeNoneTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeListTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeJSONTypedDict,
        RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestCollectMethodOtherDiscovery = Annotated[
    Union[
        Annotated[RestCollectMethodOtherRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestCollectMethodOtherRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestCollectMethodOtherRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestCollectMethodOtherRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestCollectMethodOtherRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodOtherRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodOtherRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestCollectMethodOtherRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestCollectMethodOtherRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodOtherRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestCollectMethodOtherRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodOtherRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestCollectMethodOtherPaginationUnionTypedDict = TypeAliasType(
    "RestCollectMethodOtherPaginationUnionTypedDict",
    Union[
        RestCollectMethodOtherRestPaginationTypeNoneTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseHeaderTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseBodyTypedDict,
        RestCollectMethodOtherRestPaginationTypeResponseHeaderLinkTypedDict,
        RestCollectMethodOtherRestPaginationTypeRequestOffsetTypedDict,
        RestCollectMethodOtherRestPaginationTypeRequestPageTypedDict,
    ],
)


RestCollectMethodOtherPaginationUnion = Annotated[
    Union[
        Annotated[RestCollectMethodOtherRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestCollectMethodOtherRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestCollectMethodOtherRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestCollectMethodOtherRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestCollectMethodOtherRestPaginationTypeRequestOffset, Tag("request_offset")
        ],
        Annotated[
            RestCollectMethodOtherRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodOtherAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodOtherRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodOtherRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodOtherRetryRulesTypedDict = TypeAliasType(
    "RestCollectMethodOtherRetryRulesTypedDict",
    Union[
        RestCollectMethodOtherRestRetryRulesTypeNoneTypedDict,
        RestCollectMethodOtherRestRetryRulesTypeStaticTypedDict,
        RestCollectMethodOtherRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestCollectMethodOtherRetryRules = Annotated[
    Union[
        Annotated[RestCollectMethodOtherRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestCollectMethodOtherRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestCollectMethodOtherRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodOtherStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodOtherStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodOtherStateTrackingTypedDict]


class RestCollectMethodOtherScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodOtherStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodOtherTypedDict(TypedDict):
    collect_method: RestCollectMethodOtherCollectMethod
    collect_verb: Any
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: RestCollectMethodOtherAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_body: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodOtherDiscoveryTypedDict]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodOtherPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodOtherRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodOtherSchedulingTypedDict]


class RestCollectMethodOther(BaseModel):
    collect_method: Annotated[
        RestCollectMethodOtherCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    collect_verb: Annotated[Any, pydantic.Field(alias="collectVerb")]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: RestCollectMethodOtherAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodOtherDiscovery] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodOtherPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodOtherRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodOtherScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodOtherAuthentication(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectBody",
                "collectRequestParams",
                "discovery",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyCollectMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: (
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestCollectMethodPostWithBodyDiscoveryTypedDict = TypeAliasType(
    "RestCollectMethodPostWithBodyDiscoveryTypedDict",
    Union[
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNoneTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeListTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSONTypedDict,
        RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestCollectMethodPostWithBodyDiscovery = Annotated[
    Union[
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestCollectMethodPostWithBodyRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodPostWithBodyRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostWithBodyRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestCollectMethodPostWithBodyRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostWithBodyRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestCollectMethodPostWithBodyPaginationUnionTypedDict = TypeAliasType(
    "RestCollectMethodPostWithBodyPaginationUnionTypedDict",
    Union[
        RestCollectMethodPostWithBodyRestPaginationTypeNoneTypedDict,
        RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderTypedDict,
        RestCollectMethodPostWithBodyRestPaginationTypeResponseBodyTypedDict,
        RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLinkTypedDict,
        RestCollectMethodPostWithBodyRestPaginationTypeRequestOffsetTypedDict,
        RestCollectMethodPostWithBodyRestPaginationTypeRequestPageTypedDict,
    ],
)


RestCollectMethodPostWithBodyPaginationUnion = Annotated[
    Union[
        Annotated[RestCollectMethodPostWithBodyRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestCollectMethodPostWithBodyRestPaginationTypeResponseBody,
            Tag("response_body"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestPaginationTypeRequestOffset,
            Tag("request_offset"),
        ],
        Annotated[
            RestCollectMethodPostWithBodyRestPaginationTypeRequestPage,
            Tag("request_page"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodPostWithBodyAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestCollectMethodPostWithBodyRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostWithBodyRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodPostWithBodyRetryRulesTypedDict = TypeAliasType(
    "RestCollectMethodPostWithBodyRetryRulesTypedDict",
    Union[
        RestCollectMethodPostWithBodyRestRetryRulesTypeNoneTypedDict,
        RestCollectMethodPostWithBodyRestRetryRulesTypeStaticTypedDict,
        RestCollectMethodPostWithBodyRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestCollectMethodPostWithBodyRetryRules = Annotated[
    Union[
        Annotated[RestCollectMethodPostWithBodyRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestCollectMethodPostWithBodyRestRetryRulesTypeStatic, Tag("static")],
        Annotated[
            RestCollectMethodPostWithBodyRestRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodPostWithBodyStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostWithBodyStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodySchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodPostWithBodyStateTrackingTypedDict]


class RestCollectMethodPostWithBodyScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodPostWithBodyStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostWithBodyTypedDict(TypedDict):
    collect_method: RestCollectMethodPostWithBodyCollectMethod
    collect_body: Any
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: RestCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    discovery: NotRequired[RestCollectMethodPostWithBodyDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_request_params: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodPostWithBodyPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodPostWithBodyRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodPostWithBodySchedulingTypedDict]


class RestCollectMethodPostWithBody(BaseModel):
    collect_method: Annotated[
        RestCollectMethodPostWithBodyCollectMethod,
        pydantic.Field(alias="collectMethod"),
    ]

    collect_body: Annotated[Any, pydantic.Field(alias="collectBody")]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: RestCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    discovery: Optional[RestCollectMethodPostWithBodyDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodPostWithBodyPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodPostWithBodyRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodPostWithBodyScheduling],
        pydantic.Field(alias="__scheduling"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostWithBodyAuthentication(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectVerb",
                "collectRequestParams",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestCollectMethodPostRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodPostRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestCollectMethodPostRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodPostRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestCollectMethodPostRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodPostRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: (
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    discover_type: (
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestCollectMethodPostRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestCollectMethodPostDiscoveryTypedDict = TypeAliasType(
    "RestCollectMethodPostDiscoveryTypedDict",
    Union[
        RestCollectMethodPostRestDiscoveryDiscoverTypeNoneTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeListTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeJSONTypedDict,
        RestCollectMethodPostRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestCollectMethodPostDiscovery = Annotated[
    Union[
        Annotated[RestCollectMethodPostRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestCollectMethodPostRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestCollectMethodPostRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestCollectMethodPostRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestCollectMethodPostRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodPostRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodPostRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestCollectMethodPostRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestCollectMethodPostRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodPostRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestCollectMethodPostRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodPostRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestCollectMethodPostPaginationUnionTypedDict = TypeAliasType(
    "RestCollectMethodPostPaginationUnionTypedDict",
    Union[
        RestCollectMethodPostRestPaginationTypeNoneTypedDict,
        RestCollectMethodPostRestPaginationTypeResponseHeaderTypedDict,
        RestCollectMethodPostRestPaginationTypeResponseBodyTypedDict,
        RestCollectMethodPostRestPaginationTypeResponseHeaderLinkTypedDict,
        RestCollectMethodPostRestPaginationTypeRequestOffsetTypedDict,
        RestCollectMethodPostRestPaginationTypeRequestPageTypedDict,
    ],
)


RestCollectMethodPostPaginationUnion = Annotated[
    Union[
        Annotated[RestCollectMethodPostRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestCollectMethodPostRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestCollectMethodPostRestPaginationTypeResponseHeader,
            Tag("response_header"),
        ],
        Annotated[
            RestCollectMethodPostRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestCollectMethodPostRestPaginationTypeRequestOffset, Tag("request_offset")
        ],
        Annotated[
            RestCollectMethodPostRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodPostAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodPostRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestCollectMethodPostRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodPostRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodPostRetryRulesTypedDict = TypeAliasType(
    "RestCollectMethodPostRetryRulesTypedDict",
    Union[
        RestCollectMethodPostRestRetryRulesTypeNoneTypedDict,
        RestCollectMethodPostRestRetryRulesTypeStaticTypedDict,
        RestCollectMethodPostRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestCollectMethodPostRetryRules = Annotated[
    Union[
        Annotated[RestCollectMethodPostRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestCollectMethodPostRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestCollectMethodPostRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodPostStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodPostStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodPostStateTrackingTypedDict]


class RestCollectMethodPostScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodPostStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodPostTypedDict(TypedDict):
    collect_method: RestCollectMethodPostCollectMethod
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: RestCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodPostDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodPostPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodPostRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodPostSchedulingTypedDict]


class RestCollectMethodPost(BaseModel):
    collect_method: Annotated[
        RestCollectMethodPostCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: RestCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodPostDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodPostPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodPostRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodPostScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodPostAuthentication(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectVerb",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetCollectMethod(str, Enum, metaclass=utils.OpenEnumMeta):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetRestDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeNoneTypedDict(TypedDict):
    discover_type: RestCollectMethodGetRestDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""


class RestCollectMethodGetRestDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeListTypedDict(TypedDict):
    discover_type: RestCollectMethodGetRestDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""


class RestCollectMethodGetRestDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeJSONTypedDict(TypedDict):
    discover_type: RestCollectMethodGetRestDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class RestCollectMethodGetRestDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod
    discover_verb: Any
    discover_type: (
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther(BaseModel):
    discover_method: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_verb: Annotated[Any, pydantic.Field(alias="discoverVerb")]

    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    discover_body: Any
    discover_type: RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_verb: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_body: Annotated[Any, pydantic.Field(alias="discoverBody")]

    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverVerb",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    discover_type: (
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost(BaseModel):
    discover_method: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"
    # Other
    OTHER = "other"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    HTTP = "http"
    JSON = "json"
    LIST = "list"
    NONE = "none"


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict(
    TypedDict
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination(
    BaseModel
):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: (
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    )
    discover_type: (
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    )
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""
    discover_url: str
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""
    discover_request_params: NotRequired[Any]
    discover_verb: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPaginationTypedDict
    ]
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""
    enable_strict_discover_parsing: NotRequired[bool]
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""
    discover_response_format: NotRequired[Any]
    enable_discover_code: NotRequired[bool]


class RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet(BaseModel):
    discover_method: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]

    discover_type: Annotated[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_verb: Annotated[Optional[Any], pydantic.Field(alias="discoverVerb")] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None

    pagination: Optional[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetPagination
    ] = None

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array."""

    enable_strict_discover_parsing: Annotated[
        Optional[bool], pydantic.Field(alias="enableStrictDiscoverParsing")
    ] = None
    r"""Explicitly set the discover response format. When disabled, best effort parsing is used."""

    discover_response_format: Annotated[
        Optional[Any], pydantic.Field(alias="discoverResponseFormat")
    ] = None

    enable_discover_code: Annotated[
        Optional[bool], pydantic.Field(alias="enableDiscoverCode")
    ] = None

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverVerb",
                "discoverBody",
                "discoverRequestHeaders",
                "pagination",
                "discoverDataField",
                "enableStrictDiscoverParsing",
                "discoverResponseFormat",
                "enableDiscoverCode",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOtherTypedDict,
    ],
)


RestCollectMethodGetRestDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
        Annotated[
            RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPDiscoverMethodOther,
            Tag("other"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


RestCollectMethodGetDiscoveryTypedDict = TypeAliasType(
    "RestCollectMethodGetDiscoveryTypedDict",
    Union[
        RestCollectMethodGetRestDiscoveryDiscoverTypeNoneTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeListTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeJSONTypedDict,
        RestCollectMethodGetRestDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


RestCollectMethodGetDiscovery = Annotated[
    Union[
        Annotated[RestCollectMethodGetRestDiscoveryDiscoverTypeHTTP, Tag("http")],
        Annotated[RestCollectMethodGetRestDiscoveryDiscoverTypeJSON, Tag("json")],
        Annotated[RestCollectMethodGetRestDiscoveryDiscoverTypeList, Tag("list")],
        Annotated[RestCollectMethodGetRestDiscoveryDiscoverTypeNone, Tag("none")],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class RestCollectMethodGetRestPaginationTypeRequestPageTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    page_field: str
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""
    size: float
    r"""Maximum number of records to collect per page"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    page: NotRequired[float]
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""
    total_page_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of pages for the query"""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodGetRestPaginationTypeRequestPage(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    page_field: Annotated[str, pydantic.Field(alias="pageField")]
    r"""Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size_field: Annotated[str, pydantic.Field(alias="sizeField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0"""

    size: float
    r"""Maximum number of records to collect per page"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    page: Optional[float] = None
    r"""Page number from which to start request. Defaults to undefined, which will start collection from the first page."""

    total_page_field: Annotated[
        Optional[str], pydantic.Field(alias="totalPageField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of pages for the query"""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["page", "totalPageField", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestPaginationTypeRequestOffsetTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    offset_field: str
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit_field: str
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""
    limit: float
    r"""Maximum number of records to collect per request"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    zero_indexed: bool
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""
    offset: NotRequired[float]
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""
    total_record_field: NotRequired[str]
    r"""Name of the attribute in the response that contains the total number of records for the query"""


class RestCollectMethodGetRestPaginationTypeRequestOffset(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    offset_field: Annotated[str, pydantic.Field(alias="offsetField")]
    r"""Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit_field: Annotated[str, pydantic.Field(alias="limitField")]
    r"""Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0"""

    limit: float
    r"""Maximum number of records to collect per request"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    zero_indexed: Annotated[bool, pydantic.Field(alias="zeroIndexed")]
    r"""Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1."""

    offset: Optional[float] = None
    r"""Offset index from which to start request. Defaults to undefined, which will start collection from the first record."""

    total_record_field: Annotated[
        Optional[str], pydantic.Field(alias="totalRecordField")
    ] = None
    r"""Name of the attribute in the response that contains the total number of records for the query"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["offset", "totalRecordField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestPaginationTypeResponseHeaderLinkTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    next_relation_attribute: str
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    cur_relation_attribute: NotRequired[str]
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """


class RestCollectMethodGetRestPaginationTypeResponseHeaderLink(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    next_relation_attribute: Annotated[
        str, pydantic.Field(alias="nextRelationAttribute")
    ]
    r"""Relation name used in the link header that refers to the next page in the result set. Example: rel=\"next\" refers to the next page of results: <https://myHost/nextPage>; rel=\"next\" """

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    cur_relation_attribute: Annotated[
        Optional[str], pydantic.Field(alias="curRelationAttribute")
    ] = None
    r"""Relation name used in the link header that refers to the current result set. Example: rel=\"self\" refers to the current page of results: <https://myHost/curPage>; rel=\"self\" """

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["curRelationAttribute"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestPaginationTypeResponseHeaderTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""


class RestCollectMethodGetRestPaginationTypeResponseHeader(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


class RestCollectMethodGetRestPaginationTypeResponseBodyTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination
    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""
    max_pages: float
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""
    last_page_expr: NotRequired[str]
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""


class RestCollectMethodGetRestPaginationTypeResponseBody(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    attribute: List[str]
    r"""Names of attributes within the response that contain next-page information"""

    max_pages: Annotated[float, pydantic.Field(alias="maxPages")]
    r"""Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages."""

    last_page_expr: Annotated[Optional[str], pydantic.Field(alias="lastPageExpr")] = (
        None
    )
    r"""JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["lastPageExpr"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestPaginationTypeNoneTypedDict(TypedDict):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination


class RestCollectMethodGetRestPaginationTypeNone(BaseModel):
    type: PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.PaginationOptionsRestDiscoveryDiscoverTypeHTTPPagination(
                    value
                )
            except ValueError:
                return value
        return value


RestCollectMethodGetPaginationUnionTypedDict = TypeAliasType(
    "RestCollectMethodGetPaginationUnionTypedDict",
    Union[
        RestCollectMethodGetRestPaginationTypeNoneTypedDict,
        RestCollectMethodGetRestPaginationTypeResponseHeaderTypedDict,
        RestCollectMethodGetRestPaginationTypeResponseBodyTypedDict,
        RestCollectMethodGetRestPaginationTypeResponseHeaderLinkTypedDict,
        RestCollectMethodGetRestPaginationTypeRequestOffsetTypedDict,
        RestCollectMethodGetRestPaginationTypeRequestPageTypedDict,
    ],
)


RestCollectMethodGetPaginationUnion = Annotated[
    Union[
        Annotated[RestCollectMethodGetRestPaginationTypeNone, Tag("none")],
        Annotated[
            RestCollectMethodGetRestPaginationTypeResponseBody, Tag("response_body")
        ],
        Annotated[
            RestCollectMethodGetRestPaginationTypeResponseHeader, Tag("response_header")
        ],
        Annotated[
            RestCollectMethodGetRestPaginationTypeResponseHeaderLink,
            Tag("response_header_link"),
        ],
        Annotated[
            RestCollectMethodGetRestPaginationTypeRequestOffset, Tag("request_offset")
        ],
        Annotated[
            RestCollectMethodGetRestPaginationTypeRequestPage, Tag("request_page")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodGetAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"
    GOOGLE_OAUTH = "google_oauth"
    GOOGLE_OAUTH_SECRET = "google_oauthSecret"
    HMAC = "hmac"


class RestCollectMethodGetRestRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodGetRestRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]


class RestCollectMethodGetRestRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
                "multiplier",
                "maxIntervalMs",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetRestRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    max_interval_ms: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class RestCollectMethodGetRestRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    max_interval_ms: Annotated[Optional[Any], pydantic.Field(alias="maxIntervalMs")] = (
        None
    )

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "interval",
                "limit",
                "multiplier",
                "maxIntervalMs",
                "codes",
                "enableHeader",
                "retryConnectTimeout",
                "retryConnectReset",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectMethodGetRetryRulesTypedDict = TypeAliasType(
    "RestCollectMethodGetRetryRulesTypedDict",
    Union[
        RestCollectMethodGetRestRetryRulesTypeNoneTypedDict,
        RestCollectMethodGetRestRetryRulesTypeStaticTypedDict,
        RestCollectMethodGetRestRetryRulesTypeBackoffTypedDict,
    ],
)


RestCollectMethodGetRetryRules = Annotated[
    Union[
        Annotated[RestCollectMethodGetRestRetryRulesTypeNone, Tag("none")],
        Annotated[RestCollectMethodGetRestRetryRulesTypeStatic, Tag("static")],
        Annotated[RestCollectMethodGetRestRetryRulesTypeBackoff, Tag("backoff")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class RestCollectMethodGetStateTrackingTypedDict(TypedDict):
    enabled: NotRequired[bool]
    r"""Track collection progress between consecutive scheduled executions"""


class RestCollectMethodGetStateTracking(BaseModel):
    enabled: Optional[bool] = None
    r"""Track collection progress between consecutive scheduled executions"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["enabled"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetSchedulingTypedDict(TypedDict):
    state_tracking: NotRequired[RestCollectMethodGetStateTrackingTypedDict]


class RestCollectMethodGetScheduling(BaseModel):
    state_tracking: Annotated[
        Optional[RestCollectMethodGetStateTracking],
        pydantic.Field(alias="stateTracking"),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["stateTracking"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class RestCollectMethodGetTypedDict(TypedDict):
    collect_method: RestCollectMethodGetCollectMethod
    collect_url: str
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""
    authentication: RestCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[RestCollectMethodGetDiscoveryTypedDict]
    collect_verb: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[ItemsTypeRestCollectMethodGetCollectRequestParamsTypedDict]
    ]
    pagination: NotRequired[RestCollectMethodGetPaginationUnionTypedDict]
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 to disable."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable Collector event time filtering when a date range is specified"""
    decode_url: NotRequired[bool]
    r"""Decode the URL before sending requests (including pagination requests)"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    capture_headers: NotRequired[bool]
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""
    stop_on_empty_results: NotRequired[bool]
    r"""Stop pagination when the Event Breaker produces no events"""
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text"""
    retry_rules: NotRequired[RestCollectMethodGetRetryRulesTypedDict]
    scheduling: NotRequired[RestCollectMethodGetSchedulingTypedDict]


class RestCollectMethodGet(BaseModel):
    collect_method: Annotated[
        RestCollectMethodGetCollectMethod, pydantic.Field(alias="collectMethod")
    ]

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""URL (constant or JavaScript expression) to use for the Collect operation"""

    authentication: RestCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[RestCollectMethodGetDiscovery] = None

    collect_verb: Annotated[Optional[Any], pydantic.Field(alias="collectVerb")] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[ItemsTypeRestCollectMethodGetCollectRequestParams]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None

    pagination: Optional[RestCollectMethodGetPaginationUnion] = None

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout. Use 0 to disable."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = None
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = None
    r"""Disable Collector event time filtering when a date range is specified"""

    decode_url: Annotated[Optional[bool], pydantic.Field(alias="decodeUrl")] = None
    r"""Decode the URL before sending requests (including pagination requests)"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    capture_headers: Annotated[
        Optional[bool], pydantic.Field(alias="captureHeaders")
    ] = None
    r"""Enable to add response headers to the resHeaders field under the __collectible object"""

    stop_on_empty_results: Annotated[
        Optional[bool], pydantic.Field(alias="stopOnEmptyResults")
    ] = None
    r"""Stop pagination when the Event Breaker produces no events"""

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text"""

    retry_rules: Annotated[
        Optional[RestCollectMethodGetRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    scheduling: Annotated[
        Optional[RestCollectMethodGetScheduling], pydantic.Field(alias="__scheduling")
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetCollectMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.RestCollectMethodGetAuthentication(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectVerb",
                "collectBody",
                "collectRequestHeaders",
                "pagination",
                "timeout",
                "useRoundRobinDns",
                "disableTimeFilter",
                "decodeUrl",
                "rejectUnauthorized",
                "captureHeaders",
                "stopOnEmptyResults",
                "safeHeaders",
                "retryRules",
                "__scheduling",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


RestCollectorConfTypedDict = TypeAliasType(
    "RestCollectorConfTypedDict",
    Union[
        RestCollectMethodGetTypedDict,
        RestCollectMethodPostTypedDict,
        RestCollectMethodPostWithBodyTypedDict,
        RestCollectMethodOtherTypedDict,
        RestAuthenticationNoneTypedDict,
        RestAuthenticationBasicSecretTypedDict,
        RestAuthenticationHmacTypedDict,
        RestAuthenticationBasicTypedDict,
        RestAuthenticationGoogleOauthTypedDict,
        RestAuthenticationGoogleOauthSecretTypedDict,
        RestAuthenticationLoginSecretTypedDict,
        RestAuthenticationLoginTypedDict,
        RestAuthenticationOauthTypedDict,
        RestAuthenticationOauthSecretTypedDict,
    ],
)


RestCollectorConf = Annotated[
    Union[
        Annotated[RestAuthenticationNone, Tag("none")],
        Annotated[RestAuthenticationBasic, Tag("basic")],
        Annotated[RestAuthenticationBasicSecret, Tag("basicSecret")],
        Annotated[RestAuthenticationLogin, Tag("login")],
        Annotated[RestAuthenticationLoginSecret, Tag("loginSecret")],
        Annotated[RestAuthenticationOauth, Tag("oauth")],
        Annotated[RestAuthenticationOauthSecret, Tag("oauthSecret")],
        Annotated[RestAuthenticationGoogleOauth, Tag("google_oauth")],
        Annotated[RestAuthenticationGoogleOauthSecret, Tag("google_oauthSecret")],
        Annotated[RestAuthenticationHmac, Tag("hmac")],
    ],
    Discriminator(lambda m: get_discriminator(m, "authentication", "authentication")),
]
