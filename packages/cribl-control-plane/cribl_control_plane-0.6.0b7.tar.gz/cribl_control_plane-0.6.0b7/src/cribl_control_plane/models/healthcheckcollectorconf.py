"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .hiddendefaultbreakersoptionsdatabasecollectorconf import (
    HiddenDefaultBreakersOptionsDatabaseCollectorConf,
)
from .itemstypehealthcheckauthenticationloginauthrequestheaders import (
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders,
    ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict,
)
from .itemstypehealthcheckauthenticationoauthauthrequestheaders import (
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders,
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeadersTypedDict,
)
from .itemstypehealthcheckauthenticationoauthauthrequestparams import (
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams,
    ItemsTypeHealthCheckAuthenticationOauthAuthRequestParamsTypedDict,
)
from .retrytypeoptionshealthcheckcollectorconfretryrules import (
    RetryTypeOptionsHealthCheckCollectorConfRetryRules,
)
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from cribl_control_plane.utils import get_discriminator
from enum import Enum
import pydantic
from pydantic import Discriminator, Tag, field_serializer, model_serializer
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class HealthCheckAuthenticationOauthSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationOauthSecretDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthSecretDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationOauthSecretDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationOauthSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeStaticTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationOauthSecretRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthSecretRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationOauthSecretRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeNone,
            Tag("none"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeStatic,
            Tag("static"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthSecretHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationOauthSecretTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: str
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""
    text_secret: str
    r"""Select or create a text secret that contains the client secret's value."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationOauthSecretHealthCheckMethod
    r"""Health check HTTP method."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_request_params: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestParamsTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeadersTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationOauthSecretDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationOauthSecretRetryRulesTypedDict]


class HealthCheckAuthenticationOauthSecret(BaseModel):
    authentication: HealthCheckAuthenticationOauthSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        str, pydantic.Field(alias="clientSecretParamName")
    ]
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""

    text_secret: Annotated[str, pydantic.Field(alias="textSecret")]
    r"""Select or create a text secret that contains the client secret's value."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationOauthSecretHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationOauthSecretDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationOauthSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authRequestParams",
                "authRequestHeaders",
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationOauthDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationOauthDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationOauthHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationOauthCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationOauthRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationOauthRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationOauthRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckAuthenticationOauthHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationOauthTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    client_secret_param_name: str
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""
    client_secret_param_value: str
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationOauthHealthCheckMethod
    r"""Health check HTTP method."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_request_params: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestParamsTypedDict]
    ]
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""
    auth_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeadersTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationOauthDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationOauthCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationOauthRetryRulesTypedDict]


class HealthCheckAuthenticationOauth(BaseModel):
    authentication: HealthCheckAuthenticationOauthAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for the OAuth API call. This call is expected to be a POST."""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    client_secret_param_name: Annotated[
        str, pydantic.Field(alias="clientSecretParamName")
    ]
    r"""Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters."""

    client_secret_param_value: Annotated[
        str, pydantic.Field(alias="clientSecretParamValue")
    ]
    r"""Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationOauthHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_request_params: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestParams]],
        pydantic.Field(alias="authRequestParams"),
    ] = None
    r"""OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationOauthAuthRequestHeaders]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationOauthDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationOauthCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationOauthRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationOauthHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authRequestParams",
                "authRequestHeaders",
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationLoginSecretDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginSecretDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationLoginSecretDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationLoginSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeStaticTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationLoginSecretRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginSecretRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationLoginSecretRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeNone,
            Tag("none"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeStatic,
            Tag("static"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginSecretHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationLoginSecretTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationLoginSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for login API call, this call is expected to be a POST."""
    credentials_secret: str
    r"""Select or create a stored secret that references your login credentials"""
    login_body: str
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationLoginSecretHealthCheckMethod
    r"""Health check HTTP method."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. If left blank, the entire response body will be used to derive the authorization header."""
    auth_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationLoginSecretDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationLoginSecretRetryRulesTypedDict]


class HealthCheckAuthenticationLoginSecret(BaseModel):
    authentication: HealthCheckAuthenticationLoginSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call, this call is expected to be a POST."""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your login credentials"""

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationLoginSecretHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. If left blank, the entire response body will be used to derive the authorization header."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationLoginSecretDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationLoginSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authRequestHeaders",
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationLoginDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationLoginDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationLoginHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationLoginCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationLoginRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationLoginRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationLoginRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckAuthenticationLoginHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationLoginTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationLoginAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    login_url: str
    r"""URL to use for login API call. This call is expected to be a POST."""
    username: str
    r"""Login username"""
    password: str
    r"""Login password"""
    login_body: str
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""
    auth_header_expr: str
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationLoginHealthCheckMethod
    r"""Health check HTTP method."""
    token_resp_attribute: NotRequired[str]
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""
    auth_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional authentication request headers."""
    discovery: NotRequired[HealthCheckAuthenticationLoginDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationLoginCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationLoginRetryRulesTypedDict]


class HealthCheckAuthenticationLogin(BaseModel):
    authentication: HealthCheckAuthenticationLoginAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    login_url: Annotated[str, pydantic.Field(alias="loginUrl")]
    r"""URL to use for login API call. This call is expected to be a POST."""

    username: str
    r"""Login username"""

    password: str
    r"""Login password"""

    login_body: Annotated[str, pydantic.Field(alias="loginBody")]
    r"""Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message"""

    auth_header_expr: Annotated[str, pydantic.Field(alias="authHeaderExpr")]
    r"""JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationLoginHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    token_resp_attribute: Annotated[
        Optional[str], pydantic.Field(alias="tokenRespAttribute")
    ] = None
    r"""Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header."""

    auth_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="authRequestHeaders"),
    ] = None
    r"""Optional authentication request headers."""

    discovery: Optional[HealthCheckAuthenticationLoginDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationLoginCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationLoginRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationLoginHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "tokenRespAttribute",
                "authRequestHeaders",
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationBasicSecretDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicSecretDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationBasicSecretDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationBasicSecretHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicSecretCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicSecretCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeStaticTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationBasicSecretRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicSecretRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationBasicSecretRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeNone,
            Tag("none"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeStatic,
            Tag("static"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicSecretHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationBasicSecretTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    credentials_secret: str
    r"""Select or create a stored secret that references your credentials"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationBasicSecretHealthCheckMethod
    r"""Health check HTTP method."""
    discovery: NotRequired[HealthCheckAuthenticationBasicSecretDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationBasicSecretCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationBasicSecretRetryRulesTypedDict]


class HealthCheckAuthenticationBasicSecret(BaseModel):
    authentication: HealthCheckAuthenticationBasicSecretAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    credentials_secret: Annotated[str, pydantic.Field(alias="credentialsSecret")]
    r"""Select or create a stored secret that references your credentials"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationBasicSecretHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    discovery: Optional[HealthCheckAuthenticationBasicSecretDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationBasicSecretCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationBasicSecretRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicSecretHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationBasicDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationBasicDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationBasicHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationBasicCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationBasicRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationBasicRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationBasicRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckAuthenticationBasicHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationBasicTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    username: str
    r"""Basic authentication username"""
    password: str
    r"""Basic authentication password"""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationBasicHealthCheckMethod
    r"""Health check HTTP method."""
    discovery: NotRequired[HealthCheckAuthenticationBasicDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationBasicCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationBasicRetryRulesTypedDict]


class HealthCheckAuthenticationBasic(BaseModel):
    authentication: HealthCheckAuthenticationBasicAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    username: str
    r"""Basic authentication username"""

    password: str
    r"""Basic authentication password"""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationBasicHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    discovery: Optional[HealthCheckAuthenticationBasicDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationBasicCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationBasicRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationBasicHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckAuthenticationNoneDiscoveryTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneDiscoveryTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckAuthenticationNoneDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckAuthenticationNoneHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckAuthenticationNoneRetryRulesTypedDict = TypeAliasType(
    "HealthCheckAuthenticationNoneRetryRulesTypedDict",
    Union[
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckAuthenticationNoneRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckAuthenticationNoneHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckAuthenticationNoneTypedDict(TypedDict):
    authentication: HealthCheckAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    collect_method: HealthCheckAuthenticationNoneHealthCheckMethod
    r"""Health check HTTP method."""
    discovery: NotRequired[HealthCheckAuthenticationNoneDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckAuthenticationNoneCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckAuthenticationNoneRetryRulesTypedDict]


class HealthCheckAuthenticationNone(BaseModel):
    authentication: HealthCheckAuthenticationNoneAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    collect_method: Annotated[
        HealthCheckAuthenticationNoneHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    discovery: Optional[HealthCheckAuthenticationNoneDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckAuthenticationNoneCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckAuthenticationNoneRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckAuthenticationNoneHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discovery",
                "collectRequestParams",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON(
    BaseModel
):
    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckCollectMethodPostWithBodyDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostWithBodyAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoffTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStaticTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNoneTypedDict(
    TypedDict
):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckCollectMethodPostWithBodyRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeNone,
            Tag("none"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeStatic,
            Tag("static"),
        ],
        Annotated[
            HealthCheckCollectMethodPostWithBodyHealthCheckRetryRulesTypeBackoff,
            Tag("backoff"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckCollectMethodPostWithBodyTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodPostWithBodyHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_body: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodPostWithBodyDiscoveryTypedDict]
    collect_request_params: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostWithBodyCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostWithBodyRetryRulesTypedDict]


class HealthCheckCollectMethodPostWithBody(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodPostWithBodyHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodPostWithBodyAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    discovery: Optional[HealthCheckCollectMethodPostWithBodyDiscovery] = None

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostWithBodyCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostWithBodyRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyHealthCheckMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostWithBodyAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectBody",
                "discovery",
                "collectRequestParams",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckCollectMethodPostDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckCollectMethodPostDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeHTTP,
            Tag("http"),
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeJSON,
            Tag("json"),
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeList,
            Tag("list"),
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckDiscoveryDiscoverTypeNone,
            Tag("none"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckCollectMethodPostCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodPostAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodPostRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodPostRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckCollectMethodPostRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodPostHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckCollectMethodPostHealthCheckRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckCollectMethodPostTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodPostHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodPostDiscoveryTypedDict]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodPostCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodPostRetryRulesTypedDict]


class HealthCheckCollectMethodPost(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodPostHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodPostAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[HealthCheckCollectMethodPostDiscovery] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodPostCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodPostRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodPostAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Health check HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    item_list: List[str]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    item_list: Annotated[List[str], pydantic.Field(alias="itemList")]
    r"""Comma-separated list of items to return from the Discover task. Each item returned will generate a collect task, and can be referenced using `${id}` in the collect URL, headers, or parameters."""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONTypedDict(
    TypedDict
):
    discover_type: (
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType
    )
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    manual_discover_result: str
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""
    discover_data_field: NotRequired[str]
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON(BaseModel):
    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    manual_discover_result: Annotated[str, pydantic.Field(alias="manualDiscoverResult")]
    r"""Allows hard-coding the Discover result. Must be a JSON object. Works with the Discover Data field."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Within the response JSON, name of the field or array element to pull results from. Leave blank if the result is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }"""

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["discoverDataField"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_body: NotRequired[Any]
    discover_request_params: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverBody",
                "discoverRequestParams",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Discover HTTP method."""

    # GET
    GET = "get"
    # POST
    POST = "post"
    # POST with Body
    POST_WITH_BODY = "post_with_body"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    # HTTP Request
    HTTP = "http"
    # JSON Response
    JSON = "json"
    # Item List
    LIST = "list"
    # None
    NONE = "none"


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict(
    TypedDict
):
    discover_method: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod
    r"""Discover HTTP method."""
    discover_type: HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""
    discover_url: str
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""
    discover_request_params: NotRequired[Any]
    discover_body: NotRequired[Any]
    discover_request_headers: NotRequired[
        List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeadersTypedDict]
    ]
    r"""Optional discover request headers."""
    discover_data_field: NotRequired[str]
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""


class HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet(
    BaseModel
):
    discover_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod,
        pydantic.Field(alias="discoverMethod"),
    ]
    r"""Discover HTTP method."""

    discover_type: Annotated[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType,
        pydantic.Field(alias="discoverType"),
    ]
    r"""Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task."""

    discover_url: Annotated[str, pydantic.Field(alias="discoverUrl")]
    r"""Expression to derive URL to use for the Discover operation (can be a constant)."""

    discover_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="discoverRequestParams")
    ] = None

    discover_body: Annotated[Optional[Any], pydantic.Field(alias="discoverBody")] = None

    discover_request_headers: Annotated[
        Optional[List[ItemsTypeHealthCheckAuthenticationLoginAuthRequestHeaders]],
        pydantic.Field(alias="discoverRequestHeaders"),
    ] = None
    r"""Optional discover request headers."""

    discover_data_field: Annotated[
        Optional[str], pydantic.Field(alias="discoverDataField")
    ] = None
    r"""Path to field in the response object which contains discover results (e.g.: level1.name), leave blank if the result is an array."""

    @field_serializer("discover_method")
    def serialize_discover_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverMethod(
                    value
                )
            except ValueError:
                return value
        return value

    @field_serializer("discover_type")
    def serialize_discover_type(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetDiscoverType(
                    value
                )
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "discoverRequestParams",
                "discoverBody",
                "discoverRequestHeaders",
                "discoverDataField",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGetTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBodyTypedDict,
    ],
)


HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodGet,
            Tag("get"),
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPost,
            Tag("post"),
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPDiscoverMethodPostWithBody,
            Tag("post_with_body"),
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_method", "discoverMethod")),
]


HealthCheckCollectMethodGetDiscoveryTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetDiscoveryTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNoneTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeListTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSONTypedDict,
        HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTPTypedDict,
    ],
)


HealthCheckCollectMethodGetDiscovery = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeHTTP, Tag("http")
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeJSON, Tag("json")
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeList, Tag("list")
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckDiscoveryDiscoverTypeNone, Tag("none")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "discover_type", "discoverType")),
]


class HealthCheckCollectMethodGetCollectRequestHeaderTypedDict(TypedDict):
    name: str
    r"""Header Name"""
    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetCollectRequestHeader(BaseModel):
    name: str
    r"""Header Name"""

    value: str
    r"""JavaScript expression to compute the header value (can be a constant)."""


class HealthCheckCollectMethodGetAuthentication(
    str, Enum, metaclass=utils.OpenEnumMeta
):
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    NONE = "none"
    BASIC = "basic"
    BASIC_SECRET = "basicSecret"
    LOGIN = "login"
    LOGIN_SECRET = "loginSecret"
    OAUTH = "oauth"
    OAUTH_SECRET = "oauthSecret"


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoffTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStaticTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    multiplier: NotRequired[Any]


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    multiplier: Optional[Any] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "codes", "enableHeader", "multiplier"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNoneTypedDict(TypedDict):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]


class HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNone(BaseModel):
    type: RetryTypeOptionsHealthCheckCollectorConfRetryRules
    r"""The algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.RetryTypeOptionsHealthCheckCollectorConfRetryRules(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["interval", "limit", "multiplier", "codes", "enableHeader"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectMethodGetRetryRulesTypedDict = TypeAliasType(
    "HealthCheckCollectMethodGetRetryRulesTypedDict",
    Union[
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNoneTypedDict,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStaticTypedDict,
        HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoffTypedDict,
    ],
)


HealthCheckCollectMethodGetRetryRules = Annotated[
    Union[
        Annotated[
            HealthCheckCollectMethodGetHealthCheckRetryRulesTypeNone, Tag("none")
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckRetryRulesTypeStatic, Tag("static")
        ],
        Annotated[
            HealthCheckCollectMethodGetHealthCheckRetryRulesTypeBackoff, Tag("backoff")
        ],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class HealthCheckCollectMethodGetTypedDict(TypedDict):
    collect_method: HealthCheckCollectMethodGetHealthCheckMethod
    r"""Health check HTTP method."""
    collect_url: str
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""
    authentication: HealthCheckCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""
    collect_request_params: NotRequired[Any]
    discovery: NotRequired[HealthCheckCollectMethodGetDiscoveryTypedDict]
    collect_body: NotRequired[Any]
    collect_request_headers: NotRequired[
        List[HealthCheckCollectMethodGetCollectRequestHeaderTypedDict]
    ]
    r"""Optional health check request headers."""
    authenticate_collect: NotRequired[bool]
    r"""Enable to make auth health check call."""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout, use 0 to disable"""
    reject_unauthorized: NotRequired[bool]
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""
    default_breakers: NotRequired[HiddenDefaultBreakersOptionsDatabaseCollectorConf]
    safe_headers: NotRequired[List[str]]
    r"""List of headers that are safe to log in plain text."""
    retry_rules: NotRequired[HealthCheckCollectMethodGetRetryRulesTypedDict]


class HealthCheckCollectMethodGet(BaseModel):
    collect_method: Annotated[
        HealthCheckCollectMethodGetHealthCheckMethod,
        pydantic.Field(alias="collectMethod"),
    ]
    r"""Health check HTTP method."""

    collect_url: Annotated[str, pydantic.Field(alias="collectUrl")]
    r"""Expression to derive URL to use for the health check operation (can be a constant)."""

    authentication: HealthCheckCollectMethodGetAuthentication
    r"""Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers."""

    collect_request_params: Annotated[
        Optional[Any], pydantic.Field(alias="collectRequestParams")
    ] = None

    discovery: Optional[HealthCheckCollectMethodGetDiscovery] = None

    collect_body: Annotated[Optional[Any], pydantic.Field(alias="collectBody")] = None

    collect_request_headers: Annotated[
        Optional[List[HealthCheckCollectMethodGetCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional health check request headers."""

    authenticate_collect: Annotated[
        Optional[bool], pydantic.Field(alias="authenticateCollect")
    ] = None
    r"""Enable to make auth health check call."""

    timeout: Optional[float] = None
    r"""HTTP request inactivity timeout, use 0 to disable"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = None
    r"""Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates)."""

    default_breakers: Annotated[
        Optional[HiddenDefaultBreakersOptionsDatabaseCollectorConf],
        pydantic.Field(alias="defaultBreakers"),
    ] = None

    safe_headers: Annotated[
        Optional[List[str]], pydantic.Field(alias="safeHeaders")
    ] = None
    r"""List of headers that are safe to log in plain text."""

    retry_rules: Annotated[
        Optional[HealthCheckCollectMethodGetRetryRules],
        pydantic.Field(alias="retryRules"),
    ] = None

    @field_serializer("collect_method")
    def serialize_collect_method(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetHealthCheckMethod(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.HealthCheckCollectMethodGetAuthentication(value)
            except ValueError:
                return value
        return value

    @field_serializer("default_breakers")
    def serialize_default_breakers(self, value):
        if isinstance(value, str):
            try:
                return models.HiddenDefaultBreakersOptionsDatabaseCollectorConf(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "collectRequestParams",
                "discovery",
                "collectBody",
                "collectRequestHeaders",
                "authenticateCollect",
                "timeout",
                "rejectUnauthorized",
                "defaultBreakers",
                "safeHeaders",
                "retryRules",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


HealthCheckCollectorConfTypedDict = TypeAliasType(
    "HealthCheckCollectorConfTypedDict",
    Union[
        HealthCheckCollectMethodGetTypedDict,
        HealthCheckCollectMethodPostTypedDict,
        HealthCheckCollectMethodPostWithBodyTypedDict,
        HealthCheckAuthenticationNoneTypedDict,
        HealthCheckAuthenticationBasicSecretTypedDict,
        HealthCheckAuthenticationBasicTypedDict,
        HealthCheckAuthenticationLoginSecretTypedDict,
        HealthCheckAuthenticationLoginTypedDict,
        HealthCheckAuthenticationOauthTypedDict,
        HealthCheckAuthenticationOauthSecretTypedDict,
    ],
)


HealthCheckCollectorConf = Annotated[
    Union[
        Annotated[HealthCheckAuthenticationNone, Tag("none")],
        Annotated[HealthCheckAuthenticationBasic, Tag("basic")],
        Annotated[HealthCheckAuthenticationBasicSecret, Tag("basicSecret")],
        Annotated[HealthCheckAuthenticationLogin, Tag("login")],
        Annotated[HealthCheckAuthenticationLoginSecret, Tag("loginSecret")],
        Annotated[HealthCheckAuthenticationOauth, Tag("oauth")],
        Annotated[HealthCheckAuthenticationOauthSecret, Tag("oauthSecret")],
    ],
    Discriminator(lambda m: get_discriminator(m, "authentication", "authentication")),
]
