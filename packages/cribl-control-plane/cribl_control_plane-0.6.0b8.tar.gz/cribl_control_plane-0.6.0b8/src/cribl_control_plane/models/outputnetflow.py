"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane.types import BaseModel, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class OutputNetflowType(str, Enum):
    NETFLOW = "netflow"


class OutputNetflowHostTypedDict(TypedDict):
    host: str
    r"""Destination host"""
    port: float
    r"""Destination port, default is 2055"""
    template_host: NotRequired[str]
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""
    template_port: NotRequired[str]
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""


class OutputNetflowHost(BaseModel):
    host: str
    r"""Destination host"""

    port: float
    r"""Destination port, default is 2055"""

    template_host: Annotated[Optional[str], pydantic.Field(alias="__template_host")] = (
        None
    )
    r"""Binds 'host' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'host' at runtime."""

    template_port: Annotated[Optional[str], pydantic.Field(alias="__template_port")] = (
        None
    )
    r"""Binds 'port' to a variable for dynamic value resolution. Set to variable ID (pack-scoped) or 'cribl.'/'edge.' prefixed ID (group-scoped). Variable value overrides 'port' at runtime."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["__template_host", "__template_port"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class OutputNetflowTypedDict(TypedDict):
    type: OutputNetflowType
    hosts: List[OutputNetflowHostTypedDict]
    r"""One or more NetFlow Destinations to forward events to"""
    id: NotRequired[str]
    r"""Unique ID for this output"""
    pipeline: NotRequired[str]
    r"""Pipeline to process data before sending out to this output"""
    system_fields: NotRequired[List[str]]
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""
    environment: NotRequired[str]
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""
    streamtags: NotRequired[List[str]]
    r"""Tags for filtering and grouping in @{product}"""
    dns_resolve_period_sec: NotRequired[float]
    r"""How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup."""
    enable_ip_spoofing: NotRequired[bool]
    r"""Send NetFlow traffic using the original event's Source IP and port. To enable this, you must install the external `udp-sender` helper binary at `/usr/bin/udp-sender` on all Worker Nodes and grant it the `CAP_NET_RAW` capability."""
    description: NotRequired[str]
    max_record_size: NotRequired[float]
    r"""MTU in bytes. The actual maximum NetFlow payload size will be MTU minus IP and UDP headers (28 bytes for IPv4, 48 bytes for IPv6). For example, with the default MTU of 1500, the max payload is 1472 bytes for IPv4. Payloads exceeding this limit will be dropped."""


class OutputNetflow(BaseModel):
    type: OutputNetflowType

    hosts: List[OutputNetflowHost]
    r"""One or more NetFlow Destinations to forward events to"""

    id: Optional[str] = None
    r"""Unique ID for this output"""

    pipeline: Optional[str] = None
    r"""Pipeline to process data before sending out to this output"""

    system_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="systemFields")
    ] = None
    r"""Fields to automatically add to events, such as cribl_pipe. Supports wildcards."""

    environment: Optional[str] = None
    r"""Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere."""

    streamtags: Optional[List[str]] = None
    r"""Tags for filtering and grouping in @{product}"""

    dns_resolve_period_sec: Annotated[
        Optional[float], pydantic.Field(alias="dnsResolvePeriodSec")
    ] = None
    r"""How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup."""

    enable_ip_spoofing: Annotated[
        Optional[bool], pydantic.Field(alias="enableIpSpoofing")
    ] = None
    r"""Send NetFlow traffic using the original event's Source IP and port. To enable this, you must install the external `udp-sender` helper binary at `/usr/bin/udp-sender` on all Worker Nodes and grant it the `CAP_NET_RAW` capability."""

    description: Optional[str] = None

    max_record_size: Annotated[
        Optional[float], pydantic.Field(alias="maxRecordSize")
    ] = None
    r"""MTU in bytes. The actual maximum NetFlow payload size will be MTU minus IP and UDP headers (28 bytes for IPv4, 48 bytes for IPv6). For example, with the default MTU of 1500, the max payload is 1472 bytes for IPv4. Payloads exceeding this limit will be dropped."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "id",
                "pipeline",
                "systemFields",
                "environment",
                "streamtags",
                "dnsResolvePeriodSec",
                "enableIpSpoofing",
                "description",
                "maxRecordSize",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
